"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@reduxjs";
exports.ids = ["vendor-chunks/@reduxjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReducerType: () => (/* binding */ ReducerType),\n/* harmony export */   SHOULD_AUTOBATCH: () => (/* binding */ SHOULD_AUTOBATCH),\n/* harmony export */   TaskAbortError: () => (/* binding */ TaskAbortError),\n/* harmony export */   Tuple: () => (/* binding */ Tuple),\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes),\n/* harmony export */   addListener: () => (/* binding */ addListener),\n/* harmony export */   applyMiddleware: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware),\n/* harmony export */   asyncThunkCreator: () => (/* binding */ asyncThunkCreator),\n/* harmony export */   autoBatchEnhancer: () => (/* binding */ autoBatchEnhancer),\n/* harmony export */   bindActionCreators: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators),\n/* harmony export */   buildCreateSlice: () => (/* binding */ buildCreateSlice),\n/* harmony export */   clearAllListeners: () => (/* binding */ clearAllListeners),\n/* harmony export */   combineReducers: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers),\n/* harmony export */   combineSlices: () => (/* binding */ combineSlices),\n/* harmony export */   compose: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose),\n/* harmony export */   configureStore: () => (/* binding */ configureStore),\n/* harmony export */   createAction: () => (/* binding */ createAction),\n/* harmony export */   createActionCreatorInvariantMiddleware: () => (/* binding */ createActionCreatorInvariantMiddleware),\n/* harmony export */   createAsyncThunk: () => (/* binding */ createAsyncThunk),\n/* harmony export */   createDraftSafeSelector: () => (/* binding */ createDraftSafeSelector),\n/* harmony export */   createDraftSafeSelectorCreator: () => (/* binding */ createDraftSafeSelectorCreator),\n/* harmony export */   createDynamicMiddleware: () => (/* binding */ createDynamicMiddleware),\n/* harmony export */   createEntityAdapter: () => (/* binding */ createEntityAdapter),\n/* harmony export */   createImmutableStateInvariantMiddleware: () => (/* binding */ createImmutableStateInvariantMiddleware),\n/* harmony export */   createListenerMiddleware: () => (/* binding */ createListenerMiddleware),\n/* harmony export */   createNextState: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.produce),\n/* harmony export */   createReducer: () => (/* binding */ createReducer),\n/* harmony export */   createSelector: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector),\n/* harmony export */   createSelectorCreator: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator),\n/* harmony export */   createSerializableStateInvariantMiddleware: () => (/* binding */ createSerializableStateInvariantMiddleware),\n/* harmony export */   createSlice: () => (/* binding */ createSlice),\n/* harmony export */   createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore),\n/* harmony export */   current: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current),\n/* harmony export */   findNonSerializableValue: () => (/* binding */ findNonSerializableValue),\n/* harmony export */   formatProdErrorMessage: () => (/* binding */ formatProdErrorMessage),\n/* harmony export */   freeze: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze),\n/* harmony export */   isAction: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isAction),\n/* harmony export */   isActionCreator: () => (/* binding */ isActionCreator),\n/* harmony export */   isAllOf: () => (/* binding */ isAllOf),\n/* harmony export */   isAnyOf: () => (/* binding */ isAnyOf),\n/* harmony export */   isAsyncThunkAction: () => (/* binding */ isAsyncThunkAction),\n/* harmony export */   isDraft: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft),\n/* harmony export */   isFluxStandardAction: () => (/* binding */ isFSA),\n/* harmony export */   isFulfilled: () => (/* binding */ isFulfilled),\n/* harmony export */   isImmutableDefault: () => (/* binding */ isImmutableDefault),\n/* harmony export */   isPending: () => (/* binding */ isPending),\n/* harmony export */   isPlain: () => (/* binding */ isPlain),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject),\n/* harmony export */   isRejected: () => (/* binding */ isRejected),\n/* harmony export */   isRejectedWithValue: () => (/* binding */ isRejectedWithValue),\n/* harmony export */   legacy_createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore),\n/* harmony export */   lruMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.lruMemoize),\n/* harmony export */   miniSerializeError: () => (/* binding */ miniSerializeError),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   original: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original),\n/* harmony export */   prepareAutoBatched: () => (/* binding */ prepareAutoBatched),\n/* harmony export */   removeListener: () => (/* binding */ removeListener),\n/* harmony export */   unwrapResult: () => (/* binding */ unwrapResult),\n/* harmony export */   weakMapMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize)\n/* harmony export */ });\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/@reduxjs/toolkit/node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(ssr)/./node_modules/redux-thunk/dist/redux-thunk.mjs\");\n// src/index.ts\n\n\n// src/immerImports.ts\n\n// src/index.ts\n\n// src/reselectImports.ts\n\n// src/createDraftSafeSelector.ts\nvar createDraftSafeSelectorCreator = (...args)=>{\n    const createSelector2 = (0,reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator)(...args);\n    const createDraftSafeSelector2 = Object.assign((...args2)=>{\n        const selector = createSelector2(...args2);\n        const wrappedSelector = (value, ...rest)=>selector((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value, ...rest);\n        Object.assign(wrappedSelector, selector);\n        return wrappedSelector;\n    }, {\n        withTypes: ()=>createDraftSafeSelector2\n    });\n    return createDraftSafeSelector2;\n};\nvar createDraftSafeSelector = /* @__PURE__ */ createDraftSafeSelectorCreator(reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize);\n// src/reduxImports.ts\n\n// src/devtoolsExtension.ts\nvar composeWithDevTools =  false ? 0 : function() {\n    if (arguments.length === 0) return void 0;\n    if (typeof arguments[0] === \"object\") return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\n};\nvar devToolsEnhancer =  false ? 0 : function() {\n    return function(noop3) {\n        return noop3;\n    };\n};\n// src/getDefaultMiddleware.ts\n\n// src/tsHelpers.ts\nvar hasMatchFunction = (v)=>{\n    return v && typeof v.match === \"function\";\n};\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n    function actionCreator(...args) {\n        if (prepareAction) {\n            let prepared = prepareAction(...args);\n            if (!prepared) {\n                throw new Error( false ? 0 : \"prepareAction did not return an object\");\n            }\n            return {\n                type,\n                payload: prepared.payload,\n                ...\"meta\" in prepared && {\n                    meta: prepared.meta\n                },\n                ...\"error\" in prepared && {\n                    error: prepared.error\n                }\n            };\n        }\n        return {\n            type,\n            payload: args[0]\n        };\n    }\n    actionCreator.toString = ()=>`${type}`;\n    actionCreator.type = type;\n    actionCreator.match = (action)=>(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && action.type === type;\n    return actionCreator;\n}\nfunction isActionCreator(action) {\n    return typeof action === \"function\" && \"type\" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it\n    hasMatchFunction(action);\n}\nfunction isFSA(action) {\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n    return [\n        \"type\",\n        \"payload\",\n        \"error\",\n        \"meta\"\n    ].indexOf(key) > -1;\n}\n// src/actionCreatorInvariantMiddleware.ts\nfunction getMessage(type) {\n    const splitType = type ? `${type}`.split(\"/\") : [];\n    const actionName = splitType[splitType.length - 1] || \"actionCreator\";\n    return `Detected an action creator with type \"${type || \"unknown\"}\" being dispatched. \nMake sure you're calling the action creator before dispatching, i.e. \\`dispatch(${actionName}())\\` instead of \\`dispatch(${actionName})\\`. This is necessary even if the action has no payload.`;\n}\nfunction createActionCreatorInvariantMiddleware(options = {}) {\n    if (false) {}\n    const { isActionCreator: isActionCreator2 = isActionCreator } = options;\n    return ()=>(next)=>(action)=>{\n                if (isActionCreator2(action)) {\n                    console.warn(getMessage(action.type));\n                }\n                return next(action);\n            };\n}\n// src/utils.ts\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n    let elapsed = 0;\n    return {\n        measureTime (fn) {\n            const started = Date.now();\n            try {\n                return fn();\n            } finally{\n                const finished = Date.now();\n                elapsed += finished - started;\n            }\n        },\n        warnIfExceeded () {\n            if (elapsed > maxDelay) {\n                console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.`);\n            }\n        }\n    };\n}\nvar Tuple = class _Tuple extends Array {\n    constructor(...items){\n        super(...items);\n        Object.setPrototypeOf(this, _Tuple.prototype);\n    }\n    static get [Symbol.species]() {\n        return _Tuple;\n    }\n    concat(...arr) {\n        return super.concat.apply(this, arr);\n    }\n    prepend(...arr) {\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new _Tuple(...arr[0].concat(this));\n        }\n        return new _Tuple(...arr.concat(this));\n    }\n};\nfunction freezeDraftable(val) {\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(val) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(val, ()=>{}) : val;\n}\nfunction getOrInsertComputed(map, key, compute) {\n    if (map.has(key)) return map.get(key);\n    return map.set(key, compute(key)).get(key);\n}\n// src/immutableStateInvariantMiddleware.ts\nfunction isImmutableDefault(value) {\n    return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignoredPaths, obj) {\n    const trackedProperties = trackProperties(isImmutable, ignoredPaths, obj);\n    return {\n        detectMutations () {\n            return detectMutations(isImmutable, ignoredPaths, trackedProperties, obj);\n        }\n    };\n}\nfunction trackProperties(isImmutable, ignoredPaths = [], obj, path = \"\", checkedObjects = /* @__PURE__ */ new Set()) {\n    const tracked = {\n        value: obj\n    };\n    if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n        checkedObjects.add(obj);\n        tracked.children = {};\n        const hasIgnoredPaths = ignoredPaths.length > 0;\n        for(const key in obj){\n            const nestedPath = path ? path + \".\" + key : key;\n            if (hasIgnoredPaths) {\n                const hasMatches = ignoredPaths.some((ignored)=>{\n                    if (ignored instanceof RegExp) {\n                        return ignored.test(nestedPath);\n                    }\n                    return nestedPath === ignored;\n                });\n                if (hasMatches) {\n                    continue;\n                }\n            }\n            tracked.children[key] = trackProperties(isImmutable, ignoredPaths, obj[key], nestedPath);\n        }\n    }\n    return tracked;\n}\nfunction detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = \"\") {\n    const prevObj = trackedProperty ? trackedProperty.value : void 0;\n    const sameRef = prevObj === obj;\n    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n        return {\n            wasMutated: true,\n            path\n        };\n    }\n    if (isImmutable(prevObj) || isImmutable(obj)) {\n        return {\n            wasMutated: false\n        };\n    }\n    const keysToDetect = {};\n    for(let key in trackedProperty.children){\n        keysToDetect[key] = true;\n    }\n    for(let key in obj){\n        keysToDetect[key] = true;\n    }\n    const hasIgnoredPaths = ignoredPaths.length > 0;\n    for(let key in keysToDetect){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            const hasMatches = ignoredPaths.some((ignored)=>{\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                continue;\n            }\n        }\n        const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n        if (result.wasMutated) {\n            return result;\n        }\n    }\n    return {\n        wasMutated: false\n    };\n}\nfunction createImmutableStateInvariantMiddleware(options = {}) {\n    if (false) {} else {\n        let stringify2 = function(obj, serializer, indent, decycler) {\n            return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);\n        }, getSerialize2 = function(serializer, decycler) {\n            let stack = [], keys = [];\n            if (!decycler) decycler = function(_, value) {\n                if (stack[0] === value) return \"[Circular ~]\";\n                return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n            };\n            return function(key, value) {\n                if (stack.length > 0) {\n                    var thisPos = stack.indexOf(this);\n                    ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n                    ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n                    if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n                } else stack.push(value);\n                return serializer == null ? value : serializer.call(this, key, value);\n            };\n        };\n        var stringify = stringify2, getSerialize = getSerialize2;\n        let { isImmutable = isImmutableDefault, ignoredPaths, warnAfter = 32 } = options;\n        const track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n        return ({ getState })=>{\n            let state = getState();\n            let tracker = track(state);\n            let result;\n            return (next)=>(action)=>{\n                    const measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n                    measureUtils.measureTime(()=>{\n                        state = getState();\n                        result = tracker.detectMutations();\n                        tracker = track(state);\n                        if (result.wasMutated) {\n                            throw new Error( false ? 0 : `A state mutation was detected between dispatches, in the path '${result.path || \"\"}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n                        }\n                    });\n                    const dispatchedAction = next(action);\n                    measureUtils.measureTime(()=>{\n                        state = getState();\n                        result = tracker.detectMutations();\n                        tracker = track(state);\n                        if (result.wasMutated) {\n                            throw new Error( false ? 0 : `A state mutation was detected inside a dispatch, in the path: ${result.path || \"\"}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n                        }\n                    });\n                    measureUtils.warnIfExceeded();\n                    return dispatchedAction;\n                };\n        };\n    }\n}\n// src/serializableStateInvariantMiddleware.ts\nfunction isPlain(val) {\n    const type = typeof val;\n    return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || (0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(val);\n}\nfunction findNonSerializableValue(value, path = \"\", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {\n    let foundNestedSerializable;\n    if (!isSerializable(value)) {\n        return {\n            keyPath: path || \"<root>\",\n            value\n        };\n    }\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    if (cache?.has(value)) return false;\n    const entries = getEntries != null ? getEntries(value) : Object.entries(value);\n    const hasIgnoredPaths = ignoredPaths.length > 0;\n    for (const [key, nestedValue] of entries){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            const hasMatches = ignoredPaths.some((ignored)=>{\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                continue;\n            }\n        }\n        if (!isSerializable(nestedValue)) {\n            return {\n                keyPath: nestedPath,\n                value: nestedValue\n            };\n        }\n        if (typeof nestedValue === \"object\") {\n            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n            if (foundNestedSerializable) {\n                return foundNestedSerializable;\n            }\n        }\n    }\n    if (cache && isNestedFrozen(value)) cache.add(value);\n    return false;\n}\nfunction isNestedFrozen(value) {\n    if (!Object.isFrozen(value)) return false;\n    for (const nestedValue of Object.values(value)){\n        if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n        if (!isNestedFrozen(nestedValue)) return false;\n    }\n    return true;\n}\nfunction createSerializableStateInvariantMiddleware(options = {}) {\n    if (false) {} else {\n        const { isSerializable = isPlain, getEntries, ignoredActions = [], ignoredActionPaths = [\n            \"meta.arg\",\n            \"meta.baseQueryMeta\"\n        ], ignoredPaths = [], warnAfter = 32, ignoreState = false, ignoreActions = false, disableCache = false } = options;\n        const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;\n        return (storeAPI)=>(next)=>(action)=>{\n                    if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n                        return next(action);\n                    }\n                    const result = next(action);\n                    const measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n                    if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n                        measureUtils.measureTime(()=>{\n                            const foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n                            if (foundActionNonSerializableValue) {\n                                const { keyPath, value } = foundActionNonSerializableValue;\n                                console.error(`A non-serializable value was detected in an action, in the path: \\`${keyPath}\\`. Value:`, value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n                            }\n                        });\n                    }\n                    if (!ignoreState) {\n                        measureUtils.measureTime(()=>{\n                            const state = storeAPI.getState();\n                            const foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n                            if (foundStateNonSerializableValue) {\n                                const { keyPath, value } = foundStateNonSerializableValue;\n                                console.error(`A non-serializable value was detected in the state, in the path: \\`${keyPath}\\`. Value:`, value, `\nTake a look at the reducer(s) handling this action type: ${action.type}.\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);\n                            }\n                        });\n                        measureUtils.warnIfExceeded();\n                    }\n                    return result;\n                };\n    }\n}\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n    return typeof x === \"boolean\";\n}\nvar buildGetDefaultMiddleware = ()=>function getDefaultMiddleware(options) {\n        const { thunk = true, immutableCheck = true, serializableCheck = true, actionCreatorCheck = true } = options ?? {};\n        let middlewareArray = new Tuple();\n        if (thunk) {\n            if (isBoolean(thunk)) {\n                middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__.thunk);\n            } else {\n                middlewareArray.push((0,redux_thunk__WEBPACK_IMPORTED_MODULE_3__.withExtraArgument)(thunk.extraArgument));\n            }\n        }\n        if (true) {\n            if (immutableCheck) {\n                let immutableOptions = {};\n                if (!isBoolean(immutableCheck)) {\n                    immutableOptions = immutableCheck;\n                }\n                middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n            }\n            if (serializableCheck) {\n                let serializableOptions = {};\n                if (!isBoolean(serializableCheck)) {\n                    serializableOptions = serializableCheck;\n                }\n                middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n            }\n            if (actionCreatorCheck) {\n                let actionCreatorOptions = {};\n                if (!isBoolean(actionCreatorCheck)) {\n                    actionCreatorOptions = actionCreatorCheck;\n                }\n                middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n            }\n        }\n        return middlewareArray;\n    };\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = ()=>(payload)=>({\n            payload,\n            meta: {\n                [SHOULD_AUTOBATCH]: true\n            }\n        });\nvar createQueueWithTimer = (timeout)=>{\n    return (notify)=>{\n        setTimeout(notify, timeout);\n    };\n};\nvar autoBatchEnhancer = (options = {\n    type: \"raf\"\n})=>(next)=>(...args)=>{\n            const store = next(...args);\n            let notifying = true;\n            let shouldNotifyAtEndOfTick = false;\n            let notificationQueued = false;\n            const listeners = /* @__PURE__ */ new Set();\n            const queueCallback = options.type === \"tick\" ? queueMicrotask : options.type === \"raf\" ? // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.\n             false ? 0 : createQueueWithTimer(10) : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n            const notifyListeners = ()=>{\n                notificationQueued = false;\n                if (shouldNotifyAtEndOfTick) {\n                    shouldNotifyAtEndOfTick = false;\n                    listeners.forEach((l)=>l());\n                }\n            };\n            return Object.assign({}, store, {\n                // Override the base `store.subscribe` method to keep original listeners\n                // from running if we're delaying notifications\n                subscribe (listener2) {\n                    const wrappedListener = ()=>notifying && listener2();\n                    const unsubscribe = store.subscribe(wrappedListener);\n                    listeners.add(listener2);\n                    return ()=>{\n                        unsubscribe();\n                        listeners.delete(listener2);\n                    };\n                },\n                // Override the base `store.dispatch` method so that we can check actions\n                // for the `shouldAutoBatch` flag and determine if batching is active\n                dispatch (action) {\n                    try {\n                        notifying = !action?.meta?.[SHOULD_AUTOBATCH];\n                        shouldNotifyAtEndOfTick = !notifying;\n                        if (shouldNotifyAtEndOfTick) {\n                            if (!notificationQueued) {\n                                notificationQueued = true;\n                                queueCallback(notifyListeners);\n                            }\n                        }\n                        return store.dispatch(action);\n                    } finally{\n                        notifying = true;\n                    }\n                }\n            });\n        };\n// src/getDefaultEnhancers.ts\nvar buildGetDefaultEnhancers = (middlewareEnhancer)=>function getDefaultEnhancers(options) {\n        const { autoBatch = true } = options ?? {};\n        let enhancerArray = new Tuple(middlewareEnhancer);\n        if (autoBatch) {\n            enhancerArray.push(autoBatchEnhancer(typeof autoBatch === \"object\" ? autoBatch : void 0));\n        }\n        return enhancerArray;\n    };\n// src/configureStore.ts\nfunction configureStore(options) {\n    const getDefaultMiddleware = buildGetDefaultMiddleware();\n    const { reducer = void 0, middleware, devTools = true, duplicateMiddlewareCheck = true, preloadedState = void 0, enhancers = void 0 } = options || {};\n    let rootReducer;\n    if (typeof reducer === \"function\") {\n        rootReducer = reducer;\n    } else if ((0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(reducer)) {\n        rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\n    } else {\n        throw new Error( false ? 0 : \"`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers\");\n    }\n    if ( true && middleware && typeof middleware !== \"function\") {\n        throw new Error( false ? 0 : \"`middleware` field must be a callback\");\n    }\n    let finalMiddleware;\n    if (typeof middleware === \"function\") {\n        finalMiddleware = middleware(getDefaultMiddleware);\n        if ( true && !Array.isArray(finalMiddleware)) {\n            throw new Error( false ? 0 : \"when using a middleware builder function, an array of middleware must be returned\");\n        }\n    } else {\n        finalMiddleware = getDefaultMiddleware();\n    }\n    if ( true && finalMiddleware.some((item)=>typeof item !== \"function\")) {\n        throw new Error( false ? 0 : \"each middleware provided to configureStore must be a function\");\n    }\n    if ( true && duplicateMiddlewareCheck) {\n        let middlewareReferences = /* @__PURE__ */ new Set();\n        finalMiddleware.forEach((middleware2)=>{\n            if (middlewareReferences.has(middleware2)) {\n                throw new Error( false ? 0 : \"Duplicate middleware references found when creating the store. Ensure that each middleware is only included once.\");\n            }\n            middlewareReferences.add(middleware2);\n        });\n    }\n    let finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    if (devTools) {\n        finalCompose = composeWithDevTools({\n            // Enable capture of stack traces for dispatched Redux actions\n            trace: \"development\" !== \"production\",\n            ...typeof devTools === \"object\" && devTools\n        });\n    }\n    const middlewareEnhancer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware)(...finalMiddleware);\n    const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);\n    if ( true && enhancers && typeof enhancers !== \"function\") {\n        throw new Error( false ? 0 : \"`enhancers` field must be a callback\");\n    }\n    let storeEnhancers = typeof enhancers === \"function\" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();\n    if ( true && !Array.isArray(storeEnhancers)) {\n        throw new Error( false ? 0 : \"`enhancers` callback must return an array\");\n    }\n    if ( true && storeEnhancers.some((item)=>typeof item !== \"function\")) {\n        throw new Error( false ? 0 : \"each enhancer provided to configureStore must be a function\");\n    }\n    if ( true && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {\n        console.error(\"middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`\");\n    }\n    const composedEnhancer = finalCompose(...storeEnhancers);\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n    const actionsMap = {};\n    const actionMatchers = [];\n    let defaultCaseReducer;\n    const builder = {\n        addCase (typeOrActionCreator, reducer) {\n            if (true) {\n                if (actionMatchers.length > 0) {\n                    throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n                }\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n            if (!type) {\n                throw new Error( false ? 0 : \"`builder.addCase` cannot be called with an empty action type\");\n            }\n            if (type in actionsMap) {\n                throw new Error( false ? 0 : `\\`builder.addCase\\` cannot be called with two reducers for the same action type '${type}'`);\n            }\n            actionsMap[type] = reducer;\n            return builder;\n        },\n        addAsyncThunk (asyncThunk, reducers) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addAsyncThunk` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            if (reducers.pending) actionsMap[asyncThunk.pending.type] = reducers.pending;\n            if (reducers.rejected) actionsMap[asyncThunk.rejected.type] = reducers.rejected;\n            if (reducers.fulfilled) actionsMap[asyncThunk.fulfilled.type] = reducers.fulfilled;\n            if (reducers.settled) actionMatchers.push({\n                matcher: asyncThunk.settled,\n                reducer: reducers.settled\n            });\n            return builder;\n        },\n        addMatcher (matcher, reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            actionMatchers.push({\n                matcher,\n                reducer\n            });\n            return builder;\n        },\n        addDefaultCase (reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addDefaultCase` can only be called once\");\n                }\n            }\n            defaultCaseReducer = reducer;\n            return builder;\n        }\n    };\n    builderCallback(builder);\n    return [\n        actionsMap,\n        actionMatchers,\n        defaultCaseReducer\n    ];\n}\n// src/createReducer.ts\nfunction isStateFunction(x) {\n    return typeof x === \"function\";\n}\nfunction createReducer(initialState, mapOrBuilderCallback) {\n    if (true) {\n        if (typeof mapOrBuilderCallback === \"object\") {\n            throw new Error( false ? 0 : \"The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n        }\n    }\n    let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);\n    let getInitialState;\n    if (isStateFunction(initialState)) {\n        getInitialState = ()=>freezeDraftable(initialState());\n    } else {\n        const frozenInitialState = freezeDraftable(initialState);\n        getInitialState = ()=>frozenInitialState;\n    }\n    function reducer(state = getInitialState(), action) {\n        let caseReducers = [\n            actionsMap[action.type],\n            ...finalActionMatchers.filter(({ matcher })=>matcher(action)).map(({ reducer: reducer2 })=>reducer2)\n        ];\n        if (caseReducers.filter((cr)=>!!cr).length === 0) {\n            caseReducers = [\n                finalDefaultCaseReducer\n            ];\n        }\n        return caseReducers.reduce((previousState, caseReducer)=>{\n            if (caseReducer) {\n                if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\n                    const draft = previousState;\n                    const result = caseReducer(draft, action);\n                    if (result === void 0) {\n                        return previousState;\n                    }\n                    return result;\n                } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\n                    const result = caseReducer(previousState, action);\n                    if (result === void 0) {\n                        if (previousState === null) {\n                            return previousState;\n                        }\n                        throw Error(\"A case reducer on a non-draftable value must not return undefined\");\n                    }\n                    return result;\n                } else {\n                    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(previousState, (draft)=>{\n                        return caseReducer(draft, action);\n                    });\n                }\n            }\n            return previousState;\n        }, state);\n    }\n    reducer.getInitialState = getInitialState;\n    return reducer;\n}\n// src/matchers.ts\nvar matches = (matcher, action)=>{\n    if (hasMatchFunction(matcher)) {\n        return matcher.match(action);\n    } else {\n        return matcher(action);\n    }\n};\nfunction isAnyOf(...matchers) {\n    return (action)=>{\n        return matchers.some((matcher)=>matches(matcher, action));\n    };\n}\nfunction isAllOf(...matchers) {\n    return (action)=>{\n        return matchers.every((matcher)=>matches(matcher, action));\n    };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n    if (!action || !action.meta) return false;\n    const hasValidRequestId = typeof action.meta.requestId === \"string\";\n    const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n    return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n    return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"pending\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isPending()(asyncThunks[0]);\n    }\n    return isAnyOf(...asyncThunks.map((asyncThunk)=>asyncThunk.pending));\n}\nfunction isRejected(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"rejected\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejected()(asyncThunks[0]);\n    }\n    return isAnyOf(...asyncThunks.map((asyncThunk)=>asyncThunk.rejected));\n}\nfunction isRejectedWithValue(...asyncThunks) {\n    const hasFlag = (action)=>{\n        return action && action.meta && action.meta.rejectedWithValue;\n    };\n    if (asyncThunks.length === 0) {\n        return isAllOf(isRejected(...asyncThunks), hasFlag);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejectedWithValue()(asyncThunks[0]);\n    }\n    return isAllOf(isRejected(...asyncThunks), hasFlag);\n}\nfunction isFulfilled(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"fulfilled\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isFulfilled()(asyncThunks[0]);\n    }\n    return isAnyOf(...asyncThunks.map((asyncThunk)=>asyncThunk.fulfilled));\n}\nfunction isAsyncThunkAction(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"pending\",\n                \"fulfilled\",\n                \"rejected\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isAsyncThunkAction()(asyncThunks[0]);\n    }\n    return isAnyOf(...asyncThunks.flatMap((asyncThunk)=>[\n            asyncThunk.pending,\n            asyncThunk.rejected,\n            asyncThunk.fulfilled\n        ]));\n}\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = (size = 21)=>{\n    let id = \"\";\n    let i = size;\n    while(i--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\n// src/createAsyncThunk.ts\nvar commonProperties = [\n    \"name\",\n    \"message\",\n    \"stack\",\n    \"code\"\n];\nvar RejectWithValue = class {\n    constructor(payload, meta){\n        this.payload = payload;\n        this.meta = meta;\n    }\n};\nvar FulfillWithMeta = class {\n    constructor(payload, meta){\n        this.payload = payload;\n        this.meta = meta;\n    }\n};\nvar miniSerializeError = (value)=>{\n    if (typeof value === \"object\" && value !== null) {\n        const simpleError = {};\n        for (const property of commonProperties){\n            if (typeof value[property] === \"string\") {\n                simpleError[property] = value[property];\n            }\n        }\n        return simpleError;\n    }\n    return {\n        message: String(value)\n    };\n};\nvar externalAbortMessage = \"External signal was aborted\";\nvar createAsyncThunk = /* @__PURE__ */ (()=>{\n    function createAsyncThunk2(typePrefix, payloadCreator, options) {\n        const fulfilled = createAction(typePrefix + \"/fulfilled\", (payload, requestId, arg, meta)=>({\n                payload,\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    requestStatus: \"fulfilled\"\n                }\n            }));\n        const pending = createAction(typePrefix + \"/pending\", (requestId, arg, meta)=>({\n                payload: void 0,\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    requestStatus: \"pending\"\n                }\n            }));\n        const rejected = createAction(typePrefix + \"/rejected\", (error, requestId, arg, payload, meta)=>({\n                payload,\n                error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    rejectedWithValue: !!payload,\n                    requestStatus: \"rejected\",\n                    aborted: error?.name === \"AbortError\",\n                    condition: error?.name === \"ConditionError\"\n                }\n            }));\n        function actionCreator(arg, { signal } = {}) {\n            return (dispatch, getState, extra)=>{\n                const requestId = options?.idGenerator ? options.idGenerator(arg) : nanoid();\n                const abortController = new AbortController();\n                let abortHandler;\n                let abortReason;\n                function abort(reason) {\n                    abortReason = reason;\n                    abortController.abort();\n                }\n                if (signal) {\n                    if (signal.aborted) {\n                        abort(externalAbortMessage);\n                    } else {\n                        signal.addEventListener(\"abort\", ()=>abort(externalAbortMessage), {\n                            once: true\n                        });\n                    }\n                }\n                const promise = async function() {\n                    let finalAction;\n                    try {\n                        let conditionResult = options?.condition?.(arg, {\n                            getState,\n                            extra\n                        });\n                        if (isThenable(conditionResult)) {\n                            conditionResult = await conditionResult;\n                        }\n                        if (conditionResult === false || abortController.signal.aborted) {\n                            throw {\n                                name: \"ConditionError\",\n                                message: \"Aborted due to condition callback returning false.\"\n                            };\n                        }\n                        const abortedPromise = new Promise((_, reject)=>{\n                            abortHandler = ()=>{\n                                reject({\n                                    name: \"AbortError\",\n                                    message: abortReason || \"Aborted\"\n                                });\n                            };\n                            abortController.signal.addEventListener(\"abort\", abortHandler, {\n                                once: true\n                            });\n                        });\n                        dispatch(pending(requestId, arg, options?.getPendingMeta?.({\n                            requestId,\n                            arg\n                        }, {\n                            getState,\n                            extra\n                        })));\n                        finalAction = await Promise.race([\n                            abortedPromise,\n                            Promise.resolve(payloadCreator(arg, {\n                                dispatch,\n                                getState,\n                                extra,\n                                requestId,\n                                signal: abortController.signal,\n                                abort,\n                                rejectWithValue: (value, meta)=>{\n                                    return new RejectWithValue(value, meta);\n                                },\n                                fulfillWithValue: (value, meta)=>{\n                                    return new FulfillWithMeta(value, meta);\n                                }\n                            })).then((result)=>{\n                                if (result instanceof RejectWithValue) {\n                                    throw result;\n                                }\n                                if (result instanceof FulfillWithMeta) {\n                                    return fulfilled(result.payload, requestId, arg, result.meta);\n                                }\n                                return fulfilled(result, requestId, arg);\n                            })\n                        ]);\n                    } catch (err) {\n                        finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);\n                    } finally{\n                        if (abortHandler) {\n                            abortController.signal.removeEventListener(\"abort\", abortHandler);\n                        }\n                    }\n                    const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n                    if (!skipDispatch) {\n                        dispatch(finalAction);\n                    }\n                    return finalAction;\n                }();\n                return Object.assign(promise, {\n                    abort,\n                    requestId,\n                    arg,\n                    unwrap () {\n                        return promise.then(unwrapResult);\n                    }\n                });\n            };\n        }\n        return Object.assign(actionCreator, {\n            pending,\n            rejected,\n            fulfilled,\n            settled: isAnyOf(rejected, fulfilled),\n            typePrefix\n        });\n    }\n    createAsyncThunk2.withTypes = ()=>createAsyncThunk2;\n    return createAsyncThunk2;\n})();\nfunction unwrapResult(action) {\n    if (action.meta && action.meta.rejectedWithValue) {\n        throw action.payload;\n    }\n    if (action.error) {\n        throw action.error;\n    }\n    return action.payload;\n}\nfunction isThenable(value) {\n    return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n// src/createSlice.ts\nvar asyncThunkSymbol = /* @__PURE__ */ Symbol.for(\"rtk-slice-createasyncthunk\");\nvar asyncThunkCreator = {\n    [asyncThunkSymbol]: createAsyncThunk\n};\nvar ReducerType = /* @__PURE__ */ ((ReducerType2)=>{\n    ReducerType2[\"reducer\"] = \"reducer\";\n    ReducerType2[\"reducerWithPrepare\"] = \"reducerWithPrepare\";\n    ReducerType2[\"asyncThunk\"] = \"asyncThunk\";\n    return ReducerType2;\n})(ReducerType || {});\nfunction getType(slice, actionKey) {\n    return `${slice}/${actionKey}`;\n}\nfunction buildCreateSlice({ creators } = {}) {\n    const cAT = creators?.asyncThunk?.[asyncThunkSymbol];\n    return function createSlice2(options) {\n        const { name, reducerPath = name } = options;\n        if (!name) {\n            throw new Error( false ? 0 : \"`name` is a required option for createSlice\");\n        }\n        if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n            if (options.initialState === void 0) {\n                console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n            }\n        }\n        const reducers = (typeof options.reducers === \"function\" ? options.reducers(buildReducerCreators()) : options.reducers) || {};\n        const reducerNames = Object.keys(reducers);\n        const context = {\n            sliceCaseReducersByName: {},\n            sliceCaseReducersByType: {},\n            actionCreators: {},\n            sliceMatchers: []\n        };\n        const contextMethods = {\n            addCase (typeOrActionCreator, reducer2) {\n                const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n                if (!type) {\n                    throw new Error( false ? 0 : \"`context.addCase` cannot be called with an empty action type\");\n                }\n                if (type in context.sliceCaseReducersByType) {\n                    throw new Error( false ? 0 : \"`context.addCase` cannot be called with two reducers for the same action type: \" + type);\n                }\n                context.sliceCaseReducersByType[type] = reducer2;\n                return contextMethods;\n            },\n            addMatcher (matcher, reducer2) {\n                context.sliceMatchers.push({\n                    matcher,\n                    reducer: reducer2\n                });\n                return contextMethods;\n            },\n            exposeAction (name2, actionCreator) {\n                context.actionCreators[name2] = actionCreator;\n                return contextMethods;\n            },\n            exposeCaseReducer (name2, reducer2) {\n                context.sliceCaseReducersByName[name2] = reducer2;\n                return contextMethods;\n            }\n        };\n        reducerNames.forEach((reducerName)=>{\n            const reducerDefinition = reducers[reducerName];\n            const reducerDetails = {\n                reducerName,\n                type: getType(name, reducerName),\n                createNotation: typeof options.reducers === \"function\"\n            };\n            if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {\n                handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);\n            } else {\n                handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);\n            }\n        });\n        function buildReducer() {\n            if (true) {\n                if (typeof options.extraReducers === \"object\") {\n                    throw new Error( false ? 0 : \"The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n                }\n            }\n            const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [\n                options.extraReducers\n            ];\n            const finalCaseReducers = {\n                ...extraReducers,\n                ...context.sliceCaseReducersByType\n            };\n            return createReducer(options.initialState, (builder)=>{\n                for(let key in finalCaseReducers){\n                    builder.addCase(key, finalCaseReducers[key]);\n                }\n                for (let sM of context.sliceMatchers){\n                    builder.addMatcher(sM.matcher, sM.reducer);\n                }\n                for (let m of actionMatchers){\n                    builder.addMatcher(m.matcher, m.reducer);\n                }\n                if (defaultCaseReducer) {\n                    builder.addDefaultCase(defaultCaseReducer);\n                }\n            });\n        }\n        const selectSelf = (state)=>state;\n        const injectedSelectorCache = /* @__PURE__ */ new Map();\n        const injectedStateCache = /* @__PURE__ */ new WeakMap();\n        let _reducer;\n        function reducer(state, action) {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer(state, action);\n        }\n        function getInitialState() {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer.getInitialState();\n        }\n        function makeSelectorProps(reducerPath2, injected = false) {\n            function selectSlice(state) {\n                let sliceState = state[reducerPath2];\n                if (typeof sliceState === \"undefined\") {\n                    if (injected) {\n                        sliceState = getOrInsertComputed(injectedStateCache, selectSlice, getInitialState);\n                    } else if (true) {\n                        throw new Error( false ? 0 : \"selectSlice returned undefined for an uninjected slice reducer\");\n                    }\n                }\n                return sliceState;\n            }\n            function getSelectors(selectState = selectSelf) {\n                const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, ()=>/* @__PURE__ */ new WeakMap());\n                return getOrInsertComputed(selectorCache, selectState, ()=>{\n                    const map = {};\n                    for (const [name2, selector] of Object.entries(options.selectors ?? {})){\n                        map[name2] = wrapSelector(selector, selectState, ()=>getOrInsertComputed(injectedStateCache, selectState, getInitialState), injected);\n                    }\n                    return map;\n                });\n            }\n            return {\n                reducerPath: reducerPath2,\n                getSelectors,\n                get selectors () {\n                    return getSelectors(selectSlice);\n                },\n                selectSlice\n            };\n        }\n        const slice = {\n            name,\n            reducer,\n            actions: context.actionCreators,\n            caseReducers: context.sliceCaseReducersByName,\n            getInitialState,\n            ...makeSelectorProps(reducerPath),\n            injectInto (injectable, { reducerPath: pathOpt, ...config } = {}) {\n                const newReducerPath = pathOpt ?? reducerPath;\n                injectable.inject({\n                    reducerPath: newReducerPath,\n                    reducer\n                }, config);\n                return {\n                    ...slice,\n                    ...makeSelectorProps(newReducerPath, true)\n                };\n            }\n        };\n        return slice;\n    };\n}\nfunction wrapSelector(selector, selectState, getInitialState, injected) {\n    function wrapper(rootState, ...args) {\n        let sliceState = selectState(rootState);\n        if (typeof sliceState === \"undefined\") {\n            if (injected) {\n                sliceState = getInitialState();\n            } else if (true) {\n                throw new Error( false ? 0 : \"selectState returned undefined for an uninjected slice reducer\");\n            }\n        }\n        return selector(sliceState, ...args);\n    }\n    wrapper.unwrapped = selector;\n    return wrapper;\n}\nvar createSlice = /* @__PURE__ */ buildCreateSlice();\nfunction buildReducerCreators() {\n    function asyncThunk(payloadCreator, config) {\n        return {\n            _reducerDefinitionType: \"asyncThunk\" /* asyncThunk */ ,\n            payloadCreator,\n            ...config\n        };\n    }\n    asyncThunk.withTypes = ()=>asyncThunk;\n    return {\n        reducer (caseReducer) {\n            return Object.assign({\n                // hack so the wrapping function has the same name as the original\n                // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original\n                [caseReducer.name] (...args) {\n                    return caseReducer(...args);\n                }\n            }[caseReducer.name], {\n                _reducerDefinitionType: \"reducer\" /* reducer */ \n            });\n        },\n        preparedReducer (prepare, reducer) {\n            return {\n                _reducerDefinitionType: \"reducerWithPrepare\" /* reducerWithPrepare */ ,\n                prepare,\n                reducer\n            };\n        },\n        asyncThunk\n    };\n}\nfunction handleNormalReducerDefinition({ type, reducerName, createNotation }, maybeReducerWithPrepare, context) {\n    let caseReducer;\n    let prepareCallback;\n    if (\"reducer\" in maybeReducerWithPrepare) {\n        if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {\n            throw new Error( false ? 0 : \"Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.\");\n        }\n        caseReducer = maybeReducerWithPrepare.reducer;\n        prepareCallback = maybeReducerWithPrepare.prepare;\n    } else {\n        caseReducer = maybeReducerWithPrepare;\n    }\n    context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));\n}\nfunction isAsyncThunkSliceReducerDefinition(reducerDefinition) {\n    return reducerDefinition._reducerDefinitionType === \"asyncThunk\" /* asyncThunk */ ;\n}\nfunction isCaseReducerWithPrepareDefinition(reducerDefinition) {\n    return reducerDefinition._reducerDefinitionType === \"reducerWithPrepare\" /* reducerWithPrepare */ ;\n}\nfunction handleThunkCaseReducerDefinition({ type, reducerName }, reducerDefinition, context, cAT) {\n    if (!cAT) {\n        throw new Error( false ? 0 : \"Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.\");\n    }\n    const { payloadCreator, fulfilled, pending, rejected, settled, options } = reducerDefinition;\n    const thunk = cAT(type, payloadCreator, options);\n    context.exposeAction(reducerName, thunk);\n    if (fulfilled) {\n        context.addCase(thunk.fulfilled, fulfilled);\n    }\n    if (pending) {\n        context.addCase(thunk.pending, pending);\n    }\n    if (rejected) {\n        context.addCase(thunk.rejected, rejected);\n    }\n    if (settled) {\n        context.addMatcher(thunk.settled, settled);\n    }\n    context.exposeCaseReducer(reducerName, {\n        fulfilled: fulfilled || noop,\n        pending: pending || noop,\n        rejected: rejected || noop,\n        settled: settled || noop\n    });\n}\nfunction noop() {}\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n    return {\n        ids: [],\n        entities: {}\n    };\n}\nfunction createInitialStateFactory(stateAdapter) {\n    function getInitialState(additionalState = {}, entities) {\n        const state = Object.assign(getInitialEntityState(), additionalState);\n        return entities ? stateAdapter.setAll(state, entities) : state;\n    }\n    return {\n        getInitialState\n    };\n}\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n    function getSelectors(selectState, options = {}) {\n        const { createSelector: createSelector2 = createDraftSafeSelector } = options;\n        const selectIds = (state)=>state.ids;\n        const selectEntities = (state)=>state.entities;\n        const selectAll = createSelector2(selectIds, selectEntities, (ids, entities)=>ids.map((id)=>entities[id]));\n        const selectId = (_, id)=>id;\n        const selectById = (entities, id)=>entities[id];\n        const selectTotal = createSelector2(selectIds, (ids)=>ids.length);\n        if (!selectState) {\n            return {\n                selectIds,\n                selectEntities,\n                selectAll,\n                selectTotal,\n                selectById: createSelector2(selectEntities, selectId, selectById)\n            };\n        }\n        const selectGlobalizedEntities = createSelector2(selectState, selectEntities);\n        return {\n            selectIds: createSelector2(selectState, selectIds),\n            selectEntities: selectGlobalizedEntities,\n            selectAll: createSelector2(selectState, selectAll),\n            selectTotal: createSelector2(selectState, selectTotal),\n            selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)\n        };\n    }\n    return {\n        getSelectors\n    };\n}\n// src/entities/state_adapter.ts\nvar isDraftTyped = immer__WEBPACK_IMPORTED_MODULE_2__.isDraft;\nfunction createSingleArgumentStateOperator(mutator) {\n    const operator = createStateOperator((_, state)=>mutator(state));\n    return function operation(state) {\n        return operator(state, void 0);\n    };\n}\nfunction createStateOperator(mutator) {\n    return function operation(state, arg) {\n        function isPayloadActionArgument(arg2) {\n            return isFSA(arg2);\n        }\n        const runMutator = (draft)=>{\n            if (isPayloadActionArgument(arg)) {\n                mutator(arg.payload, draft);\n            } else {\n                mutator(arg, draft);\n            }\n        };\n        if (isDraftTyped(state)) {\n            runMutator(state);\n            return state;\n        }\n        return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(state, runMutator);\n    };\n}\n// src/entities/utils.ts\nfunction selectIdValue(entity, selectId) {\n    const key = selectId(entity);\n    if ( true && key === void 0) {\n        console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n    }\n    return key;\n}\nfunction ensureEntitiesArray(entities) {\n    if (!Array.isArray(entities)) {\n        entities = Object.values(entities);\n    }\n    return entities;\n}\nfunction getCurrent(value) {\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    const existingIdsArray = getCurrent(state.ids);\n    const existingIds = new Set(existingIdsArray);\n    const added = [];\n    const addedIds = /* @__PURE__ */ new Set([]);\n    const updated = [];\n    for (const entity of newEntities){\n        const id = selectIdValue(entity, selectId);\n        if (existingIds.has(id) || addedIds.has(id)) {\n            updated.push({\n                id,\n                changes: entity\n            });\n        } else {\n            addedIds.add(id);\n            added.push(entity);\n        }\n    }\n    return [\n        added,\n        updated,\n        existingIdsArray\n    ];\n}\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n    function addOneMutably(entity, state) {\n        const key = selectIdValue(entity, selectId);\n        if (key in state.entities) {\n            return;\n        }\n        state.ids.push(key);\n        state.entities[key] = entity;\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for (const entity of newEntities){\n            addOneMutably(entity, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        const key = selectIdValue(entity, selectId);\n        if (!(key in state.entities)) {\n            state.ids.push(key);\n        }\n        ;\n        state.entities[key] = entity;\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for (const entity of newEntities){\n            setOneMutably(entity, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.ids = [];\n        state.entities = {};\n        addManyMutably(newEntities, state);\n    }\n    function removeOneMutably(key, state) {\n        return removeManyMutably([\n            key\n        ], state);\n    }\n    function removeManyMutably(keys, state) {\n        let didMutate = false;\n        keys.forEach((key)=>{\n            if (key in state.entities) {\n                delete state.entities[key];\n                didMutate = true;\n            }\n        });\n        if (didMutate) {\n            state.ids = state.ids.filter((id)=>id in state.entities);\n        }\n    }\n    function removeAllMutably(state) {\n        Object.assign(state, {\n            ids: [],\n            entities: {}\n        });\n    }\n    function takeNewKey(keys, update, state) {\n        const original3 = state.entities[update.id];\n        if (original3 === void 0) {\n            return false;\n        }\n        const updated = Object.assign({}, original3, update.changes);\n        const newKey = selectIdValue(updated, selectId);\n        const hasNewKey = newKey !== update.id;\n        if (hasNewKey) {\n            keys[update.id] = newKey;\n            delete state.entities[update.id];\n        }\n        ;\n        state.entities[newKey] = updated;\n        return hasNewKey;\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        const newKeys = {};\n        const updatesPerEntity = {};\n        updates.forEach((update)=>{\n            if (update.id in state.entities) {\n                updatesPerEntity[update.id] = {\n                    id: update.id,\n                    // Spreads ignore falsy values, so this works even if there isn't\n                    // an existing update already at this key\n                    changes: {\n                        ...updatesPerEntity[update.id]?.changes,\n                        ...update.changes\n                    }\n                };\n            }\n        });\n        updates = Object.values(updatesPerEntity);\n        const didMutateEntities = updates.length > 0;\n        if (didMutateEntities) {\n            const didMutateIds = updates.filter((update)=>takeNewKey(newKeys, update, state)).length > 0;\n            if (didMutateIds) {\n                state.ids = Object.values(state.entities).map((e)=>selectIdValue(e, selectId));\n            }\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n        addManyMutably(added, state);\n        updateManyMutably(updated, state);\n    }\n    return {\n        removeAll: createSingleArgumentStateOperator(removeAllMutably),\n        addOne: createStateOperator(addOneMutably),\n        addMany: createStateOperator(addManyMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        upsertMany: createStateOperator(upsertManyMutably),\n        removeOne: createStateOperator(removeOneMutably),\n        removeMany: createStateOperator(removeManyMutably)\n    };\n}\n// src/entities/sorted_state_adapter.ts\nfunction findInsertIndex(sortedItems, item, comparisonFunction) {\n    let lowIndex = 0;\n    let highIndex = sortedItems.length;\n    while(lowIndex < highIndex){\n        let middleIndex = lowIndex + highIndex >>> 1;\n        const currentItem = sortedItems[middleIndex];\n        const res = comparisonFunction(item, currentItem);\n        if (res >= 0) {\n            lowIndex = middleIndex + 1;\n        } else {\n            highIndex = middleIndex;\n        }\n    }\n    return lowIndex;\n}\nfunction insert(sortedItems, item, comparisonFunction) {\n    const insertAtIndex = findInsertIndex(sortedItems, item, comparisonFunction);\n    sortedItems.splice(insertAtIndex, 0, item);\n    return sortedItems;\n}\nfunction createSortedStateAdapter(selectId, comparer) {\n    const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(selectId);\n    function addOneMutably(entity, state) {\n        return addManyMutably([\n            entity\n        ], state);\n    }\n    function addManyMutably(newEntities, state, existingIds) {\n        newEntities = ensureEntitiesArray(newEntities);\n        const existingKeys = new Set(existingIds ?? getCurrent(state.ids));\n        const addedKeys = /* @__PURE__ */ new Set();\n        const models = newEntities.filter((model)=>{\n            const modelId = selectIdValue(model, selectId);\n            const notAdded = !addedKeys.has(modelId);\n            if (notAdded) addedKeys.add(modelId);\n            return !existingKeys.has(modelId) && notAdded;\n        });\n        if (models.length !== 0) {\n            mergeFunction(state, models);\n        }\n    }\n    function setOneMutably(entity, state) {\n        return setManyMutably([\n            entity\n        ], state);\n    }\n    function setManyMutably(newEntities, state) {\n        let deduplicatedEntities = {};\n        newEntities = ensureEntitiesArray(newEntities);\n        if (newEntities.length !== 0) {\n            for (const item of newEntities){\n                const entityId = selectId(item);\n                deduplicatedEntities[entityId] = item;\n                delete state.entities[entityId];\n            }\n            newEntities = ensureEntitiesArray(deduplicatedEntities);\n            mergeFunction(state, newEntities);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.entities = {};\n        state.ids = [];\n        addManyMutably(newEntities, state, []);\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        let appliedUpdates = false;\n        let replacedIds = false;\n        for (let update of updates){\n            const entity = state.entities[update.id];\n            if (!entity) {\n                continue;\n            }\n            appliedUpdates = true;\n            Object.assign(entity, update.changes);\n            const newId = selectId(entity);\n            if (update.id !== newId) {\n                replacedIds = true;\n                delete state.entities[update.id];\n                const oldIndex = state.ids.indexOf(update.id);\n                state.ids[oldIndex] = newId;\n                state.entities[newId] = entity;\n            }\n        }\n        if (appliedUpdates) {\n            mergeFunction(state, [], appliedUpdates, replacedIds);\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        const [added, updated, existingIdsArray] = splitAddedUpdatedEntities(newEntities, selectId, state);\n        if (added.length) {\n            addManyMutably(added, state, existingIdsArray);\n        }\n        if (updated.length) {\n            updateManyMutably(updated, state);\n        }\n    }\n    function areArraysEqual(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < a.length; i++){\n            if (a[i] === b[i]) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    const mergeFunction = (state, addedItems, appliedUpdates, replacedIds)=>{\n        const currentEntities = getCurrent(state.entities);\n        const currentIds = getCurrent(state.ids);\n        const stateEntities = state.entities;\n        let ids = currentIds;\n        if (replacedIds) {\n            ids = new Set(currentIds);\n        }\n        let sortedEntities = [];\n        for (const id of ids){\n            const entity = currentEntities[id];\n            if (entity) {\n                sortedEntities.push(entity);\n            }\n        }\n        const wasPreviouslyEmpty = sortedEntities.length === 0;\n        for (const item of addedItems){\n            stateEntities[selectId(item)] = item;\n            if (!wasPreviouslyEmpty) {\n                insert(sortedEntities, item, comparer);\n            }\n        }\n        if (wasPreviouslyEmpty) {\n            sortedEntities = addedItems.slice().sort(comparer);\n        } else if (appliedUpdates) {\n            sortedEntities.sort(comparer);\n        }\n        const newSortedIds = sortedEntities.map(selectId);\n        if (!areArraysEqual(currentIds, newSortedIds)) {\n            state.ids = newSortedIds;\n        }\n    };\n    return {\n        removeOne,\n        removeMany,\n        removeAll,\n        addOne: createStateOperator(addOneMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        addMany: createStateOperator(addManyMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertMany: createStateOperator(upsertManyMutably)\n    };\n}\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options = {}) {\n    const { selectId, sortComparer } = {\n        sortComparer: false,\n        selectId: (instance)=>instance.id,\n        ...options\n    };\n    const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n    const stateFactory = createInitialStateFactory(stateAdapter);\n    const selectorsFactory = createSelectorsFactory();\n    return {\n        selectId,\n        sortComparer,\n        ...stateFactory,\n        ...selectorsFactory,\n        ...stateAdapter\n    };\n}\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = `task-${cancelled}`;\nvar taskCompleted = `task-${completed}`;\nvar listenerCancelled = `${listener}-${cancelled}`;\nvar listenerCompleted = `${listener}-${completed}`;\nvar TaskAbortError = class {\n    constructor(code){\n        this.name = \"TaskAbortError\";\n        this.code = code;\n        this.message = `${task} ${cancelled} (reason: ${code})`;\n    }\n};\n// src/listenerMiddleware/utils.ts\nvar assertFunction = (func, expected)=>{\n    if (typeof func !== \"function\") {\n        throw new TypeError( false ? 0 : `${expected} is not a function`);\n    }\n};\nvar noop2 = ()=>{};\nvar catchRejection = (promise, onError = noop2)=>{\n    promise.catch(onError);\n    return promise;\n};\nvar addAbortSignalListener = (abortSignal, callback)=>{\n    abortSignal.addEventListener(\"abort\", callback, {\n        once: true\n    });\n    return ()=>abortSignal.removeEventListener(\"abort\", callback);\n};\n// src/listenerMiddleware/task.ts\nvar validateActive = (signal)=>{\n    if (signal.aborted) {\n        throw new TaskAbortError(signal.reason);\n    }\n};\nfunction raceWithSignal(signal, promise) {\n    let cleanup = noop2;\n    return new Promise((resolve, reject)=>{\n        const notifyRejection = ()=>reject(new TaskAbortError(signal.reason));\n        if (signal.aborted) {\n            notifyRejection();\n            return;\n        }\n        cleanup = addAbortSignalListener(signal, notifyRejection);\n        promise.finally(()=>cleanup()).then(resolve, reject);\n    }).finally(()=>{\n        cleanup = noop2;\n    });\n}\nvar runTask = async (task2, cleanUp)=>{\n    try {\n        await Promise.resolve();\n        const value = await task2();\n        return {\n            status: \"ok\",\n            value\n        };\n    } catch (error) {\n        return {\n            status: error instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n            error\n        };\n    } finally{\n        cleanUp?.();\n    }\n};\nvar createPause = (signal)=>{\n    return (promise)=>{\n        return catchRejection(raceWithSignal(signal, promise).then((output)=>{\n            validateActive(signal);\n            return output;\n        }));\n    };\n};\nvar createDelay = (signal)=>{\n    const pause = createPause(signal);\n    return (timeoutMs)=>{\n        return pause(new Promise((resolve)=>setTimeout(resolve, timeoutMs)));\n    };\n};\n// src/listenerMiddleware/index.ts\nvar { assign } = Object;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = (parentAbortSignal, parentBlockingPromises)=>{\n    const linkControllers = (controller)=>addAbortSignalListener(parentAbortSignal, ()=>controller.abort(parentAbortSignal.reason));\n    return (taskExecutor, opts)=>{\n        assertFunction(taskExecutor, \"taskExecutor\");\n        const childAbortController = new AbortController();\n        linkControllers(childAbortController);\n        const result = runTask(async ()=>{\n            validateActive(parentAbortSignal);\n            validateActive(childAbortController.signal);\n            const result2 = await taskExecutor({\n                pause: createPause(childAbortController.signal),\n                delay: createDelay(childAbortController.signal),\n                signal: childAbortController.signal\n            });\n            validateActive(childAbortController.signal);\n            return result2;\n        }, ()=>childAbortController.abort(taskCompleted));\n        if (opts?.autoJoin) {\n            parentBlockingPromises.push(result.catch(noop2));\n        }\n        return {\n            result: createPause(parentAbortSignal)(result),\n            cancel () {\n                childAbortController.abort(taskCancelled);\n            }\n        };\n    };\n};\nvar createTakePattern = (startListening, signal)=>{\n    const take = async (predicate, timeout)=>{\n        validateActive(signal);\n        let unsubscribe = ()=>{};\n        const tuplePromise = new Promise((resolve, reject)=>{\n            let stopListening = startListening({\n                predicate,\n                effect: (action, listenerApi)=>{\n                    listenerApi.unsubscribe();\n                    resolve([\n                        action,\n                        listenerApi.getState(),\n                        listenerApi.getOriginalState()\n                    ]);\n                }\n            });\n            unsubscribe = ()=>{\n                stopListening();\n                reject();\n            };\n        });\n        const promises = [\n            tuplePromise\n        ];\n        if (timeout != null) {\n            promises.push(new Promise((resolve)=>setTimeout(resolve, timeout, null)));\n        }\n        try {\n            const output = await raceWithSignal(signal, Promise.race(promises));\n            validateActive(signal);\n            return output;\n        } finally{\n            unsubscribe();\n        }\n    };\n    return (predicate, timeout)=>catchRejection(take(predicate, timeout));\n};\nvar getListenerEntryPropsFrom = (options)=>{\n    let { type, actionCreator, matcher, predicate, effect } = options;\n    if (type) {\n        predicate = createAction(type).match;\n    } else if (actionCreator) {\n        type = actionCreator.type;\n        predicate = actionCreator.match;\n    } else if (matcher) {\n        predicate = matcher;\n    } else if (predicate) {} else {\n        throw new Error( false ? 0 : \"Creating or removing a listener requires one of the known fields for matching an action\");\n    }\n    assertFunction(effect, \"options.listener\");\n    return {\n        predicate,\n        type,\n        effect\n    };\n};\nvar createListenerEntry = /* @__PURE__ */ assign((options)=>{\n    const { type, predicate, effect } = getListenerEntryPropsFrom(options);\n    const entry = {\n        id: nanoid(),\n        effect,\n        type,\n        predicate,\n        pending: /* @__PURE__ */ new Set(),\n        unsubscribe: ()=>{\n            throw new Error( false ? 0 : \"Unsubscribe not initialized\");\n        }\n    };\n    return entry;\n}, {\n    withTypes: ()=>createListenerEntry\n});\nvar findListenerEntry = (listenerMap, options)=>{\n    const { type, effect, predicate } = getListenerEntryPropsFrom(options);\n    return Array.from(listenerMap.values()).find((entry)=>{\n        const matchPredicateOrType = typeof type === \"string\" ? entry.type === type : entry.predicate === predicate;\n        return matchPredicateOrType && entry.effect === effect;\n    });\n};\nvar cancelActiveListeners = (entry)=>{\n    entry.pending.forEach((controller)=>{\n        controller.abort(listenerCancelled);\n    });\n};\nvar createClearListenerMiddleware = (listenerMap, executingListeners)=>{\n    return ()=>{\n        for (const listener2 of executingListeners.keys()){\n            cancelActiveListeners(listener2);\n        }\n        listenerMap.clear();\n    };\n};\nvar safelyNotifyError = (errorHandler, errorToNotify, errorInfo)=>{\n    try {\n        errorHandler(errorToNotify, errorInfo);\n    } catch (errorHandlerError) {\n        setTimeout(()=>{\n            throw errorHandlerError;\n        }, 0);\n    }\n};\nvar addListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/add`), {\n    withTypes: ()=>addListener\n});\nvar clearAllListeners = /* @__PURE__ */ createAction(`${alm}/removeAll`);\nvar removeListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/remove`), {\n    withTypes: ()=>removeListener\n});\nvar defaultErrorHandler = (...args)=>{\n    console.error(`${alm}/error`, ...args);\n};\nvar createListenerMiddleware = (middlewareOptions = {})=>{\n    const listenerMap = /* @__PURE__ */ new Map();\n    const executingListeners = /* @__PURE__ */ new Map();\n    const trackExecutingListener = (entry)=>{\n        const count = executingListeners.get(entry) ?? 0;\n        executingListeners.set(entry, count + 1);\n    };\n    const untrackExecutingListener = (entry)=>{\n        const count = executingListeners.get(entry) ?? 1;\n        if (count === 1) {\n            executingListeners.delete(entry);\n        } else {\n            executingListeners.set(entry, count - 1);\n        }\n    };\n    const { extra, onError = defaultErrorHandler } = middlewareOptions;\n    assertFunction(onError, \"onError\");\n    const insertEntry = (entry)=>{\n        entry.unsubscribe = ()=>listenerMap.delete(entry.id);\n        listenerMap.set(entry.id, entry);\n        return (cancelOptions)=>{\n            entry.unsubscribe();\n            if (cancelOptions?.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        };\n    };\n    const startListening = (options)=>{\n        const entry = findListenerEntry(listenerMap, options) ?? createListenerEntry(options);\n        return insertEntry(entry);\n    };\n    assign(startListening, {\n        withTypes: ()=>startListening\n    });\n    const stopListening = (options)=>{\n        const entry = findListenerEntry(listenerMap, options);\n        if (entry) {\n            entry.unsubscribe();\n            if (options.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        }\n        return !!entry;\n    };\n    assign(stopListening, {\n        withTypes: ()=>stopListening\n    });\n    const notifyListener = async (entry, action, api, getOriginalState)=>{\n        const internalTaskController = new AbortController();\n        const take = createTakePattern(startListening, internalTaskController.signal);\n        const autoJoinPromises = [];\n        try {\n            entry.pending.add(internalTaskController);\n            trackExecutingListener(entry);\n            await Promise.resolve(entry.effect(action, // Use assign() rather than ... to avoid extra helper functions added to bundle\n            assign({}, api, {\n                getOriginalState,\n                condition: (predicate, timeout)=>take(predicate, timeout).then(Boolean),\n                take,\n                delay: createDelay(internalTaskController.signal),\n                pause: createPause(internalTaskController.signal),\n                extra,\n                signal: internalTaskController.signal,\n                fork: createFork(internalTaskController.signal, autoJoinPromises),\n                unsubscribe: entry.unsubscribe,\n                subscribe: ()=>{\n                    listenerMap.set(entry.id, entry);\n                },\n                cancelActiveListeners: ()=>{\n                    entry.pending.forEach((controller, _, set)=>{\n                        if (controller !== internalTaskController) {\n                            controller.abort(listenerCancelled);\n                            set.delete(controller);\n                        }\n                    });\n                },\n                cancel: ()=>{\n                    internalTaskController.abort(listenerCancelled);\n                    entry.pending.delete(internalTaskController);\n                },\n                throwIfCancelled: ()=>{\n                    validateActive(internalTaskController.signal);\n                }\n            })));\n        } catch (listenerError) {\n            if (!(listenerError instanceof TaskAbortError)) {\n                safelyNotifyError(onError, listenerError, {\n                    raisedBy: \"effect\"\n                });\n            }\n        } finally{\n            await Promise.all(autoJoinPromises);\n            internalTaskController.abort(listenerCompleted);\n            untrackExecutingListener(entry);\n            entry.pending.delete(internalTaskController);\n        }\n    };\n    const clearListenerMiddleware = createClearListenerMiddleware(listenerMap, executingListeners);\n    const middleware = (api)=>(next)=>(action)=>{\n                if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n                    return next(action);\n                }\n                if (addListener.match(action)) {\n                    return startListening(action.payload);\n                }\n                if (clearAllListeners.match(action)) {\n                    clearListenerMiddleware();\n                    return;\n                }\n                if (removeListener.match(action)) {\n                    return stopListening(action.payload);\n                }\n                let originalState = api.getState();\n                const getOriginalState = ()=>{\n                    if (originalState === INTERNAL_NIL_TOKEN) {\n                        throw new Error( false ? 0 : `${alm}: getOriginalState can only be called synchronously`);\n                    }\n                    return originalState;\n                };\n                let result;\n                try {\n                    result = next(action);\n                    if (listenerMap.size > 0) {\n                        const currentState = api.getState();\n                        const listenerEntries = Array.from(listenerMap.values());\n                        for (const entry of listenerEntries){\n                            let runListener = false;\n                            try {\n                                runListener = entry.predicate(action, currentState, originalState);\n                            } catch (predicateError) {\n                                runListener = false;\n                                safelyNotifyError(onError, predicateError, {\n                                    raisedBy: \"predicate\"\n                                });\n                            }\n                            if (!runListener) {\n                                continue;\n                            }\n                            notifyListener(entry, action, api, getOriginalState);\n                        }\n                    }\n                } finally{\n                    originalState = INTERNAL_NIL_TOKEN;\n                }\n                return result;\n            };\n    return {\n        middleware,\n        startListening,\n        stopListening,\n        clearListeners: clearListenerMiddleware\n    };\n};\n// src/dynamicMiddleware/index.ts\nvar createMiddlewareEntry = (middleware)=>({\n        middleware,\n        applied: /* @__PURE__ */ new Map()\n    });\nvar matchInstance = (instanceId)=>(action)=>action?.meta?.instanceId === instanceId;\nvar createDynamicMiddleware = ()=>{\n    const instanceId = nanoid();\n    const middlewareMap = /* @__PURE__ */ new Map();\n    const withMiddleware = Object.assign(createAction(\"dynamicMiddleware/add\", (...middlewares)=>({\n            payload: middlewares,\n            meta: {\n                instanceId\n            }\n        })), {\n        withTypes: ()=>withMiddleware\n    });\n    const addMiddleware = Object.assign(function addMiddleware2(...middlewares) {\n        middlewares.forEach((middleware2)=>{\n            getOrInsertComputed(middlewareMap, middleware2, createMiddlewareEntry);\n        });\n    }, {\n        withTypes: ()=>addMiddleware\n    });\n    const getFinalMiddleware = (api)=>{\n        const appliedMiddleware = Array.from(middlewareMap.values()).map((entry)=>getOrInsertComputed(entry.applied, api, entry.middleware));\n        return (0,redux__WEBPACK_IMPORTED_MODULE_0__.compose)(...appliedMiddleware);\n    };\n    const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));\n    const middleware = (api)=>(next)=>(action)=>{\n                if (isWithMiddleware(action)) {\n                    addMiddleware(...action.payload);\n                    return api.dispatch;\n                }\n                return getFinalMiddleware(api)(next)(action);\n            };\n    return {\n        middleware,\n        addMiddleware,\n        withMiddleware,\n        instanceId\n    };\n};\n// src/combineSlices.ts\n\nvar isSliceLike = (maybeSliceLike)=>\"reducerPath\" in maybeSliceLike && typeof maybeSliceLike.reducerPath === \"string\";\nvar getReducers = (slices)=>slices.flatMap((sliceOrMap)=>isSliceLike(sliceOrMap) ? [\n            [\n                sliceOrMap.reducerPath,\n                sliceOrMap.reducer\n            ]\n        ] : Object.entries(sliceOrMap));\nvar ORIGINAL_STATE = Symbol.for(\"rtk-state-proxy-original\");\nvar isStateProxy = (value)=>!!value && !!value[ORIGINAL_STATE];\nvar stateProxyMap = /* @__PURE__ */ new WeakMap();\nvar createStateProxy = (state, reducerMap, initialStateCache)=>getOrInsertComputed(stateProxyMap, state, ()=>new Proxy(state, {\n            get: (target, prop, receiver)=>{\n                if (prop === ORIGINAL_STATE) return target;\n                const result = Reflect.get(target, prop, receiver);\n                if (typeof result === \"undefined\") {\n                    const cached = initialStateCache[prop];\n                    if (typeof cached !== \"undefined\") return cached;\n                    const reducer = reducerMap[prop];\n                    if (reducer) {\n                        const reducerResult = reducer(void 0, {\n                            type: nanoid()\n                        });\n                        if (typeof reducerResult === \"undefined\") {\n                            throw new Error( false ? 0 : `The slice reducer for key \"${prop.toString()}\" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);\n                        }\n                        initialStateCache[prop] = reducerResult;\n                        return reducerResult;\n                    }\n                }\n                return result;\n            }\n        }));\nvar original = (state)=>{\n    if (!isStateProxy(state)) {\n        throw new Error( false ? 0 : \"original must be used on state Proxy\");\n    }\n    return state[ORIGINAL_STATE];\n};\nvar emptyObject = {};\nvar noopReducer = (state = emptyObject)=>state;\nfunction combineSlices(...slices) {\n    const reducerMap = Object.fromEntries(getReducers(slices));\n    const getReducer = ()=>Object.keys(reducerMap).length ? (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducerMap) : noopReducer;\n    let reducer = getReducer();\n    function combinedReducer(state, action) {\n        return reducer(state, action);\n    }\n    combinedReducer.withLazyLoadedSlices = ()=>combinedReducer;\n    const initialStateCache = {};\n    const inject = (slice, config = {})=>{\n        const { reducerPath, reducer: reducerToInject } = slice;\n        const currentReducer = reducerMap[reducerPath];\n        if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {\n            if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n                console.error(`called \\`inject\\` to override already-existing reducer ${reducerPath} without specifying \\`overrideExisting: true\\``);\n            }\n            return combinedReducer;\n        }\n        if (config.overrideExisting && currentReducer !== reducerToInject) {\n            delete initialStateCache[reducerPath];\n        }\n        reducerMap[reducerPath] = reducerToInject;\n        reducer = getReducer();\n        return combinedReducer;\n    };\n    const selector = Object.assign(function makeSelector(selectorFn, selectState) {\n        return function selector2(state, ...args) {\n            return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap, initialStateCache), ...args);\n        };\n    }, {\n        original\n    });\n    return Object.assign(combinedReducer, {\n        inject,\n        selector\n    });\n}\n// src/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n    return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n}\n //# sourceMappingURL=redux-toolkit.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3JlZHV4LXRvb2xraXQubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ087QUFDZ0M7QUFFdEQsc0JBQXNCO0FBQ2dFO0FBRXRGLGVBQWU7QUFDdUM7QUFFdEQseUJBQXlCO0FBQ3dDO0FBRWpFLGlDQUFpQztBQUNqQyxJQUFJWSxpQ0FBaUMsQ0FBQyxHQUFHQztJQUN2QyxNQUFNQyxrQkFBa0JKLCtEQUFxQkEsSUFBSUc7SUFDakQsTUFBTUUsMkJBQTJCQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHQztRQUNqRCxNQUFNQyxXQUFXTCxtQkFBbUJJO1FBQ3BDLE1BQU1FLGtCQUFrQixDQUFDQyxPQUFPLEdBQUdDLE9BQVNILFNBQVNmLDhDQUFPQSxDQUFDaUIsU0FBU2xCLDhDQUFPQSxDQUFDa0IsU0FBU0EsVUFBVUM7UUFDakdOLE9BQU9DLE1BQU0sQ0FBQ0csaUJBQWlCRDtRQUMvQixPQUFPQztJQUNULEdBQUc7UUFDREcsV0FBVyxJQUFNUjtJQUNuQjtJQUNBLE9BQU9BO0FBQ1Q7QUFDQSxJQUFJUywwQkFBMEIsYUFBYSxHQUFHWiwrQkFBK0JELG9EQUFjQTtBQUUzRixzQkFBc0I7QUFDa0Y7QUFFeEcsMkJBQTJCO0FBQzNCLElBQUlvQixzQkFBc0IsTUFBNEUsR0FBR0MsQ0FBMkMsR0FBRztJQUNySixJQUFJRSxVQUFVQyxNQUFNLEtBQUssR0FBRyxPQUFPLEtBQUs7SUFDeEMsSUFBSSxPQUFPRCxTQUFTLENBQUMsRUFBRSxLQUFLLFVBQVUsT0FBT04sMENBQU9BO0lBQ3BELE9BQU9BLDBDQUFPQSxDQUFDUSxLQUFLLENBQUMsTUFBTUY7QUFDN0I7QUFDQSxJQUFJRyxtQkFBbUIsTUFBb0UsR0FBR0wsQ0FBbUMsR0FBRztJQUNsSSxPQUFPLFNB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U0FBUzJSLFVBQVU3Z0IsS0FBSyxFQUFFLEdBQUdwSixJQUFJO1lBQ3RDLE9BQU9ncUIsV0FBV3JCLGlCQUFpQnJRLGNBQWNBLFlBQVlsUCxVQUFVcEosUUFBUW9KLE9BQU93ZixZQUFZQyx1QkFBdUI3b0I7UUFDM0g7SUFDRixHQUFHO1FBQ0RaO0lBQ0Y7SUFDQSxPQUFPZSxPQUFPQyxNQUFNLENBQUNzcEIsaUJBQWlCO1FBQ3BDMVE7UUFDQTFZO0lBQ0Y7QUFDRjtBQUVBLGdDQUFnQztBQUNoQyxTQUFTa0MsdUJBQXVCNmUsSUFBSTtJQUNsQyxPQUFPLENBQUMsOEJBQThCLEVBQUVBLEtBQUssaURBQWlELEVBQUVBLEtBQUssK0VBQStFLENBQUM7QUFDdkw7QUFvREUsQ0FDRixpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmJpdGFsLWNvbXB1dGUtY29udHJvbC1yb29tLy4vbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvZGlzdC9yZWR1eC10b29sa2l0Lm1vZGVybi5tanM/YWQzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJyZWR1eFwiO1xuaW1wb3J0IHsgZnJlZXplLCBvcmlnaW5hbCBhcyBvcmlnaW5hbDIgfSBmcm9tIFwiaW1tZXJcIjtcblxuLy8gc3JjL2ltbWVySW1wb3J0cy50c1xuaW1wb3J0IHsgY3VycmVudCwgaXNEcmFmdCwgcHJvZHVjZSwgaXNEcmFmdGFibGUsIHNldFVzZVN0cmljdEl0ZXJhdGlvbiB9IGZyb20gXCJpbW1lclwiO1xuXG4vLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yLCBscnVNZW1vaXplIH0gZnJvbSBcInJlc2VsZWN0XCI7XG5cbi8vIHNyYy9yZXNlbGVjdEltcG9ydHMudHNcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvciwgd2Vha01hcE1lbW9pemUgfSBmcm9tIFwicmVzZWxlY3RcIjtcblxuLy8gc3JjL2NyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yLnRzXG52YXIgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JDcmVhdG9yID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgY3JlYXRlU2VsZWN0b3IyID0gY3JlYXRlU2VsZWN0b3JDcmVhdG9yKC4uLmFyZ3MpO1xuICBjb25zdCBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcjIgPSBPYmplY3QuYXNzaWduKCguLi5hcmdzMikgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3IyKC4uLmFyZ3MyKTtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSAodmFsdWUsIC4uLnJlc3QpID0+IHNlbGVjdG9yKGlzRHJhZnQodmFsdWUpID8gY3VycmVudCh2YWx1ZSkgOiB2YWx1ZSwgLi4ucmVzdCk7XG4gICAgT2JqZWN0LmFzc2lnbih3cmFwcGVkU2VsZWN0b3IsIHNlbGVjdG9yKTtcbiAgICByZXR1cm4gd3JhcHBlZFNlbGVjdG9yO1xuICB9LCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcjJcbiAgfSk7XG4gIHJldHVybiBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcjI7XG59O1xudmFyIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvcih3ZWFrTWFwTWVtb2l6ZSk7XG5cbi8vIHNyYy9yZWR1eEltcG9ydHMudHNcbmltcG9ydCB7IGNyZWF0ZVN0b3JlLCBjb21iaW5lUmVkdWNlcnMsIGFwcGx5TWlkZGxld2FyZSwgY29tcG9zZSwgaXNQbGFpbk9iamVjdCwgaXNBY3Rpb24gfSBmcm9tIFwicmVkdXhcIjtcblxuLy8gc3JjL2RldnRvb2xzRXh0ZW5zaW9uLnRzXG52YXIgY29tcG9zZVdpdGhEZXZUb29scyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA/IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gOiBmdW5jdGlvbigpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB2b2lkIDA7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSBcIm9iamVjdFwiKSByZXR1cm4gY29tcG9zZTtcbiAgcmV0dXJuIGNvbXBvc2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG52YXIgZGV2VG9vbHNFbmhhbmNlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA6IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZnVuY3Rpb24obm9vcDMpIHtcbiAgICByZXR1cm4gbm9vcDM7XG4gIH07XG59O1xuXG4vLyBzcmMvZ2V0RGVmYXVsdE1pZGRsZXdhcmUudHNcbmltcG9ydCB7IHRodW5rIGFzIHRodW5rTWlkZGxld2FyZSwgd2l0aEV4dHJhQXJndW1lbnQgfSBmcm9tIFwicmVkdXgtdGh1bmtcIjtcblxuLy8gc3JjL3RzSGVscGVycy50c1xudmFyIGhhc01hdGNoRnVuY3Rpb24gPSAodikgPT4ge1xuICByZXR1cm4gdiAmJiB0eXBlb2Ygdi5tYXRjaCA9PT0gXCJmdW5jdGlvblwiO1xufTtcblxuLy8gc3JjL2NyZWF0ZUFjdGlvbi50c1xuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKHR5cGUsIHByZXBhcmVBY3Rpb24pIHtcbiAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvciguLi5hcmdzKSB7XG4gICAgaWYgKHByZXBhcmVBY3Rpb24pIHtcbiAgICAgIGxldCBwcmVwYXJlZCA9IHByZXBhcmVBY3Rpb24oLi4uYXJncyk7XG4gICAgICBpZiAoIXByZXBhcmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDApIDogXCJwcmVwYXJlQWN0aW9uIGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHBheWxvYWQ6IHByZXBhcmVkLnBheWxvYWQsXG4gICAgICAgIC4uLlwibWV0YVwiIGluIHByZXBhcmVkICYmIHtcbiAgICAgICAgICBtZXRhOiBwcmVwYXJlZC5tZXRhXG4gICAgICAgIH0sXG4gICAgICAgIC4uLlwiZXJyb3JcIiBpbiBwcmVwYXJlZCAmJiB7XG4gICAgICAgICAgZXJyb3I6IHByZXBhcmVkLmVycm9yXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlLFxuICAgICAgcGF5bG9hZDogYXJnc1swXVxuICAgIH07XG4gIH1cbiAgYWN0aW9uQ3JlYXRvci50b1N0cmluZyA9ICgpID0+IGAke3R5cGV9YDtcbiAgYWN0aW9uQ3JlYXRvci50eXBlID0gdHlwZTtcbiAgYWN0aW9uQ3JlYXRvci5tYXRjaCA9IChhY3Rpb24pID0+IGlzQWN0aW9uKGFjdGlvbikgJiYgYWN0aW9uLnR5cGUgPT09IHR5cGU7XG4gIHJldHVybiBhY3Rpb25DcmVhdG9yO1xufVxuZnVuY3Rpb24gaXNBY3Rpb25DcmVhdG9yKGFjdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gXCJmdW5jdGlvblwiICYmIFwidHlwZVwiIGluIGFjdGlvbiAmJiAvLyBoYXNNYXRjaEZ1bmN0aW9uIG9ubHkgd2FudHMgTWF0Y2hlcnMgYnV0IEkgZG9uJ3Qgc2VlIHRoZSBwb2ludCBpbiByZXdyaXRpbmcgaXRcbiAgaGFzTWF0Y2hGdW5jdGlvbihhY3Rpb24pO1xufVxuZnVuY3Rpb24gaXNGU0EoYWN0aW9uKSB7XG4gIHJldHVybiBpc0FjdGlvbihhY3Rpb24pICYmIE9iamVjdC5rZXlzKGFjdGlvbikuZXZlcnkoaXNWYWxpZEtleSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xuICByZXR1cm4gW1widHlwZVwiLCBcInBheWxvYWRcIiwgXCJlcnJvclwiLCBcIm1ldGFcIl0uaW5kZXhPZihrZXkpID4gLTE7XG59XG5cbi8vIHNyYy9hY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZS50c1xuZnVuY3Rpb24gZ2V0TWVzc2FnZSh0eXBlKSB7XG4gIGNvbnN0IHNwbGl0VHlwZSA9IHR5cGUgPyBgJHt0eXBlfWAuc3BsaXQoXCIvXCIpIDogW107XG4gIGNvbnN0IGFjdGlvbk5hbWUgPSBzcGxpdFR5cGVbc3BsaXRUeXBlLmxlbmd0aCAtIDFdIHx8IFwiYWN0aW9uQ3JlYXRvclwiO1xuICByZXR1cm4gYERldGVjdGVkIGFuIGFjdGlvbiBjcmVhdG9yIHdpdGggdHlwZSBcIiR7dHlwZSB8fCBcInVua25vd25cIn1cIiBiZWluZyBkaXNwYXRjaGVkLiBcbk1ha2Ugc3VyZSB5b3UncmUgY2FsbGluZyB0aGUgYWN0aW9uIGNyZWF0b3IgYmVmb3JlIGRpc3BhdGNoaW5nLCBpLmUuIFxcYGRpc3BhdGNoKCR7YWN0aW9uTmFtZX0oKSlcXGAgaW5zdGVhZCBvZiBcXGBkaXNwYXRjaCgke2FjdGlvbk5hbWV9KVxcYC4gVGhpcyBpcyBuZWNlc3NhcnkgZXZlbiBpZiB0aGUgYWN0aW9uIGhhcyBubyBwYXlsb2FkLmA7XG59XG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiAoKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4gbmV4dChhY3Rpb24pO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpc0FjdGlvbkNyZWF0b3I6IGlzQWN0aW9uQ3JlYXRvcjIgPSBpc0FjdGlvbkNyZWF0b3JcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiAoKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgIGlmIChpc0FjdGlvbkNyZWF0b3IyKGFjdGlvbikpIHtcbiAgICAgIGNvbnNvbGUud2FybihnZXRNZXNzYWdlKGFjdGlvbi50eXBlKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gIH07XG59XG5cbi8vIHNyYy91dGlscy50c1xuZnVuY3Rpb24gZ2V0VGltZU1lYXN1cmVVdGlscyhtYXhEZWxheSwgZm5OYW1lKSB7XG4gIGxldCBlbGFwc2VkID0gMDtcbiAgcmV0dXJuIHtcbiAgICBtZWFzdXJlVGltZShmbikge1xuICAgICAgY29uc3Qgc3RhcnRlZCA9IERhdGUubm93KCk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnN0IGZpbmlzaGVkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgZWxhcHNlZCArPSBmaW5pc2hlZCAtIHN0YXJ0ZWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXJuSWZFeGNlZWRlZCgpIHtcbiAgICAgIGlmIChlbGFwc2VkID4gbWF4RGVsYXkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGAke2ZuTmFtZX0gdG9vayAke2VsYXBzZWR9bXMsIHdoaWNoIGlzIG1vcmUgdGhhbiB0aGUgd2FybmluZyB0aHJlc2hvbGQgb2YgJHttYXhEZWxheX1tcy4gXG5JZiB5b3VyIHN0YXRlIG9yIGFjdGlvbnMgYXJlIHZlcnkgbGFyZ2UsIHlvdSBtYXkgd2FudCB0byBkaXNhYmxlIHRoZSBtaWRkbGV3YXJlIGFzIGl0IG1pZ2h0IGNhdXNlIHRvbyBtdWNoIG9mIGEgc2xvd2Rvd24gaW4gZGV2ZWxvcG1lbnQgbW9kZS4gU2VlIGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2dldERlZmF1bHRNaWRkbGV3YXJlIGZvciBpbnN0cnVjdGlvbnMuXG5JdCBpcyBkaXNhYmxlZCBpbiBwcm9kdWN0aW9uIGJ1aWxkcywgc28geW91IGRvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhhdC5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG52YXIgVHVwbGUgPSBjbGFzcyBfVHVwbGUgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKC4uLml0ZW1zKSB7XG4gICAgc3VwZXIoLi4uaXRlbXMpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfVHVwbGUucHJvdG90eXBlKTtcbiAgfVxuICBzdGF0aWMgZ2V0IFtTeW1ib2wuc3BlY2llc10oKSB7XG4gICAgcmV0dXJuIF9UdXBsZTtcbiAgfVxuICBjb25jYXQoLi4uYXJyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvbmNhdC5hcHBseSh0aGlzLCBhcnIpO1xuICB9XG4gIHByZXBlbmQoLi4uYXJyKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcnJbMF0pKSB7XG4gICAgICByZXR1cm4gbmV3IF9UdXBsZSguLi5hcnJbMF0uY29uY2F0KHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfVHVwbGUoLi4uYXJyLmNvbmNhdCh0aGlzKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBmcmVlemVEcmFmdGFibGUodmFsKSB7XG4gIHJldHVybiBpc0RyYWZ0YWJsZSh2YWwpID8gcHJvZHVjZSh2YWwsICgpID0+IHtcbiAgfSkgOiB2YWw7XG59XG5mdW5jdGlvbiBnZXRPckluc2VydENvbXB1dGVkKG1hcCwga2V5LCBjb21wdXRlKSB7XG4gIGlmIChtYXAuaGFzKGtleSkpIHJldHVybiBtYXAuZ2V0KGtleSk7XG4gIHJldHVybiBtYXAuc2V0KGtleSwgY29tcHV0ZShrZXkpKS5nZXQoa2V5KTtcbn1cblxuLy8gc3JjL2ltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZS50c1xuZnVuY3Rpb24gaXNJbW11dGFibGVEZWZhdWx0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT0gbnVsbCB8fCBPYmplY3QuaXNGcm96ZW4odmFsdWUpO1xufVxuZnVuY3Rpb24gdHJhY2tGb3JNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZWRQYXRocywgb2JqKSB7XG4gIGNvbnN0IHRyYWNrZWRQcm9wZXJ0aWVzID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMsIG9iaik7XG4gIHJldHVybiB7XG4gICAgZGV0ZWN0TXV0YXRpb25zKCkge1xuICAgICAgcmV0dXJuIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzLCB0cmFja2VkUHJvcGVydGllcywgb2JqKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZWRQYXRocyA9IFtdLCBvYmosIHBhdGggPSBcIlwiLCBjaGVja2VkT2JqZWN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpIHtcbiAgY29uc3QgdHJhY2tlZCA9IHtcbiAgICB2YWx1ZTogb2JqXG4gIH07XG4gIGlmICghaXNJbW11dGFibGUob2JqKSAmJiAhY2hlY2tlZE9iamVjdHMuaGFzKG9iaikpIHtcbiAgICBjaGVja2VkT2JqZWN0cy5hZGQob2JqKTtcbiAgICB0cmFja2VkLmNoaWxkcmVuID0ge307XG4gICAgY29uc3QgaGFzSWdub3JlZFBhdGhzID0gaWdub3JlZFBhdGhzLmxlbmd0aCA+IDA7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICBjb25zdCBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICAgIGlmIChoYXNJZ25vcmVkUGF0aHMpIHtcbiAgICAgICAgY29uc3QgaGFzTWF0Y2hlcyA9IGlnbm9yZWRQYXRocy5zb21lKChpZ25vcmVkKSA9PiB7XG4gICAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHJldHVybiBpZ25vcmVkLnRlc3QobmVzdGVkUGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc01hdGNoZXMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJhY2tlZC5jaGlsZHJlbltrZXldID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMsIG9ialtrZXldLCBuZXN0ZWRQYXRoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyYWNrZWQ7XG59XG5mdW5jdGlvbiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZWRQYXRocyA9IFtdLCB0cmFja2VkUHJvcGVydHksIG9iaiwgc2FtZVBhcmVudFJlZiA9IGZhbHNlLCBwYXRoID0gXCJcIikge1xuICBjb25zdCBwcmV2T2JqID0gdHJhY2tlZFByb3BlcnR5ID8gdHJhY2tlZFByb3BlcnR5LnZhbHVlIDogdm9pZCAwO1xuICBjb25zdCBzYW1lUmVmID0gcHJldk9iaiA9PT0gb2JqO1xuICBpZiAoc2FtZVBhcmVudFJlZiAmJiAhc2FtZVJlZiAmJiAhTnVtYmVyLmlzTmFOKG9iaikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2FzTXV0YXRlZDogdHJ1ZSxcbiAgICAgIHBhdGhcbiAgICB9O1xuICB9XG4gIGlmIChpc0ltbXV0YWJsZShwcmV2T2JqKSB8fCBpc0ltbXV0YWJsZShvYmopKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhc011dGF0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjb25zdCBrZXlzVG9EZXRlY3QgPSB7fTtcbiAgZm9yIChsZXQga2V5IGluIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbikge1xuICAgIGtleXNUb0RldGVjdFtrZXldID0gdHJ1ZTtcbiAgfVxuICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlO1xuICB9XG4gIGNvbnN0IGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xuICBmb3IgKGxldCBrZXkgaW4ga2V5c1RvRGV0ZWN0KSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKGhhc0lnbm9yZWRQYXRocykge1xuICAgICAgY29uc3QgaGFzTWF0Y2hlcyA9IGlnbm9yZWRQYXRocy5zb21lKChpZ25vcmVkKSA9PiB7XG4gICAgICAgIGlmIChpZ25vcmVkIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgcmV0dXJuIGlnbm9yZWQudGVzdChuZXN0ZWRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVzdGVkUGF0aCA9PT0gaWdub3JlZDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhc01hdGNoZXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzLCB0cmFja2VkUHJvcGVydHkuY2hpbGRyZW5ba2V5XSwgb2JqW2tleV0sIHNhbWVSZWYsIG5lc3RlZFBhdGgpO1xuICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3YXNNdXRhdGVkOiBmYWxzZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHN0cmluZ2lmeTIgPSBmdW5jdGlvbihvYmosIHNlcmlhbGl6ZXIsIGluZGVudCwgZGVjeWNsZXIpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIGdldFNlcmlhbGl6ZTIoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpO1xuICAgIH0sIGdldFNlcmlhbGl6ZTIgPSBmdW5jdGlvbihzZXJpYWxpemVyLCBkZWN5Y2xlcikge1xuICAgICAgbGV0IHN0YWNrID0gW10sIGtleXMgPSBbXTtcbiAgICAgIGlmICghZGVjeWNsZXIpIGRlY3ljbGVyID0gZnVuY3Rpb24oXywgdmFsdWUpIHtcbiAgICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSkgcmV0dXJuIFwiW0NpcmN1bGFyIH5dXCI7XG4gICAgICAgIHJldHVybiBcIltDaXJjdWxhciB+LlwiICsga2V5cy5zbGljZSgwLCBzdGFjay5pbmRleE9mKHZhbHVlKSkuam9pbihcIi5cIikgKyBcIl1cIjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICB+dGhpc1BvcyA/IHN0YWNrLnNwbGljZSh0aGlzUG9zICsgMSkgOiBzdGFjay5wdXNoKHRoaXMpO1xuICAgICAgICAgIH50aGlzUG9zID8ga2V5cy5zcGxpY2UodGhpc1BvcywgSW5maW5pdHksIGtleSkgOiBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKSB2YWx1ZSA9IGRlY3ljbGVyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXIgPT0gbnVsbCA/IHZhbHVlIDogc2VyaWFsaXplci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBzdHJpbmdpZnkgPSBzdHJpbmdpZnkyLCBnZXRTZXJpYWxpemUgPSBnZXRTZXJpYWxpemUyO1xuICAgIGxldCB7XG4gICAgICBpc0ltbXV0YWJsZSA9IGlzSW1tdXRhYmxlRGVmYXVsdCxcbiAgICAgIGlnbm9yZWRQYXRocyxcbiAgICAgIHdhcm5BZnRlciA9IDMyXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdHJhY2sgPSB0cmFja0Zvck11dGF0aW9ucy5iaW5kKG51bGwsIGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMpO1xuICAgIHJldHVybiAoe1xuICAgICAgZ2V0U3RhdGVcbiAgICB9KSA9PiB7XG4gICAgICBsZXQgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgbGV0IHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgcmV0dXJuIChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVVdGlscyA9IGdldFRpbWVNZWFzdXJlVXRpbHMod2FybkFmdGVyLCBcIkltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZVwiKTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcbiAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTkpIDogYEEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGJldHdlZW4gZGlzcGF0Y2hlcywgaW4gdGhlIHBhdGggJyR7cmVzdWx0LnBhdGggfHwgXCJcIn0nLiAgVGhpcyBtYXkgY2F1c2UgaW5jb3JyZWN0IGJlaGF2aW9yLiAoaHR0cHM6Ly9yZWR1eC5qcy5vcmcvc3R5bGUtZ3VpZGUvc3R5bGUtZ3VpZGUjZG8tbm90LW11dGF0ZS1zdGF0ZSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkaXNwYXRjaGVkQWN0aW9uID0gbmV4dChhY3Rpb24pO1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpO1xuICAgICAgICAgIHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMCkgOiBgQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgaW5zaWRlIGEgZGlzcGF0Y2gsIGluIHRoZSBwYXRoOiAke3Jlc3VsdC5wYXRoIHx8IFwiXCJ9LiBUYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGUgYWN0aW9uICR7c3RyaW5naWZ5MihhY3Rpb24pfS4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaGVkQWN0aW9uO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGlzUGxhaW4odmFsKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsO1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsKSB8fCBpc1BsYWluT2JqZWN0KHZhbCk7XG59XG5mdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUodmFsdWUsIHBhdGggPSBcIlwiLCBpc1NlcmlhbGl6YWJsZSA9IGlzUGxhaW4sIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocyA9IFtdLCBjYWNoZSkge1xuICBsZXQgZm91bmROZXN0ZWRTZXJpYWxpemFibGU7XG4gIGlmICghaXNTZXJpYWxpemFibGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleVBhdGg6IHBhdGggfHwgXCI8cm9vdD5cIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjYWNoZT8uaGFzKHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBlbnRyaWVzID0gZ2V0RW50cmllcyAhPSBudWxsID8gZ2V0RW50cmllcyh2YWx1ZSkgOiBPYmplY3QuZW50cmllcyh2YWx1ZSk7XG4gIGNvbnN0IGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xuICBmb3IgKGNvbnN0IFtrZXksIG5lc3RlZFZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKGhhc0lnbm9yZWRQYXRocykge1xuICAgICAgY29uc3QgaGFzTWF0Y2hlcyA9IGlnbm9yZWRQYXRocy5zb21lKChpZ25vcmVkKSA9PiB7XG4gICAgICAgIGlmIChpZ25vcmVkIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgcmV0dXJuIGlnbm9yZWQudGVzdChuZXN0ZWRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVzdGVkUGF0aCA9PT0gaWdub3JlZDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhc01hdGNoZXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaXNTZXJpYWxpemFibGUobmVzdGVkVmFsdWUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXlQYXRoOiBuZXN0ZWRQYXRoLFxuICAgICAgICB2YWx1ZTogbmVzdGVkVmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmVzdGVkVmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKG5lc3RlZFZhbHVlLCBuZXN0ZWRQYXRoLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XG4gICAgICBpZiAoZm91bmROZXN0ZWRTZXJpYWxpemFibGUpIHtcbiAgICAgICAgcmV0dXJuIGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoY2FjaGUgJiYgaXNOZXN0ZWRGcm96ZW4odmFsdWUpKSBjYWNoZS5hZGQodmFsdWUpO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc05lc3RlZEZyb3plbih2YWx1ZSkge1xuICBpZiAoIU9iamVjdC5pc0Zyb3plbih2YWx1ZSkpIHJldHVybiBmYWxzZTtcbiAgZm9yIChjb25zdCBuZXN0ZWRWYWx1ZSBvZiBPYmplY3QudmFsdWVzKHZhbHVlKSkge1xuICAgIGlmICh0eXBlb2YgbmVzdGVkVmFsdWUgIT09IFwib2JqZWN0XCIgfHwgbmVzdGVkVmFsdWUgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgIGlmICghaXNOZXN0ZWRGcm96ZW4obmVzdGVkVmFsdWUpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUob3B0aW9ucyA9IHt9KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4gKCkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IG5leHQoYWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7XG4gICAgICBpc1NlcmlhbGl6YWJsZSA9IGlzUGxhaW4sXG4gICAgICBnZXRFbnRyaWVzLFxuICAgICAgaWdub3JlZEFjdGlvbnMgPSBbXSxcbiAgICAgIGlnbm9yZWRBY3Rpb25QYXRocyA9IFtcIm1ldGEuYXJnXCIsIFwibWV0YS5iYXNlUXVlcnlNZXRhXCJdLFxuICAgICAgaWdub3JlZFBhdGhzID0gW10sXG4gICAgICB3YXJuQWZ0ZXIgPSAzMixcbiAgICAgIGlnbm9yZVN0YXRlID0gZmFsc2UsXG4gICAgICBpZ25vcmVBY3Rpb25zID0gZmFsc2UsXG4gICAgICBkaXNhYmxlQ2FjaGUgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGNhY2hlID0gIWRpc2FibGVDYWNoZSAmJiBXZWFrU2V0ID8gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIChzdG9yZUFQSSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICAgIGlmICghaXNBY3Rpb24oYWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xuICAgICAgY29uc3QgbWVhc3VyZVV0aWxzID0gZ2V0VGltZU1lYXN1cmVVdGlscyh3YXJuQWZ0ZXIsIFwiU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlXCIpO1xuICAgICAgaWYgKCFpZ25vcmVBY3Rpb25zICYmICEoaWdub3JlZEFjdGlvbnMubGVuZ3RoICYmIGlnbm9yZWRBY3Rpb25zLmluZGV4T2YoYWN0aW9uLnR5cGUpICE9PSAtMSkpIHtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKGFjdGlvbiwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRBY3Rpb25QYXRocywgY2FjaGUpO1xuICAgICAgICAgIGlmIChmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gYW4gYWN0aW9uLCBpbiB0aGUgcGF0aDogXFxgJHtrZXlQYXRofVxcYC4gVmFsdWU6YCwgdmFsdWUsIFwiXFxuVGFrZSBhIGxvb2sgYXQgdGhlIGxvZ2ljIHRoYXQgZGlzcGF0Y2hlZCB0aGlzIGFjdGlvbjogXCIsIGFjdGlvbiwgXCJcXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9hY3Rpb25zI3doeS1zaG91bGQtdHlwZS1iZS1hLXN0cmluZy1vci1hdC1sZWFzdC1zZXJpYWxpemFibGUtd2h5LXNob3VsZC1teS1hY3Rpb24tdHlwZXMtYmUtY29uc3RhbnRzKVwiLCBcIlxcbihUbyBhbGxvdyBub24tc2VyaWFsaXphYmxlIHZhbHVlcyBzZWU6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvdXNhZ2UvdXNhZ2UtZ3VpZGUjd29ya2luZy13aXRoLW5vbi1zZXJpYWxpemFibGUtZGF0YSlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghaWdub3JlU3RhdGUpIHtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlQVBJLmdldFN0YXRlKCk7XG4gICAgICAgICAgY29uc3QgZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHN0YXRlLCBcIlwiLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XG4gICAgICAgICAgaWYgKGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSA9IGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gdGhlIHN0YXRlLCBpbiB0aGUgcGF0aDogXFxgJHtrZXlQYXRofVxcYC4gVmFsdWU6YCwgdmFsdWUsIGBcblRha2UgYSBsb29rIGF0IHRoZSByZWR1Y2VyKHMpIGhhbmRsaW5nIHRoaXMgYWN0aW9uIHR5cGU6ICR7YWN0aW9uLnR5cGV9LlxuKFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9mYXEvb3JnYW5pemluZy1zdGF0ZSNjYW4taS1wdXQtZnVuY3Rpb25zLXByb21pc2VzLW9yLW90aGVyLW5vbi1zZXJpYWxpemFibGUtaXRlbXMtaW4tbXktc3RvcmUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL2dldERlZmF1bHRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBpc0Jvb2xlYW4oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwiYm9vbGVhblwiO1xufVxudmFyIGJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUgPSAoKSA9PiBmdW5jdGlvbiBnZXREZWZhdWx0TWlkZGxld2FyZShvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICB0aHVuayA9IHRydWUsXG4gICAgaW1tdXRhYmxlQ2hlY2sgPSB0cnVlLFxuICAgIHNlcmlhbGl6YWJsZUNoZWNrID0gdHJ1ZSxcbiAgICBhY3Rpb25DcmVhdG9yQ2hlY2sgPSB0cnVlXG4gIH0gPSBvcHRpb25zID8/IHt9O1xuICBsZXQgbWlkZGxld2FyZUFycmF5ID0gbmV3IFR1cGxlKCk7XG4gIGlmICh0aHVuaykge1xuICAgIGlmIChpc0Jvb2xlYW4odGh1bmspKSB7XG4gICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh0aHVua01pZGRsZXdhcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh3aXRoRXh0cmFBcmd1bWVudCh0aHVuay5leHRyYUFyZ3VtZW50KSk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoaW1tdXRhYmxlQ2hlY2spIHtcbiAgICAgIGxldCBpbW11dGFibGVPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihpbW11dGFibGVDaGVjaykpIHtcbiAgICAgICAgaW1tdXRhYmxlT3B0aW9ucyA9IGltbXV0YWJsZUNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnVuc2hpZnQoY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKGltbXV0YWJsZU9wdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6YWJsZUNoZWNrKSB7XG4gICAgICBsZXQgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFpc0Jvb2xlYW4oc2VyaWFsaXphYmxlQ2hlY2spKSB7XG4gICAgICAgIHNlcmlhbGl6YWJsZU9wdGlvbnMgPSBzZXJpYWxpemFibGVDaGVjaztcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShzZXJpYWxpemFibGVPcHRpb25zKSk7XG4gICAgfVxuICAgIGlmIChhY3Rpb25DcmVhdG9yQ2hlY2spIHtcbiAgICAgIGxldCBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFpc0Jvb2xlYW4oYWN0aW9uQ3JlYXRvckNoZWNrKSkge1xuICAgICAgICBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IGFjdGlvbkNyZWF0b3JDaGVjaztcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVBcnJheS51bnNoaWZ0KGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlKGFjdGlvbkNyZWF0b3JPcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaWRkbGV3YXJlQXJyYXk7XG59O1xuXG4vLyBzcmMvYXV0b0JhdGNoRW5oYW5jZXIudHNcbnZhciBTSE9VTERfQVVUT0JBVENIID0gXCJSVEtfYXV0b0JhdGNoXCI7XG52YXIgcHJlcGFyZUF1dG9CYXRjaGVkID0gKCkgPT4gKHBheWxvYWQpID0+ICh7XG4gIHBheWxvYWQsXG4gIG1ldGE6IHtcbiAgICBbU0hPVUxEX0FVVE9CQVRDSF06IHRydWVcbiAgfVxufSk7XG52YXIgY3JlYXRlUXVldWVXaXRoVGltZXIgPSAodGltZW91dCkgPT4ge1xuICByZXR1cm4gKG5vdGlmeSkgPT4ge1xuICAgIHNldFRpbWVvdXQobm90aWZ5LCB0aW1lb3V0KTtcbiAgfTtcbn07XG52YXIgYXV0b0JhdGNoRW5oYW5jZXIgPSAob3B0aW9ucyA9IHtcbiAgdHlwZTogXCJyYWZcIlxufSkgPT4gKG5leHQpID0+ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IHN0b3JlID0gbmV4dCguLi5hcmdzKTtcbiAgbGV0IG5vdGlmeWluZyA9IHRydWU7XG4gIGxldCBzaG91bGROb3RpZnlBdEVuZE9mVGljayA9IGZhbHNlO1xuICBsZXQgbm90aWZpY2F0aW9uUXVldWVkID0gZmFsc2U7XG4gIGNvbnN0IGxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHF1ZXVlQ2FsbGJhY2sgPSBvcHRpb25zLnR5cGUgPT09IFwidGlja1wiID8gcXVldWVNaWNyb3Rhc2sgOiBvcHRpb25zLnR5cGUgPT09IFwicmFmXCIgPyAoXG4gICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHdvbid0IGV4aXN0IGluIFNTUiBlbnZpcm9ubWVudHMuIEZhbGwgYmFjayB0byBhIHZhZ3VlIGFwcHJveGltYXRpb24ganVzdCB0byBrZWVwIGZyb20gZXJyb3JpbmcuXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKDEwKVxuICApIDogb3B0aW9ucy50eXBlID09PSBcImNhbGxiYWNrXCIgPyBvcHRpb25zLnF1ZXVlTm90aWZpY2F0aW9uIDogY3JlYXRlUXVldWVXaXRoVGltZXIob3B0aW9ucy50aW1lb3V0KTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXJzID0gKCkgPT4ge1xuICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IGZhbHNlO1xuICAgIGlmIChzaG91bGROb3RpZnlBdEVuZE9mVGljaykge1xuICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsKSA9PiBsKCkpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0b3JlLCB7XG4gICAgLy8gT3ZlcnJpZGUgdGhlIGJhc2UgYHN0b3JlLnN1YnNjcmliZWAgbWV0aG9kIHRvIGtlZXAgb3JpZ2luYWwgbGlzdGVuZXJzXG4gICAgLy8gZnJvbSBydW5uaW5nIGlmIHdlJ3JlIGRlbGF5aW5nIG5vdGlmaWNhdGlvbnNcbiAgICBzdWJzY3JpYmUobGlzdGVuZXIyKSB7XG4gICAgICBjb25zdCB3cmFwcGVkTGlzdGVuZXIgPSAoKSA9PiBub3RpZnlpbmcgJiYgbGlzdGVuZXIyKCk7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZSh3cmFwcGVkTGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcjIpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcjIpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIE92ZXJyaWRlIHRoZSBiYXNlIGBzdG9yZS5kaXNwYXRjaGAgbWV0aG9kIHNvIHRoYXQgd2UgY2FuIGNoZWNrIGFjdGlvbnNcbiAgICAvLyBmb3IgdGhlIGBzaG91bGRBdXRvQmF0Y2hgIGZsYWcgYW5kIGRldGVybWluZSBpZiBiYXRjaGluZyBpcyBhY3RpdmVcbiAgICBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5vdGlmeWluZyA9ICFhY3Rpb24/Lm1ldGE/LltTSE9VTERfQVVUT0JBVENIXTtcbiAgICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSAhbm90aWZ5aW5nO1xuICAgICAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcbiAgICAgICAgICBpZiAoIW5vdGlmaWNhdGlvblF1ZXVlZCkge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uUXVldWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHF1ZXVlQ2FsbGJhY2sobm90aWZ5TGlzdGVuZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBub3RpZnlpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBzcmMvZ2V0RGVmYXVsdEVuaGFuY2Vycy50c1xudmFyIGJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyA9IChtaWRkbGV3YXJlRW5oYW5jZXIpID0+IGZ1bmN0aW9uIGdldERlZmF1bHRFbmhhbmNlcnMob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYXV0b0JhdGNoID0gdHJ1ZVxuICB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgbGV0IGVuaGFuY2VyQXJyYXkgPSBuZXcgVHVwbGUobWlkZGxld2FyZUVuaGFuY2VyKTtcbiAgaWYgKGF1dG9CYXRjaCkge1xuICAgIGVuaGFuY2VyQXJyYXkucHVzaChhdXRvQmF0Y2hFbmhhbmNlcih0eXBlb2YgYXV0b0JhdGNoID09PSBcIm9iamVjdFwiID8gYXV0b0JhdGNoIDogdm9pZCAwKSk7XG4gIH1cbiAgcmV0dXJuIGVuaGFuY2VyQXJyYXk7XG59O1xuXG4vLyBzcmMvY29uZmlndXJlU3RvcmUudHNcbmZ1bmN0aW9uIGNvbmZpZ3VyZVN0b3JlKG9wdGlvbnMpIHtcbiAgY29uc3QgZ2V0RGVmYXVsdE1pZGRsZXdhcmUgPSBidWlsZEdldERlZmF1bHRNaWRkbGV3YXJlKCk7XG4gIGNvbnN0IHtcbiAgICByZWR1Y2VyID0gdm9pZCAwLFxuICAgIG1pZGRsZXdhcmUsXG4gICAgZGV2VG9vbHMgPSB0cnVlLFxuICAgIGR1cGxpY2F0ZU1pZGRsZXdhcmVDaGVjayA9IHRydWUsXG4gICAgcHJlbG9hZGVkU3RhdGUgPSB2b2lkIDAsXG4gICAgZW5oYW5jZXJzID0gdm9pZCAwXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgcm9vdFJlZHVjZXI7XG4gIGlmICh0eXBlb2YgcmVkdWNlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcm9vdFJlZHVjZXIgPSByZWR1Y2VyO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocmVkdWNlcikpIHtcbiAgICByb290UmVkdWNlciA9IGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2VyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxKSA6IFwiYHJlZHVjZXJgIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQsIGFuZCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IG9mIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gY29tYmluZVJlZHVjZXJzXCIpO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbWlkZGxld2FyZSAmJiB0eXBlb2YgbWlkZGxld2FyZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMikgOiBcImBtaWRkbGV3YXJlYCBmaWVsZCBtdXN0IGJlIGEgY2FsbGJhY2tcIik7XG4gIH1cbiAgbGV0IGZpbmFsTWlkZGxld2FyZTtcbiAgaWYgKHR5cGVvZiBtaWRkbGV3YXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmaW5hbE1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlKGdldERlZmF1bHRNaWRkbGV3YXJlKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFBcnJheS5pc0FycmF5KGZpbmFsTWlkZGxld2FyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMpIDogXCJ3aGVuIHVzaW5nIGEgbWlkZGxld2FyZSBidWlsZGVyIGZ1bmN0aW9uLCBhbiBhcnJheSBvZiBtaWRkbGV3YXJlIG11c3QgYmUgcmV0dXJuZWRcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZpbmFsTWlkZGxld2FyZSA9IGdldERlZmF1bHRNaWRkbGV3YXJlKCk7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmaW5hbE1pZGRsZXdhcmUuc29tZSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0KSA6IFwiZWFjaCBtaWRkbGV3YXJlIHByb3ZpZGVkIHRvIGNvbmZpZ3VyZVN0b3JlIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGR1cGxpY2F0ZU1pZGRsZXdhcmVDaGVjaykge1xuICAgIGxldCBtaWRkbGV3YXJlUmVmZXJlbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZmluYWxNaWRkbGV3YXJlLmZvckVhY2goKG1pZGRsZXdhcmUyKSA9PiB7XG4gICAgICBpZiAobWlkZGxld2FyZVJlZmVyZW5jZXMuaGFzKG1pZGRsZXdhcmUyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0MikgOiBcIkR1cGxpY2F0ZSBtaWRkbGV3YXJlIHJlZmVyZW5jZXMgZm91bmQgd2hlbiBjcmVhdGluZyB0aGUgc3RvcmUuIEVuc3VyZSB0aGF0IGVhY2ggbWlkZGxld2FyZSBpcyBvbmx5IGluY2x1ZGVkIG9uY2UuXCIpO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZVJlZmVyZW5jZXMuYWRkKG1pZGRsZXdhcmUyKTtcbiAgICB9KTtcbiAgfVxuICBsZXQgZmluYWxDb21wb3NlID0gY29tcG9zZTtcbiAgaWYgKGRldlRvb2xzKSB7XG4gICAgZmluYWxDb21wb3NlID0gY29tcG9zZVdpdGhEZXZUb29scyh7XG4gICAgICAvLyBFbmFibGUgY2FwdHVyZSBvZiBzdGFjayB0cmFjZXMgZm9yIGRpc3BhdGNoZWQgUmVkdXggYWN0aW9uc1xuICAgICAgdHJhY2U6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIixcbiAgICAgIC4uLnR5cGVvZiBkZXZUb29scyA9PT0gXCJvYmplY3RcIiAmJiBkZXZUb29sc1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IG1pZGRsZXdhcmVFbmhhbmNlciA9IGFwcGx5TWlkZGxld2FyZSguLi5maW5hbE1pZGRsZXdhcmUpO1xuICBjb25zdCBnZXREZWZhdWx0RW5oYW5jZXJzID0gYnVpbGRHZXREZWZhdWx0RW5oYW5jZXJzKG1pZGRsZXdhcmVFbmhhbmNlcik7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZW5oYW5jZXJzICYmIHR5cGVvZiBlbmhhbmNlcnMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDUpIDogXCJgZW5oYW5jZXJzYCBmaWVsZCBtdXN0IGJlIGEgY2FsbGJhY2tcIik7XG4gIH1cbiAgbGV0IHN0b3JlRW5oYW5jZXJzID0gdHlwZW9mIGVuaGFuY2VycyA9PT0gXCJmdW5jdGlvblwiID8gZW5oYW5jZXJzKGdldERlZmF1bHRFbmhhbmNlcnMpIDogZ2V0RGVmYXVsdEVuaGFuY2VycygpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFBcnJheS5pc0FycmF5KHN0b3JlRW5oYW5jZXJzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDYpIDogXCJgZW5oYW5jZXJzYCBjYWxsYmFjayBtdXN0IHJldHVybiBhbiBhcnJheVwiKTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHN0b3JlRW5oYW5jZXJzLnNvbWUoKGl0ZW0pID0+IHR5cGVvZiBpdGVtICE9PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNykgOiBcImVhY2ggZW5oYW5jZXIgcHJvdmlkZWQgdG8gY29uZmlndXJlU3RvcmUgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZmluYWxNaWRkbGV3YXJlLmxlbmd0aCAmJiAhc3RvcmVFbmhhbmNlcnMuaW5jbHVkZXMobWlkZGxld2FyZUVuaGFuY2VyKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJtaWRkbGV3YXJlcyB3ZXJlIHByb3ZpZGVkLCBidXQgbWlkZGxld2FyZSBlbmhhbmNlciB3YXMgbm90IGluY2x1ZGVkIGluIGZpbmFsIGVuaGFuY2VycyAtIG1ha2Ugc3VyZSB0byBjYWxsIGBnZXREZWZhdWx0RW5oYW5jZXJzYFwiKTtcbiAgfVxuICBjb25zdCBjb21wb3NlZEVuaGFuY2VyID0gZmluYWxDb21wb3NlKC4uLnN0b3JlRW5oYW5jZXJzKTtcbiAgcmV0dXJuIGNyZWF0ZVN0b3JlKHJvb3RSZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgY29tcG9zZWRFbmhhbmNlcik7XG59XG5cbi8vIHNyYy9tYXBCdWlsZGVycy50c1xuZnVuY3Rpb24gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2soYnVpbGRlckNhbGxiYWNrKSB7XG4gIGNvbnN0IGFjdGlvbnNNYXAgPSB7fTtcbiAgY29uc3QgYWN0aW9uTWF0Y2hlcnMgPSBbXTtcbiAgbGV0IGRlZmF1bHRDYXNlUmVkdWNlcjtcbiAgY29uc3QgYnVpbGRlciA9IHtcbiAgICBhZGRDYXNlKHR5cGVPckFjdGlvbkNyZWF0b3IsIHJlZHVjZXIpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGFjdGlvbk1hdGNoZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNikgOiBcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGRNYXRjaGVyYFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjcpIDogXCJgYnVpbGRlci5hZGRDYXNlYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHR5cGVPckFjdGlvbkNyZWF0b3IgPT09IFwic3RyaW5nXCIgPyB0eXBlT3JBY3Rpb25DcmVhdG9yIDogdHlwZU9yQWN0aW9uQ3JlYXRvci50eXBlO1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI4KSA6IFwiYGJ1aWxkZXIuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFjdGlvbiB0eXBlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgaW4gYWN0aW9uc01hcCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyOSkgOiBgXFxgYnVpbGRlci5hZGRDYXNlXFxgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlICcke3R5cGV9J2ApO1xuICAgICAgfVxuICAgICAgYWN0aW9uc01hcFt0eXBlXSA9IHJlZHVjZXI7XG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9LFxuICAgIGFkZEFzeW5jVGh1bmsoYXN5bmNUaHVuaywgcmVkdWNlcnMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQzKSA6IFwiYGJ1aWxkZXIuYWRkQXN5bmNUaHVua2Agc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlZHVjZXJzLnBlbmRpbmcpIGFjdGlvbnNNYXBbYXN5bmNUaHVuay5wZW5kaW5nLnR5cGVdID0gcmVkdWNlcnMucGVuZGluZztcbiAgICAgIGlmIChyZWR1Y2Vycy5yZWplY3RlZCkgYWN0aW9uc01hcFthc3luY1RodW5rLnJlamVjdGVkLnR5cGVdID0gcmVkdWNlcnMucmVqZWN0ZWQ7XG4gICAgICBpZiAocmVkdWNlcnMuZnVsZmlsbGVkKSBhY3Rpb25zTWFwW2FzeW5jVGh1bmsuZnVsZmlsbGVkLnR5cGVdID0gcmVkdWNlcnMuZnVsZmlsbGVkO1xuICAgICAgaWYgKHJlZHVjZXJzLnNldHRsZWQpIGFjdGlvbk1hdGNoZXJzLnB1c2goe1xuICAgICAgICBtYXRjaGVyOiBhc3luY1RodW5rLnNldHRsZWQsXG4gICAgICAgIHJlZHVjZXI6IHJlZHVjZXJzLnNldHRsZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfSxcbiAgICBhZGRNYXRjaGVyKG1hdGNoZXIsIHJlZHVjZXIpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMwKSA6IFwiYGJ1aWxkZXIuYWRkTWF0Y2hlcmAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWN0aW9uTWF0Y2hlcnMucHVzaCh7XG4gICAgICAgIG1hdGNoZXIsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfSxcbiAgICBhZGREZWZhdWx0Q2FzZShyZWR1Y2VyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMSkgOiBcImBidWlsZGVyLmFkZERlZmF1bHRDYXNlYCBjYW4gb25seSBiZSBjYWxsZWQgb25jZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVmYXVsdENhc2VSZWR1Y2VyID0gcmVkdWNlcjtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbiAgfTtcbiAgYnVpbGRlckNhbGxiYWNrKGJ1aWxkZXIpO1xuICByZXR1cm4gW2FjdGlvbnNNYXAsIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXJdO1xufVxuXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xuZnVuY3Rpb24gaXNTdGF0ZUZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSwgbWFwT3JCdWlsZGVyQ2FsbGJhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICh0eXBlb2YgbWFwT3JCdWlsZGVyQ2FsbGJhY2sgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDgpIDogXCJUaGUgb2JqZWN0IG5vdGF0aW9uIGZvciBgY3JlYXRlUmVkdWNlcmAgaGFzIGJlZW4gcmVtb3ZlZC4gUGxlYXNlIHVzZSB0aGUgJ2J1aWxkZXIgY2FsbGJhY2snIG5vdGF0aW9uIGluc3RlYWQ6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2NyZWF0ZVJlZHVjZXJcIik7XG4gICAgfVxuICB9XG4gIGxldCBbYWN0aW9uc01hcCwgZmluYWxBY3Rpb25NYXRjaGVycywgZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXJdID0gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2sobWFwT3JCdWlsZGVyQ2FsbGJhY2spO1xuICBsZXQgZ2V0SW5pdGlhbFN0YXRlO1xuICBpZiAoaXNTdGF0ZUZ1bmN0aW9uKGluaXRpYWxTdGF0ZSkpIHtcbiAgICBnZXRJbml0aWFsU3RhdGUgPSAoKSA9PiBmcmVlemVEcmFmdGFibGUoaW5pdGlhbFN0YXRlKCkpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGZyb3plbkluaXRpYWxTdGF0ZSA9IGZyZWV6ZURyYWZ0YWJsZShpbml0aWFsU3RhdGUpO1xuICAgIGdldEluaXRpYWxTdGF0ZSA9ICgpID0+IGZyb3plbkluaXRpYWxTdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiByZWR1Y2VyKHN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCksIGFjdGlvbikge1xuICAgIGxldCBjYXNlUmVkdWNlcnMgPSBbYWN0aW9uc01hcFthY3Rpb24udHlwZV0sIC4uLmZpbmFsQWN0aW9uTWF0Y2hlcnMuZmlsdGVyKCh7XG4gICAgICBtYXRjaGVyXG4gICAgfSkgPT4gbWF0Y2hlcihhY3Rpb24pKS5tYXAoKHtcbiAgICAgIHJlZHVjZXI6IHJlZHVjZXIyXG4gICAgfSkgPT4gcmVkdWNlcjIpXTtcbiAgICBpZiAoY2FzZVJlZHVjZXJzLmZpbHRlcigoY3IpID0+ICEhY3IpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2FzZVJlZHVjZXJzID0gW2ZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXTtcbiAgICB9XG4gICAgcmV0dXJuIGNhc2VSZWR1Y2Vycy5yZWR1Y2UoKHByZXZpb3VzU3RhdGUsIGNhc2VSZWR1Y2VyKSA9PiB7XG4gICAgICBpZiAoY2FzZVJlZHVjZXIpIHtcbiAgICAgICAgaWYgKGlzRHJhZnQocHJldmlvdXNTdGF0ZSkpIHtcbiAgICAgICAgICBjb25zdCBkcmFmdCA9IHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FzZVJlZHVjZXIoZHJhZnQsIGFjdGlvbik7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmICghaXNEcmFmdGFibGUocHJldmlvdXNTdGF0ZSkpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihwcmV2aW91c1N0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkEgY2FzZSByZWR1Y2VyIG9uIGEgbm9uLWRyYWZ0YWJsZSB2YWx1ZSBtdXN0IG5vdCByZXR1cm4gdW5kZWZpbmVkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwcm9kdWNlKHByZXZpb3VzU3RhdGUsIChkcmFmdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNhc2VSZWR1Y2VyKGRyYWZ0LCBhY3Rpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcbiAgICB9LCBzdGF0ZSk7XG4gIH1cbiAgcmVkdWNlci5nZXRJbml0aWFsU3RhdGUgPSBnZXRJbml0aWFsU3RhdGU7XG4gIHJldHVybiByZWR1Y2VyO1xufVxuXG4vLyBzcmMvbWF0Y2hlcnMudHNcbnZhciBtYXRjaGVzID0gKG1hdGNoZXIsIGFjdGlvbikgPT4ge1xuICBpZiAoaGFzTWF0Y2hGdW5jdGlvbihtYXRjaGVyKSkge1xuICAgIHJldHVybiBtYXRjaGVyLm1hdGNoKGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1hdGNoZXIoYWN0aW9uKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGlzQW55T2YoLi4ubWF0Y2hlcnMpIHtcbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gbWF0Y2hlcnMuc29tZSgobWF0Y2hlcikgPT4gbWF0Y2hlcyhtYXRjaGVyLCBhY3Rpb24pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQWxsT2YoLi4ubWF0Y2hlcnMpIHtcbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gbWF0Y2hlcnMuZXZlcnkoKG1hdGNoZXIpID0+IG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKSk7XG4gIH07XG59XG5mdW5jdGlvbiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIHZhbGlkU3RhdHVzKSB7XG4gIGlmICghYWN0aW9uIHx8ICFhY3Rpb24ubWV0YSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBoYXNWYWxpZFJlcXVlc3RJZCA9IHR5cGVvZiBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQgPT09IFwic3RyaW5nXCI7XG4gIGNvbnN0IGhhc1ZhbGlkUmVxdWVzdFN0YXR1cyA9IHZhbGlkU3RhdHVzLmluZGV4T2YoYWN0aW9uLm1ldGEucmVxdWVzdFN0YXR1cykgPiAtMTtcbiAgcmV0dXJuIGhhc1ZhbGlkUmVxdWVzdElkICYmIGhhc1ZhbGlkUmVxdWVzdFN0YXR1cztcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FycmF5KGEpIHtcbiAgcmV0dXJuIHR5cGVvZiBhWzBdID09PSBcImZ1bmN0aW9uXCIgJiYgXCJwZW5kaW5nXCIgaW4gYVswXSAmJiBcImZ1bGZpbGxlZFwiIGluIGFbMF0gJiYgXCJyZWplY3RlZFwiIGluIGFbMF07XG59XG5mdW5jdGlvbiBpc1BlbmRpbmcoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInBlbmRpbmdcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzUGVuZGluZygpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gaXNBbnlPZiguLi5hc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsucGVuZGluZykpO1xufVxuZnVuY3Rpb24gaXNSZWplY3RlZCguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicmVqZWN0ZWRcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzUmVqZWN0ZWQoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIGlzQW55T2YoLi4uYXN5bmNUaHVua3MubWFwKChhc3luY1RodW5rKSA9PiBhc3luY1RodW5rLnJlamVjdGVkKSk7XG59XG5mdW5jdGlvbiBpc1JlamVjdGVkV2l0aFZhbHVlKC4uLmFzeW5jVGh1bmtzKSB7XG4gIGNvbnN0IGhhc0ZsYWcgPSAoYWN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIGFjdGlvbiAmJiBhY3Rpb24ubWV0YSAmJiBhY3Rpb24ubWV0YS5yZWplY3RlZFdpdGhWYWx1ZTtcbiAgfTtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBpc0FsbE9mKGlzUmVqZWN0ZWQoLi4uYXN5bmNUaHVua3MpLCBoYXNGbGFnKTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc1JlamVjdGVkV2l0aFZhbHVlKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiBpc0FsbE9mKGlzUmVqZWN0ZWQoLi4uYXN5bmNUaHVua3MpLCBoYXNGbGFnKTtcbn1cbmZ1bmN0aW9uIGlzRnVsZmlsbGVkKC4uLmFzeW5jVGh1bmtzKSB7XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJmdWxmaWxsZWRcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzRnVsZmlsbGVkKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiBpc0FueU9mKC4uLmFzeW5jVGh1bmtzLm1hcCgoYXN5bmNUaHVuaykgPT4gYXN5bmNUaHVuay5mdWxmaWxsZWQpKTtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FjdGlvbiguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiLCBcImZ1bGZpbGxlZFwiLCBcInJlamVjdGVkXCJdKTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc0FzeW5jVGh1bmtBY3Rpb24oKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIGlzQW55T2YoLi4uYXN5bmNUaHVua3MuZmxhdE1hcCgoYXN5bmNUaHVuaykgPT4gW2FzeW5jVGh1bmsucGVuZGluZywgYXN5bmNUaHVuay5yZWplY3RlZCwgYXN5bmNUaHVuay5mdWxmaWxsZWRdKSk7XG59XG5cbi8vIHNyYy9uYW5vaWQudHNcbnZhciB1cmxBbHBoYWJldCA9IFwiTW9kdWxlU3ltYmhhc093blByLTAxMjM0NTY3ODlBQkNERUZHSE5SVmZnY3RpVXZ6X0txWVRKa0x4cFpYSWpRV1wiO1xudmFyIG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gXCJcIjtcbiAgbGV0IGkgPSBzaXplO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWQgKz0gdXJsQWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XG4gIH1cbiAgcmV0dXJuIGlkO1xufTtcblxuLy8gc3JjL2NyZWF0ZUFzeW5jVGh1bmsudHNcbnZhciBjb21tb25Qcm9wZXJ0aWVzID0gW1wibmFtZVwiLCBcIm1lc3NhZ2VcIiwgXCJzdGFja1wiLCBcImNvZGVcIl07XG52YXIgUmVqZWN0V2l0aFZhbHVlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBtZXRhKSB7XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG4gIC8qXG4gIHR5cGUtb25seSBwcm9wZXJ0eSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIFJlamVjdFdpdGhWYWx1ZSBhbmQgRnVsZmlsbFdpdGhNZXRhXG4gIGRvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWVcbiAgKi9cbiAgX3R5cGU7XG59O1xudmFyIEZ1bGZpbGxXaXRoTWV0YSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocGF5bG9hZCwgbWV0YSkge1xuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgfVxuICAvKlxuICB0eXBlLW9ubHkgcHJvcGVydHkgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBSZWplY3RXaXRoVmFsdWUgYW5kIEZ1bGZpbGxXaXRoTWV0YVxuICBkb2VzIG5vdCBleGlzdCBhdCBydW50aW1lXG4gICovXG4gIF90eXBlO1xufTtcbnZhciBtaW5pU2VyaWFsaXplRXJyb3IgPSAodmFsdWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNpbXBsZUVycm9yID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBjb21tb25Qcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlW3Byb3BlcnR5XSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzaW1wbGVFcnJvcltwcm9wZXJ0eV0gPSB2YWx1ZVtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaW1wbGVFcnJvcjtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1lc3NhZ2U6IFN0cmluZyh2YWx1ZSlcbiAgfTtcbn07XG52YXIgZXh0ZXJuYWxBYm9ydE1lc3NhZ2UgPSBcIkV4dGVybmFsIHNpZ25hbCB3YXMgYWJvcnRlZFwiO1xudmFyIGNyZWF0ZUFzeW5jVGh1bmsgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgZnVuY3Rpb24gY3JlYXRlQXN5bmNUaHVuazIodHlwZVByZWZpeCwgcGF5bG9hZENyZWF0b3IsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmdWxmaWxsZWQgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL2Z1bGZpbGxlZFwiLCAocGF5bG9hZCwgcmVxdWVzdElkLCBhcmcsIG1ldGEpID0+ICh7XG4gICAgICBwYXlsb2FkLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi5tZXRhIHx8IHt9LFxuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmVxdWVzdFN0YXR1czogXCJmdWxmaWxsZWRcIlxuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCBwZW5kaW5nID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9wZW5kaW5nXCIsIChyZXF1ZXN0SWQsIGFyZywgbWV0YSkgPT4gKHtcbiAgICAgIHBheWxvYWQ6IHZvaWQgMCxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgLi4ubWV0YSB8fCB7fSxcbiAgICAgICAgYXJnLFxuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHJlcXVlc3RTdGF0dXM6IFwicGVuZGluZ1wiXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGNvbnN0IHJlamVjdGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9yZWplY3RlZFwiLCAoZXJyb3IsIHJlcXVlc3RJZCwgYXJnLCBwYXlsb2FkLCBtZXRhKSA9PiAoe1xuICAgICAgcGF5bG9hZCxcbiAgICAgIGVycm9yOiAob3B0aW9ucyAmJiBvcHRpb25zLnNlcmlhbGl6ZUVycm9yIHx8IG1pbmlTZXJpYWxpemVFcnJvcikoZXJyb3IgfHwgXCJSZWplY3RlZFwiKSxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgLi4ubWV0YSB8fCB7fSxcbiAgICAgICAgYXJnLFxuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHJlamVjdGVkV2l0aFZhbHVlOiAhIXBheWxvYWQsXG4gICAgICAgIHJlcXVlc3RTdGF0dXM6IFwicmVqZWN0ZWRcIixcbiAgICAgICAgYWJvcnRlZDogZXJyb3I/Lm5hbWUgPT09IFwiQWJvcnRFcnJvclwiLFxuICAgICAgICBjb25kaXRpb246IGVycm9yPy5uYW1lID09PSBcIkNvbmRpdGlvbkVycm9yXCJcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvcihhcmcsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0gPSB7fSkge1xuICAgICAgcmV0dXJuIChkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IG9wdGlvbnM/LmlkR2VuZXJhdG9yID8gb3B0aW9ucy5pZEdlbmVyYXRvcihhcmcpIDogbmFub2lkKCk7XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgbGV0IGFib3J0SGFuZGxlcjtcbiAgICAgICAgbGV0IGFib3J0UmVhc29uO1xuICAgICAgICBmdW5jdGlvbiBhYm9ydChyZWFzb24pIHtcbiAgICAgICAgICBhYm9ydFJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBhYm9ydChleHRlcm5hbEFib3J0TWVzc2FnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4gYWJvcnQoZXh0ZXJuYWxBYm9ydE1lc3NhZ2UpLCB7XG4gICAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGV0IGZpbmFsQWN0aW9uO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgY29uZGl0aW9uUmVzdWx0ID0gb3B0aW9ucz8uY29uZGl0aW9uPy4oYXJnLCB7XG4gICAgICAgICAgICAgIGdldFN0YXRlLFxuICAgICAgICAgICAgICBleHRyYVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaXNUaGVuYWJsZShjb25kaXRpb25SZXN1bHQpKSB7XG4gICAgICAgICAgICAgIGNvbmRpdGlvblJlc3VsdCA9IGF3YWl0IGNvbmRpdGlvblJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25kaXRpb25SZXN1bHQgPT09IGZhbHNlIHx8IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJDb25kaXRpb25FcnJvclwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQWJvcnRlZCBkdWUgdG8gY29uZGl0aW9uIGNhbGxiYWNrIHJldHVybmluZyBmYWxzZS5cIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWJvcnRlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgIGFib3J0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJBYm9ydEVycm9yXCIsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBhYm9ydFJlYXNvbiB8fCBcIkFib3J0ZWRcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydEhhbmRsZXIsIHtcbiAgICAgICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXNwYXRjaChwZW5kaW5nKHJlcXVlc3RJZCwgYXJnLCBvcHRpb25zPy5nZXRQZW5kaW5nTWV0YT8uKHtcbiAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICBhcmdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgICAgICAgIGV4dHJhXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgZmluYWxBY3Rpb24gPSBhd2FpdCBQcm9taXNlLnJhY2UoW2Fib3J0ZWRQcm9taXNlLCBQcm9taXNlLnJlc29sdmUocGF5bG9hZENyZWF0b3IoYXJnLCB7XG4gICAgICAgICAgICAgIGRpc3BhdGNoLFxuICAgICAgICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICAgICAgcmVqZWN0V2l0aFZhbHVlOiAodmFsdWUsIG1ldGEpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlamVjdFdpdGhWYWx1ZSh2YWx1ZSwgbWV0YSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bGZpbGxXaXRoVmFsdWU6ICh2YWx1ZSwgbWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRnVsZmlsbFdpdGhNZXRhKHZhbHVlLCBtZXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVqZWN0V2l0aFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBGdWxmaWxsV2l0aE1ldGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkKHJlc3VsdC5wYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgcmVzdWx0Lm1ldGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LCByZXF1ZXN0SWQsIGFyZyk7XG4gICAgICAgICAgICB9KV0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZmluYWxBY3Rpb24gPSBlcnIgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUgPyByZWplY3RlZChudWxsLCByZXF1ZXN0SWQsIGFyZywgZXJyLnBheWxvYWQsIGVyci5tZXRhKSA6IHJlamVjdGVkKGVyciwgcmVxdWVzdElkLCBhcmcpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoYWJvcnRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNraXBEaXNwYXRjaCA9IG9wdGlvbnMgJiYgIW9wdGlvbnMuZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24gJiYgcmVqZWN0ZWQubWF0Y2goZmluYWxBY3Rpb24pICYmIGZpbmFsQWN0aW9uLm1ldGEuY29uZGl0aW9uO1xuICAgICAgICAgIGlmICghc2tpcERpc3BhdGNoKSB7XG4gICAgICAgICAgICBkaXNwYXRjaChmaW5hbEFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmaW5hbEFjdGlvbjtcbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihwcm9taXNlLCB7XG4gICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgIGFyZyxcbiAgICAgICAgICB1bndyYXAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKHVud3JhcFJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjdGlvbkNyZWF0b3IsIHtcbiAgICAgIHBlbmRpbmcsXG4gICAgICByZWplY3RlZCxcbiAgICAgIGZ1bGZpbGxlZCxcbiAgICAgIHNldHRsZWQ6IGlzQW55T2YocmVqZWN0ZWQsIGZ1bGZpbGxlZCksXG4gICAgICB0eXBlUHJlZml4XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlQXN5bmNUaHVuazIud2l0aFR5cGVzID0gKCkgPT4gY3JlYXRlQXN5bmNUaHVuazI7XG4gIHJldHVybiBjcmVhdGVBc3luY1RodW5rMjtcbn0pKCk7XG5mdW5jdGlvbiB1bndyYXBSZXN1bHQoYWN0aW9uKSB7XG4gIGlmIChhY3Rpb24ubWV0YSAmJiBhY3Rpb24ubWV0YS5yZWplY3RlZFdpdGhWYWx1ZSkge1xuICAgIHRocm93IGFjdGlvbi5wYXlsb2FkO1xuICB9XG4gIGlmIChhY3Rpb24uZXJyb3IpIHtcbiAgICB0aHJvdyBhY3Rpb24uZXJyb3I7XG4gIH1cbiAgcmV0dXJuIGFjdGlvbi5wYXlsb2FkO1xufVxuZnVuY3Rpb24gaXNUaGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8vIHNyYy9jcmVhdGVTbGljZS50c1xudmFyIGFzeW5jVGh1bmtTeW1ib2wgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJ0ay1zbGljZS1jcmVhdGVhc3luY3RodW5rXCIpO1xudmFyIGFzeW5jVGh1bmtDcmVhdG9yID0ge1xuICBbYXN5bmNUaHVua1N5bWJvbF06IGNyZWF0ZUFzeW5jVGh1bmtcbn07XG52YXIgUmVkdWNlclR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChSZWR1Y2VyVHlwZTIpID0+IHtcbiAgUmVkdWNlclR5cGUyW1wicmVkdWNlclwiXSA9IFwicmVkdWNlclwiO1xuICBSZWR1Y2VyVHlwZTJbXCJyZWR1Y2VyV2l0aFByZXBhcmVcIl0gPSBcInJlZHVjZXJXaXRoUHJlcGFyZVwiO1xuICBSZWR1Y2VyVHlwZTJbXCJhc3luY1RodW5rXCJdID0gXCJhc3luY1RodW5rXCI7XG4gIHJldHVybiBSZWR1Y2VyVHlwZTI7XG59KShSZWR1Y2VyVHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBnZXRUeXBlKHNsaWNlLCBhY3Rpb25LZXkpIHtcbiAgcmV0dXJuIGAke3NsaWNlfS8ke2FjdGlvbktleX1gO1xufVxuZnVuY3Rpb24gYnVpbGRDcmVhdGVTbGljZSh7XG4gIGNyZWF0b3JzXG59ID0ge30pIHtcbiAgY29uc3QgY0FUID0gY3JlYXRvcnM/LmFzeW5jVGh1bms/Llthc3luY1RodW5rU3ltYm9sXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVNsaWNlMihvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHJlZHVjZXJQYXRoID0gbmFtZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTEpIDogXCJgbmFtZWAgaXMgYSByZXF1aXJlZCBvcHRpb24gZm9yIGNyZWF0ZVNsaWNlXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgaWYgKG9wdGlvbnMuaW5pdGlhbFN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIllvdSBtdXN0IHByb3ZpZGUgYW4gYGluaXRpYWxTdGF0ZWAgdmFsdWUgdGhhdCBpcyBub3QgYHVuZGVmaW5lZGAuIFlvdSBtYXkgaGF2ZSBtaXNzcGVsbGVkIGBpbml0aWFsU3RhdGVgXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZWR1Y2VycyA9ICh0eXBlb2Ygb3B0aW9ucy5yZWR1Y2VycyA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5yZWR1Y2VycyhidWlsZFJlZHVjZXJDcmVhdG9ycygpKSA6IG9wdGlvbnMucmVkdWNlcnMpIHx8IHt9O1xuICAgIGNvbnN0IHJlZHVjZXJOYW1lcyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWU6IHt9LFxuICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGU6IHt9LFxuICAgICAgYWN0aW9uQ3JlYXRvcnM6IHt9LFxuICAgICAgc2xpY2VNYXRjaGVyczogW11cbiAgICB9O1xuICAgIGNvbnN0IGNvbnRleHRNZXRob2RzID0ge1xuICAgICAgYWRkQ2FzZSh0eXBlT3JBY3Rpb25DcmVhdG9yLCByZWR1Y2VyMikge1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHR5cGVPckFjdGlvbkNyZWF0b3IgPT09IFwic3RyaW5nXCIgPyB0eXBlT3JBY3Rpb25DcmVhdG9yIDogdHlwZU9yQWN0aW9uQ3JlYXRvci50eXBlO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMikgOiBcImBjb250ZXh0LmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBhbiBlbXB0eSBhY3Rpb24gdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSBpbiBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTMpIDogXCJgY29udGV4dC5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggdHdvIHJlZHVjZXJzIGZvciB0aGUgc2FtZSBhY3Rpb24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlW3R5cGVdID0gcmVkdWNlcjI7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH0sXG4gICAgICBhZGRNYXRjaGVyKG1hdGNoZXIsIHJlZHVjZXIyKSB7XG4gICAgICAgIGNvbnRleHQuc2xpY2VNYXRjaGVycy5wdXNoKHtcbiAgICAgICAgICBtYXRjaGVyLFxuICAgICAgICAgIHJlZHVjZXI6IHJlZHVjZXIyXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuICAgICAgZXhwb3NlQWN0aW9uKG5hbWUyLCBhY3Rpb25DcmVhdG9yKSB7XG4gICAgICAgIGNvbnRleHQuYWN0aW9uQ3JlYXRvcnNbbmFtZTJdID0gYWN0aW9uQ3JlYXRvcjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfSxcbiAgICAgIGV4cG9zZUNhc2VSZWR1Y2VyKG5hbWUyLCByZWR1Y2VyMikge1xuICAgICAgICBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lW25hbWUyXSA9IHJlZHVjZXIyO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9XG4gICAgfTtcbiAgICByZWR1Y2VyTmFtZXMuZm9yRWFjaCgocmVkdWNlck5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHJlZHVjZXJEZWZpbml0aW9uID0gcmVkdWNlcnNbcmVkdWNlck5hbWVdO1xuICAgICAgY29uc3QgcmVkdWNlckRldGFpbHMgPSB7XG4gICAgICAgIHJlZHVjZXJOYW1lLFxuICAgICAgICB0eXBlOiBnZXRUeXBlKG5hbWUsIHJlZHVjZXJOYW1lKSxcbiAgICAgICAgY3JlYXRlTm90YXRpb246IHR5cGVvZiBvcHRpb25zLnJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCJcbiAgICAgIH07XG4gICAgICBpZiAoaXNBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbihyZWR1Y2VyRGVmaW5pdGlvbikpIHtcbiAgICAgICAgaGFuZGxlVGh1bmtDYXNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRldGFpbHMsIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0TWV0aG9kcywgY0FUKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZU5vcm1hbFJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZXRhaWxzLCByZWR1Y2VyRGVmaW5pdGlvbiwgY29udGV4dE1ldGhvZHMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGJ1aWxkUmVkdWNlcigpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNCkgOiBcIlRoZSBvYmplY3Qgbm90YXRpb24gZm9yIGBjcmVhdGVTbGljZS5leHRyYVJlZHVjZXJzYCBoYXMgYmVlbiByZW1vdmVkLiBQbGVhc2UgdXNlIHRoZSAnYnVpbGRlciBjYWxsYmFjaycgbm90YXRpb24gaW5zdGVhZDogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvY3JlYXRlU2xpY2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IFtleHRyYVJlZHVjZXJzID0ge30sIGFjdGlvbk1hdGNoZXJzID0gW10sIGRlZmF1bHRDYXNlUmVkdWNlciA9IHZvaWQgMF0gPSB0eXBlb2Ygb3B0aW9ucy5leHRyYVJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhvcHRpb25zLmV4dHJhUmVkdWNlcnMpIDogW29wdGlvbnMuZXh0cmFSZWR1Y2Vyc107XG4gICAgICBjb25zdCBmaW5hbENhc2VSZWR1Y2VycyA9IHtcbiAgICAgICAgLi4uZXh0cmFSZWR1Y2VycyxcbiAgICAgICAgLi4uY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBjcmVhdGVSZWR1Y2VyKG9wdGlvbnMuaW5pdGlhbFN0YXRlLCAoYnVpbGRlcikgPT4ge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gZmluYWxDYXNlUmVkdWNlcnMpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZENhc2Uoa2V5LCBmaW5hbENhc2VSZWR1Y2Vyc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzTSBvZiBjb250ZXh0LnNsaWNlTWF0Y2hlcnMpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZE1hdGNoZXIoc00ubWF0Y2hlciwgc00ucmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbSBvZiBhY3Rpb25NYXRjaGVycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkTWF0Y2hlcihtLm1hdGNoZXIsIG0ucmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkRGVmYXVsdENhc2UoZGVmYXVsdENhc2VSZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdFNlbGYgPSAoc3RhdGUpID0+IHN0YXRlO1xuICAgIGNvbnN0IGluamVjdGVkU2VsZWN0b3JDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgaW5qZWN0ZWRTdGF0ZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgbGV0IF9yZWR1Y2VyO1xuICAgIGZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgICAgaWYgKCFfcmVkdWNlcikgX3JlZHVjZXIgPSBidWlsZFJlZHVjZXIoKTtcbiAgICAgIHJldHVybiBfcmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgaWYgKCFfcmVkdWNlcikgX3JlZHVjZXIgPSBidWlsZFJlZHVjZXIoKTtcbiAgICAgIHJldHVybiBfcmVkdWNlci5nZXRJbml0aWFsU3RhdGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVNlbGVjdG9yUHJvcHMocmVkdWNlclBhdGgyLCBpbmplY3RlZCA9IGZhbHNlKSB7XG4gICAgICBmdW5jdGlvbiBzZWxlY3RTbGljZShzdGF0ZSkge1xuICAgICAgICBsZXQgc2xpY2VTdGF0ZSA9IHN0YXRlW3JlZHVjZXJQYXRoMl07XG4gICAgICAgIGlmICh0eXBlb2Ygc2xpY2VTdGF0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgICAgICAgc2xpY2VTdGF0ZSA9IGdldE9ySW5zZXJ0Q29tcHV0ZWQoaW5qZWN0ZWRTdGF0ZUNhY2hlLCBzZWxlY3RTbGljZSwgZ2V0SW5pdGlhbFN0YXRlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTUpIDogXCJzZWxlY3RTbGljZSByZXR1cm5lZCB1bmRlZmluZWQgZm9yIGFuIHVuaW5qZWN0ZWQgc2xpY2UgcmVkdWNlclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNsaWNlU3RhdGU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnZXRTZWxlY3RvcnMoc2VsZWN0U3RhdGUgPSBzZWxlY3RTZWxmKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yQ2FjaGUgPSBnZXRPckluc2VydENvbXB1dGVkKGluamVjdGVkU2VsZWN0b3JDYWNoZSwgaW5qZWN0ZWQsICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgICAgICAgcmV0dXJuIGdldE9ySW5zZXJ0Q29tcHV0ZWQoc2VsZWN0b3JDYWNoZSwgc2VsZWN0U3RhdGUsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lMiwgc2VsZWN0b3JdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuc2VsZWN0b3JzID8/IHt9KSkge1xuICAgICAgICAgICAgbWFwW25hbWUyXSA9IHdyYXBTZWxlY3RvcihzZWxlY3Rvciwgc2VsZWN0U3RhdGUsICgpID0+IGdldE9ySW5zZXJ0Q29tcHV0ZWQoaW5qZWN0ZWRTdGF0ZUNhY2hlLCBzZWxlY3RTdGF0ZSwgZ2V0SW5pdGlhbFN0YXRlKSwgaW5qZWN0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZHVjZXJQYXRoOiByZWR1Y2VyUGF0aDIsXG4gICAgICAgIGdldFNlbGVjdG9ycyxcbiAgICAgICAgZ2V0IHNlbGVjdG9ycygpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0U2VsZWN0b3JzKHNlbGVjdFNsaWNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0U2xpY2VcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHNsaWNlID0ge1xuICAgICAgbmFtZSxcbiAgICAgIHJlZHVjZXIsXG4gICAgICBhY3Rpb25zOiBjb250ZXh0LmFjdGlvbkNyZWF0b3JzLFxuICAgICAgY2FzZVJlZHVjZXJzOiBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lLFxuICAgICAgZ2V0SW5pdGlhbFN0YXRlLFxuICAgICAgLi4ubWFrZVNlbGVjdG9yUHJvcHMocmVkdWNlclBhdGgpLFxuICAgICAgaW5qZWN0SW50byhpbmplY3RhYmxlLCB7XG4gICAgICAgIHJlZHVjZXJQYXRoOiBwYXRoT3B0LFxuICAgICAgICAuLi5jb25maWdcbiAgICAgIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBuZXdSZWR1Y2VyUGF0aCA9IHBhdGhPcHQgPz8gcmVkdWNlclBhdGg7XG4gICAgICAgIGluamVjdGFibGUuaW5qZWN0KHtcbiAgICAgICAgICByZWR1Y2VyUGF0aDogbmV3UmVkdWNlclBhdGgsXG4gICAgICAgICAgcmVkdWNlclxuICAgICAgICB9LCBjb25maWcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnNsaWNlLFxuICAgICAgICAgIC4uLm1ha2VTZWxlY3RvclByb3BzKG5ld1JlZHVjZXJQYXRoLCB0cnVlKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHNsaWNlO1xuICB9O1xufVxuZnVuY3Rpb24gd3JhcFNlbGVjdG9yKHNlbGVjdG9yLCBzZWxlY3RTdGF0ZSwgZ2V0SW5pdGlhbFN0YXRlLCBpbmplY3RlZCkge1xuICBmdW5jdGlvbiB3cmFwcGVyKHJvb3RTdGF0ZSwgLi4uYXJncykge1xuICAgIGxldCBzbGljZVN0YXRlID0gc2VsZWN0U3RhdGUocm9vdFN0YXRlKTtcbiAgICBpZiAodHlwZW9mIHNsaWNlU3RhdGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgICBzbGljZVN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNikgOiBcInNlbGVjdFN0YXRlIHJldHVybmVkIHVuZGVmaW5lZCBmb3IgYW4gdW5pbmplY3RlZCBzbGljZSByZWR1Y2VyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3Ioc2xpY2VTdGF0ZSwgLi4uYXJncyk7XG4gIH1cbiAgd3JhcHBlci51bndyYXBwZWQgPSBzZWxlY3RvcjtcbiAgcmV0dXJuIHdyYXBwZXI7XG59XG52YXIgY3JlYXRlU2xpY2UgPSAvKiBAX19QVVJFX18gKi8gYnVpbGRDcmVhdGVTbGljZSgpO1xuZnVuY3Rpb24gYnVpbGRSZWR1Y2VyQ3JlYXRvcnMoKSB7XG4gIGZ1bmN0aW9uIGFzeW5jVGh1bmsocGF5bG9hZENyZWF0b3IsIGNvbmZpZykge1xuICAgIHJldHVybiB7XG4gICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcImFzeW5jVGh1bmtcIiAvKiBhc3luY1RodW5rICovLFxuICAgICAgcGF5bG9hZENyZWF0b3IsXG4gICAgICAuLi5jb25maWdcbiAgICB9O1xuICB9XG4gIGFzeW5jVGh1bmsud2l0aFR5cGVzID0gKCkgPT4gYXN5bmNUaHVuaztcbiAgcmV0dXJuIHtcbiAgICByZWR1Y2VyKGNhc2VSZWR1Y2VyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIC8vIGhhY2sgc28gdGhlIHdyYXBwaW5nIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBuYW1lIGFzIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHdyYXBwZXIgc28gdGhlIGByZWR1Y2VyRGVmaW5pdGlvblR5cGVgIGlzIG5vdCBhc3NpZ25lZCB0byB0aGUgb3JpZ2luYWxcbiAgICAgICAgW2Nhc2VSZWR1Y2VyLm5hbWVdKC4uLmFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1bY2FzZVJlZHVjZXIubmFtZV0sIHtcbiAgICAgICAgX3JlZHVjZXJEZWZpbml0aW9uVHlwZTogXCJyZWR1Y2VyXCIgLyogcmVkdWNlciAqL1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwcmVwYXJlZFJlZHVjZXIocHJlcGFyZSwgcmVkdWNlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3JlZHVjZXJEZWZpbml0aW9uVHlwZTogXCJyZWR1Y2VyV2l0aFByZXBhcmVcIiAvKiByZWR1Y2VyV2l0aFByZXBhcmUgKi8sXG4gICAgICAgIHByZXBhcmUsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgIH07XG4gICAgfSxcbiAgICBhc3luY1RodW5rXG4gIH07XG59XG5mdW5jdGlvbiBoYW5kbGVOb3JtYWxSZWR1Y2VyRGVmaW5pdGlvbih7XG4gIHR5cGUsXG4gIHJlZHVjZXJOYW1lLFxuICBjcmVhdGVOb3RhdGlvblxufSwgbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUsIGNvbnRleHQpIHtcbiAgbGV0IGNhc2VSZWR1Y2VyO1xuICBsZXQgcHJlcGFyZUNhbGxiYWNrO1xuICBpZiAoXCJyZWR1Y2VyXCIgaW4gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpIHtcbiAgICBpZiAoY3JlYXRlTm90YXRpb24gJiYgIWlzQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZURlZmluaXRpb24obWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNykgOiBcIlBsZWFzZSB1c2UgdGhlIGBjcmVhdGUucHJlcGFyZWRSZWR1Y2VyYCBub3RhdGlvbiBmb3IgcHJlcGFyZWQgYWN0aW9uIGNyZWF0b3JzIHdpdGggdGhlIGBjcmVhdGVgIG5vdGF0aW9uLlwiKTtcbiAgICB9XG4gICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5yZWR1Y2VyO1xuICAgIHByZXBhcmVDYWxsYmFjayA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLnByZXBhcmU7XG4gIH0gZWxzZSB7XG4gICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZTtcbiAgfVxuICBjb250ZXh0LmFkZENhc2UodHlwZSwgY2FzZVJlZHVjZXIpLmV4cG9zZUNhc2VSZWR1Y2VyKHJlZHVjZXJOYW1lLCBjYXNlUmVkdWNlcikuZXhwb3NlQWN0aW9uKHJlZHVjZXJOYW1lLCBwcmVwYXJlQ2FsbGJhY2sgPyBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUNhbGxiYWNrKSA6IGNyZWF0ZUFjdGlvbih0eXBlKSk7XG59XG5mdW5jdGlvbiBpc0FzeW5jVGh1bmtTbGljZVJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSB7XG4gIHJldHVybiByZWR1Y2VyRGVmaW5pdGlvbi5fcmVkdWNlckRlZmluaXRpb25UeXBlID09PSBcImFzeW5jVGh1bmtcIiAvKiBhc3luY1RodW5rICovO1xufVxuZnVuY3Rpb24gaXNDYXNlUmVkdWNlcldpdGhQcmVwYXJlRGVmaW5pdGlvbihyZWR1Y2VyRGVmaW5pdGlvbikge1xuICByZXR1cm4gcmVkdWNlckRlZmluaXRpb24uX3JlZHVjZXJEZWZpbml0aW9uVHlwZSA9PT0gXCJyZWR1Y2VyV2l0aFByZXBhcmVcIiAvKiByZWR1Y2VyV2l0aFByZXBhcmUgKi87XG59XG5mdW5jdGlvbiBoYW5kbGVUaHVua0Nhc2VSZWR1Y2VyRGVmaW5pdGlvbih7XG4gIHR5cGUsXG4gIHJlZHVjZXJOYW1lXG59LCByZWR1Y2VyRGVmaW5pdGlvbiwgY29udGV4dCwgY0FUKSB7XG4gIGlmICghY0FUKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTgpIDogXCJDYW5ub3QgdXNlIGBjcmVhdGUuYXN5bmNUaHVua2AgaW4gdGhlIGJ1aWx0LWluIGBjcmVhdGVTbGljZWAuIFVzZSBgYnVpbGRDcmVhdGVTbGljZSh7IGNyZWF0b3JzOiB7IGFzeW5jVGh1bms6IGFzeW5jVGh1bmtDcmVhdG9yIH0gfSlgIHRvIGNyZWF0ZSBhIGN1c3RvbWlzZWQgdmVyc2lvbiBvZiBgY3JlYXRlU2xpY2VgLlwiKTtcbiAgfVxuICBjb25zdCB7XG4gICAgcGF5bG9hZENyZWF0b3IsXG4gICAgZnVsZmlsbGVkLFxuICAgIHBlbmRpbmcsXG4gICAgcmVqZWN0ZWQsXG4gICAgc2V0dGxlZCxcbiAgICBvcHRpb25zXG4gIH0gPSByZWR1Y2VyRGVmaW5pdGlvbjtcbiAgY29uc3QgdGh1bmsgPSBjQVQodHlwZSwgcGF5bG9hZENyZWF0b3IsIG9wdGlvbnMpO1xuICBjb250ZXh0LmV4cG9zZUFjdGlvbihyZWR1Y2VyTmFtZSwgdGh1bmspO1xuICBpZiAoZnVsZmlsbGVkKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLmZ1bGZpbGxlZCwgZnVsZmlsbGVkKTtcbiAgfVxuICBpZiAocGVuZGluZykge1xuICAgIGNvbnRleHQuYWRkQ2FzZSh0aHVuay5wZW5kaW5nLCBwZW5kaW5nKTtcbiAgfVxuICBpZiAocmVqZWN0ZWQpIHtcbiAgICBjb250ZXh0LmFkZENhc2UodGh1bmsucmVqZWN0ZWQsIHJlamVjdGVkKTtcbiAgfVxuICBpZiAoc2V0dGxlZCkge1xuICAgIGNvbnRleHQuYWRkTWF0Y2hlcih0aHVuay5zZXR0bGVkLCBzZXR0bGVkKTtcbiAgfVxuICBjb250ZXh0LmV4cG9zZUNhc2VSZWR1Y2VyKHJlZHVjZXJOYW1lLCB7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQgfHwgbm9vcCxcbiAgICBwZW5kaW5nOiBwZW5kaW5nIHx8IG5vb3AsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkIHx8IG5vb3AsXG4gICAgc2V0dGxlZDogc2V0dGxlZCB8fCBub29wXG4gIH0pO1xufVxuZnVuY3Rpb24gbm9vcCgpIHtcbn1cblxuLy8gc3JjL2VudGl0aWVzL2VudGl0eV9zdGF0ZS50c1xuZnVuY3Rpb24gZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCkge1xuICByZXR1cm4ge1xuICAgIGlkczogW10sXG4gICAgZW50aXRpZXM6IHt9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5KHN0YXRlQWRhcHRlcikge1xuICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoYWRkaXRpb25hbFN0YXRlID0ge30sIGVudGl0aWVzKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBPYmplY3QuYXNzaWduKGdldEluaXRpYWxFbnRpdHlTdGF0ZSgpLCBhZGRpdGlvbmFsU3RhdGUpO1xuICAgIHJldHVybiBlbnRpdGllcyA/IHN0YXRlQWRhcHRlci5zZXRBbGwoc3RhdGUsIGVudGl0aWVzKSA6IHN0YXRlO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0SW5pdGlhbFN0YXRlXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9zdGF0ZV9zZWxlY3RvcnMudHNcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKSB7XG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9ycyhzZWxlY3RTdGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgY3JlYXRlU2VsZWN0b3I6IGNyZWF0ZVNlbGVjdG9yMiA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc2VsZWN0SWRzID0gKHN0YXRlKSA9PiBzdGF0ZS5pZHM7XG4gICAgY29uc3Qgc2VsZWN0RW50aXRpZXMgPSAoc3RhdGUpID0+IHN0YXRlLmVudGl0aWVzO1xuICAgIGNvbnN0IHNlbGVjdEFsbCA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RJZHMsIHNlbGVjdEVudGl0aWVzLCAoaWRzLCBlbnRpdGllcykgPT4gaWRzLm1hcCgoaWQpID0+IGVudGl0aWVzW2lkXSkpO1xuICAgIGNvbnN0IHNlbGVjdElkID0gKF8sIGlkKSA9PiBpZDtcbiAgICBjb25zdCBzZWxlY3RCeUlkID0gKGVudGl0aWVzLCBpZCkgPT4gZW50aXRpZXNbaWRdO1xuICAgIGNvbnN0IHNlbGVjdFRvdGFsID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdElkcywgKGlkcykgPT4gaWRzLmxlbmd0aCk7XG4gICAgaWYgKCFzZWxlY3RTdGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0SWRzLFxuICAgICAgICBzZWxlY3RFbnRpdGllcyxcbiAgICAgICAgc2VsZWN0QWxsLFxuICAgICAgICBzZWxlY3RUb3RhbCxcbiAgICAgICAgc2VsZWN0QnlJZDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdEVudGl0aWVzLCBzZWxlY3RJZCwgc2VsZWN0QnlJZClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0RW50aXRpZXMpO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RJZHM6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0SWRzKSxcbiAgICAgIHNlbGVjdEVudGl0aWVzOiBzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsXG4gICAgICBzZWxlY3RBbGw6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0QWxsKSxcbiAgICAgIHNlbGVjdFRvdGFsOiBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0U3RhdGUsIHNlbGVjdFRvdGFsKSxcbiAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRTZWxlY3RvcnNcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX2FkYXB0ZXIudHNcbnZhciBpc0RyYWZ0VHlwZWQgPSBpc0RyYWZ0O1xuZnVuY3Rpb24gY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yKG11dGF0b3IpIHtcbiAgY29uc3Qgb3BlcmF0b3IgPSBjcmVhdGVTdGF0ZU9wZXJhdG9yKChfLCBzdGF0ZSkgPT4gbXV0YXRvcihzdGF0ZSkpO1xuICByZXR1cm4gZnVuY3Rpb24gb3BlcmF0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIG9wZXJhdG9yKHN0YXRlLCB2b2lkIDApO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGVPcGVyYXRvcihtdXRhdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUsIGFyZykge1xuICAgIGZ1bmN0aW9uIGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KGFyZzIpIHtcbiAgICAgIHJldHVybiBpc0ZTQShhcmcyKTtcbiAgICB9XG4gICAgY29uc3QgcnVuTXV0YXRvciA9IChkcmFmdCkgPT4ge1xuICAgICAgaWYgKGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KGFyZykpIHtcbiAgICAgICAgbXV0YXRvcihhcmcucGF5bG9hZCwgZHJhZnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXV0YXRvcihhcmcsIGRyYWZ0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0RyYWZ0VHlwZWQoc3RhdGUpKSB7XG4gICAgICBydW5NdXRhdG9yKHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2R1Y2Uoc3RhdGUsIHJ1bk11dGF0b3IpO1xuICB9O1xufVxuXG4vLyBzcmMvZW50aXRpZXMvdXRpbHMudHNcbmZ1bmN0aW9uIHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCkge1xuICBjb25zdCBrZXkgPSBzZWxlY3RJZChlbnRpdHkpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGtleSA9PT0gdm9pZCAwKSB7XG4gICAgY29uc29sZS53YXJuKFwiVGhlIGVudGl0eSBwYXNzZWQgdG8gdGhlIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgdW5kZWZpbmVkLlwiLCBcIllvdSBzaG91bGQgcHJvYmFibHkgcHJvdmlkZSB5b3VyIG93biBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uLlwiLCBcIlRoZSBlbnRpdHkgdGhhdCB3YXMgcGFzc2VkOlwiLCBlbnRpdHksIFwiVGhlIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb246XCIsIHNlbGVjdElkLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiBlbnN1cmVFbnRpdGllc0FycmF5KGVudGl0aWVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShlbnRpdGllcykpIHtcbiAgICBlbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoZW50aXRpZXMpO1xuICB9XG4gIHJldHVybiBlbnRpdGllcztcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnQodmFsdWUpIHtcbiAgcmV0dXJuIGlzRHJhZnQodmFsdWUpID8gY3VycmVudCh2YWx1ZSkgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSkge1xuICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICBjb25zdCBleGlzdGluZ0lkc0FycmF5ID0gZ2V0Q3VycmVudChzdGF0ZS5pZHMpO1xuICBjb25zdCBleGlzdGluZ0lkcyA9IG5ldyBTZXQoZXhpc3RpbmdJZHNBcnJheSk7XG4gIGNvbnN0IGFkZGVkID0gW107XG4gIGNvbnN0IGFkZGVkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW10pO1xuICBjb25zdCB1cGRhdGVkID0gW107XG4gIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld0VudGl0aWVzKSB7XG4gICAgY29uc3QgaWQgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuICAgIGlmIChleGlzdGluZ0lkcy5oYXMoaWQpIHx8IGFkZGVkSWRzLmhhcyhpZCkpIHtcbiAgICAgIHVwZGF0ZWQucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICBjaGFuZ2VzOiBlbnRpdHlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGRlZElkcy5hZGQoaWQpO1xuICAgICAgYWRkZWQucHVzaChlbnRpdHkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2FkZGVkLCB1cGRhdGVkLCBleGlzdGluZ0lkc0FycmF5XTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3Vuc29ydGVkX3N0YXRlX2FkYXB0ZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKSB7XG4gIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIGNvbnN0IGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XG4gICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGF0ZS5pZHMucHVzaChrZXkpO1xuICAgIHN0YXRlLmVudGl0aWVzW2tleV0gPSBlbnRpdHk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgICAgYWRkT25lTXV0YWJseShlbnRpdHksIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgY29uc3Qga2V5ID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcbiAgICBpZiAoIShrZXkgaW4gc3RhdGUuZW50aXRpZXMpKSB7XG4gICAgICBzdGF0ZS5pZHMucHVzaChrZXkpO1xuICAgIH1cbiAgICA7XG4gICAgc3RhdGUuZW50aXRpZXNba2V5XSA9IGVudGl0eTtcbiAgfVxuICBmdW5jdGlvbiBzZXRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld0VudGl0aWVzKSB7XG4gICAgICBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRBbGxNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgc3RhdGUuaWRzID0gW107XG4gICAgc3RhdGUuZW50aXRpZXMgPSB7fTtcbiAgICBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU9uZU11dGFibHkoa2V5LCBzdGF0ZSkge1xuICAgIHJldHVybiByZW1vdmVNYW55TXV0YWJseShba2V5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU1hbnlNdXRhYmx5KGtleXMsIHN0YXRlKSB7XG4gICAgbGV0IGRpZE11dGF0ZSA9IGZhbHNlO1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1trZXldO1xuICAgICAgICBkaWRNdXRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkaWRNdXRhdGUpIHtcbiAgICAgIHN0YXRlLmlkcyA9IHN0YXRlLmlkcy5maWx0ZXIoKGlkKSA9PiBpZCBpbiBzdGF0ZS5lbnRpdGllcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUFsbE11dGFibHkoc3RhdGUpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLCB7XG4gICAgICBpZHM6IFtdLFxuICAgICAgZW50aXRpZXM6IHt9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdGFrZU5ld0tleShrZXlzLCB1cGRhdGUsIHN0YXRlKSB7XG4gICAgY29uc3Qgb3JpZ2luYWwzID0gc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICBpZiAob3JpZ2luYWwzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsMywgdXBkYXRlLmNoYW5nZXMpO1xuICAgIGNvbnN0IG5ld0tleSA9IHNlbGVjdElkVmFsdWUodXBkYXRlZCwgc2VsZWN0SWQpO1xuICAgIGNvbnN0IGhhc05ld0tleSA9IG5ld0tleSAhPT0gdXBkYXRlLmlkO1xuICAgIGlmIChoYXNOZXdLZXkpIHtcbiAgICAgIGtleXNbdXBkYXRlLmlkXSA9IG5ld0tleTtcbiAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgIH1cbiAgICA7XG4gICAgc3RhdGUuZW50aXRpZXNbbmV3S2V5XSA9IHVwZGF0ZWQ7XG4gICAgcmV0dXJuIGhhc05ld0tleTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzLCBzdGF0ZSkge1xuICAgIGNvbnN0IG5ld0tleXMgPSB7fTtcbiAgICBjb25zdCB1cGRhdGVzUGVyRW50aXR5ID0ge307XG4gICAgdXBkYXRlcy5mb3JFYWNoKCh1cGRhdGUpID0+IHtcbiAgICAgIGlmICh1cGRhdGUuaWQgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgICAgdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID0ge1xuICAgICAgICAgIGlkOiB1cGRhdGUuaWQsXG4gICAgICAgICAgLy8gU3ByZWFkcyBpZ25vcmUgZmFsc3kgdmFsdWVzLCBzbyB0aGlzIHdvcmtzIGV2ZW4gaWYgdGhlcmUgaXNuJ3RcbiAgICAgICAgICAvLyBhbiBleGlzdGluZyB1cGRhdGUgYWxyZWFkeSBhdCB0aGlzIGtleVxuICAgICAgICAgIGNoYW5nZXM6IHtcbiAgICAgICAgICAgIC4uLnVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXT8uY2hhbmdlcyxcbiAgICAgICAgICAgIC4uLnVwZGF0ZS5jaGFuZ2VzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVwZGF0ZXMgPSBPYmplY3QudmFsdWVzKHVwZGF0ZXNQZXJFbnRpdHkpO1xuICAgIGNvbnN0IGRpZE11dGF0ZUVudGl0aWVzID0gdXBkYXRlcy5sZW5ndGggPiAwO1xuICAgIGlmIChkaWRNdXRhdGVFbnRpdGllcykge1xuICAgICAgY29uc3QgZGlkTXV0YXRlSWRzID0gdXBkYXRlcy5maWx0ZXIoKHVwZGF0ZSkgPT4gdGFrZU5ld0tleShuZXdLZXlzLCB1cGRhdGUsIHN0YXRlKSkubGVuZ3RoID4gMDtcbiAgICAgIGlmIChkaWRNdXRhdGVJZHMpIHtcbiAgICAgICAgc3RhdGUuaWRzID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5lbnRpdGllcykubWFwKChlKSA9PiBzZWxlY3RJZFZhbHVlKGUsIHNlbGVjdElkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIGNvbnN0IFthZGRlZCwgdXBkYXRlZF0gPSBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpO1xuICAgIGFkZE1hbnlNdXRhYmx5KGFkZGVkLCBzdGF0ZSk7XG4gICAgdXBkYXRlTWFueU11dGFibHkodXBkYXRlZCwgc3RhdGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVtb3ZlQWxsOiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IocmVtb3ZlQWxsTXV0YWJseSksXG4gICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxuICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxuICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcbiAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcbiAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXG4gICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxuICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcbiAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KSxcbiAgICByZW1vdmVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IocmVtb3ZlT25lTXV0YWJseSksXG4gICAgcmVtb3ZlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVNYW55TXV0YWJseSlcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3NvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBmaW5kSW5zZXJ0SW5kZXgoc29ydGVkSXRlbXMsIGl0ZW0sIGNvbXBhcmlzb25GdW5jdGlvbikge1xuICBsZXQgbG93SW5kZXggPSAwO1xuICBsZXQgaGlnaEluZGV4ID0gc29ydGVkSXRlbXMubGVuZ3RoO1xuICB3aGlsZSAobG93SW5kZXggPCBoaWdoSW5kZXgpIHtcbiAgICBsZXQgbWlkZGxlSW5kZXggPSBsb3dJbmRleCArIGhpZ2hJbmRleCA+Pj4gMTtcbiAgICBjb25zdCBjdXJyZW50SXRlbSA9IHNvcnRlZEl0ZW1zW21pZGRsZUluZGV4XTtcbiAgICBjb25zdCByZXMgPSBjb21wYXJpc29uRnVuY3Rpb24oaXRlbSwgY3VycmVudEl0ZW0pO1xuICAgIGlmIChyZXMgPj0gMCkge1xuICAgICAgbG93SW5kZXggPSBtaWRkbGVJbmRleCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZ2hJbmRleCA9IG1pZGRsZUluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbG93SW5kZXg7XG59XG5mdW5jdGlvbiBpbnNlcnQoc29ydGVkSXRlbXMsIGl0ZW0sIGNvbXBhcmlzb25GdW5jdGlvbikge1xuICBjb25zdCBpbnNlcnRBdEluZGV4ID0gZmluZEluc2VydEluZGV4KHNvcnRlZEl0ZW1zLCBpdGVtLCBjb21wYXJpc29uRnVuY3Rpb24pO1xuICBzb3J0ZWRJdGVtcy5zcGxpY2UoaW5zZXJ0QXRJbmRleCwgMCwgaXRlbSk7XG4gIHJldHVybiBzb3J0ZWRJdGVtcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgY29tcGFyZXIpIHtcbiAgY29uc3Qge1xuICAgIHJlbW92ZU9uZSxcbiAgICByZW1vdmVNYW55LFxuICAgIHJlbW92ZUFsbFxuICB9ID0gY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xuICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gYWRkTWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUsIGV4aXN0aW5nSWRzKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBjb25zdCBleGlzdGluZ0tleXMgPSBuZXcgU2V0KGV4aXN0aW5nSWRzID8/IGdldEN1cnJlbnQoc3RhdGUuaWRzKSk7XG4gICAgY29uc3QgYWRkZWRLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBtb2RlbHMgPSBuZXdFbnRpdGllcy5maWx0ZXIoKG1vZGVsKSA9PiB7XG4gICAgICBjb25zdCBtb2RlbElkID0gc2VsZWN0SWRWYWx1ZShtb2RlbCwgc2VsZWN0SWQpO1xuICAgICAgY29uc3Qgbm90QWRkZWQgPSAhYWRkZWRLZXlzLmhhcyhtb2RlbElkKTtcbiAgICAgIGlmIChub3RBZGRlZCkgYWRkZWRLZXlzLmFkZChtb2RlbElkKTtcbiAgICAgIHJldHVybiAhZXhpc3RpbmdLZXlzLmhhcyhtb2RlbElkKSAmJiBub3RBZGRlZDtcbiAgICB9KTtcbiAgICBpZiAobW9kZWxzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgbWVyZ2VGdW5jdGlvbihzdGF0ZSwgbW9kZWxzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgcmV0dXJuIHNldE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbGV0IGRlZHVwbGljYXRlZEVudGl0aWVzID0ge307XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBpZiAobmV3RW50aXRpZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgbmV3RW50aXRpZXMpIHtcbiAgICAgICAgY29uc3QgZW50aXR5SWQgPSBzZWxlY3RJZChpdGVtKTtcbiAgICAgICAgZGVkdXBsaWNhdGVkRW50aXRpZXNbZW50aXR5SWRdID0gaXRlbTtcbiAgICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW2VudGl0eUlkXTtcbiAgICAgIH1cbiAgICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShkZWR1cGxpY2F0ZWRFbnRpdGllcyk7XG4gICAgICBtZXJnZUZ1bmN0aW9uKHN0YXRlLCBuZXdFbnRpdGllcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldEFsbE11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBzdGF0ZS5lbnRpdGllcyA9IHt9O1xuICAgIHN0YXRlLmlkcyA9IFtdO1xuICAgIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSwgW10pO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU9uZU11dGFibHkodXBkYXRlLCBzdGF0ZSkge1xuICAgIHJldHVybiB1cGRhdGVNYW55TXV0YWJseShbdXBkYXRlXSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZXMsIHN0YXRlKSB7XG4gICAgbGV0IGFwcGxpZWRVcGRhdGVzID0gZmFsc2U7XG4gICAgbGV0IHJlcGxhY2VkSWRzID0gZmFsc2U7XG4gICAgZm9yIChsZXQgdXBkYXRlIG9mIHVwZGF0ZXMpIHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XG4gICAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGFwcGxpZWRVcGRhdGVzID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5hc3NpZ24oZW50aXR5LCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICBjb25zdCBuZXdJZCA9IHNlbGVjdElkKGVudGl0eSk7XG4gICAgICBpZiAodXBkYXRlLmlkICE9PSBuZXdJZCkge1xuICAgICAgICByZXBsYWNlZElkcyA9IHRydWU7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgICAgICBjb25zdCBvbGRJbmRleCA9IHN0YXRlLmlkcy5pbmRleE9mKHVwZGF0ZS5pZCk7XG4gICAgICAgIHN0YXRlLmlkc1tvbGRJbmRleF0gPSBuZXdJZDtcbiAgICAgICAgc3RhdGUuZW50aXRpZXNbbmV3SWRdID0gZW50aXR5O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXBwbGllZFVwZGF0ZXMpIHtcbiAgICAgIG1lcmdlRnVuY3Rpb24oc3RhdGUsIFtdLCBhcHBsaWVkVXBkYXRlcywgcmVwbGFjZWRJZHMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBjb25zdCBbYWRkZWQsIHVwZGF0ZWQsIGV4aXN0aW5nSWRzQXJyYXldID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKTtcbiAgICBpZiAoYWRkZWQubGVuZ3RoKSB7XG4gICAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUsIGV4aXN0aW5nSWRzQXJyYXkpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlZC5sZW5ndGgpIHtcbiAgICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSA9PT0gYltpXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgbWVyZ2VGdW5jdGlvbiA9IChzdGF0ZSwgYWRkZWRJdGVtcywgYXBwbGllZFVwZGF0ZXMsIHJlcGxhY2VkSWRzKSA9PiB7XG4gICAgY29uc3QgY3VycmVudEVudGl0aWVzID0gZ2V0Q3VycmVudChzdGF0ZS5lbnRpdGllcyk7XG4gICAgY29uc3QgY3VycmVudElkcyA9IGdldEN1cnJlbnQoc3RhdGUuaWRzKTtcbiAgICBjb25zdCBzdGF0ZUVudGl0aWVzID0gc3RhdGUuZW50aXRpZXM7XG4gICAgbGV0IGlkcyA9IGN1cnJlbnRJZHM7XG4gICAgaWYgKHJlcGxhY2VkSWRzKSB7XG4gICAgICBpZHMgPSBuZXcgU2V0KGN1cnJlbnRJZHMpO1xuICAgIH1cbiAgICBsZXQgc29ydGVkRW50aXRpZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgY29uc3QgZW50aXR5ID0gY3VycmVudEVudGl0aWVzW2lkXTtcbiAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgc29ydGVkRW50aXRpZXMucHVzaChlbnRpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3YXNQcmV2aW91c2x5RW1wdHkgPSBzb3J0ZWRFbnRpdGllcy5sZW5ndGggPT09IDA7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFkZGVkSXRlbXMpIHtcbiAgICAgIHN0YXRlRW50aXRpZXNbc2VsZWN0SWQoaXRlbSldID0gaXRlbTtcbiAgICAgIGlmICghd2FzUHJldmlvdXNseUVtcHR5KSB7XG4gICAgICAgIGluc2VydChzb3J0ZWRFbnRpdGllcywgaXRlbSwgY29tcGFyZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAod2FzUHJldmlvdXNseUVtcHR5KSB7XG4gICAgICBzb3J0ZWRFbnRpdGllcyA9IGFkZGVkSXRlbXMuc2xpY2UoKS5zb3J0KGNvbXBhcmVyKTtcbiAgICB9IGVsc2UgaWYgKGFwcGxpZWRVcGRhdGVzKSB7XG4gICAgICBzb3J0ZWRFbnRpdGllcy5zb3J0KGNvbXBhcmVyKTtcbiAgICB9XG4gICAgY29uc3QgbmV3U29ydGVkSWRzID0gc29ydGVkRW50aXRpZXMubWFwKHNlbGVjdElkKTtcbiAgICBpZiAoIWFyZUFycmF5c0VxdWFsKGN1cnJlbnRJZHMsIG5ld1NvcnRlZElkcykpIHtcbiAgICAgIHN0YXRlLmlkcyA9IG5ld1NvcnRlZElkcztcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgcmVtb3ZlT25lLFxuICAgIHJlbW92ZU1hbnksXG4gICAgcmVtb3ZlQWxsLFxuICAgIGFkZE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRPbmVNdXRhYmx5KSxcbiAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXG4gICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxuICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcbiAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcbiAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXG4gICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXG4gICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXG4gICAgdXBzZXJ0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRNYW55TXV0YWJseSlcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL2NyZWF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVFbnRpdHlBZGFwdGVyKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgc2VsZWN0SWQsXG4gICAgc29ydENvbXBhcmVyXG4gIH0gPSB7XG4gICAgc29ydENvbXBhcmVyOiBmYWxzZSxcbiAgICBzZWxlY3RJZDogKGluc3RhbmNlKSA9PiBpbnN0YW5jZS5pZCxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IHN0YXRlQWRhcHRlciA9IHNvcnRDb21wYXJlciA/IGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgc29ydENvbXBhcmVyKSA6IGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKTtcbiAgY29uc3Qgc3RhdGVGYWN0b3J5ID0gY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeShzdGF0ZUFkYXB0ZXIpO1xuICBjb25zdCBzZWxlY3RvcnNGYWN0b3J5ID0gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSgpO1xuICByZXR1cm4ge1xuICAgIHNlbGVjdElkLFxuICAgIHNvcnRDb21wYXJlcixcbiAgICAuLi5zdGF0ZUZhY3RvcnksXG4gICAgLi4uc2VsZWN0b3JzRmFjdG9yeSxcbiAgICAuLi5zdGF0ZUFkYXB0ZXJcbiAgfTtcbn1cblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS9leGNlcHRpb25zLnRzXG52YXIgdGFzayA9IFwidGFza1wiO1xudmFyIGxpc3RlbmVyID0gXCJsaXN0ZW5lclwiO1xudmFyIGNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG52YXIgY2FuY2VsbGVkID0gXCJjYW5jZWxsZWRcIjtcbnZhciB0YXNrQ2FuY2VsbGVkID0gYHRhc2stJHtjYW5jZWxsZWR9YDtcbnZhciB0YXNrQ29tcGxldGVkID0gYHRhc2stJHtjb21wbGV0ZWR9YDtcbnZhciBsaXN0ZW5lckNhbmNlbGxlZCA9IGAke2xpc3RlbmVyfS0ke2NhbmNlbGxlZH1gO1xudmFyIGxpc3RlbmVyQ29tcGxldGVkID0gYCR7bGlzdGVuZXJ9LSR7Y29tcGxldGVkfWA7XG52YXIgVGFza0Fib3J0RXJyb3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMubWVzc2FnZSA9IGAke3Rhc2t9ICR7Y2FuY2VsbGVkfSAocmVhc29uOiAke2NvZGV9KWA7XG4gIH1cbiAgbmFtZSA9IFwiVGFza0Fib3J0RXJyb3JcIjtcbiAgbWVzc2FnZTtcbn07XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdXRpbHMudHNcbnZhciBhc3NlcnRGdW5jdGlvbiA9IChmdW5jLCBleHBlY3RlZCkgPT4ge1xuICBpZiAodHlwZW9mIGZ1bmMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMikgOiBgJHtleHBlY3RlZH0gaXMgbm90IGEgZnVuY3Rpb25gKTtcbiAgfVxufTtcbnZhciBub29wMiA9ICgpID0+IHtcbn07XG52YXIgY2F0Y2hSZWplY3Rpb24gPSAocHJvbWlzZSwgb25FcnJvciA9IG5vb3AyKSA9PiB7XG4gIHByb21pc2UuY2F0Y2gob25FcnJvcik7XG4gIHJldHVybiBwcm9taXNlO1xufTtcbnZhciBhZGRBYm9ydFNpZ25hbExpc3RlbmVyID0gKGFib3J0U2lnbmFsLCBjYWxsYmFjaykgPT4ge1xuICBhYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgY2FsbGJhY2ssIHtcbiAgICBvbmNlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gKCkgPT4gYWJvcnRTaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGNhbGxiYWNrKTtcbn07XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdGFzay50c1xudmFyIHZhbGlkYXRlQWN0aXZlID0gKHNpZ25hbCkgPT4ge1xuICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbik7XG4gIH1cbn07XG5mdW5jdGlvbiByYWNlV2l0aFNpZ25hbChzaWduYWwsIHByb21pc2UpIHtcbiAgbGV0IGNsZWFudXAgPSBub29wMjtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBub3RpZnlSZWplY3Rpb24gPSAoKSA9PiByZWplY3QobmV3IFRhc2tBYm9ydEVycm9yKHNpZ25hbC5yZWFzb24pKTtcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIG5vdGlmeVJlamVjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhbnVwID0gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihzaWduYWwsIG5vdGlmeVJlamVjdGlvbik7XG4gICAgcHJvbWlzZS5maW5hbGx5KCgpID0+IGNsZWFudXAoKSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICBjbGVhbnVwID0gbm9vcDI7XG4gIH0pO1xufVxudmFyIHJ1blRhc2sgPSBhc3luYyAodGFzazIsIGNsZWFuVXApID0+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRhc2syKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogXCJva1wiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IGVycm9yIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IgPyBcImNhbmNlbGxlZFwiIDogXCJyZWplY3RlZFwiLFxuICAgICAgZXJyb3JcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIGNsZWFuVXA/LigpO1xuICB9XG59O1xudmFyIGNyZWF0ZVBhdXNlID0gKHNpZ25hbCkgPT4ge1xuICByZXR1cm4gKHByb21pc2UpID0+IHtcbiAgICByZXR1cm4gY2F0Y2hSZWplY3Rpb24ocmFjZVdpdGhTaWduYWwoc2lnbmFsLCBwcm9taXNlKS50aGVuKChvdXRwdXQpID0+IHtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pKTtcbiAgfTtcbn07XG52YXIgY3JlYXRlRGVsYXkgPSAoc2lnbmFsKSA9PiB7XG4gIGNvbnN0IHBhdXNlID0gY3JlYXRlUGF1c2Uoc2lnbmFsKTtcbiAgcmV0dXJuICh0aW1lb3V0TXMpID0+IHtcbiAgICByZXR1cm4gcGF1c2UobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dE1zKSkpO1xuICB9O1xufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS9pbmRleC50c1xudmFyIHtcbiAgYXNzaWduXG59ID0gT2JqZWN0O1xudmFyIElOVEVSTkFMX05JTF9UT0tFTiA9IHt9O1xudmFyIGFsbSA9IFwibGlzdGVuZXJNaWRkbGV3YXJlXCI7XG52YXIgY3JlYXRlRm9yayA9IChwYXJlbnRBYm9ydFNpZ25hbCwgcGFyZW50QmxvY2tpbmdQcm9taXNlcykgPT4ge1xuICBjb25zdCBsaW5rQ29udHJvbGxlcnMgPSAoY29udHJvbGxlcikgPT4gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihwYXJlbnRBYm9ydFNpZ25hbCwgKCkgPT4gY29udHJvbGxlci5hYm9ydChwYXJlbnRBYm9ydFNpZ25hbC5yZWFzb24pKTtcbiAgcmV0dXJuICh0YXNrRXhlY3V0b3IsIG9wdHMpID0+IHtcbiAgICBhc3NlcnRGdW5jdGlvbih0YXNrRXhlY3V0b3IsIFwidGFza0V4ZWN1dG9yXCIpO1xuICAgIGNvbnN0IGNoaWxkQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxpbmtDb250cm9sbGVycyhjaGlsZEFib3J0Q29udHJvbGxlcik7XG4gICAgY29uc3QgcmVzdWx0ID0gcnVuVGFzayhhc3luYyAoKSA9PiB7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShwYXJlbnRBYm9ydFNpZ25hbCk7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IHRhc2tFeGVjdXRvcih7XG4gICAgICAgIHBhdXNlOiBjcmVhdGVQYXVzZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgc2lnbmFsOiBjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICAgIH0pO1xuICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH0sICgpID0+IGNoaWxkQWJvcnRDb250cm9sbGVyLmFib3J0KHRhc2tDb21wbGV0ZWQpKTtcbiAgICBpZiAob3B0cz8uYXV0b0pvaW4pIHtcbiAgICAgIHBhcmVudEJsb2NraW5nUHJvbWlzZXMucHVzaChyZXN1bHQuY2F0Y2gobm9vcDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogY3JlYXRlUGF1c2UocGFyZW50QWJvcnRTaWduYWwpKHJlc3VsdCksXG4gICAgICBjYW5jZWwoKSB7XG4gICAgICAgIGNoaWxkQWJvcnRDb250cm9sbGVyLmFib3J0KHRhc2tDYW5jZWxsZWQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xudmFyIGNyZWF0ZVRha2VQYXR0ZXJuID0gKHN0YXJ0TGlzdGVuaW5nLCBzaWduYWwpID0+IHtcbiAgY29uc3QgdGFrZSA9IGFzeW5jIChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IHtcbiAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuICAgIGxldCB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICB9O1xuICAgIGNvbnN0IHR1cGxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBzdG9wTGlzdGVuaW5nID0gc3RhcnRMaXN0ZW5pbmcoe1xuICAgICAgICBwcmVkaWNhdGUsXG4gICAgICAgIGVmZmVjdDogKGFjdGlvbiwgbGlzdGVuZXJBcGkpID0+IHtcbiAgICAgICAgICBsaXN0ZW5lckFwaS51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJlc29sdmUoW2FjdGlvbiwgbGlzdGVuZXJBcGkuZ2V0U3RhdGUoKSwgbGlzdGVuZXJBcGkuZ2V0T3JpZ2luYWxTdGF0ZSgpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICAgIHN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHByb21pc2VzID0gW3R1cGxlUHJvbWlzZV07XG4gICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0LCBudWxsKSkpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcmFjZVdpdGhTaWduYWwoc2lnbmFsLCBQcm9taXNlLnJhY2UocHJvbWlzZXMpKTtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IGNhdGNoUmVqZWN0aW9uKHRha2UocHJlZGljYXRlLCB0aW1lb3V0KSk7XG59O1xudmFyIGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20gPSAob3B0aW9ucykgPT4ge1xuICBsZXQge1xuICAgIHR5cGUsXG4gICAgYWN0aW9uQ3JlYXRvcixcbiAgICBtYXRjaGVyLFxuICAgIHByZWRpY2F0ZSxcbiAgICBlZmZlY3RcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICh0eXBlKSB7XG4gICAgcHJlZGljYXRlID0gY3JlYXRlQWN0aW9uKHR5cGUpLm1hdGNoO1xuICB9IGVsc2UgaWYgKGFjdGlvbkNyZWF0b3IpIHtcbiAgICB0eXBlID0gYWN0aW9uQ3JlYXRvci50eXBlO1xuICAgIHByZWRpY2F0ZSA9IGFjdGlvbkNyZWF0b3IubWF0Y2g7XG4gIH0gZWxzZSBpZiAobWF0Y2hlcikge1xuICAgIHByZWRpY2F0ZSA9IG1hdGNoZXI7XG4gIH0gZWxzZSBpZiAocHJlZGljYXRlKSB7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjEpIDogXCJDcmVhdGluZyBvciByZW1vdmluZyBhIGxpc3RlbmVyIHJlcXVpcmVzIG9uZSBvZiB0aGUga25vd24gZmllbGRzIGZvciBtYXRjaGluZyBhbiBhY3Rpb25cIik7XG4gIH1cbiAgYXNzZXJ0RnVuY3Rpb24oZWZmZWN0LCBcIm9wdGlvbnMubGlzdGVuZXJcIik7XG4gIHJldHVybiB7XG4gICAgcHJlZGljYXRlLFxuICAgIHR5cGUsXG4gICAgZWZmZWN0XG4gIH07XG59O1xudmFyIGNyZWF0ZUxpc3RlbmVyRW50cnkgPSAvKiBAX19QVVJFX18gKi8gYXNzaWduKChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIHByZWRpY2F0ZSxcbiAgICBlZmZlY3RcbiAgfSA9IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20ob3B0aW9ucyk7XG4gIGNvbnN0IGVudHJ5ID0ge1xuICAgIGlkOiBuYW5vaWQoKSxcbiAgICBlZmZlY3QsXG4gICAgdHlwZSxcbiAgICBwcmVkaWNhdGUsXG4gICAgcGVuZGluZzogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjIpIDogXCJVbnN1YnNjcmliZSBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZW50cnk7XG59LCB7XG4gIHdpdGhUeXBlczogKCkgPT4gY3JlYXRlTGlzdGVuZXJFbnRyeVxufSk7XG52YXIgZmluZExpc3RlbmVyRW50cnkgPSAobGlzdGVuZXJNYXAsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgZWZmZWN0LFxuICAgIHByZWRpY2F0ZVxuICB9ID0gZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbShvcHRpb25zKTtcbiAgcmV0dXJuIEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpLmZpbmQoKGVudHJ5KSA9PiB7XG4gICAgY29uc3QgbWF0Y2hQcmVkaWNhdGVPclR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVudHJ5LnR5cGUgPT09IHR5cGUgOiBlbnRyeS5wcmVkaWNhdGUgPT09IHByZWRpY2F0ZTtcbiAgICByZXR1cm4gbWF0Y2hQcmVkaWNhdGVPclR5cGUgJiYgZW50cnkuZWZmZWN0ID09PSBlZmZlY3Q7XG4gIH0pO1xufTtcbnZhciBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMgPSAoZW50cnkpID0+IHtcbiAgZW50cnkucGVuZGluZy5mb3JFYWNoKChjb250cm9sbGVyKSA9PiB7XG4gICAgY29udHJvbGxlci5hYm9ydChsaXN0ZW5lckNhbmNlbGxlZCk7XG4gIH0pO1xufTtcbnZhciBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSA9IChsaXN0ZW5lck1hcCwgZXhlY3V0aW5nTGlzdGVuZXJzKSA9PiB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lcjIgb2YgZXhlY3V0aW5nTGlzdGVuZXJzLmtleXMoKSkge1xuICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGxpc3RlbmVyMik7XG4gICAgfVxuICAgIGxpc3RlbmVyTWFwLmNsZWFyKCk7XG4gIH07XG59O1xudmFyIHNhZmVseU5vdGlmeUVycm9yID0gKGVycm9ySGFuZGxlciwgZXJyb3JUb05vdGlmeSwgZXJyb3JJbmZvKSA9PiB7XG4gIHRyeSB7XG4gICAgZXJyb3JIYW5kbGVyKGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbyk7XG4gIH0gY2F0Y2ggKGVycm9ySGFuZGxlckVycm9yKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aHJvdyBlcnJvckhhbmRsZXJFcnJvcjtcbiAgICB9LCAwKTtcbiAgfVxufTtcbnZhciBhZGRMaXN0ZW5lciA9IC8qIEBfX1BVUkVfXyAqLyBhc3NpZ24oLyogQF9fUFVSRV9fICovIGNyZWF0ZUFjdGlvbihgJHthbG19L2FkZGApLCB7XG4gIHdpdGhUeXBlczogKCkgPT4gYWRkTGlzdGVuZXJcbn0pO1xudmFyIGNsZWFyQWxsTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUFjdGlvbihgJHthbG19L3JlbW92ZUFsbGApO1xudmFyIHJlbW92ZUxpc3RlbmVyID0gLyogQF9fUFVSRV9fICovIGFzc2lnbigvKiBAX19QVVJFX18gKi8gY3JlYXRlQWN0aW9uKGAke2FsbX0vcmVtb3ZlYCksIHtcbiAgd2l0aFR5cGVzOiAoKSA9PiByZW1vdmVMaXN0ZW5lclxufSk7XG52YXIgZGVmYXVsdEVycm9ySGFuZGxlciA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoYCR7YWxtfS9lcnJvcmAsIC4uLmFyZ3MpO1xufTtcbnZhciBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUgPSAobWlkZGxld2FyZU9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBsaXN0ZW5lck1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGV4ZWN1dGluZ0xpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHRyYWNrRXhlY3V0aW5nTGlzdGVuZXIgPSAoZW50cnkpID0+IHtcbiAgICBjb25zdCBjb3VudCA9IGV4ZWN1dGluZ0xpc3RlbmVycy5nZXQoZW50cnkpID8/IDA7XG4gICAgZXhlY3V0aW5nTGlzdGVuZXJzLnNldChlbnRyeSwgY291bnQgKyAxKTtcbiAgfTtcbiAgY29uc3QgdW50cmFja0V4ZWN1dGluZ0xpc3RlbmVyID0gKGVudHJ5KSA9PiB7XG4gICAgY29uc3QgY291bnQgPSBleGVjdXRpbmdMaXN0ZW5lcnMuZ2V0KGVudHJ5KSA/PyAxO1xuICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgZXhlY3V0aW5nTGlzdGVuZXJzLmRlbGV0ZShlbnRyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4ZWN1dGluZ0xpc3RlbmVycy5zZXQoZW50cnksIGNvdW50IC0gMSk7XG4gICAgfVxuICB9O1xuICBjb25zdCB7XG4gICAgZXh0cmEsXG4gICAgb25FcnJvciA9IGRlZmF1bHRFcnJvckhhbmRsZXJcbiAgfSA9IG1pZGRsZXdhcmVPcHRpb25zO1xuICBhc3NlcnRGdW5jdGlvbihvbkVycm9yLCBcIm9uRXJyb3JcIik7XG4gIGNvbnN0IGluc2VydEVudHJ5ID0gKGVudHJ5KSA9PiB7XG4gICAgZW50cnkudW5zdWJzY3JpYmUgPSAoKSA9PiBsaXN0ZW5lck1hcC5kZWxldGUoZW50cnkuaWQpO1xuICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xuICAgIHJldHVybiAoY2FuY2VsT3B0aW9ucykgPT4ge1xuICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcbiAgICAgIGlmIChjYW5jZWxPcHRpb25zPy5jYW5jZWxBY3RpdmUpIHtcbiAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBjb25zdCBzdGFydExpc3RlbmluZyA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBmaW5kTGlzdGVuZXJFbnRyeShsaXN0ZW5lck1hcCwgb3B0aW9ucykgPz8gY3JlYXRlTGlzdGVuZXJFbnRyeShvcHRpb25zKTtcbiAgICByZXR1cm4gaW5zZXJ0RW50cnkoZW50cnkpO1xuICB9O1xuICBhc3NpZ24oc3RhcnRMaXN0ZW5pbmcsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHN0YXJ0TGlzdGVuaW5nXG4gIH0pO1xuICBjb25zdCBzdG9wTGlzdGVuaW5nID0gKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBlbnRyeSA9IGZpbmRMaXN0ZW5lckVudHJ5KGxpc3RlbmVyTWFwLCBvcHRpb25zKTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAob3B0aW9ucy5jYW5jZWxBY3RpdmUpIHtcbiAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICEhZW50cnk7XG4gIH07XG4gIGFzc2lnbihzdG9wTGlzdGVuaW5nLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBzdG9wTGlzdGVuaW5nXG4gIH0pO1xuICBjb25zdCBub3RpZnlMaXN0ZW5lciA9IGFzeW5jIChlbnRyeSwgYWN0aW9uLCBhcGksIGdldE9yaWdpbmFsU3RhdGUpID0+IHtcbiAgICBjb25zdCBpbnRlcm5hbFRhc2tDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHRha2UgPSBjcmVhdGVUYWtlUGF0dGVybihzdGFydExpc3RlbmluZywgaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpO1xuICAgIGNvbnN0IGF1dG9Kb2luUHJvbWlzZXMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgZW50cnkucGVuZGluZy5hZGQoaW50ZXJuYWxUYXNrQ29udHJvbGxlcik7XG4gICAgICB0cmFja0V4ZWN1dGluZ0xpc3RlbmVyKGVudHJ5KTtcbiAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZShlbnRyeS5lZmZlY3QoXG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgLy8gVXNlIGFzc2lnbigpIHJhdGhlciB0aGFuIC4uLiB0byBhdm9pZCBleHRyYSBoZWxwZXIgZnVuY3Rpb25zIGFkZGVkIHRvIGJ1bmRsZVxuICAgICAgICBhc3NpZ24oe30sIGFwaSwge1xuICAgICAgICAgIGdldE9yaWdpbmFsU3RhdGUsXG4gICAgICAgICAgY29uZGl0aW9uOiAocHJlZGljYXRlLCB0aW1lb3V0KSA9PiB0YWtlKHByZWRpY2F0ZSwgdGltZW91dCkudGhlbihCb29sZWFuKSxcbiAgICAgICAgICB0YWtlLFxuICAgICAgICAgIGRlbGF5OiBjcmVhdGVEZWxheShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgICAgcGF1c2U6IGNyZWF0ZVBhdXNlKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgICBleHRyYSxcbiAgICAgICAgICBzaWduYWw6IGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgIGZvcms6IGNyZWF0ZUZvcmsoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsIGF1dG9Kb2luUHJvbWlzZXMpLFxuICAgICAgICAgIHVuc3Vic2NyaWJlOiBlbnRyeS51bnN1YnNjcmliZSxcbiAgICAgICAgICBzdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzOiAoKSA9PiB7XG4gICAgICAgICAgICBlbnRyeS5wZW5kaW5nLmZvckVhY2goKGNvbnRyb2xsZXIsIF8sIHNldCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoY29udHJvbGxlciAhPT0gaW50ZXJuYWxUYXNrQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQobGlzdGVuZXJDYW5jZWxsZWQpO1xuICAgICAgICAgICAgICAgIHNldC5kZWxldGUoY29udHJvbGxlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FuY2VsOiAoKSA9PiB7XG4gICAgICAgICAgICBpbnRlcm5hbFRhc2tDb250cm9sbGVyLmFib3J0KGxpc3RlbmVyQ2FuY2VsbGVkKTtcbiAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZDogKCkgPT4ge1xuICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICkpO1xuICAgIH0gY2F0Y2ggKGxpc3RlbmVyRXJyb3IpIHtcbiAgICAgIGlmICghKGxpc3RlbmVyRXJyb3IgaW5zdGFuY2VvZiBUYXNrQWJvcnRFcnJvcikpIHtcbiAgICAgICAgc2FmZWx5Tm90aWZ5RXJyb3Iob25FcnJvciwgbGlzdGVuZXJFcnJvciwge1xuICAgICAgICAgIHJhaXNlZEJ5OiBcImVmZmVjdFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChhdXRvSm9pblByb21pc2VzKTtcbiAgICAgIGludGVybmFsVGFza0NvbnRyb2xsZXIuYWJvcnQobGlzdGVuZXJDb21wbGV0ZWQpO1xuICAgICAgdW50cmFja0V4ZWN1dGluZ0xpc3RlbmVyKGVudHJ5KTtcbiAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZShsaXN0ZW5lck1hcCwgZXhlY3V0aW5nTGlzdGVuZXJzKTtcbiAgY29uc3QgbWlkZGxld2FyZSA9IChhcGkpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgaWYgKCFpc0FjdGlvbihhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoYWRkTGlzdGVuZXIubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHN0YXJ0TGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICB9XG4gICAgaWYgKGNsZWFyQWxsTGlzdGVuZXJzLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZW1vdmVMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gc3RvcExpc3RlbmluZyhhY3Rpb24ucGF5bG9hZCk7XG4gICAgfVxuICAgIGxldCBvcmlnaW5hbFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZ2V0T3JpZ2luYWxTdGF0ZSA9ICgpID0+IHtcbiAgICAgIGlmIChvcmlnaW5hbFN0YXRlID09PSBJTlRFUk5BTF9OSUxfVE9LRU4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjMpIDogYCR7YWxtfTogZ2V0T3JpZ2luYWxTdGF0ZSBjYW4gb25seSBiZSBjYWxsZWQgc3luY2hyb25vdXNseWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsU3RhdGU7XG4gICAgfTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBuZXh0KGFjdGlvbik7XG4gICAgICBpZiAobGlzdGVuZXJNYXAuc2l6ZSA+IDApIHtcbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyRW50cmllcyA9IEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGxpc3RlbmVyRW50cmllcykge1xuICAgICAgICAgIGxldCBydW5MaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBydW5MaXN0ZW5lciA9IGVudHJ5LnByZWRpY2F0ZShhY3Rpb24sIGN1cnJlbnRTdGF0ZSwgb3JpZ2luYWxTdGF0ZSk7XG4gICAgICAgICAgfSBjYXRjaCAocHJlZGljYXRlRXJyb3IpIHtcbiAgICAgICAgICAgIHJ1bkxpc3RlbmVyID0gZmFsc2U7XG4gICAgICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBwcmVkaWNhdGVFcnJvciwge1xuICAgICAgICAgICAgICByYWlzZWRCeTogXCJwcmVkaWNhdGVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcnVuTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub3RpZnlMaXN0ZW5lcihlbnRyeSwgYWN0aW9uLCBhcGksIGdldE9yaWdpbmFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIG9yaWdpbmFsU3RhdGUgPSBJTlRFUk5BTF9OSUxfVE9LRU47XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWlkZGxld2FyZSxcbiAgICBzdGFydExpc3RlbmluZyxcbiAgICBzdG9wTGlzdGVuaW5nLFxuICAgIGNsZWFyTGlzdGVuZXJzOiBjbGVhckxpc3RlbmVyTWlkZGxld2FyZVxuICB9O1xufTtcblxuLy8gc3JjL2R5bmFtaWNNaWRkbGV3YXJlL2luZGV4LnRzXG52YXIgY3JlYXRlTWlkZGxld2FyZUVudHJ5ID0gKG1pZGRsZXdhcmUpID0+ICh7XG4gIG1pZGRsZXdhcmUsXG4gIGFwcGxpZWQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbn0pO1xudmFyIG1hdGNoSW5zdGFuY2UgPSAoaW5zdGFuY2VJZCkgPT4gKGFjdGlvbikgPT4gYWN0aW9uPy5tZXRhPy5pbnN0YW5jZUlkID09PSBpbnN0YW5jZUlkO1xudmFyIGNyZWF0ZUR5bmFtaWNNaWRkbGV3YXJlID0gKCkgPT4ge1xuICBjb25zdCBpbnN0YW5jZUlkID0gbmFub2lkKCk7XG4gIGNvbnN0IG1pZGRsZXdhcmVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB3aXRoTWlkZGxld2FyZSA9IE9iamVjdC5hc3NpZ24oY3JlYXRlQWN0aW9uKFwiZHluYW1pY01pZGRsZXdhcmUvYWRkXCIsICguLi5taWRkbGV3YXJlcykgPT4gKHtcbiAgICBwYXlsb2FkOiBtaWRkbGV3YXJlcyxcbiAgICBtZXRhOiB7XG4gICAgICBpbnN0YW5jZUlkXG4gICAgfVxuICB9KSksIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHdpdGhNaWRkbGV3YXJlXG4gIH0pO1xuICBjb25zdCBhZGRNaWRkbGV3YXJlID0gT2JqZWN0LmFzc2lnbihmdW5jdGlvbiBhZGRNaWRkbGV3YXJlMiguLi5taWRkbGV3YXJlcykge1xuICAgIG1pZGRsZXdhcmVzLmZvckVhY2goKG1pZGRsZXdhcmUyKSA9PiB7XG4gICAgICBnZXRPckluc2VydENvbXB1dGVkKG1pZGRsZXdhcmVNYXAsIG1pZGRsZXdhcmUyLCBjcmVhdGVNaWRkbGV3YXJlRW50cnkpO1xuICAgIH0pO1xuICB9LCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBhZGRNaWRkbGV3YXJlXG4gIH0pO1xuICBjb25zdCBnZXRGaW5hbE1pZGRsZXdhcmUgPSAoYXBpKSA9PiB7XG4gICAgY29uc3QgYXBwbGllZE1pZGRsZXdhcmUgPSBBcnJheS5mcm9tKG1pZGRsZXdhcmVNYXAudmFsdWVzKCkpLm1hcCgoZW50cnkpID0+IGdldE9ySW5zZXJ0Q29tcHV0ZWQoZW50cnkuYXBwbGllZCwgYXBpLCBlbnRyeS5taWRkbGV3YXJlKSk7XG4gICAgcmV0dXJuIGNvbXBvc2UoLi4uYXBwbGllZE1pZGRsZXdhcmUpO1xuICB9O1xuICBjb25zdCBpc1dpdGhNaWRkbGV3YXJlID0gaXNBbGxPZih3aXRoTWlkZGxld2FyZSwgbWF0Y2hJbnN0YW5jZShpbnN0YW5jZUlkKSk7XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAoYXBpKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgIGlmIChpc1dpdGhNaWRkbGV3YXJlKGFjdGlvbikpIHtcbiAgICAgIGFkZE1pZGRsZXdhcmUoLi4uYWN0aW9uLnBheWxvYWQpO1xuICAgICAgcmV0dXJuIGFwaS5kaXNwYXRjaDtcbiAgICB9XG4gICAgcmV0dXJuIGdldEZpbmFsTWlkZGxld2FyZShhcGkpKG5leHQpKGFjdGlvbik7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWlkZGxld2FyZSxcbiAgICBhZGRNaWRkbGV3YXJlLFxuICAgIHdpdGhNaWRkbGV3YXJlLFxuICAgIGluc3RhbmNlSWRcbiAgfTtcbn07XG5cbi8vIHNyYy9jb21iaW5lU2xpY2VzLnRzXG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgYXMgY29tYmluZVJlZHVjZXJzMiB9IGZyb20gXCJyZWR1eFwiO1xudmFyIGlzU2xpY2VMaWtlID0gKG1heWJlU2xpY2VMaWtlKSA9PiBcInJlZHVjZXJQYXRoXCIgaW4gbWF5YmVTbGljZUxpa2UgJiYgdHlwZW9mIG1heWJlU2xpY2VMaWtlLnJlZHVjZXJQYXRoID09PSBcInN0cmluZ1wiO1xudmFyIGdldFJlZHVjZXJzID0gKHNsaWNlcykgPT4gc2xpY2VzLmZsYXRNYXAoKHNsaWNlT3JNYXApID0+IGlzU2xpY2VMaWtlKHNsaWNlT3JNYXApID8gW1tzbGljZU9yTWFwLnJlZHVjZXJQYXRoLCBzbGljZU9yTWFwLnJlZHVjZXJdXSA6IE9iamVjdC5lbnRyaWVzKHNsaWNlT3JNYXApKTtcbnZhciBPUklHSU5BTF9TVEFURSA9IFN5bWJvbC5mb3IoXCJydGstc3RhdGUtcHJveHktb3JpZ2luYWxcIik7XG52YXIgaXNTdGF0ZVByb3h5ID0gKHZhbHVlKSA9PiAhIXZhbHVlICYmICEhdmFsdWVbT1JJR0lOQUxfU1RBVEVdO1xudmFyIHN0YXRlUHJveHlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBjcmVhdGVTdGF0ZVByb3h5ID0gKHN0YXRlLCByZWR1Y2VyTWFwLCBpbml0aWFsU3RhdGVDYWNoZSkgPT4gZ2V0T3JJbnNlcnRDb21wdXRlZChzdGF0ZVByb3h5TWFwLCBzdGF0ZSwgKCkgPT4gbmV3IFByb3h5KHN0YXRlLCB7XG4gIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICBpZiAocHJvcCA9PT0gT1JJR0lOQUxfU1RBVEUpIHJldHVybiB0YXJnZXQ7XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGluaXRpYWxTdGF0ZUNhY2hlW3Byb3BdO1xuICAgICAgaWYgKHR5cGVvZiBjYWNoZWQgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBjYWNoZWQ7XG4gICAgICBjb25zdCByZWR1Y2VyID0gcmVkdWNlck1hcFtwcm9wXTtcbiAgICAgIGlmIChyZWR1Y2VyKSB7XG4gICAgICAgIGNvbnN0IHJlZHVjZXJSZXN1bHQgPSByZWR1Y2VyKHZvaWQgMCwge1xuICAgICAgICAgIHR5cGU6IG5hbm9pZCgpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHJlZHVjZXJSZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNCkgOiBgVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7cHJvcC50b1N0cmluZygpfVwiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIGNhbGxlZCBmb3Igc2VsZWN0b3IoKS4gSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgeW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpbml0aWFsU3RhdGVDYWNoZVtwcm9wXSA9IHJlZHVjZXJSZXN1bHQ7XG4gICAgICAgIHJldHVybiByZWR1Y2VyUmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KSk7XG52YXIgb3JpZ2luYWwgPSAoc3RhdGUpID0+IHtcbiAgaWYgKCFpc1N0YXRlUHJveHkoc3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjUpIDogXCJvcmlnaW5hbCBtdXN0IGJlIHVzZWQgb24gc3RhdGUgUHJveHlcIik7XG4gIH1cbiAgcmV0dXJuIHN0YXRlW09SSUdJTkFMX1NUQVRFXTtcbn07XG52YXIgZW1wdHlPYmplY3QgPSB7fTtcbnZhciBub29wUmVkdWNlciA9IChzdGF0ZSA9IGVtcHR5T2JqZWN0KSA9PiBzdGF0ZTtcbmZ1bmN0aW9uIGNvbWJpbmVTbGljZXMoLi4uc2xpY2VzKSB7XG4gIGNvbnN0IHJlZHVjZXJNYXAgPSBPYmplY3QuZnJvbUVudHJpZXMoZ2V0UmVkdWNlcnMoc2xpY2VzKSk7XG4gIGNvbnN0IGdldFJlZHVjZXIgPSAoKSA9PiBPYmplY3Qua2V5cyhyZWR1Y2VyTWFwKS5sZW5ndGggPyBjb21iaW5lUmVkdWNlcnMyKHJlZHVjZXJNYXApIDogbm9vcFJlZHVjZXI7XG4gIGxldCByZWR1Y2VyID0gZ2V0UmVkdWNlcigpO1xuICBmdW5jdGlvbiBjb21iaW5lZFJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIHJldHVybiByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICB9XG4gIGNvbWJpbmVkUmVkdWNlci53aXRoTGF6eUxvYWRlZFNsaWNlcyA9ICgpID0+IGNvbWJpbmVkUmVkdWNlcjtcbiAgY29uc3QgaW5pdGlhbFN0YXRlQ2FjaGUgPSB7fTtcbiAgY29uc3QgaW5qZWN0ID0gKHNsaWNlLCBjb25maWcgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgcmVkdWNlcjogcmVkdWNlclRvSW5qZWN0XG4gICAgfSA9IHNsaWNlO1xuICAgIGNvbnN0IGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlck1hcFtyZWR1Y2VyUGF0aF07XG4gICAgaWYgKCFjb25maWcub3ZlcnJpZGVFeGlzdGluZyAmJiBjdXJyZW50UmVkdWNlciAmJiBjdXJyZW50UmVkdWNlciAhPT0gcmVkdWNlclRvSW5qZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBjYWxsZWQgXFxgaW5qZWN0XFxgIHRvIG92ZXJyaWRlIGFscmVhZHktZXhpc3RpbmcgcmVkdWNlciAke3JlZHVjZXJQYXRofSB3aXRob3V0IHNwZWNpZnlpbmcgXFxgb3ZlcnJpZGVFeGlzdGluZzogdHJ1ZVxcYGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbWJpbmVkUmVkdWNlcjtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5vdmVycmlkZUV4aXN0aW5nICYmIGN1cnJlbnRSZWR1Y2VyICE9PSByZWR1Y2VyVG9JbmplY3QpIHtcbiAgICAgIGRlbGV0ZSBpbml0aWFsU3RhdGVDYWNoZVtyZWR1Y2VyUGF0aF07XG4gICAgfVxuICAgIHJlZHVjZXJNYXBbcmVkdWNlclBhdGhdID0gcmVkdWNlclRvSW5qZWN0O1xuICAgIHJlZHVjZXIgPSBnZXRSZWR1Y2VyKCk7XG4gICAgcmV0dXJuIGNvbWJpbmVkUmVkdWNlcjtcbiAgfTtcbiAgY29uc3Qgc2VsZWN0b3IgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIG1ha2VTZWxlY3RvcihzZWxlY3RvckZuLCBzZWxlY3RTdGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBzZWxlY3RvcjIoc3RhdGUsIC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiBzZWxlY3RvckZuKGNyZWF0ZVN0YXRlUHJveHkoc2VsZWN0U3RhdGUgPyBzZWxlY3RTdGF0ZShzdGF0ZSwgLi4uYXJncykgOiBzdGF0ZSwgcmVkdWNlck1hcCwgaW5pdGlhbFN0YXRlQ2FjaGUpLCAuLi5hcmdzKTtcbiAgICB9O1xuICB9LCB7XG4gICAgb3JpZ2luYWxcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGNvbWJpbmVkUmVkdWNlciwge1xuICAgIGluamVjdCxcbiAgICBzZWxlY3RvclxuICB9KTtcbn1cblxuLy8gc3JjL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UudHNcbmZ1bmN0aW9uIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoY29kZSkge1xuICByZXR1cm4gYE1pbmlmaWVkIFJlZHV4IFRvb2xraXQgZXJyb3IgIyR7Y29kZX07IHZpc2l0IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvRXJyb3JzP2NvZGU9JHtjb2RlfSBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzLiBgO1xufVxuZXhwb3J0IHtcbiAgUmVkdWNlclR5cGUsXG4gIFNIT1VMRF9BVVRPQkFUQ0gsXG4gIFRhc2tBYm9ydEVycm9yLFxuICBUdXBsZSxcbiAgYWRkTGlzdGVuZXIsXG4gIGFzeW5jVGh1bmtDcmVhdG9yLFxuICBhdXRvQmF0Y2hFbmhhbmNlcixcbiAgYnVpbGRDcmVhdGVTbGljZSxcbiAgY2xlYXJBbGxMaXN0ZW5lcnMsXG4gIGNvbWJpbmVTbGljZXMsXG4gIGNvbmZpZ3VyZVN0b3JlLFxuICBjcmVhdGVBY3Rpb24sXG4gIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLFxuICBjcmVhdGVBc3luY1RodW5rLFxuICBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcixcbiAgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JDcmVhdG9yLFxuICBjcmVhdGVEeW5hbWljTWlkZGxld2FyZSxcbiAgY3JlYXRlRW50aXR5QWRhcHRlcixcbiAgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLFxuICBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUsXG4gIHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlLFxuICBjcmVhdGVSZWR1Y2VyLFxuICBjcmVhdGVTZWxlY3RvcixcbiAgY3JlYXRlU2VsZWN0b3JDcmVhdG9yLFxuICBjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsXG4gIGNyZWF0ZVNsaWNlLFxuICBjdXJyZW50LFxuICBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUsXG4gIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UsXG4gIGZyZWV6ZSxcbiAgaXNBY3Rpb25DcmVhdG9yLFxuICBpc0FsbE9mLFxuICBpc0FueU9mLFxuICBpc0FzeW5jVGh1bmtBY3Rpb24sXG4gIGlzRHJhZnQsXG4gIGlzRlNBIGFzIGlzRmx1eFN0YW5kYXJkQWN0aW9uLFxuICBpc0Z1bGZpbGxlZCxcbiAgaXNJbW11dGFibGVEZWZhdWx0LFxuICBpc1BlbmRpbmcsXG4gIGlzUGxhaW4sXG4gIGlzUmVqZWN0ZWQsXG4gIGlzUmVqZWN0ZWRXaXRoVmFsdWUsXG4gIGxydU1lbW9pemUsXG4gIG1pbmlTZXJpYWxpemVFcnJvcixcbiAgbmFub2lkLFxuICBvcmlnaW5hbDIgYXMgb3JpZ2luYWwsXG4gIHByZXBhcmVBdXRvQmF0Y2hlZCxcbiAgcmVtb3ZlTGlzdGVuZXIsXG4gIHVud3JhcFJlc3VsdCxcbiAgd2Vha01hcE1lbW9pemVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1eC10b29sa2l0Lm1vZGVybi5tanMubWFwIl0sIm5hbWVzIjpbImZyZWV6ZSIsIm9yaWdpbmFsIiwib3JpZ2luYWwyIiwiY3VycmVudCIsImlzRHJhZnQiLCJwcm9kdWNlIiwiaXNEcmFmdGFibGUiLCJzZXRVc2VTdHJpY3RJdGVyYXRpb24iLCJjcmVhdGVTZWxlY3RvciIsImxydU1lbW9pemUiLCJjcmVhdGVTZWxlY3RvckNyZWF0b3IiLCJ3ZWFrTWFwTWVtb2l6ZSIsImNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvciIsImFyZ3MiLCJjcmVhdGVTZWxlY3RvcjIiLCJjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcjIiLCJPYmplY3QiLCJhc3NpZ24iLCJhcmdzMiIsInNlbGVjdG9yIiwid3JhcHBlZFNlbGVjdG9yIiwidmFsdWUiLCJyZXN0Iiwid2l0aFR5cGVzIiwiY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IiLCJjcmVhdGVTdG9yZSIsImNvbWJpbmVSZWR1Y2VycyIsImFwcGx5TWlkZGxld2FyZSIsImNvbXBvc2UiLCJpc1BsYWluT2JqZWN0IiwiaXNBY3Rpb24iLCJjb21wb3NlV2l0aERldlRvb2xzIiwid2luZG93IiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXBwbHkiLCJkZXZUb29sc0VuaGFuY2VyIiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyIsIm5vb3AzIiwidGh1bmsiLCJ0aHVua01pZGRsZXdhcmUiLCJ3aXRoRXh0cmFBcmd1bWVudCIsImhhc01hdGNoRnVuY3Rpb24iLCJ2IiwibWF0Y2giLCJjcmVhdGVBY3Rpb24iLCJ0eXBlIiwicHJlcGFyZUFjdGlvbiIsImFjdGlvbkNyZWF0b3IiLCJwcmVwYXJlZCIsIkVycm9yIiwicHJvY2VzcyIsImZvcm1hdFByb2RFcnJvck1lc3NhZ2UiLCJwYXlsb2FkIiwibWV0YSIsImVycm9yIiwidG9TdHJpbmciLCJhY3Rpb24iLCJpc0FjdGlvbkNyZWF0b3IiLCJpc0ZTQSIsImtleXMiLCJldmVyeSIsImlzVmFsaWRLZXkiLCJrZXkiLCJpbmRleE9mIiwiZ2V0TWVzc2FnZSIsInNwbGl0VHlwZSIsInNwbGl0IiwiYWN0aW9uTmFtZSIsImNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlIiwib3B0aW9ucyIsIm5leHQiLCJpc0FjdGlvbkNyZWF0b3IyIiwiY29uc29sZSIsIndhcm4iLCJnZXRUaW1lTWVhc3VyZVV0aWxzIiwibWF4RGVsYXkiLCJmbk5hbWUiLCJlbGFwc2VkIiwibWVhc3VyZVRpbWUiLCJmbiIsInN0YXJ0ZWQiLCJEYXRlIiwibm93IiwiZmluaXNoZWQiLCJ3YXJuSWZFeGNlZWRlZCIsIlR1cGxlIiwiX1R1cGxlIiwiQXJyYXkiLCJjb25zdHJ1Y3RvciIsIml0ZW1zIiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJTeW1ib2wiLCJzcGVjaWVzIiwiY29uY2F0IiwiYXJyIiwicHJlcGVuZCIsImlzQXJyYXkiLCJmcmVlemVEcmFmdGFibGUiLCJ2YWwiLCJnZXRPckluc2VydENvbXB1dGVkIiwibWFwIiwiY29tcHV0ZSIsImhhcyIsImdldCIsInNldCIsImlzSW1tdXRhYmxlRGVmYXVsdCIsImlzRnJvemVuIiwidHJhY2tGb3JNdXRhdGlvbnMiLCJpc0ltbXV0YWJsZSIsImlnbm9yZWRQYXRocyIsIm9iaiIsInRyYWNrZWRQcm9wZXJ0aWVzIiwidHJhY2tQcm9wZXJ0aWVzIiwiZGV0ZWN0TXV0YXRpb25zIiwicGF0aCIsImNoZWNrZWRPYmplY3RzIiwiU2V0IiwidHJhY2tlZCIsImFkZCIsImNoaWxkcmVuIiwiaGFzSWdub3JlZFBhdGhzIiwibmVzdGVkUGF0aCIsImhhc01hdGNoZXMiLCJzb21lIiwiaWdub3JlZCIsIlJlZ0V4cCIsInRlc3QiLCJ0cmFja2VkUHJvcGVydHkiLCJzYW1lUGFyZW50UmVmIiwicHJldk9iaiIsInNhbWVSZWYiLCJOdW1iZXIiLCJpc05hTiIsIndhc011dGF0ZWQiLCJrZXlzVG9EZXRlY3QiLCJyZXN1bHQiLCJjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUiLCJzdHJpbmdpZnkyIiwic2VyaWFsaXplciIsImluZGVudCIsImRlY3ljbGVyIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldFNlcmlhbGl6ZTIiLCJzdGFjayIsIl8iLCJzbGljZSIsImpvaW4iLCJ0aGlzUG9zIiwic3BsaWNlIiwicHVzaCIsIkluZmluaXR5IiwiY2FsbCIsImdldFNlcmlhbGl6ZSIsIndhcm5BZnRlciIsInRyYWNrIiwiYmluZCIsImdldFN0YXRlIiwic3RhdGUiLCJ0cmFja2VyIiwibWVhc3VyZVV0aWxzIiwiZGlzcGF0Y2hlZEFjdGlvbiIsImlzUGxhaW4iLCJmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJpc1NlcmlhbGl6YWJsZSIsImdldEVudHJpZXMiLCJjYWNoZSIsImZvdW5kTmVzdGVkU2VyaWFsaXphYmxlIiwia2V5UGF0aCIsImVudHJpZXMiLCJuZXN0ZWRWYWx1ZSIsImlzTmVzdGVkRnJvemVuIiwidmFsdWVzIiwiY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlIiwiaWdub3JlZEFjdGlvbnMiLCJpZ25vcmVkQWN0aW9uUGF0aHMiLCJpZ25vcmVTdGF0ZSIsImlnbm9yZUFjdGlvbnMiLCJkaXNhYmxlQ2FjaGUiLCJXZWFrU2V0Iiwic3RvcmVBUEkiLCJmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlIiwiZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlIiwiaXNCb29sZWFuIiwieCIsImJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUiLCJnZXREZWZhdWx0TWlkZGxld2FyZSIsImltbXV0YWJsZUNoZWNrIiwic2VyaWFsaXphYmxlQ2hlY2siLCJhY3Rpb25DcmVhdG9yQ2hlY2siLCJtaWRkbGV3YXJlQXJyYXkiLCJleHRyYUFyZ3VtZW50IiwiaW1tdXRhYmxlT3B0aW9ucyIsInVuc2hpZnQiLCJzZXJpYWxpemFibGVPcHRpb25zIiwiYWN0aW9uQ3JlYXRvck9wdGlvbnMiLCJTSE9VTERfQVVUT0JBVENIIiwicHJlcGFyZUF1dG9CYXRjaGVkIiwiY3JlYXRlUXVldWVXaXRoVGltZXIiLCJ0aW1lb3V0Iiwibm90aWZ5Iiwic2V0VGltZW91dCIsImF1dG9CYXRjaEVuaGFuY2VyIiwic3RvcmUiLCJub3RpZnlpbmciLCJzaG91bGROb3RpZnlBdEVuZE9mVGljayIsIm5vdGlmaWNhdGlvblF1ZXVlZCIsImxpc3RlbmVycyIsInF1ZXVlQ2FsbGJhY2siLCJxdWV1ZU1pY3JvdGFzayIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInF1ZXVlTm90aWZpY2F0aW9uIiwibm90aWZ5TGlzdGVuZXJzIiwiZm9yRWFjaCIsImwiLCJzdWJzY3JpYmUiLCJsaXN0ZW5lcjIiLCJ3cmFwcGVkTGlzdGVuZXIiLCJ1bnN1YnNjcmliZSIsImRlbGV0ZSIsImRpc3BhdGNoIiwiYnVpbGRHZXREZWZhdWx0RW5oYW5jZXJzIiwibWlkZGxld2FyZUVuaGFuY2VyIiwiZ2V0RGVmYXVsdEVuaGFuY2VycyIsImF1dG9CYXRjaCIsImVuaGFuY2VyQXJyYXkiLCJjb25maWd1cmVTdG9yZSIsInJlZHVjZXIiLCJtaWRkbGV3YXJlIiwiZGV2VG9vbHMiLCJkdXBsaWNhdGVNaWRkbGV3YXJlQ2hlY2siLCJwcmVsb2FkZWRTdGF0ZSIsImVuaGFuY2VycyIsInJvb3RSZWR1Y2VyIiwiZmluYWxNaWRkbGV3YXJlIiwiaXRlbSIsIm1pZGRsZXdhcmVSZWZlcmVuY2VzIiwibWlkZGxld2FyZTIiLCJmaW5hbENvbXBvc2UiLCJ0cmFjZSIsInN0b3JlRW5oYW5jZXJzIiwiaW5jbHVkZXMiLCJjb21wb3NlZEVuaGFuY2VyIiwiZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2siLCJidWlsZGVyQ2FsbGJhY2siLCJhY3Rpb25zTWFwIiwiYWN0aW9uTWF0Y2hlcnMiLCJkZWZhdWx0Q2FzZVJlZHVjZXIiLCJidWlsZGVyIiwiYWRkQ2FzZSIsInR5cGVPckFjdGlvbkNyZWF0b3IiLCJhZGRBc3luY1RodW5rIiwiYXN5bmNUaHVuayIsInJlZHVjZXJzIiwicGVuZGluZyIsInJlamVjdGVkIiwiZnVsZmlsbGVkIiwic2V0dGxlZCIsIm1hdGNoZXIiLCJhZGRNYXRjaGVyIiwiYWRkRGVmYXVsdENhc2UiLCJpc1N0YXRlRnVuY3Rpb24iLCJjcmVhdGVSZWR1Y2VyIiwiaW5pdGlhbFN0YXRlIiwibWFwT3JCdWlsZGVyQ2FsbGJhY2siLCJmaW5hbEFjdGlvbk1hdGNoZXJzIiwiZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXIiLCJnZXRJbml0aWFsU3RhdGUiLCJmcm96ZW5Jbml0aWFsU3RhdGUiLCJjYXNlUmVkdWNlcnMiLCJmaWx0ZXIiLCJyZWR1Y2VyMiIsImNyIiwicmVkdWNlIiwicHJldmlvdXNTdGF0ZSIsImNhc2VSZWR1Y2VyIiwiZHJhZnQiLCJtYXRjaGVzIiwiaXNBbnlPZiIsIm1hdGNoZXJzIiwiaXNBbGxPZiIsImhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhIiwidmFsaWRTdGF0dXMiLCJoYXNWYWxpZFJlcXVlc3RJZCIsInJlcXVlc3RJZCIsImhhc1ZhbGlkUmVxdWVzdFN0YXR1cyIsInJlcXVlc3RTdGF0dXMiLCJpc0FzeW5jVGh1bmtBcnJheSIsImEiLCJpc1BlbmRpbmciLCJhc3luY1RodW5rcyIsImlzUmVqZWN0ZWQiLCJpc1JlamVjdGVkV2l0aFZhbHVlIiwiaGFzRmxhZyIsInJlamVjdGVkV2l0aFZhbHVlIiwiaXNGdWxmaWxsZWQiLCJpc0FzeW5jVGh1bmtBY3Rpb24iLCJmbGF0TWFwIiwidXJsQWxwaGFiZXQiLCJuYW5vaWQiLCJzaXplIiwiaWQiLCJpIiwiTWF0aCIsInJhbmRvbSIsImNvbW1vblByb3BlcnRpZXMiLCJSZWplY3RXaXRoVmFsdWUiLCJGdWxmaWxsV2l0aE1ldGEiLCJtaW5pU2VyaWFsaXplRXJyb3IiLCJzaW1wbGVFcnJvciIsInByb3BlcnR5IiwibWVzc2FnZSIsIlN0cmluZyIsImV4dGVybmFsQWJvcnRNZXNzYWdlIiwiY3JlYXRlQXN5bmNUaHVuayIsImNyZWF0ZUFzeW5jVGh1bmsyIiwidHlwZVByZWZpeCIsInBheWxvYWRDcmVhdG9yIiwiYXJnIiwic2VyaWFsaXplRXJyb3IiLCJhYm9ydGVkIiwibmFtZSIsImNvbmRpdGlvbiIsInNpZ25hbCIsImV4dHJhIiwiaWRHZW5lcmF0b3IiLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJhYm9ydEhhbmRsZXIiLCJhYm9ydFJlYXNvbiIsImFib3J0IiwicmVhc29uIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJwcm9taXNlIiwiZmluYWxBY3Rpb24iLCJjb25kaXRpb25SZXN1bHQiLCJpc1RoZW5hYmxlIiwiYWJvcnRlZFByb21pc2UiLCJQcm9taXNlIiwicmVqZWN0IiwiZ2V0UGVuZGluZ01ldGEiLCJyYWNlIiwicmVzb2x2ZSIsInJlamVjdFdpdGhWYWx1ZSIsImZ1bGZpbGxXaXRoVmFsdWUiLCJ0aGVuIiwiZXJyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNraXBEaXNwYXRjaCIsImRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uIiwidW53cmFwIiwidW53cmFwUmVzdWx0IiwiYXN5bmNUaHVua1N5bWJvbCIsImZvciIsImFzeW5jVGh1bmtDcmVhdG9yIiwiUmVkdWNlclR5cGUiLCJSZWR1Y2VyVHlwZTIiLCJnZXRUeXBlIiwiYWN0aW9uS2V5IiwiYnVpbGRDcmVhdGVTbGljZSIsImNyZWF0b3JzIiwiY0FUIiwiY3JlYXRlU2xpY2UyIiwicmVkdWNlclBhdGgiLCJidWlsZFJlZHVjZXJDcmVhdG9ycyIsInJlZHVjZXJOYW1lcyIsImNvbnRleHQiLCJzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZSIsInNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlIiwiYWN0aW9uQ3JlYXRvcnMiLCJzbGljZU1hdGNoZXJzIiwiY29udGV4dE1ldGhvZHMiLCJleHBvc2VBY3Rpb24iLCJuYW1lMiIsImV4cG9zZUNhc2VSZWR1Y2VyIiwicmVkdWNlck5hbWUiLCJyZWR1Y2VyRGVmaW5pdGlvbiIsInJlZHVjZXJEZXRhaWxzIiwiY3JlYXRlTm90YXRpb24iLCJpc0FzeW5jVGh1bmtTbGljZVJlZHVjZXJEZWZpbml0aW9uIiwiaGFuZGxlVGh1bmtDYXNlUmVkdWNlckRlZmluaXRpb24iLCJoYW5kbGVOb3JtYWxSZWR1Y2VyRGVmaW5pdGlvbiIsImJ1aWxkUmVkdWNlciIsImV4dHJhUmVkdWNlcnMiLCJmaW5hbENhc2VSZWR1Y2VycyIsInNNIiwibSIsInNlbGVjdFNlbGYiLCJpbmplY3RlZFNlbGVjdG9yQ2FjaGUiLCJNYXAiLCJpbmplY3RlZFN0YXRlQ2FjaGUiLCJXZWFrTWFwIiwiX3JlZHVjZXIiLCJtYWtlU2VsZWN0b3JQcm9wcyIsInJlZHVjZXJQYXRoMiIsImluamVjdGVkIiwic2VsZWN0U2xpY2UiLCJzbGljZVN0YXRlIiwiZ2V0U2VsZWN0b3JzIiwic2VsZWN0U3RhdGUiLCJzZWxlY3RvckNhY2hlIiwic2VsZWN0b3JzIiwid3JhcFNlbGVjdG9yIiwiYWN0aW9ucyIsImluamVjdEludG8iLCJpbmplY3RhYmxlIiwicGF0aE9wdCIsImNvbmZpZyIsIm5ld1JlZHVjZXJQYXRoIiwiaW5qZWN0Iiwid3JhcHBlciIsInJvb3RTdGF0ZSIsInVud3JhcHBlZCIsImNyZWF0ZVNsaWNlIiwiX3JlZHVjZXJEZWZpbml0aW9uVHlwZSIsInByZXBhcmVkUmVkdWNlciIsInByZXBhcmUiLCJtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSIsInByZXBhcmVDYWxsYmFjayIsImlzQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZURlZmluaXRpb24iLCJub29wIiwiZ2V0SW5pdGlhbEVudGl0eVN0YXRlIiwiaWRzIiwiZW50aXRpZXMiLCJjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5Iiwic3RhdGVBZGFwdGVyIiwiYWRkaXRpb25hbFN0YXRlIiwic2V0QWxsIiwiY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSIsInNlbGVjdElkcyIsInNlbGVjdEVudGl0aWVzIiwic2VsZWN0QWxsIiwic2VsZWN0SWQiLCJzZWxlY3RCeUlkIiwic2VsZWN0VG90YWwiLCJzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMiLCJpc0RyYWZ0VHlwZWQiLCJjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IiLCJtdXRhdG9yIiwib3BlcmF0b3IiLCJjcmVhdGVTdGF0ZU9wZXJhdG9yIiwib3BlcmF0aW9uIiwiaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQiLCJhcmcyIiwicnVuTXV0YXRvciIsInNlbGVjdElkVmFsdWUiLCJlbnRpdHkiLCJlbnN1cmVFbnRpdGllc0FycmF5IiwiZ2V0Q3VycmVudCIsInNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMiLCJuZXdFbnRpdGllcyIsImV4aXN0aW5nSWRzQXJyYXkiLCJleGlzdGluZ0lkcyIsImFkZGVkIiwiYWRkZWRJZHMiLCJ1cGRhdGVkIiwiY2hhbmdlcyIsImNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyIiwiYWRkT25lTXV0YWJseSIsImFkZE1hbnlNdXRhYmx5Iiwic2V0T25lTXV0YWJseSIsInNldE1hbnlNdXRhYmx5Iiwic2V0QWxsTXV0YWJseSIsInJlbW92ZU9uZU11dGFibHkiLCJyZW1vdmVNYW55TXV0YWJseSIsImRpZE11dGF0ZSIsInJlbW92ZUFsbE11dGFibHkiLCJ0YWtlTmV3S2V5IiwidXBkYXRlIiwib3JpZ2luYWwzIiwibmV3S2V5IiwiaGFzTmV3S2V5IiwidXBkYXRlT25lTXV0YWJseSIsInVwZGF0ZU1hbnlNdXRhYmx5IiwidXBkYXRlcyIsIm5ld0tleXMiLCJ1cGRhdGVzUGVyRW50aXR5IiwiZGlkTXV0YXRlRW50aXRpZXMiLCJkaWRNdXRhdGVJZHMiLCJlIiwidXBzZXJ0T25lTXV0YWJseSIsInVwc2VydE1hbnlNdXRhYmx5IiwicmVtb3ZlQWxsIiwiYWRkT25lIiwiYWRkTWFueSIsInNldE9uZSIsInNldE1hbnkiLCJ1cGRhdGVPbmUiLCJ1cGRhdGVNYW55IiwidXBzZXJ0T25lIiwidXBzZXJ0TWFueSIsInJlbW92ZU9uZSIsInJlbW92ZU1hbnkiLCJmaW5kSW5zZXJ0SW5kZXgiLCJzb3J0ZWRJdGVtcyIsImNvbXBhcmlzb25GdW5jdGlvbiIsImxvd0luZGV4IiwiaGlnaEluZGV4IiwibWlkZGxlSW5kZXgiLCJjdXJyZW50SXRlbSIsInJlcyIsImluc2VydCIsImluc2VydEF0SW5kZXgiLCJjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIiLCJjb21wYXJlciIsImV4aXN0aW5nS2V5cyIsImFkZGVkS2V5cyIsIm1vZGVscyIsIm1vZGVsIiwibW9kZWxJZCIsIm5vdEFkZGVkIiwibWVyZ2VGdW5jdGlvbiIsImRlZHVwbGljYXRlZEVudGl0aWVzIiwiZW50aXR5SWQiLCJhcHBsaWVkVXBkYXRlcyIsInJlcGxhY2VkSWRzIiwibmV3SWQiLCJvbGRJbmRleCIsImFyZUFycmF5c0VxdWFsIiwiYiIsImFkZGVkSXRlbXMiLCJjdXJyZW50RW50aXRpZXMiLCJjdXJyZW50SWRzIiwic3RhdGVFbnRpdGllcyIsInNvcnRlZEVudGl0aWVzIiwid2FzUHJldmlvdXNseUVtcHR5Iiwic29ydCIsIm5ld1NvcnRlZElkcyIsImNyZWF0ZUVudGl0eUFkYXB0ZXIiLCJzb3J0Q29tcGFyZXIiLCJpbnN0YW5jZSIsInN0YXRlRmFjdG9yeSIsInNlbGVjdG9yc0ZhY3RvcnkiLCJ0YXNrIiwibGlzdGVuZXIiLCJjb21wbGV0ZWQiLCJjYW5jZWxsZWQiLCJ0YXNrQ2FuY2VsbGVkIiwidGFza0NvbXBsZXRlZCIsImxpc3RlbmVyQ2FuY2VsbGVkIiwibGlzdGVuZXJDb21wbGV0ZWQiLCJUYXNrQWJvcnRFcnJvciIsImNvZGUiLCJhc3NlcnRGdW5jdGlvbiIsImZ1bmMiLCJleHBlY3RlZCIsIlR5cGVFcnJvciIsIm5vb3AyIiwiY2F0Y2hSZWplY3Rpb24iLCJvbkVycm9yIiwiY2F0Y2giLCJhZGRBYm9ydFNpZ25hbExpc3RlbmVyIiwiYWJvcnRTaWduYWwiLCJjYWxsYmFjayIsInZhbGlkYXRlQWN0aXZlIiwicmFjZVdpdGhTaWduYWwiLCJjbGVhbnVwIiwibm90aWZ5UmVqZWN0aW9uIiwiZmluYWxseSIsInJ1blRhc2siLCJ0YXNrMiIsImNsZWFuVXAiLCJzdGF0dXMiLCJjcmVhdGVQYXVzZSIsIm91dHB1dCIsImNyZWF0ZURlbGF5IiwicGF1c2UiLCJ0aW1lb3V0TXMiLCJJTlRFUk5BTF9OSUxfVE9LRU4iLCJhbG0iLCJjcmVhdGVGb3JrIiwicGFyZW50QWJvcnRTaWduYWwiLCJwYXJlbnRCbG9ja2luZ1Byb21pc2VzIiwibGlua0NvbnRyb2xsZXJzIiwiY29udHJvbGxlciIsInRhc2tFeGVjdXRvciIsIm9wdHMiLCJjaGlsZEFib3J0Q29udHJvbGxlciIsInJlc3VsdDIiLCJkZWxheSIsImF1dG9Kb2luIiwiY2FuY2VsIiwiY3JlYXRlVGFrZVBhdHRlcm4iLCJzdGFydExpc3RlbmluZyIsInRha2UiLCJwcmVkaWNhdGUiLCJ0dXBsZVByb21pc2UiLCJzdG9wTGlzdGVuaW5nIiwiZWZmZWN0IiwibGlzdGVuZXJBcGkiLCJnZXRPcmlnaW5hbFN0YXRlIiwicHJvbWlzZXMiLCJnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tIiwiY3JlYXRlTGlzdGVuZXJFbnRyeSIsImVudHJ5IiwiZmluZExpc3RlbmVyRW50cnkiLCJsaXN0ZW5lck1hcCIsImZyb20iLCJmaW5kIiwibWF0Y2hQcmVkaWNhdGVPclR5cGUiLCJjYW5jZWxBY3RpdmVMaXN0ZW5lcnMiLCJjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSIsImV4ZWN1dGluZ0xpc3RlbmVycyIsImNsZWFyIiwic2FmZWx5Tm90aWZ5RXJyb3IiLCJlcnJvckhhbmRsZXIiLCJlcnJvclRvTm90aWZ5IiwiZXJyb3JJbmZvIiwiZXJyb3JIYW5kbGVyRXJyb3IiLCJhZGRMaXN0ZW5lciIsImNsZWFyQWxsTGlzdGVuZXJzIiwicmVtb3ZlTGlzdGVuZXIiLCJkZWZhdWx0RXJyb3JIYW5kbGVyIiwiY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlIiwibWlkZGxld2FyZU9wdGlvbnMiLCJ0cmFja0V4ZWN1dGluZ0xpc3RlbmVyIiwiY291bnQiLCJ1bnRyYWNrRXhlY3V0aW5nTGlzdGVuZXIiLCJpbnNlcnRFbnRyeSIsImNhbmNlbE9wdGlvbnMiLCJjYW5jZWxBY3RpdmUiLCJub3RpZnlMaXN0ZW5lciIsImFwaSIsImludGVybmFsVGFza0NvbnRyb2xsZXIiLCJhdXRvSm9pblByb21pc2VzIiwiQm9vbGVhbiIsImZvcmsiLCJ0aHJvd0lmQ2FuY2VsbGVkIiwibGlzdGVuZXJFcnJvciIsInJhaXNlZEJ5IiwiYWxsIiwiY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUiLCJvcmlnaW5hbFN0YXRlIiwiY3VycmVudFN0YXRlIiwibGlzdGVuZXJFbnRyaWVzIiwicnVuTGlzdGVuZXIiLCJwcmVkaWNhdGVFcnJvciIsImNsZWFyTGlzdGVuZXJzIiwiY3JlYXRlTWlkZGxld2FyZUVudHJ5IiwiYXBwbGllZCIsIm1hdGNoSW5zdGFuY2UiLCJpbnN0YW5jZUlkIiwiY3JlYXRlRHluYW1pY01pZGRsZXdhcmUiLCJtaWRkbGV3YXJlTWFwIiwid2l0aE1pZGRsZXdhcmUiLCJtaWRkbGV3YXJlcyIsImFkZE1pZGRsZXdhcmUiLCJhZGRNaWRkbGV3YXJlMiIsImdldEZpbmFsTWlkZGxld2FyZSIsImFwcGxpZWRNaWRkbGV3YXJlIiwiaXNXaXRoTWlkZGxld2FyZSIsImNvbWJpbmVSZWR1Y2VyczIiLCJpc1NsaWNlTGlrZSIsIm1heWJlU2xpY2VMaWtlIiwiZ2V0UmVkdWNlcnMiLCJzbGljZXMiLCJzbGljZU9yTWFwIiwiT1JJR0lOQUxfU1RBVEUiLCJpc1N0YXRlUHJveHkiLCJzdGF0ZVByb3h5TWFwIiwiY3JlYXRlU3RhdGVQcm94eSIsInJlZHVjZXJNYXAiLCJpbml0aWFsU3RhdGVDYWNoZSIsIlByb3h5IiwidGFyZ2V0IiwicHJvcCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsImNhY2hlZCIsInJlZHVjZXJSZXN1bHQiLCJlbXB0eU9iamVjdCIsIm5vb3BSZWR1Y2VyIiwiY29tYmluZVNsaWNlcyIsImZyb21FbnRyaWVzIiwiZ2V0UmVkdWNlciIsImNvbWJpbmVkUmVkdWNlciIsIndpdGhMYXp5TG9hZGVkU2xpY2VzIiwicmVkdWNlclRvSW5qZWN0IiwiY3VycmVudFJlZHVjZXIiLCJvdmVycmlkZUV4aXN0aW5nIiwibWFrZVNlbGVjdG9yIiwic2VsZWN0b3JGbiIsInNlbGVjdG9yMiIsImNyZWF0ZU5leHRTdGF0ZSIsImlzRmx1eFN0YW5kYXJkQWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/node_modules/immer/dist/immer.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/node_modules/immer/dist/immer.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Immer: () => (/* binding */ Immer2),\n/* harmony export */   applyPatches: () => (/* binding */ applyPatches),\n/* harmony export */   castDraft: () => (/* binding */ castDraft),\n/* harmony export */   castImmutable: () => (/* binding */ castImmutable),\n/* harmony export */   createDraft: () => (/* binding */ createDraft),\n/* harmony export */   current: () => (/* binding */ current),\n/* harmony export */   enableMapSet: () => (/* binding */ enableMapSet),\n/* harmony export */   enablePatches: () => (/* binding */ enablePatches),\n/* harmony export */   finishDraft: () => (/* binding */ finishDraft),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   immerable: () => (/* binding */ DRAFTABLE),\n/* harmony export */   isDraft: () => (/* binding */ isDraft),\n/* harmony export */   isDraftable: () => (/* binding */ isDraftable),\n/* harmony export */   nothing: () => (/* binding */ NOTHING),\n/* harmony export */   original: () => (/* binding */ original),\n/* harmony export */   produce: () => (/* binding */ produce),\n/* harmony export */   produceWithPatches: () => (/* binding */ produceWithPatches),\n/* harmony export */   setAutoFreeze: () => (/* binding */ setAutoFreeze),\n/* harmony export */   setUseStrictIteration: () => (/* binding */ setUseStrictIteration),\n/* harmony export */   setUseStrictShallowCopy: () => (/* binding */ setUseStrictShallowCopy)\n/* harmony export */ });\n// src/utils/env.ts\nvar NOTHING = Symbol.for(\"immer-nothing\");\nvar DRAFTABLE = Symbol.for(\"immer-draftable\");\nvar DRAFT_STATE = Symbol.for(\"immer-state\");\n// src/utils/errors.ts\nvar errors =  true ? [\n    // All error codes, starting by 0:\n    function(plugin) {\n        return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`;\n    },\n    function(thing) {\n        return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;\n    },\n    \"This object has been frozen and should not be mutated\",\n    function(data) {\n        return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n    },\n    \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n    \"Immer forbids circular references\",\n    \"The first or second argument to `produce` must be a function\",\n    \"The third argument to `produce` must be a function or undefined\",\n    \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n    \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n    function(thing) {\n        return `'current' expects a draft, got: ${thing}`;\n    },\n    \"Object.defineProperty() cannot be used on an Immer draft\",\n    \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n    \"Immer only supports deleting array indices\",\n    \"Immer only supports setting array indices and the 'length' property\",\n    function(thing) {\n        return `'original' expects a draft, got: ${thing}`;\n    }\n] : 0;\nfunction die(error, ...args) {\n    if (true) {\n        const e = errors[error];\n        const msg = isFunction(e) ? e.apply(null, args) : e;\n        throw new Error(`[Immer] ${msg}`);\n    }\n    throw new Error(`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`);\n}\n// src/utils/common.ts\nvar O = Object;\nvar getPrototypeOf = O.getPrototypeOf;\nvar CONSTRUCTOR = \"constructor\";\nvar PROTOTYPE = \"prototype\";\nvar CONFIGURABLE = \"configurable\";\nvar ENUMERABLE = \"enumerable\";\nvar WRITABLE = \"writable\";\nvar VALUE = \"value\";\nvar isDraft = (value)=>!!value && !!value[DRAFT_STATE];\nfunction isDraftable(value) {\n    if (!value) return false;\n    return isPlainObject(value) || isArray(value) || !!value[DRAFTABLE] || !!value[CONSTRUCTOR]?.[DRAFTABLE] || isMap(value) || isSet(value);\n}\nvar objectCtorString = O[PROTOTYPE][CONSTRUCTOR].toString();\nvar cachedCtorStrings = /* @__PURE__ */ new WeakMap();\nfunction isPlainObject(value) {\n    if (!value || !isObjectish(value)) return false;\n    const proto = getPrototypeOf(value);\n    if (proto === null || proto === O[PROTOTYPE]) return true;\n    const Ctor = O.hasOwnProperty.call(proto, CONSTRUCTOR) && proto[CONSTRUCTOR];\n    if (Ctor === Object) return true;\n    if (!isFunction(Ctor)) return false;\n    let ctorString = cachedCtorStrings.get(Ctor);\n    if (ctorString === void 0) {\n        ctorString = Function.toString.call(Ctor);\n        cachedCtorStrings.set(Ctor, ctorString);\n    }\n    return ctorString === objectCtorString;\n}\nfunction original(value) {\n    if (!isDraft(value)) die(15, value);\n    return value[DRAFT_STATE].base_;\n}\nfunction each(obj, iter, strict = true) {\n    if (getArchtype(obj) === 0 /* Object */ ) {\n        const keys = strict ? Reflect.ownKeys(obj) : O.keys(obj);\n        keys.forEach((key)=>{\n            iter(key, obj[key], obj);\n        });\n    } else {\n        obj.forEach((entry, index)=>iter(index, entry, obj));\n    }\n}\nfunction getArchtype(thing) {\n    const state = thing[DRAFT_STATE];\n    return state ? state.type_ : isArray(thing) ? 1 /* Array */  : isMap(thing) ? 2 /* Map */  : isSet(thing) ? 3 /* Set */  : 0 /* Object */ ;\n}\nvar has = (thing, prop, type = getArchtype(thing))=>type === 2 /* Map */  ? thing.has(prop) : O[PROTOTYPE].hasOwnProperty.call(thing, prop);\nvar get = (thing, prop, type = getArchtype(thing))=>// @ts-ignore\n    type === 2 /* Map */  ? thing.get(prop) : thing[prop];\nvar set = (thing, propOrOldValue, value, type = getArchtype(thing))=>{\n    if (type === 2 /* Map */ ) thing.set(propOrOldValue, value);\n    else if (type === 3 /* Set */ ) {\n        thing.add(value);\n    } else thing[propOrOldValue] = value;\n};\nfunction is(x, y) {\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n    } else {\n        return x !== x && y !== y;\n    }\n}\nvar isArray = Array.isArray;\nvar isMap = (target)=>target instanceof Map;\nvar isSet = (target)=>target instanceof Set;\nvar isObjectish = (target)=>typeof target === \"object\";\nvar isFunction = (target)=>typeof target === \"function\";\nvar isBoolean = (target)=>typeof target === \"boolean\";\nvar getProxyDraft = (value)=>{\n    if (!isObjectish(value)) return null;\n    return value?.[DRAFT_STATE];\n};\nvar latest = (state)=>state.copy_ || state.base_;\nvar getValue = (value)=>{\n    const proxyDraft = getProxyDraft(value);\n    return proxyDraft ? proxyDraft.copy_ ?? proxyDraft.base_ : value;\n};\nvar getFinalValue = (state)=>state.modified_ ? state.copy_ : state.base_;\nfunction shallowCopy(base, strict) {\n    if (isMap(base)) {\n        return new Map(base);\n    }\n    if (isSet(base)) {\n        return new Set(base);\n    }\n    if (isArray(base)) return Array[PROTOTYPE].slice.call(base);\n    const isPlain = isPlainObject(base);\n    if (strict === true || strict === \"class_only\" && !isPlain) {\n        const descriptors = O.getOwnPropertyDescriptors(base);\n        delete descriptors[DRAFT_STATE];\n        let keys = Reflect.ownKeys(descriptors);\n        for(let i = 0; i < keys.length; i++){\n            const key = keys[i];\n            const desc = descriptors[key];\n            if (desc[WRITABLE] === false) {\n                desc[WRITABLE] = true;\n                desc[CONFIGURABLE] = true;\n            }\n            if (desc.get || desc.set) descriptors[key] = {\n                [CONFIGURABLE]: true,\n                [WRITABLE]: true,\n                // could live with !!desc.set as well here...\n                [ENUMERABLE]: desc[ENUMERABLE],\n                [VALUE]: base[key]\n            };\n        }\n        return O.create(getPrototypeOf(base), descriptors);\n    } else {\n        const proto = getPrototypeOf(base);\n        if (proto !== null && isPlain) {\n            return {\n                ...base\n            };\n        }\n        const obj = O.create(proto);\n        return O.assign(obj, base);\n    }\n}\nfunction freeze(obj, deep = false) {\n    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;\n    if (getArchtype(obj) > 1) {\n        O.defineProperties(obj, {\n            set: dontMutateMethodOverride,\n            add: dontMutateMethodOverride,\n            clear: dontMutateMethodOverride,\n            delete: dontMutateMethodOverride\n        });\n    }\n    O.freeze(obj);\n    if (deep) each(obj, (_key, value)=>{\n        freeze(value, true);\n    }, false);\n    return obj;\n}\nfunction dontMutateFrozenCollections() {\n    die(2);\n}\nvar dontMutateMethodOverride = {\n    [VALUE]: dontMutateFrozenCollections\n};\nfunction isFrozen(obj) {\n    if (obj === null || !isObjectish(obj)) return true;\n    return O.isFrozen(obj);\n}\n// src/utils/plugins.ts\nvar PluginMapSet = \"MapSet\";\nvar PluginPatches = \"Patches\";\nvar plugins = {};\nfunction getPlugin(pluginKey) {\n    const plugin = plugins[pluginKey];\n    if (!plugin) {\n        die(0, pluginKey);\n    }\n    return plugin;\n}\nvar isPluginLoaded = (pluginKey)=>!!plugins[pluginKey];\nfunction loadPlugin(pluginKey, implementation) {\n    if (!plugins[pluginKey]) plugins[pluginKey] = implementation;\n}\n// src/core/scope.ts\nvar currentScope;\nvar getCurrentScope = ()=>currentScope;\nvar createScope = (parent_, immer_)=>({\n        drafts_: [],\n        parent_,\n        immer_,\n        // Whenever the modified draft contains a draft from another scope, we\n        // need to prevent auto-freezing so the unowned draft can be finalized.\n        canAutoFreeze_: true,\n        unfinalizedDrafts_: 0,\n        handledSet_: /* @__PURE__ */ new Set(),\n        processedForPatches_: /* @__PURE__ */ new Set(),\n        mapSetPlugin_: isPluginLoaded(PluginMapSet) ? getPlugin(PluginMapSet) : void 0\n    });\nfunction usePatchesInScope(scope, patchListener) {\n    if (patchListener) {\n        scope.patchPlugin_ = getPlugin(PluginPatches);\n        scope.patches_ = [];\n        scope.inversePatches_ = [];\n        scope.patchListener_ = patchListener;\n    }\n}\nfunction revokeScope(scope) {\n    leaveScope(scope);\n    scope.drafts_.forEach(revokeDraft);\n    scope.drafts_ = null;\n}\nfunction leaveScope(scope) {\n    if (scope === currentScope) {\n        currentScope = scope.parent_;\n    }\n}\nvar enterScope = (immer2)=>currentScope = createScope(currentScope, immer2);\nfunction revokeDraft(draft) {\n    const state = draft[DRAFT_STATE];\n    if (state.type_ === 0 /* Object */  || state.type_ === 1 /* Array */ ) state.revoke_();\n    else state.revoked_ = true;\n}\n// src/core/finalize.ts\nfunction processResult(result, scope) {\n    scope.unfinalizedDrafts_ = scope.drafts_.length;\n    const baseDraft = scope.drafts_[0];\n    const isReplaced = result !== void 0 && result !== baseDraft;\n    if (isReplaced) {\n        if (baseDraft[DRAFT_STATE].modified_) {\n            revokeScope(scope);\n            die(4);\n        }\n        if (isDraftable(result)) {\n            result = finalize(scope, result);\n        }\n        const { patchPlugin_ } = scope;\n        if (patchPlugin_) {\n            patchPlugin_.generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope);\n        }\n    } else {\n        result = finalize(scope, baseDraft);\n    }\n    maybeFreeze(scope, result, true);\n    revokeScope(scope);\n    if (scope.patches_) {\n        scope.patchListener_(scope.patches_, scope.inversePatches_);\n    }\n    return result !== NOTHING ? result : void 0;\n}\nfunction finalize(rootScope, value) {\n    if (isFrozen(value)) return value;\n    const state = value[DRAFT_STATE];\n    if (!state) {\n        const finalValue = handleValue(value, rootScope.handledSet_, rootScope);\n        return finalValue;\n    }\n    if (!isSameScope(state, rootScope)) {\n        return value;\n    }\n    if (!state.modified_) {\n        return state.base_;\n    }\n    if (!state.finalized_) {\n        const { callbacks_ } = state;\n        if (callbacks_) {\n            while(callbacks_.length > 0){\n                const callback = callbacks_.pop();\n                callback(rootScope);\n            }\n        }\n        generatePatchesAndFinalize(state, rootScope);\n    }\n    return state.copy_;\n}\nfunction maybeFreeze(scope, value, deep = false) {\n    if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n        freeze(value, deep);\n    }\n}\nfunction markStateFinalized(state) {\n    state.finalized_ = true;\n    state.scope_.unfinalizedDrafts_--;\n}\nvar isSameScope = (state, rootScope)=>state.scope_ === rootScope;\nvar EMPTY_LOCATIONS_RESULT = [];\nfunction updateDraftInParent(parent, draftValue, finalizedValue, originalKey) {\n    const parentCopy = latest(parent);\n    const parentType = parent.type_;\n    if (originalKey !== void 0) {\n        const currentValue = get(parentCopy, originalKey, parentType);\n        if (currentValue === draftValue) {\n            set(parentCopy, originalKey, finalizedValue, parentType);\n            return;\n        }\n    }\n    if (!parent.draftLocations_) {\n        const draftLocations = parent.draftLocations_ = /* @__PURE__ */ new Map();\n        each(parentCopy, (key, value)=>{\n            if (isDraft(value)) {\n                const keys = draftLocations.get(value) || [];\n                keys.push(key);\n                draftLocations.set(value, keys);\n            }\n        });\n    }\n    const locations = parent.draftLocations_.get(draftValue) ?? EMPTY_LOCATIONS_RESULT;\n    for (const location of locations){\n        set(parentCopy, location, finalizedValue, parentType);\n    }\n}\nfunction registerChildFinalizationCallback(parent, child, key) {\n    parent.callbacks_.push(function childCleanup(rootScope) {\n        const state = child;\n        if (!state || !isSameScope(state, rootScope)) {\n            return;\n        }\n        rootScope.mapSetPlugin_?.fixSetContents(state);\n        const finalizedValue = getFinalValue(state);\n        updateDraftInParent(parent, state.draft_ ?? state, finalizedValue, key);\n        generatePatchesAndFinalize(state, rootScope);\n    });\n}\nfunction generatePatchesAndFinalize(state, rootScope) {\n    const shouldFinalize = state.modified_ && !state.finalized_ && (state.type_ === 3 /* Set */  || (state.assigned_?.size ?? 0) > 0);\n    if (shouldFinalize) {\n        const { patchPlugin_ } = rootScope;\n        if (patchPlugin_) {\n            const basePath = patchPlugin_.getPath(state);\n            if (basePath) {\n                patchPlugin_.generatePatches_(state, basePath, rootScope);\n            }\n        }\n        markStateFinalized(state);\n    }\n}\nfunction handleCrossReference(target, key, value) {\n    const { scope_ } = target;\n    if (isDraft(value)) {\n        const state = value[DRAFT_STATE];\n        if (isSameScope(state, scope_)) {\n            state.callbacks_.push(function crossReferenceCleanup() {\n                prepareCopy(target);\n                const finalizedValue = getFinalValue(state);\n                updateDraftInParent(target, value, finalizedValue, key);\n            });\n        }\n    } else if (isDraftable(value)) {\n        target.callbacks_.push(function nestedDraftCleanup() {\n            const targetCopy = latest(target);\n            if (get(targetCopy, key, target.type_) === value) {\n                if (scope_.drafts_.length > 1 && (target.assigned_.get(key) ?? false) === true && target.copy_) {\n                    handleValue(get(target.copy_, key, target.type_), scope_.handledSet_, scope_);\n                }\n            }\n        });\n    }\n}\nfunction handleValue(target, handledSet, rootScope) {\n    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n        return target;\n    }\n    if (isDraft(target) || handledSet.has(target) || !isDraftable(target) || isFrozen(target)) {\n        return target;\n    }\n    handledSet.add(target);\n    each(target, (key, value)=>{\n        if (isDraft(value)) {\n            const state = value[DRAFT_STATE];\n            if (isSameScope(state, rootScope)) {\n                const updatedValue = getFinalValue(state);\n                set(target, key, updatedValue, target.type_);\n                markStateFinalized(state);\n            }\n        } else if (isDraftable(value)) {\n            handleValue(value, handledSet, rootScope);\n        }\n    });\n    return target;\n}\n// src/core/proxy.ts\nfunction createProxyProxy(base, parent) {\n    const baseIsArray = isArray(base);\n    const state = {\n        type_: baseIsArray ? 1 /* Array */  : 0 /* Object */ ,\n        // Track which produce call this is associated with.\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        // True for both shallow and deep changes.\n        modified_: false,\n        // Used during finalization.\n        finalized_: false,\n        // Track which properties have been assigned (true) or deleted (false).\n        // actually instantiated in `prepareCopy()`\n        assigned_: void 0,\n        // The parent draft state.\n        parent_: parent,\n        // The base state.\n        base_: base,\n        // The base proxy.\n        draft_: null,\n        // set below\n        // The base copy with any updated values.\n        copy_: null,\n        // Called by the `produce` function.\n        revoke_: null,\n        isManual_: false,\n        // `callbacks` actually gets assigned in `createProxy`\n        callbacks_: void 0\n    };\n    let target = state;\n    let traps = objectTraps;\n    if (baseIsArray) {\n        target = [\n            state\n        ];\n        traps = arrayTraps;\n    }\n    const { revoke, proxy } = Proxy.revocable(target, traps);\n    state.draft_ = proxy;\n    state.revoke_ = revoke;\n    return [\n        proxy,\n        state\n    ];\n}\nvar objectTraps = {\n    get (state, prop) {\n        if (prop === DRAFT_STATE) return state;\n        const source = latest(state);\n        if (!has(source, prop, state.type_)) {\n            return readPropFromProto(state, source, prop);\n        }\n        const value = source[prop];\n        if (state.finalized_ || !isDraftable(value)) {\n            return value;\n        }\n        if (value === peek(state.base_, prop)) {\n            prepareCopy(state);\n            const childKey = state.type_ === 1 /* Array */  ? +prop : prop;\n            const childDraft = createProxy(state.scope_, value, state, childKey);\n            return state.copy_[childKey] = childDraft;\n        }\n        return value;\n    },\n    has (state, prop) {\n        return prop in latest(state);\n    },\n    ownKeys (state) {\n        return Reflect.ownKeys(latest(state));\n    },\n    set (state, prop, value) {\n        const desc = getDescriptorFromProto(latest(state), prop);\n        if (desc?.set) {\n            desc.set.call(state.draft_, value);\n            return true;\n        }\n        if (!state.modified_) {\n            const current2 = peek(latest(state), prop);\n            const currentState = current2?.[DRAFT_STATE];\n            if (currentState && currentState.base_ === value) {\n                state.copy_[prop] = value;\n                state.assigned_.set(prop, false);\n                return true;\n            }\n            if (is(value, current2) && (value !== void 0 || has(state.base_, prop, state.type_))) return true;\n            prepareCopy(state);\n            markChanged(state);\n        }\n        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'\n        (value !== void 0 || prop in state.copy_) || // special case: NaN\n        Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;\n        state.copy_[prop] = value;\n        state.assigned_.set(prop, true);\n        handleCrossReference(state, prop, value);\n        return true;\n    },\n    deleteProperty (state, prop) {\n        prepareCopy(state);\n        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {\n            state.assigned_.set(prop, false);\n            markChanged(state);\n        } else {\n            state.assigned_.delete(prop);\n        }\n        if (state.copy_) {\n            delete state.copy_[prop];\n        }\n        return true;\n    },\n    // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n    // the same guarantee in ES5 mode.\n    getOwnPropertyDescriptor (state, prop) {\n        const owner = latest(state);\n        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n        if (!desc) return desc;\n        return {\n            [WRITABLE]: true,\n            [CONFIGURABLE]: state.type_ !== 1 /* Array */  || prop !== \"length\",\n            [ENUMERABLE]: desc[ENUMERABLE],\n            [VALUE]: owner[prop]\n        };\n    },\n    defineProperty () {\n        die(11);\n    },\n    getPrototypeOf (state) {\n        return getPrototypeOf(state.base_);\n    },\n    setPrototypeOf () {\n        die(12);\n    }\n};\nvar arrayTraps = {};\neach(objectTraps, (key, fn)=>{\n    arrayTraps[key] = function() {\n        const args = arguments;\n        args[0] = args[0][0];\n        return fn.apply(this, args);\n    };\n});\narrayTraps.deleteProperty = function(state, prop) {\n    if ( true && isNaN(parseInt(prop))) die(13);\n    return arrayTraps.set.call(this, state, prop, void 0);\n};\narrayTraps.set = function(state, prop, value) {\n    if ( true && prop !== \"length\" && isNaN(parseInt(prop))) die(14);\n    return objectTraps.set.call(this, state[0], prop, value, state[0]);\n};\nfunction peek(draft, prop) {\n    const state = draft[DRAFT_STATE];\n    const source = state ? latest(state) : draft;\n    return source[prop];\n}\nfunction readPropFromProto(state, source, prop) {\n    const desc = getDescriptorFromProto(source, prop);\n    return desc ? VALUE in desc ? desc[VALUE] : (// This is a very special case, if the prop is a getter defined by the\n    // prototype, we should invoke it with the draft as context!\n    desc.get?.call(state.draft_)) : void 0;\n}\nfunction getDescriptorFromProto(source, prop) {\n    if (!(prop in source)) return void 0;\n    let proto = getPrototypeOf(source);\n    while(proto){\n        const desc = Object.getOwnPropertyDescriptor(proto, prop);\n        if (desc) return desc;\n        proto = getPrototypeOf(proto);\n    }\n    return void 0;\n}\nfunction markChanged(state) {\n    if (!state.modified_) {\n        state.modified_ = true;\n        if (state.parent_) {\n            markChanged(state.parent_);\n        }\n    }\n}\nfunction prepareCopy(state) {\n    if (!state.copy_) {\n        state.assigned_ = /* @__PURE__ */ new Map();\n        state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);\n    }\n}\n// src/core/immerClass.ts\nvar Immer2 = class {\n    constructor(config){\n        this.autoFreeze_ = true;\n        this.useStrictShallowCopy_ = false;\n        this.useStrictIteration_ = false;\n        /**\n     * The `produce` function takes a value and a \"recipe function\" (whose\n     * return value often depends on the base state). The recipe function is\n     * free to mutate its first argument however it wants. All mutations are\n     * only ever applied to a __copy__ of the base state.\n     *\n     * Pass only a function to create a \"curried producer\" which relieves you\n     * from passing the recipe function every time.\n     *\n     * Only plain objects and arrays are made mutable. All other objects are\n     * considered uncopyable.\n     *\n     * Note: This function is __bound__ to its `Immer` instance.\n     *\n     * @param {any} base - the initial state\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\n     * @returns {any} a new state, or the initial state if nothing was modified\n     */ this.produce = (base, recipe, patchListener)=>{\n            if (isFunction(base) && !isFunction(recipe)) {\n                const defaultBase = recipe;\n                recipe = base;\n                const self = this;\n                return function curriedProduce(base2 = defaultBase, ...args) {\n                    return self.produce(base2, (draft)=>recipe.call(this, draft, ...args));\n                };\n            }\n            if (!isFunction(recipe)) die(6);\n            if (patchListener !== void 0 && !isFunction(patchListener)) die(7);\n            let result;\n            if (isDraftable(base)) {\n                const scope = enterScope(this);\n                const proxy = createProxy(scope, base, void 0);\n                let hasError = true;\n                try {\n                    result = recipe(proxy);\n                    hasError = false;\n                } finally{\n                    if (hasError) revokeScope(scope);\n                    else leaveScope(scope);\n                }\n                usePatchesInScope(scope, patchListener);\n                return processResult(result, scope);\n            } else if (!base || !isObjectish(base)) {\n                result = recipe(base);\n                if (result === void 0) result = base;\n                if (result === NOTHING) result = void 0;\n                if (this.autoFreeze_) freeze(result, true);\n                if (patchListener) {\n                    const p = [];\n                    const ip = [];\n                    getPlugin(PluginPatches).generateReplacementPatches_(base, result, {\n                        patches_: p,\n                        inversePatches_: ip\n                    });\n                    patchListener(p, ip);\n                }\n                return result;\n            } else die(1, base);\n        };\n        this.produceWithPatches = (base, recipe)=>{\n            if (isFunction(base)) {\n                return (state, ...args)=>this.produceWithPatches(state, (draft)=>base(draft, ...args));\n            }\n            let patches, inversePatches;\n            const result = this.produce(base, recipe, (p, ip)=>{\n                patches = p;\n                inversePatches = ip;\n            });\n            return [\n                result,\n                patches,\n                inversePatches\n            ];\n        };\n        if (isBoolean(config?.autoFreeze)) this.setAutoFreeze(config.autoFreeze);\n        if (isBoolean(config?.useStrictShallowCopy)) this.setUseStrictShallowCopy(config.useStrictShallowCopy);\n        if (isBoolean(config?.useStrictIteration)) this.setUseStrictIteration(config.useStrictIteration);\n    }\n    createDraft(base) {\n        if (!isDraftable(base)) die(8);\n        if (isDraft(base)) base = current(base);\n        const scope = enterScope(this);\n        const proxy = createProxy(scope, base, void 0);\n        proxy[DRAFT_STATE].isManual_ = true;\n        leaveScope(scope);\n        return proxy;\n    }\n    finishDraft(draft, patchListener) {\n        const state = draft && draft[DRAFT_STATE];\n        if (!state || !state.isManual_) die(9);\n        const { scope_: scope } = state;\n        usePatchesInScope(scope, patchListener);\n        return processResult(void 0, scope);\n    }\n    /**\n   * Pass true to automatically freeze all copies created by Immer.\n   *\n   * By default, auto-freezing is enabled.\n   */ setAutoFreeze(value) {\n        this.autoFreeze_ = value;\n    }\n    /**\n   * Pass true to enable strict shallow copy.\n   *\n   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n   */ setUseStrictShallowCopy(value) {\n        this.useStrictShallowCopy_ = value;\n    }\n    /**\n   * Pass false to use faster iteration that skips non-enumerable properties\n   * but still handles symbols for compatibility.\n   *\n   * By default, strict iteration is enabled (includes all own properties).\n   */ setUseStrictIteration(value) {\n        this.useStrictIteration_ = value;\n    }\n    shouldUseStrictIteration() {\n        return this.useStrictIteration_;\n    }\n    applyPatches(base, patches) {\n        let i;\n        for(i = patches.length - 1; i >= 0; i--){\n            const patch = patches[i];\n            if (patch.path.length === 0 && patch.op === \"replace\") {\n                base = patch.value;\n                break;\n            }\n        }\n        if (i > -1) {\n            patches = patches.slice(i + 1);\n        }\n        const applyPatchesImpl = getPlugin(PluginPatches).applyPatches_;\n        if (isDraft(base)) {\n            return applyPatchesImpl(base, patches);\n        }\n        return this.produce(base, (draft)=>applyPatchesImpl(draft, patches));\n    }\n};\nfunction createProxy(rootScope, value, parent, key) {\n    const [draft, state] = isMap(value) ? getPlugin(PluginMapSet).proxyMap_(value, parent) : isSet(value) ? getPlugin(PluginMapSet).proxySet_(value, parent) : createProxyProxy(value, parent);\n    const scope = parent?.scope_ ?? getCurrentScope();\n    scope.drafts_.push(draft);\n    state.callbacks_ = parent?.callbacks_ ?? [];\n    state.key_ = key;\n    if (parent && key !== void 0) {\n        registerChildFinalizationCallback(parent, state, key);\n    } else {\n        state.callbacks_.push(function rootDraftCleanup(rootScope2) {\n            rootScope2.mapSetPlugin_?.fixSetContents(state);\n            const { patchPlugin_ } = rootScope2;\n            if (state.modified_ && patchPlugin_) {\n                patchPlugin_.generatePatches_(state, [], rootScope2);\n            }\n        });\n    }\n    return draft;\n}\n// src/core/current.ts\nfunction current(value) {\n    if (!isDraft(value)) die(10, value);\n    return currentImpl(value);\n}\nfunction currentImpl(value) {\n    if (!isDraftable(value) || isFrozen(value)) return value;\n    const state = value[DRAFT_STATE];\n    let copy;\n    let strict = true;\n    if (state) {\n        if (!state.modified_) return state.base_;\n        state.finalized_ = true;\n        copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);\n        strict = state.scope_.immer_.shouldUseStrictIteration();\n    } else {\n        copy = shallowCopy(value, true);\n    }\n    each(copy, (key, childValue)=>{\n        set(copy, key, currentImpl(childValue));\n    }, strict);\n    if (state) {\n        state.finalized_ = false;\n    }\n    return copy;\n}\n// src/plugins/patches.ts\nfunction enablePatches() {\n    const errorOffset = 16;\n    if (true) {\n        errors.push('Sets cannot have \"replace\" patches.', function(op) {\n            return \"Unsupported patch operation: \" + op;\n        }, function(path) {\n            return \"Cannot apply patch, path doesn't resolve: \" + path;\n        }, \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\");\n    }\n    function getPath(state, path = []) {\n        if (\"key_\" in state && state.key_ !== void 0) {\n            const parentCopy = state.parent_.copy_ ?? state.parent_.base_;\n            const proxyDraft = getProxyDraft(get(parentCopy, state.key_));\n            const valueAtKey = get(parentCopy, state.key_);\n            if (valueAtKey === void 0) {\n                return null;\n            }\n            if (valueAtKey !== state.draft_ && valueAtKey !== state.base_ && valueAtKey !== state.copy_) {\n                return null;\n            }\n            if (proxyDraft != null && proxyDraft.base_ !== state.base_) {\n                return null;\n            }\n            const isSet2 = state.parent_.type_ === 3 /* Set */ ;\n            let key;\n            if (isSet2) {\n                const setParent = state.parent_;\n                key = Array.from(setParent.drafts_.keys()).indexOf(state.key_);\n            } else {\n                key = state.key_;\n            }\n            if (!(isSet2 && parentCopy.size > key || has(parentCopy, key))) {\n                return null;\n            }\n            path.push(key);\n        }\n        if (state.parent_) {\n            return getPath(state.parent_, path);\n        }\n        path.reverse();\n        try {\n            resolvePath(state.copy_, path);\n        } catch (e) {\n            return null;\n        }\n        return path;\n    }\n    function resolvePath(base, path) {\n        let current2 = base;\n        for(let i = 0; i < path.length - 1; i++){\n            const key = path[i];\n            current2 = get(current2, key);\n            if (!isObjectish(current2) || current2 === null) {\n                throw new Error(`Cannot resolve path at '${path.join(\"/\")}'`);\n            }\n        }\n        return current2;\n    }\n    const REPLACE = \"replace\";\n    const ADD = \"add\";\n    const REMOVE = \"remove\";\n    function generatePatches_(state, basePath, scope) {\n        if (state.scope_.processedForPatches_.has(state)) {\n            return;\n        }\n        state.scope_.processedForPatches_.add(state);\n        const { patches_, inversePatches_ } = scope;\n        switch(state.type_){\n            case 0 /* Object */ :\n            case 2 /* Map */ :\n                return generatePatchesFromAssigned(state, basePath, patches_, inversePatches_);\n            case 1 /* Array */ :\n                return generateArrayPatches(state, basePath, patches_, inversePatches_);\n            case 3 /* Set */ :\n                return generateSetPatches(state, basePath, patches_, inversePatches_);\n        }\n    }\n    function generateArrayPatches(state, basePath, patches, inversePatches) {\n        let { base_, assigned_ } = state;\n        let copy_ = state.copy_;\n        if (copy_.length < base_.length) {\n            ;\n            [base_, copy_] = [\n                copy_,\n                base_\n            ];\n            [patches, inversePatches] = [\n                inversePatches,\n                patches\n            ];\n        }\n        for(let i = 0; i < base_.length; i++){\n            const copiedItem = copy_[i];\n            const baseItem = base_[i];\n            if (assigned_?.get(i.toString()) && copiedItem !== baseItem) {\n                const childState = copiedItem?.[DRAFT_STATE];\n                if (childState && childState.modified_) {\n                    continue;\n                }\n                const path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: REPLACE,\n                    path,\n                    // Need to maybe clone it, as it can in fact be the original value\n                    // due to the base/copy inversion at the start of this function\n                    value: clonePatchValueIfNeeded(copiedItem)\n                });\n                inversePatches.push({\n                    op: REPLACE,\n                    path,\n                    value: clonePatchValueIfNeeded(baseItem)\n                });\n            }\n        }\n        for(let i = base_.length; i < copy_.length; i++){\n            const path = basePath.concat([\n                i\n            ]);\n            patches.push({\n                op: ADD,\n                path,\n                // Need to maybe clone it, as it can in fact be the original value\n                // due to the base/copy inversion at the start of this function\n                value: clonePatchValueIfNeeded(copy_[i])\n            });\n        }\n        for(let i = copy_.length - 1; base_.length <= i; --i){\n            const path = basePath.concat([\n                i\n            ]);\n            inversePatches.push({\n                op: REMOVE,\n                path\n            });\n        }\n    }\n    function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n        const { base_, copy_, type_ } = state;\n        each(state.assigned_, (key, assignedValue)=>{\n            const origValue = get(base_, key, type_);\n            const value = get(copy_, key, type_);\n            const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n            if (origValue === value && op === REPLACE) return;\n            const path = basePath.concat(key);\n            patches.push(op === REMOVE ? {\n                op,\n                path\n            } : {\n                op,\n                path,\n                value: clonePatchValueIfNeeded(value)\n            });\n            inversePatches.push(op === ADD ? {\n                op: REMOVE,\n                path\n            } : op === REMOVE ? {\n                op: ADD,\n                path,\n                value: clonePatchValueIfNeeded(origValue)\n            } : {\n                op: REPLACE,\n                path,\n                value: clonePatchValueIfNeeded(origValue)\n            });\n        });\n    }\n    function generateSetPatches(state, basePath, patches, inversePatches) {\n        let { base_, copy_ } = state;\n        let i = 0;\n        base_.forEach((value)=>{\n            if (!copy_.has(value)) {\n                const path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: REMOVE,\n                    path,\n                    value\n                });\n                inversePatches.unshift({\n                    op: ADD,\n                    path,\n                    value\n                });\n            }\n            i++;\n        });\n        i = 0;\n        copy_.forEach((value)=>{\n            if (!base_.has(value)) {\n                const path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: ADD,\n                    path,\n                    value\n                });\n                inversePatches.unshift({\n                    op: REMOVE,\n                    path,\n                    value\n                });\n            }\n            i++;\n        });\n    }\n    function generateReplacementPatches_(baseValue, replacement, scope) {\n        const { patches_, inversePatches_ } = scope;\n        patches_.push({\n            op: REPLACE,\n            path: [],\n            value: replacement === NOTHING ? void 0 : replacement\n        });\n        inversePatches_.push({\n            op: REPLACE,\n            path: [],\n            value: baseValue\n        });\n    }\n    function applyPatches_(draft, patches) {\n        patches.forEach((patch)=>{\n            const { path, op } = patch;\n            let base = draft;\n            for(let i = 0; i < path.length - 1; i++){\n                const parentType = getArchtype(base);\n                let p = path[i];\n                if (typeof p !== \"string\" && typeof p !== \"number\") {\n                    p = \"\" + p;\n                }\n                if ((parentType === 0 /* Object */  || parentType === 1 /* Array */ ) && (p === \"__proto__\" || p === CONSTRUCTOR)) die(errorOffset + 3);\n                if (isFunction(base) && p === PROTOTYPE) die(errorOffset + 3);\n                base = get(base, p);\n                if (!isObjectish(base)) die(errorOffset + 2, path.join(\"/\"));\n            }\n            const type = getArchtype(base);\n            const value = deepClonePatchValue(patch.value);\n            const key = path[path.length - 1];\n            switch(op){\n                case REPLACE:\n                    switch(type){\n                        case 2 /* Map */ :\n                            return base.set(key, value);\n                        case 3 /* Set */ :\n                            die(errorOffset);\n                        default:\n                            return base[key] = value;\n                    }\n                case ADD:\n                    switch(type){\n                        case 1 /* Array */ :\n                            return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n                        case 2 /* Map */ :\n                            return base.set(key, value);\n                        case 3 /* Set */ :\n                            return base.add(value);\n                        default:\n                            return base[key] = value;\n                    }\n                case REMOVE:\n                    switch(type){\n                        case 1 /* Array */ :\n                            return base.splice(key, 1);\n                        case 2 /* Map */ :\n                            return base.delete(key);\n                        case 3 /* Set */ :\n                            return base.delete(patch.value);\n                        default:\n                            return delete base[key];\n                    }\n                default:\n                    die(errorOffset + 1, op);\n            }\n        });\n        return draft;\n    }\n    function deepClonePatchValue(obj) {\n        if (!isDraftable(obj)) return obj;\n        if (isArray(obj)) return obj.map(deepClonePatchValue);\n        if (isMap(obj)) return new Map(Array.from(obj.entries()).map(([k, v])=>[\n                k,\n                deepClonePatchValue(v)\n            ]));\n        if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));\n        const cloned = Object.create(getPrototypeOf(obj));\n        for(const key in obj)cloned[key] = deepClonePatchValue(obj[key]);\n        if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];\n        return cloned;\n    }\n    function clonePatchValueIfNeeded(obj) {\n        if (isDraft(obj)) {\n            return deepClonePatchValue(obj);\n        } else return obj;\n    }\n    loadPlugin(PluginPatches, {\n        applyPatches_,\n        generatePatches_,\n        generateReplacementPatches_,\n        getPath\n    });\n}\n// src/plugins/mapset.ts\nfunction enableMapSet() {\n    class DraftMap extends Map {\n        constructor(target, parent){\n            super();\n            this[DRAFT_STATE] = {\n                type_: 2 /* Map */ ,\n                parent_: parent,\n                scope_: parent ? parent.scope_ : getCurrentScope(),\n                modified_: false,\n                finalized_: false,\n                copy_: void 0,\n                assigned_: void 0,\n                base_: target,\n                draft_: this,\n                isManual_: false,\n                revoked_: false,\n                callbacks_: []\n            };\n        }\n        get size() {\n            return latest(this[DRAFT_STATE]).size;\n        }\n        has(key) {\n            return latest(this[DRAFT_STATE]).has(key);\n        }\n        set(key, value) {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (!latest(state).has(key) || latest(state).get(key) !== value) {\n                prepareMapCopy(state);\n                markChanged(state);\n                state.assigned_.set(key, true);\n                state.copy_.set(key, value);\n                state.assigned_.set(key, true);\n            }\n            return this;\n        }\n        delete(key) {\n            if (!this.has(key)) {\n                return false;\n            }\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareMapCopy(state);\n            markChanged(state);\n            if (state.base_.has(key)) {\n                state.assigned_.set(key, false);\n            } else {\n                state.assigned_.delete(key);\n            }\n            state.copy_.delete(key);\n            return true;\n        }\n        clear() {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (latest(state).size) {\n                prepareMapCopy(state);\n                markChanged(state);\n                state.assigned_ = /* @__PURE__ */ new Map();\n                each(state.base_, (key)=>{\n                    state.assigned_.set(key, false);\n                });\n                state.copy_.clear();\n            }\n        }\n        forEach(cb, thisArg) {\n            const state = this[DRAFT_STATE];\n            latest(state).forEach((_value, key, _map)=>{\n                cb.call(thisArg, this.get(key), key, this);\n            });\n        }\n        get(key) {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            const value = latest(state).get(key);\n            if (state.finalized_ || !isDraftable(value)) {\n                return value;\n            }\n            if (value !== state.base_.get(key)) {\n                return value;\n            }\n            const draft = createProxy(state.scope_, value, state, key);\n            prepareMapCopy(state);\n            state.copy_.set(key, draft);\n            return draft;\n        }\n        keys() {\n            return latest(this[DRAFT_STATE]).keys();\n        }\n        values() {\n            const iterator = this.keys();\n            return {\n                [Symbol.iterator]: ()=>this.values(),\n                next: ()=>{\n                    const r = iterator.next();\n                    if (r.done) return r;\n                    const value = this.get(r.value);\n                    return {\n                        done: false,\n                        value\n                    };\n                }\n            };\n        }\n        entries() {\n            const iterator = this.keys();\n            return {\n                [Symbol.iterator]: ()=>this.entries(),\n                next: ()=>{\n                    const r = iterator.next();\n                    if (r.done) return r;\n                    const value = this.get(r.value);\n                    return {\n                        done: false,\n                        value: [\n                            r.value,\n                            value\n                        ]\n                    };\n                }\n            };\n        }\n        [(DRAFT_STATE, Symbol.iterator)]() {\n            return this.entries();\n        }\n    }\n    function proxyMap_(target, parent) {\n        const map = new DraftMap(target, parent);\n        return [\n            map,\n            map[DRAFT_STATE]\n        ];\n    }\n    function prepareMapCopy(state) {\n        if (!state.copy_) {\n            state.assigned_ = /* @__PURE__ */ new Map();\n            state.copy_ = new Map(state.base_);\n        }\n    }\n    class DraftSet extends Set {\n        constructor(target, parent){\n            super();\n            this[DRAFT_STATE] = {\n                type_: 3 /* Set */ ,\n                parent_: parent,\n                scope_: parent ? parent.scope_ : getCurrentScope(),\n                modified_: false,\n                finalized_: false,\n                copy_: void 0,\n                base_: target,\n                draft_: this,\n                drafts_: /* @__PURE__ */ new Map(),\n                revoked_: false,\n                isManual_: false,\n                assigned_: void 0,\n                callbacks_: []\n            };\n        }\n        get size() {\n            return latest(this[DRAFT_STATE]).size;\n        }\n        has(value) {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (!state.copy_) {\n                return state.base_.has(value);\n            }\n            if (state.copy_.has(value)) return true;\n            if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;\n            return false;\n        }\n        add(value) {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (!this.has(value)) {\n                prepareSetCopy(state);\n                markChanged(state);\n                state.copy_.add(value);\n            }\n            return this;\n        }\n        delete(value) {\n            if (!this.has(value)) {\n                return false;\n            }\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            markChanged(state);\n            return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : /* istanbul ignore next */ false);\n        }\n        clear() {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (latest(state).size) {\n                prepareSetCopy(state);\n                markChanged(state);\n                state.copy_.clear();\n            }\n        }\n        values() {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            return state.copy_.values();\n        }\n        entries() {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            return state.copy_.entries();\n        }\n        keys() {\n            return this.values();\n        }\n        [(DRAFT_STATE, Symbol.iterator)]() {\n            return this.values();\n        }\n        forEach(cb, thisArg) {\n            const iterator = this.values();\n            let result = iterator.next();\n            while(!result.done){\n                cb.call(thisArg, result.value, result.value, this);\n                result = iterator.next();\n            }\n        }\n    }\n    function proxySet_(target, parent) {\n        const set2 = new DraftSet(target, parent);\n        return [\n            set2,\n            set2[DRAFT_STATE]\n        ];\n    }\n    function prepareSetCopy(state) {\n        if (!state.copy_) {\n            state.copy_ = /* @__PURE__ */ new Set();\n            state.base_.forEach((value)=>{\n                if (isDraftable(value)) {\n                    const draft = createProxy(state.scope_, value, state, value);\n                    state.drafts_.set(value, draft);\n                    state.copy_.add(draft);\n                } else {\n                    state.copy_.add(value);\n                }\n            });\n        }\n    }\n    function assertUnrevoked(state) {\n        if (state.revoked_) die(3, JSON.stringify(latest(state)));\n    }\n    function fixSetContents(target) {\n        if (target.type_ === 3 /* Set */  && target.copy_) {\n            const copy = new Set(target.copy_);\n            target.copy_.clear();\n            copy.forEach((value)=>{\n                target.copy_.add(getValue(value));\n            });\n        }\n    }\n    loadPlugin(PluginMapSet, {\n        proxyMap_,\n        proxySet_,\n        fixSetContents\n    });\n}\n// src/immer.ts\nvar immer = new Immer2();\nvar produce = immer.produce;\nvar produceWithPatches = /* @__PURE__ */ immer.produceWithPatches.bind(immer);\nvar setAutoFreeze = /* @__PURE__ */ immer.setAutoFreeze.bind(immer);\nvar setUseStrictShallowCopy = /* @__PURE__ */ immer.setUseStrictShallowCopy.bind(immer);\nvar setUseStrictIteration = /* @__PURE__ */ immer.setUseStrictIteration.bind(immer);\nvar applyPatches = /* @__PURE__ */ immer.applyPatches.bind(immer);\nvar createDraft = /* @__PURE__ */ immer.createDraft.bind(immer);\nvar finishDraft = /* @__PURE__ */ immer.finishDraft.bind(immer);\nvar castDraft = (value)=>value;\nvar castImmutable = (value)=>value;\n //# sourceMappingURL=immer.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbW1lci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxtQkFBbUI7QUFDbkIsSUFBSUEsVUFBVUMsT0FBT0MsR0FBRyxDQUFDO0FBQ3pCLElBQUlDLFlBQVlGLE9BQU9DLEdBQUcsQ0FBQztBQUMzQixJQUFJRSxjQUFjSCxPQUFPQyxHQUFHLENBQUM7QUFFN0Isc0JBQXNCO0FBQ3RCLElBQUlHLFNBQVNDLEtBQXFDLEdBQUc7SUFDbkQsa0NBQWtDO0lBQ2xDLFNBQVNDLE1BQU07UUFDYixPQUFPLENBQUMsZ0JBQWdCLEVBQUVBLE9BQU8sZ0ZBQWdGLEVBQUVBLE9BQU8sd0NBQXdDLENBQUM7SUFDcks7SUFDQSxTQUFTQyxLQUFLO1FBQ1osT0FBTyxDQUFDLG1KQUFtSixFQUFFQSxNQUFNLENBQUMsQ0FBQztJQUN2SztJQUNBO0lBQ0EsU0FBU0MsSUFBSTtRQUNYLE9BQU8seUhBQXlIQTtJQUNsSTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVNELEtBQUs7UUFDWixPQUFPLENBQUMsZ0NBQWdDLEVBQUVBLE1BQU0sQ0FBQztJQUNuRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBU0EsS0FBSztRQUNaLE9BQU8sQ0FBQyxpQ0FBaUMsRUFBRUEsTUFBTSxDQUFDO0lBQ3BEO0NBR0QsR0FBRyxDQUFFO0FBQ04sU0FBU0UsSUFBSUMsS0FBSyxFQUFFLEdBQUdDLElBQUk7SUFDekIsSUFBSU4sSUFBcUMsRUFBRTtRQUN6QyxNQUFNTyxJQUFJUixNQUFNLENBQUNNLE1BQU07UUFDdkIsTUFBTUcsTUFBTUMsV0FBV0YsS0FBS0EsRUFBRUcsS0FBSyxDQUFDLE1BQU1KLFFBQVFDO1FBQ2xELE1BQU0sSUFBSUksTUFBTSxDQUFDLFFBQVEsRUFBRUgsSUFBSSxDQUFDO0lBQ2xDO0lBQ0EsTUFBTSxJQUFJ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RSxJQUFJLENBQ3BFRDtBQUVGLElBQUkxRSxnQkFBZ0IsYUFBYSxHQUFHMEUsTUFBTTFFLGFBQWEsQ0FBQzJFLElBQUksQ0FBQ0Q7QUFDN0QsSUFBSXhFLDBCQUEwQixhQUFhLEdBQUd3RSxNQUFNeEUsdUJBQXVCLENBQUN5RSxJQUFJLENBQzlFRDtBQUVGLElBQUl0RSx3QkFBd0IsYUFBYSxHQUFHc0UsTUFBTXRFLHFCQUFxQixDQUFDdUUsSUFBSSxDQUMxRUQ7QUFFRixJQUFJakUsZUFBZSxhQUFhLEdBQUdpRSxNQUFNakUsWUFBWSxDQUFDa0UsSUFBSSxDQUFDRDtBQUMzRCxJQUFJckUsY0FBYyxhQUFhLEdBQUdxRSxNQUFNckUsV0FBVyxDQUFDc0UsSUFBSSxDQUFDRDtBQUN6RCxJQUFJbkUsY0FBYyxhQUFhLEdBQUdtRSxNQUFNbkUsV0FBVyxDQUFDb0UsSUFBSSxDQUFDRDtBQUN6RCxJQUFJRSxZQUFZLENBQUM1UixRQUFVQTtBQUMzQixJQUFJNlIsZ0JBQWdCLENBQUM3UixRQUFVQTtBQXNCN0IsQ0FDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmJpdGFsLWNvbXB1dGUtY29udHJvbC1yb29tLy4vbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvbm9kZV9tb2R1bGVzL2ltbWVyL2Rpc3QvaW1tZXIubWpzPzUxMmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzL2Vudi50c1xudmFyIE5PVEhJTkcgPSBTeW1ib2wuZm9yKFwiaW1tZXItbm90aGluZ1wiKTtcbnZhciBEUkFGVEFCTEUgPSBTeW1ib2wuZm9yKFwiaW1tZXItZHJhZnRhYmxlXCIpO1xudmFyIERSQUZUX1NUQVRFID0gU3ltYm9sLmZvcihcImltbWVyLXN0YXRlXCIpO1xuXG4vLyBzcmMvdXRpbHMvZXJyb3JzLnRzXG52YXIgZXJyb3JzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gW1xuICAvLyBBbGwgZXJyb3IgY29kZXMsIHN0YXJ0aW5nIGJ5IDA6XG4gIGZ1bmN0aW9uKHBsdWdpbikge1xuICAgIHJldHVybiBgVGhlIHBsdWdpbiBmb3IgJyR7cGx1Z2lufScgaGFzIG5vdCBiZWVuIGxvYWRlZCBpbnRvIEltbWVyLiBUbyBlbmFibGUgdGhlIHBsdWdpbiwgaW1wb3J0IGFuZCBjYWxsIFxcYGVuYWJsZSR7cGx1Z2lufSgpXFxgIHdoZW4gaW5pdGlhbGl6aW5nIHlvdXIgYXBwbGljYXRpb24uYDtcbiAgfSxcbiAgZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gYHByb2R1Y2UgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoaW5ncyB0aGF0IGFyZSBkcmFmdGFibGU6IHBsYWluIG9iamVjdHMsIGFycmF5cywgTWFwLCBTZXQgb3IgY2xhc3NlcyB0aGF0IGFyZSBtYXJrZWQgd2l0aCAnW2ltbWVyYWJsZV06IHRydWUnLiBHb3QgJyR7dGhpbmd9J2A7XG4gIH0sXG4gIFwiVGhpcyBvYmplY3QgaGFzIGJlZW4gZnJvemVuIGFuZCBzaG91bGQgbm90IGJlIG11dGF0ZWRcIixcbiAgZnVuY3Rpb24oZGF0YSkge1xuICAgIHJldHVybiBcIkNhbm5vdCB1c2UgYSBwcm94eSB0aGF0IGhhcyBiZWVuIHJldm9rZWQuIERpZCB5b3UgcGFzcyBhbiBvYmplY3QgZnJvbSBpbnNpZGUgYW4gaW1tZXIgZnVuY3Rpb24gdG8gYW4gYXN5bmMgcHJvY2Vzcz8gXCIgKyBkYXRhO1xuICB9LFxuICBcIkFuIGltbWVyIHByb2R1Y2VyIHJldHVybmVkIGEgbmV3IHZhbHVlICphbmQqIG1vZGlmaWVkIGl0cyBkcmFmdC4gRWl0aGVyIHJldHVybiBhIG5ldyB2YWx1ZSAqb3IqIG1vZGlmeSB0aGUgZHJhZnQuXCIsXG4gIFwiSW1tZXIgZm9yYmlkcyBjaXJjdWxhciByZWZlcmVuY2VzXCIsXG4gIFwiVGhlIGZpcnN0IG9yIHNlY29uZCBhcmd1bWVudCB0byBgcHJvZHVjZWAgbXVzdCBiZSBhIGZ1bmN0aW9uXCIsXG4gIFwiVGhlIHRoaXJkIGFyZ3VtZW50IHRvIGBwcm9kdWNlYCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgdW5kZWZpbmVkXCIsXG4gIFwiRmlyc3QgYXJndW1lbnQgdG8gYGNyZWF0ZURyYWZ0YCBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LCBhbiBhcnJheSwgb3IgYW4gaW1tZXJhYmxlIG9iamVjdFwiLFxuICBcIkZpcnN0IGFyZ3VtZW50IHRvIGBmaW5pc2hEcmFmdGAgbXVzdCBiZSBhIGRyYWZ0IHJldHVybmVkIGJ5IGBjcmVhdGVEcmFmdGBcIixcbiAgZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gYCdjdXJyZW50JyBleHBlY3RzIGEgZHJhZnQsIGdvdDogJHt0aGluZ31gO1xuICB9LFxuICBcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsXG4gIFwiT2JqZWN0LnNldFByb3RvdHlwZU9mKCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcbiAgXCJJbW1lciBvbmx5IHN1cHBvcnRzIGRlbGV0aW5nIGFycmF5IGluZGljZXNcIixcbiAgXCJJbW1lciBvbmx5IHN1cHBvcnRzIHNldHRpbmcgYXJyYXkgaW5kaWNlcyBhbmQgdGhlICdsZW5ndGgnIHByb3BlcnR5XCIsXG4gIGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIGAnb3JpZ2luYWwnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiAke3RoaW5nfWA7XG4gIH1cbiAgLy8gTm90ZTogaWYgbW9yZSBlcnJvcnMgYXJlIGFkZGVkLCB0aGUgZXJyb3JPZmZzZXQgaW4gUGF0Y2hlcy50cyBzaG91bGQgYmUgaW5jcmVhc2VkXG4gIC8vIFNlZSBQYXRjaGVzLnRzIGZvciBhZGRpdGlvbmFsIGVycm9yc1xuXSA6IFtdO1xuZnVuY3Rpb24gZGllKGVycm9yLCAuLi5hcmdzKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCBlID0gZXJyb3JzW2Vycm9yXTtcbiAgICBjb25zdCBtc2cgPSBpc0Z1bmN0aW9uKGUpID8gZS5hcHBseShudWxsLCBhcmdzKSA6IGU7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBbSW1tZXJdICR7bXNnfWApO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgW0ltbWVyXSBtaW5pZmllZCBlcnJvciBucjogJHtlcnJvcn0uIEZ1bGwgZXJyb3IgYXQ6IGh0dHBzOi8vYml0Lmx5LzNjWEVLV2ZgXG4gICk7XG59XG5cbi8vIHNyYy91dGlscy9jb21tb24udHNcbnZhciBPID0gT2JqZWN0O1xudmFyIGdldFByb3RvdHlwZU9mID0gTy5nZXRQcm90b3R5cGVPZjtcbnZhciBDT05TVFJVQ1RPUiA9IFwiY29uc3RydWN0b3JcIjtcbnZhciBQUk9UT1RZUEUgPSBcInByb3RvdHlwZVwiO1xudmFyIENPTkZJR1VSQUJMRSA9IFwiY29uZmlndXJhYmxlXCI7XG52YXIgRU5VTUVSQUJMRSA9IFwiZW51bWVyYWJsZVwiO1xudmFyIFdSSVRBQkxFID0gXCJ3cml0YWJsZVwiO1xudmFyIFZBTFVFID0gXCJ2YWx1ZVwiO1xudmFyIGlzRHJhZnQgPSAodmFsdWUpID0+ICEhdmFsdWUgJiYgISF2YWx1ZVtEUkFGVF9TVEFURV07XG5mdW5jdGlvbiBpc0RyYWZ0YWJsZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpIHx8IGlzQXJyYXkodmFsdWUpIHx8ICEhdmFsdWVbRFJBRlRBQkxFXSB8fCAhIXZhbHVlW0NPTlNUUlVDVE9SXT8uW0RSQUZUQUJMRV0gfHwgaXNNYXAodmFsdWUpIHx8IGlzU2V0KHZhbHVlKTtcbn1cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gT1tQUk9UT1RZUEVdW0NPTlNUUlVDVE9SXS50b1N0cmluZygpO1xudmFyIGNhY2hlZEN0b3JTdHJpbmdzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghdmFsdWUgfHwgIWlzT2JqZWN0aXNoKHZhbHVlKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHByb3RvID0gZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwgfHwgcHJvdG8gPT09IE9bUFJPVE9UWVBFXSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgQ3RvciA9IE8uaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgQ09OU1RSVUNUT1IpICYmIHByb3RvW0NPTlNUUlVDVE9SXTtcbiAgaWYgKEN0b3IgPT09IE9iamVjdClcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKCFpc0Z1bmN0aW9uKEN0b3IpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgbGV0IGN0b3JTdHJpbmcgPSBjYWNoZWRDdG9yU3RyaW5ncy5nZXQoQ3Rvcik7XG4gIGlmIChjdG9yU3RyaW5nID09PSB2b2lkIDApIHtcbiAgICBjdG9yU3RyaW5nID0gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChDdG9yKTtcbiAgICBjYWNoZWRDdG9yU3RyaW5ncy5zZXQoQ3RvciwgY3RvclN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIGN0b3JTdHJpbmcgPT09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5mdW5jdGlvbiBvcmlnaW5hbCh2YWx1ZSkge1xuICBpZiAoIWlzRHJhZnQodmFsdWUpKVxuICAgIGRpZSgxNSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWVbRFJBRlRfU1RBVEVdLmJhc2VfO1xufVxuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXIsIHN0cmljdCA9IHRydWUpIHtcbiAgaWYgKGdldEFyY2h0eXBlKG9iaikgPT09IDAgLyogT2JqZWN0ICovKSB7XG4gICAgY29uc3Qga2V5cyA9IHN0cmljdCA/IFJlZmxlY3Qub3duS2V5cyhvYmopIDogTy5rZXlzKG9iaik7XG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGl0ZXIoa2V5LCBvYmpba2V5XSwgb2JqKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmouZm9yRWFjaCgoZW50cnksIGluZGV4KSA9PiBpdGVyKGluZGV4LCBlbnRyeSwgb2JqKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEFyY2h0eXBlKHRoaW5nKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpbmdbRFJBRlRfU1RBVEVdO1xuICByZXR1cm4gc3RhdGUgPyBzdGF0ZS50eXBlXyA6IGlzQXJyYXkodGhpbmcpID8gMSAvKiBBcnJheSAqLyA6IGlzTWFwKHRoaW5nKSA/IDIgLyogTWFwICovIDogaXNTZXQodGhpbmcpID8gMyAvKiBTZXQgKi8gOiAwIC8qIE9iamVjdCAqLztcbn1cbnZhciBoYXMgPSAodGhpbmcsIHByb3AsIHR5cGUgPSBnZXRBcmNodHlwZSh0aGluZykpID0+IHR5cGUgPT09IDIgLyogTWFwICovID8gdGhpbmcuaGFzKHByb3ApIDogT1tQUk9UT1RZUEVdLmhhc093blByb3BlcnR5LmNhbGwodGhpbmcsIHByb3ApO1xudmFyIGdldCA9ICh0aGluZywgcHJvcCwgdHlwZSA9IGdldEFyY2h0eXBlKHRoaW5nKSkgPT4gKFxuICAvLyBAdHMtaWdub3JlXG4gIHR5cGUgPT09IDIgLyogTWFwICovID8gdGhpbmcuZ2V0KHByb3ApIDogdGhpbmdbcHJvcF1cbik7XG52YXIgc2V0ID0gKHRoaW5nLCBwcm9wT3JPbGRWYWx1ZSwgdmFsdWUsIHR5cGUgPSBnZXRBcmNodHlwZSh0aGluZykpID0+IHtcbiAgaWYgKHR5cGUgPT09IDIgLyogTWFwICovKVxuICAgIHRoaW5nLnNldChwcm9wT3JPbGRWYWx1ZSwgdmFsdWUpO1xuICBlbHNlIGlmICh0eXBlID09PSAzIC8qIFNldCAqLykge1xuICAgIHRoaW5nLmFkZCh2YWx1ZSk7XG4gIH0gZWxzZVxuICAgIHRoaW5nW3Byb3BPck9sZFZhbHVlXSA9IHZhbHVlO1xufTtcbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xudmFyIGlzTWFwID0gKHRhcmdldCkgPT4gdGFyZ2V0IGluc3RhbmNlb2YgTWFwO1xudmFyIGlzU2V0ID0gKHRhcmdldCkgPT4gdGFyZ2V0IGluc3RhbmNlb2YgU2V0O1xudmFyIGlzT2JqZWN0aXNoID0gKHRhcmdldCkgPT4gdHlwZW9mIHRhcmdldCA9PT0gXCJvYmplY3RcIjtcbnZhciBpc0Z1bmN0aW9uID0gKHRhcmdldCkgPT4gdHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiO1xudmFyIGlzQm9vbGVhbiA9ICh0YXJnZXQpID0+IHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiO1xudmFyIGdldFByb3h5RHJhZnQgPSAodmFsdWUpID0+IHtcbiAgaWYgKCFpc09iamVjdGlzaCh2YWx1ZSkpXG4gICAgcmV0dXJuIG51bGw7XG4gIHJldHVybiB2YWx1ZT8uW0RSQUZUX1NUQVRFXTtcbn07XG52YXIgbGF0ZXN0ID0gKHN0YXRlKSA9PiBzdGF0ZS5jb3B5XyB8fCBzdGF0ZS5iYXNlXztcbnZhciBnZXRWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICBjb25zdCBwcm94eURyYWZ0ID0gZ2V0UHJveHlEcmFmdCh2YWx1ZSk7XG4gIHJldHVybiBwcm94eURyYWZ0ID8gcHJveHlEcmFmdC5jb3B5XyA/PyBwcm94eURyYWZ0LmJhc2VfIDogdmFsdWU7XG59O1xudmFyIGdldEZpbmFsVmFsdWUgPSAoc3RhdGUpID0+IHN0YXRlLm1vZGlmaWVkXyA/IHN0YXRlLmNvcHlfIDogc3RhdGUuYmFzZV87XG5mdW5jdGlvbiBzaGFsbG93Q29weShiYXNlLCBzdHJpY3QpIHtcbiAgaWYgKGlzTWFwKGJhc2UpKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAoYmFzZSk7XG4gIH1cbiAgaWYgKGlzU2V0KGJhc2UpKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQoYmFzZSk7XG4gIH1cbiAgaWYgKGlzQXJyYXkoYmFzZSkpXG4gICAgcmV0dXJuIEFycmF5W1BST1RPVFlQRV0uc2xpY2UuY2FsbChiYXNlKTtcbiAgY29uc3QgaXNQbGFpbiA9IGlzUGxhaW5PYmplY3QoYmFzZSk7XG4gIGlmIChzdHJpY3QgPT09IHRydWUgfHwgc3RyaWN0ID09PSBcImNsYXNzX29ubHlcIiAmJiAhaXNQbGFpbikge1xuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gTy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGJhc2UpO1xuICAgIGRlbGV0ZSBkZXNjcmlwdG9yc1tEUkFGVF9TVEFURV07XG4gICAgbGV0IGtleXMgPSBSZWZsZWN0Lm93bktleXMoZGVzY3JpcHRvcnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGNvbnN0IGRlc2MgPSBkZXNjcmlwdG9yc1trZXldO1xuICAgICAgaWYgKGRlc2NbV1JJVEFCTEVdID09PSBmYWxzZSkge1xuICAgICAgICBkZXNjW1dSSVRBQkxFXSA9IHRydWU7XG4gICAgICAgIGRlc2NbQ09ORklHVVJBQkxFXSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpXG4gICAgICAgIGRlc2NyaXB0b3JzW2tleV0gPSB7XG4gICAgICAgICAgW0NPTkZJR1VSQUJMRV06IHRydWUsXG4gICAgICAgICAgW1dSSVRBQkxFXTogdHJ1ZSxcbiAgICAgICAgICAvLyBjb3VsZCBsaXZlIHdpdGggISFkZXNjLnNldCBhcyB3ZWxsIGhlcmUuLi5cbiAgICAgICAgICBbRU5VTUVSQUJMRV06IGRlc2NbRU5VTUVSQUJMRV0sXG4gICAgICAgICAgW1ZBTFVFXTogYmFzZVtrZXldXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBPLmNyZWF0ZShnZXRQcm90b3R5cGVPZihiYXNlKSwgZGVzY3JpcHRvcnMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYmFzZSk7XG4gICAgaWYgKHByb3RvICE9PSBudWxsICYmIGlzUGxhaW4pIHtcbiAgICAgIHJldHVybiB7IC4uLmJhc2UgfTtcbiAgICB9XG4gICAgY29uc3Qgb2JqID0gTy5jcmVhdGUocHJvdG8pO1xuICAgIHJldHVybiBPLmFzc2lnbihvYmosIGJhc2UpO1xuICB9XG59XG5mdW5jdGlvbiBmcmVlemUob2JqLCBkZWVwID0gZmFsc2UpIHtcbiAgaWYgKGlzRnJvemVuKG9iaikgfHwgaXNEcmFmdChvYmopIHx8ICFpc0RyYWZ0YWJsZShvYmopKVxuICAgIHJldHVybiBvYmo7XG4gIGlmIChnZXRBcmNodHlwZShvYmopID4gMSkge1xuICAgIE8uZGVmaW5lUHJvcGVydGllcyhvYmosIHtcbiAgICAgIHNldDogZG9udE11dGF0ZU1ldGhvZE92ZXJyaWRlLFxuICAgICAgYWRkOiBkb250TXV0YXRlTWV0aG9kT3ZlcnJpZGUsXG4gICAgICBjbGVhcjogZG9udE11dGF0ZU1ldGhvZE92ZXJyaWRlLFxuICAgICAgZGVsZXRlOiBkb250TXV0YXRlTWV0aG9kT3ZlcnJpZGVcbiAgICB9KTtcbiAgfVxuICBPLmZyZWV6ZShvYmopO1xuICBpZiAoZGVlcClcbiAgICBlYWNoKFxuICAgICAgb2JqLFxuICAgICAgKF9rZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGZyZWV6ZSh2YWx1ZSwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zKCkge1xuICBkaWUoMik7XG59XG52YXIgZG9udE11dGF0ZU1ldGhvZE92ZXJyaWRlID0ge1xuICBbVkFMVUVdOiBkb250TXV0YXRlRnJvemVuQ29sbGVjdGlvbnNcbn07XG5mdW5jdGlvbiBpc0Zyb3plbihvYmopIHtcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCAhaXNPYmplY3Rpc2gob2JqKSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIE8uaXNGcm96ZW4ob2JqKTtcbn1cblxuLy8gc3JjL3V0aWxzL3BsdWdpbnMudHNcbnZhciBQbHVnaW5NYXBTZXQgPSBcIk1hcFNldFwiO1xudmFyIFBsdWdpblBhdGNoZXMgPSBcIlBhdGNoZXNcIjtcbnZhciBwbHVnaW5zID0ge307XG5mdW5jdGlvbiBnZXRQbHVnaW4ocGx1Z2luS2V5KSB7XG4gIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbcGx1Z2luS2V5XTtcbiAgaWYgKCFwbHVnaW4pIHtcbiAgICBkaWUoMCwgcGx1Z2luS2V5KTtcbiAgfVxuICByZXR1cm4gcGx1Z2luO1xufVxudmFyIGlzUGx1Z2luTG9hZGVkID0gKHBsdWdpbktleSkgPT4gISFwbHVnaW5zW3BsdWdpbktleV07XG5mdW5jdGlvbiBsb2FkUGx1Z2luKHBsdWdpbktleSwgaW1wbGVtZW50YXRpb24pIHtcbiAgaWYgKCFwbHVnaW5zW3BsdWdpbktleV0pXG4gICAgcGx1Z2luc1twbHVnaW5LZXldID0gaW1wbGVtZW50YXRpb247XG59XG5cbi8vIHNyYy9jb3JlL3Njb3BlLnRzXG52YXIgY3VycmVudFNjb3BlO1xudmFyIGdldEN1cnJlbnRTY29wZSA9ICgpID0+IGN1cnJlbnRTY29wZTtcbnZhciBjcmVhdGVTY29wZSA9IChwYXJlbnRfLCBpbW1lcl8pID0+ICh7XG4gIGRyYWZ0c186IFtdLFxuICBwYXJlbnRfLFxuICBpbW1lcl8sXG4gIC8vIFdoZW5ldmVyIHRoZSBtb2RpZmllZCBkcmFmdCBjb250YWlucyBhIGRyYWZ0IGZyb20gYW5vdGhlciBzY29wZSwgd2VcbiAgLy8gbmVlZCB0byBwcmV2ZW50IGF1dG8tZnJlZXppbmcgc28gdGhlIHVub3duZWQgZHJhZnQgY2FuIGJlIGZpbmFsaXplZC5cbiAgY2FuQXV0b0ZyZWV6ZV86IHRydWUsXG4gIHVuZmluYWxpemVkRHJhZnRzXzogMCxcbiAgaGFuZGxlZFNldF86IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gIHByb2Nlc3NlZEZvclBhdGNoZXNfOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICBtYXBTZXRQbHVnaW5fOiBpc1BsdWdpbkxvYWRlZChQbHVnaW5NYXBTZXQpID8gZ2V0UGx1Z2luKFBsdWdpbk1hcFNldCkgOiB2b2lkIDBcbn0pO1xuZnVuY3Rpb24gdXNlUGF0Y2hlc0luU2NvcGUoc2NvcGUsIHBhdGNoTGlzdGVuZXIpIHtcbiAgaWYgKHBhdGNoTGlzdGVuZXIpIHtcbiAgICBzY29wZS5wYXRjaFBsdWdpbl8gPSBnZXRQbHVnaW4oUGx1Z2luUGF0Y2hlcyk7XG4gICAgc2NvcGUucGF0Y2hlc18gPSBbXTtcbiAgICBzY29wZS5pbnZlcnNlUGF0Y2hlc18gPSBbXTtcbiAgICBzY29wZS5wYXRjaExpc3RlbmVyXyA9IHBhdGNoTGlzdGVuZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHJldm9rZVNjb3BlKHNjb3BlKSB7XG4gIGxlYXZlU2NvcGUoc2NvcGUpO1xuICBzY29wZS5kcmFmdHNfLmZvckVhY2gocmV2b2tlRHJhZnQpO1xuICBzY29wZS5kcmFmdHNfID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGxlYXZlU2NvcGUoc2NvcGUpIHtcbiAgaWYgKHNjb3BlID09PSBjdXJyZW50U2NvcGUpIHtcbiAgICBjdXJyZW50U2NvcGUgPSBzY29wZS5wYXJlbnRfO1xuICB9XG59XG52YXIgZW50ZXJTY29wZSA9IChpbW1lcjIpID0+IGN1cnJlbnRTY29wZSA9IGNyZWF0ZVNjb3BlKGN1cnJlbnRTY29wZSwgaW1tZXIyKTtcbmZ1bmN0aW9uIHJldm9rZURyYWZ0KGRyYWZ0KSB7XG4gIGNvbnN0IHN0YXRlID0gZHJhZnRbRFJBRlRfU1RBVEVdO1xuICBpZiAoc3RhdGUudHlwZV8gPT09IDAgLyogT2JqZWN0ICovIHx8IHN0YXRlLnR5cGVfID09PSAxIC8qIEFycmF5ICovKVxuICAgIHN0YXRlLnJldm9rZV8oKTtcbiAgZWxzZVxuICAgIHN0YXRlLnJldm9rZWRfID0gdHJ1ZTtcbn1cblxuLy8gc3JjL2NvcmUvZmluYWxpemUudHNcbmZ1bmN0aW9uIHByb2Nlc3NSZXN1bHQocmVzdWx0LCBzY29wZSkge1xuICBzY29wZS51bmZpbmFsaXplZERyYWZ0c18gPSBzY29wZS5kcmFmdHNfLmxlbmd0aDtcbiAgY29uc3QgYmFzZURyYWZ0ID0gc2NvcGUuZHJhZnRzX1swXTtcbiAgY29uc3QgaXNSZXBsYWNlZCA9IHJlc3VsdCAhPT0gdm9pZCAwICYmIHJlc3VsdCAhPT0gYmFzZURyYWZ0O1xuICBpZiAoaXNSZXBsYWNlZCkge1xuICAgIGlmIChiYXNlRHJhZnRbRFJBRlRfU1RBVEVdLm1vZGlmaWVkXykge1xuICAgICAgcmV2b2tlU2NvcGUoc2NvcGUpO1xuICAgICAgZGllKDQpO1xuICAgIH1cbiAgICBpZiAoaXNEcmFmdGFibGUocmVzdWx0KSkge1xuICAgICAgcmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIHJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IHsgcGF0Y2hQbHVnaW5fIH0gPSBzY29wZTtcbiAgICBpZiAocGF0Y2hQbHVnaW5fKSB7XG4gICAgICBwYXRjaFBsdWdpbl8uZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKFxuICAgICAgICBiYXNlRHJhZnRbRFJBRlRfU1RBVEVdLmJhc2VfLFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIHNjb3BlXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBmaW5hbGl6ZShzY29wZSwgYmFzZURyYWZ0KTtcbiAgfVxuICBtYXliZUZyZWV6ZShzY29wZSwgcmVzdWx0LCB0cnVlKTtcbiAgcmV2b2tlU2NvcGUoc2NvcGUpO1xuICBpZiAoc2NvcGUucGF0Y2hlc18pIHtcbiAgICBzY29wZS5wYXRjaExpc3RlbmVyXyhzY29wZS5wYXRjaGVzXywgc2NvcGUuaW52ZXJzZVBhdGNoZXNfKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0ICE9PSBOT1RISU5HID8gcmVzdWx0IDogdm9pZCAwO1xufVxuZnVuY3Rpb24gZmluYWxpemUocm9vdFNjb3BlLCB2YWx1ZSkge1xuICBpZiAoaXNGcm96ZW4odmFsdWUpKVxuICAgIHJldHVybiB2YWx1ZTtcbiAgY29uc3Qgc3RhdGUgPSB2YWx1ZVtEUkFGVF9TVEFURV07XG4gIGlmICghc3RhdGUpIHtcbiAgICBjb25zdCBmaW5hbFZhbHVlID0gaGFuZGxlVmFsdWUodmFsdWUsIHJvb3RTY29wZS5oYW5kbGVkU2V0Xywgcm9vdFNjb3BlKTtcbiAgICByZXR1cm4gZmluYWxWYWx1ZTtcbiAgfVxuICBpZiAoIWlzU2FtZVNjb3BlKHN0YXRlLCByb290U2NvcGUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgcmV0dXJuIHN0YXRlLmJhc2VfO1xuICB9XG4gIGlmICghc3RhdGUuZmluYWxpemVkXykge1xuICAgIGNvbnN0IHsgY2FsbGJhY2tzXyB9ID0gc3RhdGU7XG4gICAgaWYgKGNhbGxiYWNrc18pIHtcbiAgICAgIHdoaWxlIChjYWxsYmFja3NfLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjYWxsYmFja3NfLnBvcCgpO1xuICAgICAgICBjYWxsYmFjayhyb290U2NvcGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5lcmF0ZVBhdGNoZXNBbmRGaW5hbGl6ZShzdGF0ZSwgcm9vdFNjb3BlKTtcbiAgfVxuICByZXR1cm4gc3RhdGUuY29weV87XG59XG5mdW5jdGlvbiBtYXliZUZyZWV6ZShzY29wZSwgdmFsdWUsIGRlZXAgPSBmYWxzZSkge1xuICBpZiAoIXNjb3BlLnBhcmVudF8gJiYgc2NvcGUuaW1tZXJfLmF1dG9GcmVlemVfICYmIHNjb3BlLmNhbkF1dG9GcmVlemVfKSB7XG4gICAgZnJlZXplKHZhbHVlLCBkZWVwKTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya1N0YXRlRmluYWxpemVkKHN0YXRlKSB7XG4gIHN0YXRlLmZpbmFsaXplZF8gPSB0cnVlO1xuICBzdGF0ZS5zY29wZV8udW5maW5hbGl6ZWREcmFmdHNfLS07XG59XG52YXIgaXNTYW1lU2NvcGUgPSAoc3RhdGUsIHJvb3RTY29wZSkgPT4gc3RhdGUuc2NvcGVfID09PSByb290U2NvcGU7XG52YXIgRU1QVFlfTE9DQVRJT05TX1JFU1VMVCA9IFtdO1xuZnVuY3Rpb24gdXBkYXRlRHJhZnRJblBhcmVudChwYXJlbnQsIGRyYWZ0VmFsdWUsIGZpbmFsaXplZFZhbHVlLCBvcmlnaW5hbEtleSkge1xuICBjb25zdCBwYXJlbnRDb3B5ID0gbGF0ZXN0KHBhcmVudCk7XG4gIGNvbnN0IHBhcmVudFR5cGUgPSBwYXJlbnQudHlwZV87XG4gIGlmIChvcmlnaW5hbEtleSAhPT0gdm9pZCAwKSB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gZ2V0KHBhcmVudENvcHksIG9yaWdpbmFsS2V5LCBwYXJlbnRUeXBlKTtcbiAgICBpZiAoY3VycmVudFZhbHVlID09PSBkcmFmdFZhbHVlKSB7XG4gICAgICBzZXQocGFyZW50Q29weSwgb3JpZ2luYWxLZXksIGZpbmFsaXplZFZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKCFwYXJlbnQuZHJhZnRMb2NhdGlvbnNfKSB7XG4gICAgY29uc3QgZHJhZnRMb2NhdGlvbnMgPSBwYXJlbnQuZHJhZnRMb2NhdGlvbnNfID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBlYWNoKHBhcmVudENvcHksIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICBpZiAoaXNEcmFmdCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IGRyYWZ0TG9jYXRpb25zLmdldCh2YWx1ZSkgfHwgW107XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICBkcmFmdExvY2F0aW9ucy5zZXQodmFsdWUsIGtleXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGxvY2F0aW9ucyA9IHBhcmVudC5kcmFmdExvY2F0aW9uc18uZ2V0KGRyYWZ0VmFsdWUpID8/IEVNUFRZX0xPQ0FUSU9OU19SRVNVTFQ7XG4gIGZvciAoY29uc3QgbG9jYXRpb24gb2YgbG9jYXRpb25zKSB7XG4gICAgc2V0KHBhcmVudENvcHksIGxvY2F0aW9uLCBmaW5hbGl6ZWRWYWx1ZSwgcGFyZW50VHlwZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyQ2hpbGRGaW5hbGl6YXRpb25DYWxsYmFjayhwYXJlbnQsIGNoaWxkLCBrZXkpIHtcbiAgcGFyZW50LmNhbGxiYWNrc18ucHVzaChmdW5jdGlvbiBjaGlsZENsZWFudXAocm9vdFNjb3BlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBjaGlsZDtcbiAgICBpZiAoIXN0YXRlIHx8ICFpc1NhbWVTY29wZShzdGF0ZSwgcm9vdFNjb3BlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByb290U2NvcGUubWFwU2V0UGx1Z2luXz8uZml4U2V0Q29udGVudHMoc3RhdGUpO1xuICAgIGNvbnN0IGZpbmFsaXplZFZhbHVlID0gZ2V0RmluYWxWYWx1ZShzdGF0ZSk7XG4gICAgdXBkYXRlRHJhZnRJblBhcmVudChwYXJlbnQsIHN0YXRlLmRyYWZ0XyA/PyBzdGF0ZSwgZmluYWxpemVkVmFsdWUsIGtleSk7XG4gICAgZ2VuZXJhdGVQYXRjaGVzQW5kRmluYWxpemUoc3RhdGUsIHJvb3RTY29wZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVQYXRjaGVzQW5kRmluYWxpemUoc3RhdGUsIHJvb3RTY29wZSkge1xuICBjb25zdCBzaG91bGRGaW5hbGl6ZSA9IHN0YXRlLm1vZGlmaWVkXyAmJiAhc3RhdGUuZmluYWxpemVkXyAmJiAoc3RhdGUudHlwZV8gPT09IDMgLyogU2V0ICovIHx8IChzdGF0ZS5hc3NpZ25lZF8/LnNpemUgPz8gMCkgPiAwKTtcbiAgaWYgKHNob3VsZEZpbmFsaXplKSB7XG4gICAgY29uc3QgeyBwYXRjaFBsdWdpbl8gfSA9IHJvb3RTY29wZTtcbiAgICBpZiAocGF0Y2hQbHVnaW5fKSB7XG4gICAgICBjb25zdCBiYXNlUGF0aCA9IHBhdGNoUGx1Z2luXy5nZXRQYXRoKHN0YXRlKTtcbiAgICAgIGlmIChiYXNlUGF0aCkge1xuICAgICAgICBwYXRjaFBsdWdpbl8uZ2VuZXJhdGVQYXRjaGVzXyhzdGF0ZSwgYmFzZVBhdGgsIHJvb3RTY29wZSk7XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtTdGF0ZUZpbmFsaXplZChzdGF0ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUNyb3NzUmVmZXJlbmNlKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICBjb25zdCB7IHNjb3BlXyB9ID0gdGFyZ2V0O1xuICBpZiAoaXNEcmFmdCh2YWx1ZSkpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHZhbHVlW0RSQUZUX1NUQVRFXTtcbiAgICBpZiAoaXNTYW1lU2NvcGUoc3RhdGUsIHNjb3BlXykpIHtcbiAgICAgIHN0YXRlLmNhbGxiYWNrc18ucHVzaChmdW5jdGlvbiBjcm9zc1JlZmVyZW5jZUNsZWFudXAoKSB7XG4gICAgICAgIHByZXBhcmVDb3B5KHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGZpbmFsaXplZFZhbHVlID0gZ2V0RmluYWxWYWx1ZShzdGF0ZSk7XG4gICAgICAgIHVwZGF0ZURyYWZ0SW5QYXJlbnQodGFyZ2V0LCB2YWx1ZSwgZmluYWxpemVkVmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgdGFyZ2V0LmNhbGxiYWNrc18ucHVzaChmdW5jdGlvbiBuZXN0ZWREcmFmdENsZWFudXAoKSB7XG4gICAgICBjb25zdCB0YXJnZXRDb3B5ID0gbGF0ZXN0KHRhcmdldCk7XG4gICAgICBpZiAoZ2V0KHRhcmdldENvcHksIGtleSwgdGFyZ2V0LnR5cGVfKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgaWYgKHNjb3BlXy5kcmFmdHNfLmxlbmd0aCA+IDEgJiYgKHRhcmdldC5hc3NpZ25lZF8uZ2V0KGtleSkgPz8gZmFsc2UpID09PSB0cnVlICYmIHRhcmdldC5jb3B5Xykge1xuICAgICAgICAgIGhhbmRsZVZhbHVlKFxuICAgICAgICAgICAgZ2V0KHRhcmdldC5jb3B5Xywga2V5LCB0YXJnZXQudHlwZV8pLFxuICAgICAgICAgICAgc2NvcGVfLmhhbmRsZWRTZXRfLFxuICAgICAgICAgICAgc2NvcGVfXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVWYWx1ZSh0YXJnZXQsIGhhbmRsZWRTZXQsIHJvb3RTY29wZSkge1xuICBpZiAoIXJvb3RTY29wZS5pbW1lcl8uYXV0b0ZyZWV6ZV8gJiYgcm9vdFNjb3BlLnVuZmluYWxpemVkRHJhZnRzXyA8IDEpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGlmIChpc0RyYWZ0KHRhcmdldCkgfHwgaGFuZGxlZFNldC5oYXModGFyZ2V0KSB8fCAhaXNEcmFmdGFibGUodGFyZ2V0KSB8fCBpc0Zyb3plbih0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBoYW5kbGVkU2V0LmFkZCh0YXJnZXQpO1xuICBlYWNoKHRhcmdldCwgKGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAoaXNEcmFmdCh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmFsdWVbRFJBRlRfU1RBVEVdO1xuICAgICAgaWYgKGlzU2FtZVNjb3BlKHN0YXRlLCByb290U2NvcGUpKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRWYWx1ZSA9IGdldEZpbmFsVmFsdWUoc3RhdGUpO1xuICAgICAgICBzZXQodGFyZ2V0LCBrZXksIHVwZGF0ZWRWYWx1ZSwgdGFyZ2V0LnR5cGVfKTtcbiAgICAgICAgbWFya1N0YXRlRmluYWxpemVkKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgICAgaGFuZGxlVmFsdWUodmFsdWUsIGhhbmRsZWRTZXQsIHJvb3RTY29wZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLy8gc3JjL2NvcmUvcHJveHkudHNcbmZ1bmN0aW9uIGNyZWF0ZVByb3h5UHJveHkoYmFzZSwgcGFyZW50KSB7XG4gIGNvbnN0IGJhc2VJc0FycmF5ID0gaXNBcnJheShiYXNlKTtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgdHlwZV86IGJhc2VJc0FycmF5ID8gMSAvKiBBcnJheSAqLyA6IDAgLyogT2JqZWN0ICovLFxuICAgIC8vIFRyYWNrIHdoaWNoIHByb2R1Y2UgY2FsbCB0aGlzIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICBzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSxcbiAgICAvLyBUcnVlIGZvciBib3RoIHNoYWxsb3cgYW5kIGRlZXAgY2hhbmdlcy5cbiAgICBtb2RpZmllZF86IGZhbHNlLFxuICAgIC8vIFVzZWQgZHVyaW5nIGZpbmFsaXphdGlvbi5cbiAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcbiAgICAvLyBUcmFjayB3aGljaCBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBhc3NpZ25lZCAodHJ1ZSkgb3IgZGVsZXRlZCAoZmFsc2UpLlxuICAgIC8vIGFjdHVhbGx5IGluc3RhbnRpYXRlZCBpbiBgcHJlcGFyZUNvcHkoKWBcbiAgICBhc3NpZ25lZF86IHZvaWQgMCxcbiAgICAvLyBUaGUgcGFyZW50IGRyYWZ0IHN0YXRlLlxuICAgIHBhcmVudF86IHBhcmVudCxcbiAgICAvLyBUaGUgYmFzZSBzdGF0ZS5cbiAgICBiYXNlXzogYmFzZSxcbiAgICAvLyBUaGUgYmFzZSBwcm94eS5cbiAgICBkcmFmdF86IG51bGwsXG4gICAgLy8gc2V0IGJlbG93XG4gICAgLy8gVGhlIGJhc2UgY29weSB3aXRoIGFueSB1cGRhdGVkIHZhbHVlcy5cbiAgICBjb3B5XzogbnVsbCxcbiAgICAvLyBDYWxsZWQgYnkgdGhlIGBwcm9kdWNlYCBmdW5jdGlvbi5cbiAgICByZXZva2VfOiBudWxsLFxuICAgIGlzTWFudWFsXzogZmFsc2UsXG4gICAgLy8gYGNhbGxiYWNrc2AgYWN0dWFsbHkgZ2V0cyBhc3NpZ25lZCBpbiBgY3JlYXRlUHJveHlgXG4gICAgY2FsbGJhY2tzXzogdm9pZCAwXG4gIH07XG4gIGxldCB0YXJnZXQgPSBzdGF0ZTtcbiAgbGV0IHRyYXBzID0gb2JqZWN0VHJhcHM7XG4gIGlmIChiYXNlSXNBcnJheSkge1xuICAgIHRhcmdldCA9IFtzdGF0ZV07XG4gICAgdHJhcHMgPSBhcnJheVRyYXBzO1xuICB9XG4gIGNvbnN0IHsgcmV2b2tlLCBwcm94eSB9ID0gUHJveHkucmV2b2NhYmxlKHRhcmdldCwgdHJhcHMpO1xuICBzdGF0ZS5kcmFmdF8gPSBwcm94eTtcbiAgc3RhdGUucmV2b2tlXyA9IHJldm9rZTtcbiAgcmV0dXJuIFtwcm94eSwgc3RhdGVdO1xufVxudmFyIG9iamVjdFRyYXBzID0ge1xuICBnZXQoc3RhdGUsIHByb3ApIHtcbiAgICBpZiAocHJvcCA9PT0gRFJBRlRfU1RBVEUpXG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgY29uc3Qgc291cmNlID0gbGF0ZXN0KHN0YXRlKTtcbiAgICBpZiAoIWhhcyhzb3VyY2UsIHByb3AsIHN0YXRlLnR5cGVfKSkge1xuICAgICAgcmV0dXJuIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlLCBzb3VyY2UsIHByb3ApO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtwcm9wXTtcbiAgICBpZiAoc3RhdGUuZmluYWxpemVkXyB8fCAhaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gcGVlayhzdGF0ZS5iYXNlXywgcHJvcCkpIHtcbiAgICAgIHByZXBhcmVDb3B5KHN0YXRlKTtcbiAgICAgIGNvbnN0IGNoaWxkS2V5ID0gc3RhdGUudHlwZV8gPT09IDEgLyogQXJyYXkgKi8gPyArcHJvcCA6IHByb3A7XG4gICAgICBjb25zdCBjaGlsZERyYWZ0ID0gY3JlYXRlUHJveHkoc3RhdGUuc2NvcGVfLCB2YWx1ZSwgc3RhdGUsIGNoaWxkS2V5KTtcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5X1tjaGlsZEtleV0gPSBjaGlsZERyYWZ0O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGhhcyhzdGF0ZSwgcHJvcCkge1xuICAgIHJldHVybiBwcm9wIGluIGxhdGVzdChzdGF0ZSk7XG4gIH0sXG4gIG93bktleXMoc3RhdGUpIHtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKGxhdGVzdChzdGF0ZSkpO1xuICB9LFxuICBzZXQoc3RhdGUsIHByb3AsIHZhbHVlKSB7XG4gICAgY29uc3QgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8obGF0ZXN0KHN0YXRlKSwgcHJvcCk7XG4gICAgaWYgKGRlc2M/LnNldCkge1xuICAgICAgZGVzYy5zZXQuY2FsbChzdGF0ZS5kcmFmdF8sIHZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuICAgICAgY29uc3QgY3VycmVudDIgPSBwZWVrKGxhdGVzdChzdGF0ZSksIHByb3ApO1xuICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gY3VycmVudDI/LltEUkFGVF9TVEFURV07XG4gICAgICBpZiAoY3VycmVudFN0YXRlICYmIGN1cnJlbnRTdGF0ZS5iYXNlXyA9PT0gdmFsdWUpIHtcbiAgICAgICAgc3RhdGUuY29weV9bcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChwcm9wLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzKHZhbHVlLCBjdXJyZW50MikgJiYgKHZhbHVlICE9PSB2b2lkIDAgfHwgaGFzKHN0YXRlLmJhc2VfLCBwcm9wLCBzdGF0ZS50eXBlXykpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIHByZXBhcmVDb3B5KHN0YXRlKTtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmNvcHlfW3Byb3BdID09PSB2YWx1ZSAmJiAvLyBzcGVjaWFsIGNhc2U6IGhhbmRsZSBuZXcgcHJvcHMgd2l0aCB2YWx1ZSAndW5kZWZpbmVkJ1xuICAgICh2YWx1ZSAhPT0gdm9pZCAwIHx8IHByb3AgaW4gc3RhdGUuY29weV8pIHx8IC8vIHNwZWNpYWwgY2FzZTogTmFOXG4gICAgTnVtYmVyLmlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNOYU4oc3RhdGUuY29weV9bcHJvcF0pKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgc3RhdGUuY29weV9bcHJvcF0gPSB2YWx1ZTtcbiAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KHByb3AsIHRydWUpO1xuICAgIGhhbmRsZUNyb3NzUmVmZXJlbmNlKHN0YXRlLCBwcm9wLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGRlbGV0ZVByb3BlcnR5KHN0YXRlLCBwcm9wKSB7XG4gICAgcHJlcGFyZUNvcHkoc3RhdGUpO1xuICAgIGlmIChwZWVrKHN0YXRlLmJhc2VfLCBwcm9wKSAhPT0gdm9pZCAwIHx8IHByb3AgaW4gc3RhdGUuYmFzZV8pIHtcbiAgICAgIHN0YXRlLmFzc2lnbmVkXy5zZXQocHJvcCwgZmFsc2UpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5hc3NpZ25lZF8uZGVsZXRlKHByb3ApO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY29weV8pIHtcbiAgICAgIGRlbGV0ZSBzdGF0ZS5jb3B5X1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIE5vdGU6IFdlIG5ldmVyIGNvZXJjZSBgZGVzYy52YWx1ZWAgaW50byBhbiBJbW1lciBkcmFmdCwgYmVjYXVzZSB3ZSBjYW4ndCBtYWtlXG4gIC8vIHRoZSBzYW1lIGd1YXJhbnRlZSBpbiBFUzUgbW9kZS5cbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHN0YXRlLCBwcm9wKSB7XG4gICAgY29uc3Qgb3duZXIgPSBsYXRlc3Qoc3RhdGUpO1xuICAgIGNvbnN0IGRlc2MgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvd25lciwgcHJvcCk7XG4gICAgaWYgKCFkZXNjKVxuICAgICAgcmV0dXJuIGRlc2M7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtXUklUQUJMRV06IHRydWUsXG4gICAgICBbQ09ORklHVVJBQkxFXTogc3RhdGUudHlwZV8gIT09IDEgLyogQXJyYXkgKi8gfHwgcHJvcCAhPT0gXCJsZW5ndGhcIixcbiAgICAgIFtFTlVNRVJBQkxFXTogZGVzY1tFTlVNRVJBQkxFXSxcbiAgICAgIFtWQUxVRV06IG93bmVyW3Byb3BdXG4gICAgfTtcbiAgfSxcbiAgZGVmaW5lUHJvcGVydHkoKSB7XG4gICAgZGllKDExKTtcbiAgfSxcbiAgZ2V0UHJvdG90eXBlT2Yoc3RhdGUpIHtcbiAgICByZXR1cm4gZ2V0UHJvdG90eXBlT2Yoc3RhdGUuYmFzZV8pO1xuICB9LFxuICBzZXRQcm90b3R5cGVPZigpIHtcbiAgICBkaWUoMTIpO1xuICB9XG59O1xudmFyIGFycmF5VHJhcHMgPSB7fTtcbmVhY2gob2JqZWN0VHJhcHMsIChrZXksIGZuKSA9PiB7XG4gIGFycmF5VHJhcHNba2V5XSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF1bMF07XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufSk7XG5hcnJheVRyYXBzLmRlbGV0ZVByb3BlcnR5ID0gZnVuY3Rpb24oc3RhdGUsIHByb3ApIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc05hTihwYXJzZUludChwcm9wKSkpXG4gICAgZGllKDEzKTtcbiAgcmV0dXJuIGFycmF5VHJhcHMuc2V0LmNhbGwodGhpcywgc3RhdGUsIHByb3AsIHZvaWQgMCk7XG59O1xuYXJyYXlUcmFwcy5zZXQgPSBmdW5jdGlvbihzdGF0ZSwgcHJvcCwgdmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBwcm9wICE9PSBcImxlbmd0aFwiICYmIGlzTmFOKHBhcnNlSW50KHByb3ApKSlcbiAgICBkaWUoMTQpO1xuICByZXR1cm4gb2JqZWN0VHJhcHMuc2V0LmNhbGwodGhpcywgc3RhdGVbMF0sIHByb3AsIHZhbHVlLCBzdGF0ZVswXSk7XG59O1xuZnVuY3Rpb24gcGVlayhkcmFmdCwgcHJvcCkge1xuICBjb25zdCBzdGF0ZSA9IGRyYWZ0W0RSQUZUX1NUQVRFXTtcbiAgY29uc3Qgc291cmNlID0gc3RhdGUgPyBsYXRlc3Qoc3RhdGUpIDogZHJhZnQ7XG4gIHJldHVybiBzb3VyY2VbcHJvcF07XG59XG5mdW5jdGlvbiByZWFkUHJvcEZyb21Qcm90byhzdGF0ZSwgc291cmNlLCBwcm9wKSB7XG4gIGNvbnN0IGRlc2MgPSBnZXREZXNjcmlwdG9yRnJvbVByb3RvKHNvdXJjZSwgcHJvcCk7XG4gIHJldHVybiBkZXNjID8gVkFMVUUgaW4gZGVzYyA/IGRlc2NbVkFMVUVdIDogKFxuICAgIC8vIFRoaXMgaXMgYSB2ZXJ5IHNwZWNpYWwgY2FzZSwgaWYgdGhlIHByb3AgaXMgYSBnZXR0ZXIgZGVmaW5lZCBieSB0aGVcbiAgICAvLyBwcm90b3R5cGUsIHdlIHNob3VsZCBpbnZva2UgaXQgd2l0aCB0aGUgZHJhZnQgYXMgY29udGV4dCFcbiAgICBkZXNjLmdldD8uY2FsbChzdGF0ZS5kcmFmdF8pXG4gICkgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXREZXNjcmlwdG9yRnJvbVByb3RvKHNvdXJjZSwgcHJvcCkge1xuICBpZiAoIShwcm9wIGluIHNvdXJjZSkpXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgbGV0IHByb3RvID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlKTtcbiAgd2hpbGUgKHByb3RvKSB7XG4gICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIHByb3ApO1xuICAgIGlmIChkZXNjKVxuICAgICAgcmV0dXJuIGRlc2M7XG4gICAgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIG1hcmtDaGFuZ2VkKHN0YXRlKSB7XG4gIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgc3RhdGUubW9kaWZpZWRfID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUucGFyZW50Xykge1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUucGFyZW50Xyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlQ29weShzdGF0ZSkge1xuICBpZiAoIXN0YXRlLmNvcHlfKSB7XG4gICAgc3RhdGUuYXNzaWduZWRfID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBzdGF0ZS5jb3B5XyA9IHNoYWxsb3dDb3B5KFxuICAgICAgc3RhdGUuYmFzZV8sXG4gICAgICBzdGF0ZS5zY29wZV8uaW1tZXJfLnVzZVN0cmljdFNoYWxsb3dDb3B5X1xuICAgICk7XG4gIH1cbn1cblxuLy8gc3JjL2NvcmUvaW1tZXJDbGFzcy50c1xudmFyIEltbWVyMiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5hdXRvRnJlZXplXyA9IHRydWU7XG4gICAgdGhpcy51c2VTdHJpY3RTaGFsbG93Q29weV8gPSBmYWxzZTtcbiAgICB0aGlzLnVzZVN0cmljdEl0ZXJhdGlvbl8gPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgYHByb2R1Y2VgIGZ1bmN0aW9uIHRha2VzIGEgdmFsdWUgYW5kIGEgXCJyZWNpcGUgZnVuY3Rpb25cIiAod2hvc2VcbiAgICAgKiByZXR1cm4gdmFsdWUgb2Z0ZW4gZGVwZW5kcyBvbiB0aGUgYmFzZSBzdGF0ZSkuIFRoZSByZWNpcGUgZnVuY3Rpb24gaXNcbiAgICAgKiBmcmVlIHRvIG11dGF0ZSBpdHMgZmlyc3QgYXJndW1lbnQgaG93ZXZlciBpdCB3YW50cy4gQWxsIG11dGF0aW9ucyBhcmVcbiAgICAgKiBvbmx5IGV2ZXIgYXBwbGllZCB0byBhIF9fY29weV9fIG9mIHRoZSBiYXNlIHN0YXRlLlxuICAgICAqXG4gICAgICogUGFzcyBvbmx5IGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgXCJjdXJyaWVkIHByb2R1Y2VyXCIgd2hpY2ggcmVsaWV2ZXMgeW91XG4gICAgICogZnJvbSBwYXNzaW5nIHRoZSByZWNpcGUgZnVuY3Rpb24gZXZlcnkgdGltZS5cbiAgICAgKlxuICAgICAqIE9ubHkgcGxhaW4gb2JqZWN0cyBhbmQgYXJyYXlzIGFyZSBtYWRlIG11dGFibGUuIEFsbCBvdGhlciBvYmplY3RzIGFyZVxuICAgICAqIGNvbnNpZGVyZWQgdW5jb3B5YWJsZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgX19ib3VuZF9fIHRvIGl0cyBgSW1tZXJgIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGJhc2UgLSB0aGUgaW5pdGlhbCBzdGF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlY2lwZSAtIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBwcm94eSBvZiB0aGUgYmFzZSBzdGF0ZSBhcyBmaXJzdCBhcmd1bWVudCBhbmQgd2hpY2ggY2FuIGJlIGZyZWVseSBtb2RpZmllZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHBhdGNoTGlzdGVuZXIgLSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYWxsIHRoZSBwYXRjaGVzIHByb2R1Y2VkIGhlcmVcbiAgICAgKiBAcmV0dXJucyB7YW55fSBhIG5ldyBzdGF0ZSwgb3IgdGhlIGluaXRpYWwgc3RhdGUgaWYgbm90aGluZyB3YXMgbW9kaWZpZWRcbiAgICAgKi9cbiAgICB0aGlzLnByb2R1Y2UgPSAoYmFzZSwgcmVjaXBlLCBwYXRjaExpc3RlbmVyKSA9PiB7XG4gICAgICBpZiAoaXNGdW5jdGlvbihiYXNlKSAmJiAhaXNGdW5jdGlvbihyZWNpcGUpKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRCYXNlID0gcmVjaXBlO1xuICAgICAgICByZWNpcGUgPSBiYXNlO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGN1cnJpZWRQcm9kdWNlKGJhc2UyID0gZGVmYXVsdEJhc2UsIC4uLmFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5wcm9kdWNlKGJhc2UyLCAoZHJhZnQpID0+IHJlY2lwZS5jYWxsKHRoaXMsIGRyYWZ0LCAuLi5hcmdzKSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoIWlzRnVuY3Rpb24ocmVjaXBlKSlcbiAgICAgICAgZGllKDYpO1xuICAgICAgaWYgKHBhdGNoTGlzdGVuZXIgIT09IHZvaWQgMCAmJiAhaXNGdW5jdGlvbihwYXRjaExpc3RlbmVyKSlcbiAgICAgICAgZGllKDcpO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGlmIChpc0RyYWZ0YWJsZShiYXNlKSkge1xuICAgICAgICBjb25zdCBzY29wZSA9IGVudGVyU2NvcGUodGhpcyk7XG4gICAgICAgIGNvbnN0IHByb3h5ID0gY3JlYXRlUHJveHkoc2NvcGUsIGJhc2UsIHZvaWQgMCk7XG4gICAgICAgIGxldCBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVjaXBlKHByb3h5KTtcbiAgICAgICAgICBoYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChoYXNFcnJvcilcbiAgICAgICAgICAgIHJldm9rZVNjb3BlKHNjb3BlKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZWF2ZVNjb3BlKHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpO1xuICAgICAgfSBlbHNlIGlmICghYmFzZSB8fCAhaXNPYmplY3Rpc2goYmFzZSkpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVjaXBlKGJhc2UpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApXG4gICAgICAgICAgcmVzdWx0ID0gYmFzZTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gTk9USElORylcbiAgICAgICAgICByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgIGlmICh0aGlzLmF1dG9GcmVlemVfKVxuICAgICAgICAgIGZyZWV6ZShyZXN1bHQsIHRydWUpO1xuICAgICAgICBpZiAocGF0Y2hMaXN0ZW5lcikge1xuICAgICAgICAgIGNvbnN0IHAgPSBbXTtcbiAgICAgICAgICBjb25zdCBpcCA9IFtdO1xuICAgICAgICAgIGdldFBsdWdpbihQbHVnaW5QYXRjaGVzKS5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZSwgcmVzdWx0LCB7XG4gICAgICAgICAgICBwYXRjaGVzXzogcCxcbiAgICAgICAgICAgIGludmVyc2VQYXRjaGVzXzogaXBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwYXRjaExpc3RlbmVyKHAsIGlwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlXG4gICAgICAgIGRpZSgxLCBiYXNlKTtcbiAgICB9O1xuICAgIHRoaXMucHJvZHVjZVdpdGhQYXRjaGVzID0gKGJhc2UsIHJlY2lwZSkgPT4ge1xuICAgICAgaWYgKGlzRnVuY3Rpb24oYmFzZSkpIHtcbiAgICAgICAgcmV0dXJuIChzdGF0ZSwgLi4uYXJncykgPT4gdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMoc3RhdGUsIChkcmFmdCkgPT4gYmFzZShkcmFmdCwgLi4uYXJncykpO1xuICAgICAgfVxuICAgICAgbGV0IHBhdGNoZXMsIGludmVyc2VQYXRjaGVzO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wcm9kdWNlKGJhc2UsIHJlY2lwZSwgKHAsIGlwKSA9PiB7XG4gICAgICAgIHBhdGNoZXMgPSBwO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcyA9IGlwO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdO1xuICAgIH07XG4gICAgaWYgKGlzQm9vbGVhbihjb25maWc/LmF1dG9GcmVlemUpKVxuICAgICAgdGhpcy5zZXRBdXRvRnJlZXplKGNvbmZpZy5hdXRvRnJlZXplKTtcbiAgICBpZiAoaXNCb29sZWFuKGNvbmZpZz8udXNlU3RyaWN0U2hhbGxvd0NvcHkpKVxuICAgICAgdGhpcy5zZXRVc2VTdHJpY3RTaGFsbG93Q29weShjb25maWcudXNlU3RyaWN0U2hhbGxvd0NvcHkpO1xuICAgIGlmIChpc0Jvb2xlYW4oY29uZmlnPy51c2VTdHJpY3RJdGVyYXRpb24pKVxuICAgICAgdGhpcy5zZXRVc2VTdHJpY3RJdGVyYXRpb24oY29uZmlnLnVzZVN0cmljdEl0ZXJhdGlvbik7XG4gIH1cbiAgY3JlYXRlRHJhZnQoYmFzZSkge1xuICAgIGlmICghaXNEcmFmdGFibGUoYmFzZSkpXG4gICAgICBkaWUoOCk7XG4gICAgaWYgKGlzRHJhZnQoYmFzZSkpXG4gICAgICBiYXNlID0gY3VycmVudChiYXNlKTtcbiAgICBjb25zdCBzY29wZSA9IGVudGVyU2NvcGUodGhpcyk7XG4gICAgY29uc3QgcHJveHkgPSBjcmVhdGVQcm94eShzY29wZSwgYmFzZSwgdm9pZCAwKTtcbiAgICBwcm94eVtEUkFGVF9TVEFURV0uaXNNYW51YWxfID0gdHJ1ZTtcbiAgICBsZWF2ZVNjb3BlKHNjb3BlKTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH1cbiAgZmluaXNoRHJhZnQoZHJhZnQsIHBhdGNoTGlzdGVuZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGRyYWZ0ICYmIGRyYWZ0W0RSQUZUX1NUQVRFXTtcbiAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5pc01hbnVhbF8pXG4gICAgICBkaWUoOSk7XG4gICAgY29uc3QgeyBzY29wZV86IHNjb3BlIH0gPSBzdGF0ZTtcbiAgICB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcik7XG4gICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQodm9pZCAwLCBzY29wZSk7XG4gIH1cbiAgLyoqXG4gICAqIFBhc3MgdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IGZyZWV6ZSBhbGwgY29waWVzIGNyZWF0ZWQgYnkgSW1tZXIuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGF1dG8tZnJlZXppbmcgaXMgZW5hYmxlZC5cbiAgICovXG4gIHNldEF1dG9GcmVlemUodmFsdWUpIHtcbiAgICB0aGlzLmF1dG9GcmVlemVfID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFBhc3MgdHJ1ZSB0byBlbmFibGUgc3RyaWN0IHNoYWxsb3cgY29weS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgaW1tZXIgZG9lcyBub3QgY29weSB0aGUgb2JqZWN0IGRlc2NyaXB0b3JzIHN1Y2ggYXMgZ2V0dGVyLCBzZXR0ZXIgYW5kIG5vbi1lbnVtcmFibGUgcHJvcGVydGllcy5cbiAgICovXG4gIHNldFVzZVN0cmljdFNoYWxsb3dDb3B5KHZhbHVlKSB7XG4gICAgdGhpcy51c2VTdHJpY3RTaGFsbG93Q29weV8gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUGFzcyBmYWxzZSB0byB1c2UgZmFzdGVyIGl0ZXJhdGlvbiB0aGF0IHNraXBzIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAgICogYnV0IHN0aWxsIGhhbmRsZXMgc3ltYm9scyBmb3IgY29tcGF0aWJpbGl0eS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgc3RyaWN0IGl0ZXJhdGlvbiBpcyBlbmFibGVkIChpbmNsdWRlcyBhbGwgb3duIHByb3BlcnRpZXMpLlxuICAgKi9cbiAgc2V0VXNlU3RyaWN0SXRlcmF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy51c2VTdHJpY3RJdGVyYXRpb25fID0gdmFsdWU7XG4gIH1cbiAgc2hvdWxkVXNlU3RyaWN0SXRlcmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnVzZVN0cmljdEl0ZXJhdGlvbl87XG4gIH1cbiAgYXBwbHlQYXRjaGVzKGJhc2UsIHBhdGNoZXMpIHtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSBwYXRjaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDAgJiYgcGF0Y2gub3AgPT09IFwicmVwbGFjZVwiKSB7XG4gICAgICAgIGJhc2UgPSBwYXRjaC52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIHBhdGNoZXMgPSBwYXRjaGVzLnNsaWNlKGkgKyAxKTtcbiAgICB9XG4gICAgY29uc3QgYXBwbHlQYXRjaGVzSW1wbCA9IGdldFBsdWdpbihQbHVnaW5QYXRjaGVzKS5hcHBseVBhdGNoZXNfO1xuICAgIGlmIChpc0RyYWZ0KGJhc2UpKSB7XG4gICAgICByZXR1cm4gYXBwbHlQYXRjaGVzSW1wbChiYXNlLCBwYXRjaGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvZHVjZShcbiAgICAgIGJhc2UsXG4gICAgICAoZHJhZnQpID0+IGFwcGx5UGF0Y2hlc0ltcGwoZHJhZnQsIHBhdGNoZXMpXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVByb3h5KHJvb3RTY29wZSwgdmFsdWUsIHBhcmVudCwga2V5KSB7XG4gIGNvbnN0IFtkcmFmdCwgc3RhdGVdID0gaXNNYXAodmFsdWUpID8gZ2V0UGx1Z2luKFBsdWdpbk1hcFNldCkucHJveHlNYXBfKHZhbHVlLCBwYXJlbnQpIDogaXNTZXQodmFsdWUpID8gZ2V0UGx1Z2luKFBsdWdpbk1hcFNldCkucHJveHlTZXRfKHZhbHVlLCBwYXJlbnQpIDogY3JlYXRlUHJveHlQcm94eSh2YWx1ZSwgcGFyZW50KTtcbiAgY29uc3Qgc2NvcGUgPSBwYXJlbnQ/LnNjb3BlXyA/PyBnZXRDdXJyZW50U2NvcGUoKTtcbiAgc2NvcGUuZHJhZnRzXy5wdXNoKGRyYWZ0KTtcbiAgc3RhdGUuY2FsbGJhY2tzXyA9IHBhcmVudD8uY2FsbGJhY2tzXyA/PyBbXTtcbiAgc3RhdGUua2V5XyA9IGtleTtcbiAgaWYgKHBhcmVudCAmJiBrZXkgIT09IHZvaWQgMCkge1xuICAgIHJlZ2lzdGVyQ2hpbGRGaW5hbGl6YXRpb25DYWxsYmFjayhwYXJlbnQsIHN0YXRlLCBrZXkpO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNhbGxiYWNrc18ucHVzaChmdW5jdGlvbiByb290RHJhZnRDbGVhbnVwKHJvb3RTY29wZTIpIHtcbiAgICAgIHJvb3RTY29wZTIubWFwU2V0UGx1Z2luXz8uZml4U2V0Q29udGVudHMoc3RhdGUpO1xuICAgICAgY29uc3QgeyBwYXRjaFBsdWdpbl8gfSA9IHJvb3RTY29wZTI7XG4gICAgICBpZiAoc3RhdGUubW9kaWZpZWRfICYmIHBhdGNoUGx1Z2luXykge1xuICAgICAgICBwYXRjaFBsdWdpbl8uZ2VuZXJhdGVQYXRjaGVzXyhzdGF0ZSwgW10sIHJvb3RTY29wZTIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBkcmFmdDtcbn1cblxuLy8gc3JjL2NvcmUvY3VycmVudC50c1xuZnVuY3Rpb24gY3VycmVudCh2YWx1ZSkge1xuICBpZiAoIWlzRHJhZnQodmFsdWUpKVxuICAgIGRpZSgxMCwgdmFsdWUpO1xuICByZXR1cm4gY3VycmVudEltcGwodmFsdWUpO1xufVxuZnVuY3Rpb24gY3VycmVudEltcGwodmFsdWUpIHtcbiAgaWYgKCFpc0RyYWZ0YWJsZSh2YWx1ZSkgfHwgaXNGcm96ZW4odmFsdWUpKVxuICAgIHJldHVybiB2YWx1ZTtcbiAgY29uc3Qgc3RhdGUgPSB2YWx1ZVtEUkFGVF9TVEFURV07XG4gIGxldCBjb3B5O1xuICBsZXQgc3RyaWN0ID0gdHJ1ZTtcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pXG4gICAgICByZXR1cm4gc3RhdGUuYmFzZV87XG4gICAgc3RhdGUuZmluYWxpemVkXyA9IHRydWU7XG4gICAgY29weSA9IHNoYWxsb3dDb3B5KHZhbHVlLCBzdGF0ZS5zY29wZV8uaW1tZXJfLnVzZVN0cmljdFNoYWxsb3dDb3B5Xyk7XG4gICAgc3RyaWN0ID0gc3RhdGUuc2NvcGVfLmltbWVyXy5zaG91bGRVc2VTdHJpY3RJdGVyYXRpb24oKTtcbiAgfSBlbHNlIHtcbiAgICBjb3B5ID0gc2hhbGxvd0NvcHkodmFsdWUsIHRydWUpO1xuICB9XG4gIGVhY2goXG4gICAgY29weSxcbiAgICAoa2V5LCBjaGlsZFZhbHVlKSA9PiB7XG4gICAgICBzZXQoY29weSwga2V5LCBjdXJyZW50SW1wbChjaGlsZFZhbHVlKSk7XG4gICAgfSxcbiAgICBzdHJpY3RcbiAgKTtcbiAgaWYgKHN0YXRlKSB7XG4gICAgc3RhdGUuZmluYWxpemVkXyA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBjb3B5O1xufVxuXG4vLyBzcmMvcGx1Z2lucy9wYXRjaGVzLnRzXG5mdW5jdGlvbiBlbmFibGVQYXRjaGVzKCkge1xuICBjb25zdCBlcnJvck9mZnNldCA9IDE2O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgZXJyb3JzLnB1c2goXG4gICAgICAnU2V0cyBjYW5ub3QgaGF2ZSBcInJlcGxhY2VcIiBwYXRjaGVzLicsXG4gICAgICBmdW5jdGlvbihvcCkge1xuICAgICAgICByZXR1cm4gXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiICsgb3A7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gXCJDYW5ub3QgYXBwbHkgcGF0Y2gsIHBhdGggZG9lc24ndCByZXNvbHZlOiBcIiArIHBhdGg7XG4gICAgICB9LFxuICAgICAgXCJQYXRjaGluZyByZXNlcnZlZCBhdHRyaWJ1dGVzIGxpa2UgX19wcm90b19fLCBwcm90b3R5cGUgYW5kIGNvbnN0cnVjdG9yIGlzIG5vdCBhbGxvd2VkXCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGdldFBhdGgoc3RhdGUsIHBhdGggPSBbXSkge1xuICAgIGlmIChcImtleV9cIiBpbiBzdGF0ZSAmJiBzdGF0ZS5rZXlfICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHBhcmVudENvcHkgPSBzdGF0ZS5wYXJlbnRfLmNvcHlfID8/IHN0YXRlLnBhcmVudF8uYmFzZV87XG4gICAgICBjb25zdCBwcm94eURyYWZ0ID0gZ2V0UHJveHlEcmFmdChnZXQocGFyZW50Q29weSwgc3RhdGUua2V5XykpO1xuICAgICAgY29uc3QgdmFsdWVBdEtleSA9IGdldChwYXJlbnRDb3B5LCBzdGF0ZS5rZXlfKTtcbiAgICAgIGlmICh2YWx1ZUF0S2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVBdEtleSAhPT0gc3RhdGUuZHJhZnRfICYmIHZhbHVlQXRLZXkgIT09IHN0YXRlLmJhc2VfICYmIHZhbHVlQXRLZXkgIT09IHN0YXRlLmNvcHlfKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHByb3h5RHJhZnQgIT0gbnVsbCAmJiBwcm94eURyYWZ0LmJhc2VfICE9PSBzdGF0ZS5iYXNlXykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzU2V0MiA9IHN0YXRlLnBhcmVudF8udHlwZV8gPT09IDMgLyogU2V0ICovO1xuICAgICAgbGV0IGtleTtcbiAgICAgIGlmIChpc1NldDIpIHtcbiAgICAgICAgY29uc3Qgc2V0UGFyZW50ID0gc3RhdGUucGFyZW50XztcbiAgICAgICAga2V5ID0gQXJyYXkuZnJvbShzZXRQYXJlbnQuZHJhZnRzXy5rZXlzKCkpLmluZGV4T2Yoc3RhdGUua2V5Xyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXkgPSBzdGF0ZS5rZXlfO1xuICAgICAgfVxuICAgICAgaWYgKCEoaXNTZXQyICYmIHBhcmVudENvcHkuc2l6ZSA+IGtleSB8fCBoYXMocGFyZW50Q29weSwga2V5KSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBwYXRoLnB1c2goa2V5KTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnBhcmVudF8pIHtcbiAgICAgIHJldHVybiBnZXRQYXRoKHN0YXRlLnBhcmVudF8sIHBhdGgpO1xuICAgIH1cbiAgICBwYXRoLnJldmVyc2UoKTtcbiAgICB0cnkge1xuICAgICAgcmVzb2x2ZVBhdGgoc3RhdGUuY29weV8sIHBhdGgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBmdW5jdGlvbiByZXNvbHZlUGF0aChiYXNlLCBwYXRoKSB7XG4gICAgbGV0IGN1cnJlbnQyID0gYmFzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBwYXRoW2ldO1xuICAgICAgY3VycmVudDIgPSBnZXQoY3VycmVudDIsIGtleSk7XG4gICAgICBpZiAoIWlzT2JqZWN0aXNoKGN1cnJlbnQyKSB8fCBjdXJyZW50MiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXNvbHZlIHBhdGggYXQgJyR7cGF0aC5qb2luKFwiL1wiKX0nYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50MjtcbiAgfVxuICBjb25zdCBSRVBMQUNFID0gXCJyZXBsYWNlXCI7XG4gIGNvbnN0IEFERCA9IFwiYWRkXCI7XG4gIGNvbnN0IFJFTU9WRSA9IFwicmVtb3ZlXCI7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc18oc3RhdGUsIGJhc2VQYXRoLCBzY29wZSkge1xuICAgIGlmIChzdGF0ZS5zY29wZV8ucHJvY2Vzc2VkRm9yUGF0Y2hlc18uaGFzKHN0YXRlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGF0ZS5zY29wZV8ucHJvY2Vzc2VkRm9yUGF0Y2hlc18uYWRkKHN0YXRlKTtcbiAgICBjb25zdCB7IHBhdGNoZXNfLCBpbnZlcnNlUGF0Y2hlc18gfSA9IHNjb3BlO1xuICAgIHN3aXRjaCAoc3RhdGUudHlwZV8pIHtcbiAgICAgIGNhc2UgMCAvKiBPYmplY3QgKi86XG4gICAgICBjYXNlIDIgLyogTWFwICovOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGJhc2VQYXRoLFxuICAgICAgICAgIHBhdGNoZXNfLFxuICAgICAgICAgIGludmVyc2VQYXRjaGVzX1xuICAgICAgICApO1xuICAgICAgY2FzZSAxIC8qIEFycmF5ICovOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVBcnJheVBhdGNoZXMoXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgYmFzZVBhdGgsXG4gICAgICAgICAgcGF0Y2hlc18sXG4gICAgICAgICAgaW52ZXJzZVBhdGNoZXNfXG4gICAgICAgICk7XG4gICAgICBjYXNlIDMgLyogU2V0ICovOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVTZXRQYXRjaGVzKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGJhc2VQYXRoLFxuICAgICAgICAgIHBhdGNoZXNfLFxuICAgICAgICAgIGludmVyc2VQYXRjaGVzX1xuICAgICAgICApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZUFycmF5UGF0Y2hlcyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgbGV0IHsgYmFzZV8sIGFzc2lnbmVkXyB9ID0gc3RhdGU7XG4gICAgbGV0IGNvcHlfID0gc3RhdGUuY29weV87XG4gICAgaWYgKGNvcHlfLmxlbmd0aCA8IGJhc2VfLmxlbmd0aCkge1xuICAgICAgO1xuICAgICAgW2Jhc2VfLCBjb3B5X10gPSBbY29weV8sIGJhc2VfXTtcbiAgICAgIFtwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlc10gPSBbaW52ZXJzZVBhdGNoZXMsIHBhdGNoZXNdO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2VfLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb3BpZWRJdGVtID0gY29weV9baV07XG4gICAgICBjb25zdCBiYXNlSXRlbSA9IGJhc2VfW2ldO1xuICAgICAgaWYgKGFzc2lnbmVkXz8uZ2V0KGkudG9TdHJpbmcoKSkgJiYgY29waWVkSXRlbSAhPT0gYmFzZUl0ZW0pIHtcbiAgICAgICAgY29uc3QgY2hpbGRTdGF0ZSA9IGNvcGllZEl0ZW0/LltEUkFGVF9TVEFURV07XG4gICAgICAgIGlmIChjaGlsZFN0YXRlICYmIGNoaWxkU3RhdGUubW9kaWZpZWRfKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgLy8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgICAgLy8gZHVlIHRvIHRoZSBiYXNlL2NvcHkgaW52ZXJzaW9uIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGNvcGllZEl0ZW0pXG4gICAgICAgIH0pO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogUkVQTEFDRSxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChiYXNlSXRlbSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBiYXNlXy5sZW5ndGg7IGkgPCBjb3B5Xy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgb3A6IEFERCxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgLy8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgIC8vIGR1ZSB0byB0aGUgYmFzZS9jb3B5IGludmVyc2lvbiBhdCB0aGUgc3RhcnQgb2YgdGhpcyBmdW5jdGlvblxuICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9baV0pXG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGNvcHlfLmxlbmd0aCAtIDE7IGJhc2VfLmxlbmd0aCA8PSBpOyAtLWkpIHtcbiAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgIGludmVyc2VQYXRjaGVzLnB1c2goe1xuICAgICAgICBvcDogUkVNT1ZFLFxuICAgICAgICBwYXRoXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBjb25zdCB7IGJhc2VfLCBjb3B5XywgdHlwZV8gfSA9IHN0YXRlO1xuICAgIGVhY2goc3RhdGUuYXNzaWduZWRfLCAoa2V5LCBhc3NpZ25lZFZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBvcmlnVmFsdWUgPSBnZXQoYmFzZV8sIGtleSwgdHlwZV8pO1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXQoY29weV8sIGtleSwgdHlwZV8pO1xuICAgICAgY29uc3Qgb3AgPSAhYXNzaWduZWRWYWx1ZSA/IFJFTU9WRSA6IGhhcyhiYXNlXywga2V5KSA/IFJFUExBQ0UgOiBBREQ7XG4gICAgICBpZiAob3JpZ1ZhbHVlID09PSB2YWx1ZSAmJiBvcCA9PT0gUkVQTEFDRSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChrZXkpO1xuICAgICAgcGF0Y2hlcy5wdXNoKFxuICAgICAgICBvcCA9PT0gUkVNT1ZFID8geyBvcCwgcGF0aCB9IDogeyBvcCwgcGF0aCwgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKHZhbHVlKSB9XG4gICAgICApO1xuICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaChcbiAgICAgICAgb3AgPT09IEFERCA/IHsgb3A6IFJFTU9WRSwgcGF0aCB9IDogb3AgPT09IFJFTU9WRSA/IHsgb3A6IEFERCwgcGF0aCwgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9yaWdWYWx1ZSkgfSA6IHsgb3A6IFJFUExBQ0UsIHBhdGgsIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvcmlnVmFsdWUpIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVTZXRQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBsZXQgeyBiYXNlXywgY29weV8gfSA9IHN0YXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBiYXNlXy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKCFjb3B5Xy5oYXModmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogUkVNT1ZFLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xuICAgICAgICAgIG9wOiBBREQsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9KTtcbiAgICBpID0gMDtcbiAgICBjb3B5Xy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKCFiYXNlXy5oYXModmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogQURELFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xuICAgICAgICAgIG9wOiBSRU1PVkUsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZVZhbHVlLCByZXBsYWNlbWVudCwgc2NvcGUpIHtcbiAgICBjb25zdCB7IHBhdGNoZXNfLCBpbnZlcnNlUGF0Y2hlc18gfSA9IHNjb3BlO1xuICAgIHBhdGNoZXNfLnB1c2goe1xuICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICBwYXRoOiBbXSxcbiAgICAgIHZhbHVlOiByZXBsYWNlbWVudCA9PT0gTk9USElORyA/IHZvaWQgMCA6IHJlcGxhY2VtZW50XG4gICAgfSk7XG4gICAgaW52ZXJzZVBhdGNoZXNfLnB1c2goe1xuICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICBwYXRoOiBbXSxcbiAgICAgIHZhbHVlOiBiYXNlVmFsdWVcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseVBhdGNoZXNfKGRyYWZ0LCBwYXRjaGVzKSB7XG4gICAgcGF0Y2hlcy5mb3JFYWNoKChwYXRjaCkgPT4ge1xuICAgICAgY29uc3QgeyBwYXRoLCBvcCB9ID0gcGF0Y2g7XG4gICAgICBsZXQgYmFzZSA9IGRyYWZ0O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJlbnRUeXBlID0gZ2V0QXJjaHR5cGUoYmFzZSk7XG4gICAgICAgIGxldCBwID0gcGF0aFtpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBwICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcCA9IFwiXCIgKyBwO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocGFyZW50VHlwZSA9PT0gMCAvKiBPYmplY3QgKi8gfHwgcGFyZW50VHlwZSA9PT0gMSAvKiBBcnJheSAqLykgJiYgKHAgPT09IFwiX19wcm90b19fXCIgfHwgcCA9PT0gQ09OU1RSVUNUT1IpKVxuICAgICAgICAgIGRpZShlcnJvck9mZnNldCArIDMpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihiYXNlKSAmJiBwID09PSBQUk9UT1RZUEUpXG4gICAgICAgICAgZGllKGVycm9yT2Zmc2V0ICsgMyk7XG4gICAgICAgIGJhc2UgPSBnZXQoYmFzZSwgcCk7XG4gICAgICAgIGlmICghaXNPYmplY3Rpc2goYmFzZSkpXG4gICAgICAgICAgZGllKGVycm9yT2Zmc2V0ICsgMiwgcGF0aC5qb2luKFwiL1wiKSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlID0gZ2V0QXJjaHR5cGUoYmFzZSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUocGF0Y2gudmFsdWUpO1xuICAgICAgY29uc3Qga2V5ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlIFJFUExBQ0U6XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDIgLyogTWFwICovOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIDMgLyogU2V0ICovOlxuICAgICAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Vba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBBREQ6XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogQXJyYXkgKi86XG4gICAgICAgICAgICAgIHJldHVybiBrZXkgPT09IFwiLVwiID8gYmFzZS5wdXNoKHZhbHVlKSA6IGJhc2Uuc3BsaWNlKGtleSwgMCwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAyIC8qIE1hcCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFNldCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUkVNT1ZFOlxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxIC8qIEFycmF5ICovOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zcGxpY2Uoa2V5LCAxKTtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBNYXAgKi86XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFNldCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuZGVsZXRlKHBhdGNoLnZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBkZWxldGUgYmFzZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQgKyAxLCBvcCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRyYWZ0O1xuICB9XG4gIGZ1bmN0aW9uIGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqKSB7XG4gICAgaWYgKCFpc0RyYWZ0YWJsZShvYmopKVxuICAgICAgcmV0dXJuIG9iajtcbiAgICBpZiAoaXNBcnJheShvYmopKVxuICAgICAgcmV0dXJuIG9iai5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSk7XG4gICAgaWYgKGlzTWFwKG9iaikpXG4gICAgICByZXR1cm4gbmV3IE1hcChcbiAgICAgICAgQXJyYXkuZnJvbShvYmouZW50cmllcygpKS5tYXAoKFtrLCB2XSkgPT4gW2ssIGRlZXBDbG9uZVBhdGNoVmFsdWUodildKVxuICAgICAgKTtcbiAgICBpZiAoaXNTZXQob2JqKSlcbiAgICAgIHJldHVybiBuZXcgU2V0KEFycmF5LmZyb20ob2JqKS5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSkpO1xuICAgIGNvbnN0IGNsb25lZCA9IE9iamVjdC5jcmVhdGUoZ2V0UHJvdG90eXBlT2Yob2JqKSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKVxuICAgICAgY2xvbmVkW2tleV0gPSBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9ialtrZXldKTtcbiAgICBpZiAoaGFzKG9iaiwgRFJBRlRBQkxFKSlcbiAgICAgIGNsb25lZFtEUkFGVEFCTEVdID0gb2JqW0RSQUZUQUJMRV07XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBmdW5jdGlvbiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvYmopIHtcbiAgICBpZiAoaXNEcmFmdChvYmopKSB7XG4gICAgICByZXR1cm4gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmopO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIG9iajtcbiAgfVxuICBsb2FkUGx1Z2luKFBsdWdpblBhdGNoZXMsIHtcbiAgICBhcHBseVBhdGNoZXNfLFxuICAgIGdlbmVyYXRlUGF0Y2hlc18sXG4gICAgZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfLFxuICAgIGdldFBhdGhcbiAgfSk7XG59XG5cbi8vIHNyYy9wbHVnaW5zL21hcHNldC50c1xuZnVuY3Rpb24gZW5hYmxlTWFwU2V0KCkge1xuICBjbGFzcyBEcmFmdE1hcCBleHRlbmRzIE1hcCB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzW0RSQUZUX1NUQVRFXSA9IHtcbiAgICAgICAgdHlwZV86IDIgLyogTWFwICovLFxuICAgICAgICBwYXJlbnRfOiBwYXJlbnQsXG4gICAgICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgICAgICBtb2RpZmllZF86IGZhbHNlLFxuICAgICAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcbiAgICAgICAgY29weV86IHZvaWQgMCxcbiAgICAgICAgYXNzaWduZWRfOiB2b2lkIDAsXG4gICAgICAgIGJhc2VfOiB0YXJnZXQsXG4gICAgICAgIGRyYWZ0XzogdGhpcyxcbiAgICAgICAgaXNNYW51YWxfOiBmYWxzZSxcbiAgICAgICAgcmV2b2tlZF86IGZhbHNlLFxuICAgICAgICBjYWxsYmFja3NfOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5zaXplO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5oYXMoa2V5KTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgaWYgKCFsYXRlc3Qoc3RhdGUpLmhhcyhrZXkpIHx8IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSkgIT09IHZhbHVlKSB7XG4gICAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgIGlmICghdGhpcy5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5iYXNlXy5oYXMoa2V5KSkge1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgc3RhdGUuY29weV8uZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGlmIChsYXRlc3Qoc3RhdGUpLnNpemUpIHtcbiAgICAgICAgcHJlcGFyZU1hcENvcHkoc3RhdGUpO1xuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGVhY2goc3RhdGUuYmFzZV8sIChrZXkpID0+IHtcbiAgICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGUuY29weV8uY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yRWFjaChjYiwgdGhpc0FyZykge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGxhdGVzdChzdGF0ZSkuZm9yRWFjaCgoX3ZhbHVlLCBrZXksIF9tYXApID0+IHtcbiAgICAgICAgY2IuY2FsbCh0aGlzQXJnLCB0aGlzLmdldChrZXkpLCBrZXksIHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgY29uc3QgdmFsdWUgPSBsYXRlc3Qoc3RhdGUpLmdldChrZXkpO1xuICAgICAgaWYgKHN0YXRlLmZpbmFsaXplZF8gfHwgIWlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT09IHN0YXRlLmJhc2VfLmdldChrZXkpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRyYWZ0ID0gY3JlYXRlUHJveHkoc3RhdGUuc2NvcGVfLCB2YWx1ZSwgc3RhdGUsIGtleSk7XG4gICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICBzdGF0ZS5jb3B5Xy5zZXQoa2V5LCBkcmFmdCk7XG4gICAgICByZXR1cm4gZHJhZnQ7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5rZXlzKCk7XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5rZXlzKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4gdGhpcy52YWx1ZXMoKSxcbiAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHIuZG9uZSlcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoci52YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLmtleXMoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB0aGlzLmVudHJpZXMoKSxcbiAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHIuZG9uZSlcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoci52YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IFtyLnZhbHVlLCB2YWx1ZV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBbKERSQUZUX1NUQVRFLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJveHlNYXBfKHRhcmdldCwgcGFyZW50KSB7XG4gICAgY29uc3QgbWFwID0gbmV3IERyYWZ0TWFwKHRhcmdldCwgcGFyZW50KTtcbiAgICByZXR1cm4gW21hcCwgbWFwW0RSQUZUX1NUQVRFXV07XG4gIH1cbiAgZnVuY3Rpb24gcHJlcGFyZU1hcENvcHkoc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlLmNvcHlfKSB7XG4gICAgICBzdGF0ZS5hc3NpZ25lZF8gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RhdGUuY29weV8gPSBuZXcgTWFwKHN0YXRlLmJhc2VfKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgRHJhZnRTZXQgZXh0ZW5kcyBTZXQge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgcGFyZW50KSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpc1tEUkFGVF9TVEFURV0gPSB7XG4gICAgICAgIHR5cGVfOiAzIC8qIFNldCAqLyxcbiAgICAgICAgcGFyZW50XzogcGFyZW50LFxuICAgICAgICBzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSxcbiAgICAgICAgbW9kaWZpZWRfOiBmYWxzZSxcbiAgICAgICAgZmluYWxpemVkXzogZmFsc2UsXG4gICAgICAgIGNvcHlfOiB2b2lkIDAsXG4gICAgICAgIGJhc2VfOiB0YXJnZXQsXG4gICAgICAgIGRyYWZ0XzogdGhpcyxcbiAgICAgICAgZHJhZnRzXzogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgICAgcmV2b2tlZF86IGZhbHNlLFxuICAgICAgICBpc01hbnVhbF86IGZhbHNlLFxuICAgICAgICBhc3NpZ25lZF86IHZvaWQgMCxcbiAgICAgICAgY2FsbGJhY2tzXzogW11cbiAgICAgIH07XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuc2l6ZTtcbiAgICB9XG4gICAgaGFzKHZhbHVlKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGlmICghc3RhdGUuY29weV8pIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmJhc2VfLmhhcyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuY29weV8uaGFzKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoc3RhdGUuZHJhZnRzXy5oYXModmFsdWUpICYmIHN0YXRlLmNvcHlfLmhhcyhzdGF0ZS5kcmFmdHNfLmdldCh2YWx1ZSkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5jb3B5Xy5hZGQodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlbGV0ZSh2YWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUuY29weV8uZGVsZXRlKHZhbHVlKSB8fCAoc3RhdGUuZHJhZnRzXy5oYXModmFsdWUpID8gc3RhdGUuY29weV8uZGVsZXRlKHN0YXRlLmRyYWZ0c18uZ2V0KHZhbHVlKSkgOiAoXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZhbHNlXG4gICAgICApKTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGlmIChsYXRlc3Qoc3RhdGUpLnNpemUpIHtcbiAgICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLnZhbHVlcygpO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUuY29weV8uZW50cmllcygpO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gICAgfVxuICAgIFsoRFJBRlRfU1RBVEUsIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gICAgfVxuICAgIGZvckVhY2goY2IsIHRoaXNBcmcpIHtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy52YWx1ZXMoKTtcbiAgICAgIGxldCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIGNiLmNhbGwodGhpc0FyZywgcmVzdWx0LnZhbHVlLCByZXN1bHQudmFsdWUsIHRoaXMpO1xuICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByb3h5U2V0Xyh0YXJnZXQsIHBhcmVudCkge1xuICAgIGNvbnN0IHNldDIgPSBuZXcgRHJhZnRTZXQodGFyZ2V0LCBwYXJlbnQpO1xuICAgIHJldHVybiBbc2V0Miwgc2V0MltEUkFGVF9TVEFURV1dO1xuICB9XG4gIGZ1bmN0aW9uIHByZXBhcmVTZXRDb3B5KHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgICAgc3RhdGUuY29weV8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgc3RhdGUuYmFzZV8uZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgICAgICAgIGNvbnN0IGRyYWZ0ID0gY3JlYXRlUHJveHkoc3RhdGUuc2NvcGVfLCB2YWx1ZSwgc3RhdGUsIHZhbHVlKTtcbiAgICAgICAgICBzdGF0ZS5kcmFmdHNfLnNldCh2YWx1ZSwgZHJhZnQpO1xuICAgICAgICAgIHN0YXRlLmNvcHlfLmFkZChkcmFmdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUuY29weV8uYWRkKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFzc2VydFVucmV2b2tlZChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5yZXZva2VkXylcbiAgICAgIGRpZSgzLCBKU09OLnN0cmluZ2lmeShsYXRlc3Qoc3RhdGUpKSk7XG4gIH1cbiAgZnVuY3Rpb24gZml4U2V0Q29udGVudHModGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC50eXBlXyA9PT0gMyAvKiBTZXQgKi8gJiYgdGFyZ2V0LmNvcHlfKSB7XG4gICAgICBjb25zdCBjb3B5ID0gbmV3IFNldCh0YXJnZXQuY29weV8pO1xuICAgICAgdGFyZ2V0LmNvcHlfLmNsZWFyKCk7XG4gICAgICBjb3B5LmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgIHRhcmdldC5jb3B5Xy5hZGQoZ2V0VmFsdWUodmFsdWUpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBsb2FkUGx1Z2luKFBsdWdpbk1hcFNldCwgeyBwcm94eU1hcF8sIHByb3h5U2V0XywgZml4U2V0Q29udGVudHMgfSk7XG59XG5cbi8vIHNyYy9pbW1lci50c1xudmFyIGltbWVyID0gbmV3IEltbWVyMigpO1xudmFyIHByb2R1Y2UgPSBpbW1lci5wcm9kdWNlO1xudmFyIHByb2R1Y2VXaXRoUGF0Y2hlcyA9IC8qIEBfX1BVUkVfXyAqLyBpbW1lci5wcm9kdWNlV2l0aFBhdGNoZXMuYmluZChcbiAgaW1tZXJcbik7XG52YXIgc2V0QXV0b0ZyZWV6ZSA9IC8qIEBfX1BVUkVfXyAqLyBpbW1lci5zZXRBdXRvRnJlZXplLmJpbmQoaW1tZXIpO1xudmFyIHNldFVzZVN0cmljdFNoYWxsb3dDb3B5ID0gLyogQF9fUFVSRV9fICovIGltbWVyLnNldFVzZVN0cmljdFNoYWxsb3dDb3B5LmJpbmQoXG4gIGltbWVyXG4pO1xudmFyIHNldFVzZVN0cmljdEl0ZXJhdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBpbW1lci5zZXRVc2VTdHJpY3RJdGVyYXRpb24uYmluZChcbiAgaW1tZXJcbik7XG52YXIgYXBwbHlQYXRjaGVzID0gLyogQF9fUFVSRV9fICovIGltbWVyLmFwcGx5UGF0Y2hlcy5iaW5kKGltbWVyKTtcbnZhciBjcmVhdGVEcmFmdCA9IC8qIEBfX1BVUkVfXyAqLyBpbW1lci5jcmVhdGVEcmFmdC5iaW5kKGltbWVyKTtcbnZhciBmaW5pc2hEcmFmdCA9IC8qIEBfX1BVUkVfXyAqLyBpbW1lci5maW5pc2hEcmFmdC5iaW5kKGltbWVyKTtcbnZhciBjYXN0RHJhZnQgPSAodmFsdWUpID0+IHZhbHVlO1xudmFyIGNhc3RJbW11dGFibGUgPSAodmFsdWUpID0+IHZhbHVlO1xuZXhwb3J0IHtcbiAgSW1tZXIyIGFzIEltbWVyLFxuICBhcHBseVBhdGNoZXMsXG4gIGNhc3REcmFmdCxcbiAgY2FzdEltbXV0YWJsZSxcbiAgY3JlYXRlRHJhZnQsXG4gIGN1cnJlbnQsXG4gIGVuYWJsZU1hcFNldCxcbiAgZW5hYmxlUGF0Y2hlcyxcbiAgZmluaXNoRHJhZnQsXG4gIGZyZWV6ZSxcbiAgRFJBRlRBQkxFIGFzIGltbWVyYWJsZSxcbiAgaXNEcmFmdCxcbiAgaXNEcmFmdGFibGUsXG4gIE5PVEhJTkcgYXMgbm90aGluZyxcbiAgb3JpZ2luYWwsXG4gIHByb2R1Y2UsXG4gIHByb2R1Y2VXaXRoUGF0Y2hlcyxcbiAgc2V0QXV0b0ZyZWV6ZSxcbiAgc2V0VXNlU3RyaWN0SXRlcmF0aW9uLFxuICBzZXRVc2VTdHJpY3RTaGFsbG93Q29weVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltbWVyLm1qcy5tYXAiXSwibmFtZXMiOlsiTk9USElORyIsIlN5bWJvbCIsImZvciIsIkRSQUZUQUJMRSIsIkRSQUZUX1NUQVRFIiwiZXJyb3JzIiwicHJvY2VzcyIsInBsdWdpbiIsInRoaW5nIiwiZGF0YSIsImRpZSIsImVycm9yIiwiYXJncyIsImUiLCJtc2ciLCJpc0Z1bmN0aW9uIiwiYXBwbHkiLCJFcnJvciIsIk8iLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsIkNPTlNUUlVDVE9SIiwiUFJPVE9UWVBFIiwiQ09ORklHVVJBQkxFIiwiRU5VTUVSQUJMRSIsIldSSVRBQkxFIiwiVkFMVUUiLCJpc0RyYWZ0IiwidmFsdWUiLCJpc0RyYWZ0YWJsZSIsImlzUGxhaW5PYmplY3QiLCJpc0FycmF5IiwiaXNNYXAiLCJpc1NldCIsIm9iamVjdEN0b3JTdHJpbmciLCJ0b1N0cmluZyIsImNhY2hlZEN0b3JTdHJpbmdzIiwiV2Vha01hcCIsImlzT2JqZWN0aXNoIiwicHJvdG8iLCJDdG9yIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiY3RvclN0cmluZyIsImdldCIsIkZ1bmN0aW9uIiwic2V0Iiwib3JpZ2luYWwiLCJiYXNlXyIsImVhY2giLCJvYmoiLCJpdGVyIiwic3RyaWN0IiwiZ2V0QXJjaHR5cGUiLCJrZXlzIiwiUmVmbGVjdCIsIm93bktleXMiLCJmb3JFYWNoIiwia2V5IiwiZW50cnkiLCJpbmRleCIsInN0YXRlIiwidHlwZV8iLCJoYXMiLCJwcm9wIiwidHlwZSIsInByb3BPck9sZFZhbHVlIiwiYWRkIiwiaXMiLCJ4IiwieSIsIkFycmF5IiwidGFyZ2V0IiwiTWFwIiwiU2V0IiwiaXNCb29sZWFuIiwiZ2V0UHJveHlEcmFmdCIsImxhdGVzdCIsImNvcHlfIiwiZ2V0VmFsdWUiLCJwcm94eURyYWZ0IiwiZ2V0RmluYWxWYWx1ZSIsIm1vZGlmaWVkXyIsInNoYWxsb3dDb3B5IiwiYmFzZSIsInNsaWNlIiwiaXNQbGFpbiIsImRlc2NyaXB0b3JzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImkiLCJsZW5ndGgiLCJkZXNjIiwiY3JlYXRlIiwiYXNzaWduIiwiZnJlZXplIiwiZGVlcCIsImlzRnJvemVuIiwiZGVmaW5lUHJvcGVydGllcyIsImRvbnRNdXRhdGVNZXRob2RPdmVycmlkZSIsImNsZWFyIiwiZGVsZXRlIiwiX2tleSIsImRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucyIsIlBsdWdpbk1hcFNldCIsIlBsdWdpblBhdGNoZXMiLCJwbHVnaW5zIiwiZ2V0UGx1Z2luIiwicGx1Z2luS2V5IiwiaXNQbHVnaW5Mb2FkZWQiLCJsb2FkUGx1Z2luIiwiaW1wbGVtZW50YXRpb24iLCJjdXJyZW50U2NvcGUiLCJnZXRDdXJyZW50U2NvcGUiLCJjcmVhdGVTY29wZSIsInBhcmVudF8iLCJpbW1lcl8iLCJkcmFmdHNfIiwiY2FuQXV0b0ZyZWV6ZV8iLCJ1bmZpbmFsaXplZERyYWZ0c18iLCJoYW5kbGVkU2V0XyIsInByb2Nlc3NlZEZvclBhdGNoZXNfIiwibWFwU2V0UGx1Z2luXyIsInVzZVBhdGNoZXNJblNjb3BlIiwic2NvcGUiLCJwYXRjaExpc3RlbmVyIiwicGF0Y2hQbHVnaW5fIiwicGF0Y2hlc18iLCJpbnZlcnNlUGF0Y2hlc18iLCJwYXRjaExpc3RlbmVyXyIsInJldm9rZVNjb3BlIiwibGVhdmVTY29wZSIsInJldm9rZURyYWZ0IiwiZW50ZXJTY29wZSIsImltbWVyMiIsImRyYWZ0IiwicmV2b2tlXyIsInJldm9rZWRfIiwicHJvY2Vzc1Jlc3VsdCIsInJlc3VsdCIsImJhc2VEcmFmdCIsImlzUmVwbGFjZWQiLCJmaW5hbGl6ZSIsImdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyIsIm1heWJlRnJlZXplIiwicm9vdFNjb3BlIiwiZmluYWxWYWx1ZSIsImhhbmRsZVZhbHVlIiwiaXNTYW1lU2NvcGUiLCJmaW5hbGl6ZWRfIiwiY2FsbGJhY2tzXyIsImNhbGxiYWNrIiwicG9wIiwiZ2VuZXJhdGVQYXRjaGVzQW5kRmluYWxpemUiLCJhdXRvRnJlZXplXyIsIm1hcmtTdGF0ZUZpbmFsaXplZCIsInNjb3BlXyIsIkVNUFRZX0xPQ0FUSU9OU19SRVNVTFQiLCJ1cGRhdGVEcmFmdEluUGFyZW50IiwicGFyZW50IiwiZHJhZnRWYWx1ZSIsImZpbmFsaXplZFZhbHVlIiwib3JpZ2luYWxLZXkiLCJwYXJlbnRDb3B5IiwicGFyZW50VHlwZSIsImN1cnJlbnRWYWx1ZSIsImRyYWZ0TG9jYXRpb25zXyIsImRyYWZ0TG9jYXRpb25zIiwicHVzaCIsImxvY2F0aW9ucyIsImxvY2F0aW9uIiwicmVnaXN0ZXJDaGlsZEZpbmFsaXphdGlvbkNhbGxiYWNrIiwiY2hpbGQiLCJjaGlsZENsZWFudXAiLCJmaXhTZXRDb250ZW50cyIsImRyYWZ0XyIsInNob3VsZEZpbmFsaXplIiwiYXNzaWduZWRfIiwic2l6ZSIsImJhc2VQYXRoIiwiZ2V0UGF0aCIsImdlbmVyYXRlUGF0Y2hlc18iLCJoYW5kbGVDcm9zc1JlZmVyZW5jZSIsImNyb3NzUmVmZXJlbmNlQ2xlYW51cCIsInByZXBhcmVDb3B5IiwibmVzdGVkRHJhZnRDbGVhbnVwIiwidGFyZ2V0Q29weSIsImhhbmRsZWRTZXQiLCJ1cGRhdGVkVmFsdWUiLCJjcmVhdGVQcm94eVByb3h5IiwiYmFzZUlzQXJyYXkiLCJpc01hbnVhbF8iLCJ0cmFwcyIsIm9iamVjdFRyYXBzIiwiYXJyYXlUcmFwcyIsInJldm9rZSIsInByb3h5IiwiUHJveHkiLCJyZXZvY2FibGUiLCJzb3VyY2UiLCJyZWFkUHJvcEZyb21Qcm90byIsInBlZWsiLCJjaGlsZEtleSIsImNoaWxkRHJhZnQiLCJjcmVhdGVQcm94eSIsImdldERlc2NyaXB0b3JGcm9tUHJvdG8iLCJjdXJyZW50MiIsImN1cnJlbnRTdGF0ZSIsIm1hcmtDaGFuZ2VkIiwiTnVtYmVyIiwiaXNOYU4iLCJkZWxldGVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIm93bmVyIiwiZGVmaW5lUHJvcGVydHkiLCJzZXRQcm90b3R5cGVPZiIsImZuIiwiYXJndW1lbnRzIiwicGFyc2VJbnQiLCJ1c2VTdHJpY3RTaGFsbG93Q29weV8iLCJJbW1lcjIiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsInVzZVN0cmljdEl0ZXJhdGlvbl8iLCJwcm9kdWNlIiwicmVjaXBlIiwiZGVmYXVsdEJhc2UiLCJzZWxmIiwiY3VycmllZFByb2R1Y2UiLCJiYXNlMiIsImhhc0Vycm9yIiwicCIsImlwIiwicHJvZHVjZVdpdGhQYXRjaGVzIiwicGF0Y2hlcyIsImludmVyc2VQYXRjaGVzIiwiYXV0b0ZyZWV6ZSIsInNldEF1dG9GcmVlemUiLCJ1c2VTdHJpY3RTaGFsbG93Q29weSIsInNldFVzZVN0cmljdFNoYWxsb3dDb3B5IiwidXNlU3RyaWN0SXRlcmF0aW9uIiwic2V0VXNlU3RyaWN0SXRlcmF0aW9uIiwiY3JlYXRlRHJhZnQiLCJjdXJyZW50IiwiZmluaXNoRHJhZnQiLCJzaG91bGRVc2VTdHJpY3RJdGVyYXRpb24iLCJhcHBseVBhdGNoZXMiLCJwYXRjaCIsInBhdGgiLCJvcCIsImFwcGx5UGF0Y2hlc0ltcGwiLCJhcHBseVBhdGNoZXNfIiwicHJveHlNYXBfIiwicHJveHlTZXRfIiwia2V5XyIsInJvb3REcmFmdENsZWFudXAiLCJyb290U2NvcGUyIiwiY3VycmVudEltcGwiLCJjb3B5IiwiY2hpbGRWYWx1ZSIsImVuYWJsZVBhdGNoZXMiLCJlcnJvck9mZnNldCIsInZhbHVlQXRLZXkiLCJpc1NldDIiLCJzZXRQYXJlbnQiLCJmcm9tIiwiaW5kZXhPZiIsInJldmVyc2UiLCJyZXNvbHZlUGF0aCIsImpvaW4iLCJSRVBMQUNFIiwiQUREIiwiUkVNT1ZFIiwiZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkIiwiZ2VuZXJhdGVBcnJheVBhdGNoZXMiLCJnZW5lcmF0ZVNldFBhdGNoZXMiLCJjb3BpZWRJdGVtIiwiYmFzZUl0ZW0iLCJjaGlsZFN0YXRlIiwiY29uY2F0IiwiY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQiLCJhc3NpZ25lZFZhbHVlIiwib3JpZ1ZhbHVlIiwidW5zaGlmdCIsImJhc2VWYWx1ZSIsInJlcGxhY2VtZW50IiwiZGVlcENsb25lUGF0Y2hWYWx1ZSIsInNwbGljZSIsIm1hcCIsImVudHJpZXMiLCJrIiwidiIsImNsb25lZCIsImVuYWJsZU1hcFNldCIsIkRyYWZ0TWFwIiwiYXNzZXJ0VW5yZXZva2VkIiwicHJlcGFyZU1hcENvcHkiLCJjYiIsInRoaXNBcmciLCJfdmFsdWUiLCJfbWFwIiwidmFsdWVzIiwiaXRlcmF0b3IiLCJuZXh0IiwiciIsImRvbmUiLCJEcmFmdFNldCIsInByZXBhcmVTZXRDb3B5Iiwic2V0MiIsIkpTT04iLCJzdHJpbmdpZnkiLCJpbW1lciIsImJpbmQiLCJjYXN0RHJhZnQiLCJjYXN0SW1tdXRhYmxlIiwiSW1tZXIiLCJpbW1lcmFibGUiLCJub3RoaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/node_modules/immer/dist/immer.mjs\n");

/***/ })

};
;