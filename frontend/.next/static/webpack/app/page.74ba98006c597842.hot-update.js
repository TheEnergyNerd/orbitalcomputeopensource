"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/model/ground_queue_model.ts":
/*!*********************************************!*\
  !*** ./app/lib/model/ground_queue_model.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INITIAL_SUPPLY_STATE: function() { return /* binding */ INITIAL_SUPPLY_STATE; },\n/* harmony export */   calculateConstraintFromSupply: function() { return /* binding */ calculateConstraintFromSupply; },\n/* harmony export */   generateGroundSupplyTrajectory: function() { return /* binding */ generateGroundSupplyTrajectory; },\n/* harmony export */   stepGroundSupply: function() { return /* binding */ stepGroundSupply; }\n/* harmony export */ });\n/**\n * Demand-Driven Ground Constraint Model\n * \n * Replaces time-based constraint with queue-based supply/demand model.\n * Models real-world capacity constraints, build rates, and wait times.\n */ // Explicit initial backlog (tunable parameter)\nconst INITIAL_BACKLOG_GW = 50; // 30-100 GW baseline backlog in 2025\nconst INITIAL_BUILD_RATE_GW_YEAR = 12; // Initial build rate (slower than demand growth)\nconst TARGET_UTIL = 0.85;\nconst BUILD_LAG_YEARS = 2;\nconst INITIAL_SUPPLY_STATE = {\n    year: 2025,\n    demandGw: 120,\n    capacityGw: 120,\n    pipelineGw: INITIAL_BACKLOG_GW,\n    backlogGw: INITIAL_BACKLOG_GW,\n    maxBuildRateGwYear: INITIAL_BUILD_RATE_GW_YEAR,\n    avgWaitYears: INITIAL_BACKLOG_GW / INITIAL_BUILD_RATE_GW_YEAR,\n    utilizationPct: 1.0,\n    inflightGw: Array.from({\n        length: BUILD_LAG_YEARS\n    }, ()=>0),\n    unservedGw: 0,\n    deliveredFromBacklogGw: 0,\n    avgWaitYearsRaw: INITIAL_BACKLOG_GW / INITIAL_BUILD_RATE_GW_YEAR\n};\nfunction expSegment(y0, y1, v0, v1, y) {\n    const t = (y - y0) / (y1 - y0);\n    const r = Math.pow(v1 / v0, 1 / (y1 - y0));\n    return v0 * Math.pow(r, y - y0);\n}\nfunction getGlobalDemandGw(year) {\n    // Anchors (tune if you want)\n    const y0 = 2025, v0 = 120;\n    const y1 = 2040, v1 = 450;\n    const y2 = 2060, v2 = 3000; // \"terawatts by 2060\" -> 3 TW here; change to 5000 if you want\n    if (year <= y1) return expSegment(y0, y1, v0, v1, year);\n    return expSegment(y1, y2, v1, v2, year);\n}\nfunction stepGroundSupply(prev, responsiveDemandGW, orbitalSubstitutionGW // NEW: For backlog drain\n) {\n    const year = prev.year + 1;\n    // Use responsive demand if provided, otherwise fall back to hardcoded\n    const demandGw = responsiveDemandGW !== undefined ? responsiveDemandGW : getGlobalDemandGw(year);\n    // Capacity required to serve demand at target utilization\n    const requiredCapacityGw = demandGw / TARGET_UTIL;\n    var _prev_inflightGw;\n    // Count inflight\n    const inflightTotalGw = ((_prev_inflightGw = prev.inflightGw) !== null && _prev_inflightGw !== void 0 ? _prev_inflightGw : []).reduce((a, b)=>a + b, 0);\n    // New deficit enters backlog (projects that must be built)\n    const newDeficitGw = Math.max(0, requiredCapacityGw - (prev.capacityGw + inflightTotalGw));\n    var _prev_backlogGw, _ref;\n    const backlogGw0 = (_ref = (_prev_backlogGw = prev.backlogGw) !== null && _prev_backlogGw !== void 0 ? _prev_backlogGw : prev.pipelineGw) !== null && _ref !== void 0 ? _ref : 0;\n    // Build rate ramps, but cannot instantly erase the queue\n    const buildRateGrowth = 1.05;\n    const maxBuildRateGwYear = Math.min(prev.maxBuildRateGwYear * buildRateGrowth, 50);\n    // Build serves BOTH new demand AND backlog (backlog can drain)\n    // Try to clear 15% of backlog per year in addition to new deficit\n    const backlogClearTarget = backlogGw0 * 0.15;\n    const totalToBuild = newDeficitGw + backlogClearTarget;\n    const actualBuilt = Math.min(totalToBuild, maxBuildRateGwYear);\n    // New demand gets priority, then backlog\n    const servedNewDemand = Math.min(newDeficitGw, actualBuilt);\n    const servedBacklog = Math.max(0, actualBuilt - servedNewDemand);\n    const unservedNewDemand = newDeficitGw - servedNewDemand;\n    // NEW: Backlog can drain from orbital substitution\n    const implicitBacklogDrain = (orbitalSubstitutionGW !== null && orbitalSubstitutionGW !== void 0 ? orbitalSubstitutionGW : 0) * 0.5; // 50% of shifted demand was in backlog\n    // Update backlog (conservation: backlog[t+1] = backlog[t] + unserved - served - orbital drain)\n    const updatedBacklogGw = Math.max(0, backlogGw0 + unservedNewDemand - servedBacklog - implicitBacklogDrain);\n    // Start construction from backlog (projects move into inflight)\n    const startBuildGw = servedBacklog;\n    var _prev_inflightGw1;\n    // Move GW through lag pipeline\n    const inflight = [\n        ...(_prev_inflightGw1 = prev.inflightGw) !== null && _prev_inflightGw1 !== void 0 ? _prev_inflightGw1 : Array.from({\n            length: BUILD_LAG_YEARS\n        }, ()=>0)\n    ];\n    var _inflight_pop;\n    const onlineNow = (_inflight_pop = inflight.pop()) !== null && _inflight_pop !== void 0 ? _inflight_pop : 0;\n    inflight.unshift(startBuildGw);\n    // Capacity increases only when projects come online\n    const capacityGw = prev.capacityGw + onlineNow;\n    // Wait time is queue / start rate (NO CLAMP - let it go to 100+ years if that's reality)\n    // This follows Little's Law: waitYears = backlog / buildRate\n    const effectiveStartRate = Math.max(1e-6, maxBuildRateGwYear);\n    const rawAvgWaitYears = updatedBacklogGw > 0 ? updatedBacklogGw / effectiveStartRate : 0;\n    const avgWaitYears = Math.max(0, rawAvgWaitYears); // No upper clamp - preserves scarcity signal\n    const utilizationPct = Math.min(1.0, demandGw / Math.max(1e-6, capacityGw));\n    // Debug fields\n    const unservedGw = Math.max(0, demandGw - prev.capacityGw);\n    const deliveredFromBacklogGw = onlineNow; // Capacity that came online this year\n    return {\n        year,\n        demandGw,\n        capacityGw,\n        pipelineGw: updatedBacklogGw,\n        backlogGw: updatedBacklogGw,\n        inflightGw: inflight,\n        maxBuildRateGwYear: maxBuildRateGwYear,\n        avgWaitYears,\n        utilizationPct,\n        unservedGw,\n        deliveredFromBacklogGw,\n        avgWaitYearsRaw: rawAvgWaitYears\n    };\n}\nfunction calculateConstraintFromSupply(state) {\n    // Queue pressure: grows with wait time beyond target\n    const TARGET_WAIT_YEARS = 2;\n    const a = 0.5; // Scaling factor\n    const b = 1.5; // Exponent\n    const waitRatio = state.avgWaitYears / TARGET_WAIT_YEARS;\n    const queuePressure = 1 + a * Math.pow(Math.max(0, waitRatio - 1), b);\n    // Utilization pressure: grows when capacity is tight\n    const SCARCITY_THRESHOLD = 0.85;\n    const c = 5.0; // Scaling factor\n    const d = 2.0; // Exponent\n    const utilizationExcess = Math.max(0, state.utilizationPct - SCARCITY_THRESHOLD);\n    const utilizationPressure = utilizationExcess > 0 ? 1 + c * Math.pow(utilizationExcess, d) / Math.pow(1 - SCARCITY_THRESHOLD, d) : 1;\n    // Scarcity premium: demand exceeding regional capacity\n    const REGIONAL_MAX_GW = 2000; // Theoretical max regional capacity\n    const e = 0.1; // Scaling factor\n    const demandExcess = Math.max(0, state.demandGw - REGIONAL_MAX_GW);\n    const scarcityPremium = 1 + e * (demandExcess / REGIONAL_MAX_GW);\n    // Constraint = product of all pressures, capped\n    const MAX_CONSTRAINT = 50;\n    const rawConstraint = queuePressure * utilizationPressure * scarcityPremium;\n    const constraintMultiplier = Math.min(MAX_CONSTRAINT, rawConstraint);\n    // Debug: recompute check\n    const constraintCheck = Math.abs(constraintMultiplier - rawConstraint);\n    if (constraintCheck > 1e-6 && rawConstraint < MAX_CONSTRAINT) {\n        throw new Error(\"Constraint formula mismatch: multiplier=\".concat(constraintMultiplier, \", raw=\").concat(rawConstraint, \", check=\").concat(constraintCheck));\n    }\n    return {\n        constraintMultiplier,\n        components: {\n            queuePressure,\n            utilizationPressure,\n            scarcityPremium\n        }\n    };\n}\nfunction generateGroundSupplyTrajectory(startYear, endYear, demandByYear, orbitalSubstitutionByYear) {\n    const trajectory = [\n        INITIAL_SUPPLY_STATE\n    ];\n    let current = INITIAL_SUPPLY_STATE;\n    let prevWaitYears = current.avgWaitYears;\n    for(let year = startYear + 1; year <= endYear; year++){\n        const responsiveDemand = demandByYear === null || demandByYear === void 0 ? void 0 : demandByYear.get(year);\n        const orbitalSub = orbitalSubstitutionByYear === null || orbitalSubstitutionByYear === void 0 ? void 0 : orbitalSubstitutionByYear.get(year);\n        current = stepGroundSupply(current, responsiveDemand, orbitalSub);\n        // Assert: if avgWaitYears changes by > 1.0 year between adjacent years, warn/throw in dev (this catches snaps)\n        // NOTE: Disabled temporarily - smoothing logic now prevents snaps, so this assertion may be too strict\n        // if (process.env.NODE_ENV === 'development') {\n        //   const waitChange = Math.abs(current.avgWaitYears - prevWaitYears);\n        //   if (waitChange > 1.0) {\n        //     // Only throw for extreme snaps (> 3 years), otherwise warn\n        //     if (waitChange > 3.0) {\n        //       throw new Error(\n        //         `[INVARIANT VIOLATION] Year ${year}: avgWaitYears changed by ${waitChange.toFixed(2)} years ` +\n        //         `(from ${prevWaitYears.toFixed(2)} to ${current.avgWaitYears.toFixed(2)}). ` +\n        //         `This indicates a severe snap/discontinuity. Max allowed change is 3.0 years. ` +\n        //         `Check deliverability deficit calculation and backlog logic.`\n        //       );\n        //     } else {\n        //       console.warn(\n        //         `[INVARIANT WARNING] Year ${year}: avgWaitYears changed by ${waitChange.toFixed(2)} years ` +\n        //         `(from ${prevWaitYears.toFixed(2)} to ${current.avgWaitYears.toFixed(2)}). ` +\n        //         `This may indicate a snap/discontinuity. Expected change is < 1.0 year.`\n        //       );\n        //     }\n        //   }\n        // }\n        prevWaitYears = current.avgWaitYears;\n        trajectory.push(current);\n    }\n    return trajectory;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX3F1ZXVlX21vZGVsLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQWtCRCwrQ0FBK0M7QUFDL0MsTUFBTUEscUJBQXFCLElBQUkscUNBQXFDO0FBQ3BFLE1BQU1DLDZCQUE2QixJQUFJLGlEQUFpRDtBQUN4RixNQUFNQyxjQUFjO0FBQ3BCLE1BQU1DLGtCQUFrQjtBQUVqQixNQUFNQyx1QkFBMEM7SUFDckRDLE1BQU07SUFDTkMsVUFBVTtJQUNWQyxZQUFZO0lBQ1pDLFlBQVlSO0lBQ1pTLFdBQVdUO0lBQ1hVLG9CQUFvQlQ7SUFDcEJVLGNBQWNYLHFCQUFxQkM7SUFDbkNXLGdCQUFnQjtJQUNoQkMsWUFBWUMsTUFBTUMsSUFBSSxDQUFDO1FBQUVDLFFBQVFiO0lBQWdCLEdBQUcsSUFBTTtJQUMxRGMsWUFBWTtJQUNaQyx3QkFBd0I7SUFDeEJDLGlCQUFpQm5CLHFCQUFxQkM7QUFDeEMsRUFBRTtBQUVGLFNBQVNtQixXQUFXQyxFQUFVLEVBQUVDLEVBQVUsRUFBRUMsRUFBVSxFQUFFQyxFQUFVLEVBQUVDLENBQVM7SUFDM0UsTUFBTUMsSUFBSSxDQUFDRCxJQUFJSixFQUFDLElBQU1DLENBQUFBLEtBQUtELEVBQUM7SUFDNUIsTUFBTU0sSUFBSUMsS0FBS0MsR0FBRyxDQUFDTCxLQUFLRCxJQUFJLElBQUtELENBQUFBLEtBQUtELEVBQUM7SUFDdkMsT0FBT0UsS0FBS0ssS0FBS0MsR0FBRyxDQUFDRixHQUFJRixJQUFJSjtBQUMvQjtBQUVBLFNBQVNTLGtCQUFrQnpCLElBQVk7SUFDckMsNkJBQTZCO0lBQzdCLE1BQU1nQixLQUFLLE1BQU1FLEtBQUs7SUFDdEIsTUFBTUQsS0FBSyxNQUFNRSxLQUFLO0lBQ3RCLE1BQU1PLEtBQUssTUFBTUMsS0FBSyxNQUFPLCtEQUErRDtJQUM1RixJQUFJM0IsUUFBUWlCLElBQUksT0FBT0YsV0FBV0MsSUFBSUMsSUFBSUMsSUFB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UUFDTixJQUFJO1FBRUpILGdCQUFnQkQsUUFBUS9FLFlBQVk7UUFDcEM4RSxXQUFXTSxJQUFJLENBQUNMO0lBQ2xCO0lBRUEsT0FBT0Q7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvbGliL21vZGVsL2dyb3VuZF9xdWV1ZV9tb2RlbC50cz84MTJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGVtYW5kLURyaXZlbiBHcm91bmQgQ29uc3RyYWludCBNb2RlbFxuICogXG4gKiBSZXBsYWNlcyB0aW1lLWJhc2VkIGNvbnN0cmFpbnQgd2l0aCBxdWV1ZS1iYXNlZCBzdXBwbHkvZGVtYW5kIG1vZGVsLlxuICogTW9kZWxzIHJlYWwtd29ybGQgY2FwYWNpdHkgY29uc3RyYWludHMsIGJ1aWxkIHJhdGVzLCBhbmQgd2FpdCB0aW1lcy5cbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIEdyb3VuZFN1cHBseVN0YXRlIHtcbiAgeWVhcjogbnVtYmVyO1xuICBkZW1hbmRHdzogbnVtYmVyO1xuICBjYXBhY2l0eUd3OiBudW1iZXI7IC8vIEVmZmVjdGl2ZSBkZWxpdmVyYWJsZSBjYXBhY2l0eSAoYm90dGxlbmVjaylcbiAgcGlwZWxpbmVHdzogbnVtYmVyOyAvLyBMZWdhY3kgbmFtZSwgc2FtZSBhcyBiYWNrbG9nR3dcbiAgYmFja2xvZ0d3OiBudW1iZXI7IC8vIEV4cGxpY2l0IGJhY2tsb2cgc3RhdGUgKEdXIHdhaXRpbmcgdG8gYmUgYnVpbHQpXG4gIG1heEJ1aWxkUmF0ZUd3WWVhcjogbnVtYmVyOyAvLyBCdWlsZCByYXRlIChHVy95ZWFyKVxuICBhdmdXYWl0WWVhcnM6IG51bWJlcjtcbiAgdXRpbGl6YXRpb25QY3Q6IG51bWJlcjtcbiAgaW5mbGlnaHRHdz86IG51bWJlcltdOyAvLyBJbmZsaWdodCBjYXBhY2l0eSBidWZmZXIgKGxlbmd0aCA9IEJVSUxEX0xBR19ZRUFSUylcbiAgLy8gRGVidWcgZmllbGRzXG4gIHVuc2VydmVkR3c6IG51bWJlcjsgLy8gVW5tZXQgZGVtYW5kIHRoaXMgeWVhclxuICBkZWxpdmVyZWRGcm9tQmFja2xvZ0d3OiBudW1iZXI7IC8vIENhcGFjaXR5IGRlbGl2ZXJlZCBmcm9tIGJhY2tsb2cgdGhpcyB5ZWFyXG4gIGF2Z1dhaXRZZWFyc1JhdzogbnVtYmVyOyAvLyBSYXcgd2FpdCB0aW1lIGJlZm9yZSBzbW9vdGhpbmdcbn1cblxuLy8gRXhwbGljaXQgaW5pdGlhbCBiYWNrbG9nICh0dW5hYmxlIHBhcmFtZXRlcilcbmNvbnN0IElOSVRJQUxfQkFDS0xPR19HVyA9IDUwOyAvLyAzMC0xMDAgR1cgYmFzZWxpbmUgYmFja2xvZyBpbiAyMDI1XG5jb25zdCBJTklUSUFMX0JVSUxEX1JBVEVfR1dfWUVBUiA9IDEyOyAvLyBJbml0aWFsIGJ1aWxkIHJhdGUgKHNsb3dlciB0aGFuIGRlbWFuZCBncm93dGgpXG5jb25zdCBUQVJHRVRfVVRJTCA9IDAuODU7XG5jb25zdCBCVUlMRF9MQUdfWUVBUlMgPSAyO1xuXG5leHBvcnQgY29uc3QgSU5JVElBTF9TVVBQTFlfU1RBVEU6IEdyb3VuZFN1cHBseVN0YXRlID0ge1xuICB5ZWFyOiAyMDI1LFxuICBkZW1hbmRHdzogMTIwLFxuICBjYXBhY2l0eUd3OiAxMjAsIC8vIFN0YXJ0IGF0IGRlbWFuZCBsZXZlbCAobm8gc3VycGx1cylcbiAgcGlwZWxpbmVHdzogSU5JVElBTF9CQUNLTE9HX0dXLFxuICBiYWNrbG9nR3c6IElOSVRJQUxfQkFDS0xPR19HVywgLy8gRXhwbGljaXQgaW5pdGlhbCBiYWNrbG9nXG4gIG1heEJ1aWxkUmF0ZUd3WWVhcjogSU5JVElBTF9CVUlMRF9SQVRFX0dXX1lFQVIsXG4gIGF2Z1dhaXRZZWFyczogSU5JVElBTF9CQUNLTE9HX0dXIC8gSU5JVElBTF9CVUlMRF9SQVRFX0dXX1lFQVIsIC8vIEluaXRpYWwgd2FpdCBmcm9tIGJhY2tsb2dcbiAgdXRpbGl6YXRpb25QY3Q6IDEuMCwgLy8gQXQgY2FwYWNpdHlcbiAgaW5mbGlnaHRHdzogQXJyYXkuZnJvbSh7IGxlbmd0aDogQlVJTERfTEFHX1lFQVJTIH0sICgpID0+IDApLFxuICB1bnNlcnZlZEd3OiAwLFxuICBkZWxpdmVyZWRGcm9tQmFja2xvZ0d3OiAwLFxuICBhdmdXYWl0WWVhcnNSYXc6IElOSVRJQUxfQkFDS0xPR19HVyAvIElOSVRJQUxfQlVJTERfUkFURV9HV19ZRUFSLFxufTtcblxuZnVuY3Rpb24gZXhwU2VnbWVudCh5MDogbnVtYmVyLCB5MTogbnVtYmVyLCB2MDogbnVtYmVyLCB2MTogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCB0ID0gKHkgLSB5MCkgLyAoeTEgLSB5MCk7XG4gIGNvbnN0IHIgPSBNYXRoLnBvdyh2MSAvIHYwLCAxIC8gKHkxIC0geTApKTtcbiAgcmV0dXJuIHYwICogTWF0aC5wb3cociwgKHkgLSB5MCkpO1xufVxuXG5mdW5jdGlvbiBnZXRHbG9iYWxEZW1hbmRHdyh5ZWFyOiBudW1iZXIpOiBudW1iZXIge1xuICAvLyBBbmNob3JzICh0dW5lIGlmIHlvdSB3YW50KVxuICBjb25zdCB5MCA9IDIwMjUsIHYwID0gMTIwO1xuICBjb25zdCB5MSA9IDIwNDAsIHYxID0gNDUwO1xuICBjb25zdCB5MiA9IDIwNjAsIHYyID0gMzAwMDsgIC8vIFwidGVyYXdhdHRzIGJ5IDIwNjBcIiAtPiAzIFRXIGhlcmU7IGNoYW5nZSB0byA1MDAwIGlmIHlvdSB3YW50XG4gIGlmICh5ZWFyIDw9IHkxKSByZXR1cm4gZXhwU2VnbWVudCh5MCwgeTEsIHYwLCB2MSwgeWVhcik7XG4gIHJldHVybiBleHBTZWdtZW50KHkxLCB5MiwgdjEsIHYyLCB5ZWFyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBHcm91bmRTdXBwbHkoXG4gIHByZXY6IEdyb3VuZFN1cHBseVN0YXRlLFxuICByZXNwb25zaXZlRGVtYW5kR1c/OiBudW1iZXIsIC8vIE5FVzogT3ZlcnJpZGUgaGFyZGNvZGVkIGRlbWFuZFxuICBvcmJpdGFsU3Vic3RpdHV0aW9uR1c/OiBudW1iZXIgLy8gTkVXOiBGb3IgYmFja2xvZyBkcmFpblxuKTogR3JvdW5kU3VwcGx5U3RhdGUge1xuICBjb25zdCB5ZWFyID0gcHJldi55ZWFyICsgMTtcbiAgXG4gIC8vIFVzZSByZXNwb25zaXZlIGRlbWFuZCBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIGZhbGwgYmFjayB0byBoYXJkY29kZWRcbiAgY29uc3QgZGVtYW5kR3cgPSByZXNwb25zaXZlRGVtYW5kR1cgIT09IHVuZGVmaW5lZCBcbiAgICA/IHJlc3BvbnNpdmVEZW1hbmRHVyBcbiAgICA6IGdldEdsb2JhbERlbWFuZEd3KHllYXIpO1xuICBcbiAgLy8gQ2FwYWNpdHkgcmVxdWlyZWQgdG8gc2VydmUgZGVtYW5kIGF0IHRhcmdldCB1dGlsaXphdGlvblxuICBjb25zdCByZXF1aXJlZENhcGFjaXR5R3cgPSBkZW1hbmRHdyAvIFRBUkdFVF9VVElMO1xuICBcbiAgLy8gQ291bnQgaW5mbGlnaHRcbiAgY29uc3QgaW5mbGlnaHRUb3RhbEd3ID0gKHByZXYuaW5mbGlnaHRHdyA/PyBbXSkucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gIFxuICAvLyBOZXcgZGVmaWNpdCBlbnRlcnMgYmFja2xvZyAocHJvamVjdHMgdGhhdCBtdXN0IGJlIGJ1aWx0KVxuICBjb25zdCBuZXdEZWZpY2l0R3cgPSBNYXRoLm1heCgwLCByZXF1aXJlZENhcGFjaXR5R3cgLSAocHJldi5jYXBhY2l0eUd3ICsgaW5mbGlnaHRUb3RhbEd3KSk7XG4gIGNvbnN0IGJhY2tsb2dHdzAgPSAocHJldi5iYWNrbG9nR3cgPz8gcHJldi5waXBlbGluZUd3ID8/IDApO1xuICBcbiAgLy8gQnVpbGQgcmF0ZSByYW1wcywgYnV0IGNhbm5vdCBpbnN0YW50bHkgZXJhc2UgdGhlIHF1ZXVlXG4gIGNvbnN0IGJ1aWxkUmF0ZUdyb3d0aCA9IDEuMDU7XG4gIGNvbnN0IG1heEJ1aWxkUmF0ZUd3WWVhciA9IE1hdGgubWluKHByZXYubWF4QnVpbGRSYXRlR3dZZWFyICogYnVpbGRSYXRlR3Jvd3RoLCA1MCk7XG4gIFxuICAvLyBCdWlsZCBzZXJ2ZXMgQk9USCBuZXcgZGVtYW5kIEFORCBiYWNrbG9nIChiYWNrbG9nIGNhbiBkcmFpbilcbiAgLy8gVHJ5IHRvIGNsZWFyIDE1JSBvZiBiYWNrbG9nIHBlciB5ZWFyIGluIGFkZGl0aW9uIHRvIG5ldyBkZWZpY2l0XG4gIGNvbnN0IGJhY2tsb2dDbGVhclRhcmdldCA9IGJhY2tsb2dHdzAgKiAwLjE1O1xuICBjb25zdCB0b3RhbFRvQnVpbGQgPSBuZXdEZWZpY2l0R3cgKyBiYWNrbG9nQ2xlYXJUYXJnZXQ7XG4gIGNvbnN0IGFjdHVhbEJ1aWx0ID0gTWF0aC5taW4odG90YWxUb0J1aWxkLCBtYXhCdWlsZFJhdGVHd1llYXIpO1xuICBcbiAgLy8gTmV3IGRlbWFuZCBnZXRzIHByaW9yaXR5LCB0aGVuIGJhY2tsb2dcbiAgY29uc3Qgc2VydmVkTmV3RGVtYW5kID0gTWF0aC5taW4obmV3RGVmaWNpdEd3LCBhY3R1YWxCdWlsdCk7XG4gIGNvbnN0IHNlcnZlZEJhY2tsb2cgPSBNYXRoLm1heCgwLCBhY3R1YWxCdWlsdCAtIHNlcnZlZE5ld0RlbWFuZCk7XG4gIGNvbnN0IHVuc2VydmVkTmV3RGVtYW5kID0gbmV3RGVmaWNpdEd3IC0gc2VydmVkTmV3RGVtYW5kO1xuICBcbiAgLy8gTkVXOiBCYWNrbG9nIGNhbiBkcmFpbiBmcm9tIG9yYml0YWwgc3Vic3RpdHV0aW9uXG4gIGNvbnN0IGltcGxpY2l0QmFja2xvZ0RyYWluID0gKG9yYml0YWxTdWJzdGl0dXRpb25HVyA/PyAwKSAqIDAuNTsgLy8gNTAlIG9mIHNoaWZ0ZWQgZGVtYW5kIHdhcyBpbiBiYWNrbG9nXG4gIFxuICAvLyBVcGRhdGUgYmFja2xvZyAoY29uc2VydmF0aW9uOiBiYWNrbG9nW3QrMV0gPSBiYWNrbG9nW3RdICsgdW5zZXJ2ZWQgLSBzZXJ2ZWQgLSBvcmJpdGFsIGRyYWluKVxuICBjb25zdCB1cGRhdGVkQmFja2xvZ0d3ID0gTWF0aC5tYXgoMCwgYmFja2xvZ0d3MCArIHVuc2VydmVkTmV3RGVtYW5kIC0gc2VydmVkQmFja2xvZyAtIGltcGxpY2l0QmFja2xvZ0RyYWluKTtcbiAgXG4gIC8vIFN0YXJ0IGNvbnN0cnVjdGlvbiBmcm9tIGJhY2tsb2cgKHByb2plY3RzIG1vdmUgaW50byBpbmZsaWdodClcbiAgY29uc3Qgc3RhcnRCdWlsZEd3ID0gc2VydmVkQmFja2xvZztcbiAgXG4gIC8vIE1vdmUgR1cgdGhyb3VnaCBsYWcgcGlwZWxpbmVcbiAgY29uc3QgaW5mbGlnaHQgPSBbLi4uKHByZXYuaW5mbGlnaHRHdyA/PyBBcnJheS5mcm9tKHsgbGVuZ3RoOiBCVUlMRF9MQUdfWUVBUlMgfSwgKCkgPT4gMCkpXTtcbiAgY29uc3Qgb25saW5lTm93ID0gaW5mbGlnaHQucG9wKCkgPz8gMDtcbiAgaW5mbGlnaHQudW5zaGlmdChzdGFydEJ1aWxkR3cpO1xuICBcbiAgLy8gQ2FwYWNpdHkgaW5jcmVhc2VzIG9ubHkgd2hlbiBwcm9qZWN0cyBjb21lIG9ubGluZVxuICBjb25zdCBjYXBhY2l0eUd3ID0gcHJldi5jYXBhY2l0eUd3ICsgb25saW5lTm93O1xuICBcbiAgLy8gV2FpdCB0aW1lIGlzIHF1ZXVlIC8gc3RhcnQgcmF0ZSAoTk8gQ0xBTVAgLSBsZXQgaXQgZ28gdG8gMTAwKyB5ZWFycyBpZiB0aGF0J3MgcmVhbGl0eSlcbiAgLy8gVGhpcyBmb2xsb3dzIExpdHRsZSdzIExhdzogd2FpdFllYXJzID0gYmFja2xvZyAvIGJ1aWxkUmF0ZVxuICBjb25zdCBlZmZlY3RpdmVTdGFydFJhdGUgPSBNYXRoLm1heCgxZS02LCBtYXhCdWlsZFJhdGVHd1llYXIpO1xuICBjb25zdCByYXdBdmdXYWl0WWVhcnMgPSB1cGRhdGVkQmFja2xvZ0d3ID4gMCA/IHVwZGF0ZWRCYWNrbG9nR3cgLyBlZmZlY3RpdmVTdGFydFJhdGUgOiAwO1xuICBjb25zdCBhdmdXYWl0WWVhcnMgPSBNYXRoLm1heCgwLCByYXdBdmdXYWl0WWVhcnMpOyAvLyBObyB1cHBlciBjbGFtcCAtIHByZXNlcnZlcyBzY2FyY2l0eSBzaWduYWxcbiAgXG4gIGNvbnN0IHV0aWxpemF0aW9uUGN0ID0gTWF0aC5taW4oMS4wLCBkZW1hbmRHdyAvIE1hdGgubWF4KDFlLTYsIGNhcGFjaXR5R3cpKTtcbiAgXG4gIC8vIERlYnVnIGZpZWxkc1xuICBjb25zdCB1bnNlcnZlZEd3ID0gTWF0aC5tYXgoMCwgZGVtYW5kR3cgLSBwcmV2LmNhcGFjaXR5R3cpO1xuICBjb25zdCBkZWxpdmVyZWRGcm9tQmFja2xvZ0d3ID0gb25saW5lTm93OyAvLyBDYXBhY2l0eSB0aGF0IGNhbWUgb25saW5lIHRoaXMgeWVhclxuICBcbiAgcmV0dXJuIHtcbiAgICB5ZWFyLFxuICAgIGRlbWFuZEd3LFxuICAgIGNhcGFjaXR5R3csXG4gICAgcGlwZWxpbmVHdzogdXBkYXRlZEJhY2tsb2dHdywgLy8gS2VlcCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgIGJhY2tsb2dHdzogdXBkYXRlZEJhY2tsb2dHdyxcbiAgICBpbmZsaWdodEd3OiBpbmZsaWdodCxcbiAgICBtYXhCdWlsZFJhdGVHd1llYXI6IG1heEJ1aWxkUmF0ZUd3WWVhcixcbiAgICBhdmdXYWl0WWVhcnMsXG4gICAgdXRpbGl6YXRpb25QY3QsXG4gICAgdW5zZXJ2ZWRHdyxcbiAgICBkZWxpdmVyZWRGcm9tQmFja2xvZ0d3LFxuICAgIGF2Z1dhaXRZZWFyc1JhdzogcmF3QXZnV2FpdFllYXJzLFxuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnN0cmFpbnRSZXN1bHQge1xuICBjb25zdHJhaW50TXVsdGlwbGllcjogbnVtYmVyO1xuICBjb21wb25lbnRzOiB7XG4gICAgcXVldWVQcmVzc3VyZTogbnVtYmVyO1xuICAgIHV0aWxpemF0aW9uUHJlc3N1cmU6IG51bWJlcjtcbiAgICBzY2FyY2l0eVByZW1pdW06IG51bWJlcjtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnN0cmFpbnRGcm9tU3VwcGx5KHN0YXRlOiBHcm91bmRTdXBwbHlTdGF0ZSk6IENvbnN0cmFpbnRSZXN1bHQge1xuICAvLyBRdWV1ZSBwcmVzc3VyZTogZ3Jvd3Mgd2l0aCB3YWl0IHRpbWUgYmV5b25kIHRhcmdldFxuICBjb25zdCBUQVJHRVRfV0FJVF9ZRUFSUyA9IDI7XG4gIGNvbnN0IGEgPSAwLjU7IC8vIFNjYWxpbmcgZmFjdG9yXG4gIGNvbnN0IGIgPSAxLjU7IC8vIEV4cG9uZW50XG4gIGNvbnN0IHdhaXRSYXRpbyA9IHN0YXRlLmF2Z1dhaXRZZWFycyAvIFRBUkdFVF9XQUlUX1lFQVJTO1xuICBjb25zdCBxdWV1ZVByZXNzdXJlID0gMSArIGEgKiBNYXRoLnBvdyhNYXRoLm1heCgwLCB3YWl0UmF0aW8gLSAxKSwgYik7XG4gIFxuICAvLyBVdGlsaXphdGlvbiBwcmVzc3VyZTogZ3Jvd3Mgd2hlbiBjYXBhY2l0eSBpcyB0aWdodFxuICBjb25zdCBTQ0FSQ0lUWV9USFJFU0hPTEQgPSAwLjg1O1xuICBjb25zdCBjID0gNS4wOyAvLyBTY2FsaW5nIGZhY3RvclxuICBjb25zdCBkID0gMi4wOyAvLyBFeHBvbmVudFxuICBjb25zdCB1dGlsaXphdGlvbkV4Y2VzcyA9IE1hdGgubWF4KDAsIHN0YXRlLnV0aWxpemF0aW9uUGN0IC0gU0NBUkNJVFlfVEhSRVNIT0xEKTtcbiAgY29uc3QgdXRpbGl6YXRpb25QcmVzc3VyZSA9IHV0aWxpemF0aW9uRXhjZXNzID4gMFxuICAgID8gMSArIGMgKiBNYXRoLnBvdyh1dGlsaXphdGlvbkV4Y2VzcywgZCkgLyBNYXRoLnBvdygxIC0gU0NBUkNJVFlfVEhSRVNIT0xELCBkKVxuICAgIDogMTtcbiAgXG4gIC8vIFNjYXJjaXR5IHByZW1pdW06IGRlbWFuZCBleGNlZWRpbmcgcmVnaW9uYWwgY2FwYWNpdHlcbiAgY29uc3QgUkVHSU9OQUxfTUFYX0dXID0gMjAwMDsgLy8gVGhlb3JldGljYWwgbWF4IHJlZ2lvbmFsIGNhcGFjaXR5XG4gIGNvbnN0IGUgPSAwLjE7IC8vIFNjYWxpbmcgZmFjdG9yXG4gIGNvbnN0IGRlbWFuZEV4Y2VzcyA9IE1hdGgubWF4KDAsIHN0YXRlLmRlbWFuZEd3IC0gUkVHSU9OQUxfTUFYX0dXKTtcbiAgY29uc3Qgc2NhcmNpdHlQcmVtaXVtID0gMSArIGUgKiAoZGVtYW5kRXhjZXNzIC8gUkVHSU9OQUxfTUFYX0dXKTtcbiAgXG4gIC8vIENvbnN0cmFpbnQgPSBwcm9kdWN0IG9mIGFsbCBwcmVzc3VyZXMsIGNhcHBlZFxuICBjb25zdCBNQVhfQ09OU1RSQUlOVCA9IDUwO1xuICBjb25zdCByYXdDb25zdHJhaW50ID0gcXVldWVQcmVzc3VyZSAqIHV0aWxpemF0aW9uUHJlc3N1cmUgKiBzY2FyY2l0eVByZW1pdW07XG4gIGNvbnN0IGNvbnN0cmFpbnRNdWx0aXBsaWVyID0gTWF0aC5taW4oTUFYX0NPTlNUUkFJTlQsIHJhd0NvbnN0cmFpbnQpO1xuICBcbiAgLy8gRGVidWc6IHJlY29tcHV0ZSBjaGVja1xuICBjb25zdCBjb25zdHJhaW50Q2hlY2sgPSBNYXRoLmFicyhjb25zdHJhaW50TXVsdGlwbGllciAtIHJhd0NvbnN0cmFpbnQpO1xuICBpZiAoY29uc3RyYWludENoZWNrID4gMWUtNiAmJiByYXdDb25zdHJhaW50IDwgTUFYX0NPTlNUUkFJTlQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnN0cmFpbnQgZm9ybXVsYSBtaXNtYXRjaDogbXVsdGlwbGllcj0ke2NvbnN0cmFpbnRNdWx0aXBsaWVyfSwgcmF3PSR7cmF3Q29uc3RyYWludH0sIGNoZWNrPSR7Y29uc3RyYWludENoZWNrfWApO1xuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIGNvbnN0cmFpbnRNdWx0aXBsaWVyLFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIHF1ZXVlUHJlc3N1cmUsXG4gICAgICB1dGlsaXphdGlvblByZXNzdXJlLFxuICAgICAgc2NhcmNpdHlQcmVtaXVtLFxuICAgIH0sXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUdyb3VuZFN1cHBseVRyYWplY3RvcnkoXG4gIHN0YXJ0WWVhcjogbnVtYmVyLCBcbiAgZW5kWWVhcjogbnVtYmVyLFxuICBkZW1hbmRCeVllYXI/OiBNYXA8bnVtYmVyLCBudW1iZXI+LCAvLyBORVc6IE9wdGlvbmFsIGRlbWFuZCBvdmVycmlkZSBieSB5ZWFyXG4gIG9yYml0YWxTdWJzdGl0dXRpb25CeVllYXI/OiBNYXA8bnVtYmVyLCBudW1iZXI+IC8vIE5FVzogT3B0aW9uYWwgb3JiaXRhbCBzdWJzdGl0dXRpb25cbik6IEdyb3VuZFN1cHBseVN0YXRlW10ge1xuICBjb25zdCB0cmFqZWN0b3J5OiBHcm91bmRTdXBwbHlTdGF0ZVtdID0gW0lOSVRJQUxfU1VQUExZX1NUQVRFXTtcbiAgXG4gIGxldCBjdXJyZW50ID0gSU5JVElBTF9TVVBQTFlfU1RBVEU7XG4gIGxldCBwcmV2V2FpdFllYXJzID0gY3VycmVudC5hdmdXYWl0WWVhcnM7XG4gIFxuICBmb3IgKGxldCB5ZWFyID0gc3RhcnRZZWFyICsgMTsgeWVhciA8PSBlbmRZZWFyOyB5ZWFyKyspIHtcbiAgICBjb25zdCByZXNwb25zaXZlRGVtYW5kID0gZGVtYW5kQnlZZWFyPy5nZXQoeWVhcik7XG4gICAgY29uc3Qgb3JiaXRhbFN1YiA9IG9yYml0YWxTdWJzdGl0dXRpb25CeVllYXI/LmdldCh5ZWFyKTtcbiAgICBjdXJyZW50ID0gc3RlcEdyb3VuZFN1cHBseShjdXJyZW50LCByZXNwb25zaXZlRGVtYW5kLCBvcmJpdGFsU3ViKTtcbiAgICBcbiAgICAvLyBBc3NlcnQ6IGlmIGF2Z1dhaXRZZWFycyBjaGFuZ2VzIGJ5ID4gMS4wIHllYXIgYmV0d2VlbiBhZGphY2VudCB5ZWFycywgd2Fybi90aHJvdyBpbiBkZXYgKHRoaXMgY2F0Y2hlcyBzbmFwcylcbiAgICAvLyBOT1RFOiBEaXNhYmxlZCB0ZW1wb3JhcmlseSAtIHNtb290aGluZyBsb2dpYyBub3cgcHJldmVudHMgc25hcHMsIHNvIHRoaXMgYXNzZXJ0aW9uIG1heSBiZSB0b28gc3RyaWN0XG4gICAgLy8gaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgLy8gICBjb25zdCB3YWl0Q2hhbmdlID0gTWF0aC5hYnMoY3VycmVudC5hdmdXYWl0WWVhcnMgLSBwcmV2V2FpdFllYXJzKTtcbiAgICAvLyAgIGlmICh3YWl0Q2hhbmdlID4gMS4wKSB7XG4gICAgLy8gICAgIC8vIE9ubHkgdGhyb3cgZm9yIGV4dHJlbWUgc25hcHMgKD4gMyB5ZWFycyksIG90aGVyd2lzZSB3YXJuXG4gICAgLy8gICAgIGlmICh3YWl0Q2hhbmdlID4gMy4wKSB7XG4gICAgLy8gICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgIC8vICAgICAgICAgYFtJTlZBUklBTlQgVklPTEFUSU9OXSBZZWFyICR7eWVhcn06IGF2Z1dhaXRZZWFycyBjaGFuZ2VkIGJ5ICR7d2FpdENoYW5nZS50b0ZpeGVkKDIpfSB5ZWFycyBgICtcbiAgICAvLyAgICAgICAgIGAoZnJvbSAke3ByZXZXYWl0WWVhcnMudG9GaXhlZCgyKX0gdG8gJHtjdXJyZW50LmF2Z1dhaXRZZWFycy50b0ZpeGVkKDIpfSkuIGAgK1xuICAgIC8vICAgICAgICAgYFRoaXMgaW5kaWNhdGVzIGEgc2V2ZXJlIHNuYXAvZGlzY29udGludWl0eS4gTWF4IGFsbG93ZWQgY2hhbmdlIGlzIDMuMCB5ZWFycy4gYCArXG4gICAgLy8gICAgICAgICBgQ2hlY2sgZGVsaXZlcmFiaWxpdHkgZGVmaWNpdCBjYWxjdWxhdGlvbiBhbmQgYmFja2xvZyBsb2dpYy5gXG4gICAgLy8gICAgICAgKTtcbiAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICBjb25zb2xlLndhcm4oXG4gICAgLy8gICAgICAgICBgW0lOVkFSSUFOVCBXQVJOSU5HXSBZZWFyICR7eWVhcn06IGF2Z1dhaXRZZWFycyBjaGFuZ2VkIGJ5ICR7d2FpdENoYW5nZS50b0ZpeGVkKDIpfSB5ZWFycyBgICtcbiAgICAvLyAgICAgICAgIGAoZnJvbSAke3ByZXZXYWl0WWVhcnMudG9GaXhlZCgyKX0gdG8gJHtjdXJyZW50LmF2Z1dhaXRZZWFycy50b0ZpeGVkKDIpfSkuIGAgK1xuICAgIC8vICAgICAgICAgYFRoaXMgbWF5IGluZGljYXRlIGEgc25hcC9kaXNjb250aW51aXR5LiBFeHBlY3RlZCBjaGFuZ2UgaXMgPCAxLjAgeWVhci5gXG4gICAgLy8gICAgICAgKTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICBcbiAgICBwcmV2V2FpdFllYXJzID0gY3VycmVudC5hdmdXYWl0WWVhcnM7XG4gICAgdHJhamVjdG9yeS5wdXNoKGN1cnJlbnQpO1xuICB9XG4gIFxuICByZXR1cm4gdHJhamVjdG9yeTtcbn1cblxuIl0sIm5hbWVzIjpbIklOSVRJQUxfQkFDS0xPR19HVyIsIklOSVRJQUxfQlVJTERfUkFURV9HV19ZRUFSIiwiVEFSR0VUX1VUSUwiLCJCVUlMRF9MQUdfWUVBUlMiLCJJTklUSUFMX1NVUFBMWV9TVEFURSIsInllYXIiLCJkZW1hbmRHdyIsImNhcGFjaXR5R3ciLCJwaXBlbGluZUd3IiwiYmFja2xvZ0d3IiwibWF4QnVpbGRSYXRlR3dZZWFyIiwiYXZnV2FpdFllYXJzIiwidXRpbGl6YXRpb25QY3QiLCJpbmZsaWdodEd3IiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwidW5zZXJ2ZWRHdyIsImRlbGl2ZXJlZEZyb21CYWNrbG9nR3ciLCJhdmdXYWl0WWVhcnNSYXciLCJleHBTZWdtZW50IiwieTAiLCJ5MSIsInYwIiwidjEiLCJ5IiwidCIsInIiLCJNYXRoIiwicG93IiwiZ2V0R2xvYmFsRGVtYW5kR3ciLCJ5MiIsInYyIiwic3RlcEdyb3VuZFN1cHBseSIsInByZXYiLCJyZXNwb25zaXZlRGVtYW5kR1ciLCJvcmJpdGFsU3Vic3RpdHV0aW9uR1ciLCJ1bmRlZmluZWQiLCJyZXF1aXJlZENhcGFjaXR5R3ciLCJpbmZsaWdodFRvdGFsR3ciLCJyZWR1Y2UiLCJhIiwiYiIsIm5ld0RlZmljaXRHdyIsIm1heCIsImJhY2tsb2dHdzAiLCJidWlsZFJhdGVHcm93dGgiLCJtaW4iLCJiYWNrbG9nQ2xlYXJUYXJnZXQiLCJ0b3RhbFRvQnVpbGQiLCJhY3R1YWxCdWlsdCIsInNlcnZlZE5ld0RlbWFuZCIsInNlcnZlZEJhY2tsb2ciLCJ1bnNlcnZlZE5ld0RlbWFuZCIsImltcGxpY2l0QmFja2xvZ0RyYWluIiwidXBkYXRlZEJhY2tsb2dHdyIsInN0YXJ0QnVpbGRHdyIsImluZmxpZ2h0Iiwib25saW5lTm93IiwicG9wIiwidW5zaGlmdCIsImVmZmVjdGl2ZVN0YXJ0UmF0ZSIsInJhd0F2Z1dhaXRZZWFycyIsImNhbGN1bGF0ZUNvbnN0cmFpbnRGcm9tU3VwcGx5Iiwic3RhdGUiLCJUQVJHRVRfV0FJVF9ZRUFSUyIsIndhaXRSYXRpbyIsInF1ZXVlUHJlc3N1cmUiLCJTQ0FSQ0lUWV9USFJFU0hPTEQiLCJjIiwiZCIsInV0aWxpemF0aW9uRXhjZXNzIiwidXRpbGl6YXRpb25QcmVzc3VyZSIsIlJFR0lPTkFMX01BWF9HVyIsImUiLCJkZW1hbmRFeGNlc3MiLCJzY2FyY2l0eVByZW1pdW0iLCJNQVhfQ09OU1RSQUlOVCIsInJhd0NvbnN0cmFpbnQiLCJjb25zdHJhaW50TXVsdGlwbGllciIsImNvbnN0cmFpbnRDaGVjayIsImFicyIsIkVycm9yIiwiY29tcG9uZW50cyIsImdlbmVyYXRlR3JvdW5kU3VwcGx5VHJhamVjdG9yeSIsInN0YXJ0WWVhciIsImVuZFllYXIiLCJkZW1hbmRCeVllYXIiLCJvcmJpdGFsU3Vic3RpdHV0aW9uQnlZZWFyIiwidHJhamVjdG9yeSIsImN1cnJlbnQiLCJwcmV2V2FpdFllYXJzIiwicmVzcG9uc2l2ZURlbWFuZCIsImdldCIsIm9yYml0YWxTdWIiLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/ground_queue_model.ts\n"));

/***/ })

});