"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/model/physicsCost.ts":
/*!**************************************!*\
  !*** ./app/lib/model/physicsCost.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_SMR_PARAMS: function() { return /* binding */ DEFAULT_SMR_PARAMS; },\n/* harmony export */   GROUND_SCENARIOS: function() { return /* binding */ GROUND_SCENARIOS; },\n/* harmony export */   MODEL_UNITS: function() { return /* binding */ MODEL_UNITS; },\n/* harmony export */   computePhysicsCost: function() { return /* binding */ computePhysicsCost; },\n/* harmony export */   getLaunchCostPerKg: function() { return /* binding */ getLaunchCostPerKg; }\n/* harmony export */ });\n/* harmony import */ var _congestion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./congestion */ \"(app-pages-browser)/./app/lib/model/congestion.ts\");\n/* harmony import */ var _edgeInference__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./edgeInference */ \"(app-pages-browser)/./app/lib/model/edgeInference.ts\");\n/* harmony import */ var _orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./orbitalPhysics */ \"(app-pages-browser)/./app/lib/model/orbitalPhysics.ts\");\n/* harmony import */ var _ground_supply_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ground_supply_model */ \"(app-pages-browser)/./app/lib/model/ground_supply_model.ts\");\n/* harmony import */ var _ground_queue_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ground_queue_model */ \"(app-pages-browser)/./app/lib/model/ground_queue_model.ts\");\n/* harmony import */ var _ground_constraint_penalties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ground_constraint_penalties */ \"(app-pages-browser)/./app/lib/model/ground_constraint_penalties.ts\");\n/* harmony import */ var _ground_buildout__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ground_buildout */ \"(app-pages-browser)/./app/lib/model/ground_buildout.ts\");\n/* harmony import */ var _ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ground_ramping_mobilization */ \"(app-pages-browser)/./app/lib/model/ground_ramping_mobilization.ts\");\n/* harmony import */ var _compute_efficiency__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./compute_efficiency */ \"(app-pages-browser)/./app/lib/model/compute_efficiency.ts\");\n/* harmony import */ var _cost_accounting__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./cost_accounting */ \"(app-pages-browser)/./app/lib/model/cost_accounting.ts\");\n/* harmony import */ var _units__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./units */ \"(app-pages-browser)/./app/lib/model/units.ts\");\n/* harmony import */ var _constellation_sizing__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./constellation_sizing */ \"(app-pages-browser)/./app/lib/model/constellation_sizing.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst CONSTANTS = {\n    HOURS_PER_YEAR: 8760,\n    GROUND_HARDWARE_COST_PFLOP_2025: 15000,\n    GROUND_HARDWARE_LIFETIME: 3,\n    MIN_DELIVERED_GFLOPS_PER_W: 20\n};\nconst DEFAULT_SMR_PARAMS = {\n    enabled: false,\n    smrDeploymentStartYear: 2030,\n    smrRampUpYears: 5,\n    electricityCostWithSMR: 50,\n    gridConstraintRelief: 0.90,\n    coolingConstraintRelief: 0.50,\n    waterConstraintRelief: 0.30,\n    landConstraintRelief: 0.60,\n    smrCapexPremium: 1.15\n};\nconst GROUND_SCENARIOS = {\n    unconstrained: {\n        name: \"Unconstrained\",\n        description: \"SMRs + geographic arbitrage solve power/water constraints\",\n        constraintCap: 1.5,\n        gridGrowthRate: 0.02,\n        coolingGrowthRate: 0.01,\n        waterGrowthRate: 0.01,\n        landGrowthRate: 0.01\n    },\n    moderate: {\n        name: \"Moderate\",\n        description: \"Partial adaptation, some persistent friction\",\n        constraintCap: 3.0,\n        gridGrowthRate: 0.03,\n        coolingGrowthRate: 0.02,\n        waterGrowthRate: 0.015,\n        landGrowthRate: 0.015\n    },\n    constrained: {\n        name: \"Constrained (Aggressive Baseline)\",\n        description: \"Accelerated AI demand pressure on infrastructure\",\n        constraintCap: null,\n        gridGrowthRate: 0.07,\n        coolingGrowthRate: 0.04,\n        waterGrowthRate: 0.03,\n        landGrowthRate: 0.03\n    },\n    severe: {\n        name: \"Severe\",\n        description: \"Constrained + carbon tax + water scarcity crisis\",\n        constraintCap: null,\n        gridGrowthRate: 0.09,\n        coolingGrowthRate: 0.06,\n        waterGrowthRate: 0.05,\n        landGrowthRate: 0.04\n    }\n};\nfunction calculateGroundConstraint(year, scenarioKey, enabled) {\n    if (!enabled) return {\n        multiplier: 1.0,\n        breakdown: {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0\n        }\n    };\n    const scenario = GROUND_SCENARIOS[scenarioKey];\n    const yearsFromBase = Math.max(0, year - 2025);\n    const grid = Math.pow(1 + scenario.gridGrowthRate, yearsFromBase);\n    const cooling = Math.pow(1 + scenario.coolingGrowthRate, yearsFromBase);\n    const water = Math.pow(1 + scenario.waterGrowthRate, yearsFromBase);\n    const land = Math.pow(1 + scenario.landGrowthRate, yearsFromBase);\n    let multiplier = grid * cooling * water * land;\n    if (scenario.constraintCap !== null) {\n        multiplier = Math.min(multiplier, scenario.constraintCap);\n    }\n    return {\n        multiplier,\n        breakdown: {\n            grid,\n            cooling,\n            water,\n            land\n        }\n    };\n}\nfunction validateComputeEfficiency(gflopsPerWatt) {\n    let level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"system\";\n    const ranges = {\n        chip: {\n            min: 100,\n            max: 10000\n        },\n        system: {\n            min: 30,\n            max: 5000\n        },\n        datacenter: {\n            min: 10,\n            max: 1000\n        }\n    };\n    const range = ranges[level];\n    if (gflopsPerWatt < range.min || gflopsPerWatt > range.max) {\n        return {\n            valid: false,\n            warning: \"gflopsPerWatt=\".concat(gflopsPerWatt.toFixed(0), \" outside expected range for \").concat(level, \" level (\").concat(range.min, \"-\").concat(range.max, \")\")\n        };\n    }\n    return {\n        valid: true\n    };\n}\nconst SLA_TIERS = {\n    \"basic\": {\n        availabilityTarget: 0.99,\n        maxLatencyToGroundMs: 100,\n        minBandwidthGbps: 1,\n        maxRecoveryTimeMinutes: 60,\n        creditPerViolationPct: 10\n    },\n    \"standard\": {\n        availabilityTarget: 0.999,\n        maxLatencyToGroundMs: 50,\n        minBandwidthGbps: 10,\n        maxRecoveryTimeMinutes: 15,\n        creditPerViolationPct: 25\n    },\n    \"premium\": {\n        availabilityTarget: 0.9999,\n        maxLatencyToGroundMs: 20,\n        minBandwidthGbps: 100,\n        maxRecoveryTimeMinutes: 5,\n        creditPerViolationPct: 50\n    }\n};\nfunction applyStaticFreeze(params) {\n    if (!params.isStaticMode) return params;\n    return {\n        ...params,\n        launchCostKg: 1500,\n        specificPowerWKg: 36.5,\n        groundEffectiveGflopsPerW_2025: 30,\n        orbitEffectiveGflopsPerW_2025: 25,\n        groundConstraintsEnabled: true,\n        powerGridMultiplier: 1.0,\n        coolingMultiplier: 1.0,\n        waterScarcityEnabled: false,\n        landScarcityEnabled: false,\n        deployableArea2025M2: 75,\n        deployableArea2040M2: 75\n    };\n}\n// Cache for monotonicity check\nlet prevLaunchCostCache = new Map();\nfunction getLaunchCostPerKg(year, base2025) {\n    if (year <= 2025) {\n        prevLaunchCostCache.set(year, base2025);\n        return base2025;\n    }\n    const COMMERCIAL_MARKUP = 2.5;\n    const INSURANCE_PCT = 0.05;\n    const INTEGRATION_COST_PER_LAUNCH = 500000; // $500k per launch\n    const ASSUMED_PAYLOAD_KG = 100000; // 100t payload for integration cost amortization\n    // Internal SpaceX cost trajectory (marginal cost)\n    // Normalize base2025 to internal cost scale\n    const internalBase2025 = base2025 / (COMMERCIAL_MARKUP * (1 + INSURANCE_PCT)) - INTEGRATION_COST_PER_LAUNCH / ASSUMED_PAYLOAD_KG;\n    const normalizedBase = Math.max(internalBase2025, 600); // Ensure reasonable internal cost\n    const internalWaypoints = [\n        [\n            2025,\n            normalizedBase\n        ],\n        [\n            2026,\n            800\n        ],\n        [\n            2027,\n            400\n        ],\n        [\n            2028,\n            200\n        ],\n        [\n            2030,\n            75\n        ],\n        [\n            2035,\n            30\n        ],\n        [\n            2040,\n            20\n        ],\n        [\n            2045,\n            15\n        ],\n        [\n            2050,\n            10\n        ] // Internal cost floor\n    ];\n    // Find internal cost\n    let internalCostPerKg = normalizedBase;\n    for(let i = 0; i < internalWaypoints.length - 1; i++){\n        const [y1, c1] = internalWaypoints[i];\n        const [y2, c2] = internalWaypoints[i + 1];\n        if (year >= y1 && year <= y2) {\n            const t = (year - y1) / (y2 - y1);\n            internalCostPerKg = c1 * Math.pow(c2 / c1, t);\n            break;\n        }\n    }\n    if (year > internalWaypoints[internalWaypoints.length - 1][0]) {\n        internalCostPerKg = internalWaypoints[internalWaypoints.length - 1][1];\n    }\n    // Apply commercial markup\n    const withMarkup = internalCostPerKg * COMMERCIAL_MARKUP;\n    const withInsurance = withMarkup * (1 + INSURANCE_PCT);\n    const integrationPerKg = INTEGRATION_COST_PER_LAUNCH / ASSUMED_PAYLOAD_KG;\n    const commercialCostPerKg = withInsurance + integrationPerKg;\n    // Floor: commercial cost never below $30/kg (realistic minimum)\n    let result = Math.max(commercialCostPerKg, 30);\n    // Enforce monotonicity: never increase from previous year\n    const prevYear = year - 1;\n    const prevCost = prevLaunchCostCache.get(prevYear);\n    if (prevCost !== undefined && result > prevCost) {\n        result = prevCost; // Clamp to previous year's cost\n    }\n    prevLaunchCostCache.set(year, result);\n    return result;\n}\nfunction calculateTokenPricing(costPerPflopYear, modelConfig) {\n    const baseFLOPS = modelConfig.params * 2;\n    const precisionMultiplier = {\n        \"fp16\": 1.0,\n        \"fp8\": 0.5,\n        \"int8\": 0.5\n    }[modelConfig.precision];\n    const flopsPerToken = baseFLOPS * precisionMultiplier;\n    const secondsPerYear = 8760 * 3600;\n    const flopsPerPflopYear = 1e15 * secondsPerYear;\n    const tokensPerPflopYear = flopsPerPflopYear / flopsPerToken;\n    const costPerToken = costPerPflopYear / tokensPerPflopYear;\n    return {\n        modelParams: modelConfig.params,\n        precision: modelConfig.precision,\n        flopsPerToken,\n        tokensPerPflopYear,\n        costPerToken,\n        costPer1kTokens: costPerToken * 1000,\n        costPer1mTokens: costPerToken * 1e6\n    };\n}\nfunction calculateGpuHourPricing(costPerPflopYear, params, costBreakdown) {\n    const hoursPerYear = 8760;\n    const costPerGpuYear = costPerPflopYear * params.pflopsPerGpu;\n    const effectiveHours = hoursPerYear * params.utilizationTarget;\n    const basePerHour = costPerGpuYear / effectiveHours;\n    // DEFENSIVE CHECK: GPU-hour price should be in reasonable range ($0.01 to $100)\n    // If costPerPflopYear is insane (e.g., billions), this will catch it\n    if ( true && basePerHour > 1000) {\n        console.error(\"[GPU-HOUR PRICING] Year calculation: basePerHour=\".concat(basePerHour, \" > 1000. \") + \"costPerPflopYear=\".concat(costPerPflopYear, \", pflopsPerGpu=\").concat(params.pflopsPerGpu, \", \") + \"effectiveHours=\".concat(effectiveHours));\n        // Clamp to prevent chart explosion\n        const clampedCostPerPflopYear = Math.min(costPerPflopYear, 10000); // Cap at $10k/PFLOP-year\n        const clampedCostPerGpuYear = clampedCostPerPflopYear * params.pflopsPerGpu;\n        const clampedBasePerHour = clampedCostPerGpuYear / effectiveHours;\n        if (clampedBasePerHour > 100) {\n            throw new Error(\"[GPU-HOUR PRICING] Even after clamping, basePerHour=\".concat(clampedBasePerHour, \" > 100. \") + \"This indicates a unit error or calculation bug. Check costPerPflopYear input.\");\n        }\n    }\n    // Derive breakdown from cost components if provided\n    let powerPerHour = 0;\n    let coolingPerHour = 0;\n    let interconnectPerHour = 0;\n    let opsPerHour = 0;\n    let computePerHour = basePerHour;\n    if (costBreakdown) {\n        const totalBase = (costBreakdown.power || 0) + (costBreakdown.thermal || 0) + (costBreakdown.interconnect || 0) + (costBreakdown.ops || 0) + (costBreakdown.compute || 0);\n        if (totalBase > 0) {\n            // Scale breakdown components to GPU-hour\n            const scale = costPerGpuYear / (totalBase * params.pflopsPerGpu) / effectiveHours;\n            powerPerHour = (costBreakdown.power || 0) * params.pflopsPerGpu * scale;\n            coolingPerHour = (costBreakdown.thermal || 0) * params.pflopsPerGpu * scale;\n            interconnectPerHour = (costBreakdown.interconnect || 0) * params.pflopsPerGpu * scale;\n            opsPerHour = (costBreakdown.ops || 0) * params.pflopsPerGpu * scale;\n            computePerHour = (costBreakdown.compute || 0) * params.pflopsPerGpu * scale;\n        }\n    } else {\n        // Fallback: estimate ops as 5% of base\n        opsPerHour = basePerHour * 0.05;\n    }\n    const nines = -Math.log10(1 - params.sla.availabilityTarget);\n    const sparesRatio = 1 + 0.05 * nines;\n    const sparesPerHour = computePerHour * (sparesRatio - 1);\n    const violationProb = 1 - params.sla.availabilityTarget;\n    const expectedCreditPerHour = violationProb * params.sla.creditPerViolationPct / 100;\n    const slaRiskBuffer = basePerHour * expectedCreditPerHour * 2;\n    const totalCostPerHour = computePerHour + powerPerHour + coolingPerHour + interconnectPerHour + opsPerHour + sparesPerHour + slaRiskBuffer;\n    const margin = totalCostPerHour * params.operatorMarginPct;\n    let pricePerGpuHour = totalCostPerHour + margin;\n    // FINAL CLAMP: GPU-hour price must be in reasonable range ($0.01 to $100)\n    // This prevents chart explosion from unit errors or calculation bugs\n    const MAX_REASONABLE_GPU_HOUR_PRICE = 100;\n    const MIN_REASONABLE_GPU_HOUR_PRICE = 0.01;\n    if (pricePerGpuHour > MAX_REASONABLE_GPU_HOUR_PRICE) {\n        if (true) {\n            console.error(\"[GPU-HOUR PRICING] pricePerGpuHour=\".concat(pricePerGpuHour, \" > \").concat(MAX_REASONABLE_GPU_HOUR_PRICE, \". \") + \"Clamping to \".concat(MAX_REASONABLE_GPU_HOUR_PRICE, \". \") + \"costPerPflopYear=\".concat(costPerPflopYear, \", basePerHour=\").concat(basePerHour, \", totalCostPerHour=\").concat(totalCostPerHour));\n        }\n        pricePerGpuHour = MAX_REASONABLE_GPU_HOUR_PRICE;\n    }\n    if (pricePerGpuHour < MIN_REASONABLE_GPU_HOUR_PRICE && pricePerGpuHour > 0) {\n        pricePerGpuHour = MIN_REASONABLE_GPU_HOUR_PRICE;\n    }\n    return {\n        gpuType: \"H100-equivalent\",\n        location: params.location,\n        sla: params.sla,\n        pricePerGpuHour,\n        costBreakdown: {\n            hardwareAmortization: computePerHour,\n            power: powerPerHour,\n            cooling: coolingPerHour,\n            interconnect: interconnectPerHour,\n            operations: opsPerHour,\n            spares: sparesPerHour,\n            slaRiskBuffer,\n            margin\n        },\n        effectiveUtilization: params.utilizationTarget,\n        sparesRatio\n    };\n}\nconst MODEL_UNITS = {\n    pflopDefinition: \"fp16\",\n    sustainedVsPeak: \"sustained\",\n    gflopsPerWattLevel: \"system\",\n    includesNetworkingOverhead: false\n};\nfunction assertComputePowerConsistency(gflopsPerWatt, computePowerKw, effectivePflops) {\n    let units = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : MODEL_UNITS;\n    // 1 PFLOP = 1e6 GFLOPS\n    // Power (W) = GFLOPS / (GFLOPS/W) = (effectivePflops * 1e6) / gflopsPerWatt\n    // Power (kW) = Power (W) / 1000\n    // gflopsPerWatt is at system level (includes power conversion, cooling)\n    const expectedKw = effectivePflops * 1e6 / gflopsPerWatt / 1000;\n    const discrepancy = computePowerKw / expectedKw;\n    return {\n        valid: discrepancy > 0.5 && discrepancy < 2.0,\n        ratio: discrepancy,\n        expectedKw,\n        discrepancy\n    };\n}\nconst BASE_SITE_2025 = 1500; // Base site cost in 2025 ($/PFLOP-year)\nfunction calculateGroundTotal(year, params, energyCostBase, hardwareCostBase, isStaticMode, effectiveScenario) {\n    let latencyPenalty = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1.0, smrParams = arguments.length > 7 ? arguments[7] : void 0, firstCapYear = arguments.length > 8 ? arguments[8] : void 0, actualEnergyCostPerPflopYear = arguments.length > 9 ? arguments[9] : void 0, actualElectricityPricePerMwh = arguments.length > 10 ? arguments[10] : void 0;\n    const yearsFromBase = Math.max(0, year - 2025);\n    let siteCostBase = BASE_SITE_2025;\n    const enabled = params.groundConstraintsEnabled && !params.isStaticMode;\n    // SMR Toggle logic\n    const smrEnabled = (smrParams === null || smrParams === void 0 ? void 0 : smrParams.enabled) && year >= (smrParams.smrDeploymentStartYear || 2030);\n    let smrRampFactor = 0;\n    let constraintRelief = {\n        grid: 0,\n        cooling: 0,\n        water: 0,\n        land: 0\n    };\n    if (smrEnabled && smrParams) {\n        const yearsActive = year - smrParams.smrDeploymentStartYear;\n        smrRampFactor = Math.min(1, yearsActive / smrParams.smrRampUpYears);\n        // Apply constraint relief\n        constraintRelief = {\n            grid: smrParams.gridConstraintRelief * smrRampFactor,\n            cooling: smrParams.coolingConstraintRelief * smrRampFactor,\n            water: smrParams.waterConstraintRelief * smrRampFactor,\n            land: smrParams.landConstraintRelief * smrRampFactor\n        };\n        siteCostBase = BASE_SITE_2025 * (1 + (smrParams.smrCapexPremium - 1) * smrRampFactor);\n    }\n    // REFACTORED: Split energy (no multiplier) vs capacity/delivery premium (with multiplier)\n    // \n    // Energy cost: Raw electricity price * kWh (NO constraint multiplier)\n    // - Represents actual market electricity price\n    // - Grows with electricity price trajectory, not infrastructure scarcity\n    const energyCost = actualEnergyCostPerPflopYear !== null && actualEnergyCostPerPflopYear !== void 0 ? actualEnergyCostPerPflopYear : energyCostBase;\n    const effectiveElectricityPrice = actualElectricityPricePerMwh !== null && actualElectricityPricePerMwh !== void 0 ? actualElectricityPricePerMwh : 120;\n    if (!enabled) {\n        // No constraints: all costs at base, no premium\n        const total = (energyCost + siteCostBase + hardwareCostBase) * latencyPenalty;\n        return {\n            energyCost: energyCost * latencyPenalty,\n            siteCost: siteCostBase * latencyPenalty,\n            hardwareCost: hardwareCostBase * latencyPenalty,\n            capacityDeliveryPremium: 0,\n            timeToEnergizePenalty: 0,\n            totalCostPerPflopYear: total,\n            constraintMultiplier: 1.0,\n            breakdown: {\n                grid: 1.0,\n                cooling: 1.0,\n                water: 1.0,\n                land: 1.0,\n                energyMultiplier: 1.0,\n                siteMultiplier: 1.0,\n                capacityDeliveryMultiplier: 1.0\n            },\n            smrEnabled,\n            smrRampFactor,\n            effectiveElectricityCost: effectiveElectricityPrice,\n            constraintRelief\n        };\n    }\n    // CRITICAL FIX: Use queue-derived constraints, NOT time-based exponential\n    // This function is only used when NOT using buildout/queue models (legacy path)\n    // For consistency, use minimal constraints here (base costs only)\n    // Real constraint pricing should come from buildout/queue models\n    // GROUND COST ACCOUNTING: Explicit separation of components (ADDITIVE ONLY)\n    // \n    // 1. siteCapexAmortPerPflopYear: Pure amortized capex\n    //    - Buildings + power delivery inside site + cooling plant\n    //    - Base cost, NOT affected by constraint\n    const siteCapexAmortPerPflopYear = siteCostBase;\n    // 2. capacityDeliveryPremiumPerPflopYear: Scarcity price for firm MW at right place/time\n    //    - Set to zero in legacy path (constraints should come from buildout/queue models)\n    //    - This path is only for backward compatibility\n    const capacityDeliveryPremiumPerPflopYear = 0;\n    // 3. timeToEnergizePenaltyPerPflopYear: Financing cost of waiting (WACC + delay years)\n    //    - Set to zero in legacy path (delay penalties should come from buildout/queue models)\n    //    - This path is only for backward compatibility\n    const timeToEnergizePenaltyPerPflopYear = 0;\n    // CRITICAL: Remove double counting\n    // Do NOT include timeToEnergizePenalty in headline cost used for crossover\n    // (capacity gating in market share already accounts for backlog)\n    // Compute both base and effective costs:\n    const siteCostPerPflopYear_base = siteCapexAmortPerPflopYear + capacityDeliveryPremiumPerPflopYear;\n    const siteCostPerPflopYear_effective = siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + capacityDeliveryPremiumPerPflopYear;\n    // Validation: siteCost_effective must equal sum of components\n    const siteCostCheck = Math.abs(siteCostPerPflopYear_effective - (siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + capacityDeliveryPremiumPerPflopYear));\n    if (siteCostCheck > 0.01) {\n        throw new Error(\"Site cost accounting error: siteCost_effective=\".concat(siteCostPerPflopYear_effective, \" != sum(components)=\").concat(siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + capacityDeliveryPremiumPerPflopYear, \", diff=\").concat(siteCostCheck));\n    }\n    const hardware = hardwareCostBase;\n    // Headline cost for crossover: base only (excludes delay penalty, which is handled via capacity gating)\n    const total = (energyCost + siteCostPerPflopYear_base + hardware) * latencyPenalty;\n    // Effective/all-in cost: includes delay penalty (for reference/debug)\n    const totalEffective = (energyCost + siteCostPerPflopYear_effective + hardware) * latencyPenalty;\n    return {\n        energyCost: energyCost * latencyPenalty,\n        siteCost: siteCostPerPflopYear_base * latencyPenalty,\n        hardwareCost: hardware * latencyPenalty,\n        siteCapexAmortPerPflopYear: siteCapexAmortPerPflopYear * latencyPenalty,\n        capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear * latencyPenalty,\n        timeToEnergizePenalty: timeToEnergizePenaltyPerPflopYear * latencyPenalty,\n        totalCostPerPflopYear: total,\n        totalCostPerPflopYearEffective: totalEffective,\n        constraintMultiplier: 1.0,\n        breakdown: {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        },\n        constraints: {\n            method: \"adders\",\n            capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear * latencyPenalty,\n            delayPenalty: timeToEnergizePenaltyPerPflopYear * latencyPenalty,\n            appliedMultipliers: {\n                constraintMultiplierUsed: false,\n                energyMultiplierUsed: false,\n                siteMultiplierUsed: false\n            },\n            debug: {\n                doubleCountCheck: {\n                    mode: \"adders\",\n                    multiplierApplied: false,\n                    addersApplied: capacityDeliveryPremiumPerPflopYear > 0 || timeToEnergizePenaltyPerPflopYear > 0,\n                    invariantOk: true,\n                    notes: \"calculateGroundTotal uses adders only (capacityDeliveryPremium + timeToEnergizePenalty)\"\n                }\n            }\n        },\n        smrEnabled,\n        smrRampFactor,\n        effectiveElectricityCost: effectiveElectricityPrice,\n        constraintRelief\n    };\n}\nfunction computePhysicsCost(rawParams) {\n    let firstCapYear = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n    var _hybridResult_regulatory, _groundResult_constraints, _groundResult_constraints1, _params_edgeInference, _hybridResult_specificPowerMultipliers, _hybridResult_computePayload, _hybridResult_specificPowerMultipliers1, _groundResult_buildoutDebug, _groundResult_supplyMetrics, _groundResult_supplyMetrics1, _groundResult_supplyMetrics2, _groundResult_buildoutDebug1, _groundResult_supplyMetrics3, _groundResult_buildoutDebug2, _groundResult_buildoutDebug3;\n    const params = applyStaticFreeze(rawParams);\n    const { year, isStaticMode, launchCostKg: baseLaunchCost, specificPowerWKg: trajSpecificPower, groundEffectiveGflopsPerW_2025: rawGroundEffectiveGflopsPerW_2025, orbitEffectiveGflopsPerW_2025: rawOrbitEffectiveGflopsPerW_2025, pueGround, pueOrbital, capacityFactorGround, targetGW, satellitePowerKW, groundConstraintsEnabled, powerGridMultiplier, coolingMultiplier, waterScarcityEnabled, landScarcityEnabled, spaceTrafficEnabled, orbitalAltitude, useRadHardChips, sunFraction, groundScenario, smrMitigationEnabled, workloadType, elonScenarioEnabled, globalLatencyRequirementEnabled, spaceManufacturingEnabled, aiWinterEnabled } = params;\n    var _ref;\n    // CRITICAL FIX: Handle parameter name migration\n    // Old names: flopsPerWattGround, flopsPerWattOrbital (DEPRECATED - delete conversion logic)\n    // New names: groundEffectiveGflopsPerW_2025, orbitEffectiveGflopsPerW_2025\n    // Parameters are ALREADY in GFLOPS/W (not FLOPS/W) - no conversion needed\n    const actualGroundInput = (_ref = rawGroundEffectiveGflopsPerW_2025 !== null && rawGroundEffectiveGflopsPerW_2025 !== void 0 ? rawGroundEffectiveGflopsPerW_2025 : params.gflopsPerWattGround2025) !== null && _ref !== void 0 ? _ref : params.flopsPerWattGround;\n    var _ref1;\n    const actualOrbitInput = (_ref1 = rawOrbitEffectiveGflopsPerW_2025 !== null && rawOrbitEffectiveGflopsPerW_2025 !== void 0 ? rawOrbitEffectiveGflopsPerW_2025 : params.gflopsPerWattOrbital2025) !== null && _ref1 !== void 0 ? _ref1 : params.flopsPerWattOrbital;\n    // CANONICAL COMPUTE EFFICIENCY: Single source of truth for GFLOPS/W\n    // Parameter is interpreted as GFLOPS/W (not FLOPS/W) - no 1e9/1e12 conversions\n    let groundEfficiencyResult;\n    let orbitalEfficiencyResult;\n    // Ground: Use canonical ComputeEfficiency function\n    // CRITICAL FIX: Parameter is ALREADY in GFLOPS/W (not FLOPS/W)\n    // No unit conversion - treat input as effective GFLOPS/W directly\n    if (!actualGroundInput || !isFinite(actualGroundInput) || actualGroundInput <= 0) {\n        // Invalid input - use default\n        groundEfficiencyResult = (0,_compute_efficiency__WEBPACK_IMPORTED_MODULE_8__.getDefaultComputeEfficiency)(\"NVIDIA H100 SXM\", year, \"FP16\");\n    } else {\n        // Input is effective GFLOPS/W - derive chip peak assuming standard factors\n        // effective = chipPeak * utilization / systemOverhead\n        // So: chipPeak = effective * systemOverhead / utilization\n        const systemOverheadFactor = 1.18; // PUE 1.18 equivalent\n        const utilizationFactor = 0.70;\n        const chipPeakGflopsPerW = actualGroundInput * systemOverheadFactor / utilizationFactor;\n        // FAIL-FAST INVARIANT: Chip peak must be in realistic range [1, 20000] GFLOPS/W\n        if (chipPeakGflopsPerW < 1 || chipPeakGflopsPerW > 20000) {\n            throw new Error(\"GROUND COMPUTE EFFICIENCY UNIT MISMATCH: \" + \"chipPeakGflopsPerW=\".concat(chipPeakGflopsPerW.toFixed(2), \" is outside valid range [1, 20000] GFLOPS/W. \") + \"Input: actualGroundInput=\".concat(actualGroundInput, \", \") + \"This suggests a units error. Expected range: 30-5000 GFLOPS/W for system-level efficiency.\");\n        }\n        groundEfficiencyResult = (0,_compute_efficiency__WEBPACK_IMPORTED_MODULE_8__.ComputeEfficiency)({\n            chipPeakGflopsPerW,\n            utilizationFactor,\n            systemOverheadFactor\n        });\n        // FAIL-FAST INVARIANT: Effective GFLOPS/W must be in realistic range [1, 5000] GFLOPS/W\n        if (groundEfficiencyResult.effectiveGflopsPerW < 1 || groundEfficiencyResult.effectiveGflopsPerW > 5000) {\n            throw new Error(\"GROUND COMPUTE EFFICIENCY OUT OF RANGE: \" + \"effectiveGflopsPerW=\".concat(groundEfficiencyResult.effectiveGflopsPerW.toFixed(2), \" is outside valid range [1, 5000] GFLOPS/W. \") + \"Input: actualGroundInput=\".concat(actualGroundInput, \", \") + \"chipPeakGflopsPerW=\".concat(chipPeakGflopsPerW.toFixed(2), \". \") + \"This suggests a units error or invalid input.\");\n        }\n    }\n    // Orbital: Same logic - parameter is ALREADY in GFLOPS/W (not FLOPS/W)\n    // No unit conversion - treat input as effective GFLOPS/W directly\n    if (!actualOrbitInput || !isFinite(actualOrbitInput) || actualOrbitInput <= 0) {\n        // Invalid input - use default\n        orbitalEfficiencyResult = (0,_compute_efficiency__WEBPACK_IMPORTED_MODULE_8__.getDefaultComputeEfficiency)(\"H100-equivalent (rad-tolerant)\", year, \"FP16\");\n    } else {\n        // Input is effective GFLOPS/W - derive chip peak\n        const systemOverheadFactor = 1.18;\n        const utilizationFactor = 0.65;\n        const chipPeakGflopsPerW = actualOrbitInput * systemOverheadFactor / utilizationFactor;\n        // FAIL-FAST INVARIANT: Chip peak must be in realistic range [1, 20000] GFLOPS/W\n        if (chipPeakGflopsPerW < 1 || chipPeakGflopsPerW > 20000) {\n            throw new Error(\"ORBITAL COMPUTE EFFICIENCY UNIT MISMATCH: \" + \"chipPeakGflopsPerW=\".concat(chipPeakGflopsPerW.toFixed(2), \" is outside valid range [1, 20000] GFLOPS/W. \") + \"Input: actualOrbitInput=\".concat(actualOrbitInput, \", \") + \"This suggests a units error. Expected range: 25-4000 GFLOPS/W for system-level efficiency.\");\n        }\n        orbitalEfficiencyResult = (0,_compute_efficiency__WEBPACK_IMPORTED_MODULE_8__.ComputeEfficiency)({\n            chipPeakGflopsPerW,\n            utilizationFactor,\n            systemOverheadFactor\n        });\n        // FAIL-FAST INVARIANT: Effective GFLOPS/W must be in realistic range [1, 5000] GFLOPS/W\n        if (orbitalEfficiencyResult.effectiveGflopsPerW < 1 || orbitalEfficiencyResult.effectiveGflopsPerW > 5000) {\n            throw new Error(\"ORBITAL COMPUTE EFFICIENCY OUT OF RANGE: \" + \"effectiveGflopsPerW=\".concat(orbitalEfficiencyResult.effectiveGflopsPerW.toFixed(2), \" is outside valid range [1, 5000] GFLOPS/W. \") + \"Input: actualOrbitInput=\".concat(actualOrbitInput, \", \") + \"chipPeakGflopsPerW=\".concat(chipPeakGflopsPerW.toFixed(2), \". \") + \"This suggests a units error or invalid input.\");\n        }\n    }\n    // HARD ASSERT: Ground efficiency must always be populated and finite\n    if (!groundEfficiencyResult || !isFinite(groundEfficiencyResult.effectiveGflopsPerW) || groundEfficiencyResult.effectiveGflopsPerW <= 0) {\n        throw new Error(\"CRITICAL: Ground compute efficiency is invalid. \" + \"actualGroundInput=\".concat(actualGroundInput, \", \") + \"rawGroundEffectiveGflopsPerW_2025=\".concat(rawGroundEffectiveGflopsPerW_2025, \", \") + \"gflopsPerWattGround2025=\".concat(params.gflopsPerWattGround2025, \", \") + \"groundEfficiencyResult=\".concat(JSON.stringify(groundEfficiencyResult)));\n    }\n    // CRITICAL FIX: Standardize compute-efficiency level definitions\n    // Standard definitions:\n    // - peakGflopsPerWatt: chip peak (no utilization, no overhead, no derates)\n    // - systemEffectiveGflopsPerWatt: peak * utilization / systemOverheadFactor (SYSTEM-LEVEL EFFECTIVE)\n    // - deliveredGflopsPerWatt: systemEffective * thermalCapFactor * radiationDerate * availability\n    // Ground: systemEffective only (no delivery derates)\n    const groundEffectiveGflopsPerW = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(groundEfficiencyResult.effectiveGflopsPerW, \"ground efficiency calculation\");\n    // Orbital: Track all three levels\n    const orbitPeakGflopsPerWatt = orbitalEfficiencyResult.debug.chipPeakGflopsPerW;\n    const orbitSystemEffectiveGflopsPerWatt = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(orbitalEfficiencyResult.effectiveGflopsPerW, \"orbital systemEffective efficiency calculation\");\n    // NOTE: deliveredGflopsPerWatt will be calculated after thermal system is computed\n    // It will be: systemEffective * thermalCapFactor * radiationDerate * availability\n    // AI Winter: Constraints grow 50% slower\n    const effectiveGroundScenario = aiWinterEnabled && year >= 2028 ? {\n        ...GROUND_SCENARIOS[groundScenario],\n        gridGrowthRate: GROUND_SCENARIOS[groundScenario].gridGrowthRate * 0.5,\n        coolingGrowthRate: GROUND_SCENARIOS[groundScenario].coolingGrowthRate * 0.5,\n        waterGrowthRate: GROUND_SCENARIOS[groundScenario].waterGrowthRate * 0.5,\n        landGrowthRate: GROUND_SCENARIOS[groundScenario].landGrowthRate * 0.5\n    } : GROUND_SCENARIOS[groundScenario];\n    // Elon Scenario: Discounts\n    const launchDiscount = elonScenarioEnabled ? 0.50 : 1.0;\n    const powerDiscount = elonScenarioEnabled ? 0.70 : 1.0;\n    const networkingDiscount = elonScenarioEnabled ? 0.10 : 1.0;\n    const operatorMargin = elonScenarioEnabled ? 0.05 : 0.20;\n    // Global Latency: 3x ground overprovisioning penalty\n    const groundLatencyPenalty = globalLatencyRequirementEnabled && year >= 2028 ? 3.0 : 1.0;\n    // Space Manufacturing: Mass reduction\n    let massMultiplier = 1.0;\n    if (spaceManufacturingEnabled && year >= 2032) {\n        const yearsSinceStart = year - 2032;\n        const ramp = Math.min(1.0, yearsSinceStart / 5);\n        massMultiplier = 1.0 - 0.60 * ramp;\n    }\n    // EMERGENCY FIX: Use simple fixed 2025 base values\n    // These are the known-correct values from the emergency fix\n    // Don't try to calculate from flopsPerWatt - just use these constants\n    const BASE_ENERGY_2025 = 581; // $/PFLOP-year (fixed 2025 base)\n    const BASE_SITE_2025 = 1500; // $/PFLOP-year (fixed 2025 base)\n    const ENERGY_COST_BASE_2025 = BASE_ENERGY_2025; // Use fixed base, not calculated\n    // For reference/display (not used in constraint calculation)\n    const BASE_ELECTRICITY_PRICE_2025 = 120; // $/MWh (2025 baseline)\n    let groundElectricityPricePerMwh = BASE_ELECTRICITY_PRICE_2025;\n    if (!params.isStaticMode) {\n        groundElectricityPricePerMwh *= Math.pow(1.02, year - 2025);\n    }\n    const effectivePueGround = pueGround + (year - 2025) * 0.01;\n    // Convert GFLOPS/W to power: 1 PFLOP = 1e6 GFLOPS, so power (W) = (1e6 GFLOPS) / (GFLOPS/W)\n    const groundEnergyMWhPerPflopYear = 8760 * 1e6 / groundEffectiveGflopsPerW * effectivePueGround / 1e6;\n    const groundEnergyCostPerPflopYear = groundEnergyMWhPerPflopYear * groundElectricityPricePerMwh * capacityFactorGround;\n    const computeGroundHardwareCost = (y, baseCost)=>{\n        const yearIndex = y - 2025;\n        let cost = baseCost;\n        for(let i = 0; i < yearIndex; i++){\n            let annualDecline;\n            if (i < 3) annualDecline = 0.10;\n            else if (i < 6) annualDecline = 0.05;\n            else if (i < 10) annualDecline = 0.02;\n            else annualDecline = 0.005;\n            cost *= 1 - annualDecline;\n        }\n        return cost;\n    };\n    var _params_groundHardwareLifetimeYears;\n    const groundLifetime = (_params_groundHardwareLifetimeYears = params.groundHardwareLifetimeYears) !== null && _params_groundHardwareLifetimeYears !== void 0 ? _params_groundHardwareLifetimeYears : CONSTANTS.GROUND_HARDWARE_LIFETIME;\n    const groundHardwareCapexPerPflopYear = computeGroundHardwareCost(year, CONSTANTS.GROUND_HARDWARE_COST_PFLOP_2025) / groundLifetime;\n    const smrParams = params.smrToggleEnabled ? params.smrToggleParams || DEFAULT_SMR_PARAMS : undefined;\n    let groundResult;\n    let groundTotalCost;\n    let groundComparatorCostPerPflopYear; // Comparator cost for crossover (uses effective when queue exists)\n    let groundHasQueue = false; // Track if ground has queue/backlog (for debug and comparator cost)\n    let energyConstraintMultiplier;\n    let constraintBreakdown;\n    const useRegionalModel = params.useRegionalGroundModel === true && params.groundConstraintsEnabled && !params.isStaticMode;\n    // FIX: Make buildout model the default (it correctly uses responsive demand)\n    // Queue model requires full demand trajectory to work correctly, so it's opt-in only\n    // Only use queue model if explicitly enabled (useQueueBasedConstraint === true)\n    const useQueueModel = params.useQueueBasedConstraint === true && params.groundConstraintsEnabled && !params.isStaticMode && !useRegionalModel;\n    // Buildout model is the default (defaults to true unless explicitly disabled)\n    const useBuildoutModel = params.useBuildoutModel !== false && params.groundConstraintsEnabled && !params.isStaticMode && !useRegionalModel && !useQueueModel;\n    if (useQueueModel) {\n        // WARNING: Queue model requires full demand trajectory to work correctly\n        // Currently only receives current year's responsive demand, so previous years use hardcoded demand\n        // RECOMMENDED: Use buildout model instead (default) which correctly handles responsive demand\n        if (true) {\n            console.warn(\"[QUEUE MODEL] Year \".concat(year, \": Queue model is enabled but only receives current year's responsive demand. \") + \"Previous years (2025-\".concat(year - 1, \") will use hardcoded exponential demand. \") + \"For accurate S-curve behavior, use buildout model (default) instead.\");\n        }\n        // Pass responsive demand and orbital substitution to queue model (if available from trajectory.ts)\n        const responsiveDemandGW = params.responsiveDemandGW;\n        const orbitalSubstitutionGW = params.orbitalSubstitutionGW;\n        // Build demand map if responsive demand is provided\n        // NOTE: Only current year is passed - previous years will use hardcoded demand\n        const demandByYear = responsiveDemandGW !== undefined ? new Map([\n            [\n                year,\n                responsiveDemandGW\n            ]\n        ]) : undefined;\n        const orbitalSubstitutionByYear = orbitalSubstitutionGW !== undefined ? new Map([\n            [\n                year,\n                orbitalSubstitutionGW\n            ]\n        ]) : undefined;\n        const supplyTrajectory = (0,_ground_queue_model__WEBPACK_IMPORTED_MODULE_4__.generateGroundSupplyTrajectory)(2025, year, demandByYear, orbitalSubstitutionByYear);\n        const currentSupplyState = supplyTrajectory[supplyTrajectory.length - 1];\n        // Debug: Log if responsive demand is being used\n        if ( true && responsiveDemandGW !== undefined) {\n            const hardcodedDemand = (0,_ground_queue_model__WEBPACK_IMPORTED_MODULE_4__.getGlobalDemandGw)(year);\n            if (Math.abs(currentSupplyState.demandGw - hardcodedDemand) < 1e-6) {\n                console.warn(\"[QUEUE MODEL DEBUG] Year \".concat(year, \": Responsive demand (\").concat(responsiveDemandGW.toFixed(2), \" GW) was ignored. \") + \"Queue model using hardcoded: \".concat(currentSupplyState.demandGw.toFixed(2), \" GW\"));\n            } else {\n                console.log(\"[QUEUE MODEL DEBUG] Year \".concat(year, \": Using responsive demand \").concat(responsiveDemandGW.toFixed(2), \" GW \") + \"(queue model: \".concat(currentSupplyState.demandGw.toFixed(2), \" GW)\"));\n            }\n        }\n        var _params_wacc, _params_waccBacklogK, _params_waccBacklogExponent, _params_criticalBacklogGW;\n        // Calculate WACC-based penalties and multipliers\n        // Pass WACC parameters for capital rationing (WACC rises with backlog)\n        const waccParams = {\n            baseWacc: (_params_wacc = params.wacc) !== null && _params_wacc !== void 0 ? _params_wacc : 0.10,\n            waccBacklogK: (_params_waccBacklogK = params.waccBacklogK) !== null && _params_waccBacklogK !== void 0 ? _params_waccBacklogK : 0.5,\n            waccBacklogExponent: (_params_waccBacklogExponent = params.waccBacklogExponent) !== null && _params_waccBacklogExponent !== void 0 ? _params_waccBacklogExponent : 1.2,\n            criticalBacklogGW: (_params_criticalBacklogGW = params.criticalBacklogGW) !== null && _params_criticalBacklogGW !== void 0 ? _params_criticalBacklogGW : 50\n        };\n        const penalties = (0,_ground_constraint_penalties__WEBPACK_IMPORTED_MODULE_5__.calculateGroundConstraintPenalties)(currentSupplyState, groundEffectiveGflopsPerW, effectivePueGround, capacityFactorGround, waccParams);\n        const BASE_SITE_2025 = 1500;\n        // Energy cost: Use actual calculated value (NOT multiplied by constraint)\n        // CRITICAL FIX: Do NOT apply PUE multiplier - energy cost is base only\n        // PUE stress should be reflected in capacityDeliveryPremium, not energy multiplier\n        const energyCostBase = groundEnergyCostPerPflopYear;\n        const energyCost = energyCostBase; // Base energy cost only - no multiplier\n        // GROUND COST ACCOUNTING: Explicit separation of components (queue model)\n        const siteCostBase = BASE_SITE_2025;\n        // 1. siteCapexAmortPerPflopYear: Pure amortized capex (NOT affected by constraint)\n        const siteCapexAmortPerPflopYear = siteCostBase;\n        // CHOICE: Use delayPenalty + scarcityRent (Hill-based), NOT capacityDeliveryPremium\n        // Set capacityDeliveryPremium to 0 to avoid triple-charging\n        const capacityDeliveryPremiumPerPflopYear = 0; // NOT USED - using delayPenalty + scarcityRent instead\n        // 1. timeToEnergizePenaltyPerPflopYear: Bounded linear WACC carry (NOT exponential)\n        const timeToEnergizePenaltyPerPflopYear = penalties.timeToEnergizePenaltyPerPflopYear;\n        // 2. scarcityRentPerPflopYear: Hill function of avgWaitYears (w50=2.0, n=2.0, rentMax=0.65)\n        // Base cost for scarcity rent = hardware + site (no capacityDeliveryPremium)\n        const capexAnnualBasePerPflopYear = groundHardwareCapexPerPflopYear + siteCapexAmortPerPflopYear;\n        // Calculate scarcity multiplier using LOG-BASED function (never fully saturates)\n        // Returns multiplier (1.0 = no scarcity, 2.0 = 2x price) - MULTIPLICATIVE, not additive\n        const scarcityRentResult = (0,_ground_constraint_penalties__WEBPACK_IMPORTED_MODULE_5__.calculateScarcityRent)(currentSupplyState.avgWaitYears, currentSupplyState.utilizationPct, {\n            waitThresholdYears: 1.0,\n            rentMaxMultiplier: 2.0,\n            utilizationThreshold: 0.85\n        });\n        const scarcityMultiplier = scarcityRentResult.scarcityMultiplier;\n        // For backward compatibility: scarcityRentPerPflopYear = 0 (scarcity is now multiplicative)\n        const scarcityRentPerPflopYear = 0;\n        // Debug: verify queue model consistency\n        if (true) {\n            var _currentSupplyState_unservedGw;\n            const unservedGw = (_currentSupplyState_unservedGw = currentSupplyState.unservedGw) !== null && _currentSupplyState_unservedGw !== void 0 ? _currentSupplyState_unservedGw : currentSupplyState.demandGw - currentSupplyState.capacityGw;\n            if (currentSupplyState.demandGw < currentSupplyState.capacityGw && currentSupplyState.backlogGw > 50) {\n                console.warn(\"[QUEUE MODEL] Year \".concat(year, \": demandGw=\").concat(currentSupplyState.demandGw.toFixed(1), \" < capacityGw=\").concat(currentSupplyState.capacityGw.toFixed(1), \" \") + \"but backlogGw=\".concat(currentSupplyState.backlogGw.toFixed(1), \" > 50. This may indicate queue model issue.\"));\n            }\n        }\n        // CRITICAL: Remove double counting\n        // Do NOT include timeToEnergizePenalty + scarcityRent in headline cost used for crossover\n        // (capacity gating in market share already accounts for backlog)\n        // Compute both base and effective costs:\n        const siteCostPerPflopYear_base = siteCapexAmortPerPflopYear; // No capacityDeliveryPremium\n        const siteCostPerPflopYear_effective = siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + scarcityRentPerPflopYear;\n        // Validation\n        const expectedEffective = siteCapexAmortPerPflopYear + capacityDeliveryPremiumPerPflopYear + timeToEnergizePenaltyPerPflopYear + scarcityRentPerPflopYear;\n        const siteCostCheck = Math.abs(siteCostPerPflopYear_effective - expectedEffective);\n        if (siteCostCheck > 0.01) {\n            throw new Error(\"Site cost accounting error (queue model): siteCost_effective=\".concat(siteCostPerPflopYear_effective, \" != sum(components)=\").concat(expectedEffective, \" (siteCapex=\").concat(siteCapexAmortPerPflopYear, \", premium=\").concat(capacityDeliveryPremiumPerPflopYear, \", delay=\").concat(timeToEnergizePenaltyPerPflopYear, \", scarcity=\").concat(scarcityRentPerPflopYear, \"), diff=\").concat(siteCostCheck));\n        }\n        const hardwareCost = groundHardwareCapexPerPflopYear;\n        // UNIFIED SCARCITY ACCOUNTING: Keep totalCostPerPflopYear physical-only\n        // Scarcity (delayPenalty + scarcityRent) is treated purely in GPU-hour pricing, not in PFLOP-year cost\n        groundTotalCost = (energyCost + siteCostPerPflopYear_base + hardwareCost) * groundLatencyPenalty;\n        // For crossover: use base cost (scarcity is already reflected in GPU-hour pricing)\n        // This ensures we don't double-count scarcity\n        groundHasQueue = timeToEnergizePenaltyPerPflopYear > 0.01;\n        groundComparatorCostPerPflopYear = groundTotalCost; // Base cost only (scarcity in GPU-hour)\n        // CRITICAL FIX: Remove all multipliers - use additive terms only\n        // Multipliers are NOT applied to any dollar amounts\n        // All constraint effects are captured in capacityDeliveryPremium and timeToEnergizePenalty\n        energyConstraintMultiplier = 1.0; // Never applied - for backward compat only\n        // Constraint breakdown: all multipliers set to 1.0 (not applied)\n        // These are kept for debug/decomposition but never multiplied into costs\n        constraintBreakdown = {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        };\n        var _currentSupplyState_avgWaitYearsRaw, _currentSupplyState_unservedGw1, _currentSupplyState_deliveredFromBacklogGw, _currentSupplyState_unservedGw2, _currentSupplyState_deliveredFromBacklogGw1, _currentSupplyState_avgWaitYearsRaw1;\n        groundResult = {\n            energyCost: energyCost * groundLatencyPenalty,\n            siteCost: siteCostPerPflopYear_base * groundLatencyPenalty,\n            hardwareCost: hardwareCost * groundLatencyPenalty,\n            siteCapexAmortPerPflopYear: siteCapexAmortPerPflopYear * groundLatencyPenalty,\n            capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear * groundLatencyPenalty,\n            timeToEnergizePenalty: timeToEnergizePenaltyPerPflopYear * groundLatencyPenalty,\n            totalCostPerPflopYear: groundTotalCost,\n            totalCostPerPflopYearEffective: groundTotalCost,\n            totalCostPerPflopYearAllIn: groundTotalCost,\n            constraintMultiplier: 1.0,\n            breakdown: constraintBreakdown,\n            constraints: {\n                method: \"adders\",\n                capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear * groundLatencyPenalty,\n                delayPenalty: timeToEnergizePenaltyPerPflopYear * groundLatencyPenalty,\n                scarcityRentPerPflopYear: scarcityRentPerPflopYear * groundLatencyPenalty,\n                scarcityMultiplier: scarcityMultiplier,\n                appliedMultipliers: {\n                    constraintMultiplierUsed: false,\n                    energyMultiplierUsed: false,\n                    siteMultiplierUsed: false\n                },\n                // Debug fields for Hill-based scarcity rent (wait-time based)\n                scarcityHill: scarcityRentResult.scarcityHill,\n                avgWaitYearsRaw: (_currentSupplyState_avgWaitYearsRaw = currentSupplyState.avgWaitYearsRaw) !== null && _currentSupplyState_avgWaitYearsRaw !== void 0 ? _currentSupplyState_avgWaitYearsRaw : currentSupplyState.avgWaitYears,\n                avgWaitYearsClamped: scarcityRentResult.avgWaitYearsClamped,\n                rentFrac: scarcityRentResult.rentFrac,\n                // Additional debug fields for verification\n                backlogGw: currentSupplyState.backlogGw,\n                unservedGw: (_currentSupplyState_unservedGw1 = currentSupplyState.unservedGw) !== null && _currentSupplyState_unservedGw1 !== void 0 ? _currentSupplyState_unservedGw1 : 0,\n                deliveredFromBacklogGw: (_currentSupplyState_deliveredFromBacklogGw = currentSupplyState.deliveredFromBacklogGw) !== null && _currentSupplyState_deliveredFromBacklogGw !== void 0 ? _currentSupplyState_deliveredFromBacklogGw : 0,\n                baseCostPerPflopYear: capexAnnualBasePerPflopYear * groundLatencyPenalty,\n                totalCostPerPflopYear: groundTotalCost\n            },\n            supplyMetrics: {\n                demandGw: currentSupplyState.demandGw,\n                capacityGw: currentSupplyState.capacityGw,\n                pipelineGw: currentSupplyState.pipelineGw,\n                maxBuildRateGwYear: currentSupplyState.maxBuildRateGwYear,\n                avgWaitYears: currentSupplyState.avgWaitYears,\n                utilizationPct: currentSupplyState.utilizationPct,\n                // Debug fields for queue model verification\n                backlogGw: currentSupplyState.backlogGw,\n                unservedGw: (_currentSupplyState_unservedGw2 = currentSupplyState.unservedGw) !== null && _currentSupplyState_unservedGw2 !== void 0 ? _currentSupplyState_unservedGw2 : 0,\n                deliveredFromBacklogGw: (_currentSupplyState_deliveredFromBacklogGw1 = currentSupplyState.deliveredFromBacklogGw) !== null && _currentSupplyState_deliveredFromBacklogGw1 !== void 0 ? _currentSupplyState_deliveredFromBacklogGw1 : 0,\n                avgWaitYearsRaw: (_currentSupplyState_avgWaitYearsRaw1 = currentSupplyState.avgWaitYearsRaw) !== null && _currentSupplyState_avgWaitYearsRaw1 !== void 0 ? _currentSupplyState_avgWaitYearsRaw1 : currentSupplyState.avgWaitYears\n            },\n            constraintComponents: {\n                queuePressure: currentSupplyState.avgWaitYears > 0 ? 1 + currentSupplyState.avgWaitYears / 2 : 1,\n                utilizationPressure: currentSupplyState.utilizationPct > 0.85 ? 1 + (currentSupplyState.utilizationPct - 0.85) * 5 : 1,\n                scarcityPremium: penalties.siteMultiplier\n            },\n            // Debug fields for WACC penalties\n            backlogGw: penalties.backlogGw,\n            avgWaitYears: penalties.avgWaitYears,\n            capexAtRiskPerMW: penalties.capexAtRiskPerMW,\n            carryCostPerMW: penalties.carryCostPerMW,\n            lostMarginPerMW: penalties.lostMarginPerMW,\n            timeToEnergizePenaltyPerPflopYear: penalties.timeToEnergizePenaltyPerPflopYear,\n            pueMultiplier: penalties.pueMultiplier,\n            smrEnabled: false,\n            smrRampFactor: 0,\n            effectiveElectricityCost: groundElectricityPricePerMwh,\n            constraintRelief: {\n                grid: 0,\n                cooling: 0,\n                water: 0,\n                land: 0\n            }\n        };\n    } else if (useBuildoutModel) {\n        var _groundResult_buildoutDebug4;\n        // NEW: Ramping Mobilization Model\n        // Replaces constraint multiplier with explicit buildout capex premium and delay penalties\n        // Uses ramping buildout capacity with smooth interpolation\n        // Get mobilization parameters (use defaults if not provided)\n        const mobilizationParams = params.mobilizationParams ? {\n            ..._ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_MOBILIZATION_PARAMS,\n            ...params.mobilizationParams,\n            demandCurve: params.mobilizationParams.demandCurve || _ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_MOBILIZATION_PARAMS.demandCurve\n        } : _ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_MOBILIZATION_PARAMS;\n        var _params_prevMobilizationState;\n        // Get previous mobilization state from params (passed from trajectory)\n        // If not provided, calculate from previous year's demand\n        const prevMobilizationState = (_params_prevMobilizationState = params.prevMobilizationState) !== null && _params_prevMobilizationState !== void 0 ? _params_prevMobilizationState : null;\n        // Step mobilization state forward\n        // Pass responsive demand and orbital substitution if available (from trajectory.ts)\n        const responsiveDemandGW = params.responsiveDemandGW;\n        const orbitalSubstitutionGW = params.orbitalSubstitutionGW;\n        const mobilizationResult = (0,_ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__.stepMobilizationState)(prevMobilizationState, mobilizationParams, year, effectivePueGround, 0, orbitalSubstitutionGW, responsiveDemandGW // Pass responsive demand (overrides hardcoded)\n        );\n        // Extract values from mobilization model\n        const demandNewGW = mobilizationResult.demandNewGW;\n        const buildRateGWyr = mobilizationResult.buildRateGWyr;\n        const buildableGW = buildRateGWyr; // buildable = build rate\n        const capacityGW = mobilizationResult.capacityGW;\n        const pipelineGW = mobilizationResult.pipelineGW;\n        const backlogGW = mobilizationResult.backlogGW;\n        const avgWaitYears = mobilizationResult.avgWaitYears;\n        var _params_wacc1;\n        // Default buildout parameters\n        const baseWacc = (_params_wacc1 = params.wacc) !== null && _params_wacc1 !== void 0 ? _params_wacc1 : 0.10; // 10% base WACC\n        const PROJECT_LIFETIME = 20; // 20 years\n        const BUILDOUT_CAPEX_BASE = 2000; // $2k/kW base buildout capex (reduced from 3k)\n        const DEFAULT_SCARCITY_CURVE = {\n            k: 2.0,\n            exponent: 1.7,\n            thresholdUtil: 0.0\n        };\n        const PANIC_EXPONENT = 1.3; // Exponent for delay penalty panic regime\n        var _params_waccBacklogK1;\n        // Compute effective WACC (rises with backlog - capital rationing)\n        const waccBacklogK = (_params_waccBacklogK1 = params.waccBacklogK) !== null && _params_waccBacklogK1 !== void 0 ? _params_waccBacklogK1 : 0.5;\n        var _params_waccBacklogExponent1;\n        const waccBacklogExponent = (_params_waccBacklogExponent1 = params.waccBacklogExponent) !== null && _params_waccBacklogExponent1 !== void 0 ? _params_waccBacklogExponent1 : 1.2;\n        var _params_criticalBacklogGW1;\n        const criticalBacklogGW = (_params_criticalBacklogGW1 = params.criticalBacklogGW) !== null && _params_criticalBacklogGW1 !== void 0 ? _params_criticalBacklogGW1 : 50;\n        const backlogRatio = Math.max(0, backlogGW / criticalBacklogGW);\n        const waccMultiplier = 1 + waccBacklogK * Math.pow(backlogRatio, waccBacklogExponent);\n        const waccEffective = baseWacc * waccMultiplier;\n        var _params_buildoutProjectLifetimeYears, _params_valueOfTimeMode, _params_buildoutCapexBase_$PerkW, _params_buildoutCapexScarcityCurve, _params_buildoutPanicExponent, _params_buildoutHybridWeights;\n        // Calculate buildout constraints\n        const buildoutParams = {\n            demandNewGWByYear: demandNewGW,\n            buildableGWByYear: buildableGW,\n            backlogGW: backlogGW,\n            avgWaitYears: avgWaitYears,\n            baseEnergyPricePerMwhByYear: groundElectricityPricePerMwh,\n            pueGroundByYear: effectivePueGround,\n            wacc: waccEffective,\n            projectLifetimeYears: (_params_buildoutProjectLifetimeYears = params.buildoutProjectLifetimeYears) !== null && _params_buildoutProjectLifetimeYears !== void 0 ? _params_buildoutProjectLifetimeYears : PROJECT_LIFETIME,\n            valueOfTimeMode: (_params_valueOfTimeMode = params.valueOfTimeMode) !== null && _params_valueOfTimeMode !== void 0 ? _params_valueOfTimeMode : \"wacc_on_capex\",\n            buildoutCapexBase_$PerkW: (_params_buildoutCapexBase_$PerkW = params.buildoutCapexBase_$PerkW) !== null && _params_buildoutCapexBase_$PerkW !== void 0 ? _params_buildoutCapexBase_$PerkW : BUILDOUT_CAPEX_BASE,\n            buildoutCapexScarcityCurve: (_params_buildoutCapexScarcityCurve = params.buildoutCapexScarcityCurve) !== null && _params_buildoutCapexScarcityCurve !== void 0 ? _params_buildoutCapexScarcityCurve : DEFAULT_SCARCITY_CURVE,\n            panicExponent: (_params_buildoutPanicExponent = params.buildoutPanicExponent) !== null && _params_buildoutPanicExponent !== void 0 ? _params_buildoutPanicExponent : PANIC_EXPONENT,\n            hardwareCapexPerPflopYear: groundHardwareCapexPerPflopYear,\n            siteCapexAmortPerPflopYear: BASE_SITE_2025,\n            // Legacy fields (kept for backward compat, but not used in new calculation)\n            computeHardwareCapex: groundHardwareCapexPerPflopYear * (groundEffectiveGflopsPerW * capacityFactorGround / effectivePueGround / 1e6),\n            siteCapex: BASE_SITE_2025 * (groundEffectiveGflopsPerW * capacityFactorGround / effectivePueGround / 1e6),\n            marginPerGpuHour: 0.5,\n            annualGpuHoursDelivered: 8760 * capacityFactorGround,\n            hybridWeights: (_params_buildoutHybridWeights = params.buildoutHybridWeights) !== null && _params_buildoutHybridWeights !== void 0 ? _params_buildoutHybridWeights : {\n                waccWeight: 0.5,\n                marginWeight: 0.5\n            }\n        };\n        const buildoutResult = (0,_ground_buildout__WEBPACK_IMPORTED_MODULE_6__.calculateBuildoutConstraints)(null, buildoutParams, year, groundEffectiveGflopsPerW, effectivePueGround, capacityFactorGround);\n        // Energy cost: base energy only (NOT affected by buildout constraints)\n        const energyCost = groundEnergyCostPerPflopYear;\n        // Site cost: base capex + buildout premium (engineering cost only, not scarcity pricing)\n        const siteCapexAmortPerPflopYear = BASE_SITE_2025;\n        const buildoutPremiumPerPflopYear = buildoutResult.buildoutPremiumPerPflopYear; // Base engineering cost only\n        const delayPenaltyPerPflopYear = buildoutResult.delayPenaltyPerPflopYear; // Linear: WACC * capex * waitYears\n        // CRITICAL: Wait-time-based scarcity rent (EARLY, SATURATING)\n        // Define annualized capex base for scarcity rent calculation\n        const capexAnnualBasePerPflopYear = groundHardwareCapexPerPflopYear + siteCapexAmortPerPflopYear + buildoutPremiumPerPflopYear; // Include buildout premium as true engineering capex\n        // Calculate scarcity multiplier using LOG-BASED function (never fully saturates)\n        // Returns multiplier (1.0 = no scarcity, 2.0 = 2x price) - MULTIPLICATIVE, not additive\n        const utilizationPct = capacityGW > 0 ? Math.min(1.0, demandNewGW / capacityGW) : 1.0;\n        var _params_scarcityRentWaitThresholdYears, _params_scarcityRentMaxMultiplier;\n        const scarcityRentResult = (0,_ground_constraint_penalties__WEBPACK_IMPORTED_MODULE_5__.calculateScarcityRent)(avgWaitYears, utilizationPct, {\n            waitThresholdYears: (_params_scarcityRentWaitThresholdYears = params.scarcityRentWaitThresholdYears) !== null && _params_scarcityRentWaitThresholdYears !== void 0 ? _params_scarcityRentWaitThresholdYears : 1.0,\n            rentMaxMultiplier: (_params_scarcityRentMaxMultiplier = params.scarcityRentMaxMultiplier) !== null && _params_scarcityRentMaxMultiplier !== void 0 ? _params_scarcityRentMaxMultiplier : 2.0,\n            utilizationThreshold: 0.85\n        });\n        const scarcityMultiplier = scarcityRentResult.scarcityMultiplier;\n        // For backward compatibility: scarcityRentPerPflopYear = 0 (scarcity is now multiplicative)\n        const scarcityRentPerPflopYear = 0;\n        // Define three totals:\n        // 1. base: energy + siteCapexAmort + buildoutPremium + hardware (no scarcity pricing)\n        // 2. effective: includes delayPenalty + scarcityRent (used for crossover)\n        // 3. headline: same as base (for backward compatibility)\n        const siteCostPerPflopYear_base = siteCapexAmortPerPflopYear + buildoutPremiumPerPflopYear;\n        const siteCostPerPflopYear_effective = siteCapexAmortPerPflopYear + buildoutPremiumPerPflopYear + delayPenaltyPerPflopYear + scarcityRentPerPflopYear;\n        // Validation: ensure no double counting\n        if (params.useQueueBasedConstraint !== false) {\n            console.warn(\"[BUILDOUT] useQueueBasedConstraint should be false when useBuildoutModel is true to avoid double counting\");\n        }\n        // Double counting guardrails: ensure constraintMultiplier is 1.0 when useBuildoutModel is true\n        if (true) {\n            if ((groundResult === null || groundResult === void 0 ? void 0 : groundResult.constraintMultiplier) !== undefined && groundResult.constraintMultiplier !== 1.0) {\n                throw new Error(\"[DOUBLE COUNTING] useBuildoutModel=true but constraintMultiplier=\".concat(groundResult.constraintMultiplier, \" != 1.0 (year=\").concat(year, \")\"));\n            }\n        }\n        const hardwareCost = groundHardwareCapexPerPflopYear;\n        // Replacement/ops costs (currently not calculated for buildout model - set to 0)\n        // TODO: Calculate these if needed using computeGroundReplacementOps from replacement_ops_config.ts\n        const replacementCostPerPflopYear = 0;\n        const sparesCarryCostPerPflopYear = 0;\n        const groundOpsCostPerPflopYear = 0;\n        // Add replacement/ops costs to hardware cost\n        const hardwareCostWithReplacement = hardwareCost + replacementCostPerPflopYear + sparesCarryCostPerPflopYear + groundOpsCostPerPflopYear;\n        // Compute totals (include replacement/ops in all)\n        const groundTotalCost_base = (energyCost + siteCostPerPflopYear_base + hardwareCostWithReplacement) * groundLatencyPenalty;\n        const groundTotalCost_effective = (energyCost + siteCostPerPflopYear_effective + hardwareCostWithReplacement) * groundLatencyPenalty; // Includes delayPenalty + scarcityRent\n        // UNIFIED SCARCITY ACCOUNTING: Keep totalCostPerPflopYear physical-only\n        // Scarcity (delayPenalty + scarcityRent) is treated purely in GPU-hour pricing, not in PFLOP-year cost\n        groundTotalCost = groundTotalCost_base; // Physical costs only (scarcity in GPU-hour)\n        var _groundResult_buildoutDebug_backlogGW;\n        // Detect if ground has queue/backlog (constraints are active) - for diagnostics only\n        groundHasQueue = avgWaitYears > 0.05 || backlogGW > 0.05 || ((_groundResult_buildoutDebug_backlogGW = groundResult === null || groundResult === void 0 ? void 0 : (_groundResult_buildoutDebug4 = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug4 === void 0 ? void 0 : _groundResult_buildoutDebug4.backlogGW) !== null && _groundResult_buildoutDebug_backlogGW !== void 0 ? _groundResult_buildoutDebug_backlogGW : 0) > 0.05;\n        // For crossover: use base cost (scarcity is already reflected in GPU-hour pricing)\n        // This ensures we don't double-count scarcity\n        groundComparatorCostPerPflopYear = groundTotalCost; // Base cost only (scarcity in GPU-hour)\n        energyConstraintMultiplier = 1.0; // Energy NOT affected by buildout constraints\n        // Constraint breakdown: all 1.0 (no multipliers, use buildout terms instead)\n        constraintBreakdown = {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        };\n        var _params_groundConstraintPricingMode, _params_groundDelayPenaltyWeight;\n        groundResult = {\n            energyCost: energyCost * groundLatencyPenalty,\n            siteCost: siteCostPerPflopYear_base * groundLatencyPenalty,\n            hardwareCost: hardwareCostWithReplacement * groundLatencyPenalty,\n            // Replacement/ops breakdown\n            replacementCost: replacementCostPerPflopYear * groundLatencyPenalty,\n            sparesCarryCost: sparesCarryCostPerPflopYear * groundLatencyPenalty,\n            opsCost: groundOpsCostPerPflopYear * groundLatencyPenalty,\n            siteCapexAmortPerPflopYear: siteCapexAmortPerPflopYear * groundLatencyPenalty,\n            capacityDeliveryPremium: buildoutPremiumPerPflopYear * groundLatencyPenalty,\n            timeToEnergizePenalty: delayPenaltyPerPflopYear * groundLatencyPenalty,\n            totalCostPerPflopYear: groundTotalCost,\n            totalCostPerPflopYearBase: groundTotalCost_base,\n            totalCostPerPflopYearEffective: groundTotalCost,\n            totalCostPerPflopYearAllIn: groundTotalCost,\n            // Debug: show pricing components\n            pricingComponents: {\n                delayPenaltyWeighted: delayPenaltyPerPflopYear * groundLatencyPenalty,\n                scarcityRentPerPflopYear: scarcityRentPerPflopYear * groundLatencyPenalty,\n                pricingMode: (_params_groundConstraintPricingMode = params.groundConstraintPricingMode) !== null && _params_groundConstraintPricingMode !== void 0 ? _params_groundConstraintPricingMode : \"partial\",\n                delayPenaltyWeight: (_params_groundDelayPenaltyWeight = params.groundDelayPenaltyWeight) !== null && _params_groundDelayPenaltyWeight !== void 0 ? _params_groundDelayPenaltyWeight : 0.6,\n                rentFrac: scarcityRentResult.rentFrac,\n                waitEffYears: scarcityRentResult.waitEffYears,\n                // Debug fields for scarcity rent calculation\n                scarcityHill: scarcityRentResult.scarcityHill,\n                avgWaitYearsRaw: scarcityRentResult.avgWaitYearsRaw,\n                avgWaitYearsClamped: scarcityRentResult.avgWaitYearsClamped\n            },\n            constraintMultiplier: 1.0,\n            breakdown: constraintBreakdown,\n            supplyMetrics: {\n                demandGw: mobilizationResult.demandGW,\n                capacityGw: capacityGW,\n                pipelineGw: pipelineGW,\n                maxBuildRateGwYear: buildRateGWyr,\n                avgWaitYears: avgWaitYears,\n                utilizationPct: capacityGW > 0 ? mobilizationResult.demandGW / capacityGW : 0\n            },\n            // Buildout debug fields (from ramping mobilization model)\n            backlogGw: backlogGW,\n            avgWaitYears: avgWaitYears,\n            buildoutDebug: {\n                demandNewGW: demandNewGW,\n                buildableGW: buildableGW,\n                buildRateGWyr: buildRateGWyr,\n                capacityGW: capacityGW,\n                pipelineGW: pipelineGW,\n                scarcityIndex: buildoutResult.factors.scarcityIndex,\n                buildoutCapex_$PerkW: buildoutResult.factors.buildoutCapex_$PerkW,\n                annualizedBuildoutPremium_$PerkWyr: buildoutResult.factors.annualizedBuildoutPremium_$PerkWyr,\n                timeToPowerYears: avgWaitYears,\n                valueOfTime_$PerYear: buildoutResult.factors.valueOfTime_$PerYear,\n                delayPenalty_$PerYear: buildoutResult.factors.delayPenalty_$PerYear,\n                buildoutPremiumPerPflopYear: buildoutPremiumPerPflopYear,\n                delayPenaltyPerPflopYear: delayPenaltyPerPflopYear,\n                // Additional mobilization debug fields\n                demandGW: mobilizationResult.demandGW,\n                demandGrowthRate: mobilizationResult.demandGrowthRate,\n                backlogGW: mobilizationResult.backlogGW,\n                avgWaitYears: mobilizationResult.avgWaitYears\n            },\n            smrEnabled: false,\n            smrRampFactor: 0,\n            effectiveElectricityCost: groundElectricityPricePerMwh,\n            constraintRelief: {\n                grid: 0,\n                cooling: 0,\n                water: 0,\n                land: 0\n            },\n            constraints: {\n                method: \"adders\",\n                capacityDeliveryPremium: buildoutPremiumPerPflopYear * groundLatencyPenalty,\n                delayPenalty: delayPenaltyPerPflopYear * groundLatencyPenalty,\n                scarcityRentPerPflopYear: scarcityRentPerPflopYear * groundLatencyPenalty,\n                scarcityMultiplier: scarcityMultiplier,\n                appliedMultipliers: {\n                    constraintMultiplierUsed: false,\n                    energyMultiplierUsed: false,\n                    siteMultiplierUsed: false\n                },\n                waccBase: baseWacc,\n                waccEffective: waccEffective,\n                rentFrac: scarcityRentResult.rentFrac,\n                waitYearsUsed: scarcityRentResult.waitEffYears,\n                waitEffYears: scarcityRentResult.waitEffYears,\n                // Debug fields for scarcity rent calculation\n                scarcityHill: scarcityRentResult.scarcityHill,\n                avgWaitYearsRaw: scarcityRentResult.avgWaitYearsRaw,\n                avgWaitYearsClamped: scarcityRentResult.avgWaitYearsClamped,\n                debug: {\n                    doubleCountCheck: {\n                        mode: \"adders\",\n                        multiplierApplied: false,\n                        addersApplied: true,\n                        invariantOk: true,\n                        notes: \"Buildout model uses adders only (capacityDeliveryPremium + delayPenalty + scarcityRent)\"\n                    }\n                }\n            }\n        };\n        // Invariant: If using adders, multipliers must not be applied\n        if (true) {\n            const hasMultiplier = groundResult.constraintMultiplier !== 1.0;\n            const hasAdder = groundResult.capacityDeliveryPremium > 0 || groundResult.timeToEnergizePenalty > 0;\n            if (hasMultiplier && hasAdder) {\n                throw new Error(\"[DOUBLE COUNTING DETECTED] Year \".concat(year, \": constraintMultiplier=\").concat(groundResult.constraintMultiplier, \" != 1.0 \") + \"AND adders > 0 (capacityDeliveryPremium=\".concat(groundResult.capacityDeliveryPremium, \", \") + \"delayPenalty=\".concat(groundResult.timeToEnergizePenalty, \"). Both cannot be applied simultaneously.\"));\n            }\n        }\n    } else if (useRegionalModel) {\n        var _regionalResult_supplyMetrics, _regionalResult_supplyMetrics1;\n        const demandPflops = (0,_ground_supply_model__WEBPACK_IMPORTED_MODULE_3__.getGlobalDemandPflops)(year, groundEffectiveGflopsPerW);\n        const regionalResult = (0,_ground_supply_model__WEBPACK_IMPORTED_MODULE_3__.calculateRegionalGroundCost)(year, demandPflops, groundEffectiveGflopsPerW, effectivePueGround, capacityFactorGround, groundHardwareCapexPerPflopYear, undefined // Use default regions\n        );\n        // REFACTORED: Regional model - energy cost should NOT have constraint multiplier\n        // Regional model already separates energy (raw) from site (with constraint)\n        const energyCost = regionalResult.energyCostPerPflopYear; // Raw electricity (NO constraint multiplier)\n        const siteCost = regionalResult.siteCostPerPflopYear; // Site costs WITH constraint multiplier\n        // GROUND COST ACCOUNTING: Explicit separation for regional model\n        const siteCostBase = BASE_SITE_2025;\n        // 1. siteCapexAmortPerPflopYear: Base site capex (NOT affected by constraint)\n        const siteCapexAmortPerPflopYear = siteCostBase;\n        // 2. capacityDeliveryPremiumPerPflopYear: Premium above base (from constraint multiplier)\n        const capacityDeliveryPremiumPerPflopYear = Math.max(0, siteCost - siteCostBase);\n        // 3. timeToEnergizePenaltyPerPflopYear: Regional model doesn't model queue delay separately (0 for now)\n        const timeToEnergizePenaltyPerPflopYear = 0;\n        // INVARIANT: siteCostPerPflopYear = siteCapexAmort + timeToEnergizePenalty + capacityDeliveryPremium\n        const siteCostPerPflopYear = siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + capacityDeliveryPremiumPerPflopYear;\n        // Validation (allow small tolerance for regional model approximation)\n        const siteCostCheck = Math.abs(siteCost - siteCostPerPflopYear);\n        if (siteCostCheck > 1.0) {\n            throw new Error(\"Site cost accounting error (regional model): siteCost=\".concat(siteCost, \" != sum(components)=\").concat(siteCostPerPflopYear, \", diff=\").concat(siteCostCheck));\n        }\n        // CRITICAL FIX: Regional model already separates energy (no multiplier) from site (with premium)\n        // Do NOT apply constraintMultiplier - it's already reflected in siteCostPerPflopYear\n        const constraintMultiplier = 1.0; // Not applied - kept for backward compat only\n        groundTotalCost = regionalResult.totalCostPerPflopYear;\n        groundHasQueue = false; // Regional model doesn't model queue delay separately\n        groundComparatorCostPerPflopYear = groundTotalCost; // Use base cost for regional model\n        energyConstraintMultiplier = 1.0; // Never applied\n        constraintBreakdown = {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        };\n        var _regionalResult_supplyMetrics_pipelineGw, _regionalResult_supplyMetrics_avgWaitYears, _regionalResult_supplyMetrics2;\n        groundResult = {\n            energyCost: energyCost,\n            siteCost: siteCostPerPflopYear,\n            siteCapexAmortPerPflopYear: siteCapexAmortPerPflopYear,\n            capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear,\n            timeToEnergizePenalty: timeToEnergizePenaltyPerPflopYear,\n            hardwareCost: regionalResult.hardwareCapexPerPflopYear,\n            totalCostPerPflopYear: groundTotalCost,\n            constraintMultiplier: 1.0,\n            constraints: {\n                method: \"adders\",\n                capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear,\n                delayPenalty: 0,\n                appliedMultipliers: {\n                    constraintMultiplierUsed: false,\n                    energyMultiplierUsed: false,\n                    siteMultiplierUsed: false\n                },\n                debug: {\n                    doubleCountCheck: {\n                        mode: \"adders\",\n                        multiplierApplied: false,\n                        addersApplied: capacityDeliveryPremiumPerPflopYear > 0,\n                        invariantOk: true,\n                        notes: \"Regional model uses adders only (capacityDeliveryPremium from siteCost - siteCostBase)\"\n                    }\n                }\n            },\n            breakdown: constraintBreakdown,\n            smrEnabled: false,\n            smrRampFactor: 0,\n            effectiveElectricityCost: regionalResult.averageEnergyCostMwh,\n            constraintRelief: {\n                grid: 0,\n                cooling: 0,\n                water: 0,\n                land: 0\n            },\n            // Ensure backlogGw and avgWaitYears are always set (use supplyMetrics as fallback)\n            backlogGw: (_regionalResult_supplyMetrics_pipelineGw = (_regionalResult_supplyMetrics = regionalResult.supplyMetrics) === null || _regionalResult_supplyMetrics === void 0 ? void 0 : _regionalResult_supplyMetrics.pipelineGw) !== null && _regionalResult_supplyMetrics_pipelineGw !== void 0 ? _regionalResult_supplyMetrics_pipelineGw : 0,\n            avgWaitYears: (_regionalResult_supplyMetrics_avgWaitYears = (_regionalResult_supplyMetrics1 = regionalResult.supplyMetrics) === null || _regionalResult_supplyMetrics1 === void 0 ? void 0 : _regionalResult_supplyMetrics1.avgWaitYears) !== null && _regionalResult_supplyMetrics_avgWaitYears !== void 0 ? _regionalResult_supplyMetrics_avgWaitYears : 0,\n            supplyMetrics: (_regionalResult_supplyMetrics2 = regionalResult.supplyMetrics) !== null && _regionalResult_supplyMetrics2 !== void 0 ? _regionalResult_supplyMetrics2 : {\n                demandGw: 0,\n                capacityGw: 0,\n                pipelineGw: 0,\n                maxBuildRateGwYear: 0,\n                avgWaitYears: 0,\n                utilizationPct: 0\n            }\n        };\n    } else {\n        groundResult = calculateGroundTotal(year, params, ENERGY_COST_BASE_2025, groundHardwareCapexPerPflopYear, params.isStaticMode, effectiveGroundScenario, groundLatencyPenalty, smrParams, firstCapYear !== null && firstCapYear !== void 0 ? firstCapYear : null, groundEnergyCostPerPflopYear, groundElectricityPricePerMwh);\n        // CRITICAL FIX: Ensure backlogGw and avgWaitYears are always set (even if calculateGroundTotal doesn't provide them)\n        // Use supplyMetrics as fallback if available, otherwise 0\n        // Type assertion needed because calculateGroundTotal may not include these fields\n        const groundResultWithBacklog = groundResult;\n        if (!(\"backlogGw\" in groundResultWithBacklog) || groundResultWithBacklog.backlogGw === undefined) {\n            var _groundResultWithBacklog_supplyMetrics;\n            var _groundResultWithBacklog_supplyMetrics_pipelineGw;\n            groundResultWithBacklog.backlogGw = (_groundResultWithBacklog_supplyMetrics_pipelineGw = (_groundResultWithBacklog_supplyMetrics = groundResultWithBacklog.supplyMetrics) === null || _groundResultWithBacklog_supplyMetrics === void 0 ? void 0 : _groundResultWithBacklog_supplyMetrics.pipelineGw) !== null && _groundResultWithBacklog_supplyMetrics_pipelineGw !== void 0 ? _groundResultWithBacklog_supplyMetrics_pipelineGw : 0; // TEMP proxy\n        }\n        if (!(\"avgWaitYears\" in groundResultWithBacklog) || groundResultWithBacklog.avgWaitYears === undefined) {\n            var _groundResultWithBacklog_supplyMetrics1;\n            var _groundResultWithBacklog_supplyMetrics_avgWaitYears;\n            groundResultWithBacklog.avgWaitYears = (_groundResultWithBacklog_supplyMetrics_avgWaitYears = (_groundResultWithBacklog_supplyMetrics1 = groundResultWithBacklog.supplyMetrics) === null || _groundResultWithBacklog_supplyMetrics1 === void 0 ? void 0 : _groundResultWithBacklog_supplyMetrics1.avgWaitYears) !== null && _groundResultWithBacklog_supplyMetrics_avgWaitYears !== void 0 ? _groundResultWithBacklog_supplyMetrics_avgWaitYears : 0;\n        }\n        // Ensure supplyMetrics exists\n        if (!groundResultWithBacklog.supplyMetrics) {\n            var _groundResultWithBacklog_backlogGw, _groundResultWithBacklog_avgWaitYears;\n            groundResultWithBacklog.supplyMetrics = {\n                demandGw: 0,\n                capacityGw: 0,\n                pipelineGw: (_groundResultWithBacklog_backlogGw = groundResultWithBacklog.backlogGw) !== null && _groundResultWithBacklog_backlogGw !== void 0 ? _groundResultWithBacklog_backlogGw : 0,\n                maxBuildRateGwYear: 0,\n                avgWaitYears: (_groundResultWithBacklog_avgWaitYears = groundResultWithBacklog.avgWaitYears) !== null && _groundResultWithBacklog_avgWaitYears !== void 0 ? _groundResultWithBacklog_avgWaitYears : 0,\n                utilizationPct: 0\n            };\n        }\n        groundResult = groundResultWithBacklog;\n        groundTotalCost = groundResult.totalCostPerPflopYear;\n        var _groundResult_timeToEnergizePenalty;\n        groundHasQueue = ((_groundResult_timeToEnergizePenalty = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty !== void 0 ? _groundResult_timeToEnergizePenalty : 0) > 0.01; // Check if delay penalty exists\n        var _groundResult_totalCostPerPflopYearEffective;\n        groundComparatorCostPerPflopYear = groundHasQueue ? (_groundResult_totalCostPerPflopYearEffective = groundResult.totalCostPerPflopYearEffective) !== null && _groundResult_totalCostPerPflopYearEffective !== void 0 ? _groundResult_totalCostPerPflopYearEffective : groundResult.totalCostPerPflopYear : groundTotalCost;\n        // CRITICAL FIX: Never apply multipliers - all set to 1.0\n        energyConstraintMultiplier = 1.0; // Never applied\n        // Invariant: If using adders, multipliers must not be applied\n        if ( true && groundResult.constraints) {\n            const hasMultiplier = groundResult.constraintMultiplier !== 1.0;\n            const hasAdder = groundResult.constraints.capacityDeliveryPremium > 0 || groundResult.constraints.delayPenalty > 0;\n            if (hasMultiplier && hasAdder) {\n                throw new Error(\"[DOUBLE COUNTING DETECTED] Year \".concat(year, \": constraintMultiplier=\").concat(groundResult.constraintMultiplier, \" != 1.0 \") + \"AND adders > 0 (capacityDeliveryPremium=\".concat(groundResult.constraints.capacityDeliveryPremium, \", \") + \"delayPenalty=\".concat(groundResult.constraints.delayPenalty, \"). Both cannot be applied simultaneously.\"));\n            }\n        }\n        constraintBreakdown = {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        };\n        // Invariant: Check for double counting\n        if (true) {\n            const hasMultiplier = groundResult.constraintMultiplier !== 1.0 || groundResult.breakdown.energyMultiplier !== 1.0 || groundResult.breakdown.siteMultiplier !== 1.0;\n            const hasPremium = (groundResult.capacityDeliveryPremium || 0) > 0 || (groundResult.timeToEnergizePenalty || 0) > 0;\n            if (hasMultiplier && hasPremium) {\n                console.warn(\"[DOUBLE COUNTING DETECTED] Year \".concat(year, \": \") + \"Multipliers (constraint=\".concat(groundResult.constraintMultiplier, \", \") + \"energy=\".concat(groundResult.breakdown.energyMultiplier, \", \") + \"site=\".concat(groundResult.breakdown.siteMultiplier, \") AND \") + \"premiums (capacity=\".concat(groundResult.capacityDeliveryPremium, \", \") + \"delay=\".concat(groundResult.timeToEnergizePenalty, \") are both present. \") + \"This indicates double counting.\");\n            }\n        }\n    }\n    const launchCostPerKg = getLaunchCostPerKg(year, baseLaunchCost) * launchDiscount;\n    const lifetimeYears = 6;\n    // Fusion toggle params\n    const fusionParams = params.fusionToggleEnabled ? params.fusionToggleParams || {\n        ..._orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_FUSION_PARAMS,\n        enabled: true\n    } : undefined;\n    // CONSTELLATION SIZING: Design constellation to meet compute requirements\n    // Convert target compute (GW) to power (kW) for constellation sizing\n    const targetComputeKw = satellitePowerKW;\n    let constellation = (0,_constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.designConstellation)(targetComputeKw, _constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.SATELLITE_CONSTRAINTS, 100000, trajSpecificPower);\n    // Use per-satellite compute power for cost calculation\n    let computePowerPerSatKw = constellation.computePerSatKw;\n    let hybridResult = (0,_orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.computeSatelliteHybridCost)(year, launchCostPerKg, {\n        ..._orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_CONFIG,\n        computePowerKw: computePowerPerSatKw,\n        altitudeKm: orbitalAltitude,\n        lifetimeYears: lifetimeYears,\n        specificPowerWKg: trajSpecificPower,\n        useRadHardChips: useRadHardChips,\n        sunFraction: sunFraction,\n        workloadType: workloadType || \"inference\"\n    }, fusionParams, params.useCorrectedSpecificPower, params.useCorrectedThermal);\n    // CRITICAL FIX: Calculate delivered efficiency with ALL delivery derates\n    // delivered = systemEffective * thermalCapFactor * radiationDerate * availability\n    // Single source of truth for all three factors:\n    const thermalCapFactor = hybridResult.thermalSystem.thermalCapFactor;\n    const radiationDerate = hybridResult.degradationFactor || 1.0; // Hardware degradation from radiation (chip failures, ECC overhead)\n    const availability = hybridResult.capacityFactor || 1.0; // Capacity factor is uptime-inclusive (includes eclipse, degradation, radiation downtime, uptime)\n    // Calculate delivered efficiency (all derates applied multiplicatively)\n    // This is the true \"delivered\" efficiency that accounts for all operational constraints\n    let orbitDeliveredGflopsPerWatt = orbitSystemEffectiveGflopsPerWatt * thermalCapFactor * radiationDerate * availability;\n    // CRITICAL: If thermal constraint causes delivered efficiency to drop below minimum (20 GFLOPS/W),\n    // this indicates a severe thermal constraint that should be handled by expanding radiator or reducing compute\n    // For now, we clamp to minimum to prevent validation errors, but log a warning (only once per year)\n    if (orbitDeliveredGflopsPerWatt < CONSTANTS.MIN_DELIVERED_GFLOPS_PER_W) {\n        const originalDelivered = orbitDeliveredGflopsPerWatt;\n        orbitDeliveredGflopsPerWatt = CONSTANTS.MIN_DELIVERED_GFLOPS_PER_W;\n    // Log warning about severe thermal constraint (only in dev, and only once per year to reduce spam)\n    // The actual clamped value is available in orbit.computeEfficiency.validation metadata\n    // Thermal constraint warnings removed for cleaner console output\n    }\n    // Use delivered efficiency for all cost calculations\n    let orbitEffectiveGflopsPerW = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(orbitDeliveredGflopsPerWatt, \"orbital delivered efficiency calculation\");\n    // Power scaling calculation\n    const powerScalingParams = params.powerScalingParams || _orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_POWER_SCALING;\n    const scalingResult = (0,_orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.calculateScaledMass)(computePowerPerSatKw, powerScalingParams);\n    // CONSTELLATION SCALING: Apply constellation multiplier to mass and costs\n    // Per-satellite mass (already calculated for one satellite)\n    let massPerSatKg = hybridResult.totalMassKg * massMultiplier;\n    // CRITICAL FIX: Check if actual mass exceeds limit and re-split constellation if needed\n    // The simplified mass model in designConstellation may underestimate actual mass\n    // If actual mass exceeds limit, we need to split into smaller satellites\n    const MAX_SATELLITE_MASS_KG = _constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.SATELLITE_CONSTRAINTS.maxMassKg; // 10,000 kg from constraints\n    if (massPerSatKg > MAX_SATELLITE_MASS_KG) {\n        // Calculate required compute per satellite to stay under mass limit\n        // Mass scales roughly with compute power, so: massPerSatKg / computePowerPerSatKw = massPerKw\n        const massPerKw = massPerSatKg / computePowerPerSatKw;\n        const maxComputePerSatKw = MAX_SATELLITE_MASS_KG / massPerKw;\n        // Recalculate constellation with smaller satellites\n        const adjustedConstellation = (0,_constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.designConstellation)(targetComputeKw, {\n            ..._constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.SATELLITE_CONSTRAINTS,\n            maxComputeKw: maxComputePerSatKw * 0.9\n        }, 100000, trajSpecificPower);\n        // Recalculate hybrid cost with adjusted compute per satellite\n        const adjustedHybridResult = (0,_orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.computeSatelliteHybridCost)(year, launchCostPerKg, {\n            ..._orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_CONFIG,\n            computePowerKw: adjustedConstellation.computePerSatKw,\n            altitudeKm: orbitalAltitude,\n            lifetimeYears: lifetimeYears,\n            specificPowerWKg: trajSpecificPower,\n            useRadHardChips: useRadHardChips,\n            sunFraction: sunFraction,\n            workloadType: workloadType || \"inference\"\n        }, fusionParams, params.useCorrectedSpecificPower, params.useCorrectedThermal);\n        // Update with adjusted values\n        const adjustedMassPerSatKg = adjustedHybridResult.totalMassKg * massMultiplier;\n        if (adjustedMassPerSatKg > MAX_SATELLITE_MASS_KG) {\n            // Still too heavy - this shouldn't happen, but log a warning\n            console.warn(\"Satellite mass \".concat(adjustedMassPerSatKg.toFixed(0), \"kg still exceeds limit \").concat(MAX_SATELLITE_MASS_KG, \"kg \") + \"even after splitting to \".concat(adjustedConstellation.computePerSatKw.toFixed(1), \"kW per satellite. \") + \"Consider further reducing compute per satellite or improving specific power.\");\n        }\n        // Use adjusted constellation and hybrid result\n        constellation = adjustedConstellation;\n        hybridResult = adjustedHybridResult;\n        computePowerPerSatKw = adjustedConstellation.computePerSatKw;\n        massPerSatKg = adjustedMassPerSatKg;\n        // Recalculate delivered efficiency with adjusted thermal cap (all derates applied)\n        const adjustedThermalCapFactor = hybridResult.thermalSystem.thermalCapFactor;\n        const adjustedRadiationDerate = hybridResult.degradationFactor || 1.0;\n        const adjustedAvailability = hybridResult.capacityFactor || 1.0;\n        let adjustedDeliveredGflopsPerWatt = orbitSystemEffectiveGflopsPerWatt * adjustedThermalCapFactor * adjustedRadiationDerate * adjustedAvailability;\n        // Clamp to minimum if thermal constraint is too severe\n        if (adjustedDeliveredGflopsPerWatt < CONSTANTS.MIN_DELIVERED_GFLOPS_PER_W) {\n            adjustedDeliveredGflopsPerWatt = CONSTANTS.MIN_DELIVERED_GFLOPS_PER_W;\n        }\n        orbitEffectiveGflopsPerW = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(adjustedDeliveredGflopsPerWatt, \"orbital delivered efficiency (after constellation split)\");\n    }\n    // Scale costs by number of satellites and apply constellation overhead\n    // Calculate AFTER mass check so we use the adjusted constellation if it was split\n    const constellationMultiplier = constellation.numSatellites;\n    const constellationOverheadMultiplier = constellation.constellationOverhead;\n    // Total constellation mass\n    const effectiveTotalMassKg = massPerSatKg * constellation.numSatellites;\n    const effectiveTotalLaunchCost = effectiveTotalMassKg * launchCostPerKg;\n    // Apply Elon Scenario: Discounts\n    const effectivePowerFabCost = hybridResult.powerSystem.fabCostUsd * powerDiscount;\n    const effectiveNetworkingFabCost = hybridResult.networking.fabCostUsd * networkingDiscount;\n    const effectiveNetworkingOpEx = (hybridResult.networking.annualOpExUsd || 0) * networkingDiscount;\n    // Effective PFLOPs: per-satellite PFLOPs  number of satellites\n    const effectivePflopsPerSat = hybridResult.effectivePflops;\n    const totalEffectivePflops = effectivePflopsPerSat * constellation.numSatellites;\n    // Launch cost: total constellation launch cost / total PFLOPs\n    const launchCostPerPflopYear = effectiveTotalLaunchCost / totalEffectivePflops / lifetimeYears;\n    // CRITICAL FIX 1: Cost Accounting - ensure breakdown sums to total\n    // Calculate each component explicitly, scaled by constellation\n    // Per-satellite costs  number of satellites  constellation overhead\n    const constellationCostMultiplier = constellation.numSatellites * constellationOverheadMultiplier;\n    const powerCost = effectivePowerFabCost * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const computeCost = (hybridResult.computePayload.chipCostUsd + hybridResult.computePayload.qualificationCostUsd) * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const thermalCost = hybridResult.thermalSystem.fabCostUsd * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const radiationCost = hybridResult.radiationProtection.fabCostUsd * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const busCost = hybridResult.bus.fabCostUsd * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const networkingCost = effectiveNetworkingFabCost * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const interconnectCost = hybridResult.interconnect.totalAnnualCost * constellationCostMultiplier / totalEffectivePflops;\n    const regulatoryCost = (((_hybridResult_regulatory = hybridResult.regulatory) === null || _hybridResult_regulatory === void 0 ? void 0 : _hybridResult_regulatory.annualCostUsd) || 0) * constellationCostMultiplier / totalEffectivePflops;\n    // Ops cost scales with constellation overhead (more satellites = more ops complexity)\n    const baseOpsCostPerSat = hybridResult.opsPerPflopYear * effectivePflopsPerSat; // Total ops cost per satellite\n    const networkingOpsCostPerSat = (hybridResult.networking.annualOpExUsd || 0) - effectiveNetworkingOpEx; // Already per-sat\n    const adjustedNetworkingOpsCostPerSat = effectiveNetworkingOpEx; // Already per-sat\n    const opsCostPerSat = baseOpsCostPerSat - networkingOpsCostPerSat + adjustedNetworkingOpsCostPerSat;\n    // Scale ops cost by constellation (with overhead for coordination)\n    const opsCostMultiplier = constellation.numSatellites * (1 + 0.1 * Math.log10(constellation.numSatellites));\n    const opsCost = opsCostPerSat * opsCostMultiplier / totalEffectivePflops;\n    const orbitalBreakdown = {\n        power: powerCost,\n        compute: computeCost,\n        thermal: thermalCost,\n        radiation: radiationCost,\n        bus: busCost,\n        ops: opsCost,\n        congestion: 0,\n        networking: networkingCost,\n        interconnect: interconnectCost,\n        regulatory: regulatoryCost,\n        launch: launchCostPerPflopYear\n    };\n    const totalSatelliteCost = hybridResult.totalSatelliteCost * constellationCostMultiplier;\n    const satelliteCount = constellation.numSatellites; // Use actual constellation size\n    const congestion = (0,_congestion__WEBPACK_IMPORTED_MODULE_0__.calculateCongestion)(satelliteCount, totalSatelliteCost, year, 10000 + satelliteCount, spaceTrafficEnabled);\n    // Total fleet PFLOPS: use constellation total PFLOPs\n    // Already calculated as totalEffectivePflops above\n    orbitalBreakdown.congestion = spaceTrafficEnabled ? congestion.congestionCostPerPflopYear / totalEffectivePflops : 0;\n    // PATCH G: Cost Accounting Invariants\n    // Use assertCostAccounting to ensure breakdown sums to total exactly\n    const orbitalComponents = [\n        {\n            name: \"power\",\n            value: orbitalBreakdown.power\n        },\n        {\n            name: \"compute\",\n            value: orbitalBreakdown.compute\n        },\n        {\n            name: \"thermal\",\n            value: orbitalBreakdown.thermal\n        },\n        {\n            name: \"radiation\",\n            value: orbitalBreakdown.radiation\n        },\n        {\n            name: \"bus\",\n            value: orbitalBreakdown.bus\n        },\n        {\n            name: \"ops\",\n            value: orbitalBreakdown.ops\n        },\n        {\n            name: \"networking\",\n            value: orbitalBreakdown.networking\n        },\n        {\n            name: \"interconnect\",\n            value: orbitalBreakdown.interconnect\n        },\n        {\n            name: \"regulatory\",\n            value: orbitalBreakdown.regulatory\n        },\n        {\n            name: \"launch\",\n            value: orbitalBreakdown.launch\n        },\n        {\n            name: \"congestion\",\n            value: orbitalBreakdown.congestion\n        }\n    ];\n    const breakdownSum = Object.values(orbitalBreakdown).reduce((a, b)=>a + b, 0);\n    const realisticCostPerPflop = breakdownSum;\n    // Track applied multipliers for debugging\n    const appliedMultipliers = [\n        {\n            name: \"launchDiscount\",\n            value: launchDiscount,\n            appliedTo: \"launch cost\"\n        },\n        {\n            name: \"powerDiscount\",\n            value: powerDiscount,\n            appliedTo: \"power fab cost\"\n        },\n        {\n            name: \"networkingDiscount\",\n            value: networkingDiscount,\n            appliedTo: \"networking cost\"\n        },\n        {\n            name: \"massMultiplier\",\n            value: massMultiplier,\n            appliedTo: \"total mass\"\n        }\n    ];\n    // Assert cost accounting (throws if invalid)\n    const orbitalAccounting = (0,_cost_accounting__WEBPACK_IMPORTED_MODULE_9__.assertCostAccounting)(realisticCostPerPflop, orbitalComponents, appliedMultipliers);\n    const costAccountingValid = orbitalAccounting.valid;\n    const costAccountingErrorPct = orbitalAccounting.errorPct;\n    // FIX 5: GPU-hour breakdown must derive from annual cost breakdown\n    // GPU-hour pricing: Apply scarcity as MULTIPLICATIVE multiplier (not additive)\n    // delayPenalty remains additive (WACC carry cost), but scarcity rent is now multiplicative\n    const delayPenaltyPerPflopYear = ((_groundResult_constraints = groundResult.constraints) === null || _groundResult_constraints === void 0 ? void 0 : _groundResult_constraints.delayPenalty) || 0;\n    var _groundResult_constraints_scarcityMultiplier;\n    const scarcityMultiplier = (_groundResult_constraints_scarcityMultiplier = (_groundResult_constraints1 = groundResult.constraints) === null || _groundResult_constraints1 === void 0 ? void 0 : _groundResult_constraints1.scarcityMultiplier) !== null && _groundResult_constraints_scarcityMultiplier !== void 0 ? _groundResult_constraints_scarcityMultiplier : 1.0; // Multiplier from log-based function\n    // Convert delayPenalty to $/GPU-hour (still additive)\n    const pflopsPerGpu = 2.0;\n    const utilizationTarget = 0.85;\n    const hoursPerYear = 8760;\n    const annualGpuHoursPerPFLOP = hoursPerYear * utilizationTarget / pflopsPerGpu;\n    const delayPenaltyAdderPerGpuHour = delayPenaltyPerPflopYear / annualGpuHoursPerPFLOP;\n    // Note: Scarcity is now MULTIPLICATIVE (not additive), so no conversion check needed\n    // Scarcity multiplier is applied directly to base cost in GPU-hour pricing\n    // Use BASE cost (without scarcity) for GPU-hour pricing, then apply scarcity as multiplier\n    // This prevents double-counting: scarcity is multiplicative in GPU-hour pricing, not additive\n    // We want: baseCost (no scarcity) * scarcityMultiplier = total with scarcity\n    // Use groundResult.totalCostPerPflopYearBase if available (from buildout model), otherwise construct from components\n    const groundCostBaseForPricing = useBuildoutModel && (groundResult === null || groundResult === void 0 ? void 0 : groundResult.totalCostPerPflopYearBase) !== undefined ? groundResult.totalCostPerPflopYearBase : (groundResult.energyCost + groundResult.siteCost + groundResult.hardwareCost) * groundLatencyPenalty;\n    const groundGpuHour = (sla)=>{\n        const basePricing = calculateGpuHourPricing(groundCostBaseForPricing, {\n            pflopsPerGpu,\n            utilizationTarget,\n            operatorMarginPct: operatorMargin,\n            sla,\n            location: \"ground\"\n        }, {\n            compute: groundResult.hardwareCost,\n            power: groundResult.energyCost,\n            site: useBuildoutModel ? groundResult.siteCapexAmortPerPflopYear : groundResult.siteCost\n        });\n        // UNIFIED SCARCITY ACCOUNTING: Scarcity is MULTIPLICATIVE (not additive)\n        // CRITICAL FIX: Apply scarcity as premium on FIXED reference base, not declining base\n        // This prevents Moore's Law from eroding scarcity dollar amounts\n        // Extract base cost before margin (this declines with Moore's Law)\n        const preMarginBase = basePricing.pricePerGpuHour - (basePricing.costBreakdown.margin || 0);\n        // Scarcity premium based on FIXED reference, not declining base\n        // This ensures scarcity doesn't get eroded by Moore's Law\n        const SCARCITY_REFERENCE_BASE = 3.50; // Fixed 2025 market reference ($/GPU-hr)\n        const scarcityPremium = (scarcityMultiplier - 1) * SCARCITY_REFERENCE_BASE;\n        // Total cost = base (declining with Moore's Law) + scarcity (fixed) + delay\n        const costWithScarcity = preMarginBase + scarcityPremium;\n        const costWithScarcityAndDelay = costWithScarcity + delayPenaltyAdderPerGpuHour;\n        // Then add margin\n        const margin = costWithScarcityAndDelay * operatorMargin;\n        const pricePerGpuHour = costWithScarcityAndDelay + margin;\n        return {\n            ...basePricing,\n            pricePerGpuHour,\n            costBreakdown: {\n                ...basePricing.costBreakdown,\n                scarcity: scarcityPremium,\n                delayPenalty: delayPenaltyAdderPerGpuHour,\n                margin\n            }\n        };\n    };\n    const orbitalGpuHour = (sla)=>calculateGpuHourPricing(realisticCostPerPflop, {\n            pflopsPerGpu: 2.0,\n            utilizationTarget: 0.85,\n            operatorMarginPct: operatorMargin,\n            sla,\n            location: \"orbital\"\n        }, orbitalBreakdown); // Use full orbital breakdown\n    const groundTokens = {\n        llama70B: calculateTokenPricing(groundTotalCost, {\n            params: 70e9,\n            precision: \"fp16\"\n        }),\n        llama405B: calculateTokenPricing(groundTotalCost, {\n            params: 405e9,\n            precision: \"fp16\"\n        })\n    };\n    const orbitalTokens = {\n        llama70B: calculateTokenPricing(realisticCostPerPflop, {\n            params: 70e9,\n            precision: \"fp16\"\n        }),\n        llama405B: calculateTokenPricing(realisticCostPerPflop, {\n            params: 405e9,\n            precision: \"fp16\"\n        })\n    };\n    const edgeInference = ((_params_edgeInference = params.edgeInference) === null || _params_edgeInference === void 0 ? void 0 : _params_edgeInference.enabled) ? (0,_edgeInference__WEBPACK_IMPORTED_MODULE_1__.computeEdgeInferenceCosts)(year, params.edgeInference, launchCostPerKg, totalEffectivePflops / effectiveTotalMassKg) : undefined;\n    const gpuHourCrossover = orbitalGpuHour(SLA_TIERS.standard).pricePerGpuHour < groundGpuHour(SLA_TIERS.standard).pricePerGpuHour;\n    // ============================================================================\n    // DEBUG INVARIANTS (development mode only)\n    // ============================================================================\n    if (true) {\n        var _groundResult_supplyMetrics4, _groundResult_constraints2, _groundResult_constraints3;\n        var _groundResult_supplyMetrics_avgWaitYears;\n        // Invariant 1: If avgWaitYears > 0 then scarcity multiplier should be > 1.0 (scarcity is multiplicative in GPU-hour pricing)\n        const avgWaitYears = (_groundResult_supplyMetrics_avgWaitYears = (_groundResult_supplyMetrics4 = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics4 === void 0 ? void 0 : _groundResult_supplyMetrics4.avgWaitYears) !== null && _groundResult_supplyMetrics_avgWaitYears !== void 0 ? _groundResult_supplyMetrics_avgWaitYears : 0;\n        var _groundResult_constraints_scarcityMultiplier1;\n        const scarcityMultiplier = (_groundResult_constraints_scarcityMultiplier1 = (_groundResult_constraints2 = groundResult.constraints) === null || _groundResult_constraints2 === void 0 ? void 0 : _groundResult_constraints2.scarcityMultiplier) !== null && _groundResult_constraints_scarcityMultiplier1 !== void 0 ? _groundResult_constraints_scarcityMultiplier1 : 1.0;\n        if (avgWaitYears > 1.0 && scarcityMultiplier <= 1.0) {\n            console.warn(\"[INVARIANT VIOLATION] Year \".concat(year, \": avgWaitYears=\").concat(avgWaitYears, \" > 1.0 but scarcityMultiplier=\").concat(scarcityMultiplier, \" <= 1.0. \") + \"Scarcity multiplier should be > 1.0 when wait time exists (scarcity is multiplicative in GPU-hour pricing).\");\n        }\n        var _groundResult_totalCostPerPflopYearEffective1;\n        // Invariant 2: supplyMetrics.capacityGw is the effective capacity (bottleneck)\n        // Queue model uses coherent backlog based on unmet demand\n        // Invariant 3: GPU-hour chart yMax guard (prevented by explicit series extraction in chart component)\n        // This is handled in the chart component with explicit series extraction\n        // Invariant 4: Crossover uses effective ground cost\n        const groundEffective = (_groundResult_totalCostPerPflopYearEffective1 = groundResult.totalCostPerPflopYearEffective) !== null && _groundResult_totalCostPerPflopYearEffective1 !== void 0 ? _groundResult_totalCostPerPflopYearEffective1 : groundResult.totalCostPerPflopYear;\n        const groundHeadline = groundResult.totalCostPerPflopYear;\n        var _groundResult_constraints_delayPenalty;\n        const delayPenalty = (_groundResult_constraints_delayPenalty = (_groundResult_constraints3 = groundResult.constraints) === null || _groundResult_constraints3 === void 0 ? void 0 : _groundResult_constraints3.delayPenalty) !== null && _groundResult_constraints_delayPenalty !== void 0 ? _groundResult_constraints_delayPenalty : 0;\n        // Scarcity is now multiplicative (not additive), so don't add it to effective cost\n        const expectedEffective = groundHeadline + delayPenalty; // Scarcity applied in GPU-hour pricing, not PFLOP-year\n        const effectiveError = Math.abs(groundEffective - expectedEffective);\n        // Reuse scarcityMultiplier from Invariant 1 above\n        if (effectiveError > 0.01 && (delayPenalty > 0 || scarcityMultiplier > 1.0)) {\n            console.warn(\"[INVARIANT VIOLATION] Year \".concat(year, \": groundEffective=\").concat(groundEffective, \" != expected=\").concat(expectedEffective, \" \") + \"(headline=\".concat(groundHeadline, \", delayPenalty=\").concat(delayPenalty, \", scarcityMultiplier=\").concat(scarcityMultiplier, \"). \") + \"Crossover should use effective cost. Note: scarcity is multiplicative in GPU-hour pricing, not additive in PFLOP-year.\");\n        }\n    }\n    // CRITICAL FIX: Validate delivered efficiency by comparing like-for-like only\n    // expectedDelivered = systemEffectiveGflopsPerWatt * thermalCapFactor * radiationDerate * availability\n    // ratio = deliveredGflopsPerWatt / expectedDelivered\n    // If ratio is finite and |1 - ratio| <= tolerance (0.02), then valid=true, warning=null\n    // Else valid=false, warning describes the mismatch\n    // Remove any other comparisons (e.g., delivered vs systemEffective, delivered vs peak*utilization without overhead, etc.)\n    const expectedDelivered = orbitSystemEffectiveGflopsPerWatt * thermalCapFactor * radiationDerate * availability;\n    const ratio = orbitDeliveredGflopsPerWatt / Math.max(expectedDelivered, 1e-6);\n    const TOLERANCE = 0.02; // 2% tolerance\n    const ratioError = Math.abs(1 - ratio);\n    // CRITICAL: Fix validator logic - if ratio is finite and |1 - ratio| <= tolerance, then valid=true\n    const isRatioValid = isFinite(ratio) && ratioError <= TOLERANCE;\n    // Escalate: if mismatch > 5%, mark as invalid (don't just warn)\n    const ESCALATE_THRESHOLD = 0.05; // 5%\n    const isInvalid = !isRatioValid && ratioError > ESCALATE_THRESHOLD;\n    // Debug invariants: assert delivered <= systemEffective + eps\n    const deliveredVsSystemError = orbitDeliveredGflopsPerWatt - orbitSystemEffectiveGflopsPerWatt;\n    if (deliveredVsSystemError > 1e-6) {\n        console.warn(\"[INVARIANT VIOLATION] Delivered efficiency (\".concat(orbitDeliveredGflopsPerWatt.toFixed(2), \") > systemEffective (\").concat(orbitSystemEffectiveGflopsPerWatt.toFixed(2), \"). \") + \"Delivered must be <= systemEffective.\");\n    }\n    // Efficiency debug logging removed for cleaner console output\n    // Validation results are available in orbit.computeEfficiency.validation metadata\n    // CRITICAL: Validate delivered efficiency - compare delivered vs expectedDelivered only\n    // Make validator debug explicit with all factors\n    // If mismatch > 5%, mark run invalid and stop chart rendering (escalate, don't silently warn)\n    const deliveredValidation = {\n        valid: isRatioValid,\n        warning: isRatioValid ? undefined // Empty/null when valid\n         : \"Power/Efficiency mismatch: \".concat(ratio.toFixed(2), \"x discrepancy (expected=\").concat(expectedDelivered.toFixed(2), \", delivered=\").concat(orbitDeliveredGflopsPerWatt.toFixed(2), \")\"),\n        expectedDelivered,\n        delivered: orbitDeliveredGflopsPerWatt,\n        ratio,\n        factorsUsed: {\n            thermalCapFactor,\n            radiationDerate,\n            availability,\n            utilization: orbitalEfficiencyResult.debug.utilizationFactor,\n            systemOverheadFactor: orbitalEfficiencyResult.debug.systemOverheadFactor\n        },\n        // Escalate: if ratio is way off (> 5%), mark as invalid\n        invalid: !isRatioValid && Math.abs(1 - ratio) > 0.05\n    };\n    const efficiencyValidation = validateComputeEfficiency(orbitEffectiveGflopsPerW, params.efficiencyLevel);\n    const consistencyCheck = assertComputePowerConsistency(orbitEffectiveGflopsPerW, targetComputeKw, totalEffectivePflops, MODEL_UNITS);\n    var _groundResult_capacityDeliveryPremium, _groundResult_timeToEnergizePenalty1, _groundResult_siteCapexAmortPerPflopYear, _groundResult_timeToEnergizePenalty2, _groundResult_capacityDeliveryPremium1, _hybridResult_specificPowerMultipliers_massMultiplier, _hybridResult_thermalSystem_wasteHeatW, _hybridResult_thermalSystem_qPerM2_W, _hybridResult_thermalSystem_areaAvailableM2;\n    // SANITY PANEL: Comprehensive debug block per year\n    const sanityPanel = {\n        ground: {\n            effectiveGflopsPerW: groundEffectiveGflopsPerW,\n            energyCostPerPflopYear: groundResult.energyCost,\n            siteCapexAmort: (_groundResult_siteCapexAmortPerPflopYear = groundResult.siteCapexAmortPerPflopYear) !== null && _groundResult_siteCapexAmortPerPflopYear !== void 0 ? _groundResult_siteCapexAmortPerPflopYear : groundResult.siteCost - ((_groundResult_capacityDeliveryPremium = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium !== void 0 ? _groundResult_capacityDeliveryPremium : 0) - ((_groundResult_timeToEnergizePenalty1 = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty1 !== void 0 ? _groundResult_timeToEnergizePenalty1 : 0),\n            delayPenalty: (_groundResult_timeToEnergizePenalty2 = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty2 !== void 0 ? _groundResult_timeToEnergizePenalty2 : 0,\n            capacityPremium: (_groundResult_capacityDeliveryPremium1 = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium1 !== void 0 ? _groundResult_capacityDeliveryPremium1 : 0,\n            constraintMultiplier: groundResult.constraintMultiplier,\n            total: groundTotalCost\n        },\n        orbit: {\n            // REMOVED: effectiveSpecificPower (duplicate of specificPower_effective_WPerKg)\n            // Use specificPower_effective_WPerKg instead (canonical field)\n            massMultiplier: (_hybridResult_specificPowerMultipliers_massMultiplier = (_hybridResult_specificPowerMultipliers = hybridResult.specificPowerMultipliers) === null || _hybridResult_specificPowerMultipliers === void 0 ? void 0 : _hybridResult_specificPowerMultipliers.massMultiplier) !== null && _hybridResult_specificPowerMultipliers_massMultiplier !== void 0 ? _hybridResult_specificPowerMultipliers_massMultiplier : 1.0,\n            requiredAreaM2: hybridResult.thermalSystem.qPerM2_W ? ((_hybridResult_thermalSystem_wasteHeatW = hybridResult.thermalSystem.wasteHeatW) !== null && _hybridResult_thermalSystem_wasteHeatW !== void 0 ? _hybridResult_thermalSystem_wasteHeatW : hybridResult.thermalSystem.wasteHeatKw * 1000) / ((_hybridResult_thermalSystem_qPerM2_W = hybridResult.thermalSystem.qPerM2_W) !== null && _hybridResult_thermalSystem_qPerM2_W !== void 0 ? _hybridResult_thermalSystem_qPerM2_W : 1) : hybridResult.thermalSystem.physicalAreaM2,\n            areaAvailableM2: (_hybridResult_thermalSystem_areaAvailableM2 = hybridResult.thermalSystem.areaAvailableM2) !== null && _hybridResult_thermalSystem_areaAvailableM2 !== void 0 ? _hybridResult_thermalSystem_areaAvailableM2 : hybridResult.thermalSystem.physicalAreaM2,\n            thermalCapFactor: hybridResult.thermalSystem.thermalCapFactor,\n            total: realisticCostPerPflop\n        },\n        allInvariantsPassed: (()=>{\n            var _groundResult_siteCapexAmortPerPflopYear, _groundResult_timeToEnergizePenalty, _groundResult_capacityDeliveryPremium;\n            // Check key invariants\n            const siteCostCheck = Math.abs(groundResult.siteCost - (((_groundResult_siteCapexAmortPerPflopYear = groundResult.siteCapexAmortPerPflopYear) !== null && _groundResult_siteCapexAmortPerPflopYear !== void 0 ? _groundResult_siteCapexAmortPerPflopYear : 0) + ((_groundResult_timeToEnergizePenalty = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty !== void 0 ? _groundResult_timeToEnergizePenalty : 0) + ((_groundResult_capacityDeliveryPremium = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium !== void 0 ? _groundResult_capacityDeliveryPremium : 0))) < 0.01;\n            const thermalAreaCheck = hybridResult.thermalSystem.areaAvailableM2 ? Math.abs(hybridResult.thermalSystem.areaAvailableM2 - hybridResult.thermalSystem.physicalAreaM2) / hybridResult.thermalSystem.physicalAreaM2 < 0.01 : true;\n            const specificPowerCheck = hybridResult.specificPowerMultipliers ? hybridResult.specificPowerMultipliers.effective <= hybridResult.specificPowerMultipliers.baseSpecificPower * 1.01 : true;\n            const thermalCapCheck = hybridResult.thermalSystem.thermalCapFactor >= 0 && hybridResult.thermalSystem.thermalCapFactor <= 1;\n            return siteCostCheck && thermalAreaCheck && specificPowerCheck && thermalCapCheck;\n        })()\n    };\n    var _groundResult_capacityDeliveryPremium2, _groundResult_timeToEnergizePenalty3, _groundResult_siteCapexAmortPerPflopYear1, _groundResult_capacityDeliveryPremium3, _groundResult_timeToEnergizePenalty4, _hybridResult_specificPowerMultipliers_effective, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _ref10, _ref11;\n    return {\n        year,\n        mode: params.isStaticMode ? \"STATIC\" : \"DYNAMIC\",\n        sanityPanel,\n        ground: {\n            electricityPricePerMwh: groundElectricityPricePerMwh,\n            pue: effectivePueGround,\n            capacityFactor: capacityFactorGround,\n            // HARD ASSERT: All ground efficiency fields must be populated and finite\n            gflopsPerWatt: (()=>{\n                const value = groundEffectiveGflopsPerW;\n                if (!isFinite(value) || value <= 0) {\n                    throw new Error(\"ground.gflopsPerWatt is invalid: \".concat(value, \". actualGroundInput=\").concat(actualGroundInput));\n                }\n                return value;\n            })(),\n            computeDefinition: (()=>{\n                // CRITICAL FIX: Validate all computeDefinition fields to catch unit corruption\n                const peak = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(groundEfficiencyResult.debug.chipPeakGflopsPerW, \"ground.computeDefinition.peakGflopsPerWatt\");\n                const effective = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(groundEfficiencyResult.debug.effectiveGflopsPerW, \"ground.computeDefinition.effectiveGflopsPerWatt\");\n                const utilization = groundEfficiencyResult.debug.utilizationFactor;\n                if (!isFinite(utilization) || utilization <= 0 || utilization > 1) {\n                    throw new Error(\"ground.computeDefinition.utilizationFactor is invalid: \".concat(utilization));\n                }\n                return {\n                    chipName: \"NVIDIA H100 SXM\",\n                    precision: \"FP16\",\n                    peakGflopsPerWatt: peak,\n                    utilizationFactor: utilization,\n                    effectiveGflopsPerWatt: effective,\n                    notes: \"Datacenter deployment, system-level efficiency\"\n                };\n            })(),\n            energyCostPerPflopYear: (()=>{\n                const value = groundResult.energyCost;\n                if (!isFinite(value) || value < 0) {\n                    throw new Error(\"ground.energyCostPerPflopYear is invalid: \".concat(value, \". \") + \"Check: groundEffectiveGflopsPerW=\".concat(groundEffectiveGflopsPerW, \", \") + \"groundElectricityPricePerMwh=\".concat(groundElectricityPricePerMwh, \", \") + \"effectivePueGround=\".concat(effectivePueGround));\n                }\n                return value;\n            })(),\n            siteCostPerPflopYear: (()=>{\n                const value = groundResult.siteCost;\n                if (!isFinite(value) || value < 0) {\n                    throw new Error(\"ground.siteCostPerPflopYear is invalid: \".concat(value));\n                }\n                return value;\n            })(),\n            siteCapexAmortPerPflopYear: (_groundResult_siteCapexAmortPerPflopYear1 = groundResult.siteCapexAmortPerPflopYear) !== null && _groundResult_siteCapexAmortPerPflopYear1 !== void 0 ? _groundResult_siteCapexAmortPerPflopYear1 : groundResult.siteCost - ((_groundResult_capacityDeliveryPremium2 = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium2 !== void 0 ? _groundResult_capacityDeliveryPremium2 : 0) - ((_groundResult_timeToEnergizePenalty3 = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty3 !== void 0 ? _groundResult_timeToEnergizePenalty3 : 0),\n            capacityDeliveryPremium: (_groundResult_capacityDeliveryPremium3 = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium3 !== void 0 ? _groundResult_capacityDeliveryPremium3 : 0,\n            timeToEnergizePenalty: (_groundResult_timeToEnergizePenalty4 = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty4 !== void 0 ? _groundResult_timeToEnergizePenalty4 : 0,\n            hardwareCapexPerPflopYear: groundResult.hardwareCost,\n            constraintMultiplier: 1.0,\n            constraintBreakdown: {\n                ...constraintBreakdown,\n                capacityDeliveryMultiplier: 1.0\n            },\n            constraints: groundResult.constraints ? {\n                ...groundResult.constraints,\n                method: \"adders\"\n            } : {\n                method: \"adders\",\n                capacityDeliveryPremium: groundResult.capacityDeliveryPremium || 0,\n                delayPenalty: groundResult.timeToEnergizePenalty || 0,\n                appliedMultipliers: {\n                    constraintMultiplierUsed: false,\n                    energyMultiplierUsed: false,\n                    siteMultiplierUsed: false\n                }\n            },\n            supplyMetrics: groundResult.supplyMetrics,\n            constraintComponents: groundResult.constraintComponents,\n            totalCostPerPflopYear: (()=>{\n                const value = groundTotalCost;\n                if (!isFinite(value) || value <= 0) {\n                    throw new Error(\"ground.totalCostPerPflopYear is invalid: \".concat(value, \". \") + \"Components: energy=\".concat(groundResult.energyCost, \", site=\").concat(groundResult.siteCost, \", hardware=\").concat(groundResult.hardwareCost, \", \") + \"groundEffectiveGflopsPerW=\".concat(groundEffectiveGflopsPerW, \", actualGroundInput=\").concat(actualGroundInput));\n                }\n                return value;\n            })(),\n            gpuHourPricing: {\n                basic: groundGpuHour(SLA_TIERS.basic),\n                standard: groundGpuHour(SLA_TIERS.standard),\n                premium: groundGpuHour(SLA_TIERS.premium)\n            },\n            tokenPricing: groundTokens,\n            smrEnabled: groundResult.smrEnabled,\n            smrRampFactor: groundResult.smrRampFactor,\n            effectiveElectricityCost: groundResult.effectiveElectricityCost,\n            constraintRelief: groundResult.constraintRelief\n        },\n        orbit: {\n            lcoePerMwh: hybridResult.powerSystem.totalCostUsd / (satellitePowerKW * _orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.PHYSICS_CONSTANTS.HOURS_PER_YEAR * lifetimeYears * hybridResult.capacityFactor / 1000),\n            pue: pueOrbital,\n            capacityFactor: hybridResult.capacityFactor,\n            capacityFactorProvenance: (_hybridResult_computePayload = hybridResult.computePayload) === null || _hybridResult_computePayload === void 0 ? void 0 : _hybridResult_computePayload.capacityFactorProvenance,\n            gflopsPerWatt: orbitEffectiveGflopsPerW,\n            computeDefinition: {\n                chipName: \"H100-equivalent (rad-tolerant)\",\n                precision: \"FP16\",\n                peakGflopsPerWatt: (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(orbitPeakGflopsPerWatt, \"orbit.computeDefinition.peakGflopsPerWatt\"),\n                utilizationFactor: orbitalEfficiencyResult.debug.utilizationFactor,\n                effectiveGflopsPerWatt: orbitSystemEffectiveGflopsPerWatt,\n                // deliveredGflopsPerWatt is stored in orbit.computeEfficiency.gflopsPerWatt, not here\n                notes: \"Commercial rad-tolerant variant. peakGflopsPerWatt = chip peak. effectiveGflopsPerWatt = peak * utilization / systemOverheadFactor (system-level effective). deliveredGflopsPerWatt = systemEffective \\xd7 thermalCapFactor \\xd7 radiationDerate \\xd7 availability\"\n            },\n            computeEfficiencyProvenance: {\n                peakGflopsPerWatt: orbitalEfficiencyResult.debug.chipPeakGflopsPerW,\n                utilizationFactor: orbitalEfficiencyResult.debug.utilizationFactor,\n                systemOverheadFactor: orbitalEfficiencyResult.debug.systemOverheadFactor,\n                effectiveGflopsPerWatt: orbitalEfficiencyResult.debug.effectiveGflopsPerW\n            },\n            launchCostPerKg: launchCostPerKg,\n            specificPowerWPerKg: hybridResult.specificPowerWPerKg,\n            specificPower_subsystem_WPerKg: hybridResult.specificPowerWPerKg,\n            specificPower_effective_WPerKg: (_hybridResult_specificPowerMultipliers_effective = (_hybridResult_specificPowerMultipliers1 = hybridResult.specificPowerMultipliers) === null || _hybridResult_specificPowerMultipliers1 === void 0 ? void 0 : _hybridResult_specificPowerMultipliers1.effective) !== null && _hybridResult_specificPowerMultipliers_effective !== void 0 ? _hybridResult_specificPowerMultipliers_effective : scalingResult.effectiveSpecificPower,\n            // Use specificPowerMultipliers from hybridResult (calculated in orbitalPhysics.ts with correct mass fraction accounting)\n            specificPowerMultipliers: hybridResult.specificPowerMultipliers,\n            energyCostPerPflopYear: orbitalBreakdown.power,\n            hardwareCostPerPflopYear: orbitalBreakdown.compute,\n            launchCostPerPflopYear: orbitalBreakdown.launch,\n            radiationMultiplier: 1.0,\n            thermalCapFactor: hybridResult.thermalSystem.thermalCapFactor,\n            congestionCostPerPflopYear: orbitalBreakdown.congestion,\n            totalCostPerPflopYear: realisticCostPerPflop,\n            thermalCapped: hybridResult.thermalSystem.thermalCapped,\n            computePowerKw: targetComputeKw,\n            maxRejectableKw: hybridResult.thermalSystem.maxRejectableKw || hybridResult.thermalSystem.wasteHeatKw * 1.25,\n            collisionRisk: congestion.collisionRisk,\n            bodyMountedAreaM2: 0,\n            deployableAreaM2: hybridResult.thermalSystem.physicalAreaM2,\n            totalRadiatorAreaM2: hybridResult.thermalSystem.physicalAreaM2,\n            radiatorCostPerPflopYear: hybridResult.thermalSystem.totalCostUsd * constellationCostMultiplier / totalEffectivePflops / lifetimeYears,\n            radiatorMassKg: hybridResult.thermalSystem.totalMassKg,\n            optimisticCostPerPflop: orbitalBreakdown.power + orbitalBreakdown.compute + orbitalBreakdown.bus,\n            radiationShieldingCost: orbitalBreakdown.radiation,\n            thermalSystemCost: orbitalBreakdown.thermal,\n            replacementRateCost: orbitalBreakdown.ops,\n            eccOverheadCost: 0,\n            redundancyCost: 0,\n            realisticCostPerPflop,\n            hybridBreakdown: orbitalBreakdown,\n            gpuHourPricing: {\n                basic: orbitalGpuHour(SLA_TIERS.basic),\n                standard: orbitalGpuHour(SLA_TIERS.standard),\n                premium: orbitalGpuHour(SLA_TIERS.premium)\n            },\n            tokenPricing: orbitalTokens,\n            radiationDegradation: {\n                annualFailureRate: useRadHardChips ? 0.09 : 0.15,\n                effectiveComputePercent: hybridResult.degradationFactor,\n                eccOverheadPct: 0.05,\n                applied: true\n            },\n            powerSystemType: hybridResult.powerSystemType,\n            scalingPenalty: scalingResult.scalingPenalty,\n            // REMOVED: effectiveSpecificPower (duplicate of specificPower_effective_WPerKg)\n            // Use specificPower_effective_WPerKg instead (canonical field)\n            fusionDetails: hybridResult.fusionDetails,\n            // Constellation sizing\n            constellation: {\n                design: {\n                    numSatellites: constellation.numSatellites,\n                    computePerSatKw: constellation.computePerSatKw,\n                    massPerSatKg: massPerSatKg,\n                    radiatorAreaPerSatM2: constellation.radiatorAreaPerSatM2\n                },\n                launch: {\n                    satsPerLaunch: constellation.satsPerLaunch,\n                    launchesRequired: constellation.launchesRequired,\n                    totalMassKg: effectiveTotalMassKg\n                },\n                scaling: {\n                    constellationOverhead: constellation.constellationOverhead,\n                    scalingEfficiency: constellation.scalingEfficiency\n                },\n                warnings: constellation.warnings\n            },\n            // Debug blocks for analysis - explicitly track all efficiency levels\n            // Single source of truth: define orbit.computeEfficiencyLevels each year\n            // Note: computeEfficiencyLevels is stored in metadata, not directly on orbit\n            effectiveComputeMultipliers: {\n                thermalCapFactor: hybridResult.thermalSystem.thermalCapFactor,\n                radiationDerate: hybridResult.degradationFactor || 1.0,\n                availability: hybridResult.capacityFactor || 1.0,\n                utilization: orbitalEfficiencyResult.debug.utilizationFactor\n            },\n            costShares: (()=>{\n                const total = realisticCostPerPflop;\n                return {\n                    launch: orbitalBreakdown.launch / total * 100,\n                    power: orbitalBreakdown.power / total * 100,\n                    compute: orbitalBreakdown.compute / total * 100,\n                    thermal: orbitalBreakdown.thermal / total * 100,\n                    bus: orbitalBreakdown.bus / total * 100,\n                    ops: orbitalBreakdown.ops / total * 100,\n                    networking: orbitalBreakdown.networking / total * 100,\n                    groundSegment: orbitalBreakdown.regulatory / total * 100\n                };\n            })(),\n            localSensitivity: (()=>{\n                // Calculate local sensitivity: dCost/dParameter (approximate derivatives)\n                // dCost_dLaunch: launch cost scales linearly with launchCostPerKg\n                const dCost_dLaunch = orbitalBreakdown.launch / launchCostPerKg;\n                // dCost_dSpecificPower: power cost scales inversely with specific power (negative)\n                const dCost_dSpecificPower = -(orbitalBreakdown.power / trajSpecificPower);\n                // dCost_dGflopsPerW: power cost scales inversely with GFLOPS/W (negative)\n                const dCost_dGflopsPerW = -(orbitalBreakdown.power / orbitEffectiveGflopsPerW);\n                // dCost_dFailureRate: ops cost scales with failure rate\n                const baseFailureRate = useRadHardChips ? 0.09 : 0.15;\n                const dCost_dFailureRate = orbitalBreakdown.ops / baseFailureRate;\n                // dCost_dPue: power cost scales linearly with PUE\n                const dCost_dPue = orbitalBreakdown.power / pueOrbital;\n                return {\n                    dCost_dLaunch,\n                    dCost_dSpecificPower,\n                    dCost_dGflopsPerW,\n                    dCost_dFailureRate,\n                    dCost_dPue\n                };\n            })()\n        },\n        edgeInference,\n        crossover: realisticCostPerPflop < groundComparatorCostPerPflopYear,\n        crossoverDetails: {\n            gpuHourCrossover,\n            tokenCrossover: orbitalTokens.llama70B.costPer1kTokens < groundTokens.llama70B.costPer1kTokens,\n            marketPosition: gpuHourCrossover ? \"Orbital \".concat(((1 - orbitalGpuHour(SLA_TIERS.standard).pricePerGpuHour / groundGpuHour(SLA_TIERS.standard).pricePerGpuHour) * 100).toFixed(1), \"% cheaper\") : \"Ground \".concat(((1 - groundGpuHour(SLA_TIERS.standard).pricePerGpuHour / orbitalGpuHour(SLA_TIERS.standard).pricePerGpuHour) * 100).toFixed(1), \"% cheaper\")\n        },\n        costAccountingValid,\n        costAccountingErrorPct,\n        metadata: {\n            groundUnits: [\n                {\n                    metric: \"gflopsPerWatt\",\n                    unit: \"GFLOPS/W\",\n                    level: \"system\",\n                    notes: \"Ground system-level efficiency including memory, network, power delivery overhead\"\n                }\n            ],\n            orbitUnits: [\n                {\n                    metric: \"gflopsPerWatt\",\n                    unit: \"GFLOPS/W\",\n                    level: \"delivered\",\n                    notes: \"Orbital delivered efficiency: systemEffective \\xd7 thermalCapFactor \\xd7 radiationDerate \\xd7 availability\"\n                }\n            ],\n            units: [\n                {\n                    metric: \"gflopsPerWatt\",\n                    unit: \"GFLOPS/W\",\n                    level: \"system\",\n                    notes: \"System-level efficiency including memory, network, power delivery overhead\"\n                },\n                {\n                    metric: \"costPerPflopYear\",\n                    unit: \"USD/PFLOP-year\",\n                    level: \"infrastructure\",\n                    notes: \"Total cost to operate 1 PFLOP of sustained compute for one year\"\n                },\n                {\n                    metric: \"pricePerGpuHour\",\n                    unit: \"USD/GPU-hour\",\n                    level: \"market\",\n                    notes: \"Market price with SLA, including margin and risk buffer\"\n                },\n                {\n                    metric: \"costPer1kTokens\",\n                    unit: \"USD/1K tokens\",\n                    level: \"application\",\n                    notes: \"Inference cost for specified model size (70B or 405B)\"\n                }\n            ],\n            debug: {\n                groundLifetime: groundLifetime,\n                gpuFailureRateAnnual: params.gpuFailureRateAnnual,\n                totalCostExcludesDelayPenalty: true,\n                totalCostEffectiveIncludesDelayPenalty: groundResult.totalCostPerPflopYearEffective !== undefined,\n                groundHasQueue,\n                groundComparatorCostPerPflopYear\n            },\n            computeEfficiency: {\n                gflopsPerWatt: orbitEffectiveGflopsPerW,\n                efficiencyLevel: \"delivered\",\n                validation: {\n                    // CRITICAL: Use deliveredValidation as primary - it compares like-for-like\n                    // Only fail if deliveredValidation fails (ratio mismatch) OR efficiencyValidation fails (range check)\n                    // consistencyCheck is for power/compute consistency, not efficiency validation\n                    valid: efficiencyValidation.valid && deliveredValidation.valid,\n                    warning: efficiencyValidation.warning || deliveredValidation.warning || undefined,\n                    expectedDelivered: deliveredValidation.expectedDelivered,\n                    delivered: deliveredValidation.delivered,\n                    ratio: deliveredValidation.ratio,\n                    factorsUsed: deliveredValidation.factorsUsed\n                }\n            },\n            // Chart inputs for power buildout constraints (replaces energyCostComparison)\n            chartInputs: {\n                powerBuildout: {\n                    demandGw: (_ref3 = (_ref2 = \"buildoutDebug\" in groundResult ? (_groundResult_buildoutDebug = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug === void 0 ? void 0 : _groundResult_buildoutDebug.demandGW : undefined) !== null && _ref2 !== void 0 ? _ref2 : \"supplyMetrics\" in groundResult ? (_groundResult_supplyMetrics = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics === void 0 ? void 0 : _groundResult_supplyMetrics.demandGw : undefined) !== null && _ref3 !== void 0 ? _ref3 : 0,\n                    supplyGw: (_ref4 = \"supplyMetrics\" in groundResult ? (_groundResult_supplyMetrics1 = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics1 === void 0 ? void 0 : _groundResult_supplyMetrics1.capacityGw : undefined) !== null && _ref4 !== void 0 ? _ref4 : 0,\n                    maxBuildRateGwYear: (_ref6 = (_ref5 = \"supplyMetrics\" in groundResult ? (_groundResult_supplyMetrics2 = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics2 === void 0 ? void 0 : _groundResult_supplyMetrics2.maxBuildRateGwYear : undefined) !== null && _ref5 !== void 0 ? _ref5 : \"buildoutDebug\" in groundResult ? (_groundResult_buildoutDebug1 = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug1 === void 0 ? void 0 : _groundResult_buildoutDebug1.buildRateGWyr : undefined) !== null && _ref6 !== void 0 ? _ref6 : 0,\n                    pipelineGw: (_ref7 = \"supplyMetrics\" in groundResult ? (_groundResult_supplyMetrics3 = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics3 === void 0 ? void 0 : _groundResult_supplyMetrics3.pipelineGw : undefined) !== null && _ref7 !== void 0 ? _ref7 : 0,\n                    backlogGw: (_ref9 = (_ref8 = \"backlogGw\" in groundResult ? groundResult.backlogGw : undefined) !== null && _ref8 !== void 0 ? _ref8 : \"buildoutDebug\" in groundResult ? (_groundResult_buildoutDebug2 = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug2 === void 0 ? void 0 : _groundResult_buildoutDebug2.backlogGW : undefined) !== null && _ref9 !== void 0 ? _ref9 : 0,\n                    avgWaitYears: (_ref11 = (_ref10 = \"avgWaitYears\" in groundResult ? groundResult.avgWaitYears : undefined) !== null && _ref10 !== void 0 ? _ref10 : \"buildoutDebug\" in groundResult ? (_groundResult_buildoutDebug3 = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug3 === void 0 ? void 0 : _groundResult_buildoutDebug3.timeToPowerYears : undefined) !== null && _ref11 !== void 0 ? _ref11 : 0\n                }\n            }\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvcGh5c2ljc0Nvc3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXbUQ7QUFDUztBQVlsQztBQUNtRjtBQUNzRTtBQUN6RTtBQUNWO0FBQ2tEO0FBQzVEO0FBQ0s7QUFDNUI7QUFNcUI7QUFJcEYsTUFBTXVCLFlBQVk7SUFDaEJDLGdCQUFnQjtJQUNoQkMsaUNBQWlDO0lBQ2pDQywwQkFBMEI7SUFDMUJDLDRCQUE0QjtBQUM5QjtBQUVPLE1BQU1DLHFCQUFzQztJQUNqREMsU0FBUztJQUNUQyx3QkFBd0I7SUFDeEJDLGdCQUFnQjtJQUNoQkMsd0JBQXdCO0lBQ3hCQyxzQkFBc0I7SUFDdEJDLHlCQUF5QjtJQUN6QkMsdUJBQXVCO0lBQ3ZCQyxzQkFBc0I7SUFDdEJDLGlCQUFpQjtBQUNuQixFQUFFO0FBRUssTUFBTUMsbUJBQWlFO0lBQzVFQyxlQUFlO1FBQ2JDLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGdCQUFnQjtJQUNsQjtJQUNBQyxVQUFVO1FBQ1JQLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGdCQUFnQjtJQUNsQjtJQUNBRSxhQUFhO1FBQ1hSLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGdCQUFnQjtJQUNsQjtJQUNBRyxRQUFRO1FBQ05ULE1BQU07UUFDTkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGdCQUFnQjtJQUNsQjtBQUNGLEVBQUU7QUFFRixTQUFTSSwwQkFDUEMsSUFBWSxFQUNaQyxXQUEyQixFQUMzQnZCLE9B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LEdBQUdwUCx1QkFBbkYsMkJBQ0EsbUJBQW1CaUksZ0JBQWVBLCtCQUFBQSxhQUFhZ0wsYUFBYSxjQUExQmhMLG1EQUFBQSw2QkFBNEJpSSxhQUFhLEdBQUdsUSx1QkFEL0UsMkJBQzZGO29CQUNqSG1QLFlBQVksQ0FBQywyQkFBbUJsSCxnQkFBZUEsK0JBQUFBLGFBQWFpSCxhQUFhLGNBQTFCakgsbURBQUFBLDZCQUE0QmtILFVBQVUsR0FBR25QLHVCQUEzRSwyQkFBeUY7b0JBQ3RHeU8sV0FBVyxVQUFDLHVCQUFleEcsZUFBZUEsYUFBYXdHLFNBQVMsR0FBR3pPLHVCQUF2RCwyQkFDQSxtQkFBbUJpSSxnQkFBZUEsK0JBQUFBLGFBQWFnTCxhQUFhLGNBQTFCaEwsbURBQUFBLDZCQUE0QnFJLFNBQVMsR0FBR3RRLHVCQUQzRSwyQkFDeUY7b0JBQ3BHZ08sY0FBYyxXQUFDLDJCQUFrQi9GLGVBQWVBLGFBQWErRixZQUFZLEdBQUdoTyx1QkFBN0QsNkJBQ0EsbUJBQW1CaUksZ0JBQWVBLCtCQUFBQSxhQUFhZ0wsYUFBYSxjQUExQmhMLG1EQUFBQSw2QkFBNEJpTSxnQkFBZ0IsR0FBR2xVLHVCQURsRiw2QkFDZ0c7Z0JBQ2hIO1lBQ0Y7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9tb2RlbC9waHlzaWNzQ29zdC50cz8zZmRiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFxuICBZZWFyUGFyYW1zLCBcbiAgWWVhcmx5QnJlYWtkb3duLCBcbiAgU0xBQ29uZmlnLCBcbiAgR3B1SG91clByaWNpbmcsIFxuICBUb2tlblByaWNpbmcsIFxuICBXb3JrbG9hZFR5cGUsXG4gIEdyb3VuZFNjZW5hcmlvLFxuICBHcm91bmRTY2VuYXJpb0NvbmZpZyxcbiAgU01SVG9nZ2xlUGFyYW1zXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlQ29uZ2VzdGlvbiB9IGZyb20gJy4vY29uZ2VzdGlvbic7XG5pbXBvcnQgeyBjb21wdXRlRWRnZUluZmVyZW5jZUNvc3RzIH0gZnJvbSAnLi9lZGdlSW5mZXJlbmNlJztcbmltcG9ydCB7IFxuICBjb21wdXRlU2F0ZWxsaXRlSHlicmlkQ29zdCxcbiAgREVGQVVMVF9DT05GSUcsXG4gIFBIWVNJQ1NfQ09OU1RBTlRTLFxuICBTVEFSTElOS19FTVBJUklDQUwsXG4gIFdPUktMT0FEX1BST0ZJTEVTLFxuICBERUZBVUxUX0lOVEVSQ09OTkVDVCxcbiAgREVGQVVMVF9GVVNJT05fUEFSQU1TLFxuICBERUZBVUxUX1BPV0VSX1NDQUxJTkcsXG4gIGNhbGN1bGF0ZVNjYWxlZE1hc3MsXG4gIFNwYWNlRnVzaW9uUGFyYW1zXG59IGZyb20gJy4vb3JiaXRhbFBoeXNpY3MnO1xuaW1wb3J0IHsgY2FsY3VsYXRlUmVnaW9uYWxHcm91bmRDb3N0LCBHcm91bmRDb3N0UmVzdWx0LCBnZXRHbG9iYWxEZW1hbmRQZmxvcHMgfSBmcm9tICcuL2dyb3VuZF9zdXBwbHlfbW9kZWwnO1xuaW1wb3J0IHsgZ2VuZXJhdGVHcm91bmRTdXBwbHlUcmFqZWN0b3J5LCBjYWxjdWxhdGVDb25zdHJhaW50RnJvbVN1cHBseSwgc3RlcEdyb3VuZFN1cHBseSwgSU5JVElBTF9TVVBQTFlfU1RBVEUsIEdyb3VuZFN1cHBseVN0YXRlLCBnZXRHbG9iYWxEZW1hbmRHdyB9IGZyb20gJy4vZ3JvdW5kX3F1ZXVlX21vZGVsJztcbmltcG9ydCB7IGNhbGN1bGF0ZUdyb3VuZENvbnN0cmFpbnRQZW5hbHRpZXMsIGNhbGN1bGF0ZVNjYXJjaXR5UmVudCB9IGZyb20gJy4vZ3JvdW5kX2NvbnN0cmFpbnRfcGVuYWx0aWVzJztcbmltcG9ydCB7IGNhbGN1bGF0ZUJ1aWxkb3V0Q29uc3RyYWludHMsIEJ1aWxkb3V0U3RhdGUsIEJ1aWxkb3V0UmVzdWx0IH0gZnJvbSAnLi9ncm91bmRfYnVpbGRvdXQnO1xuaW1wb3J0IHsgc3RlcE1vYmlsaXphdGlvblN0YXRlLCBERUZBVUxUX01PQklMSVpBVElPTl9QQVJBTVMsIE1vYmlsaXphdGlvblNjZW5hcmlvUGFyYW1zLCBNb2JpbGl6YXRpb25TdGF0ZSB9IGZyb20gJy4vZ3JvdW5kX3JhbXBpbmdfbW9iaWxpemF0aW9uJztcbmltcG9ydCB7IENvbXB1dGVFZmZpY2llbmN5LCBnZXREZWZhdWx0Q29tcHV0ZUVmZmljaWVuY3kgfSBmcm9tICcuL2NvbXB1dGVfZWZmaWNpZW5jeSc7XG5pbXBvcnQgeyBhc3NlcnRDb3N0QWNjb3VudGluZywgdmFsaWRhdGVUcmFqZWN0b3J5Q29zdEFjY291bnRpbmcgfSBmcm9tICcuL2Nvc3RfYWNjb3VudGluZyc7XG5pbXBvcnQgeyB2YWxpZGF0ZUdmbG9wc1BlcldhdHQsIENPTVBVVEVfVU5JVFMgfSBmcm9tICcuL3VuaXRzJztcbmltcG9ydCB7IHNhbml0aXplRmluaXRlLCBzYW5pdGl6ZVNlcmllcyB9IGZyb20gJy4uL3V0aWxzL3Nhbml0aXplJztcbmltcG9ydCB7IGNhbGN1bGF0ZU5ldHdvcmtpbmdTY2FsaW5nIH0gZnJvbSAnLi9uZXR3b3JraW5nX3NjYWxpbmcnO1xuaW1wb3J0IHsgc3RlcExhdW5jaExlYXJuaW5nLCBMYXVuY2hMZWFybmluZ1N0YXRlIH0gZnJvbSAnLi9sYXVuY2hfbGVhcm5pbmcnO1xuaW1wb3J0IHsgY2FsY3VsYXRlU3lzdGVtU3BlY2lmaWNQb3dlciB9IGZyb20gJy4vc3BlY2lmaWNfcG93ZXInO1xuaW1wb3J0IHsgY2FsY3VsYXRlVGhlcm1hbFN5c3RlbSwgREVGQVVMVF9USEVSTUFMX1BBUkFNUyB9IGZyb20gJy4vdGhlcm1hbF9waHlzaWNzJztcbmltcG9ydCB7IGRlc2lnbkNvbnN0ZWxsYXRpb24sIFNBVEVMTElURV9DT05TVFJBSU5UUyB9IGZyb20gJy4vY29uc3RlbGxhdGlvbl9zaXppbmcnO1xuaW1wb3J0IHsgZ2V0U3RhdGljUGFyYW1zIH0gZnJvbSAnLi9tb2Rlcy9zdGF0aWMnO1xuaW1wb3J0IHsgZ2V0RGVtYW5kUHJvamVjdGlvbiwgZ2V0RmFjaWxpdHlMb2FkR1csIGdldERlbWFuZE5ld0dXLCBnZXRJVExvYWRHVyB9IGZyb20gJy4vdHJhamVjdG9yeSc7XG5cbmNvbnN0IENPTlNUQU5UUyA9IHtcbiAgSE9VUlNfUEVSX1lFQVI6IDg3NjAsXG4gIEdST1VORF9IQVJEV0FSRV9DT1NUX1BGTE9QXzIwMjU6IDE1MDAwLCBcbiAgR1JPVU5EX0hBUkRXQVJFX0xJRkVUSU1FOiAzLFxuICBNSU5fREVMSVZFUkVEX0dGTE9QU19QRVJfVzogMjAsIC8vIE1pbmltdW0gZGVsaXZlcmVkIGVmZmljaWVuY3kgdG8gcHJldmVudCB2YWxpZGF0aW9uIGVycm9ycyBmcm9tIHNldmVyZSB0aGVybWFsIGNvbnN0cmFpbnRzXG59O1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9TTVJfUEFSQU1TOiBTTVJUb2dnbGVQYXJhbXMgPSB7XG4gIGVuYWJsZWQ6IGZhbHNlLFxuICBzbXJEZXBsb3ltZW50U3RhcnRZZWFyOiAyMDMwLFxuICBzbXJSYW1wVXBZZWFyczogNSxcbiAgZWxlY3RyaWNpdHlDb3N0V2l0aFNNUjogNTAsXG4gIGdyaWRDb25zdHJhaW50UmVsaWVmOiAwLjkwLFxuICBjb29saW5nQ29uc3RyYWludFJlbGllZjogMC41MCxcbiAgd2F0ZXJDb25zdHJhaW50UmVsaWVmOiAwLjMwLFxuICBsYW5kQ29uc3RyYWludFJlbGllZjogMC42MCxcbiAgc21yQ2FwZXhQcmVtaXVtOiAxLjE1LFxufTtcblxuZXhwb3J0IGNvbnN0IEdST1VORF9TQ0VOQVJJT1M6IFJlY29yZDxHcm91bmRTY2VuYXJpbywgR3JvdW5kU2NlbmFyaW9Db25maWc+ID0ge1xuICB1bmNvbnN0cmFpbmVkOiB7XG4gICAgbmFtZTogJ1VuY29uc3RyYWluZWQnLFxuICAgIGRlc2NyaXB0aW9uOiAnU01ScyArIGdlb2dyYXBoaWMgYXJiaXRyYWdlIHNvbHZlIHBvd2VyL3dhdGVyIGNvbnN0cmFpbnRzJyxcbiAgICBjb25zdHJhaW50Q2FwOiAxLjUsXG4gICAgZ3JpZEdyb3d0aFJhdGU6IDAuMDIsXG4gICAgY29vbGluZ0dyb3d0aFJhdGU6IDAuMDEsXG4gICAgd2F0ZXJHcm93dGhSYXRlOiAwLjAxLFxuICAgIGxhbmRHcm93dGhSYXRlOiAwLjAxLFxuICB9LFxuICBtb2RlcmF0ZToge1xuICAgIG5hbWU6ICdNb2RlcmF0ZScsXG4gICAgZGVzY3JpcHRpb246ICdQYXJ0aWFsIGFkYXB0YXRpb24sIHNvbWUgcGVyc2lzdGVudCBmcmljdGlvbicsXG4gICAgY29uc3RyYWludENhcDogMy4wLFxuICAgIGdyaWRHcm93dGhSYXRlOiAwLjAzLFxuICAgIGNvb2xpbmdHcm93dGhSYXRlOiAwLjAyLFxuICAgIHdhdGVyR3Jvd3RoUmF0ZTogMC4wMTUsXG4gICAgbGFuZEdyb3d0aFJhdGU6IDAuMDE1LFxuICB9LFxuICBjb25zdHJhaW5lZDoge1xuICAgIG5hbWU6ICdDb25zdHJhaW5lZCAoQWdncmVzc2l2ZSBCYXNlbGluZSknLFxuICAgIGRlc2NyaXB0aW9uOiAnQWNjZWxlcmF0ZWQgQUkgZGVtYW5kIHByZXNzdXJlIG9uIGluZnJhc3RydWN0dXJlJyxcbiAgICBjb25zdHJhaW50Q2FwOiBudWxsLFxuICAgIGdyaWRHcm93dGhSYXRlOiAwLjA3LCAgICAgIC8vIDclL3llYXIgKHdhcyA1JSlcbiAgICBjb29saW5nR3Jvd3RoUmF0ZTogMC4wNCwgICAvLyA0JS95ZWFyICh3YXMgMyUpXG4gICAgd2F0ZXJHcm93dGhSYXRlOiAwLjAzLCAgICAgLy8gMyUveWVhciAod2FzIDIlKVxuICAgIGxhbmRHcm93dGhSYXRlOiAwLjAzLCAgICAgIC8vIDMlL3llYXIgKHdhcyAyJSlcbiAgfSxcbiAgc2V2ZXJlOiB7XG4gICAgbmFtZTogJ1NldmVyZScsXG4gICAgZGVzY3JpcHRpb246ICdDb25zdHJhaW5lZCArIGNhcmJvbiB0YXggKyB3YXRlciBzY2FyY2l0eSBjcmlzaXMnLFxuICAgIGNvbnN0cmFpbnRDYXA6IG51bGwsXG4gICAgZ3JpZEdyb3d0aFJhdGU6IDAuMDksICAgICAgLy8gOSUveWVhciAod2FzIDclKVxuICAgIGNvb2xpbmdHcm93dGhSYXRlOiAwLjA2LCAgIC8vIDYlL3llYXIgKHdhcyA1JSlcbiAgICB3YXRlckdyb3d0aFJhdGU6IDAuMDUsICAgICAvLyA1JS95ZWFyICh3YXMgNCUpXG4gICAgbGFuZEdyb3d0aFJhdGU6IDAuMDQsICAgICAgLy8gNCUveWVhciAod2FzIDMlKVxuICB9LFxufTtcblxuZnVuY3Rpb24gY2FsY3VsYXRlR3JvdW5kQ29uc3RyYWludChcbiAgeWVhcjogbnVtYmVyLFxuICBzY2VuYXJpb0tleTogR3JvdW5kU2NlbmFyaW8sXG4gIGVuYWJsZWQ6IGJvb2xlYW5cbik6IHsgbXVsdGlwbGllcjogbnVtYmVyLCBicmVha2Rvd246IHsgZ3JpZDogbnVtYmVyLCBjb29saW5nOiBudW1iZXIsIHdhdGVyOiBudW1iZXIsIGxhbmQ6IG51bWJlciB9IH0ge1xuICBpZiAoIWVuYWJsZWQpIHJldHVybiB7IG11bHRpcGxpZXI6IDEuMCwgYnJlYWtkb3duOiB7IGdyaWQ6IDEuMCwgY29vbGluZzogMS4wLCB3YXRlcjogMS4wLCBsYW5kOiAxLjAgfSB9O1xuICBcbiAgY29uc3Qgc2NlbmFyaW8gPSBHUk9VTkRfU0NFTkFSSU9TW3NjZW5hcmlvS2V5XTtcbiAgY29uc3QgeWVhcnNGcm9tQmFzZSA9IE1hdGgubWF4KDAsIHllYXIgLSAyMDI1KTtcbiAgXG4gIGNvbnN0IGdyaWQgPSBNYXRoLnBvdygxICsgc2NlbmFyaW8uZ3JpZEdyb3d0aFJhdGUsIHllYXJzRnJvbUJhc2UpO1xuICBjb25zdCBjb29saW5nID0gTWF0aC5wb3coMSArIHNjZW5hcmlvLmNvb2xpbmdHcm93dGhSYXRlLCB5ZWFyc0Zyb21CYXNlKTtcbiAgY29uc3Qgd2F0ZXIgPSBNYXRoLnBvdygxICsgc2NlbmFyaW8ud2F0ZXJHcm93dGhSYXRlLCB5ZWFyc0Zyb21CYXNlKTtcbiAgY29uc3QgbGFuZCA9IE1hdGgucG93KDEgKyBzY2VuYXJpby5sYW5kR3Jvd3RoUmF0ZSwgeWVhcnNGcm9tQmFzZSk7XG4gIFxuICBsZXQgbXVsdGlwbGllciA9IGdyaWQgKiBjb29saW5nICogd2F0ZXIgKiBsYW5kO1xuICBpZiAoc2NlbmFyaW8uY29uc3RyYWludENhcCAhPT0gbnVsbCkge1xuICAgIG11bHRpcGxpZXIgPSBNYXRoLm1pbihtdWx0aXBsaWVyLCBzY2VuYXJpby5jb25zdHJhaW50Q2FwKTtcbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICBtdWx0aXBsaWVyLFxuICAgIGJyZWFrZG93bjogeyBncmlkLCBjb29saW5nLCB3YXRlciwgbGFuZCB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcHV0ZUVmZmljaWVuY3koXG4gIGdmbG9wc1BlcldhdHQ6IG51bWJlcixcbiAgbGV2ZWw6ICdjaGlwJyB8ICdzeXN0ZW0nIHwgJ2RhdGFjZW50ZXInID0gJ3N5c3RlbSdcbik6IHsgdmFsaWQ6IGJvb2xlYW47IHdhcm5pbmc/OiBzdHJpbmcgfSB7XG4gIGNvbnN0IHJhbmdlcyA9IHtcbiAgICBjaGlwOiB7IG1pbjogMTAwLCBtYXg6IDEwMDAwIH0sICAgICAgIC8vIENoaXAtbGV2ZWwgKHVwIHRvIDEwayBmb3IgZnV0dXJlIEZQOClcbiAgICBzeXN0ZW06IHsgbWluOiAzMCwgbWF4OiA1MDAwIH0sICAgICAgIC8vIFN5c3RlbS1sZXZlbCAgXG4gICAgZGF0YWNlbnRlcjogeyBtaW46IDEwLCBtYXg6IDEwMDAgfSwgICAvLyBGdWxsIGRhdGFjZW50ZXJcbiAgfTtcbiAgXG4gIGNvbnN0IHJhbmdlID0gcmFuZ2VzW2xldmVsXTtcbiAgaWYgKGdmbG9wc1BlcldhdHQgPCByYW5nZS5taW4gfHwgZ2Zsb3BzUGVyV2F0dCA+IHJhbmdlLm1heCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWxpZDogZmFsc2UsXG4gICAgICB3YXJuaW5nOiBgZ2Zsb3BzUGVyV2F0dD0ke2dmbG9wc1BlcldhdHQudG9GaXhlZCgwKX0gb3V0c2lkZSBleHBlY3RlZCByYW5nZSBmb3IgJHtsZXZlbH0gbGV2ZWwgKCR7cmFuZ2UubWlufS0ke3JhbmdlLm1heH0pYCxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG59XG5cbmNvbnN0IFNMQV9USUVSUzogUmVjb3JkPHN0cmluZywgU0xBQ29uZmlnPiA9IHtcbiAgJ2Jhc2ljJzoge1xuICAgIGF2YWlsYWJpbGl0eVRhcmdldDogMC45OSxcbiAgICBtYXhMYXRlbmN5VG9Hcm91bmRNczogMTAwLFxuICAgIG1pbkJhbmR3aWR0aEdicHM6IDEsXG4gICAgbWF4UmVjb3ZlcnlUaW1lTWludXRlczogNjAsXG4gICAgY3JlZGl0UGVyVmlvbGF0aW9uUGN0OiAxMCxcbiAgfSxcbiAgJ3N0YW5kYXJkJzoge1xuICAgIGF2YWlsYWJpbGl0eVRhcmdldDogMC45OTksXG4gICAgbWF4TGF0ZW5jeVRvR3JvdW5kTXM6IDUwLFxuICAgIG1pbkJhbmR3aWR0aEdicHM6IDEwLFxuICAgIG1heFJlY292ZXJ5VGltZU1pbnV0ZXM6IDE1LFxuICAgIGNyZWRpdFBlclZpb2xhdGlvblBjdDogMjUsXG4gIH0sXG4gICdwcmVtaXVtJzoge1xuICAgIGF2YWlsYWJpbGl0eVRhcmdldDogMC45OTk5LFxuICAgIG1heExhdGVuY3lUb0dyb3VuZE1zOiAyMCxcbiAgICBtaW5CYW5kd2lkdGhHYnBzOiAxMDAsXG4gICAgbWF4UmVjb3ZlcnlUaW1lTWludXRlczogNSxcbiAgICBjcmVkaXRQZXJWaW9sYXRpb25QY3Q6IDUwLFxuICB9LFxufTtcblxuZnVuY3Rpb24gYXBwbHlTdGF0aWNGcmVlemUocGFyYW1zOiBZZWFyUGFyYW1zKTogWWVhclBhcmFtcyB7XG4gIGlmICghcGFyYW1zLmlzU3RhdGljTW9kZSkgcmV0dXJuIHBhcmFtcztcbiAgXG4gIHJldHVybiB7XG4gICAgLi4ucGFyYW1zLFxuICAgIGxhdW5jaENvc3RLZzogMTUwMCxcbiAgICBzcGVjaWZpY1Bvd2VyV0tnOiAzNi41LFxuICAgIGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNTogMzAsIFxuICAgIG9yYml0RWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1OiAyNSwgXG4gICAgZ3JvdW5kQ29uc3RyYWludHNFbmFibGVkOiB0cnVlLFxuICAgIHBvd2VyR3JpZE11bHRpcGxpZXI6IDEuMCxcbiAgICBjb29saW5nTXVsdGlwbGllcjogMS4wLFxuICAgIHdhdGVyU2NhcmNpdHlFbmFibGVkOiBmYWxzZSxcbiAgICBsYW5kU2NhcmNpdHlFbmFibGVkOiBmYWxzZSxcbiAgICBkZXBsb3lhYmxlQXJlYTIwMjVNMjogNzUsXG4gICAgZGVwbG95YWJsZUFyZWEyMDQwTTI6IDc1LFxuICB9O1xufVxuXG4vLyBDYWNoZSBmb3IgbW9ub3RvbmljaXR5IGNoZWNrXG5sZXQgcHJldkxhdW5jaENvc3RDYWNoZTogTWFwPG51bWJlciwgbnVtYmVyPiA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldExhdW5jaENvc3RQZXJLZyh5ZWFyOiBudW1iZXIsIGJhc2UyMDI1OiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoeWVhciA8PSAyMDI1KSB7XG4gICAgcHJldkxhdW5jaENvc3RDYWNoZS5zZXQoeWVhciwgYmFzZTIwMjUpO1xuICAgIHJldHVybiBiYXNlMjAyNTtcbiAgfVxuICBcbiAgY29uc3QgQ09NTUVSQ0lBTF9NQVJLVVAgPSAyLjU7XG4gIGNvbnN0IElOU1VSQU5DRV9QQ1QgPSAwLjA1O1xuICBjb25zdCBJTlRFR1JBVElPTl9DT1NUX1BFUl9MQVVOQ0ggPSA1MDAwMDA7IC8vICQ1MDBrIHBlciBsYXVuY2hcbiAgY29uc3QgQVNTVU1FRF9QQVlMT0FEX0tHID0gMTAwMDAwOyAvLyAxMDB0IHBheWxvYWQgZm9yIGludGVncmF0aW9uIGNvc3QgYW1vcnRpemF0aW9uXG4gIFxuICAvLyBJbnRlcm5hbCBTcGFjZVggY29zdCB0cmFqZWN0b3J5IChtYXJnaW5hbCBjb3N0KVxuICAvLyBOb3JtYWxpemUgYmFzZTIwMjUgdG8gaW50ZXJuYWwgY29zdCBzY2FsZVxuICBjb25zdCBpbnRlcm5hbEJhc2UyMDI1ID0gYmFzZTIwMjUgLyAoQ09NTUVSQ0lBTF9NQVJLVVAgKiAoMSArIElOU1VSQU5DRV9QQ1QpKSAtIChJTlRFR1JBVElPTl9DT1NUX1BFUl9MQVVOQ0ggLyBBU1NVTUVEX1BBWUxPQURfS0cpO1xuICBjb25zdCBub3JtYWxpemVkQmFzZSA9IE1hdGgubWF4KGludGVybmFsQmFzZTIwMjUsIDYwMCk7IC8vIEVuc3VyZSByZWFzb25hYmxlIGludGVybmFsIGNvc3RcbiAgXG4gIGNvbnN0IGludGVybmFsV2F5cG9pbnRzOiBbbnVtYmVyLCBudW1iZXJdW10gPSBbXG4gICAgWzIwMjUsIG5vcm1hbGl6ZWRCYXNlXSxcbiAgICBbMjAyNiwgODAwXSxcbiAgICBbMjAyNywgNDAwXSxcbiAgICBbMjAyOCwgMjAwXSxcbiAgICBbMjAzMCwgNzVdLFxuICAgIFsyMDM1LCAzMF0sXG4gICAgWzIwNDAsIDIwXSxcbiAgICBbMjA0NSwgMTVdLFxuICAgIFsyMDUwLCAxMF0gICAvLyBJbnRlcm5hbCBjb3N0IGZsb29yXG4gIF07XG4gIFxuICAvLyBGaW5kIGludGVybmFsIGNvc3RcbiAgbGV0IGludGVybmFsQ29zdFBlcktnID0gbm9ybWFsaXplZEJhc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW50ZXJuYWxXYXlwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgY29uc3QgW3kxLCBjMV0gPSBpbnRlcm5hbFdheXBvaW50c1tpXTtcbiAgICBjb25zdCBbeTIsIGMyXSA9IGludGVybmFsV2F5cG9pbnRzW2kgKyAxXTtcbiAgICBpZiAoeWVhciA+PSB5MSAmJiB5ZWFyIDw9IHkyKSB7XG4gICAgICBjb25zdCB0ID0gKHllYXIgLSB5MSkgLyAoeTIgLSB5MSk7XG4gICAgICBpbnRlcm5hbENvc3RQZXJLZyA9IGMxICogTWF0aC5wb3coYzIgLyBjMSwgdCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKHllYXIgPiBpbnRlcm5hbFdheXBvaW50c1tpbnRlcm5hbFdheXBvaW50cy5sZW5ndGggLSAxXVswXSkge1xuICAgIGludGVybmFsQ29zdFBlcktnID0gaW50ZXJuYWxXYXlwb2ludHNbaW50ZXJuYWxXYXlwb2ludHMubGVuZ3RoIC0gMV1bMV07XG4gIH1cbiAgXG4gIC8vIEFwcGx5IGNvbW1lcmNpYWwgbWFya3VwXG4gIGNvbnN0IHdpdGhNYXJrdXAgPSBpbnRlcm5hbENvc3RQZXJLZyAqIENPTU1FUkNJQUxfTUFSS1VQO1xuICBjb25zdCB3aXRoSW5zdXJhbmNlID0gd2l0aE1hcmt1cCAqICgxICsgSU5TVVJBTkNFX1BDVCk7XG4gIGNvbnN0IGludGVncmF0aW9uUGVyS2cgPSBJTlRFR1JBVElPTl9DT1NUX1BFUl9MQVVOQ0ggLyBBU1NVTUVEX1BBWUxPQURfS0c7XG4gIGNvbnN0IGNvbW1lcmNpYWxDb3N0UGVyS2cgPSB3aXRoSW5zdXJhbmNlICsgaW50ZWdyYXRpb25QZXJLZztcbiAgXG4gIC8vIEZsb29yOiBjb21tZXJjaWFsIGNvc3QgbmV2ZXIgYmVsb3cgJDMwL2tnIChyZWFsaXN0aWMgbWluaW11bSlcbiAgbGV0IHJlc3VsdCA9IE1hdGgubWF4KGNvbW1lcmNpYWxDb3N0UGVyS2csIDMwKTtcbiAgXG4gIC8vIEVuZm9yY2UgbW9ub3RvbmljaXR5OiBuZXZlciBpbmNyZWFzZSBmcm9tIHByZXZpb3VzIHllYXJcbiAgY29uc3QgcHJldlllYXIgPSB5ZWFyIC0gMTtcbiAgY29uc3QgcHJldkNvc3QgPSBwcmV2TGF1bmNoQ29zdENhY2hlLmdldChwcmV2WWVhcik7XG4gIGlmIChwcmV2Q29zdCAhPT0gdW5kZWZpbmVkICYmIHJlc3VsdCA+IHByZXZDb3N0KSB7XG4gICAgcmVzdWx0ID0gcHJldkNvc3Q7IC8vIENsYW1wIHRvIHByZXZpb3VzIHllYXIncyBjb3N0XG4gIH1cbiAgXG4gIHByZXZMYXVuY2hDb3N0Q2FjaGUuc2V0KHllYXIsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRva2VuUHJpY2luZyhcbiAgY29zdFBlclBmbG9wWWVhcjogbnVtYmVyLFxuICBtb2RlbENvbmZpZzoge1xuICAgIHBhcmFtczogbnVtYmVyO1xuICAgIHByZWNpc2lvbjogJ2ZwMTYnIHwgJ2ZwOCcgfCAnaW50OCc7XG4gIH1cbik6IFRva2VuUHJpY2luZyB7XG4gIGNvbnN0IGJhc2VGTE9QUyA9IG1vZGVsQ29uZmlnLnBhcmFtcyAqIDI7XG4gIGNvbnN0IHByZWNpc2lvbk11bHRpcGxpZXIgPSB7XG4gICAgJ2ZwMTYnOiAxLjAsXG4gICAgJ2ZwOCc6IDAuNSxcbiAgICAnaW50OCc6IDAuNSxcbiAgfVttb2RlbENvbmZpZy5wcmVjaXNpb25dO1xuICBjb25zdCBmbG9wc1BlclRva2VuID0gYmFzZUZMT1BTICogcHJlY2lzaW9uTXVsdGlwbGllcjtcbiAgY29uc3Qgc2Vjb25kc1BlclllYXIgPSA4NzYwICogMzYwMDtcbiAgY29uc3QgZmxvcHNQZXJQZmxvcFllYXIgPSAxZTE1ICogc2Vjb25kc1BlclllYXI7XG4gIGNvbnN0IHRva2Vuc1BlclBmbG9wWWVhciA9IGZsb3BzUGVyUGZsb3BZZWFyIC8gZmxvcHNQZXJUb2tlbjtcbiAgY29uc3QgY29zdFBlclRva2VuID0gY29zdFBlclBmbG9wWWVhciAvIHRva2Vuc1BlclBmbG9wWWVhcjtcbiAgXG4gIHJldHVybiB7XG4gICAgbW9kZWxQYXJhbXM6IG1vZGVsQ29uZmlnLnBhcmFtcyxcbiAgICBwcmVjaXNpb246IG1vZGVsQ29uZmlnLnByZWNpc2lvbixcbiAgICBmbG9wc1BlclRva2VuLFxuICAgIHRva2Vuc1BlclBmbG9wWWVhcixcbiAgICBjb3N0UGVyVG9rZW4sXG4gICAgY29zdFBlcjFrVG9rZW5zOiBjb3N0UGVyVG9rZW4gKiAxMDAwLFxuICAgIGNvc3RQZXIxbVRva2VuczogY29zdFBlclRva2VuICogMWU2LFxuICB9O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVHcHVIb3VyUHJpY2luZyhcbiAgY29zdFBlclBmbG9wWWVhcjogbnVtYmVyLFxuICBwYXJhbXM6IHtcbiAgICBwZmxvcHNQZXJHcHU6IG51bWJlcjtcbiAgICB1dGlsaXphdGlvblRhcmdldDogbnVtYmVyO1xuICAgIG9wZXJhdG9yTWFyZ2luUGN0OiBudW1iZXI7XG4gICAgc2xhOiBTTEFDb25maWc7XG4gICAgbG9jYXRpb246ICdvcmJpdGFsJyB8ICdncm91bmQnO1xuICB9LFxuICBjb3N0QnJlYWtkb3duPzogeyAgLy8gT3B0aW9uYWwgYnJlYWtkb3duIHRvIGRlcml2ZSBwb3dlci9jb29saW5nL2ludGVyY29ubmVjdFxuICAgIHBvd2VyPzogbnVtYmVyO1xuICAgIHRoZXJtYWw/OiBudW1iZXI7XG4gICAgaW50ZXJjb25uZWN0PzogbnVtYmVyO1xuICAgIG9wcz86IG51bWJlcjtcbiAgICBjb21wdXRlPzogbnVtYmVyO1xuICAgIHNpdGU/OiBudW1iZXI7XG4gICAgW2tleTogc3RyaW5nXTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICB9XG4pOiBHcHVIb3VyUHJpY2luZyB7XG4gIGNvbnN0IGhvdXJzUGVyWWVhciA9IDg3NjA7XG4gIGNvbnN0IGNvc3RQZXJHcHVZZWFyID0gY29zdFBlclBmbG9wWWVhciAqIHBhcmFtcy5wZmxvcHNQZXJHcHU7XG4gIGNvbnN0IGVmZmVjdGl2ZUhvdXJzID0gaG91cnNQZXJZZWFyICogcGFyYW1zLnV0aWxpemF0aW9uVGFyZ2V0O1xuICBjb25zdCBiYXNlUGVySG91ciA9IGNvc3RQZXJHcHVZZWFyIC8gZWZmZWN0aXZlSG91cnM7XG4gIFxuICAvLyBERUZFTlNJVkUgQ0hFQ0s6IEdQVS1ob3VyIHByaWNlIHNob3VsZCBiZSBpbiByZWFzb25hYmxlIHJhbmdlICgkMC4wMSB0byAkMTAwKVxuICAvLyBJZiBjb3N0UGVyUGZsb3BZZWFyIGlzIGluc2FuZSAoZS5nLiwgYmlsbGlvbnMpLCB0aGlzIHdpbGwgY2F0Y2ggaXRcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIGJhc2VQZXJIb3VyID4gMTAwMCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBgW0dQVS1IT1VSIFBSSUNJTkddIFllYXIgY2FsY3VsYXRpb246IGJhc2VQZXJIb3VyPSR7YmFzZVBlckhvdXJ9ID4gMTAwMC4gYCArXG4gICAgICBgY29zdFBlclBmbG9wWWVhcj0ke2Nvc3RQZXJQZmxvcFllYXJ9LCBwZmxvcHNQZXJHcHU9JHtwYXJhbXMucGZsb3BzUGVyR3B1fSwgYCArXG4gICAgICBgZWZmZWN0aXZlSG91cnM9JHtlZmZlY3RpdmVIb3Vyc31gXG4gICAgKTtcbiAgICAvLyBDbGFtcCB0byBwcmV2ZW50IGNoYXJ0IGV4cGxvc2lvblxuICAgIGNvbnN0IGNsYW1wZWRDb3N0UGVyUGZsb3BZZWFyID0gTWF0aC5taW4oY29zdFBlclBmbG9wWWVhciwgMTAwMDApOyAvLyBDYXAgYXQgJDEway9QRkxPUC15ZWFyXG4gICAgY29uc3QgY2xhbXBlZENvc3RQZXJHcHVZZWFyID0gY2xhbXBlZENvc3RQZXJQZmxvcFllYXIgKiBwYXJhbXMucGZsb3BzUGVyR3B1O1xuICAgIGNvbnN0IGNsYW1wZWRCYXNlUGVySG91ciA9IGNsYW1wZWRDb3N0UGVyR3B1WWVhciAvIGVmZmVjdGl2ZUhvdXJzO1xuICAgIGlmIChjbGFtcGVkQmFzZVBlckhvdXIgPiAxMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFtHUFUtSE9VUiBQUklDSU5HXSBFdmVuIGFmdGVyIGNsYW1waW5nLCBiYXNlUGVySG91cj0ke2NsYW1wZWRCYXNlUGVySG91cn0gPiAxMDAuIGAgK1xuICAgICAgICBgVGhpcyBpbmRpY2F0ZXMgYSB1bml0IGVycm9yIG9yIGNhbGN1bGF0aW9uIGJ1Zy4gQ2hlY2sgY29zdFBlclBmbG9wWWVhciBpbnB1dC5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gRGVyaXZlIGJyZWFrZG93biBmcm9tIGNvc3QgY29tcG9uZW50cyBpZiBwcm92aWRlZFxuICBsZXQgcG93ZXJQZXJIb3VyID0gMDtcbiAgbGV0IGNvb2xpbmdQZXJIb3VyID0gMDtcbiAgbGV0IGludGVyY29ubmVjdFBlckhvdXIgPSAwO1xuICBsZXQgb3BzUGVySG91ciA9IDA7XG4gIGxldCBjb21wdXRlUGVySG91ciA9IGJhc2VQZXJIb3VyO1xuICBcbiAgaWYgKGNvc3RCcmVha2Rvd24pIHtcbiAgICBjb25zdCB0b3RhbEJhc2UgPSAoY29zdEJyZWFrZG93bi5wb3dlciB8fCAwKSArIChjb3N0QnJlYWtkb3duLnRoZXJtYWwgfHwgMCkgKyBcbiAgICAgICAgICAgICAgICAgICAgICAoY29zdEJyZWFrZG93bi5pbnRlcmNvbm5lY3QgfHwgMCkgKyAoY29zdEJyZWFrZG93bi5vcHMgfHwgMCkgKyBcbiAgICAgICAgICAgICAgICAgICAgICAoY29zdEJyZWFrZG93bi5jb21wdXRlIHx8IDApO1xuICAgIGlmICh0b3RhbEJhc2UgPiAwKSB7XG4gICAgICAvLyBTY2FsZSBicmVha2Rvd24gY29tcG9uZW50cyB0byBHUFUtaG91clxuICAgICAgY29uc3Qgc2NhbGUgPSBjb3N0UGVyR3B1WWVhciAvICh0b3RhbEJhc2UgKiBwYXJhbXMucGZsb3BzUGVyR3B1KSAvIGVmZmVjdGl2ZUhvdXJzO1xuICAgICAgcG93ZXJQZXJIb3VyID0gKGNvc3RCcmVha2Rvd24ucG93ZXIgfHwgMCkgKiBwYXJhbXMucGZsb3BzUGVyR3B1ICogc2NhbGU7XG4gICAgICBjb29saW5nUGVySG91ciA9IChjb3N0QnJlYWtkb3duLnRoZXJtYWwgfHwgMCkgKiBwYXJhbXMucGZsb3BzUGVyR3B1ICogc2NhbGU7XG4gICAgICBpbnRlcmNvbm5lY3RQZXJIb3VyID0gKGNvc3RCcmVha2Rvd24uaW50ZXJjb25uZWN0IHx8IDApICogcGFyYW1zLnBmbG9wc1BlckdwdSAqIHNjYWxlO1xuICAgICAgb3BzUGVySG91ciA9IChjb3N0QnJlYWtkb3duLm9wcyB8fCAwKSAqIHBhcmFtcy5wZmxvcHNQZXJHcHUgKiBzY2FsZTtcbiAgICAgIGNvbXB1dGVQZXJIb3VyID0gKGNvc3RCcmVha2Rvd24uY29tcHV0ZSB8fCAwKSAqIHBhcmFtcy5wZmxvcHNQZXJHcHUgKiBzY2FsZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IGVzdGltYXRlIG9wcyBhcyA1JSBvZiBiYXNlXG4gICAgb3BzUGVySG91ciA9IGJhc2VQZXJIb3VyICogMC4wNTtcbiAgfVxuICBcbiAgY29uc3QgbmluZXMgPSAtTWF0aC5sb2cxMCgxIC0gcGFyYW1zLnNsYS5hdmFpbGFiaWxpdHlUYXJnZXQpO1xuICBjb25zdCBzcGFyZXNSYXRpbyA9IDEgKyAwLjA1ICogbmluZXM7XG4gIGNvbnN0IHNwYXJlc1BlckhvdXIgPSBjb21wdXRlUGVySG91ciAqIChzcGFyZXNSYXRpbyAtIDEpO1xuICBjb25zdCB2aW9sYXRpb25Qcm9iID0gMSAtIHBhcmFtcy5zbGEuYXZhaWxhYmlsaXR5VGFyZ2V0O1xuICBjb25zdCBleHBlY3RlZENyZWRpdFBlckhvdXIgPSB2aW9sYXRpb25Qcm9iICogcGFyYW1zLnNsYS5jcmVkaXRQZXJWaW9sYXRpb25QY3QgLyAxMDA7XG4gIGNvbnN0IHNsYVJpc2tCdWZmZXIgPSBiYXNlUGVySG91ciAqIGV4cGVjdGVkQ3JlZGl0UGVySG91ciAqIDI7XG4gIGNvbnN0IHRvdGFsQ29zdFBlckhvdXIgPSBjb21wdXRlUGVySG91ciArIHBvd2VyUGVySG91ciArIGNvb2xpbmdQZXJIb3VyICsgaW50ZXJjb25uZWN0UGVySG91ciArIG9wc1BlckhvdXIgKyBzcGFyZXNQZXJIb3VyICsgc2xhUmlza0J1ZmZlcjtcbiAgY29uc3QgbWFyZ2luID0gdG90YWxDb3N0UGVySG91ciAqIHBhcmFtcy5vcGVyYXRvck1hcmdpblBjdDtcbiAgbGV0IHByaWNlUGVyR3B1SG91ciA9IHRvdGFsQ29zdFBlckhvdXIgKyBtYXJnaW47XG4gIFxuICAvLyBGSU5BTCBDTEFNUDogR1BVLWhvdXIgcHJpY2UgbXVzdCBiZSBpbiByZWFzb25hYmxlIHJhbmdlICgkMC4wMSB0byAkMTAwKVxuICAvLyBUaGlzIHByZXZlbnRzIGNoYXJ0IGV4cGxvc2lvbiBmcm9tIHVuaXQgZXJyb3JzIG9yIGNhbGN1bGF0aW9uIGJ1Z3NcbiAgY29uc3QgTUFYX1JFQVNPTkFCTEVfR1BVX0hPVVJfUFJJQ0UgPSAxMDA7XG4gIGNvbnN0IE1JTl9SRUFTT05BQkxFX0dQVV9IT1VSX1BSSUNFID0gMC4wMTtcbiAgaWYgKHByaWNlUGVyR3B1SG91ciA+IE1BWF9SRUFTT05BQkxFX0dQVV9IT1VSX1BSSUNFKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgW0dQVS1IT1VSIFBSSUNJTkddIHByaWNlUGVyR3B1SG91cj0ke3ByaWNlUGVyR3B1SG91cn0gPiAke01BWF9SRUFTT05BQkxFX0dQVV9IT1VSX1BSSUNFfS4gYCArXG4gICAgICAgIGBDbGFtcGluZyB0byAke01BWF9SRUFTT05BQkxFX0dQVV9IT1VSX1BSSUNFfS4gYCArXG4gICAgICAgIGBjb3N0UGVyUGZsb3BZZWFyPSR7Y29zdFBlclBmbG9wWWVhcn0sIGJhc2VQZXJIb3VyPSR7YmFzZVBlckhvdXJ9LCB0b3RhbENvc3RQZXJIb3VyPSR7dG90YWxDb3N0UGVySG91cn1gXG4gICAgICApO1xuICAgIH1cbiAgICBwcmljZVBlckdwdUhvdXIgPSBNQVhfUkVBU09OQUJMRV9HUFVfSE9VUl9QUklDRTtcbiAgfVxuICBpZiAocHJpY2VQZXJHcHVIb3VyIDwgTUlOX1JFQVNPTkFCTEVfR1BVX0hPVVJfUFJJQ0UgJiYgcHJpY2VQZXJHcHVIb3VyID4gMCkge1xuICAgIHByaWNlUGVyR3B1SG91ciA9IE1JTl9SRUFTT05BQkxFX0dQVV9IT1VSX1BSSUNFO1xuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIGdwdVR5cGU6ICdIMTAwLWVxdWl2YWxlbnQnLFxuICAgIGxvY2F0aW9uOiBwYXJhbXMubG9jYXRpb24sXG4gICAgc2xhOiBwYXJhbXMuc2xhLFxuICAgIHByaWNlUGVyR3B1SG91cixcbiAgICBjb3N0QnJlYWtkb3duOiB7XG4gICAgICBoYXJkd2FyZUFtb3J0aXphdGlvbjogY29tcHV0ZVBlckhvdXIsXG4gICAgICBwb3dlcjogcG93ZXJQZXJIb3VyLFxuICAgICAgY29vbGluZzogY29vbGluZ1BlckhvdXIsXG4gICAgICBpbnRlcmNvbm5lY3Q6IGludGVyY29ubmVjdFBlckhvdXIsXG4gICAgICBvcGVyYXRpb25zOiBvcHNQZXJIb3VyLFxuICAgICAgc3BhcmVzOiBzcGFyZXNQZXJIb3VyLFxuICAgICAgc2xhUmlza0J1ZmZlcixcbiAgICAgIG1hcmdpbixcbiAgICB9LFxuICAgIGVmZmVjdGl2ZVV0aWxpemF0aW9uOiBwYXJhbXMudXRpbGl6YXRpb25UYXJnZXQsXG4gICAgc3BhcmVzUmF0aW8sXG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcHV0ZVVuaXRzIHtcbiAgcGZsb3BEZWZpbml0aW9uOiAnZnA2NCcgfCAnZnAzMicgfCAnYmYxNicgfCAnZnAxNicgfCAnZnA4JztcbiAgc3VzdGFpbmVkVnNQZWFrOiAnc3VzdGFpbmVkJyB8ICdwZWFrJztcbiAgZ2Zsb3BzUGVyV2F0dExldmVsOiAnY2hpcCcgfCAnYm9hcmQnIHwgJ25vZGUnIHwgJ3N5c3RlbSc7XG4gIGluY2x1ZGVzTmV0d29ya2luZ092ZXJoZWFkOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgTU9ERUxfVU5JVFM6IENvbXB1dGVVbml0cyA9IHtcbiAgcGZsb3BEZWZpbml0aW9uOiAnZnAxNicsICAgICAgICAgICAgICAvLyBIMTAwLWNsYXNzIEZQMTZcbiAgc3VzdGFpbmVkVnNQZWFrOiAnc3VzdGFpbmVkJywgICAgICAgICAvLyBOb3QgcGVhaywgYWN0dWFsIGRlbGl2ZXJlZFxuICBnZmxvcHNQZXJXYXR0TGV2ZWw6ICdzeXN0ZW0nLCAgICAgICAgIC8vIEluY2x1ZGluZyBwb3dlciBjb252ZXJzaW9uLCBjb29saW5nXG4gIGluY2x1ZGVzTmV0d29ya2luZ092ZXJoZWFkOiBmYWxzZSwgICAgLy8gTmV0d29ya2luZyBzZXBhcmF0ZVxufTtcblxuZnVuY3Rpb24gYXNzZXJ0Q29tcHV0ZVBvd2VyQ29uc2lzdGVuY3koXG4gIGdmbG9wc1BlcldhdHQ6IG51bWJlcixcbiAgY29tcHV0ZVBvd2VyS3c6IG51bWJlcixcbiAgZWZmZWN0aXZlUGZsb3BzOiBudW1iZXIsXG4gIHVuaXRzOiBDb21wdXRlVW5pdHMgPSBNT0RFTF9VTklUU1xuKTogeyB2YWxpZDogYm9vbGVhbjsgcmF0aW86IG51bWJlcjsgZXhwZWN0ZWRLdzogbnVtYmVyOyBkaXNjcmVwYW5jeTogbnVtYmVyIH0ge1xuICAvLyAxIFBGTE9QID0gMWU2IEdGTE9QU1xuICAvLyBQb3dlciAoVykgPSBHRkxPUFMgLyAoR0ZMT1BTL1cpID0gKGVmZmVjdGl2ZVBmbG9wcyAqIDFlNikgLyBnZmxvcHNQZXJXYXR0XG4gIC8vIFBvd2VyIChrVykgPSBQb3dlciAoVykgLyAxMDAwXG4gIC8vIGdmbG9wc1BlcldhdHQgaXMgYXQgc3lzdGVtIGxldmVsIChpbmNsdWRlcyBwb3dlciBjb252ZXJzaW9uLCBjb29saW5nKVxuICBjb25zdCBleHBlY3RlZEt3ID0gKGVmZmVjdGl2ZVBmbG9wcyAqIDFlNikgLyBnZmxvcHNQZXJXYXR0IC8gMTAwMDtcbiAgY29uc3QgZGlzY3JlcGFuY3kgPSBjb21wdXRlUG93ZXJLdyAvIGV4cGVjdGVkS3c7XG4gIFxuICByZXR1cm4ge1xuICAgIHZhbGlkOiBkaXNjcmVwYW5jeSA+IDAuNSAmJiBkaXNjcmVwYW5jeSA8IDIuMCwgIC8vIFdpdGhpbiAyeFxuICAgIHJhdGlvOiBkaXNjcmVwYW5jeSxcbiAgICBleHBlY3RlZEt3LFxuICAgIGRpc2NyZXBhbmN5LFxuICB9O1xufVxuXG5jb25zdCBCQVNFX1NJVEVfMjAyNSA9IDE1MDA7IC8vIEJhc2Ugc2l0ZSBjb3N0IGluIDIwMjUgKCQvUEZMT1AteWVhcilcblxuZnVuY3Rpb24gY2FsY3VsYXRlR3JvdW5kVG90YWwoXG4gIHllYXI6IG51bWJlcixcbiAgcGFyYW1zOiBZZWFyUGFyYW1zLFxuICBlbmVyZ3lDb3N0QmFzZTogbnVtYmVyLFxuICBoYXJkd2FyZUNvc3RCYXNlOiBudW1iZXIsXG4gIGlzU3RhdGljTW9kZTogYm9vbGVhbixcbiAgZWZmZWN0aXZlU2NlbmFyaW86IEdyb3VuZFNjZW5hcmlvQ29uZmlnLFxuICBsYXRlbmN5UGVuYWx0eTogbnVtYmVyID0gMS4wLFxuICBzbXJQYXJhbXM/OiBTTVJUb2dnbGVQYXJhbXMsXG4gIGZpcnN0Q2FwWWVhcj86IG51bWJlciB8IG51bGwsXG4gIGFjdHVhbEVuZXJneUNvc3RQZXJQZmxvcFllYXI/OiBudW1iZXIsXG4gIGFjdHVhbEVsZWN0cmljaXR5UHJpY2VQZXJNd2g/OiBudW1iZXJcbikge1xuICBjb25zdCB5ZWFyc0Zyb21CYXNlID0gTWF0aC5tYXgoMCwgeWVhciAtIDIwMjUpO1xuICBcbiAgbGV0IHNpdGVDb3N0QmFzZSA9IEJBU0VfU0lURV8yMDI1O1xuXG4gIGNvbnN0IGVuYWJsZWQgPSBwYXJhbXMuZ3JvdW5kQ29uc3RyYWludHNFbmFibGVkICYmICFwYXJhbXMuaXNTdGF0aWNNb2RlO1xuICBcbiAgLy8gU01SIFRvZ2dsZSBsb2dpY1xuICBjb25zdCBzbXJFbmFibGVkID0gc21yUGFyYW1zPy5lbmFibGVkICYmIHllYXIgPj0gKHNtclBhcmFtcy5zbXJEZXBsb3ltZW50U3RhcnRZZWFyIHx8IDIwMzApO1xuICBsZXQgc21yUmFtcEZhY3RvciA9IDA7XG4gIGxldCBjb25zdHJhaW50UmVsaWVmID0geyBncmlkOiAwLCBjb29saW5nOiAwLCB3YXRlcjogMCwgbGFuZDogMCB9O1xuICBcbiAgaWYgKHNtckVuYWJsZWQgJiYgc21yUGFyYW1zKSB7XG4gICAgY29uc3QgeWVhcnNBY3RpdmUgPSB5ZWFyIC0gc21yUGFyYW1zLnNtckRlcGxveW1lbnRTdGFydFllYXI7XG4gICAgc21yUmFtcEZhY3RvciA9IE1hdGgubWluKDEsIHllYXJzQWN0aXZlIC8gc21yUGFyYW1zLnNtclJhbXBVcFllYXJzKTtcbiAgICBcbiAgICAvLyBBcHBseSBjb25zdHJhaW50IHJlbGllZlxuICAgIGNvbnN0cmFpbnRSZWxpZWYgPSB7XG4gICAgICBncmlkOiBzbXJQYXJhbXMuZ3JpZENvbnN0cmFpbnRSZWxpZWYgKiBzbXJSYW1wRmFjdG9yLFxuICAgICAgY29vbGluZzogc21yUGFyYW1zLmNvb2xpbmdDb25zdHJhaW50UmVsaWVmICogc21yUmFtcEZhY3RvcixcbiAgICAgIHdhdGVyOiBzbXJQYXJhbXMud2F0ZXJDb25zdHJhaW50UmVsaWVmICogc21yUmFtcEZhY3RvcixcbiAgICAgIGxhbmQ6IHNtclBhcmFtcy5sYW5kQ29uc3RyYWludFJlbGllZiAqIHNtclJhbXBGYWN0b3IsXG4gICAgfTtcbiAgICBcbiAgICBzaXRlQ29zdEJhc2UgPSBCQVNFX1NJVEVfMjAyNSAqICgxICsgKHNtclBhcmFtcy5zbXJDYXBleFByZW1pdW0gLSAxKSAqIHNtclJhbXBGYWN0b3IpO1xuICB9XG5cbiAgLy8gUkVGQUNUT1JFRDogU3BsaXQgZW5lcmd5IChubyBtdWx0aXBsaWVyKSB2cyBjYXBhY2l0eS9kZWxpdmVyeSBwcmVtaXVtICh3aXRoIG11bHRpcGxpZXIpXG4gIC8vIFxuICAvLyBFbmVyZ3kgY29zdDogUmF3IGVsZWN0cmljaXR5IHByaWNlICoga1doIChOTyBjb25zdHJhaW50IG11bHRpcGxpZXIpXG4gIC8vIC0gUmVwcmVzZW50cyBhY3R1YWwgbWFya2V0IGVsZWN0cmljaXR5IHByaWNlXG4gIC8vIC0gR3Jvd3Mgd2l0aCBlbGVjdHJpY2l0eSBwcmljZSB0cmFqZWN0b3J5LCBub3QgaW5mcmFzdHJ1Y3R1cmUgc2NhcmNpdHlcbiAgY29uc3QgZW5lcmd5Q29zdCA9IGFjdHVhbEVuZXJneUNvc3RQZXJQZmxvcFllYXIgPz8gZW5lcmd5Q29zdEJhc2U7XG4gIGNvbnN0IGVmZmVjdGl2ZUVsZWN0cmljaXR5UHJpY2UgPSBhY3R1YWxFbGVjdHJpY2l0eVByaWNlUGVyTXdoID8/IDEyMDtcblxuICBpZiAoIWVuYWJsZWQpIHtcbiAgICAvLyBObyBjb25zdHJhaW50czogYWxsIGNvc3RzIGF0IGJhc2UsIG5vIHByZW1pdW1cbiAgICBjb25zdCB0b3RhbCA9IChlbmVyZ3lDb3N0ICsgc2l0ZUNvc3RCYXNlICsgaGFyZHdhcmVDb3N0QmFzZSkgKiBsYXRlbmN5UGVuYWx0eTtcbiAgICByZXR1cm4ge1xuICAgICAgZW5lcmd5Q29zdDogZW5lcmd5Q29zdCAqIGxhdGVuY3lQZW5hbHR5LFxuICAgICAgc2l0ZUNvc3Q6IHNpdGVDb3N0QmFzZSAqIGxhdGVuY3lQZW5hbHR5LFxuICAgICAgaGFyZHdhcmVDb3N0OiBoYXJkd2FyZUNvc3RCYXNlICogbGF0ZW5jeVBlbmFsdHksXG4gICAgICBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bTogMCwgLy8gTm8gcHJlbWl1bSB3aGVuIGNvbnN0cmFpbnRzIGRpc2FibGVkXG4gICAgICB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHk6IDAsIC8vIE5vIHF1ZXVlIGRlbGF5IHdoZW4gY29uc3RyYWludHMgZGlzYWJsZWRcbiAgICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhcjogdG90YWwsXG4gICAgICBjb25zdHJhaW50TXVsdGlwbGllcjogMS4wLFxuICAgICAgYnJlYWtkb3duOiB7IFxuICAgICAgICBncmlkOiAxLjAsIFxuICAgICAgICBjb29saW5nOiAxLjAsIFxuICAgICAgICB3YXRlcjogMS4wLCBcbiAgICAgICAgbGFuZDogMS4wLCBcbiAgICAgICAgZW5lcmd5TXVsdGlwbGllcjogMS4wLCBcbiAgICAgICAgc2l0ZU11bHRpcGxpZXI6IDEuMCxcbiAgICAgICAgY2FwYWNpdHlEZWxpdmVyeU11bHRpcGxpZXI6IDEuMCxcbiAgICAgIH0sXG4gICAgICBzbXJFbmFibGVkLFxuICAgICAgc21yUmFtcEZhY3RvcixcbiAgICAgIGVmZmVjdGl2ZUVsZWN0cmljaXR5Q29zdDogZWZmZWN0aXZlRWxlY3RyaWNpdHlQcmljZSxcbiAgICAgIGNvbnN0cmFpbnRSZWxpZWZcbiAgICB9O1xuICB9XG5cbiAgLy8gQ1JJVElDQUwgRklYOiBVc2UgcXVldWUtZGVyaXZlZCBjb25zdHJhaW50cywgTk9UIHRpbWUtYmFzZWQgZXhwb25lbnRpYWxcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgd2hlbiBOT1QgdXNpbmcgYnVpbGRvdXQvcXVldWUgbW9kZWxzIChsZWdhY3kgcGF0aClcbiAgLy8gRm9yIGNvbnNpc3RlbmN5LCB1c2UgbWluaW1hbCBjb25zdHJhaW50cyBoZXJlIChiYXNlIGNvc3RzIG9ubHkpXG4gIC8vIFJlYWwgY29uc3RyYWludCBwcmljaW5nIHNob3VsZCBjb21lIGZyb20gYnVpbGRvdXQvcXVldWUgbW9kZWxzXG4gIFxuICAvLyBHUk9VTkQgQ09TVCBBQ0NPVU5USU5HOiBFeHBsaWNpdCBzZXBhcmF0aW9uIG9mIGNvbXBvbmVudHMgKEFERElUSVZFIE9OTFkpXG4gIC8vIFxuICAvLyAxLiBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhcjogUHVyZSBhbW9ydGl6ZWQgY2FwZXhcbiAgLy8gICAgLSBCdWlsZGluZ3MgKyBwb3dlciBkZWxpdmVyeSBpbnNpZGUgc2l0ZSArIGNvb2xpbmcgcGxhbnRcbiAgLy8gICAgLSBCYXNlIGNvc3QsIE5PVCBhZmZlY3RlZCBieSBjb25zdHJhaW50XG4gIGNvbnN0IHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyID0gc2l0ZUNvc3RCYXNlO1xuICBcbiAgLy8gMi4gY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXI6IFNjYXJjaXR5IHByaWNlIGZvciBmaXJtIE1XIGF0IHJpZ2h0IHBsYWNlL3RpbWVcbiAgLy8gICAgLSBTZXQgdG8gemVybyBpbiBsZWdhY3kgcGF0aCAoY29uc3RyYWludHMgc2hvdWxkIGNvbWUgZnJvbSBidWlsZG91dC9xdWV1ZSBtb2RlbHMpXG4gIC8vICAgIC0gVGhpcyBwYXRoIGlzIG9ubHkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgY29uc3QgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXIgPSAwO1xuICBcbiAgLy8gMy4gdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyOiBGaW5hbmNpbmcgY29zdCBvZiB3YWl0aW5nIChXQUNDICsgZGVsYXkgeWVhcnMpXG4gIC8vICAgIC0gU2V0IHRvIHplcm8gaW4gbGVnYWN5IHBhdGggKGRlbGF5IHBlbmFsdGllcyBzaG91bGQgY29tZSBmcm9tIGJ1aWxkb3V0L3F1ZXVlIG1vZGVscylcbiAgLy8gICAgLSBUaGlzIHBhdGggaXMgb25seSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICBjb25zdCB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgPSAwO1xuICBcbiAgLy8gQ1JJVElDQUw6IFJlbW92ZSBkb3VibGUgY291bnRpbmdcbiAgLy8gRG8gTk9UIGluY2x1ZGUgdGltZVRvRW5lcmdpemVQZW5hbHR5IGluIGhlYWRsaW5lIGNvc3QgdXNlZCBmb3IgY3Jvc3NvdmVyXG4gIC8vIChjYXBhY2l0eSBnYXRpbmcgaW4gbWFya2V0IHNoYXJlIGFscmVhZHkgYWNjb3VudHMgZm9yIGJhY2tsb2cpXG4gIC8vIENvbXB1dGUgYm90aCBiYXNlIGFuZCBlZmZlY3RpdmUgY29zdHM6XG4gIGNvbnN0IHNpdGVDb3N0UGVyUGZsb3BZZWFyX2Jhc2UgPSBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciArIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyO1xuICBjb25zdCBzaXRlQ29zdFBlclBmbG9wWWVhcl9lZmZlY3RpdmUgPSBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciArIHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciArIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyO1xuICBcbiAgLy8gVmFsaWRhdGlvbjogc2l0ZUNvc3RfZWZmZWN0aXZlIG11c3QgZXF1YWwgc3VtIG9mIGNvbXBvbmVudHNcbiAgY29uc3Qgc2l0ZUNvc3RDaGVjayA9IE1hdGguYWJzKHNpdGVDb3N0UGVyUGZsb3BZZWFyX2VmZmVjdGl2ZSAtIChzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciArIHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciArIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyKSk7XG4gIGlmIChzaXRlQ29zdENoZWNrID4gMC4wMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgU2l0ZSBjb3N0IGFjY291bnRpbmcgZXJyb3I6IHNpdGVDb3N0X2VmZmVjdGl2ZT0ke3NpdGVDb3N0UGVyUGZsb3BZZWFyX2VmZmVjdGl2ZX0gIT0gc3VtKGNvbXBvbmVudHMpPSR7c2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgKyB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgKyBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhcn0sIGRpZmY9JHtzaXRlQ29zdENoZWNrfWApO1xuICB9XG4gIFxuICBjb25zdCBoYXJkd2FyZSA9IGhhcmR3YXJlQ29zdEJhc2U7XG5cbiAgLy8gSGVhZGxpbmUgY29zdCBmb3IgY3Jvc3NvdmVyOiBiYXNlIG9ubHkgKGV4Y2x1ZGVzIGRlbGF5IHBlbmFsdHksIHdoaWNoIGlzIGhhbmRsZWQgdmlhIGNhcGFjaXR5IGdhdGluZylcbiAgY29uc3QgdG90YWwgPSAoZW5lcmd5Q29zdCArIHNpdGVDb3N0UGVyUGZsb3BZZWFyX2Jhc2UgKyBoYXJkd2FyZSkgKiBsYXRlbmN5UGVuYWx0eTtcbiAgLy8gRWZmZWN0aXZlL2FsbC1pbiBjb3N0OiBpbmNsdWRlcyBkZWxheSBwZW5hbHR5IChmb3IgcmVmZXJlbmNlL2RlYnVnKVxuICBjb25zdCB0b3RhbEVmZmVjdGl2ZSA9IChlbmVyZ3lDb3N0ICsgc2l0ZUNvc3RQZXJQZmxvcFllYXJfZWZmZWN0aXZlICsgaGFyZHdhcmUpICogbGF0ZW5jeVBlbmFsdHk7XG4gIFxuICByZXR1cm4ge1xuICAgIGVuZXJneUNvc3Q6IGVuZXJneUNvc3QgKiBsYXRlbmN5UGVuYWx0eSwgLy8gRW5lcmd5IE5PVCBtdWx0aXBsaWVkIGJ5IGNvbnN0cmFpbnRcbiAgICBzaXRlQ29zdDogc2l0ZUNvc3RQZXJQZmxvcFllYXJfYmFzZSAqIGxhdGVuY3lQZW5hbHR5LCAvLyBTaXRlID0gYmFzZSBjb21wb25lbnRzIChleGNsdWRlcyBkZWxheSBwZW5hbHR5KVxuICAgIGhhcmR3YXJlQ29zdDogaGFyZHdhcmUgKiBsYXRlbmN5UGVuYWx0eSxcbiAgICBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhcjogc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgKiBsYXRlbmN5UGVuYWx0eSwgLy8gRXhwbGljaXQ6IHB1cmUgY2FwZXggYW1vcnRpemF0aW9uXG4gICAgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW06IGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyICogbGF0ZW5jeVBlbmFsdHksIC8vIEV4cGxpY2l0OiBzY2FyY2l0eSBwcmVtaXVtXG4gICAgdGltZVRvRW5lcmdpemVQZW5hbHR5OiB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgKiBsYXRlbmN5UGVuYWx0eSwgLy8gRXhwbGljaXQ6IFdBQ0MtYmFzZWQgcGVuYWx0eSAobm90IGluIGhlYWRsaW5lIGNvc3QpXG4gICAgdG90YWxDb3N0UGVyUGZsb3BZZWFyOiB0b3RhbCwgLy8gQmFzZSBjb3N0IChleGNsdWRlcyBkZWxheSBwZW5hbHR5IC0gaGFuZGxlZCB2aWEgY2FwYWNpdHkgZ2F0aW5nKVxuICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhckVmZmVjdGl2ZTogdG90YWxFZmZlY3RpdmUsIC8vIEVmZmVjdGl2ZS9hbGwtaW4gY29zdCAoaW5jbHVkZXMgZGVsYXkgcGVuYWx0eSlcbiAgICBjb25zdHJhaW50TXVsdGlwbGllcjogMS4wLCAvLyBOT1QgQVBQTElFRCAtIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdCBvbmx5XG4gICAgYnJlYWtkb3duOiB7IFxuICAgICAgZ3JpZDogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgY29vbGluZzogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgd2F0ZXI6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIGxhbmQ6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIGVuZXJneU11bHRpcGxpZXI6IDEuMCwgLy8gTmV2ZXIgYXBwbGllZFxuICAgICAgc2l0ZU11bHRpcGxpZXI6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIGNhcGFjaXR5RGVsaXZlcnlNdWx0aXBsaWVyOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgfSxcbiAgICBjb25zdHJhaW50czoge1xuICAgICAgbWV0aG9kOiAnYWRkZXJzJyxcbiAgICAgIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtOiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhciAqIGxhdGVuY3lQZW5hbHR5LFxuICAgICAgZGVsYXlQZW5hbHR5OiB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgKiBsYXRlbmN5UGVuYWx0eSxcbiAgICAgIGFwcGxpZWRNdWx0aXBsaWVyczoge1xuICAgICAgICBjb25zdHJhaW50TXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgICBlbmVyZ3lNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgIHNpdGVNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICB9LFxuICAgICAgZGVidWc6IHtcbiAgICAgICAgZG91YmxlQ291bnRDaGVjazoge1xuICAgICAgICAgIG1vZGU6ICdhZGRlcnMnLFxuICAgICAgICAgIG11bHRpcGxpZXJBcHBsaWVkOiBmYWxzZSxcbiAgICAgICAgICBhZGRlcnNBcHBsaWVkOiAoY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXIgPiAwKSB8fCAodGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyID4gMCksXG4gICAgICAgICAgaW52YXJpYW50T2s6IHRydWUsXG4gICAgICAgICAgbm90ZXM6ICdjYWxjdWxhdGVHcm91bmRUb3RhbCB1c2VzIGFkZGVycyBvbmx5IChjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSArIHRpbWVUb0VuZXJnaXplUGVuYWx0eSknLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIHNtckVuYWJsZWQsXG4gICAgc21yUmFtcEZhY3RvcixcbiAgICBlZmZlY3RpdmVFbGVjdHJpY2l0eUNvc3Q6IGVmZmVjdGl2ZUVsZWN0cmljaXR5UHJpY2UsXG4gICAgY29uc3RyYWludFJlbGllZixcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVQaHlzaWNzQ29zdChyYXdQYXJhbXM6IFllYXJQYXJhbXMsIGZpcnN0Q2FwWWVhcjogbnVtYmVyIHwgbnVsbCA9IG51bGwpOiBZZWFybHlCcmVha2Rvd24ge1xuICBjb25zdCBwYXJhbXMgPSBhcHBseVN0YXRpY0ZyZWV6ZShyYXdQYXJhbXMpO1xuICBcbiAgY29uc3Qge1xuICAgIHllYXIsXG4gICAgaXNTdGF0aWNNb2RlLFxuICAgIGxhdW5jaENvc3RLZzogYmFzZUxhdW5jaENvc3QsXG4gICAgc3BlY2lmaWNQb3dlcldLZzogdHJhalNwZWNpZmljUG93ZXIsXG4gICAgZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1OiByYXdHcm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjUsXG4gICAgb3JiaXRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjU6IHJhd09yYml0RWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1LFxuICAgIHB1ZUdyb3VuZCxcbiAgICBwdWVPcmJpdGFsLFxuICAgIGNhcGFjaXR5RmFjdG9yR3JvdW5kLFxuICAgIHRhcmdldEdXLFxuICAgIHNhdGVsbGl0ZVBvd2VyS1csXG4gICAgZ3JvdW5kQ29uc3RyYWludHNFbmFibGVkLFxuICAgIHBvd2VyR3JpZE11bHRpcGxpZXIsXG4gICAgY29vbGluZ011bHRpcGxpZXIsXG4gICAgd2F0ZXJTY2FyY2l0eUVuYWJsZWQsXG4gICAgbGFuZFNjYXJjaXR5RW5hYmxlZCxcbiAgICBzcGFjZVRyYWZmaWNFbmFibGVkLFxuICAgIG9yYml0YWxBbHRpdHVkZSxcbiAgICB1c2VSYWRIYXJkQ2hpcHMsXG4gICAgc3VuRnJhY3Rpb24sXG4gICAgZ3JvdW5kU2NlbmFyaW8sXG4gICAgc21yTWl0aWdhdGlvbkVuYWJsZWQsXG4gICAgd29ya2xvYWRUeXBlLFxuICAgIGVsb25TY2VuYXJpb0VuYWJsZWQsXG4gICAgZ2xvYmFsTGF0ZW5jeVJlcXVpcmVtZW50RW5hYmxlZCxcbiAgICBzcGFjZU1hbnVmYWN0dXJpbmdFbmFibGVkLFxuICAgIGFpV2ludGVyRW5hYmxlZFxuICB9ID0gcGFyYW1zO1xuICBcbiAgLy8gQ1JJVElDQUwgRklYOiBIYW5kbGUgcGFyYW1ldGVyIG5hbWUgbWlncmF0aW9uXG4gIC8vIE9sZCBuYW1lczogZmxvcHNQZXJXYXR0R3JvdW5kLCBmbG9wc1BlcldhdHRPcmJpdGFsIChERVBSRUNBVEVEIC0gZGVsZXRlIGNvbnZlcnNpb24gbG9naWMpXG4gIC8vIE5ldyBuYW1lczogZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1LCBvcmJpdEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNVxuICAvLyBQYXJhbWV0ZXJzIGFyZSBBTFJFQURZIGluIEdGTE9QUy9XIChub3QgRkxPUFMvVykgLSBubyBjb252ZXJzaW9uIG5lZWRlZFxuICBjb25zdCBhY3R1YWxHcm91bmRJbnB1dCA9IHJhd0dyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNSA/PyAocGFyYW1zIGFzIGFueSkuZ2Zsb3BzUGVyV2F0dEdyb3VuZDIwMjUgPz8gKHBhcmFtcyBhcyBhbnkpLmZsb3BzUGVyV2F0dEdyb3VuZDtcbiAgY29uc3QgYWN0dWFsT3JiaXRJbnB1dCA9IHJhd09yYml0RWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1ID8/IChwYXJhbXMgYXMgYW55KS5nZmxvcHNQZXJXYXR0T3JiaXRhbDIwMjUgPz8gKHBhcmFtcyBhcyBhbnkpLmZsb3BzUGVyV2F0dE9yYml0YWw7XG5cbiAgLy8gQ0FOT05JQ0FMIENPTVBVVEUgRUZGSUNJRU5DWTogU2luZ2xlIHNvdXJjZSBvZiB0cnV0aCBmb3IgR0ZMT1BTL1dcbiAgLy8gUGFyYW1ldGVyIGlzIGludGVycHJldGVkIGFzIEdGTE9QUy9XIChub3QgRkxPUFMvVykgLSBubyAxZTkvMWUxMiBjb252ZXJzaW9uc1xuICBsZXQgZ3JvdW5kRWZmaWNpZW5jeVJlc3VsdDtcbiAgbGV0IG9yYml0YWxFZmZpY2llbmN5UmVzdWx0O1xuICBcbiAgLy8gR3JvdW5kOiBVc2UgY2Fub25pY2FsIENvbXB1dGVFZmZpY2llbmN5IGZ1bmN0aW9uXG4gIC8vIENSSVRJQ0FMIEZJWDogUGFyYW1ldGVyIGlzIEFMUkVBRFkgaW4gR0ZMT1BTL1cgKG5vdCBGTE9QUy9XKVxuICAvLyBObyB1bml0IGNvbnZlcnNpb24gLSB0cmVhdCBpbnB1dCBhcyBlZmZlY3RpdmUgR0ZMT1BTL1cgZGlyZWN0bHlcbiAgaWYgKCFhY3R1YWxHcm91bmRJbnB1dCB8fCAhaXNGaW5pdGUoYWN0dWFsR3JvdW5kSW5wdXQpIHx8IGFjdHVhbEdyb3VuZElucHV0IDw9IDApIHtcbiAgICAvLyBJbnZhbGlkIGlucHV0IC0gdXNlIGRlZmF1bHRcbiAgICBncm91bmRFZmZpY2llbmN5UmVzdWx0ID0gZ2V0RGVmYXVsdENvbXB1dGVFZmZpY2llbmN5KCdOVklESUEgSDEwMCBTWE0nLCB5ZWFyLCAnRlAxNicpO1xuICB9IGVsc2Uge1xuICAgIC8vIElucHV0IGlzIGVmZmVjdGl2ZSBHRkxPUFMvVyAtIGRlcml2ZSBjaGlwIHBlYWsgYXNzdW1pbmcgc3RhbmRhcmQgZmFjdG9yc1xuICAgIC8vIGVmZmVjdGl2ZSA9IGNoaXBQZWFrICogdXRpbGl6YXRpb24gLyBzeXN0ZW1PdmVyaGVhZFxuICAgIC8vIFNvOiBjaGlwUGVhayA9IGVmZmVjdGl2ZSAqIHN5c3RlbU92ZXJoZWFkIC8gdXRpbGl6YXRpb25cbiAgICBjb25zdCBzeXN0ZW1PdmVyaGVhZEZhY3RvciA9IDEuMTg7IC8vIFBVRSAxLjE4IGVxdWl2YWxlbnRcbiAgICBjb25zdCB1dGlsaXphdGlvbkZhY3RvciA9IDAuNzA7XG4gICAgY29uc3QgY2hpcFBlYWtHZmxvcHNQZXJXID0gYWN0dWFsR3JvdW5kSW5wdXQgKiBzeXN0ZW1PdmVyaGVhZEZhY3RvciAvIHV0aWxpemF0aW9uRmFjdG9yO1xuICAgIFxuICAgIC8vIEZBSUwtRkFTVCBJTlZBUklBTlQ6IENoaXAgcGVhayBtdXN0IGJlIGluIHJlYWxpc3RpYyByYW5nZSBbMSwgMjAwMDBdIEdGTE9QUy9XXG4gICAgaWYgKGNoaXBQZWFrR2Zsb3BzUGVyVyA8IDEgfHwgY2hpcFBlYWtHZmxvcHNQZXJXID4gMjAwMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEdST1VORCBDT01QVVRFIEVGRklDSUVOQ1kgVU5JVCBNSVNNQVRDSDogYCArXG4gICAgICAgIGBjaGlwUGVha0dmbG9wc1Blclc9JHtjaGlwUGVha0dmbG9wc1BlclcudG9GaXhlZCgyKX0gaXMgb3V0c2lkZSB2YWxpZCByYW5nZSBbMSwgMjAwMDBdIEdGTE9QUy9XLiBgICtcbiAgICAgICAgYElucHV0OiBhY3R1YWxHcm91bmRJbnB1dD0ke2FjdHVhbEdyb3VuZElucHV0fSwgYCArXG4gICAgICAgIGBUaGlzIHN1Z2dlc3RzIGEgdW5pdHMgZXJyb3IuIEV4cGVjdGVkIHJhbmdlOiAzMC01MDAwIEdGTE9QUy9XIGZvciBzeXN0ZW0tbGV2ZWwgZWZmaWNpZW5jeS5gXG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICBncm91bmRFZmZpY2llbmN5UmVzdWx0ID0gQ29tcHV0ZUVmZmljaWVuY3koe1xuICAgICAgY2hpcFBlYWtHZmxvcHNQZXJXLFxuICAgICAgdXRpbGl6YXRpb25GYWN0b3IsXG4gICAgICBzeXN0ZW1PdmVyaGVhZEZhY3RvcixcbiAgICB9KTtcbiAgICBcbiAgICAvLyBGQUlMLUZBU1QgSU5WQVJJQU5UOiBFZmZlY3RpdmUgR0ZMT1BTL1cgbXVzdCBiZSBpbiByZWFsaXN0aWMgcmFuZ2UgWzEsIDUwMDBdIEdGTE9QUy9XXG4gICAgaWYgKGdyb3VuZEVmZmljaWVuY3lSZXN1bHQuZWZmZWN0aXZlR2Zsb3BzUGVyVyA8IDEgfHwgZ3JvdW5kRWZmaWNpZW5jeVJlc3VsdC5lZmZlY3RpdmVHZmxvcHNQZXJXID4gNTAwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgR1JPVU5EIENPTVBVVEUgRUZGSUNJRU5DWSBPVVQgT0YgUkFOR0U6IGAgK1xuICAgICAgICBgZWZmZWN0aXZlR2Zsb3BzUGVyVz0ke2dyb3VuZEVmZmljaWVuY3lSZXN1bHQuZWZmZWN0aXZlR2Zsb3BzUGVyVy50b0ZpeGVkKDIpfSBpcyBvdXRzaWRlIHZhbGlkIHJhbmdlIFsxLCA1MDAwXSBHRkxPUFMvVy4gYCArXG4gICAgICAgIGBJbnB1dDogYWN0dWFsR3JvdW5kSW5wdXQ9JHthY3R1YWxHcm91bmRJbnB1dH0sIGAgK1xuICAgICAgICBgY2hpcFBlYWtHZmxvcHNQZXJXPSR7Y2hpcFBlYWtHZmxvcHNQZXJXLnRvRml4ZWQoMil9LiBgICtcbiAgICAgICAgYFRoaXMgc3VnZ2VzdHMgYSB1bml0cyBlcnJvciBvciBpbnZhbGlkIGlucHV0LmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBPcmJpdGFsOiBTYW1lIGxvZ2ljIC0gcGFyYW1ldGVyIGlzIEFMUkVBRFkgaW4gR0ZMT1BTL1cgKG5vdCBGTE9QUy9XKVxuICAvLyBObyB1bml0IGNvbnZlcnNpb24gLSB0cmVhdCBpbnB1dCBhcyBlZmZlY3RpdmUgR0ZMT1BTL1cgZGlyZWN0bHlcbiAgaWYgKCFhY3R1YWxPcmJpdElucHV0IHx8ICFpc0Zpbml0ZShhY3R1YWxPcmJpdElucHV0KSB8fCBhY3R1YWxPcmJpdElucHV0IDw9IDApIHtcbiAgICAvLyBJbnZhbGlkIGlucHV0IC0gdXNlIGRlZmF1bHRcbiAgICBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdCA9IGdldERlZmF1bHRDb21wdXRlRWZmaWNpZW5jeSgnSDEwMC1lcXVpdmFsZW50IChyYWQtdG9sZXJhbnQpJywgeWVhciwgJ0ZQMTYnKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJbnB1dCBpcyBlZmZlY3RpdmUgR0ZMT1BTL1cgLSBkZXJpdmUgY2hpcCBwZWFrXG4gICAgY29uc3Qgc3lzdGVtT3ZlcmhlYWRGYWN0b3IgPSAxLjE4O1xuICAgIGNvbnN0IHV0aWxpemF0aW9uRmFjdG9yID0gMC42NTtcbiAgICBjb25zdCBjaGlwUGVha0dmbG9wc1BlclcgPSBhY3R1YWxPcmJpdElucHV0ICogc3lzdGVtT3ZlcmhlYWRGYWN0b3IgLyB1dGlsaXphdGlvbkZhY3RvcjtcbiAgICBcbiAgICAvLyBGQUlMLUZBU1QgSU5WQVJJQU5UOiBDaGlwIHBlYWsgbXVzdCBiZSBpbiByZWFsaXN0aWMgcmFuZ2UgWzEsIDIwMDAwXSBHRkxPUFMvV1xuICAgIGlmIChjaGlwUGVha0dmbG9wc1BlclcgPCAxIHx8IGNoaXBQZWFrR2Zsb3BzUGVyVyA+IDIwMDAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBPUkJJVEFMIENPTVBVVEUgRUZGSUNJRU5DWSBVTklUIE1JU01BVENIOiBgICtcbiAgICAgICAgYGNoaXBQZWFrR2Zsb3BzUGVyVz0ke2NoaXBQZWFrR2Zsb3BzUGVyVy50b0ZpeGVkKDIpfSBpcyBvdXRzaWRlIHZhbGlkIHJhbmdlIFsxLCAyMDAwMF0gR0ZMT1BTL1cuIGAgK1xuICAgICAgICBgSW5wdXQ6IGFjdHVhbE9yYml0SW5wdXQ9JHthY3R1YWxPcmJpdElucHV0fSwgYCArXG4gICAgICAgIGBUaGlzIHN1Z2dlc3RzIGEgdW5pdHMgZXJyb3IuIEV4cGVjdGVkIHJhbmdlOiAyNS00MDAwIEdGTE9QUy9XIGZvciBzeXN0ZW0tbGV2ZWwgZWZmaWNpZW5jeS5gXG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdCA9IENvbXB1dGVFZmZpY2llbmN5KHtcbiAgICAgIGNoaXBQZWFrR2Zsb3BzUGVyVyxcbiAgICAgIHV0aWxpemF0aW9uRmFjdG9yLFxuICAgICAgc3lzdGVtT3ZlcmhlYWRGYWN0b3IsXG4gICAgfSk7XG4gICAgXG4gICAgLy8gRkFJTC1GQVNUIElOVkFSSUFOVDogRWZmZWN0aXZlIEdGTE9QUy9XIG11c3QgYmUgaW4gcmVhbGlzdGljIHJhbmdlIFsxLCA1MDAwXSBHRkxPUFMvV1xuICAgIGlmIChvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5lZmZlY3RpdmVHZmxvcHNQZXJXIDwgMSB8fCBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5lZmZlY3RpdmVHZmxvcHNQZXJXID4gNTAwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgT1JCSVRBTCBDT01QVVRFIEVGRklDSUVOQ1kgT1VUIE9GIFJBTkdFOiBgICtcbiAgICAgICAgYGVmZmVjdGl2ZUdmbG9wc1Blclc9JHtvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5lZmZlY3RpdmVHZmxvcHNQZXJXLnRvRml4ZWQoMil9IGlzIG91dHNpZGUgdmFsaWQgcmFuZ2UgWzEsIDUwMDBdIEdGTE9QUy9XLiBgICtcbiAgICAgICAgYElucHV0OiBhY3R1YWxPcmJpdElucHV0PSR7YWN0dWFsT3JiaXRJbnB1dH0sIGAgK1xuICAgICAgICBgY2hpcFBlYWtHZmxvcHNQZXJXPSR7Y2hpcFBlYWtHZmxvcHNQZXJXLnRvRml4ZWQoMil9LiBgICtcbiAgICAgICAgYFRoaXMgc3VnZ2VzdHMgYSB1bml0cyBlcnJvciBvciBpbnZhbGlkIGlucHV0LmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBIQVJEIEFTU0VSVDogR3JvdW5kIGVmZmljaWVuY3kgbXVzdCBhbHdheXMgYmUgcG9wdWxhdGVkIGFuZCBmaW5pdGVcbiAgaWYgKCFncm91bmRFZmZpY2llbmN5UmVzdWx0IHx8ICFpc0Zpbml0ZShncm91bmRFZmZpY2llbmN5UmVzdWx0LmVmZmVjdGl2ZUdmbG9wc1BlclcpIHx8IGdyb3VuZEVmZmljaWVuY3lSZXN1bHQuZWZmZWN0aXZlR2Zsb3BzUGVyVyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENSSVRJQ0FMOiBHcm91bmQgY29tcHV0ZSBlZmZpY2llbmN5IGlzIGludmFsaWQuIGAgK1xuICAgICAgYGFjdHVhbEdyb3VuZElucHV0PSR7YWN0dWFsR3JvdW5kSW5wdXR9LCBgICtcbiAgICAgIGByYXdHcm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjU9JHtyYXdHcm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjV9LCBgICtcbiAgICAgIGBnZmxvcHNQZXJXYXR0R3JvdW5kMjAyNT0keyhwYXJhbXMgYXMgYW55KS5nZmxvcHNQZXJXYXR0R3JvdW5kMjAyNX0sIGAgK1xuICAgICAgYGdyb3VuZEVmZmljaWVuY3lSZXN1bHQ9JHtKU09OLnN0cmluZ2lmeShncm91bmRFZmZpY2llbmN5UmVzdWx0KX1gXG4gICAgKTtcbiAgfVxuICBcbiAgLy8gQ1JJVElDQUwgRklYOiBTdGFuZGFyZGl6ZSBjb21wdXRlLWVmZmljaWVuY3kgbGV2ZWwgZGVmaW5pdGlvbnNcbiAgLy8gU3RhbmRhcmQgZGVmaW5pdGlvbnM6XG4gIC8vIC0gcGVha0dmbG9wc1BlcldhdHQ6IGNoaXAgcGVhayAobm8gdXRpbGl6YXRpb24sIG5vIG92ZXJoZWFkLCBubyBkZXJhdGVzKVxuICAvLyAtIHN5c3RlbUVmZmVjdGl2ZUdmbG9wc1BlcldhdHQ6IHBlYWsgKiB1dGlsaXphdGlvbiAvIHN5c3RlbU92ZXJoZWFkRmFjdG9yIChTWVNURU0tTEVWRUwgRUZGRUNUSVZFKVxuICAvLyAtIGRlbGl2ZXJlZEdmbG9wc1BlcldhdHQ6IHN5c3RlbUVmZmVjdGl2ZSAqIHRoZXJtYWxDYXBGYWN0b3IgKiByYWRpYXRpb25EZXJhdGUgKiBhdmFpbGFiaWxpdHlcbiAgXG4gIC8vIEdyb3VuZDogc3lzdGVtRWZmZWN0aXZlIG9ubHkgKG5vIGRlbGl2ZXJ5IGRlcmF0ZXMpXG4gIGNvbnN0IGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlclcgPSB2YWxpZGF0ZUdmbG9wc1BlcldhdHQoXG4gICAgZ3JvdW5kRWZmaWNpZW5jeVJlc3VsdC5lZmZlY3RpdmVHZmxvcHNQZXJXLFxuICAgICdncm91bmQgZWZmaWNpZW5jeSBjYWxjdWxhdGlvbidcbiAgKTtcbiAgXG4gIC8vIE9yYml0YWw6IFRyYWNrIGFsbCB0aHJlZSBsZXZlbHNcbiAgY29uc3Qgb3JiaXRQZWFrR2Zsb3BzUGVyV2F0dCA9IG9yYml0YWxFZmZpY2llbmN5UmVzdWx0LmRlYnVnLmNoaXBQZWFrR2Zsb3BzUGVyVztcbiAgY29uc3Qgb3JiaXRTeXN0ZW1FZmZlY3RpdmVHZmxvcHNQZXJXYXR0ID0gdmFsaWRhdGVHZmxvcHNQZXJXYXR0KFxuICAgIG9yYml0YWxFZmZpY2llbmN5UmVzdWx0LmVmZmVjdGl2ZUdmbG9wc1BlclcsXG4gICAgJ29yYml0YWwgc3lzdGVtRWZmZWN0aXZlIGVmZmljaWVuY3kgY2FsY3VsYXRpb24nXG4gICk7XG4gIFxuICAvLyBOT1RFOiBkZWxpdmVyZWRHZmxvcHNQZXJXYXR0IHdpbGwgYmUgY2FsY3VsYXRlZCBhZnRlciB0aGVybWFsIHN5c3RlbSBpcyBjb21wdXRlZFxuICAvLyBJdCB3aWxsIGJlOiBzeXN0ZW1FZmZlY3RpdmUgKiB0aGVybWFsQ2FwRmFjdG9yICogcmFkaWF0aW9uRGVyYXRlICogYXZhaWxhYmlsaXR5XG5cbiAgLy8gQUkgV2ludGVyOiBDb25zdHJhaW50cyBncm93IDUwJSBzbG93ZXJcbiAgY29uc3QgZWZmZWN0aXZlR3JvdW5kU2NlbmFyaW8gPSBhaVdpbnRlckVuYWJsZWQgJiYgeWVhciA+PSAyMDI4ID8ge1xuICAgIC4uLkdST1VORF9TQ0VOQVJJT1NbZ3JvdW5kU2NlbmFyaW9dLFxuICAgIGdyaWRHcm93dGhSYXRlOiBHUk9VTkRfU0NFTkFSSU9TW2dyb3VuZFNjZW5hcmlvXS5ncmlkR3Jvd3RoUmF0ZSAqIDAuNSxcbiAgICBjb29saW5nR3Jvd3RoUmF0ZTogR1JPVU5EX1NDRU5BUklPU1tncm91bmRTY2VuYXJpb10uY29vbGluZ0dyb3d0aFJhdGUgKiAwLjUsXG4gICAgd2F0ZXJHcm93dGhSYXRlOiBHUk9VTkRfU0NFTkFSSU9TW2dyb3VuZFNjZW5hcmlvXS53YXRlckdyb3d0aFJhdGUgKiAwLjUsXG4gICAgbGFuZEdyb3d0aFJhdGU6IEdST1VORF9TQ0VOQVJJT1NbZ3JvdW5kU2NlbmFyaW9dLmxhbmRHcm93dGhSYXRlICogMC41LFxuICB9IDogR1JPVU5EX1NDRU5BUklPU1tncm91bmRTY2VuYXJpb107XG5cbiAgLy8gRWxvbiBTY2VuYXJpbzogRGlzY291bnRzXG4gIGNvbnN0IGxhdW5jaERpc2NvdW50ID0gZWxvblNjZW5hcmlvRW5hYmxlZCA/IDAuNTAgOiAxLjA7XG4gIGNvbnN0IHBvd2VyRGlzY291bnQgPSBlbG9uU2NlbmFyaW9FbmFibGVkID8gMC43MCA6IDEuMDtcbiAgY29uc3QgbmV0d29ya2luZ0Rpc2NvdW50ID0gZWxvblNjZW5hcmlvRW5hYmxlZCA/IDAuMTAgOiAxLjA7XG4gIGNvbnN0IG9wZXJhdG9yTWFyZ2luID0gZWxvblNjZW5hcmlvRW5hYmxlZCA/IDAuMDUgOiAwLjIwO1xuXG4gIC8vIEdsb2JhbCBMYXRlbmN5OiAzeCBncm91bmQgb3ZlcnByb3Zpc2lvbmluZyBwZW5hbHR5XG4gIGNvbnN0IGdyb3VuZExhdGVuY3lQZW5hbHR5ID0gKGdsb2JhbExhdGVuY3lSZXF1aXJlbWVudEVuYWJsZWQgJiYgeWVhciA+PSAyMDI4KSA/IDMuMCA6IDEuMDtcblxuICAvLyBTcGFjZSBNYW51ZmFjdHVyaW5nOiBNYXNzIHJlZHVjdGlvblxuICBsZXQgbWFzc011bHRpcGxpZXIgPSAxLjA7XG4gIGlmIChzcGFjZU1hbnVmYWN0dXJpbmdFbmFibGVkICYmIHllYXIgPj0gMjAzMikge1xuICAgIGNvbnN0IHllYXJzU2luY2VTdGFydCA9IHllYXIgLSAyMDMyO1xuICAgIGNvbnN0IHJhbXAgPSBNYXRoLm1pbigxLjAsIHllYXJzU2luY2VTdGFydCAvIDUpO1xuICAgIG1hc3NNdWx0aXBsaWVyID0gMS4wIC0gKDAuNjAgKiByYW1wKTtcbiAgfVxuXG4gIC8vIEVNRVJHRU5DWSBGSVg6IFVzZSBzaW1wbGUgZml4ZWQgMjAyNSBiYXNlIHZhbHVlc1xuICAvLyBUaGVzZSBhcmUgdGhlIGtub3duLWNvcnJlY3QgdmFsdWVzIGZyb20gdGhlIGVtZXJnZW5jeSBmaXhcbiAgLy8gRG9uJ3QgdHJ5IHRvIGNhbGN1bGF0ZSBmcm9tIGZsb3BzUGVyV2F0dCAtIGp1c3QgdXNlIHRoZXNlIGNvbnN0YW50c1xuICBjb25zdCBCQVNFX0VORVJHWV8yMDI1ID0gNTgxOyAgICAgIC8vICQvUEZMT1AteWVhciAoZml4ZWQgMjAyNSBiYXNlKVxuICBjb25zdCBCQVNFX1NJVEVfMjAyNSA9IDE1MDA7ICAgICAgLy8gJC9QRkxPUC15ZWFyIChmaXhlZCAyMDI1IGJhc2UpXG4gIGNvbnN0IEVORVJHWV9DT1NUX0JBU0VfMjAyNSA9IEJBU0VfRU5FUkdZXzIwMjU7IC8vIFVzZSBmaXhlZCBiYXNlLCBub3QgY2FsY3VsYXRlZFxuICBcbiAgLy8gRm9yIHJlZmVyZW5jZS9kaXNwbGF5IChub3QgdXNlZCBpbiBjb25zdHJhaW50IGNhbGN1bGF0aW9uKVxuICBjb25zdCBCQVNFX0VMRUNUUklDSVRZX1BSSUNFXzIwMjUgPSAxMjA7IC8vICQvTVdoICgyMDI1IGJhc2VsaW5lKVxuICBsZXQgZ3JvdW5kRWxlY3RyaWNpdHlQcmljZVBlck13aCA9IEJBU0VfRUxFQ1RSSUNJVFlfUFJJQ0VfMjAyNTsgXG4gIGlmICghcGFyYW1zLmlzU3RhdGljTW9kZSkge1xuICAgIGdyb3VuZEVsZWN0cmljaXR5UHJpY2VQZXJNd2ggKj0gTWF0aC5wb3coMS4wMiwgeWVhciAtIDIwMjUpO1xuICB9XG4gIFxuICBjb25zdCBlZmZlY3RpdmVQdWVHcm91bmQgPSBwdWVHcm91bmQgKyAoKHllYXIgLSAyMDI1KSAqIDAuMDEpO1xuICAvLyBDb252ZXJ0IEdGTE9QUy9XIHRvIHBvd2VyOiAxIFBGTE9QID0gMWU2IEdGTE9QUywgc28gcG93ZXIgKFcpID0gKDFlNiBHRkxPUFMpIC8gKEdGTE9QUy9XKVxuICBjb25zdCBncm91bmRFbmVyZ3lNV2hQZXJQZmxvcFllYXIgPSAoODc2MCAqIDFlNiAvIGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlclcpICogZWZmZWN0aXZlUHVlR3JvdW5kIC8gMWU2O1xuICBjb25zdCBncm91bmRFbmVyZ3lDb3N0UGVyUGZsb3BZZWFyID0gZ3JvdW5kRW5lcmd5TVdoUGVyUGZsb3BZZWFyICogKGdyb3VuZEVsZWN0cmljaXR5UHJpY2VQZXJNd2gpICogY2FwYWNpdHlGYWN0b3JHcm91bmQ7XG5cbiAgY29uc3QgY29tcHV0ZUdyb3VuZEhhcmR3YXJlQ29zdCA9ICh5OiBudW1iZXIsIGJhc2VDb3N0OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCB5ZWFySW5kZXggPSB5IC0gMjAyNTtcbiAgICBsZXQgY29zdCA9IGJhc2VDb3N0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeWVhckluZGV4OyBpKyspIHtcbiAgICAgIGxldCBhbm51YWxEZWNsaW5lO1xuICAgICAgaWYgKGkgPCAzKSBhbm51YWxEZWNsaW5lID0gMC4xMDtcbiAgICAgIGVsc2UgaWYgKGkgPCA2KSBhbm51YWxEZWNsaW5lID0gMC4wNTtcbiAgICAgIGVsc2UgaWYgKGkgPCAxMCkgYW5udWFsRGVjbGluZSA9IDAuMDI7XG4gICAgICBlbHNlIGFubnVhbERlY2xpbmUgPSAwLjAwNTtcbiAgICAgIGNvc3QgKj0gKDEgLSBhbm51YWxEZWNsaW5lKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvc3Q7XG4gIH07XG4gIGNvbnN0IGdyb3VuZExpZmV0aW1lID0gcGFyYW1zLmdyb3VuZEhhcmR3YXJlTGlmZXRpbWVZZWFycyA/PyBDT05TVEFOVFMuR1JPVU5EX0hBUkRXQVJFX0xJRkVUSU1FO1xuICBjb25zdCBncm91bmRIYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyID0gY29tcHV0ZUdyb3VuZEhhcmR3YXJlQ29zdCh5ZWFyLCBDT05TVEFOVFMuR1JPVU5EX0hBUkRXQVJFX0NPU1RfUEZMT1BfMjAyNSkgLyBncm91bmRMaWZldGltZTtcblxuICBjb25zdCBzbXJQYXJhbXMgPSBwYXJhbXMuc21yVG9nZ2xlRW5hYmxlZCA/IChwYXJhbXMuc21yVG9nZ2xlUGFyYW1zIHx8IERFRkFVTFRfU01SX1BBUkFNUykgOiB1bmRlZmluZWQ7XG4gIFxuICBsZXQgZ3JvdW5kUmVzdWx0O1xuICBsZXQgZ3JvdW5kVG90YWxDb3N0OiBudW1iZXI7XG4gIGxldCBncm91bmRDb21wYXJhdG9yQ29zdFBlclBmbG9wWWVhcjogbnVtYmVyOyAvLyBDb21wYXJhdG9yIGNvc3QgZm9yIGNyb3Nzb3ZlciAodXNlcyBlZmZlY3RpdmUgd2hlbiBxdWV1ZSBleGlzdHMpXG4gIGxldCBncm91bmRIYXNRdWV1ZTogYm9vbGVhbiA9IGZhbHNlOyAvLyBUcmFjayBpZiBncm91bmQgaGFzIHF1ZXVlL2JhY2tsb2cgKGZvciBkZWJ1ZyBhbmQgY29tcGFyYXRvciBjb3N0KVxuICBsZXQgZW5lcmd5Q29uc3RyYWludE11bHRpcGxpZXI6IG51bWJlcjtcbiAgbGV0IGNvbnN0cmFpbnRCcmVha2Rvd246IHtcbiAgICBncmlkOiBudW1iZXI7XG4gICAgY29vbGluZzogbnVtYmVyO1xuICAgIHdhdGVyOiBudW1iZXI7XG4gICAgbGFuZDogbnVtYmVyO1xuICAgIGVuZXJneU11bHRpcGxpZXI6IG51bWJlcjtcbiAgICBzaXRlTXVsdGlwbGllcjogbnVtYmVyO1xuICAgIGNhcGFjaXR5RGVsaXZlcnlNdWx0aXBsaWVyPzogbnVtYmVyO1xuICB9O1xuICBcbiAgY29uc3QgdXNlUmVnaW9uYWxNb2RlbCA9IHBhcmFtcy51c2VSZWdpb25hbEdyb3VuZE1vZGVsID09PSB0cnVlICYmIHBhcmFtcy5ncm91bmRDb25zdHJhaW50c0VuYWJsZWQgJiYgIXBhcmFtcy5pc1N0YXRpY01vZGU7XG4gIFxuICAvLyBGSVg6IE1ha2UgYnVpbGRvdXQgbW9kZWwgdGhlIGRlZmF1bHQgKGl0IGNvcnJlY3RseSB1c2VzIHJlc3BvbnNpdmUgZGVtYW5kKVxuICAvLyBRdWV1ZSBtb2RlbCByZXF1aXJlcyBmdWxsIGRlbWFuZCB0cmFqZWN0b3J5IHRvIHdvcmsgY29ycmVjdGx5LCBzbyBpdCdzIG9wdC1pbiBvbmx5XG4gIC8vIE9ubHkgdXNlIHF1ZXVlIG1vZGVsIGlmIGV4cGxpY2l0bHkgZW5hYmxlZCAodXNlUXVldWVCYXNlZENvbnN0cmFpbnQgPT09IHRydWUpXG4gIGNvbnN0IHVzZVF1ZXVlTW9kZWwgPSBwYXJhbXMudXNlUXVldWVCYXNlZENvbnN0cmFpbnQgPT09IHRydWUgJiYgcGFyYW1zLmdyb3VuZENvbnN0cmFpbnRzRW5hYmxlZCAmJiAhcGFyYW1zLmlzU3RhdGljTW9kZSAmJiAhdXNlUmVnaW9uYWxNb2RlbDtcbiAgLy8gQnVpbGRvdXQgbW9kZWwgaXMgdGhlIGRlZmF1bHQgKGRlZmF1bHRzIHRvIHRydWUgdW5sZXNzIGV4cGxpY2l0bHkgZGlzYWJsZWQpXG4gIGNvbnN0IHVzZUJ1aWxkb3V0TW9kZWwgPSAocGFyYW1zLnVzZUJ1aWxkb3V0TW9kZWwgIT09IGZhbHNlKSAmJiBwYXJhbXMuZ3JvdW5kQ29uc3RyYWludHNFbmFibGVkICYmICFwYXJhbXMuaXNTdGF0aWNNb2RlICYmICF1c2VSZWdpb25hbE1vZGVsICYmICF1c2VRdWV1ZU1vZGVsO1xuICBcbiAgaWYgKHVzZVF1ZXVlTW9kZWwpIHtcbiAgICAvLyBXQVJOSU5HOiBRdWV1ZSBtb2RlbCByZXF1aXJlcyBmdWxsIGRlbWFuZCB0cmFqZWN0b3J5IHRvIHdvcmsgY29ycmVjdGx5XG4gICAgLy8gQ3VycmVudGx5IG9ubHkgcmVjZWl2ZXMgY3VycmVudCB5ZWFyJ3MgcmVzcG9uc2l2ZSBkZW1hbmQsIHNvIHByZXZpb3VzIHllYXJzIHVzZSBoYXJkY29kZWQgZGVtYW5kXG4gICAgLy8gUkVDT01NRU5ERUQ6IFVzZSBidWlsZG91dCBtb2RlbCBpbnN0ZWFkIChkZWZhdWx0KSB3aGljaCBjb3JyZWN0bHkgaGFuZGxlcyByZXNwb25zaXZlIGRlbWFuZFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW1FVRVVFIE1PREVMXSBZZWFyICR7eWVhcn06IFF1ZXVlIG1vZGVsIGlzIGVuYWJsZWQgYnV0IG9ubHkgcmVjZWl2ZXMgY3VycmVudCB5ZWFyJ3MgcmVzcG9uc2l2ZSBkZW1hbmQuIGAgK1xuICAgICAgICBgUHJldmlvdXMgeWVhcnMgKDIwMjUtJHt5ZWFyLTF9KSB3aWxsIHVzZSBoYXJkY29kZWQgZXhwb25lbnRpYWwgZGVtYW5kLiBgICtcbiAgICAgICAgYEZvciBhY2N1cmF0ZSBTLWN1cnZlIGJlaGF2aW9yLCB1c2UgYnVpbGRvdXQgbW9kZWwgKGRlZmF1bHQpIGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUGFzcyByZXNwb25zaXZlIGRlbWFuZCBhbmQgb3JiaXRhbCBzdWJzdGl0dXRpb24gdG8gcXVldWUgbW9kZWwgKGlmIGF2YWlsYWJsZSBmcm9tIHRyYWplY3RvcnkudHMpXG4gICAgY29uc3QgcmVzcG9uc2l2ZURlbWFuZEdXID0gKHBhcmFtcyBhcyBhbnkpLnJlc3BvbnNpdmVEZW1hbmRHVyBhcyBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb3JiaXRhbFN1YnN0aXR1dGlvbkdXID0gKHBhcmFtcyBhcyBhbnkpLm9yYml0YWxTdWJzdGl0dXRpb25HVyBhcyBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgXG4gICAgLy8gQnVpbGQgZGVtYW5kIG1hcCBpZiByZXNwb25zaXZlIGRlbWFuZCBpcyBwcm92aWRlZFxuICAgIC8vIE5PVEU6IE9ubHkgY3VycmVudCB5ZWFyIGlzIHBhc3NlZCAtIHByZXZpb3VzIHllYXJzIHdpbGwgdXNlIGhhcmRjb2RlZCBkZW1hbmRcbiAgICBjb25zdCBkZW1hbmRCeVllYXIgPSByZXNwb25zaXZlRGVtYW5kR1cgIT09IHVuZGVmaW5lZCBcbiAgICAgID8gbmV3IE1hcChbW3llYXIsIHJlc3BvbnNpdmVEZW1hbmRHV11dKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb3JiaXRhbFN1YnN0aXR1dGlvbkJ5WWVhciA9IG9yYml0YWxTdWJzdGl0dXRpb25HVyAhPT0gdW5kZWZpbmVkXG4gICAgICA/IG5ldyBNYXAoW1t5ZWFyLCBvcmJpdGFsU3Vic3RpdHV0aW9uR1ddXSlcbiAgICAgIDogdW5kZWZpbmVkO1xuICAgIFxuICAgIGNvbnN0IHN1cHBseVRyYWplY3RvcnkgPSBnZW5lcmF0ZUdyb3VuZFN1cHBseVRyYWplY3RvcnkoMjAyNSwgeWVhciwgZGVtYW5kQnlZZWFyLCBvcmJpdGFsU3Vic3RpdHV0aW9uQnlZZWFyKTtcbiAgICBjb25zdCBjdXJyZW50U3VwcGx5U3RhdGUgPSBzdXBwbHlUcmFqZWN0b3J5W3N1cHBseVRyYWplY3RvcnkubGVuZ3RoIC0gMV07XG4gICAgXG4gICAgLy8gRGVidWc6IExvZyBpZiByZXNwb25zaXZlIGRlbWFuZCBpcyBiZWluZyB1c2VkXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIHJlc3BvbnNpdmVEZW1hbmRHVyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBoYXJkY29kZWREZW1hbmQgPSBnZXRHbG9iYWxEZW1hbmRHdyh5ZWFyKTtcbiAgICAgIGlmIChNYXRoLmFicyhjdXJyZW50U3VwcGx5U3RhdGUuZGVtYW5kR3cgLSBoYXJkY29kZWREZW1hbmQpIDwgMWUtNikge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFtRVUVVRSBNT0RFTCBERUJVR10gWWVhciAke3llYXJ9OiBSZXNwb25zaXZlIGRlbWFuZCAoJHtyZXNwb25zaXZlRGVtYW5kR1cudG9GaXhlZCgyKX0gR1cpIHdhcyBpZ25vcmVkLiBgICtcbiAgICAgICAgICBgUXVldWUgbW9kZWwgdXNpbmcgaGFyZGNvZGVkOiAke2N1cnJlbnRTdXBwbHlTdGF0ZS5kZW1hbmRHdy50b0ZpeGVkKDIpfSBHV2BcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGBbUVVFVUUgTU9ERUwgREVCVUddIFllYXIgJHt5ZWFyfTogVXNpbmcgcmVzcG9uc2l2ZSBkZW1hbmQgJHtyZXNwb25zaXZlRGVtYW5kR1cudG9GaXhlZCgyKX0gR1cgYCArXG4gICAgICAgICAgYChxdWV1ZSBtb2RlbDogJHtjdXJyZW50U3VwcGx5U3RhdGUuZGVtYW5kR3cudG9GaXhlZCgyKX0gR1cpYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgV0FDQy1iYXNlZCBwZW5hbHRpZXMgYW5kIG11bHRpcGxpZXJzXG4gICAgLy8gUGFzcyBXQUNDIHBhcmFtZXRlcnMgZm9yIGNhcGl0YWwgcmF0aW9uaW5nIChXQUNDIHJpc2VzIHdpdGggYmFja2xvZylcbiAgICBjb25zdCB3YWNjUGFyYW1zID0ge1xuICAgICAgYmFzZVdhY2M6IHBhcmFtcy53YWNjID8/IDAuMTAsXG4gICAgICB3YWNjQmFja2xvZ0s6IHBhcmFtcy53YWNjQmFja2xvZ0sgPz8gMC41LFxuICAgICAgd2FjY0JhY2tsb2dFeHBvbmVudDogcGFyYW1zLndhY2NCYWNrbG9nRXhwb25lbnQgPz8gMS4yLFxuICAgICAgY3JpdGljYWxCYWNrbG9nR1c6IHBhcmFtcy5jcml0aWNhbEJhY2tsb2dHVyA/PyA1MCxcbiAgICB9O1xuICAgIGNvbnN0IHBlbmFsdGllcyA9IGNhbGN1bGF0ZUdyb3VuZENvbnN0cmFpbnRQZW5hbHRpZXMoXG4gICAgICBjdXJyZW50U3VwcGx5U3RhdGUsXG4gICAgICBncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXLFxuICAgICAgZWZmZWN0aXZlUHVlR3JvdW5kLFxuICAgICAgY2FwYWNpdHlGYWN0b3JHcm91bmQsXG4gICAgICB3YWNjUGFyYW1zXG4gICAgKTtcbiAgICBcbiAgICBjb25zdCBCQVNFX1NJVEVfMjAyNSA9IDE1MDA7XG4gICAgXG4gICAgLy8gRW5lcmd5IGNvc3Q6IFVzZSBhY3R1YWwgY2FsY3VsYXRlZCB2YWx1ZSAoTk9UIG11bHRpcGxpZWQgYnkgY29uc3RyYWludClcbiAgICAvLyBDUklUSUNBTCBGSVg6IERvIE5PVCBhcHBseSBQVUUgbXVsdGlwbGllciAtIGVuZXJneSBjb3N0IGlzIGJhc2Ugb25seVxuICAgIC8vIFBVRSBzdHJlc3Mgc2hvdWxkIGJlIHJlZmxlY3RlZCBpbiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSwgbm90IGVuZXJneSBtdWx0aXBsaWVyXG4gICAgY29uc3QgZW5lcmd5Q29zdEJhc2UgPSBncm91bmRFbmVyZ3lDb3N0UGVyUGZsb3BZZWFyO1xuICAgIGNvbnN0IGVuZXJneUNvc3QgPSBlbmVyZ3lDb3N0QmFzZTsgLy8gQmFzZSBlbmVyZ3kgY29zdCBvbmx5IC0gbm8gbXVsdGlwbGllclxuICAgIFxuICAgIC8vIEdST1VORCBDT1NUIEFDQ09VTlRJTkc6IEV4cGxpY2l0IHNlcGFyYXRpb24gb2YgY29tcG9uZW50cyAocXVldWUgbW9kZWwpXG4gICAgY29uc3Qgc2l0ZUNvc3RCYXNlID0gQkFTRV9TSVRFXzIwMjU7XG4gICAgXG4gICAgLy8gMS4gc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXI6IFB1cmUgYW1vcnRpemVkIGNhcGV4IChOT1QgYWZmZWN0ZWQgYnkgY29uc3RyYWludClcbiAgICBjb25zdCBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciA9IHNpdGVDb3N0QmFzZTtcbiAgICBcbiAgICAvLyBDSE9JQ0U6IFVzZSBkZWxheVBlbmFsdHkgKyBzY2FyY2l0eVJlbnQgKEhpbGwtYmFzZWQpLCBOT1QgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1cbiAgICAvLyBTZXQgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gdG8gMCB0byBhdm9pZCB0cmlwbGUtY2hhcmdpbmdcbiAgICBjb25zdCBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhciA9IDA7IC8vIE5PVCBVU0VEIC0gdXNpbmcgZGVsYXlQZW5hbHR5ICsgc2NhcmNpdHlSZW50IGluc3RlYWRcbiAgICBcbiAgICAvLyAxLiB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXI6IEJvdW5kZWQgbGluZWFyIFdBQ0MgY2FycnkgKE5PVCBleHBvbmVudGlhbClcbiAgICBjb25zdCB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgPSBwZW5hbHRpZXMudGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyO1xuICAgIFxuICAgIC8vIDIuIHNjYXJjaXR5UmVudFBlclBmbG9wWWVhcjogSGlsbCBmdW5jdGlvbiBvZiBhdmdXYWl0WWVhcnMgKHc1MD0yLjAsIG49Mi4wLCByZW50TWF4PTAuNjUpXG4gICAgLy8gQmFzZSBjb3N0IGZvciBzY2FyY2l0eSByZW50ID0gaGFyZHdhcmUgKyBzaXRlIChubyBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSlcbiAgICBjb25zdCBjYXBleEFubnVhbEJhc2VQZXJQZmxvcFllYXIgPSBcbiAgICAgIGdyb3VuZEhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXIgK1xuICAgICAgc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXI7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHNjYXJjaXR5IG11bHRpcGxpZXIgdXNpbmcgTE9HLUJBU0VEIGZ1bmN0aW9uIChuZXZlciBmdWxseSBzYXR1cmF0ZXMpXG4gICAgLy8gUmV0dXJucyBtdWx0aXBsaWVyICgxLjAgPSBubyBzY2FyY2l0eSwgMi4wID0gMnggcHJpY2UpIC0gTVVMVElQTElDQVRJVkUsIG5vdCBhZGRpdGl2ZVxuICAgIGNvbnN0IHNjYXJjaXR5UmVudFJlc3VsdCA9IGNhbGN1bGF0ZVNjYXJjaXR5UmVudChcbiAgICAgIGN1cnJlbnRTdXBwbHlTdGF0ZS5hdmdXYWl0WWVhcnMsXG4gICAgICBjdXJyZW50U3VwcGx5U3RhdGUudXRpbGl6YXRpb25QY3QsIC8vIFBhc3MgdXRpbGl6YXRpb24gZm9yIHRocmVzaG9sZCBnYXRlXG4gICAgICB7XG4gICAgICAgIHdhaXRUaHJlc2hvbGRZZWFyczogMS4wLCAvLyBNaW5pbXVtIHdhaXQgYmVmb3JlIHNjYXJjaXR5IGFjdGl2YXRlc1xuICAgICAgICByZW50TWF4TXVsdGlwbGllcjogMi4wLCAvLyBNYXhpbXVtIHByaWNlIG11bHRpcGxpZXIgKDJ4ID0gMTAwJSBpbmNyZWFzZSlcbiAgICAgICAgdXRpbGl6YXRpb25UaHJlc2hvbGQ6IDAuODUsIC8vIFV0aWxpemF0aW9uIHRocmVzaG9sZFxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3Qgc2NhcmNpdHlNdWx0aXBsaWVyID0gc2NhcmNpdHlSZW50UmVzdWx0LnNjYXJjaXR5TXVsdGlwbGllcjtcbiAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eTogc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyID0gMCAoc2NhcmNpdHkgaXMgbm93IG11bHRpcGxpY2F0aXZlKVxuICAgIGNvbnN0IHNjYXJjaXR5UmVudFBlclBmbG9wWWVhciA9IDA7XG4gICAgXG4gICAgLy8gRGVidWc6IHZlcmlmeSBxdWV1ZSBtb2RlbCBjb25zaXN0ZW5jeVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgY29uc3QgdW5zZXJ2ZWRHdyA9IGN1cnJlbnRTdXBwbHlTdGF0ZS51bnNlcnZlZEd3ID8/IChjdXJyZW50U3VwcGx5U3RhdGUuZGVtYW5kR3cgLSBjdXJyZW50U3VwcGx5U3RhdGUuY2FwYWNpdHlHdyk7XG4gICAgICBpZiAoY3VycmVudFN1cHBseVN0YXRlLmRlbWFuZEd3IDwgY3VycmVudFN1cHBseVN0YXRlLmNhcGFjaXR5R3cgJiYgY3VycmVudFN1cHBseVN0YXRlLmJhY2tsb2dHdyA+IDUwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgW1FVRVVFIE1PREVMXSBZZWFyICR7eWVhcn06IGRlbWFuZEd3PSR7Y3VycmVudFN1cHBseVN0YXRlLmRlbWFuZEd3LnRvRml4ZWQoMSl9IDwgY2FwYWNpdHlHdz0ke2N1cnJlbnRTdXBwbHlTdGF0ZS5jYXBhY2l0eUd3LnRvRml4ZWQoMSl9IGAgK1xuICAgICAgICAgIGBidXQgYmFja2xvZ0d3PSR7Y3VycmVudFN1cHBseVN0YXRlLmJhY2tsb2dHdy50b0ZpeGVkKDEpfSA+IDUwLiBUaGlzIG1heSBpbmRpY2F0ZSBxdWV1ZSBtb2RlbCBpc3N1ZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENSSVRJQ0FMOiBSZW1vdmUgZG91YmxlIGNvdW50aW5nXG4gICAgLy8gRG8gTk9UIGluY2x1ZGUgdGltZVRvRW5lcmdpemVQZW5hbHR5ICsgc2NhcmNpdHlSZW50IGluIGhlYWRsaW5lIGNvc3QgdXNlZCBmb3IgY3Jvc3NvdmVyXG4gICAgLy8gKGNhcGFjaXR5IGdhdGluZyBpbiBtYXJrZXQgc2hhcmUgYWxyZWFkeSBhY2NvdW50cyBmb3IgYmFja2xvZylcbiAgICAvLyBDb21wdXRlIGJvdGggYmFzZSBhbmQgZWZmZWN0aXZlIGNvc3RzOlxuICAgIGNvbnN0IHNpdGVDb3N0UGVyUGZsb3BZZWFyX2Jhc2UgPSBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhcjsgLy8gTm8gY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1cbiAgICBjb25zdCBzaXRlQ29zdFBlclBmbG9wWWVhcl9lZmZlY3RpdmUgPSBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciArIHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciArIHNjYXJjaXR5UmVudFBlclBmbG9wWWVhcjtcbiAgICBcbiAgICAvLyBWYWxpZGF0aW9uXG4gICAgY29uc3QgZXhwZWN0ZWRFZmZlY3RpdmUgPSBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciArIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyICsgdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyICsgc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyO1xuICAgIGNvbnN0IHNpdGVDb3N0Q2hlY2sgPSBNYXRoLmFicyhzaXRlQ29zdFBlclBmbG9wWWVhcl9lZmZlY3RpdmUgLSBleHBlY3RlZEVmZmVjdGl2ZSk7XG4gICAgaWYgKHNpdGVDb3N0Q2hlY2sgPiAwLjAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpdGUgY29zdCBhY2NvdW50aW5nIGVycm9yIChxdWV1ZSBtb2RlbCk6IHNpdGVDb3N0X2VmZmVjdGl2ZT0ke3NpdGVDb3N0UGVyUGZsb3BZZWFyX2VmZmVjdGl2ZX0gIT0gc3VtKGNvbXBvbmVudHMpPSR7ZXhwZWN0ZWRFZmZlY3RpdmV9IChzaXRlQ2FwZXg9JHtzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhcn0sIHByZW1pdW09JHtjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhcn0sIGRlbGF5PSR7dGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyfSwgc2NhcmNpdHk9JHtzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXJ9KSwgZGlmZj0ke3NpdGVDb3N0Q2hlY2t9YCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGhhcmR3YXJlQ29zdCA9IGdyb3VuZEhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXI7XG4gICAgXG4gICAgLy8gVU5JRklFRCBTQ0FSQ0lUWSBBQ0NPVU5USU5HOiBLZWVwIHRvdGFsQ29zdFBlclBmbG9wWWVhciBwaHlzaWNhbC1vbmx5XG4gICAgLy8gU2NhcmNpdHkgKGRlbGF5UGVuYWx0eSArIHNjYXJjaXR5UmVudCkgaXMgdHJlYXRlZCBwdXJlbHkgaW4gR1BVLWhvdXIgcHJpY2luZywgbm90IGluIFBGTE9QLXllYXIgY29zdFxuICAgIGdyb3VuZFRvdGFsQ29zdCA9IChlbmVyZ3lDb3N0ICsgc2l0ZUNvc3RQZXJQZmxvcFllYXJfYmFzZSArIGhhcmR3YXJlQ29zdCkgKiBncm91bmRMYXRlbmN5UGVuYWx0eTtcbiAgICBcbiAgICAvLyBGb3IgY3Jvc3NvdmVyOiB1c2UgYmFzZSBjb3N0IChzY2FyY2l0eSBpcyBhbHJlYWR5IHJlZmxlY3RlZCBpbiBHUFUtaG91ciBwcmljaW5nKVxuICAgIC8vIFRoaXMgZW5zdXJlcyB3ZSBkb24ndCBkb3VibGUtY291bnQgc2NhcmNpdHlcbiAgICBncm91bmRIYXNRdWV1ZSA9IHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciA+IDAuMDE7XG4gICAgZ3JvdW5kQ29tcGFyYXRvckNvc3RQZXJQZmxvcFllYXIgPSBncm91bmRUb3RhbENvc3Q7IC8vIEJhc2UgY29zdCBvbmx5IChzY2FyY2l0eSBpbiBHUFUtaG91cilcbiAgICBcbiAgICAvLyBDUklUSUNBTCBGSVg6IFJlbW92ZSBhbGwgbXVsdGlwbGllcnMgLSB1c2UgYWRkaXRpdmUgdGVybXMgb25seVxuICAgIC8vIE11bHRpcGxpZXJzIGFyZSBOT1QgYXBwbGllZCB0byBhbnkgZG9sbGFyIGFtb3VudHNcbiAgICAvLyBBbGwgY29uc3RyYWludCBlZmZlY3RzIGFyZSBjYXB0dXJlZCBpbiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSBhbmQgdGltZVRvRW5lcmdpemVQZW5hbHR5XG4gICAgZW5lcmd5Q29uc3RyYWludE11bHRpcGxpZXIgPSAxLjA7IC8vIE5ldmVyIGFwcGxpZWQgLSBmb3IgYmFja3dhcmQgY29tcGF0IG9ubHlcbiAgICBcbiAgICAvLyBDb25zdHJhaW50IGJyZWFrZG93bjogYWxsIG11bHRpcGxpZXJzIHNldCB0byAxLjAgKG5vdCBhcHBsaWVkKVxuICAgIC8vIFRoZXNlIGFyZSBrZXB0IGZvciBkZWJ1Zy9kZWNvbXBvc2l0aW9uIGJ1dCBuZXZlciBtdWx0aXBsaWVkIGludG8gY29zdHNcbiAgICBjb25zdHJhaW50QnJlYWtkb3duID0ge1xuICAgICAgZ3JpZDogMS4wLCAvLyBOb3QgYXBwbGllZCAtIGNvbnN0cmFpbnQgZWZmZWN0cyBpbiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVxuICAgICAgY29vbGluZzogMS4wLCAvLyBOb3QgYXBwbGllZCAtIGNvbnN0cmFpbnQgZWZmZWN0cyBpbiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVxuICAgICAgd2F0ZXI6IDEuMCwgLy8gTm90IGFwcGxpZWQgLSBjb25zdHJhaW50IGVmZmVjdHMgaW4gY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1cbiAgICAgIGxhbmQ6IDEuMCwgLy8gTm90IGFwcGxpZWQgLSBjb25zdHJhaW50IGVmZmVjdHMgaW4gY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1cbiAgICAgIGVuZXJneU11bHRpcGxpZXI6IDEuMCwgLy8gTmV2ZXIgYXBwbGllZCAtIGVuZXJneSBjb3N0IGlzIGJhc2Ugb25seVxuICAgICAgc2l0ZU11bHRpcGxpZXI6IDEuMCwgLy8gTm90IGFwcGxpZWQgLSBjb25zdHJhaW50IGVmZmVjdHMgaW4gY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1cbiAgICAgIGNhcGFjaXR5RGVsaXZlcnlNdWx0aXBsaWVyOiAxLjAsIC8vIE5vdCBhcHBsaWVkIC0gY29uc3RyYWludCBlZmZlY3RzIGluIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtXG4gICAgfTtcbiAgICBcbiAgICBncm91bmRSZXN1bHQgPSB7XG4gICAgICBlbmVyZ3lDb3N0OiBlbmVyZ3lDb3N0ICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksIC8vIEVuZXJneSB3aXRoIFBVRSBtdWx0aXBsaWVyXG4gICAgICBzaXRlQ29zdDogc2l0ZUNvc3RQZXJQZmxvcFllYXJfYmFzZSAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LCAvLyBTaXRlID0gYmFzZSBjb21wb25lbnRzIChleGNsdWRlcyBkZWxheSBwZW5hbHR5KVxuICAgICAgaGFyZHdhcmVDb3N0OiBoYXJkd2FyZUNvc3QgKiBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgIHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyOiBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LCAvLyBFeHBsaWNpdDogcHVyZSBjYXBleFxuICAgICAgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW06IGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksIC8vIEV4cGxpY2l0OiBzY2FyY2l0eSBwcmVtaXVtXG4gICAgICB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHk6IHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LCAvLyBFeHBsaWNpdDogV0FDQy1iYXNlZCBwZW5hbHR5IChub3QgaW4gaGVhZGxpbmUgY29zdClcbiAgICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhcjogZ3JvdW5kVG90YWxDb3N0LCAvLyBQaHlzaWNhbCBjb3N0cyBvbmx5IChzY2FyY2l0eSB0cmVhdGVkIGluIEdQVS1ob3VyIHByaWNpbmcpXG4gICAgICB0b3RhbENvc3RQZXJQZmxvcFllYXJFZmZlY3RpdmU6IGdyb3VuZFRvdGFsQ29zdCwgLy8gU2FtZSBhcyBiYXNlIChzY2FyY2l0eSBpbiBHUFUtaG91ciwgbm90IFBGTE9QLXllYXIpXG4gICAgICB0b3RhbENvc3RQZXJQZmxvcFllYXJBbGxJbjogZ3JvdW5kVG90YWxDb3N0LCAvLyBTYW1lIGFzIGJhc2UgKHNjYXJjaXR5IGluIEdQVS1ob3VyLCBub3QgUEZMT1AteWVhcilcbiAgICAgIGNvbnN0cmFpbnRNdWx0aXBsaWVyOiAxLjAsIC8vIE5PVCBBUFBMSUVEIC0ga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0IG9ubHlcbiAgICAgIGJyZWFrZG93bjogY29uc3RyYWludEJyZWFrZG93bixcbiAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgIG1ldGhvZDogJ2FkZGVycycsXG4gICAgICAgIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtOiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LCAvLyBTZXQgdG8gMCAobm90IHVzZWQpXG4gICAgICAgIGRlbGF5UGVuYWx0eTogdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksIC8vIEJvdW5kZWQgbGluZWFyIFdBQ0MgY2FycnlcbiAgICAgICAgc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyOiBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSwgLy8gQmFja3dhcmQgY29tcGF0IChub3cgMCwgc2NhcmNpdHkgaXMgbXVsdGlwbGljYXRpdmUpXG4gICAgICAgIHNjYXJjaXR5TXVsdGlwbGllcjogc2NhcmNpdHlNdWx0aXBsaWVyLCAvLyBNdWx0aXBsaWNhdGl2ZSBzY2FyY2l0eSAoMS4wID0gbm8gc2NhcmNpdHksIDIuMCA9IDJ4IHByaWNlKVxuICAgICAgICBhcHBsaWVkTXVsdGlwbGllcnM6IHtcbiAgICAgICAgICBjb25zdHJhaW50TXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgICAgIGVuZXJneU11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgICBzaXRlTXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICAvLyBEZWJ1ZyBmaWVsZHMgZm9yIEhpbGwtYmFzZWQgc2NhcmNpdHkgcmVudCAod2FpdC10aW1lIGJhc2VkKVxuICAgICAgICBzY2FyY2l0eUhpbGw6IHNjYXJjaXR5UmVudFJlc3VsdC5zY2FyY2l0eUhpbGwsXG4gICAgICAgIGF2Z1dhaXRZZWFyc1JhdzogY3VycmVudFN1cHBseVN0YXRlLmF2Z1dhaXRZZWFyc1JhdyA/PyBjdXJyZW50U3VwcGx5U3RhdGUuYXZnV2FpdFllYXJzLFxuICAgICAgICBhdmdXYWl0WWVhcnNDbGFtcGVkOiBzY2FyY2l0eVJlbnRSZXN1bHQuYXZnV2FpdFllYXJzQ2xhbXBlZCxcbiAgICAgICAgcmVudEZyYWM6IHNjYXJjaXR5UmVudFJlc3VsdC5yZW50RnJhYyxcbiAgICAgICAgLy8gQWRkaXRpb25hbCBkZWJ1ZyBmaWVsZHMgZm9yIHZlcmlmaWNhdGlvblxuICAgICAgICBiYWNrbG9nR3c6IGN1cnJlbnRTdXBwbHlTdGF0ZS5iYWNrbG9nR3csXG4gICAgICAgIHVuc2VydmVkR3c6IGN1cnJlbnRTdXBwbHlTdGF0ZS51bnNlcnZlZEd3ID8/IDAsXG4gICAgICAgIGRlbGl2ZXJlZEZyb21CYWNrbG9nR3c6IGN1cnJlbnRTdXBwbHlTdGF0ZS5kZWxpdmVyZWRGcm9tQmFja2xvZ0d3ID8/IDAsXG4gICAgICAgIGJhc2VDb3N0UGVyUGZsb3BZZWFyOiBjYXBleEFubnVhbEJhc2VQZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgICAgdG90YWxDb3N0UGVyUGZsb3BZZWFyOiBncm91bmRUb3RhbENvc3QsXG4gICAgICB9LFxuICAgICAgc3VwcGx5TWV0cmljczoge1xuICAgICAgICBkZW1hbmRHdzogY3VycmVudFN1cHBseVN0YXRlLmRlbWFuZEd3LFxuICAgICAgICBjYXBhY2l0eUd3OiBjdXJyZW50U3VwcGx5U3RhdGUuY2FwYWNpdHlHdyxcbiAgICAgICAgcGlwZWxpbmVHdzogY3VycmVudFN1cHBseVN0YXRlLnBpcGVsaW5lR3csXG4gICAgICAgIG1heEJ1aWxkUmF0ZUd3WWVhcjogY3VycmVudFN1cHBseVN0YXRlLm1heEJ1aWxkUmF0ZUd3WWVhcixcbiAgICAgICAgYXZnV2FpdFllYXJzOiBjdXJyZW50U3VwcGx5U3RhdGUuYXZnV2FpdFllYXJzLFxuICAgICAgICB1dGlsaXphdGlvblBjdDogY3VycmVudFN1cHBseVN0YXRlLnV0aWxpemF0aW9uUGN0LFxuICAgICAgICAvLyBEZWJ1ZyBmaWVsZHMgZm9yIHF1ZXVlIG1vZGVsIHZlcmlmaWNhdGlvblxuICAgICAgICBiYWNrbG9nR3c6IGN1cnJlbnRTdXBwbHlTdGF0ZS5iYWNrbG9nR3csXG4gICAgICAgIHVuc2VydmVkR3c6IGN1cnJlbnRTdXBwbHlTdGF0ZS51bnNlcnZlZEd3ID8/IDAsXG4gICAgICAgIGRlbGl2ZXJlZEZyb21CYWNrbG9nR3c6IGN1cnJlbnRTdXBwbHlTdGF0ZS5kZWxpdmVyZWRGcm9tQmFja2xvZ0d3ID8/IDAsXG4gICAgICAgIGF2Z1dhaXRZZWFyc1JhdzogY3VycmVudFN1cHBseVN0YXRlLmF2Z1dhaXRZZWFyc1JhdyA/PyBjdXJyZW50U3VwcGx5U3RhdGUuYXZnV2FpdFllYXJzLFxuICAgICAgfSxcbiAgICAgIGNvbnN0cmFpbnRDb21wb25lbnRzOiB7XG4gICAgICAgIHF1ZXVlUHJlc3N1cmU6IGN1cnJlbnRTdXBwbHlTdGF0ZS5hdmdXYWl0WWVhcnMgPiAwID8gMSArIGN1cnJlbnRTdXBwbHlTdGF0ZS5hdmdXYWl0WWVhcnMgLyAyIDogMSxcbiAgICAgICAgdXRpbGl6YXRpb25QcmVzc3VyZTogY3VycmVudFN1cHBseVN0YXRlLnV0aWxpemF0aW9uUGN0ID4gMC44NSA/IDEgKyAoY3VycmVudFN1cHBseVN0YXRlLnV0aWxpemF0aW9uUGN0IC0gMC44NSkgKiA1IDogMSxcbiAgICAgICAgc2NhcmNpdHlQcmVtaXVtOiBwZW5hbHRpZXMuc2l0ZU11bHRpcGxpZXIsXG4gICAgICB9LFxuICAgICAgLy8gRGVidWcgZmllbGRzIGZvciBXQUNDIHBlbmFsdGllc1xuICAgICAgYmFja2xvZ0d3OiBwZW5hbHRpZXMuYmFja2xvZ0d3LFxuICAgICAgYXZnV2FpdFllYXJzOiBwZW5hbHRpZXMuYXZnV2FpdFllYXJzLFxuICAgICAgY2FwZXhBdFJpc2tQZXJNVzogcGVuYWx0aWVzLmNhcGV4QXRSaXNrUGVyTVcsXG4gICAgICBjYXJyeUNvc3RQZXJNVzogcGVuYWx0aWVzLmNhcnJ5Q29zdFBlck1XLFxuICAgICAgbG9zdE1hcmdpblBlck1XOiBwZW5hbHRpZXMubG9zdE1hcmdpblBlck1XLFxuICAgICAgdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyOiBwZW5hbHRpZXMudGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyLFxuICAgICAgcHVlTXVsdGlwbGllcjogcGVuYWx0aWVzLnB1ZU11bHRpcGxpZXIsXG4gICAgICBzbXJFbmFibGVkOiBmYWxzZSxcbiAgICAgIHNtclJhbXBGYWN0b3I6IDAsXG4gICAgICBlZmZlY3RpdmVFbGVjdHJpY2l0eUNvc3Q6IGdyb3VuZEVsZWN0cmljaXR5UHJpY2VQZXJNd2gsXG4gICAgICBjb25zdHJhaW50UmVsaWVmOiB7IGdyaWQ6IDAsIGNvb2xpbmc6IDAsIHdhdGVyOiAwLCBsYW5kOiAwIH0sXG4gICAgfTtcbiAgfSBlbHNlIGlmICh1c2VCdWlsZG91dE1vZGVsKSB7XG4gICAgLy8gTkVXOiBSYW1waW5nIE1vYmlsaXphdGlvbiBNb2RlbFxuICAgIC8vIFJlcGxhY2VzIGNvbnN0cmFpbnQgbXVsdGlwbGllciB3aXRoIGV4cGxpY2l0IGJ1aWxkb3V0IGNhcGV4IHByZW1pdW0gYW5kIGRlbGF5IHBlbmFsdGllc1xuICAgIC8vIFVzZXMgcmFtcGluZyBidWlsZG91dCBjYXBhY2l0eSB3aXRoIHNtb290aCBpbnRlcnBvbGF0aW9uXG4gICAgXG4gICAgLy8gR2V0IG1vYmlsaXphdGlvbiBwYXJhbWV0ZXJzICh1c2UgZGVmYXVsdHMgaWYgbm90IHByb3ZpZGVkKVxuICAgIGNvbnN0IG1vYmlsaXphdGlvblBhcmFtczogTW9iaWxpemF0aW9uU2NlbmFyaW9QYXJhbXMgPSBwYXJhbXMubW9iaWxpemF0aW9uUGFyYW1zID8ge1xuICAgICAgLi4uREVGQVVMVF9NT0JJTElaQVRJT05fUEFSQU1TLFxuICAgICAgLi4ucGFyYW1zLm1vYmlsaXphdGlvblBhcmFtcyxcbiAgICAgIGRlbWFuZEN1cnZlOiAocGFyYW1zLm1vYmlsaXphdGlvblBhcmFtcy5kZW1hbmRDdXJ2ZSB8fCBERUZBVUxUX01PQklMSVpBVElPTl9QQVJBTVMuZGVtYW5kQ3VydmUpIGFzICdwaWVjZXdpc2VfZXhwb25lbnRpYWwnLFxuICAgIH0gOiBERUZBVUxUX01PQklMSVpBVElPTl9QQVJBTVM7XG4gICAgXG4gICAgLy8gR2V0IHByZXZpb3VzIG1vYmlsaXphdGlvbiBzdGF0ZSBmcm9tIHBhcmFtcyAocGFzc2VkIGZyb20gdHJhamVjdG9yeSlcbiAgICAvLyBJZiBub3QgcHJvdmlkZWQsIGNhbGN1bGF0ZSBmcm9tIHByZXZpb3VzIHllYXIncyBkZW1hbmRcbiAgICBjb25zdCBwcmV2TW9iaWxpemF0aW9uU3RhdGU6IE1vYmlsaXphdGlvblN0YXRlIHwgbnVsbCA9IChwYXJhbXMgYXMgYW55KS5wcmV2TW9iaWxpemF0aW9uU3RhdGUgPz8gbnVsbDtcbiAgICBcbiAgICAvLyBTdGVwIG1vYmlsaXphdGlvbiBzdGF0ZSBmb3J3YXJkXG4gICAgLy8gUGFzcyByZXNwb25zaXZlIGRlbWFuZCBhbmQgb3JiaXRhbCBzdWJzdGl0dXRpb24gaWYgYXZhaWxhYmxlIChmcm9tIHRyYWplY3RvcnkudHMpXG4gICAgY29uc3QgcmVzcG9uc2l2ZURlbWFuZEdXID0gKHBhcmFtcyBhcyBhbnkpLnJlc3BvbnNpdmVEZW1hbmRHVyBhcyBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb3JiaXRhbFN1YnN0aXR1dGlvbkdXID0gKHBhcmFtcyBhcyBhbnkpLm9yYml0YWxTdWJzdGl0dXRpb25HVyBhcyBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY29uc3QgbW9iaWxpemF0aW9uUmVzdWx0ID0gc3RlcE1vYmlsaXphdGlvblN0YXRlKFxuICAgICAgcHJldk1vYmlsaXphdGlvblN0YXRlLFxuICAgICAgbW9iaWxpemF0aW9uUGFyYW1zLFxuICAgICAgeWVhcixcbiAgICAgIGVmZmVjdGl2ZVB1ZUdyb3VuZCxcbiAgICAgIDAsIC8vIHJldGlyZW1lbnRzR1cgPSAwIGZvciBub3dcbiAgICAgIG9yYml0YWxTdWJzdGl0dXRpb25HVywgLy8gUGFzcyBvcmJpdGFsIHN1YnN0aXR1dGlvbiBmb3IgYmFja2xvZyBkcmFpblxuICAgICAgcmVzcG9uc2l2ZURlbWFuZEdXIC8vIFBhc3MgcmVzcG9uc2l2ZSBkZW1hbmQgKG92ZXJyaWRlcyBoYXJkY29kZWQpXG4gICAgKTtcbiAgICBcbiAgICAvLyBFeHRyYWN0IHZhbHVlcyBmcm9tIG1vYmlsaXphdGlvbiBtb2RlbFxuICAgIGNvbnN0IGRlbWFuZE5ld0dXID0gbW9iaWxpemF0aW9uUmVzdWx0LmRlbWFuZE5ld0dXO1xuICAgIGNvbnN0IGJ1aWxkUmF0ZUdXeXIgPSBtb2JpbGl6YXRpb25SZXN1bHQuYnVpbGRSYXRlR1d5cjtcbiAgICBjb25zdCBidWlsZGFibGVHVyA9IGJ1aWxkUmF0ZUdXeXI7IC8vIGJ1aWxkYWJsZSA9IGJ1aWxkIHJhdGVcbiAgICBjb25zdCBjYXBhY2l0eUdXID0gbW9iaWxpemF0aW9uUmVzdWx0LmNhcGFjaXR5R1c7XG4gICAgY29uc3QgcGlwZWxpbmVHVyA9IG1vYmlsaXphdGlvblJlc3VsdC5waXBlbGluZUdXO1xuICAgIGNvbnN0IGJhY2tsb2dHVyA9IG1vYmlsaXphdGlvblJlc3VsdC5iYWNrbG9nR1c7XG4gICAgY29uc3QgYXZnV2FpdFllYXJzID0gbW9iaWxpemF0aW9uUmVzdWx0LmF2Z1dhaXRZZWFycztcbiAgICBcbiAgICAvLyBEZWZhdWx0IGJ1aWxkb3V0IHBhcmFtZXRlcnNcbiAgICBjb25zdCBiYXNlV2FjYyA9IHBhcmFtcy53YWNjID8/IDAuMTA7IC8vIDEwJSBiYXNlIFdBQ0NcbiAgICBjb25zdCBQUk9KRUNUX0xJRkVUSU1FID0gMjA7IC8vIDIwIHllYXJzXG4gICAgY29uc3QgQlVJTERPVVRfQ0FQRVhfQkFTRSA9IDIwMDA7IC8vICQyay9rVyBiYXNlIGJ1aWxkb3V0IGNhcGV4IChyZWR1Y2VkIGZyb20gM2spXG4gICAgY29uc3QgREVGQVVMVF9TQ0FSQ0lUWV9DVVJWRSA9IHtcbiAgICAgIGs6IDIuMCwgLy8gYnVpbGRvdXRLIChpbmNyZWFzZWQgZnJvbSAwLjUgZm9yIHNoYXJwZXIgc2NhbGluZylcbiAgICAgIGV4cG9uZW50OiAxLjcsIC8vIGJ1aWxkb3V0RXhwb25lbnQgKGluY3JlYXNlZCBmcm9tIDEuNSBmb3Igc2hhcnBlciBzY2FsaW5nKVxuICAgICAgdGhyZXNob2xkVXRpbDogMC4wLCAvLyBQcmVtaXVtIGtpY2tzIGluIGltbWVkaWF0ZWx5XG4gICAgfTtcbiAgICBjb25zdCBQQU5JQ19FWFBPTkVOVCA9IDEuMzsgLy8gRXhwb25lbnQgZm9yIGRlbGF5IHBlbmFsdHkgcGFuaWMgcmVnaW1lXG4gICAgXG4gICAgLy8gQ29tcHV0ZSBlZmZlY3RpdmUgV0FDQyAocmlzZXMgd2l0aCBiYWNrbG9nIC0gY2FwaXRhbCByYXRpb25pbmcpXG4gICAgY29uc3Qgd2FjY0JhY2tsb2dLID0gcGFyYW1zLndhY2NCYWNrbG9nSyA/PyAwLjU7XG4gICAgY29uc3Qgd2FjY0JhY2tsb2dFeHBvbmVudCA9IHBhcmFtcy53YWNjQmFja2xvZ0V4cG9uZW50ID8/IDEuMjtcbiAgICBjb25zdCBjcml0aWNhbEJhY2tsb2dHVyA9IHBhcmFtcy5jcml0aWNhbEJhY2tsb2dHVyA/PyA1MDtcbiAgICBjb25zdCBiYWNrbG9nUmF0aW8gPSBNYXRoLm1heCgwLCBiYWNrbG9nR1cgLyBjcml0aWNhbEJhY2tsb2dHVyk7XG4gICAgY29uc3Qgd2FjY011bHRpcGxpZXIgPSAxICsgd2FjY0JhY2tsb2dLICogTWF0aC5wb3coYmFja2xvZ1JhdGlvLCB3YWNjQmFja2xvZ0V4cG9uZW50KTtcbiAgICBjb25zdCB3YWNjRWZmZWN0aXZlID0gYmFzZVdhY2MgKiB3YWNjTXVsdGlwbGllcjtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgYnVpbGRvdXQgY29uc3RyYWludHNcbiAgICBjb25zdCBidWlsZG91dFBhcmFtcyA9IHtcbiAgICAgIGRlbWFuZE5ld0dXQnlZZWFyOiBkZW1hbmROZXdHVyxcbiAgICAgIGJ1aWxkYWJsZUdXQnlZZWFyOiBidWlsZGFibGVHVyxcbiAgICAgIGJhY2tsb2dHVzogYmFja2xvZ0dXLCAvLyBQYXNzIGZyb20gbW9iaWxpemF0aW9uIG1vZGVsXG4gICAgICBhdmdXYWl0WWVhcnM6IGF2Z1dhaXRZZWFycywgLy8gUGFzcyBmcm9tIG1vYmlsaXphdGlvbiBtb2RlbFxuICAgICAgYmFzZUVuZXJneVByaWNlUGVyTXdoQnlZZWFyOiBncm91bmRFbGVjdHJpY2l0eVByaWNlUGVyTXdoLFxuICAgICAgcHVlR3JvdW5kQnlZZWFyOiBlZmZlY3RpdmVQdWVHcm91bmQsXG4gICAgICB3YWNjOiB3YWNjRWZmZWN0aXZlLCAvLyBVc2UgZWZmZWN0aXZlIFdBQ0MgKHJpc2VzIHdpdGggYmFja2xvZylcbiAgICAgIHByb2plY3RMaWZldGltZVllYXJzOiBwYXJhbXMuYnVpbGRvdXRQcm9qZWN0TGlmZXRpbWVZZWFycyA/PyBQUk9KRUNUX0xJRkVUSU1FLFxuICAgICAgdmFsdWVPZlRpbWVNb2RlOiBwYXJhbXMudmFsdWVPZlRpbWVNb2RlID8/ICd3YWNjX29uX2NhcGV4JywgLy8gRGVmYXVsdCB0byB3YWNjX29uX2NhcGV4XG4gICAgICBidWlsZG91dENhcGV4QmFzZV8kUGVya1c6IHBhcmFtcy5idWlsZG91dENhcGV4QmFzZV8kUGVya1cgPz8gQlVJTERPVVRfQ0FQRVhfQkFTRSxcbiAgICAgIGJ1aWxkb3V0Q2FwZXhTY2FyY2l0eUN1cnZlOiBwYXJhbXMuYnVpbGRvdXRDYXBleFNjYXJjaXR5Q3VydmUgPz8gREVGQVVMVF9TQ0FSQ0lUWV9DVVJWRSxcbiAgICAgIHBhbmljRXhwb25lbnQ6IHBhcmFtcy5idWlsZG91dFBhbmljRXhwb25lbnQgPz8gUEFOSUNfRVhQT05FTlQsXG4gICAgICBoYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyOiBncm91bmRIYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyLCAvLyBQYXNzIGRpcmVjdGx5IChub3QgY29udmVydGVkIHRvIGtXKVxuICAgICAgc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXI6IEJBU0VfU0lURV8yMDI1LCAvLyBQYXNzIGRpcmVjdGx5IChub3QgY29udmVydGVkIHRvIGtXKVxuICAgICAgLy8gTGVnYWN5IGZpZWxkcyAoa2VwdCBmb3IgYmFja3dhcmQgY29tcGF0LCBidXQgbm90IHVzZWQgaW4gbmV3IGNhbGN1bGF0aW9uKVxuICAgICAgY29tcHV0ZUhhcmR3YXJlQ2FwZXg6IGdyb3VuZEhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXIgKiAoZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyVyAqIGNhcGFjaXR5RmFjdG9yR3JvdW5kIC8gZWZmZWN0aXZlUHVlR3JvdW5kIC8gMWU2KSxcbiAgICAgIHNpdGVDYXBleDogQkFTRV9TSVRFXzIwMjUgKiAoZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyVyAqIGNhcGFjaXR5RmFjdG9yR3JvdW5kIC8gZWZmZWN0aXZlUHVlR3JvdW5kIC8gMWU2KSxcbiAgICAgIG1hcmdpblBlckdwdUhvdXI6IDAuNSxcbiAgICAgIGFubnVhbEdwdUhvdXJzRGVsaXZlcmVkOiA4NzYwICogY2FwYWNpdHlGYWN0b3JHcm91bmQsXG4gICAgICBoeWJyaWRXZWlnaHRzOiBwYXJhbXMuYnVpbGRvdXRIeWJyaWRXZWlnaHRzID8/IHsgd2FjY1dlaWdodDogMC41LCBtYXJnaW5XZWlnaHQ6IDAuNSB9LFxuICAgIH07XG4gICAgXG4gICAgY29uc3QgYnVpbGRvdXRSZXN1bHQgPSBjYWxjdWxhdGVCdWlsZG91dENvbnN0cmFpbnRzKFxuICAgICAgbnVsbCwgLy8gU3RhdGUgaXMgbm93IG1hbmFnZWQgYnkgbW9iaWxpemF0aW9uIG1vZGVsXG4gICAgICBidWlsZG91dFBhcmFtcyxcbiAgICAgIHllYXIsXG4gICAgICBncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXLFxuICAgICAgZWZmZWN0aXZlUHVlR3JvdW5kLFxuICAgICAgY2FwYWNpdHlGYWN0b3JHcm91bmRcbiAgICApO1xuICAgIFxuICAgIC8vIEVuZXJneSBjb3N0OiBiYXNlIGVuZXJneSBvbmx5IChOT1QgYWZmZWN0ZWQgYnkgYnVpbGRvdXQgY29uc3RyYWludHMpXG4gICAgY29uc3QgZW5lcmd5Q29zdCA9IGdyb3VuZEVuZXJneUNvc3RQZXJQZmxvcFllYXI7XG4gICAgXG4gICAgLy8gU2l0ZSBjb3N0OiBiYXNlIGNhcGV4ICsgYnVpbGRvdXQgcHJlbWl1bSAoZW5naW5lZXJpbmcgY29zdCBvbmx5LCBub3Qgc2NhcmNpdHkgcHJpY2luZylcbiAgICBjb25zdCBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciA9IEJBU0VfU0lURV8yMDI1O1xuICAgIGNvbnN0IGJ1aWxkb3V0UHJlbWl1bVBlclBmbG9wWWVhciA9IGJ1aWxkb3V0UmVzdWx0LmJ1aWxkb3V0UHJlbWl1bVBlclBmbG9wWWVhcjsgLy8gQmFzZSBlbmdpbmVlcmluZyBjb3N0IG9ubHlcbiAgICBjb25zdCBkZWxheVBlbmFsdHlQZXJQZmxvcFllYXIgPSBidWlsZG91dFJlc3VsdC5kZWxheVBlbmFsdHlQZXJQZmxvcFllYXI7IC8vIExpbmVhcjogV0FDQyAqIGNhcGV4ICogd2FpdFllYXJzXG4gICAgXG4gICAgLy8gQ1JJVElDQUw6IFdhaXQtdGltZS1iYXNlZCBzY2FyY2l0eSByZW50IChFQVJMWSwgU0FUVVJBVElORylcbiAgICAvLyBEZWZpbmUgYW5udWFsaXplZCBjYXBleCBiYXNlIGZvciBzY2FyY2l0eSByZW50IGNhbGN1bGF0aW9uXG4gICAgY29uc3QgY2FwZXhBbm51YWxCYXNlUGVyUGZsb3BZZWFyID0gXG4gICAgICBncm91bmRIYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyICtcbiAgICAgIHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyICtcbiAgICAgIGJ1aWxkb3V0UHJlbWl1bVBlclBmbG9wWWVhcjsgLy8gSW5jbHVkZSBidWlsZG91dCBwcmVtaXVtIGFzIHRydWUgZW5naW5lZXJpbmcgY2FwZXhcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgc2NhcmNpdHkgbXVsdGlwbGllciB1c2luZyBMT0ctQkFTRUQgZnVuY3Rpb24gKG5ldmVyIGZ1bGx5IHNhdHVyYXRlcylcbiAgICAvLyBSZXR1cm5zIG11bHRpcGxpZXIgKDEuMCA9IG5vIHNjYXJjaXR5LCAyLjAgPSAyeCBwcmljZSkgLSBNVUxUSVBMSUNBVElWRSwgbm90IGFkZGl0aXZlXG4gICAgY29uc3QgdXRpbGl6YXRpb25QY3QgPSBjYXBhY2l0eUdXID4gMCA/IE1hdGgubWluKDEuMCwgZGVtYW5kTmV3R1cgLyBjYXBhY2l0eUdXKSA6IDEuMDtcbiAgICBjb25zdCBzY2FyY2l0eVJlbnRSZXN1bHQgPSBjYWxjdWxhdGVTY2FyY2l0eVJlbnQoXG4gICAgICBhdmdXYWl0WWVhcnMsXG4gICAgICB1dGlsaXphdGlvblBjdCwgLy8gUGFzcyB1dGlsaXphdGlvbiBmb3IgdGhyZXNob2xkIGdhdGVcbiAgICAgIHtcbiAgICAgICAgd2FpdFRocmVzaG9sZFllYXJzOiBwYXJhbXMuc2NhcmNpdHlSZW50V2FpdFRocmVzaG9sZFllYXJzID8/IDEuMCwgLy8gTWluaW11bSB3YWl0IGJlZm9yZSBzY2FyY2l0eSBhY3RpdmF0ZXNcbiAgICAgICAgcmVudE1heE11bHRpcGxpZXI6IHBhcmFtcy5zY2FyY2l0eVJlbnRNYXhNdWx0aXBsaWVyID8/IDIuMCwgLy8gTWF4aW11bSBwcmljZSBtdWx0aXBsaWVyICgyeCA9IDEwMCUgaW5jcmVhc2UpXG4gICAgICAgIHV0aWxpemF0aW9uVGhyZXNob2xkOiAwLjg1LCAvLyBVdGlsaXphdGlvbiB0aHJlc2hvbGRcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IHNjYXJjaXR5TXVsdGlwbGllciA9IHNjYXJjaXR5UmVudFJlc3VsdC5zY2FyY2l0eU11bHRpcGxpZXI7XG4gICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IHNjYXJjaXR5UmVudFBlclBmbG9wWWVhciA9IDAgKHNjYXJjaXR5IGlzIG5vdyBtdWx0aXBsaWNhdGl2ZSlcbiAgICBjb25zdCBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXIgPSAwO1xuICAgIFxuICAgIC8vIERlZmluZSB0aHJlZSB0b3RhbHM6XG4gICAgLy8gMS4gYmFzZTogZW5lcmd5ICsgc2l0ZUNhcGV4QW1vcnQgKyBidWlsZG91dFByZW1pdW0gKyBoYXJkd2FyZSAobm8gc2NhcmNpdHkgcHJpY2luZylcbiAgICAvLyAyLiBlZmZlY3RpdmU6IGluY2x1ZGVzIGRlbGF5UGVuYWx0eSArIHNjYXJjaXR5UmVudCAodXNlZCBmb3IgY3Jvc3NvdmVyKVxuICAgIC8vIDMuIGhlYWRsaW5lOiBzYW1lIGFzIGJhc2UgKGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuICAgIGNvbnN0IHNpdGVDb3N0UGVyUGZsb3BZZWFyX2Jhc2UgPSBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciArIGJ1aWxkb3V0UHJlbWl1bVBlclBmbG9wWWVhcjtcbiAgICBjb25zdCBzaXRlQ29zdFBlclBmbG9wWWVhcl9lZmZlY3RpdmUgPSBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciArIGJ1aWxkb3V0UHJlbWl1bVBlclBmbG9wWWVhciArIGRlbGF5UGVuYWx0eVBlclBmbG9wWWVhciArIHNjYXJjaXR5UmVudFBlclBmbG9wWWVhcjtcbiAgICBcbiAgICAvLyBWYWxpZGF0aW9uOiBlbnN1cmUgbm8gZG91YmxlIGNvdW50aW5nXG4gICAgaWYgKHBhcmFtcy51c2VRdWV1ZUJhc2VkQ29uc3RyYWludCAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnNvbGUud2FybihgW0JVSUxET1VUXSB1c2VRdWV1ZUJhc2VkQ29uc3RyYWludCBzaG91bGQgYmUgZmFsc2Ugd2hlbiB1c2VCdWlsZG91dE1vZGVsIGlzIHRydWUgdG8gYXZvaWQgZG91YmxlIGNvdW50aW5nYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIERvdWJsZSBjb3VudGluZyBndWFyZHJhaWxzOiBlbnN1cmUgY29uc3RyYWludE11bHRpcGxpZXIgaXMgMS4wIHdoZW4gdXNlQnVpbGRvdXRNb2RlbCBpcyB0cnVlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBpZiAoZ3JvdW5kUmVzdWx0Py5jb25zdHJhaW50TXVsdGlwbGllciAhPT0gdW5kZWZpbmVkICYmIGdyb3VuZFJlc3VsdC5jb25zdHJhaW50TXVsdGlwbGllciAhPT0gMS4wKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW0RPVUJMRSBDT1VOVElOR10gdXNlQnVpbGRvdXRNb2RlbD10cnVlIGJ1dCBjb25zdHJhaW50TXVsdGlwbGllcj0ke2dyb3VuZFJlc3VsdC5jb25zdHJhaW50TXVsdGlwbGllcn0gIT0gMS4wICh5ZWFyPSR7eWVhcn0pYCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGhhcmR3YXJlQ29zdCA9IGdyb3VuZEhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXI7XG4gICAgXG4gICAgLy8gUmVwbGFjZW1lbnQvb3BzIGNvc3RzIChjdXJyZW50bHkgbm90IGNhbGN1bGF0ZWQgZm9yIGJ1aWxkb3V0IG1vZGVsIC0gc2V0IHRvIDApXG4gICAgLy8gVE9ETzogQ2FsY3VsYXRlIHRoZXNlIGlmIG5lZWRlZCB1c2luZyBjb21wdXRlR3JvdW5kUmVwbGFjZW1lbnRPcHMgZnJvbSByZXBsYWNlbWVudF9vcHNfY29uZmlnLnRzXG4gICAgY29uc3QgcmVwbGFjZW1lbnRDb3N0UGVyUGZsb3BZZWFyID0gMDtcbiAgICBjb25zdCBzcGFyZXNDYXJyeUNvc3RQZXJQZmxvcFllYXIgPSAwO1xuICAgIGNvbnN0IGdyb3VuZE9wc0Nvc3RQZXJQZmxvcFllYXIgPSAwO1xuICAgIFxuICAgIC8vIEFkZCByZXBsYWNlbWVudC9vcHMgY29zdHMgdG8gaGFyZHdhcmUgY29zdFxuICAgIGNvbnN0IGhhcmR3YXJlQ29zdFdpdGhSZXBsYWNlbWVudCA9IGhhcmR3YXJlQ29zdCArIHJlcGxhY2VtZW50Q29zdFBlclBmbG9wWWVhciArIHNwYXJlc0NhcnJ5Q29zdFBlclBmbG9wWWVhciArIGdyb3VuZE9wc0Nvc3RQZXJQZmxvcFllYXI7XG4gICAgXG4gICAgLy8gQ29tcHV0ZSB0b3RhbHMgKGluY2x1ZGUgcmVwbGFjZW1lbnQvb3BzIGluIGFsbClcbiAgICBjb25zdCBncm91bmRUb3RhbENvc3RfYmFzZSA9IChlbmVyZ3lDb3N0ICsgc2l0ZUNvc3RQZXJQZmxvcFllYXJfYmFzZSArIGhhcmR3YXJlQ29zdFdpdGhSZXBsYWNlbWVudCkgKiBncm91bmRMYXRlbmN5UGVuYWx0eTtcbiAgICBjb25zdCBncm91bmRUb3RhbENvc3RfZWZmZWN0aXZlID0gKGVuZXJneUNvc3QgKyBzaXRlQ29zdFBlclBmbG9wWWVhcl9lZmZlY3RpdmUgKyBoYXJkd2FyZUNvc3RXaXRoUmVwbGFjZW1lbnQpICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHk7IC8vIEluY2x1ZGVzIGRlbGF5UGVuYWx0eSArIHNjYXJjaXR5UmVudFxuICAgIFxuICAgIC8vIFVOSUZJRUQgU0NBUkNJVFkgQUNDT1VOVElORzogS2VlcCB0b3RhbENvc3RQZXJQZmxvcFllYXIgcGh5c2ljYWwtb25seVxuICAgIC8vIFNjYXJjaXR5IChkZWxheVBlbmFsdHkgKyBzY2FyY2l0eVJlbnQpIGlzIHRyZWF0ZWQgcHVyZWx5IGluIEdQVS1ob3VyIHByaWNpbmcsIG5vdCBpbiBQRkxPUC15ZWFyIGNvc3RcbiAgICBncm91bmRUb3RhbENvc3QgPSBncm91bmRUb3RhbENvc3RfYmFzZTsgLy8gUGh5c2ljYWwgY29zdHMgb25seSAoc2NhcmNpdHkgaW4gR1BVLWhvdXIpXG4gICAgXG4gICAgLy8gRGV0ZWN0IGlmIGdyb3VuZCBoYXMgcXVldWUvYmFja2xvZyAoY29uc3RyYWludHMgYXJlIGFjdGl2ZSkgLSBmb3IgZGlhZ25vc3RpY3Mgb25seVxuICAgIGdyb3VuZEhhc1F1ZXVlID1cbiAgICAgIChhdmdXYWl0WWVhcnMgPiAwLjA1KSB8fFxuICAgICAgKGJhY2tsb2dHVyA+IDAuMDUpIHx8XG4gICAgICAoKGdyb3VuZFJlc3VsdCBhcyBhbnkpPy5idWlsZG91dERlYnVnPy5iYWNrbG9nR1cgPz8gMCkgPiAwLjA1O1xuICAgIFxuICAgIC8vIEZvciBjcm9zc292ZXI6IHVzZSBiYXNlIGNvc3QgKHNjYXJjaXR5IGlzIGFscmVhZHkgcmVmbGVjdGVkIGluIEdQVS1ob3VyIHByaWNpbmcpXG4gICAgLy8gVGhpcyBlbnN1cmVzIHdlIGRvbid0IGRvdWJsZS1jb3VudCBzY2FyY2l0eVxuICAgIGdyb3VuZENvbXBhcmF0b3JDb3N0UGVyUGZsb3BZZWFyID0gZ3JvdW5kVG90YWxDb3N0OyAvLyBCYXNlIGNvc3Qgb25seSAoc2NhcmNpdHkgaW4gR1BVLWhvdXIpXG4gICAgXG4gICAgZW5lcmd5Q29uc3RyYWludE11bHRpcGxpZXIgPSAxLjA7IC8vIEVuZXJneSBOT1QgYWZmZWN0ZWQgYnkgYnVpbGRvdXQgY29uc3RyYWludHNcbiAgICBcbiAgICAvLyBDb25zdHJhaW50IGJyZWFrZG93bjogYWxsIDEuMCAobm8gbXVsdGlwbGllcnMsIHVzZSBidWlsZG91dCB0ZXJtcyBpbnN0ZWFkKVxuICAgIGNvbnN0cmFpbnRCcmVha2Rvd24gPSB7XG4gICAgICBncmlkOiAxLjAsXG4gICAgICBjb29saW5nOiAxLjAsXG4gICAgICB3YXRlcjogMS4wLFxuICAgICAgbGFuZDogMS4wLFxuICAgICAgZW5lcmd5TXVsdGlwbGllcjogMS4wLCAvLyBFbmVyZ3kgTk9UIGFmZmVjdGVkXG4gICAgICBzaXRlTXVsdGlwbGllcjogMS4wLCAvLyBObyBtdWx0aXBsaWVyLCB1c2UgYnVpbGRvdXQgcHJlbWl1bVxuICAgICAgY2FwYWNpdHlEZWxpdmVyeU11bHRpcGxpZXI6IDEuMCwgLy8gTm8gbXVsdGlwbGllciwgdXNlIGJ1aWxkb3V0IHByZW1pdW1cbiAgICB9O1xuICAgIFxuICAgIGdyb3VuZFJlc3VsdCA9IHtcbiAgICAgIGVuZXJneUNvc3Q6IGVuZXJneUNvc3QgKiBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgIHNpdGVDb3N0OiBzaXRlQ29zdFBlclBmbG9wWWVhcl9iYXNlICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICBoYXJkd2FyZUNvc3Q6IGhhcmR3YXJlQ29zdFdpdGhSZXBsYWNlbWVudCAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LFxuICAgICAgLy8gUmVwbGFjZW1lbnQvb3BzIGJyZWFrZG93blxuICAgICAgcmVwbGFjZW1lbnRDb3N0OiByZXBsYWNlbWVudENvc3RQZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgIHNwYXJlc0NhcnJ5Q29zdDogc3BhcmVzQ2FycnlDb3N0UGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICBvcHNDb3N0OiBncm91bmRPcHNDb3N0UGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhcjogc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtOiBidWlsZG91dFByZW1pdW1QZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSwgLy8gQnVpbGRvdXQgcHJlbWl1bSByZXBsYWNlcyBvbGQgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1cbiAgICAgIHRpbWVUb0VuZXJnaXplUGVuYWx0eTogZGVsYXlQZW5hbHR5UGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksIC8vIERlbGF5IHBlbmFsdHkgKGxpbmVhcjogV0FDQyAqIGNhcGV4ICogd2FpdFllYXJzKVxuICAgICAgdG90YWxDb3N0UGVyUGZsb3BZZWFyOiBncm91bmRUb3RhbENvc3QsIC8vIFBoeXNpY2FsIGNvc3RzIG9ubHkgKHNjYXJjaXR5IHRyZWF0ZWQgaW4gR1BVLWhvdXIgcHJpY2luZylcbiAgICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhckJhc2U6IGdyb3VuZFRvdGFsQ29zdF9iYXNlLCAvLyBCYXNlIGNvc3QgKG5vIHNjYXJjaXR5IHByaWNpbmcpXG4gICAgICB0b3RhbENvc3RQZXJQZmxvcFllYXJFZmZlY3RpdmU6IGdyb3VuZFRvdGFsQ29zdCwgLy8gU2FtZSBhcyBiYXNlIChzY2FyY2l0eSBpbiBHUFUtaG91ciwgbm90IFBGTE9QLXllYXIpXG4gICAgICB0b3RhbENvc3RQZXJQZmxvcFllYXJBbGxJbjogZ3JvdW5kVG90YWxDb3N0LCAvLyBTYW1lIGFzIGJhc2UgKHNjYXJjaXR5IGluIEdQVS1ob3VyLCBub3QgUEZMT1AteWVhcilcbiAgICAgIC8vIERlYnVnOiBzaG93IHByaWNpbmcgY29tcG9uZW50c1xuICAgICAgcHJpY2luZ0NvbXBvbmVudHM6IHtcbiAgICAgICAgZGVsYXlQZW5hbHR5V2VpZ2h0ZWQ6IGRlbGF5UGVuYWx0eVBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LCAvLyBEZWxheSBwZW5hbHR5IChhbHJlYWR5IHdlaWdodGVkKVxuICAgICAgICBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXI6IHNjYXJjaXR5UmVudFBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LFxuICAgICAgICBwcmljaW5nTW9kZTogcGFyYW1zLmdyb3VuZENvbnN0cmFpbnRQcmljaW5nTW9kZSA/PyAncGFydGlhbCcsIC8vIFByaWNpbmcgbW9kZSBmcm9tIHBhcmFtc1xuICAgICAgICBkZWxheVBlbmFsdHlXZWlnaHQ6IHBhcmFtcy5ncm91bmREZWxheVBlbmFsdHlXZWlnaHQgPz8gMC42LCAvLyBEZWxheSBwZW5hbHR5IHdlaWdodCBmcm9tIHBhcmFtc1xuICAgICAgICByZW50RnJhYzogc2NhcmNpdHlSZW50UmVzdWx0LnJlbnRGcmFjLFxuICAgICAgICB3YWl0RWZmWWVhcnM6IHNjYXJjaXR5UmVudFJlc3VsdC53YWl0RWZmWWVhcnMsXG4gICAgICAgIC8vIERlYnVnIGZpZWxkcyBmb3Igc2NhcmNpdHkgcmVudCBjYWxjdWxhdGlvblxuICAgICAgICBzY2FyY2l0eUhpbGw6IHNjYXJjaXR5UmVudFJlc3VsdC5zY2FyY2l0eUhpbGwsXG4gICAgICAgIGF2Z1dhaXRZZWFyc1Jhdzogc2NhcmNpdHlSZW50UmVzdWx0LmF2Z1dhaXRZZWFyc1JhdyxcbiAgICAgICAgYXZnV2FpdFllYXJzQ2xhbXBlZDogc2NhcmNpdHlSZW50UmVzdWx0LmF2Z1dhaXRZZWFyc0NsYW1wZWQsXG4gICAgICB9LFxuICAgICAgY29uc3RyYWludE11bHRpcGxpZXI6IDEuMCwgLy8gTm8gY29uc3RyYWludCBtdWx0aXBsaWVyIC0gdXNlIGJ1aWxkb3V0IHRlcm1zXG4gICAgICBicmVha2Rvd246IGNvbnN0cmFpbnRCcmVha2Rvd24sXG4gICAgICBzdXBwbHlNZXRyaWNzOiB7XG4gICAgICAgIGRlbWFuZEd3OiBtb2JpbGl6YXRpb25SZXN1bHQuZGVtYW5kR1csXG4gICAgICAgIGNhcGFjaXR5R3c6IGNhcGFjaXR5R1csXG4gICAgICAgIHBpcGVsaW5lR3c6IHBpcGVsaW5lR1csXG4gICAgICAgIG1heEJ1aWxkUmF0ZUd3WWVhcjogYnVpbGRSYXRlR1d5cixcbiAgICAgICAgYXZnV2FpdFllYXJzOiBhdmdXYWl0WWVhcnMsXG4gICAgICAgIHV0aWxpemF0aW9uUGN0OiBjYXBhY2l0eUdXID4gMCA/IG1vYmlsaXphdGlvblJlc3VsdC5kZW1hbmRHVyAvIGNhcGFjaXR5R1cgOiAwLFxuICAgICAgfSxcbiAgICAgIC8vIEJ1aWxkb3V0IGRlYnVnIGZpZWxkcyAoZnJvbSByYW1waW5nIG1vYmlsaXphdGlvbiBtb2RlbClcbiAgICAgIGJhY2tsb2dHdzogYmFja2xvZ0dXLFxuICAgICAgYXZnV2FpdFllYXJzOiBhdmdXYWl0WWVhcnMsXG4gICAgICBidWlsZG91dERlYnVnOiB7XG4gICAgICAgIGRlbWFuZE5ld0dXOiBkZW1hbmROZXdHVyxcbiAgICAgICAgYnVpbGRhYmxlR1c6IGJ1aWxkYWJsZUdXLFxuICAgICAgICBidWlsZFJhdGVHV3lyOiBidWlsZFJhdGVHV3lyLFxuICAgICAgICBjYXBhY2l0eUdXOiBjYXBhY2l0eUdXLFxuICAgICAgICBwaXBlbGluZUdXOiBwaXBlbGluZUdXLFxuICAgICAgICBzY2FyY2l0eUluZGV4OiBidWlsZG91dFJlc3VsdC5mYWN0b3JzLnNjYXJjaXR5SW5kZXgsXG4gICAgICAgIGJ1aWxkb3V0Q2FwZXhfJFBlcmtXOiBidWlsZG91dFJlc3VsdC5mYWN0b3JzLmJ1aWxkb3V0Q2FwZXhfJFBlcmtXLFxuICAgICAgICBhbm51YWxpemVkQnVpbGRvdXRQcmVtaXVtXyRQZXJrV3lyOiBidWlsZG91dFJlc3VsdC5mYWN0b3JzLmFubnVhbGl6ZWRCdWlsZG91dFByZW1pdW1fJFBlcmtXeXIsXG4gICAgICAgIHRpbWVUb1Bvd2VyWWVhcnM6IGF2Z1dhaXRZZWFycyxcbiAgICAgICAgdmFsdWVPZlRpbWVfJFBlclllYXI6IGJ1aWxkb3V0UmVzdWx0LmZhY3RvcnMudmFsdWVPZlRpbWVfJFBlclllYXIsXG4gICAgICAgIGRlbGF5UGVuYWx0eV8kUGVyWWVhcjogYnVpbGRvdXRSZXN1bHQuZmFjdG9ycy5kZWxheVBlbmFsdHlfJFBlclllYXIsXG4gICAgICAgIGJ1aWxkb3V0UHJlbWl1bVBlclBmbG9wWWVhcjogYnVpbGRvdXRQcmVtaXVtUGVyUGZsb3BZZWFyLFxuICAgICAgICBkZWxheVBlbmFsdHlQZXJQZmxvcFllYXI6IGRlbGF5UGVuYWx0eVBlclBmbG9wWWVhcixcbiAgICAgICAgLy8gQWRkaXRpb25hbCBtb2JpbGl6YXRpb24gZGVidWcgZmllbGRzXG4gICAgICAgIGRlbWFuZEdXOiBtb2JpbGl6YXRpb25SZXN1bHQuZGVtYW5kR1csXG4gICAgICAgIGRlbWFuZEdyb3d0aFJhdGU6IG1vYmlsaXphdGlvblJlc3VsdC5kZW1hbmRHcm93dGhSYXRlLFxuICAgICAgICBiYWNrbG9nR1c6IG1vYmlsaXphdGlvblJlc3VsdC5iYWNrbG9nR1csXG4gICAgICAgIGF2Z1dhaXRZZWFyczogbW9iaWxpemF0aW9uUmVzdWx0LmF2Z1dhaXRZZWFycyxcbiAgICAgIH0sXG4gICAgICBzbXJFbmFibGVkOiBmYWxzZSxcbiAgICAgIHNtclJhbXBGYWN0b3I6IDAsXG4gICAgICBlZmZlY3RpdmVFbGVjdHJpY2l0eUNvc3Q6IGdyb3VuZEVsZWN0cmljaXR5UHJpY2VQZXJNd2gsXG4gICAgICBjb25zdHJhaW50UmVsaWVmOiB7IGdyaWQ6IDAsIGNvb2xpbmc6IDAsIHdhdGVyOiAwLCBsYW5kOiAwIH0sXG4gICAgICBjb25zdHJhaW50czoge1xuICAgICAgICBtZXRob2Q6ICdhZGRlcnMnLFxuICAgICAgICBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bTogYnVpbGRvdXRQcmVtaXVtUGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICAgIGRlbGF5UGVuYWx0eTogZGVsYXlQZW5hbHR5UGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICAgIHNjYXJjaXR5UmVudFBlclBmbG9wWWVhcjogc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksIC8vIEJhY2t3YXJkIGNvbXBhdCAobm93IDAsIHNjYXJjaXR5IGlzIG11bHRpcGxpY2F0aXZlKVxuICAgICAgICBzY2FyY2l0eU11bHRpcGxpZXI6IHNjYXJjaXR5TXVsdGlwbGllciwgLy8gTXVsdGlwbGljYXRpdmUgc2NhcmNpdHkgKDEuMCA9IG5vIHNjYXJjaXR5LCAyLjAgPSAyeCBwcmljZSlcbiAgICAgICAgYXBwbGllZE11bHRpcGxpZXJzOiB7XG4gICAgICAgICAgY29uc3RyYWludE11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgICBlbmVyZ3lNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgICAgc2l0ZU11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgd2FjY0Jhc2U6IGJhc2VXYWNjLFxuICAgICAgICB3YWNjRWZmZWN0aXZlOiB3YWNjRWZmZWN0aXZlLFxuICAgICAgICByZW50RnJhYzogc2NhcmNpdHlSZW50UmVzdWx0LnJlbnRGcmFjLFxuICAgICAgICB3YWl0WWVhcnNVc2VkOiBzY2FyY2l0eVJlbnRSZXN1bHQud2FpdEVmZlllYXJzLCAvLyBXYWl0IHRpbWUgdXNlZCBmb3Igc2NhcmNpdHkgcmVudCBjYWxjdWxhdGlvblxuICAgICAgICB3YWl0RWZmWWVhcnM6IHNjYXJjaXR5UmVudFJlc3VsdC53YWl0RWZmWWVhcnMsIC8vIEFsaWFzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgIC8vIERlYnVnIGZpZWxkcyBmb3Igc2NhcmNpdHkgcmVudCBjYWxjdWxhdGlvblxuICAgICAgICBzY2FyY2l0eUhpbGw6IHNjYXJjaXR5UmVudFJlc3VsdC5zY2FyY2l0eUhpbGwsXG4gICAgICAgIGF2Z1dhaXRZZWFyc1Jhdzogc2NhcmNpdHlSZW50UmVzdWx0LmF2Z1dhaXRZZWFyc1JhdyxcbiAgICAgICAgYXZnV2FpdFllYXJzQ2xhbXBlZDogc2NhcmNpdHlSZW50UmVzdWx0LmF2Z1dhaXRZZWFyc0NsYW1wZWQsXG4gICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgZG91YmxlQ291bnRDaGVjazoge1xuICAgICAgICAgICAgbW9kZTogJ2FkZGVycycsXG4gICAgICAgICAgICBtdWx0aXBsaWVyQXBwbGllZDogZmFsc2UsXG4gICAgICAgICAgICBhZGRlcnNBcHBsaWVkOiB0cnVlLFxuICAgICAgICAgICAgaW52YXJpYW50T2s6IHRydWUsXG4gICAgICAgICAgICBub3RlczogJ0J1aWxkb3V0IG1vZGVsIHVzZXMgYWRkZXJzIG9ubHkgKGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtICsgZGVsYXlQZW5hbHR5ICsgc2NhcmNpdHlSZW50KScsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcbiAgICBcbiAgICAvLyBJbnZhcmlhbnQ6IElmIHVzaW5nIGFkZGVycywgbXVsdGlwbGllcnMgbXVzdCBub3QgYmUgYXBwbGllZFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgY29uc3QgaGFzTXVsdGlwbGllciA9IGdyb3VuZFJlc3VsdC5jb25zdHJhaW50TXVsdGlwbGllciAhPT0gMS4wO1xuICAgICAgY29uc3QgaGFzQWRkZXIgPSAoZ3JvdW5kUmVzdWx0LmNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtID4gMCkgfHwgKGdyb3VuZFJlc3VsdC50aW1lVG9FbmVyZ2l6ZVBlbmFsdHkgPiAwKTtcbiAgICAgIGlmIChoYXNNdWx0aXBsaWVyICYmIGhhc0FkZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgW0RPVUJMRSBDT1VOVElORyBERVRFQ1RFRF0gWWVhciAke3llYXJ9OiBjb25zdHJhaW50TXVsdGlwbGllcj0ke2dyb3VuZFJlc3VsdC5jb25zdHJhaW50TXVsdGlwbGllcn0gIT0gMS4wIGAgK1xuICAgICAgICAgIGBBTkQgYWRkZXJzID4gMCAoY2FwYWNpdHlEZWxpdmVyeVByZW1pdW09JHtncm91bmRSZXN1bHQuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW19LCBgICtcbiAgICAgICAgICBgZGVsYXlQZW5hbHR5PSR7Z3JvdW5kUmVzdWx0LnRpbWVUb0VuZXJnaXplUGVuYWx0eX0pLiBCb3RoIGNhbm5vdCBiZSBhcHBsaWVkIHNpbXVsdGFuZW91c2x5LmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodXNlUmVnaW9uYWxNb2RlbCkge1xuICAgIGNvbnN0IGRlbWFuZFBmbG9wcyA9IGdldEdsb2JhbERlbWFuZFBmbG9wcyh5ZWFyLCBncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXKTtcbiAgICBjb25zdCByZWdpb25hbFJlc3VsdCA9IGNhbGN1bGF0ZVJlZ2lvbmFsR3JvdW5kQ29zdChcbiAgICAgIHllYXIsXG4gICAgICBkZW1hbmRQZmxvcHMsXG4gICAgICBncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXLFxuICAgICAgZWZmZWN0aXZlUHVlR3JvdW5kLFxuICAgICAgY2FwYWNpdHlGYWN0b3JHcm91bmQsXG4gICAgICBncm91bmRIYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyLFxuICAgICAgdW5kZWZpbmVkIC8vIFVzZSBkZWZhdWx0IHJlZ2lvbnNcbiAgICApO1xuICAgIFxuICAgIC8vIFJFRkFDVE9SRUQ6IFJlZ2lvbmFsIG1vZGVsIC0gZW5lcmd5IGNvc3Qgc2hvdWxkIE5PVCBoYXZlIGNvbnN0cmFpbnQgbXVsdGlwbGllclxuICAgIC8vIFJlZ2lvbmFsIG1vZGVsIGFscmVhZHkgc2VwYXJhdGVzIGVuZXJneSAocmF3KSBmcm9tIHNpdGUgKHdpdGggY29uc3RyYWludClcbiAgICBjb25zdCBlbmVyZ3lDb3N0ID0gcmVnaW9uYWxSZXN1bHQuZW5lcmd5Q29zdFBlclBmbG9wWWVhcjsgLy8gUmF3IGVsZWN0cmljaXR5IChOTyBjb25zdHJhaW50IG11bHRpcGxpZXIpXG4gICAgY29uc3Qgc2l0ZUNvc3QgPSByZWdpb25hbFJlc3VsdC5zaXRlQ29zdFBlclBmbG9wWWVhcjsgLy8gU2l0ZSBjb3N0cyBXSVRIIGNvbnN0cmFpbnQgbXVsdGlwbGllclxuICAgIFxuICAgIC8vIEdST1VORCBDT1NUIEFDQ09VTlRJTkc6IEV4cGxpY2l0IHNlcGFyYXRpb24gZm9yIHJlZ2lvbmFsIG1vZGVsXG4gICAgY29uc3Qgc2l0ZUNvc3RCYXNlID0gQkFTRV9TSVRFXzIwMjU7XG4gICAgXG4gICAgLy8gMS4gc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXI6IEJhc2Ugc2l0ZSBjYXBleCAoTk9UIGFmZmVjdGVkIGJ5IGNvbnN0cmFpbnQpXG4gICAgY29uc3Qgc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgPSBzaXRlQ29zdEJhc2U7XG4gICAgXG4gICAgLy8gMi4gY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXI6IFByZW1pdW0gYWJvdmUgYmFzZSAoZnJvbSBjb25zdHJhaW50IG11bHRpcGxpZXIpXG4gICAgY29uc3QgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXIgPSBNYXRoLm1heCgwLCBzaXRlQ29zdCAtIHNpdGVDb3N0QmFzZSk7XG4gICAgXG4gICAgLy8gMy4gdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyOiBSZWdpb25hbCBtb2RlbCBkb2Vzbid0IG1vZGVsIHF1ZXVlIGRlbGF5IHNlcGFyYXRlbHkgKDAgZm9yIG5vdylcbiAgICBjb25zdCB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgPSAwO1xuICAgIFxuICAgIC8vIElOVkFSSUFOVDogc2l0ZUNvc3RQZXJQZmxvcFllYXIgPSBzaXRlQ2FwZXhBbW9ydCArIHRpbWVUb0VuZXJnaXplUGVuYWx0eSArIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtXG4gICAgY29uc3Qgc2l0ZUNvc3RQZXJQZmxvcFllYXIgPSBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciArIHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciArIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyO1xuICAgIFxuICAgIC8vIFZhbGlkYXRpb24gKGFsbG93IHNtYWxsIHRvbGVyYW5jZSBmb3IgcmVnaW9uYWwgbW9kZWwgYXBwcm94aW1hdGlvbilcbiAgICBjb25zdCBzaXRlQ29zdENoZWNrID0gTWF0aC5hYnMoc2l0ZUNvc3QgLSBzaXRlQ29zdFBlclBmbG9wWWVhcik7XG4gICAgaWYgKHNpdGVDb3N0Q2hlY2sgPiAxLjApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2l0ZSBjb3N0IGFjY291bnRpbmcgZXJyb3IgKHJlZ2lvbmFsIG1vZGVsKTogc2l0ZUNvc3Q9JHtzaXRlQ29zdH0gIT0gc3VtKGNvbXBvbmVudHMpPSR7c2l0ZUNvc3RQZXJQZmxvcFllYXJ9LCBkaWZmPSR7c2l0ZUNvc3RDaGVja31gKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ1JJVElDQUwgRklYOiBSZWdpb25hbCBtb2RlbCBhbHJlYWR5IHNlcGFyYXRlcyBlbmVyZ3kgKG5vIG11bHRpcGxpZXIpIGZyb20gc2l0ZSAod2l0aCBwcmVtaXVtKVxuICAgIC8vIERvIE5PVCBhcHBseSBjb25zdHJhaW50TXVsdGlwbGllciAtIGl0J3MgYWxyZWFkeSByZWZsZWN0ZWQgaW4gc2l0ZUNvc3RQZXJQZmxvcFllYXJcbiAgICBjb25zdCBjb25zdHJhaW50TXVsdGlwbGllciA9IDEuMDsgLy8gTm90IGFwcGxpZWQgLSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXQgb25seVxuICAgIFxuICAgIGdyb3VuZFRvdGFsQ29zdCA9IHJlZ2lvbmFsUmVzdWx0LnRvdGFsQ29zdFBlclBmbG9wWWVhcjtcbiAgICBncm91bmRIYXNRdWV1ZSA9IGZhbHNlOyAvLyBSZWdpb25hbCBtb2RlbCBkb2Vzbid0IG1vZGVsIHF1ZXVlIGRlbGF5IHNlcGFyYXRlbHlcbiAgICBncm91bmRDb21wYXJhdG9yQ29zdFBlclBmbG9wWWVhciA9IGdyb3VuZFRvdGFsQ29zdDsgLy8gVXNlIGJhc2UgY29zdCBmb3IgcmVnaW9uYWwgbW9kZWxcbiAgICBlbmVyZ3lDb25zdHJhaW50TXVsdGlwbGllciA9IDEuMDsgLy8gTmV2ZXIgYXBwbGllZFxuICAgIGNvbnN0cmFpbnRCcmVha2Rvd24gPSB7XG4gICAgICBncmlkOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICBjb29saW5nOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICB3YXRlcjogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgbGFuZDogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgZW5lcmd5TXVsdGlwbGllcjogMS4wLCAvLyBOZXZlciBhcHBsaWVkXG4gICAgICBzaXRlTXVsdGlwbGllcjogMS4wLCAvLyBOb3QgYXBwbGllZCAtIGNvbnN0cmFpbnQgZWZmZWN0cyBhbHJlYWR5IGluIHNpdGVDb3N0XG4gICAgICBjYXBhY2l0eURlbGl2ZXJ5TXVsdGlwbGllcjogMS4wLCAvLyBOb3QgYXBwbGllZCAtIGNvbnN0cmFpbnQgZWZmZWN0cyBhbHJlYWR5IGluIHNpdGVDb3N0XG4gICAgfTtcbiAgICBcbiAgICBncm91bmRSZXN1bHQgPSB7XG4gICAgICBlbmVyZ3lDb3N0OiBlbmVyZ3lDb3N0LCAvLyBSYXcgZWxlY3RyaWNpdHkgY29zdCAoTk8gY29uc3RyYWludCBtdWx0aXBsaWVyKVxuICAgICAgc2l0ZUNvc3Q6IHNpdGVDb3N0UGVyUGZsb3BZZWFyLCAvLyBTaXRlID0gc3VtIG9mIGNvbXBvbmVudHMgKElOVkFSSUFOVClcbiAgICAgIHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyOiBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciwgLy8gRXhwbGljaXQ6IHB1cmUgY2FwZXhcbiAgICAgIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtOiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhciwgLy8gRXhwbGljaXQ6IHNjYXJjaXR5IHByZW1pdW1cbiAgICAgIHRpbWVUb0VuZXJnaXplUGVuYWx0eTogdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyLCAvLyBSZWdpb25hbCBtb2RlbDogMCAobm90IG1vZGVsZWQgc2VwYXJhdGVseSlcbiAgICAgIGhhcmR3YXJlQ29zdDogcmVnaW9uYWxSZXN1bHQuaGFyZHdhcmVDYXBleFBlclBmbG9wWWVhcixcbiAgICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhcjogZ3JvdW5kVG90YWxDb3N0LFxuICAgICAgY29uc3RyYWludE11bHRpcGxpZXI6IDEuMCwgLy8gTk9UIEFQUExJRUQgLSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXQgb25seVxuICAgICAgY29uc3RyYWludHM6IHtcbiAgICAgICAgbWV0aG9kOiAnYWRkZXJzJyxcbiAgICAgICAgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW06IGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyLCAvLyBGcm9tIHJlZ2lvbmFsIG1vZGVsIHNpdGVDb3N0IC0gc2l0ZUNvc3RCYXNlXG4gICAgICAgIGRlbGF5UGVuYWx0eTogMCwgLy8gUmVnaW9uYWwgbW9kZWwgZG9lc24ndCBtb2RlbCBkZWxheSBzZXBhcmF0ZWx5XG4gICAgICAgIGFwcGxpZWRNdWx0aXBsaWVyczoge1xuICAgICAgICAgIGNvbnN0cmFpbnRNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgICAgZW5lcmd5TXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgICAgIHNpdGVNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgZG91YmxlQ291bnRDaGVjazoge1xuICAgICAgICAgICAgbW9kZTogJ2FkZGVycycsXG4gICAgICAgICAgICBtdWx0aXBsaWVyQXBwbGllZDogZmFsc2UsXG4gICAgICAgICAgICBhZGRlcnNBcHBsaWVkOiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhciA+IDAsXG4gICAgICAgICAgICBpbnZhcmlhbnRPazogdHJ1ZSxcbiAgICAgICAgICAgIG5vdGVzOiAnUmVnaW9uYWwgbW9kZWwgdXNlcyBhZGRlcnMgb25seSAoY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gZnJvbSBzaXRlQ29zdCAtIHNpdGVDb3N0QmFzZSknLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgYnJlYWtkb3duOiBjb25zdHJhaW50QnJlYWtkb3duLFxuICAgICAgc21yRW5hYmxlZDogZmFsc2UsXG4gICAgICBzbXJSYW1wRmFjdG9yOiAwLFxuICAgICAgZWZmZWN0aXZlRWxlY3RyaWNpdHlDb3N0OiByZWdpb25hbFJlc3VsdC5hdmVyYWdlRW5lcmd5Q29zdE13aCxcbiAgICAgIGNvbnN0cmFpbnRSZWxpZWY6IHsgZ3JpZDogMCwgY29vbGluZzogMCwgd2F0ZXI6IDAsIGxhbmQ6IDAgfSxcbiAgICAgIC8vIEVuc3VyZSBiYWNrbG9nR3cgYW5kIGF2Z1dhaXRZZWFycyBhcmUgYWx3YXlzIHNldCAodXNlIHN1cHBseU1ldHJpY3MgYXMgZmFsbGJhY2spXG4gICAgICBiYWNrbG9nR3c6IHJlZ2lvbmFsUmVzdWx0LnN1cHBseU1ldHJpY3M/LnBpcGVsaW5lR3cgPz8gMCwgLy8gVEVNUCBwcm94eTogdXNlIHBpcGVsaW5lIGFzIHBsYWNlaG9sZGVyXG4gICAgICBhdmdXYWl0WWVhcnM6IHJlZ2lvbmFsUmVzdWx0LnN1cHBseU1ldHJpY3M/LmF2Z1dhaXRZZWFycyA/PyAwLFxuICAgICAgc3VwcGx5TWV0cmljczogcmVnaW9uYWxSZXN1bHQuc3VwcGx5TWV0cmljcyA/PyB7XG4gICAgICAgIGRlbWFuZEd3OiAwLFxuICAgICAgICBjYXBhY2l0eUd3OiAwLFxuICAgICAgICBwaXBlbGluZUd3OiAwLFxuICAgICAgICBtYXhCdWlsZFJhdGVHd1llYXI6IDAsXG4gICAgICAgIGF2Z1dhaXRZZWFyczogMCxcbiAgICAgICAgdXRpbGl6YXRpb25QY3Q6IDAsXG4gICAgICB9LFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZ3JvdW5kUmVzdWx0ID0gY2FsY3VsYXRlR3JvdW5kVG90YWwoXG4gICAgICB5ZWFyLFxuICAgICAgcGFyYW1zLFxuICAgICAgRU5FUkdZX0NPU1RfQkFTRV8yMDI1LFxuICAgICAgZ3JvdW5kSGFyZHdhcmVDYXBleFBlclBmbG9wWWVhcixcbiAgICAgIHBhcmFtcy5pc1N0YXRpY01vZGUsXG4gICAgICBlZmZlY3RpdmVHcm91bmRTY2VuYXJpbyxcbiAgICAgIGdyb3VuZExhdGVuY3lQZW5hbHR5LFxuICAgICAgc21yUGFyYW1zLFxuICAgICAgZmlyc3RDYXBZZWFyID8/IG51bGwsXG4gICAgICBncm91bmRFbmVyZ3lDb3N0UGVyUGZsb3BZZWFyLFxuICAgICAgZ3JvdW5kRWxlY3RyaWNpdHlQcmljZVBlck13aFxuICAgICk7XG5cbiAgICAvLyBDUklUSUNBTCBGSVg6IEVuc3VyZSBiYWNrbG9nR3cgYW5kIGF2Z1dhaXRZZWFycyBhcmUgYWx3YXlzIHNldCAoZXZlbiBpZiBjYWxjdWxhdGVHcm91bmRUb3RhbCBkb2Vzbid0IHByb3ZpZGUgdGhlbSlcbiAgICAvLyBVc2Ugc3VwcGx5TWV0cmljcyBhcyBmYWxsYmFjayBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSAwXG4gICAgLy8gVHlwZSBhc3NlcnRpb24gbmVlZGVkIGJlY2F1c2UgY2FsY3VsYXRlR3JvdW5kVG90YWwgbWF5IG5vdCBpbmNsdWRlIHRoZXNlIGZpZWxkc1xuICAgIGNvbnN0IGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nID0gZ3JvdW5kUmVzdWx0IGFzIGFueTtcbiAgICBpZiAoISgnYmFja2xvZ0d3JyBpbiBncm91bmRSZXN1bHRXaXRoQmFja2xvZykgfHwgZ3JvdW5kUmVzdWx0V2l0aEJhY2tsb2cuYmFja2xvZ0d3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nLmJhY2tsb2dHdyA9IGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nLnN1cHBseU1ldHJpY3M/LnBpcGVsaW5lR3cgPz8gMDsgLy8gVEVNUCBwcm94eVxuICAgIH1cbiAgICBpZiAoISgnYXZnV2FpdFllYXJzJyBpbiBncm91bmRSZXN1bHRXaXRoQmFja2xvZykgfHwgZ3JvdW5kUmVzdWx0V2l0aEJhY2tsb2cuYXZnV2FpdFllYXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nLmF2Z1dhaXRZZWFycyA9IGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nLnN1cHBseU1ldHJpY3M/LmF2Z1dhaXRZZWFycyA/PyAwO1xuICAgIH1cbiAgICAvLyBFbnN1cmUgc3VwcGx5TWV0cmljcyBleGlzdHNcbiAgICBpZiAoIWdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nLnN1cHBseU1ldHJpY3MpIHtcbiAgICAgIGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nLnN1cHBseU1ldHJpY3MgPSB7XG4gICAgICAgIGRlbWFuZEd3OiAwLFxuICAgICAgICBjYXBhY2l0eUd3OiAwLFxuICAgICAgICBwaXBlbGluZUd3OiBncm91bmRSZXN1bHRXaXRoQmFja2xvZy5iYWNrbG9nR3cgPz8gMCxcbiAgICAgICAgbWF4QnVpbGRSYXRlR3dZZWFyOiAwLFxuICAgICAgICBhdmdXYWl0WWVhcnM6IGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nLmF2Z1dhaXRZZWFycyA/PyAwLFxuICAgICAgICB1dGlsaXphdGlvblBjdDogMCxcbiAgICAgIH07XG4gICAgfVxuICAgIGdyb3VuZFJlc3VsdCA9IGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nO1xuXG4gICAgZ3JvdW5kVG90YWxDb3N0ID0gZ3JvdW5kUmVzdWx0LnRvdGFsQ29zdFBlclBmbG9wWWVhcjtcbiAgICBncm91bmRIYXNRdWV1ZSA9IChncm91bmRSZXN1bHQudGltZVRvRW5lcmdpemVQZW5hbHR5ID8/IDApID4gMC4wMTsgLy8gQ2hlY2sgaWYgZGVsYXkgcGVuYWx0eSBleGlzdHNcbiAgICBncm91bmRDb21wYXJhdG9yQ29zdFBlclBmbG9wWWVhciA9IGdyb3VuZEhhc1F1ZXVlXG4gICAgICA/IChncm91bmRSZXN1bHQudG90YWxDb3N0UGVyUGZsb3BZZWFyRWZmZWN0aXZlID8/IGdyb3VuZFJlc3VsdC50b3RhbENvc3RQZXJQZmxvcFllYXIpXG4gICAgICA6IGdyb3VuZFRvdGFsQ29zdDtcbiAgICAvLyBDUklUSUNBTCBGSVg6IE5ldmVyIGFwcGx5IG11bHRpcGxpZXJzIC0gYWxsIHNldCB0byAxLjBcbiAgICBlbmVyZ3lDb25zdHJhaW50TXVsdGlwbGllciA9IDEuMDsgLy8gTmV2ZXIgYXBwbGllZFxuICAgIFxuICAgIC8vIEludmFyaWFudDogSWYgdXNpbmcgYWRkZXJzLCBtdWx0aXBsaWVycyBtdXN0IG5vdCBiZSBhcHBsaWVkXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIGdyb3VuZFJlc3VsdC5jb25zdHJhaW50cykge1xuICAgICAgY29uc3QgaGFzTXVsdGlwbGllciA9IGdyb3VuZFJlc3VsdC5jb25zdHJhaW50TXVsdGlwbGllciAhPT0gMS4wO1xuICAgICAgY29uc3QgaGFzQWRkZXIgPSAoZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRzLmNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtID4gMCkgfHwgKGdyb3VuZFJlc3VsdC5jb25zdHJhaW50cy5kZWxheVBlbmFsdHkgPiAwKTtcbiAgICAgIGlmIChoYXNNdWx0aXBsaWVyICYmIGhhc0FkZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgW0RPVUJMRSBDT1VOVElORyBERVRFQ1RFRF0gWWVhciAke3llYXJ9OiBjb25zdHJhaW50TXVsdGlwbGllcj0ke2dyb3VuZFJlc3VsdC5jb25zdHJhaW50TXVsdGlwbGllcn0gIT0gMS4wIGAgK1xuICAgICAgICAgIGBBTkQgYWRkZXJzID4gMCAoY2FwYWNpdHlEZWxpdmVyeVByZW1pdW09JHtncm91bmRSZXN1bHQuY29uc3RyYWludHMuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW19LCBgICtcbiAgICAgICAgICBgZGVsYXlQZW5hbHR5PSR7Z3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRzLmRlbGF5UGVuYWx0eX0pLiBCb3RoIGNhbm5vdCBiZSBhcHBsaWVkIHNpbXVsdGFuZW91c2x5LmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3RyYWludEJyZWFrZG93biA9IHtcbiAgICAgIGdyaWQ6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIGNvb2xpbmc6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIHdhdGVyOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICBsYW5kOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICBlbmVyZ3lNdWx0aXBsaWVyOiAxLjAsIC8vIE5ldmVyIGFwcGxpZWRcbiAgICAgIHNpdGVNdWx0aXBsaWVyOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICBjYXBhY2l0eURlbGl2ZXJ5TXVsdGlwbGllcjogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgIH07XG4gICAgXG4gICAgLy8gSW52YXJpYW50OiBDaGVjayBmb3IgZG91YmxlIGNvdW50aW5nXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBjb25zdCBoYXNNdWx0aXBsaWVyID0gKGdyb3VuZFJlc3VsdC5jb25zdHJhaW50TXVsdGlwbGllciAhPT0gMS4wKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChncm91bmRSZXN1bHQuYnJlYWtkb3duLmVuZXJneU11bHRpcGxpZXIgIT09IDEuMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChncm91bmRSZXN1bHQuYnJlYWtkb3duLnNpdGVNdWx0aXBsaWVyICE9PSAxLjApO1xuICAgICAgY29uc3QgaGFzUHJlbWl1bSA9IChncm91bmRSZXN1bHQuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gfHwgMCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoZ3JvdW5kUmVzdWx0LnRpbWVUb0VuZXJnaXplUGVuYWx0eSB8fCAwKSA+IDA7XG4gICAgICBpZiAoaGFzTXVsdGlwbGllciAmJiBoYXNQcmVtaXVtKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgW0RPVUJMRSBDT1VOVElORyBERVRFQ1RFRF0gWWVhciAke3llYXJ9OiBgICtcbiAgICAgICAgICBgTXVsdGlwbGllcnMgKGNvbnN0cmFpbnQ9JHtncm91bmRSZXN1bHQuY29uc3RyYWludE11bHRpcGxpZXJ9LCBgICtcbiAgICAgICAgICBgZW5lcmd5PSR7Z3JvdW5kUmVzdWx0LmJyZWFrZG93bi5lbmVyZ3lNdWx0aXBsaWVyfSwgYCArXG4gICAgICAgICAgYHNpdGU9JHtncm91bmRSZXN1bHQuYnJlYWtkb3duLnNpdGVNdWx0aXBsaWVyfSkgQU5EIGAgK1xuICAgICAgICAgIGBwcmVtaXVtcyAoY2FwYWNpdHk9JHtncm91bmRSZXN1bHQuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW19LCBgICtcbiAgICAgICAgICBgZGVsYXk9JHtncm91bmRSZXN1bHQudGltZVRvRW5lcmdpemVQZW5hbHR5fSkgYXJlIGJvdGggcHJlc2VudC4gYCArXG4gICAgICAgICAgYFRoaXMgaW5kaWNhdGVzIGRvdWJsZSBjb3VudGluZy5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbGF1bmNoQ29zdFBlcktnID0gZ2V0TGF1bmNoQ29zdFBlcktnKHllYXIsIGJhc2VMYXVuY2hDb3N0KSAqIGxhdW5jaERpc2NvdW50O1xuICBjb25zdCBsaWZldGltZVllYXJzID0gNjtcbiAgXG4gIC8vIEZ1c2lvbiB0b2dnbGUgcGFyYW1zXG4gIGNvbnN0IGZ1c2lvblBhcmFtcyA9IHBhcmFtcy5mdXNpb25Ub2dnbGVFbmFibGVkIFxuICAgID8gKHBhcmFtcy5mdXNpb25Ub2dnbGVQYXJhbXMgfHwgeyAuLi5ERUZBVUxUX0ZVU0lPTl9QQVJBTVMsIGVuYWJsZWQ6IHRydWUgfSlcbiAgICA6IHVuZGVmaW5lZDtcblxuICAvLyBDT05TVEVMTEFUSU9OIFNJWklORzogRGVzaWduIGNvbnN0ZWxsYXRpb24gdG8gbWVldCBjb21wdXRlIHJlcXVpcmVtZW50c1xuICAvLyBDb252ZXJ0IHRhcmdldCBjb21wdXRlIChHVykgdG8gcG93ZXIgKGtXKSBmb3IgY29uc3RlbGxhdGlvbiBzaXppbmdcbiAgY29uc3QgdGFyZ2V0Q29tcHV0ZUt3ID0gc2F0ZWxsaXRlUG93ZXJLVztcbiAgbGV0IGNvbnN0ZWxsYXRpb24gPSBkZXNpZ25Db25zdGVsbGF0aW9uKFxuICAgIHRhcmdldENvbXB1dGVLdyxcbiAgICBTQVRFTExJVEVfQ09OU1RSQUlOVFMsXG4gICAgMTAwMDAwLCAvLyBTdGFyc2hpcDogMTAwdCB0byBMRU9cbiAgICB0cmFqU3BlY2lmaWNQb3dlclxuICApO1xuICBcbiAgLy8gVXNlIHBlci1zYXRlbGxpdGUgY29tcHV0ZSBwb3dlciBmb3IgY29zdCBjYWxjdWxhdGlvblxuICBsZXQgY29tcHV0ZVBvd2VyUGVyU2F0S3cgPSBjb25zdGVsbGF0aW9uLmNvbXB1dGVQZXJTYXRLdztcblxuICBsZXQgaHlicmlkUmVzdWx0ID0gY29tcHV0ZVNhdGVsbGl0ZUh5YnJpZENvc3QoXG4gICAgeWVhciwgXG4gICAgbGF1bmNoQ29zdFBlcktnLCBcbiAgICB7XG4gICAgICAuLi5ERUZBVUxUX0NPTkZJRyxcbiAgICAgIGNvbXB1dGVQb3dlckt3OiBjb21wdXRlUG93ZXJQZXJTYXRLdywgLy8gVXNlIHBlci1zYXRlbGxpdGUgcG93ZXJcbiAgICAgIGFsdGl0dWRlS206IG9yYml0YWxBbHRpdHVkZSxcbiAgICAgIGxpZmV0aW1lWWVhcnM6IGxpZmV0aW1lWWVhcnMsXG4gICAgICBzcGVjaWZpY1Bvd2VyV0tnOiB0cmFqU3BlY2lmaWNQb3dlcixcbiAgICAgIHVzZVJhZEhhcmRDaGlwczogdXNlUmFkSGFyZENoaXBzLFxuICAgICAgc3VuRnJhY3Rpb246IHN1bkZyYWN0aW9uLFxuICAgICAgd29ya2xvYWRUeXBlOiB3b3JrbG9hZFR5cGUgfHwgJ2luZmVyZW5jZSdcbiAgICB9LCBcbiAgICBmdXNpb25QYXJhbXMsXG4gICAgcGFyYW1zLnVzZUNvcnJlY3RlZFNwZWNpZmljUG93ZXIsXG4gICAgcGFyYW1zLnVzZUNvcnJlY3RlZFRoZXJtYWxcbiAgKTtcbiAgXG4gIC8vIENSSVRJQ0FMIEZJWDogQ2FsY3VsYXRlIGRlbGl2ZXJlZCBlZmZpY2llbmN5IHdpdGggQUxMIGRlbGl2ZXJ5IGRlcmF0ZXNcbiAgLy8gZGVsaXZlcmVkID0gc3lzdGVtRWZmZWN0aXZlICogdGhlcm1hbENhcEZhY3RvciAqIHJhZGlhdGlvbkRlcmF0ZSAqIGF2YWlsYWJpbGl0eVxuICAvLyBTaW5nbGUgc291cmNlIG9mIHRydXRoIGZvciBhbGwgdGhyZWUgZmFjdG9yczpcbiAgY29uc3QgdGhlcm1hbENhcEZhY3RvciA9IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnRoZXJtYWxDYXBGYWN0b3I7XG4gIGNvbnN0IHJhZGlhdGlvbkRlcmF0ZSA9IGh5YnJpZFJlc3VsdC5kZWdyYWRhdGlvbkZhY3RvciB8fCAxLjA7IC8vIEhhcmR3YXJlIGRlZ3JhZGF0aW9uIGZyb20gcmFkaWF0aW9uIChjaGlwIGZhaWx1cmVzLCBFQ0Mgb3ZlcmhlYWQpXG4gIGNvbnN0IGF2YWlsYWJpbGl0eSA9IGh5YnJpZFJlc3VsdC5jYXBhY2l0eUZhY3RvciB8fCAxLjA7IC8vIENhcGFjaXR5IGZhY3RvciBpcyB1cHRpbWUtaW5jbHVzaXZlIChpbmNsdWRlcyBlY2xpcHNlLCBkZWdyYWRhdGlvbiwgcmFkaWF0aW9uIGRvd250aW1lLCB1cHRpbWUpXG4gIFxuICAvLyBDYWxjdWxhdGUgZGVsaXZlcmVkIGVmZmljaWVuY3kgKGFsbCBkZXJhdGVzIGFwcGxpZWQgbXVsdGlwbGljYXRpdmVseSlcbiAgLy8gVGhpcyBpcyB0aGUgdHJ1ZSBcImRlbGl2ZXJlZFwiIGVmZmljaWVuY3kgdGhhdCBhY2NvdW50cyBmb3IgYWxsIG9wZXJhdGlvbmFsIGNvbnN0cmFpbnRzXG4gIGxldCBvcmJpdERlbGl2ZXJlZEdmbG9wc1BlcldhdHQgPSBvcmJpdFN5c3RlbUVmZmVjdGl2ZUdmbG9wc1BlcldhdHQgKiB0aGVybWFsQ2FwRmFjdG9yICogcmFkaWF0aW9uRGVyYXRlICogYXZhaWxhYmlsaXR5O1xuICBcbiAgLy8gQ1JJVElDQUw6IElmIHRoZXJtYWwgY29uc3RyYWludCBjYXVzZXMgZGVsaXZlcmVkIGVmZmljaWVuY3kgdG8gZHJvcCBiZWxvdyBtaW5pbXVtICgyMCBHRkxPUFMvVyksXG4gIC8vIHRoaXMgaW5kaWNhdGVzIGEgc2V2ZXJlIHRoZXJtYWwgY29uc3RyYWludCB0aGF0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IGV4cGFuZGluZyByYWRpYXRvciBvciByZWR1Y2luZyBjb21wdXRlXG4gIC8vIEZvciBub3csIHdlIGNsYW1wIHRvIG1pbmltdW0gdG8gcHJldmVudCB2YWxpZGF0aW9uIGVycm9ycywgYnV0IGxvZyBhIHdhcm5pbmcgKG9ubHkgb25jZSBwZXIgeWVhcilcbiAgaWYgKG9yYml0RGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCA8IENPTlNUQU5UUy5NSU5fREVMSVZFUkVEX0dGTE9QU19QRVJfVykge1xuICAgIGNvbnN0IG9yaWdpbmFsRGVsaXZlcmVkID0gb3JiaXREZWxpdmVyZWRHZmxvcHNQZXJXYXR0O1xuICAgIG9yYml0RGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCA9IENPTlNUQU5UUy5NSU5fREVMSVZFUkVEX0dGTE9QU19QRVJfVztcbiAgICBcbiAgICAvLyBMb2cgd2FybmluZyBhYm91dCBzZXZlcmUgdGhlcm1hbCBjb25zdHJhaW50IChvbmx5IGluIGRldiwgYW5kIG9ubHkgb25jZSBwZXIgeWVhciB0byByZWR1Y2Ugc3BhbSlcbiAgICAvLyBUaGUgYWN0dWFsIGNsYW1wZWQgdmFsdWUgaXMgYXZhaWxhYmxlIGluIG9yYml0LmNvbXB1dGVFZmZpY2llbmN5LnZhbGlkYXRpb24gbWV0YWRhdGFcbiAgICAvLyBUaGVybWFsIGNvbnN0cmFpbnQgd2FybmluZ3MgcmVtb3ZlZCBmb3IgY2xlYW5lciBjb25zb2xlIG91dHB1dFxuICB9XG4gIFxuICAvLyBVc2UgZGVsaXZlcmVkIGVmZmljaWVuY3kgZm9yIGFsbCBjb3N0IGNhbGN1bGF0aW9uc1xuICBsZXQgb3JiaXRFZmZlY3RpdmVHZmxvcHNQZXJXID0gdmFsaWRhdGVHZmxvcHNQZXJXYXR0KFxuICAgIG9yYml0RGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCxcbiAgICAnb3JiaXRhbCBkZWxpdmVyZWQgZWZmaWNpZW5jeSBjYWxjdWxhdGlvbidcbiAgKTtcbiAgXG4gIC8vIFBvd2VyIHNjYWxpbmcgY2FsY3VsYXRpb25cbiAgY29uc3QgcG93ZXJTY2FsaW5nUGFyYW1zID0gcGFyYW1zLnBvd2VyU2NhbGluZ1BhcmFtcyB8fCBERUZBVUxUX1BPV0VSX1NDQUxJTkc7XG4gIGNvbnN0IHNjYWxpbmdSZXN1bHQgPSBjYWxjdWxhdGVTY2FsZWRNYXNzKGNvbXB1dGVQb3dlclBlclNhdEt3LCBwb3dlclNjYWxpbmdQYXJhbXMpO1xuXG4gIC8vIENPTlNURUxMQVRJT04gU0NBTElORzogQXBwbHkgY29uc3RlbGxhdGlvbiBtdWx0aXBsaWVyIHRvIG1hc3MgYW5kIGNvc3RzXG4gIC8vIFBlci1zYXRlbGxpdGUgbWFzcyAoYWxyZWFkeSBjYWxjdWxhdGVkIGZvciBvbmUgc2F0ZWxsaXRlKVxuICBsZXQgbWFzc1BlclNhdEtnID0gaHlicmlkUmVzdWx0LnRvdGFsTWFzc0tnICogbWFzc011bHRpcGxpZXI7XG4gIFxuICAvLyBDUklUSUNBTCBGSVg6IENoZWNrIGlmIGFjdHVhbCBtYXNzIGV4Y2VlZHMgbGltaXQgYW5kIHJlLXNwbGl0IGNvbnN0ZWxsYXRpb24gaWYgbmVlZGVkXG4gIC8vIFRoZSBzaW1wbGlmaWVkIG1hc3MgbW9kZWwgaW4gZGVzaWduQ29uc3RlbGxhdGlvbiBtYXkgdW5kZXJlc3RpbWF0ZSBhY3R1YWwgbWFzc1xuICAvLyBJZiBhY3R1YWwgbWFzcyBleGNlZWRzIGxpbWl0LCB3ZSBuZWVkIHRvIHNwbGl0IGludG8gc21hbGxlciBzYXRlbGxpdGVzXG4gIGNvbnN0IE1BWF9TQVRFTExJVEVfTUFTU19LRyA9IFNBVEVMTElURV9DT05TVFJBSU5UUy5tYXhNYXNzS2c7IC8vIDEwLDAwMCBrZyBmcm9tIGNvbnN0cmFpbnRzXG4gIGlmIChtYXNzUGVyU2F0S2cgPiBNQVhfU0FURUxMSVRFX01BU1NfS0cpIHtcbiAgICAvLyBDYWxjdWxhdGUgcmVxdWlyZWQgY29tcHV0ZSBwZXIgc2F0ZWxsaXRlIHRvIHN0YXkgdW5kZXIgbWFzcyBsaW1pdFxuICAgIC8vIE1hc3Mgc2NhbGVzIHJvdWdobHkgd2l0aCBjb21wdXRlIHBvd2VyLCBzbzogbWFzc1BlclNhdEtnIC8gY29tcHV0ZVBvd2VyUGVyU2F0S3cgPSBtYXNzUGVyS3dcbiAgICBjb25zdCBtYXNzUGVyS3cgPSBtYXNzUGVyU2F0S2cgLyBjb21wdXRlUG93ZXJQZXJTYXRLdztcbiAgICBjb25zdCBtYXhDb21wdXRlUGVyU2F0S3cgPSBNQVhfU0FURUxMSVRFX01BU1NfS0cgLyBtYXNzUGVyS3c7XG4gICAgXG4gICAgLy8gUmVjYWxjdWxhdGUgY29uc3RlbGxhdGlvbiB3aXRoIHNtYWxsZXIgc2F0ZWxsaXRlc1xuICAgIGNvbnN0IGFkanVzdGVkQ29uc3RlbGxhdGlvbiA9IGRlc2lnbkNvbnN0ZWxsYXRpb24oXG4gICAgICB0YXJnZXRDb21wdXRlS3csXG4gICAgICB7XG4gICAgICAgIC4uLlNBVEVMTElURV9DT05TVFJBSU5UUyxcbiAgICAgICAgbWF4Q29tcHV0ZUt3OiBtYXhDb21wdXRlUGVyU2F0S3cgKiAwLjksIC8vIFVzZSA5MCUgb2YgbWF4IHRvIGxlYXZlIG1hcmdpblxuICAgICAgfSxcbiAgICAgIDEwMDAwMCwgLy8gU3RhcnNoaXA6IDEwMHQgdG8gTEVPXG4gICAgICB0cmFqU3BlY2lmaWNQb3dlclxuICAgICk7XG4gICAgXG4gICAgLy8gUmVjYWxjdWxhdGUgaHlicmlkIGNvc3Qgd2l0aCBhZGp1c3RlZCBjb21wdXRlIHBlciBzYXRlbGxpdGVcbiAgICBjb25zdCBhZGp1c3RlZEh5YnJpZFJlc3VsdCA9IGNvbXB1dGVTYXRlbGxpdGVIeWJyaWRDb3N0KFxuICAgICAgeWVhciwgXG4gICAgICBsYXVuY2hDb3N0UGVyS2csIFxuICAgICAge1xuICAgICAgICAuLi5ERUZBVUxUX0NPTkZJRyxcbiAgICAgICAgY29tcHV0ZVBvd2VyS3c6IGFkanVzdGVkQ29uc3RlbGxhdGlvbi5jb21wdXRlUGVyU2F0S3csXG4gICAgICAgIGFsdGl0dWRlS206IG9yYml0YWxBbHRpdHVkZSxcbiAgICAgICAgbGlmZXRpbWVZZWFyczogbGlmZXRpbWVZZWFycyxcbiAgICAgICAgc3BlY2lmaWNQb3dlcldLZzogdHJhalNwZWNpZmljUG93ZXIsXG4gICAgICAgIHVzZVJhZEhhcmRDaGlwczogdXNlUmFkSGFyZENoaXBzLFxuICAgICAgICBzdW5GcmFjdGlvbjogc3VuRnJhY3Rpb24sXG4gICAgICAgIHdvcmtsb2FkVHlwZTogd29ya2xvYWRUeXBlIHx8ICdpbmZlcmVuY2UnXG4gICAgICB9LCBcbiAgICAgIGZ1c2lvblBhcmFtcyxcbiAgICAgIHBhcmFtcy51c2VDb3JyZWN0ZWRTcGVjaWZpY1Bvd2VyLFxuICAgICAgcGFyYW1zLnVzZUNvcnJlY3RlZFRoZXJtYWxcbiAgICApO1xuICAgIFxuICAgIC8vIFVwZGF0ZSB3aXRoIGFkanVzdGVkIHZhbHVlc1xuICAgIGNvbnN0IGFkanVzdGVkTWFzc1BlclNhdEtnID0gYWRqdXN0ZWRIeWJyaWRSZXN1bHQudG90YWxNYXNzS2cgKiBtYXNzTXVsdGlwbGllcjtcbiAgICBpZiAoYWRqdXN0ZWRNYXNzUGVyU2F0S2cgPiBNQVhfU0FURUxMSVRFX01BU1NfS0cpIHtcbiAgICAgIC8vIFN0aWxsIHRvbyBoZWF2eSAtIHRoaXMgc2hvdWxkbid0IGhhcHBlbiwgYnV0IGxvZyBhIHdhcm5pbmdcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFNhdGVsbGl0ZSBtYXNzICR7YWRqdXN0ZWRNYXNzUGVyU2F0S2cudG9GaXhlZCgwKX1rZyBzdGlsbCBleGNlZWRzIGxpbWl0ICR7TUFYX1NBVEVMTElURV9NQVNTX0tHfWtnIGAgK1xuICAgICAgICBgZXZlbiBhZnRlciBzcGxpdHRpbmcgdG8gJHthZGp1c3RlZENvbnN0ZWxsYXRpb24uY29tcHV0ZVBlclNhdEt3LnRvRml4ZWQoMSl9a1cgcGVyIHNhdGVsbGl0ZS4gYCArXG4gICAgICAgIGBDb25zaWRlciBmdXJ0aGVyIHJlZHVjaW5nIGNvbXB1dGUgcGVyIHNhdGVsbGl0ZSBvciBpbXByb3Zpbmcgc3BlY2lmaWMgcG93ZXIuYFxuICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXNlIGFkanVzdGVkIGNvbnN0ZWxsYXRpb24gYW5kIGh5YnJpZCByZXN1bHRcbiAgICBjb25zdGVsbGF0aW9uID0gYWRqdXN0ZWRDb25zdGVsbGF0aW9uO1xuICAgIGh5YnJpZFJlc3VsdCA9IGFkanVzdGVkSHlicmlkUmVzdWx0O1xuICAgIGNvbXB1dGVQb3dlclBlclNhdEt3ID0gYWRqdXN0ZWRDb25zdGVsbGF0aW9uLmNvbXB1dGVQZXJTYXRLdztcbiAgICBtYXNzUGVyU2F0S2cgPSBhZGp1c3RlZE1hc3NQZXJTYXRLZztcbiAgICBcbiAgICAvLyBSZWNhbGN1bGF0ZSBkZWxpdmVyZWQgZWZmaWNpZW5jeSB3aXRoIGFkanVzdGVkIHRoZXJtYWwgY2FwIChhbGwgZGVyYXRlcyBhcHBsaWVkKVxuICAgIGNvbnN0IGFkanVzdGVkVGhlcm1hbENhcEZhY3RvciA9IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnRoZXJtYWxDYXBGYWN0b3I7XG4gICAgY29uc3QgYWRqdXN0ZWRSYWRpYXRpb25EZXJhdGUgPSBoeWJyaWRSZXN1bHQuZGVncmFkYXRpb25GYWN0b3IgfHwgMS4wO1xuICAgIGNvbnN0IGFkanVzdGVkQXZhaWxhYmlsaXR5ID0gaHlicmlkUmVzdWx0LmNhcGFjaXR5RmFjdG9yIHx8IDEuMDtcbiAgICBsZXQgYWRqdXN0ZWREZWxpdmVyZWRHZmxvcHNQZXJXYXR0ID0gb3JiaXRTeXN0ZW1FZmZlY3RpdmVHZmxvcHNQZXJXYXR0ICogYWRqdXN0ZWRUaGVybWFsQ2FwRmFjdG9yICogYWRqdXN0ZWRSYWRpYXRpb25EZXJhdGUgKiBhZGp1c3RlZEF2YWlsYWJpbGl0eTtcbiAgICBcbiAgICAvLyBDbGFtcCB0byBtaW5pbXVtIGlmIHRoZXJtYWwgY29uc3RyYWludCBpcyB0b28gc2V2ZXJlXG4gICAgaWYgKGFkanVzdGVkRGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCA8IENPTlNUQU5UUy5NSU5fREVMSVZFUkVEX0dGTE9QU19QRVJfVykge1xuICAgICAgYWRqdXN0ZWREZWxpdmVyZWRHZmxvcHNQZXJXYXR0ID0gQ09OU1RBTlRTLk1JTl9ERUxJVkVSRURfR0ZMT1BTX1BFUl9XO1xuICAgIH1cbiAgICBcbiAgICBvcmJpdEVmZmVjdGl2ZUdmbG9wc1BlclcgPSB2YWxpZGF0ZUdmbG9wc1BlcldhdHQoXG4gICAgICBhZGp1c3RlZERlbGl2ZXJlZEdmbG9wc1BlcldhdHQsXG4gICAgICAnb3JiaXRhbCBkZWxpdmVyZWQgZWZmaWNpZW5jeSAoYWZ0ZXIgY29uc3RlbGxhdGlvbiBzcGxpdCknXG4gICAgKTtcbiAgfVxuICBcbiAgLy8gU2NhbGUgY29zdHMgYnkgbnVtYmVyIG9mIHNhdGVsbGl0ZXMgYW5kIGFwcGx5IGNvbnN0ZWxsYXRpb24gb3ZlcmhlYWRcbiAgLy8gQ2FsY3VsYXRlIEFGVEVSIG1hc3MgY2hlY2sgc28gd2UgdXNlIHRoZSBhZGp1c3RlZCBjb25zdGVsbGF0aW9uIGlmIGl0IHdhcyBzcGxpdFxuICBjb25zdCBjb25zdGVsbGF0aW9uTXVsdGlwbGllciA9IGNvbnN0ZWxsYXRpb24ubnVtU2F0ZWxsaXRlcztcbiAgY29uc3QgY29uc3RlbGxhdGlvbk92ZXJoZWFkTXVsdGlwbGllciA9IGNvbnN0ZWxsYXRpb24uY29uc3RlbGxhdGlvbk92ZXJoZWFkO1xuICBcbiAgLy8gVG90YWwgY29uc3RlbGxhdGlvbiBtYXNzXG4gIGNvbnN0IGVmZmVjdGl2ZVRvdGFsTWFzc0tnID0gbWFzc1BlclNhdEtnICogY29uc3RlbGxhdGlvbi5udW1TYXRlbGxpdGVzO1xuICBjb25zdCBlZmZlY3RpdmVUb3RhbExhdW5jaENvc3QgPSBlZmZlY3RpdmVUb3RhbE1hc3NLZyAqIGxhdW5jaENvc3RQZXJLZztcblxuICAvLyBBcHBseSBFbG9uIFNjZW5hcmlvOiBEaXNjb3VudHNcbiAgY29uc3QgZWZmZWN0aXZlUG93ZXJGYWJDb3N0ID0gaHlicmlkUmVzdWx0LnBvd2VyU3lzdGVtLmZhYkNvc3RVc2QgKiBwb3dlckRpc2NvdW50O1xuICBjb25zdCBlZmZlY3RpdmVOZXR3b3JraW5nRmFiQ29zdCA9IGh5YnJpZFJlc3VsdC5uZXR3b3JraW5nLmZhYkNvc3RVc2QgKiBuZXR3b3JraW5nRGlzY291bnQ7XG4gIGNvbnN0IGVmZmVjdGl2ZU5ldHdvcmtpbmdPcEV4ID0gKGh5YnJpZFJlc3VsdC5uZXR3b3JraW5nLmFubnVhbE9wRXhVc2QgfHwgMCkgKiBuZXR3b3JraW5nRGlzY291bnQ7XG5cbiAgLy8gRWZmZWN0aXZlIFBGTE9QczogcGVyLXNhdGVsbGl0ZSBQRkxPUHMgw5cgbnVtYmVyIG9mIHNhdGVsbGl0ZXNcbiAgY29uc3QgZWZmZWN0aXZlUGZsb3BzUGVyU2F0ID0gaHlicmlkUmVzdWx0LmVmZmVjdGl2ZVBmbG9wcztcbiAgY29uc3QgdG90YWxFZmZlY3RpdmVQZmxvcHMgPSBlZmZlY3RpdmVQZmxvcHNQZXJTYXQgKiBjb25zdGVsbGF0aW9uLm51bVNhdGVsbGl0ZXM7XG4gIFxuICAvLyBMYXVuY2ggY29zdDogdG90YWwgY29uc3RlbGxhdGlvbiBsYXVuY2ggY29zdCAvIHRvdGFsIFBGTE9Qc1xuICBjb25zdCBsYXVuY2hDb3N0UGVyUGZsb3BZZWFyID0gZWZmZWN0aXZlVG90YWxMYXVuY2hDb3N0IC8gdG90YWxFZmZlY3RpdmVQZmxvcHMgLyBsaWZldGltZVllYXJzO1xuXG4gIC8vIENSSVRJQ0FMIEZJWCAxOiBDb3N0IEFjY291bnRpbmcgLSBlbnN1cmUgYnJlYWtkb3duIHN1bXMgdG8gdG90YWxcbiAgLy8gQ2FsY3VsYXRlIGVhY2ggY29tcG9uZW50IGV4cGxpY2l0bHksIHNjYWxlZCBieSBjb25zdGVsbGF0aW9uXG4gIC8vIFBlci1zYXRlbGxpdGUgY29zdHMgw5cgbnVtYmVyIG9mIHNhdGVsbGl0ZXMgw5cgY29uc3RlbGxhdGlvbiBvdmVyaGVhZFxuICBjb25zdCBjb25zdGVsbGF0aW9uQ29zdE11bHRpcGxpZXIgPSBjb25zdGVsbGF0aW9uLm51bVNhdGVsbGl0ZXMgKiBjb25zdGVsbGF0aW9uT3ZlcmhlYWRNdWx0aXBsaWVyO1xuICBcbiAgY29uc3QgcG93ZXJDb3N0ID0gKGVmZmVjdGl2ZVBvd2VyRmFiQ29zdCAqIGNvbnN0ZWxsYXRpb25Db3N0TXVsdGlwbGllcikgLyB0b3RhbEVmZmVjdGl2ZVBmbG9wcyAvIGxpZmV0aW1lWWVhcnM7XG4gIGNvbnN0IGNvbXB1dGVDb3N0ID0gKChoeWJyaWRSZXN1bHQuY29tcHV0ZVBheWxvYWQuY2hpcENvc3RVc2QgKyBoeWJyaWRSZXN1bHQuY29tcHV0ZVBheWxvYWQucXVhbGlmaWNhdGlvbkNvc3RVc2QpICogY29uc3RlbGxhdGlvbkNvc3RNdWx0aXBsaWVyKSAvIHRvdGFsRWZmZWN0aXZlUGZsb3BzIC8gbGlmZXRpbWVZZWFycztcbiAgY29uc3QgdGhlcm1hbENvc3QgPSAoaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0uZmFiQ29zdFVzZCAqIGNvbnN0ZWxsYXRpb25Db3N0TXVsdGlwbGllcikgLyB0b3RhbEVmZmVjdGl2ZVBmbG9wcyAvIGxpZmV0aW1lWWVhcnM7XG4gIGNvbnN0IHJhZGlhdGlvbkNvc3QgPSAoaHlicmlkUmVzdWx0LnJhZGlhdGlvblByb3RlY3Rpb24uZmFiQ29zdFVzZCAqIGNvbnN0ZWxsYXRpb25Db3N0TXVsdGlwbGllcikgLyB0b3RhbEVmZmVjdGl2ZVBmbG9wcyAvIGxpZmV0aW1lWWVhcnM7XG4gIGNvbnN0IGJ1c0Nvc3QgPSAoaHlicmlkUmVzdWx0LmJ1cy5mYWJDb3N0VXNkICogY29uc3RlbGxhdGlvbkNvc3RNdWx0aXBsaWVyKSAvIHRvdGFsRWZmZWN0aXZlUGZsb3BzIC8gbGlmZXRpbWVZZWFycztcbiAgY29uc3QgbmV0d29ya2luZ0Nvc3QgPSAoZWZmZWN0aXZlTmV0d29ya2luZ0ZhYkNvc3QgKiBjb25zdGVsbGF0aW9uQ29zdE11bHRpcGxpZXIpIC8gdG90YWxFZmZlY3RpdmVQZmxvcHMgLyBsaWZldGltZVllYXJzO1xuICBjb25zdCBpbnRlcmNvbm5lY3RDb3N0ID0gKGh5YnJpZFJlc3VsdC5pbnRlcmNvbm5lY3QudG90YWxBbm51YWxDb3N0ICogY29uc3RlbGxhdGlvbkNvc3RNdWx0aXBsaWVyKSAvIHRvdGFsRWZmZWN0aXZlUGZsb3BzO1xuICBjb25zdCByZWd1bGF0b3J5Q29zdCA9ICgoaHlicmlkUmVzdWx0LnJlZ3VsYXRvcnk/LmFubnVhbENvc3RVc2QgfHwgMCkgKiBjb25zdGVsbGF0aW9uQ29zdE11bHRpcGxpZXIpIC8gdG90YWxFZmZlY3RpdmVQZmxvcHM7XG4gIFxuICAvLyBPcHMgY29zdCBzY2FsZXMgd2l0aCBjb25zdGVsbGF0aW9uIG92ZXJoZWFkIChtb3JlIHNhdGVsbGl0ZXMgPSBtb3JlIG9wcyBjb21wbGV4aXR5KVxuICBjb25zdCBiYXNlT3BzQ29zdFBlclNhdCA9IGh5YnJpZFJlc3VsdC5vcHNQZXJQZmxvcFllYXIgKiBlZmZlY3RpdmVQZmxvcHNQZXJTYXQ7IC8vIFRvdGFsIG9wcyBjb3N0IHBlciBzYXRlbGxpdGVcbiAgY29uc3QgbmV0d29ya2luZ09wc0Nvc3RQZXJTYXQgPSAoaHlicmlkUmVzdWx0Lm5ldHdvcmtpbmcuYW5udWFsT3BFeFVzZCB8fCAwKSAtIGVmZmVjdGl2ZU5ldHdvcmtpbmdPcEV4OyAvLyBBbHJlYWR5IHBlci1zYXRcbiAgY29uc3QgYWRqdXN0ZWROZXR3b3JraW5nT3BzQ29zdFBlclNhdCA9IGVmZmVjdGl2ZU5ldHdvcmtpbmdPcEV4OyAvLyBBbHJlYWR5IHBlci1zYXRcbiAgY29uc3Qgb3BzQ29zdFBlclNhdCA9IGJhc2VPcHNDb3N0UGVyU2F0IC0gbmV0d29ya2luZ09wc0Nvc3RQZXJTYXQgKyBhZGp1c3RlZE5ldHdvcmtpbmdPcHNDb3N0UGVyU2F0O1xuICBcbiAgLy8gU2NhbGUgb3BzIGNvc3QgYnkgY29uc3RlbGxhdGlvbiAod2l0aCBvdmVyaGVhZCBmb3IgY29vcmRpbmF0aW9uKVxuICBjb25zdCBvcHNDb3N0TXVsdGlwbGllciA9IGNvbnN0ZWxsYXRpb24ubnVtU2F0ZWxsaXRlcyAqICgxICsgMC4xICogTWF0aC5sb2cxMChjb25zdGVsbGF0aW9uLm51bVNhdGVsbGl0ZXMpKTtcbiAgY29uc3Qgb3BzQ29zdCA9IChvcHNDb3N0UGVyU2F0ICogb3BzQ29zdE11bHRpcGxpZXIpIC8gdG90YWxFZmZlY3RpdmVQZmxvcHM7XG5cbiAgY29uc3Qgb3JiaXRhbEJyZWFrZG93biA9IHtcbiAgICBwb3dlcjogcG93ZXJDb3N0LFxuICAgIGNvbXB1dGU6IGNvbXB1dGVDb3N0LFxuICAgIHRoZXJtYWw6IHRoZXJtYWxDb3N0LFxuICAgIHJhZGlhdGlvbjogcmFkaWF0aW9uQ29zdCxcbiAgICBidXM6IGJ1c0Nvc3QsXG4gICAgb3BzOiBvcHNDb3N0LFxuICAgIGNvbmdlc3Rpb246IDAsIC8vIENhbGN1bGF0ZWQgYmVsb3dcbiAgICBuZXR3b3JraW5nOiBuZXR3b3JraW5nQ29zdCxcbiAgICBpbnRlcmNvbm5lY3Q6IGludGVyY29ubmVjdENvc3QsXG4gICAgcmVndWxhdG9yeTogcmVndWxhdG9yeUNvc3QsXG4gICAgbGF1bmNoOiBsYXVuY2hDb3N0UGVyUGZsb3BZZWFyXG4gIH07XG5cbiAgY29uc3QgdG90YWxTYXRlbGxpdGVDb3N0ID0gaHlicmlkUmVzdWx0LnRvdGFsU2F0ZWxsaXRlQ29zdCAqIGNvbnN0ZWxsYXRpb25Db3N0TXVsdGlwbGllcjtcbiAgY29uc3Qgc2F0ZWxsaXRlQ291bnQgPSBjb25zdGVsbGF0aW9uLm51bVNhdGVsbGl0ZXM7IC8vIFVzZSBhY3R1YWwgY29uc3RlbGxhdGlvbiBzaXplXG4gIGNvbnN0IGNvbmdlc3Rpb24gPSBjYWxjdWxhdGVDb25nZXN0aW9uKHNhdGVsbGl0ZUNvdW50LCB0b3RhbFNhdGVsbGl0ZUNvc3QsIHllYXIsIDEwMDAwICsgc2F0ZWxsaXRlQ291bnQsIHNwYWNlVHJhZmZpY0VuYWJsZWQpO1xuICBcbiAgLy8gVG90YWwgZmxlZXQgUEZMT1BTOiB1c2UgY29uc3RlbGxhdGlvbiB0b3RhbCBQRkxPUHNcbiAgLy8gQWxyZWFkeSBjYWxjdWxhdGVkIGFzIHRvdGFsRWZmZWN0aXZlUGZsb3BzIGFib3ZlXG4gIG9yYml0YWxCcmVha2Rvd24uY29uZ2VzdGlvbiA9IHNwYWNlVHJhZmZpY0VuYWJsZWQgPyAoY29uZ2VzdGlvbi5jb25nZXN0aW9uQ29zdFBlclBmbG9wWWVhciAvIHRvdGFsRWZmZWN0aXZlUGZsb3BzKSA6IDA7XG5cbiAgLy8gUEFUQ0ggRzogQ29zdCBBY2NvdW50aW5nIEludmFyaWFudHNcbiAgLy8gVXNlIGFzc2VydENvc3RBY2NvdW50aW5nIHRvIGVuc3VyZSBicmVha2Rvd24gc3VtcyB0byB0b3RhbCBleGFjdGx5XG4gIGNvbnN0IG9yYml0YWxDb21wb25lbnRzID0gW1xuICAgIHsgbmFtZTogJ3Bvd2VyJywgdmFsdWU6IG9yYml0YWxCcmVha2Rvd24ucG93ZXIgfSxcbiAgICB7IG5hbWU6ICdjb21wdXRlJywgdmFsdWU6IG9yYml0YWxCcmVha2Rvd24uY29tcHV0ZSB9LFxuICAgIHsgbmFtZTogJ3RoZXJtYWwnLCB2YWx1ZTogb3JiaXRhbEJyZWFrZG93bi50aGVybWFsIH0sXG4gICAgeyBuYW1lOiAncmFkaWF0aW9uJywgdmFsdWU6IG9yYml0YWxCcmVha2Rvd24ucmFkaWF0aW9uIH0sXG4gICAgeyBuYW1lOiAnYnVzJywgdmFsdWU6IG9yYml0YWxCcmVha2Rvd24uYnVzIH0sXG4gICAgeyBuYW1lOiAnb3BzJywgdmFsdWU6IG9yYml0YWxCcmVha2Rvd24ub3BzIH0sXG4gICAgeyBuYW1lOiAnbmV0d29ya2luZycsIHZhbHVlOiBvcmJpdGFsQnJlYWtkb3duLm5ldHdvcmtpbmcgfSxcbiAgICB7IG5hbWU6ICdpbnRlcmNvbm5lY3QnLCB2YWx1ZTogb3JiaXRhbEJyZWFrZG93bi5pbnRlcmNvbm5lY3QgfSxcbiAgICB7IG5hbWU6ICdyZWd1bGF0b3J5JywgdmFsdWU6IG9yYml0YWxCcmVha2Rvd24ucmVndWxhdG9yeSB9LFxuICAgIHsgbmFtZTogJ2xhdW5jaCcsIHZhbHVlOiBvcmJpdGFsQnJlYWtkb3duLmxhdW5jaCB9LFxuICAgIHsgbmFtZTogJ2Nvbmdlc3Rpb24nLCB2YWx1ZTogb3JiaXRhbEJyZWFrZG93bi5jb25nZXN0aW9uIH0sXG4gIF07XG4gIFxuICBjb25zdCBicmVha2Rvd25TdW0gPSBPYmplY3QudmFsdWVzKG9yYml0YWxCcmVha2Rvd24pLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICBjb25zdCByZWFsaXN0aWNDb3N0UGVyUGZsb3AgPSBicmVha2Rvd25TdW07XG4gIFxuICAvLyBUcmFjayBhcHBsaWVkIG11bHRpcGxpZXJzIGZvciBkZWJ1Z2dpbmdcbiAgY29uc3QgYXBwbGllZE11bHRpcGxpZXJzOiBBcnJheTx7IG5hbWU6IHN0cmluZzsgdmFsdWU6IG51bWJlcjsgYXBwbGllZFRvOiBzdHJpbmcgfT4gPSBbXG4gICAgeyBuYW1lOiAnbGF1bmNoRGlzY291bnQnLCB2YWx1ZTogbGF1bmNoRGlzY291bnQsIGFwcGxpZWRUbzogJ2xhdW5jaCBjb3N0JyB9LFxuICAgIHsgbmFtZTogJ3Bvd2VyRGlzY291bnQnLCB2YWx1ZTogcG93ZXJEaXNjb3VudCwgYXBwbGllZFRvOiAncG93ZXIgZmFiIGNvc3QnIH0sXG4gICAgeyBuYW1lOiAnbmV0d29ya2luZ0Rpc2NvdW50JywgdmFsdWU6IG5ldHdvcmtpbmdEaXNjb3VudCwgYXBwbGllZFRvOiAnbmV0d29ya2luZyBjb3N0JyB9LFxuICAgIHsgbmFtZTogJ21hc3NNdWx0aXBsaWVyJywgdmFsdWU6IG1hc3NNdWx0aXBsaWVyLCBhcHBsaWVkVG86ICd0b3RhbCBtYXNzJyB9LFxuICBdO1xuICBcbiAgLy8gQXNzZXJ0IGNvc3QgYWNjb3VudGluZyAodGhyb3dzIGlmIGludmFsaWQpXG4gIGNvbnN0IG9yYml0YWxBY2NvdW50aW5nID0gYXNzZXJ0Q29zdEFjY291bnRpbmcocmVhbGlzdGljQ29zdFBlclBmbG9wLCBvcmJpdGFsQ29tcG9uZW50cywgYXBwbGllZE11bHRpcGxpZXJzKTtcbiAgY29uc3QgY29zdEFjY291bnRpbmdWYWxpZCA9IG9yYml0YWxBY2NvdW50aW5nLnZhbGlkO1xuICBjb25zdCBjb3N0QWNjb3VudGluZ0Vycm9yUGN0ID0gb3JiaXRhbEFjY291bnRpbmcuZXJyb3JQY3Q7XG5cbiAgLy8gRklYIDU6IEdQVS1ob3VyIGJyZWFrZG93biBtdXN0IGRlcml2ZSBmcm9tIGFubnVhbCBjb3N0IGJyZWFrZG93blxuICAvLyBHUFUtaG91ciBwcmljaW5nOiBBcHBseSBzY2FyY2l0eSBhcyBNVUxUSVBMSUNBVElWRSBtdWx0aXBsaWVyIChub3QgYWRkaXRpdmUpXG4gIC8vIGRlbGF5UGVuYWx0eSByZW1haW5zIGFkZGl0aXZlIChXQUNDIGNhcnJ5IGNvc3QpLCBidXQgc2NhcmNpdHkgcmVudCBpcyBub3cgbXVsdGlwbGljYXRpdmVcbiAgY29uc3QgZGVsYXlQZW5hbHR5UGVyUGZsb3BZZWFyID0gZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRzPy5kZWxheVBlbmFsdHkgfHwgMDtcbiAgY29uc3Qgc2NhcmNpdHlNdWx0aXBsaWVyID0gZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRzPy5zY2FyY2l0eU11bHRpcGxpZXIgPz8gMS4wOyAvLyBNdWx0aXBsaWVyIGZyb20gbG9nLWJhc2VkIGZ1bmN0aW9uXG4gIFxuICAvLyBDb252ZXJ0IGRlbGF5UGVuYWx0eSB0byAkL0dQVS1ob3VyIChzdGlsbCBhZGRpdGl2ZSlcbiAgY29uc3QgcGZsb3BzUGVyR3B1ID0gMi4wO1xuICBjb25zdCB1dGlsaXphdGlvblRhcmdldCA9IDAuODU7XG4gIGNvbnN0IGhvdXJzUGVyWWVhciA9IDg3NjA7XG4gIGNvbnN0IGFubnVhbEdwdUhvdXJzUGVyUEZMT1AgPSBob3Vyc1BlclllYXIgKiB1dGlsaXphdGlvblRhcmdldCAvIHBmbG9wc1BlckdwdTtcbiAgY29uc3QgZGVsYXlQZW5hbHR5QWRkZXJQZXJHcHVIb3VyID0gZGVsYXlQZW5hbHR5UGVyUGZsb3BZZWFyIC8gYW5udWFsR3B1SG91cnNQZXJQRkxPUDtcbiAgXG4gIC8vIE5vdGU6IFNjYXJjaXR5IGlzIG5vdyBNVUxUSVBMSUNBVElWRSAobm90IGFkZGl0aXZlKSwgc28gbm8gY29udmVyc2lvbiBjaGVjayBuZWVkZWRcbiAgLy8gU2NhcmNpdHkgbXVsdGlwbGllciBpcyBhcHBsaWVkIGRpcmVjdGx5IHRvIGJhc2UgY29zdCBpbiBHUFUtaG91ciBwcmljaW5nXG4gIFxuICAvLyBVc2UgQkFTRSBjb3N0ICh3aXRob3V0IHNjYXJjaXR5KSBmb3IgR1BVLWhvdXIgcHJpY2luZywgdGhlbiBhcHBseSBzY2FyY2l0eSBhcyBtdWx0aXBsaWVyXG4gIC8vIFRoaXMgcHJldmVudHMgZG91YmxlLWNvdW50aW5nOiBzY2FyY2l0eSBpcyBtdWx0aXBsaWNhdGl2ZSBpbiBHUFUtaG91ciBwcmljaW5nLCBub3QgYWRkaXRpdmVcbiAgLy8gV2Ugd2FudDogYmFzZUNvc3QgKG5vIHNjYXJjaXR5KSAqIHNjYXJjaXR5TXVsdGlwbGllciA9IHRvdGFsIHdpdGggc2NhcmNpdHlcbiAgLy8gVXNlIGdyb3VuZFJlc3VsdC50b3RhbENvc3RQZXJQZmxvcFllYXJCYXNlIGlmIGF2YWlsYWJsZSAoZnJvbSBidWlsZG91dCBtb2RlbCksIG90aGVyd2lzZSBjb25zdHJ1Y3QgZnJvbSBjb21wb25lbnRzXG4gIGNvbnN0IGdyb3VuZENvc3RCYXNlRm9yUHJpY2luZyA9IHVzZUJ1aWxkb3V0TW9kZWwgJiYgZ3JvdW5kUmVzdWx0Py50b3RhbENvc3RQZXJQZmxvcFllYXJCYXNlICE9PSB1bmRlZmluZWRcbiAgICA/IGdyb3VuZFJlc3VsdC50b3RhbENvc3RQZXJQZmxvcFllYXJCYXNlXG4gICAgOiAoZ3JvdW5kUmVzdWx0LmVuZXJneUNvc3QgKyBncm91bmRSZXN1bHQuc2l0ZUNvc3QgKyBncm91bmRSZXN1bHQuaGFyZHdhcmVDb3N0KSAqIGdyb3VuZExhdGVuY3lQZW5hbHR5O1xuICBcbiAgY29uc3QgZ3JvdW5kR3B1SG91ciA9IChzbGE6IFNMQUNvbmZpZykgPT4ge1xuICAgIGNvbnN0IGJhc2VQcmljaW5nID0gY2FsY3VsYXRlR3B1SG91clByaWNpbmcoZ3JvdW5kQ29zdEJhc2VGb3JQcmljaW5nLCB7XG4gICAgICBwZmxvcHNQZXJHcHUsXG4gICAgICB1dGlsaXphdGlvblRhcmdldCxcbiAgICAgIG9wZXJhdG9yTWFyZ2luUGN0OiBvcGVyYXRvck1hcmdpbixcbiAgICAgIHNsYSxcbiAgICAgIGxvY2F0aW9uOiAnZ3JvdW5kJ1xuICAgIH0sIHtcbiAgICAgIGNvbXB1dGU6IGdyb3VuZFJlc3VsdC5oYXJkd2FyZUNvc3QsXG4gICAgICBwb3dlcjogZ3JvdW5kUmVzdWx0LmVuZXJneUNvc3QsXG4gICAgICBzaXRlOiB1c2VCdWlsZG91dE1vZGVsID8gZ3JvdW5kUmVzdWx0LnNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyIDogZ3JvdW5kUmVzdWx0LnNpdGVDb3N0LFxuICAgICAgLy8gR3JvdW5kIGNvb2xpbmcgaW5jbHVkZWQgaW4gZW5lcmd5LCBpbnRlcmNvbm5lY3QgbWluaW1hbFxuICAgIH0pO1xuICAgIFxuICAgIC8vIFVOSUZJRUQgU0NBUkNJVFkgQUNDT1VOVElORzogU2NhcmNpdHkgaXMgTVVMVElQTElDQVRJVkUgKG5vdCBhZGRpdGl2ZSlcbiAgICAvLyBDUklUSUNBTCBGSVg6IEFwcGx5IHNjYXJjaXR5IGFzIHByZW1pdW0gb24gRklYRUQgcmVmZXJlbmNlIGJhc2UsIG5vdCBkZWNsaW5pbmcgYmFzZVxuICAgIC8vIFRoaXMgcHJldmVudHMgTW9vcmUncyBMYXcgZnJvbSBlcm9kaW5nIHNjYXJjaXR5IGRvbGxhciBhbW91bnRzXG4gICAgXG4gICAgLy8gRXh0cmFjdCBiYXNlIGNvc3QgYmVmb3JlIG1hcmdpbiAodGhpcyBkZWNsaW5lcyB3aXRoIE1vb3JlJ3MgTGF3KVxuICAgIGNvbnN0IHByZU1hcmdpbkJhc2UgPSBiYXNlUHJpY2luZy5wcmljZVBlckdwdUhvdXIgLSAoYmFzZVByaWNpbmcuY29zdEJyZWFrZG93bi5tYXJnaW4gfHwgMCk7XG4gICAgXG4gICAgLy8gU2NhcmNpdHkgcHJlbWl1bSBiYXNlZCBvbiBGSVhFRCByZWZlcmVuY2UsIG5vdCBkZWNsaW5pbmcgYmFzZVxuICAgIC8vIFRoaXMgZW5zdXJlcyBzY2FyY2l0eSBkb2Vzbid0IGdldCBlcm9kZWQgYnkgTW9vcmUncyBMYXdcbiAgICBjb25zdCBTQ0FSQ0lUWV9SRUZFUkVOQ0VfQkFTRSA9IDMuNTA7IC8vIEZpeGVkIDIwMjUgbWFya2V0IHJlZmVyZW5jZSAoJC9HUFUtaHIpXG4gICAgY29uc3Qgc2NhcmNpdHlQcmVtaXVtID0gKHNjYXJjaXR5TXVsdGlwbGllciAtIDEpICogU0NBUkNJVFlfUkVGRVJFTkNFX0JBU0U7XG4gICAgXG4gICAgLy8gVG90YWwgY29zdCA9IGJhc2UgKGRlY2xpbmluZyB3aXRoIE1vb3JlJ3MgTGF3KSArIHNjYXJjaXR5IChmaXhlZCkgKyBkZWxheVxuICAgIGNvbnN0IGNvc3RXaXRoU2NhcmNpdHkgPSBwcmVNYXJnaW5CYXNlICsgc2NhcmNpdHlQcmVtaXVtO1xuICAgIGNvbnN0IGNvc3RXaXRoU2NhcmNpdHlBbmREZWxheSA9IGNvc3RXaXRoU2NhcmNpdHkgKyBkZWxheVBlbmFsdHlBZGRlclBlckdwdUhvdXI7XG4gICAgXG4gICAgLy8gVGhlbiBhZGQgbWFyZ2luXG4gICAgY29uc3QgbWFyZ2luID0gY29zdFdpdGhTY2FyY2l0eUFuZERlbGF5ICogb3BlcmF0b3JNYXJnaW47XG4gICAgY29uc3QgcHJpY2VQZXJHcHVIb3VyID0gY29zdFdpdGhTY2FyY2l0eUFuZERlbGF5ICsgbWFyZ2luO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAuLi5iYXNlUHJpY2luZyxcbiAgICAgIHByaWNlUGVyR3B1SG91cixcbiAgICAgIGNvc3RCcmVha2Rvd246IHtcbiAgICAgICAgLi4uYmFzZVByaWNpbmcuY29zdEJyZWFrZG93bixcbiAgICAgICAgc2NhcmNpdHk6IHNjYXJjaXR5UHJlbWl1bSwgLy8gRml4ZWQtYmFzZSBzY2FyY2l0eSBwcmVtaXVtIChkb2Vzbid0IGRlY2xpbmUgd2l0aCBNb29yZSdzIExhdylcbiAgICAgICAgZGVsYXlQZW5hbHR5OiBkZWxheVBlbmFsdHlBZGRlclBlckdwdUhvdXIsIC8vIERlbGF5IHBlbmFsdHkgKFdBQ0MgY2FycnkpXG4gICAgICAgIG1hcmdpbiwgLy8gb3ZlcndyaXRlIHdpdGggcmVjb21wdXRlZCBtYXJnaW5cbiAgICAgIH0sXG4gICAgfTtcbiAgfTtcblxuICBjb25zdCBvcmJpdGFsR3B1SG91ciA9IChzbGE6IFNMQUNvbmZpZykgPT4gY2FsY3VsYXRlR3B1SG91clByaWNpbmcocmVhbGlzdGljQ29zdFBlclBmbG9wLCB7XG4gICAgcGZsb3BzUGVyR3B1OiAyLjAsXG4gICAgdXRpbGl6YXRpb25UYXJnZXQ6IDAuODUsXG4gICAgb3BlcmF0b3JNYXJnaW5QY3Q6IG9wZXJhdG9yTWFyZ2luLFxuICAgIHNsYSxcbiAgICBsb2NhdGlvbjogJ29yYml0YWwnXG4gIH0sIG9yYml0YWxCcmVha2Rvd24pOyAvLyBVc2UgZnVsbCBvcmJpdGFsIGJyZWFrZG93blxuXG4gIGNvbnN0IGdyb3VuZFRva2VucyA9IHtcbiAgICBsbGFtYTcwQjogY2FsY3VsYXRlVG9rZW5QcmljaW5nKGdyb3VuZFRvdGFsQ29zdCwgeyBwYXJhbXM6IDcwZTksIHByZWNpc2lvbjogJ2ZwMTYnIH0pLFxuICAgIGxsYW1hNDA1QjogY2FsY3VsYXRlVG9rZW5QcmljaW5nKGdyb3VuZFRvdGFsQ29zdCwgeyBwYXJhbXM6IDQwNWU5LCBwcmVjaXNpb246ICdmcDE2JyB9KVxuICB9O1xuXG4gIGNvbnN0IG9yYml0YWxUb2tlbnMgPSB7XG4gICAgbGxhbWE3MEI6IGNhbGN1bGF0ZVRva2VuUHJpY2luZyhyZWFsaXN0aWNDb3N0UGVyUGZsb3AsIHsgcGFyYW1zOiA3MGU5LCBwcmVjaXNpb246ICdmcDE2JyB9KSxcbiAgICBsbGFtYTQwNUI6IGNhbGN1bGF0ZVRva2VuUHJpY2luZyhyZWFsaXN0aWNDb3N0UGVyUGZsb3AsIHsgcGFyYW1zOiA0MDVlOSwgcHJlY2lzaW9uOiAnZnAxNicgfSlcbiAgfTtcblxuICBjb25zdCBlZGdlSW5mZXJlbmNlID0gcGFyYW1zLmVkZ2VJbmZlcmVuY2U/LmVuYWJsZWQgXG4gICAgPyBjb21wdXRlRWRnZUluZmVyZW5jZUNvc3RzKHllYXIsIHBhcmFtcy5lZGdlSW5mZXJlbmNlLCBsYXVuY2hDb3N0UGVyS2csIHRvdGFsRWZmZWN0aXZlUGZsb3BzIC8gZWZmZWN0aXZlVG90YWxNYXNzS2cpXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3QgZ3B1SG91ckNyb3Nzb3ZlciA9IG9yYml0YWxHcHVIb3VyKFNMQV9USUVSUy5zdGFuZGFyZCkucHJpY2VQZXJHcHVIb3VyIDwgZ3JvdW5kR3B1SG91cihTTEFfVElFUlMuc3RhbmRhcmQpLnByaWNlUGVyR3B1SG91cjtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIERFQlVHIElOVkFSSUFOVFMgKGRldmVsb3BtZW50IG1vZGUgb25seSlcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAvLyBJbnZhcmlhbnQgMTogSWYgYXZnV2FpdFllYXJzID4gMCB0aGVuIHNjYXJjaXR5IG11bHRpcGxpZXIgc2hvdWxkIGJlID4gMS4wIChzY2FyY2l0eSBpcyBtdWx0aXBsaWNhdGl2ZSBpbiBHUFUtaG91ciBwcmljaW5nKVxuICAgIGNvbnN0IGF2Z1dhaXRZZWFycyA9IGdyb3VuZFJlc3VsdC5zdXBwbHlNZXRyaWNzPy5hdmdXYWl0WWVhcnMgPz8gMDtcbiAgICBjb25zdCBzY2FyY2l0eU11bHRpcGxpZXIgPSBncm91bmRSZXN1bHQuY29uc3RyYWludHM/LnNjYXJjaXR5TXVsdGlwbGllciA/PyAxLjA7XG4gICAgaWYgKGF2Z1dhaXRZZWFycyA+IDEuMCAmJiBzY2FyY2l0eU11bHRpcGxpZXIgPD0gMS4wKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbSU5WQVJJQU5UIFZJT0xBVElPTl0gWWVhciAke3llYXJ9OiBhdmdXYWl0WWVhcnM9JHthdmdXYWl0WWVhcnN9ID4gMS4wIGJ1dCBzY2FyY2l0eU11bHRpcGxpZXI9JHtzY2FyY2l0eU11bHRpcGxpZXJ9IDw9IDEuMC4gYCArXG4gICAgICAgIGBTY2FyY2l0eSBtdWx0aXBsaWVyIHNob3VsZCBiZSA+IDEuMCB3aGVuIHdhaXQgdGltZSBleGlzdHMgKHNjYXJjaXR5IGlzIG11bHRpcGxpY2F0aXZlIGluIEdQVS1ob3VyIHByaWNpbmcpLmBcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIC8vIEludmFyaWFudCAyOiBzdXBwbHlNZXRyaWNzLmNhcGFjaXR5R3cgaXMgdGhlIGVmZmVjdGl2ZSBjYXBhY2l0eSAoYm90dGxlbmVjaylcbiAgICAvLyBRdWV1ZSBtb2RlbCB1c2VzIGNvaGVyZW50IGJhY2tsb2cgYmFzZWQgb24gdW5tZXQgZGVtYW5kXG4gICAgXG4gICAgLy8gSW52YXJpYW50IDM6IEdQVS1ob3VyIGNoYXJ0IHlNYXggZ3VhcmQgKHByZXZlbnRlZCBieSBleHBsaWNpdCBzZXJpZXMgZXh0cmFjdGlvbiBpbiBjaGFydCBjb21wb25lbnQpXG4gICAgLy8gVGhpcyBpcyBoYW5kbGVkIGluIHRoZSBjaGFydCBjb21wb25lbnQgd2l0aCBleHBsaWNpdCBzZXJpZXMgZXh0cmFjdGlvblxuICAgIFxuICAgIC8vIEludmFyaWFudCA0OiBDcm9zc292ZXIgdXNlcyBlZmZlY3RpdmUgZ3JvdW5kIGNvc3RcbiAgICBjb25zdCBncm91bmRFZmZlY3RpdmUgPSBncm91bmRSZXN1bHQudG90YWxDb3N0UGVyUGZsb3BZZWFyRWZmZWN0aXZlID8/IGdyb3VuZFJlc3VsdC50b3RhbENvc3RQZXJQZmxvcFllYXI7XG4gICAgY29uc3QgZ3JvdW5kSGVhZGxpbmUgPSBncm91bmRSZXN1bHQudG90YWxDb3N0UGVyUGZsb3BZZWFyO1xuICAgIGNvbnN0IGRlbGF5UGVuYWx0eSA9IGdyb3VuZFJlc3VsdC5jb25zdHJhaW50cz8uZGVsYXlQZW5hbHR5ID8/IDA7XG4gICAgLy8gU2NhcmNpdHkgaXMgbm93IG11bHRpcGxpY2F0aXZlIChub3QgYWRkaXRpdmUpLCBzbyBkb24ndCBhZGQgaXQgdG8gZWZmZWN0aXZlIGNvc3RcbiAgICBjb25zdCBleHBlY3RlZEVmZmVjdGl2ZSA9IGdyb3VuZEhlYWRsaW5lICsgZGVsYXlQZW5hbHR5OyAvLyBTY2FyY2l0eSBhcHBsaWVkIGluIEdQVS1ob3VyIHByaWNpbmcsIG5vdCBQRkxPUC15ZWFyXG4gICAgY29uc3QgZWZmZWN0aXZlRXJyb3IgPSBNYXRoLmFicyhncm91bmRFZmZlY3RpdmUgLSBleHBlY3RlZEVmZmVjdGl2ZSk7XG4gICAgLy8gUmV1c2Ugc2NhcmNpdHlNdWx0aXBsaWVyIGZyb20gSW52YXJpYW50IDEgYWJvdmVcbiAgICBpZiAoZWZmZWN0aXZlRXJyb3IgPiAwLjAxICYmIChkZWxheVBlbmFsdHkgPiAwIHx8IHNjYXJjaXR5TXVsdGlwbGllciA+IDEuMCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFtJTlZBUklBTlQgVklPTEFUSU9OXSBZZWFyICR7eWVhcn06IGdyb3VuZEVmZmVjdGl2ZT0ke2dyb3VuZEVmZmVjdGl2ZX0gIT0gZXhwZWN0ZWQ9JHtleHBlY3RlZEVmZmVjdGl2ZX0gYCArXG4gICAgICAgIGAoaGVhZGxpbmU9JHtncm91bmRIZWFkbGluZX0sIGRlbGF5UGVuYWx0eT0ke2RlbGF5UGVuYWx0eX0sIHNjYXJjaXR5TXVsdGlwbGllcj0ke3NjYXJjaXR5TXVsdGlwbGllcn0pLiBgICtcbiAgICAgICAgYENyb3Nzb3ZlciBzaG91bGQgdXNlIGVmZmVjdGl2ZSBjb3N0LiBOb3RlOiBzY2FyY2l0eSBpcyBtdWx0aXBsaWNhdGl2ZSBpbiBHUFUtaG91ciBwcmljaW5nLCBub3QgYWRkaXRpdmUgaW4gUEZMT1AteWVhci5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8vIENSSVRJQ0FMIEZJWDogVmFsaWRhdGUgZGVsaXZlcmVkIGVmZmljaWVuY3kgYnkgY29tcGFyaW5nIGxpa2UtZm9yLWxpa2Ugb25seVxuICAvLyBleHBlY3RlZERlbGl2ZXJlZCA9IHN5c3RlbUVmZmVjdGl2ZUdmbG9wc1BlcldhdHQgKiB0aGVybWFsQ2FwRmFjdG9yICogcmFkaWF0aW9uRGVyYXRlICogYXZhaWxhYmlsaXR5XG4gIC8vIHJhdGlvID0gZGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCAvIGV4cGVjdGVkRGVsaXZlcmVkXG4gIC8vIElmIHJhdGlvIGlzIGZpbml0ZSBhbmQgfDEgLSByYXRpb3wgPD0gdG9sZXJhbmNlICgwLjAyKSwgdGhlbiB2YWxpZD10cnVlLCB3YXJuaW5nPW51bGxcbiAgLy8gRWxzZSB2YWxpZD1mYWxzZSwgd2FybmluZyBkZXNjcmliZXMgdGhlIG1pc21hdGNoXG4gIC8vIFJlbW92ZSBhbnkgb3RoZXIgY29tcGFyaXNvbnMgKGUuZy4sIGRlbGl2ZXJlZCB2cyBzeXN0ZW1FZmZlY3RpdmUsIGRlbGl2ZXJlZCB2cyBwZWFrKnV0aWxpemF0aW9uIHdpdGhvdXQgb3ZlcmhlYWQsIGV0Yy4pXG4gIGNvbnN0IGV4cGVjdGVkRGVsaXZlcmVkID0gb3JiaXRTeXN0ZW1FZmZlY3RpdmVHZmxvcHNQZXJXYXR0ICogdGhlcm1hbENhcEZhY3RvciAqIHJhZGlhdGlvbkRlcmF0ZSAqIGF2YWlsYWJpbGl0eTtcbiAgY29uc3QgcmF0aW8gPSBvcmJpdERlbGl2ZXJlZEdmbG9wc1BlcldhdHQgLyBNYXRoLm1heChleHBlY3RlZERlbGl2ZXJlZCwgMWUtNik7XG4gIGNvbnN0IFRPTEVSQU5DRSA9IDAuMDI7IC8vIDIlIHRvbGVyYW5jZVxuICBjb25zdCByYXRpb0Vycm9yID0gTWF0aC5hYnMoMSAtIHJhdGlvKTtcbiAgXG4gIC8vIENSSVRJQ0FMOiBGaXggdmFsaWRhdG9yIGxvZ2ljIC0gaWYgcmF0aW8gaXMgZmluaXRlIGFuZCB8MSAtIHJhdGlvfCA8PSB0b2xlcmFuY2UsIHRoZW4gdmFsaWQ9dHJ1ZVxuICBjb25zdCBpc1JhdGlvVmFsaWQgPSBpc0Zpbml0ZShyYXRpbykgJiYgcmF0aW9FcnJvciA8PSBUT0xFUkFOQ0U7XG4gIFxuICAvLyBFc2NhbGF0ZTogaWYgbWlzbWF0Y2ggPiA1JSwgbWFyayBhcyBpbnZhbGlkIChkb24ndCBqdXN0IHdhcm4pXG4gIGNvbnN0IEVTQ0FMQVRFX1RIUkVTSE9MRCA9IDAuMDU7IC8vIDUlXG4gIGNvbnN0IGlzSW52YWxpZCA9ICFpc1JhdGlvVmFsaWQgJiYgcmF0aW9FcnJvciA+IEVTQ0FMQVRFX1RIUkVTSE9MRDtcbiAgXG4gIC8vIERlYnVnIGludmFyaWFudHM6IGFzc2VydCBkZWxpdmVyZWQgPD0gc3lzdGVtRWZmZWN0aXZlICsgZXBzXG4gIGNvbnN0IGRlbGl2ZXJlZFZzU3lzdGVtRXJyb3IgPSBvcmJpdERlbGl2ZXJlZEdmbG9wc1BlcldhdHQgLSBvcmJpdFN5c3RlbUVmZmVjdGl2ZUdmbG9wc1BlcldhdHQ7XG4gIGlmIChkZWxpdmVyZWRWc1N5c3RlbUVycm9yID4gMWUtNikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBbSU5WQVJJQU5UIFZJT0xBVElPTl0gRGVsaXZlcmVkIGVmZmljaWVuY3kgKCR7b3JiaXREZWxpdmVyZWRHZmxvcHNQZXJXYXR0LnRvRml4ZWQoMil9KSA+IHN5c3RlbUVmZmVjdGl2ZSAoJHtvcmJpdFN5c3RlbUVmZmVjdGl2ZUdmbG9wc1BlcldhdHQudG9GaXhlZCgyKX0pLiBgICtcbiAgICAgIGBEZWxpdmVyZWQgbXVzdCBiZSA8PSBzeXN0ZW1FZmZlY3RpdmUuYFxuICAgICk7XG4gIH1cbiAgXG4gIC8vIEVmZmljaWVuY3kgZGVidWcgbG9nZ2luZyByZW1vdmVkIGZvciBjbGVhbmVyIGNvbnNvbGUgb3V0cHV0XG4gIC8vIFZhbGlkYXRpb24gcmVzdWx0cyBhcmUgYXZhaWxhYmxlIGluIG9yYml0LmNvbXB1dGVFZmZpY2llbmN5LnZhbGlkYXRpb24gbWV0YWRhdGFcbiAgXG4gIC8vIENSSVRJQ0FMOiBWYWxpZGF0ZSBkZWxpdmVyZWQgZWZmaWNpZW5jeSAtIGNvbXBhcmUgZGVsaXZlcmVkIHZzIGV4cGVjdGVkRGVsaXZlcmVkIG9ubHlcbiAgLy8gTWFrZSB2YWxpZGF0b3IgZGVidWcgZXhwbGljaXQgd2l0aCBhbGwgZmFjdG9yc1xuICAvLyBJZiBtaXNtYXRjaCA+IDUlLCBtYXJrIHJ1biBpbnZhbGlkIGFuZCBzdG9wIGNoYXJ0IHJlbmRlcmluZyAoZXNjYWxhdGUsIGRvbid0IHNpbGVudGx5IHdhcm4pXG4gIGNvbnN0IGRlbGl2ZXJlZFZhbGlkYXRpb24gPSB7XG4gICAgdmFsaWQ6IGlzUmF0aW9WYWxpZCxcbiAgICB3YXJuaW5nOiBpc1JhdGlvVmFsaWQgXG4gICAgICA/IHVuZGVmaW5lZCAvLyBFbXB0eS9udWxsIHdoZW4gdmFsaWRcbiAgICAgIDogYFBvd2VyL0VmZmljaWVuY3kgbWlzbWF0Y2g6ICR7cmF0aW8udG9GaXhlZCgyKX14IGRpc2NyZXBhbmN5IChleHBlY3RlZD0ke2V4cGVjdGVkRGVsaXZlcmVkLnRvRml4ZWQoMil9LCBkZWxpdmVyZWQ9JHtvcmJpdERlbGl2ZXJlZEdmbG9wc1BlcldhdHQudG9GaXhlZCgyKX0pYCxcbiAgICBleHBlY3RlZERlbGl2ZXJlZCxcbiAgICBkZWxpdmVyZWQ6IG9yYml0RGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCxcbiAgICByYXRpbyxcbiAgICBmYWN0b3JzVXNlZDoge1xuICAgICAgdGhlcm1hbENhcEZhY3RvcixcbiAgICAgIHJhZGlhdGlvbkRlcmF0ZSxcbiAgICAgIGF2YWlsYWJpbGl0eSxcbiAgICAgIHV0aWxpemF0aW9uOiBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5kZWJ1Zy51dGlsaXphdGlvbkZhY3RvcixcbiAgICAgIHN5c3RlbU92ZXJoZWFkRmFjdG9yOiBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5kZWJ1Zy5zeXN0ZW1PdmVyaGVhZEZhY3RvcixcbiAgICB9LFxuICAgIC8vIEVzY2FsYXRlOiBpZiByYXRpbyBpcyB3YXkgb2ZmICg+IDUlKSwgbWFyayBhcyBpbnZhbGlkXG4gICAgaW52YWxpZDogIWlzUmF0aW9WYWxpZCAmJiBNYXRoLmFicygxIC0gcmF0aW8pID4gMC4wNSxcbiAgfTtcbiAgXG4gIGNvbnN0IGVmZmljaWVuY3lWYWxpZGF0aW9uID0gdmFsaWRhdGVDb21wdXRlRWZmaWNpZW5jeShvcmJpdEVmZmVjdGl2ZUdmbG9wc1BlclcsIHBhcmFtcy5lZmZpY2llbmN5TGV2ZWwpO1xuICBjb25zdCBjb25zaXN0ZW5jeUNoZWNrID0gYXNzZXJ0Q29tcHV0ZVBvd2VyQ29uc2lzdGVuY3kob3JiaXRFZmZlY3RpdmVHZmxvcHNQZXJXLCB0YXJnZXRDb21wdXRlS3csIHRvdGFsRWZmZWN0aXZlUGZsb3BzLCBNT0RFTF9VTklUUyk7XG5cbiAgLy8gU0FOSVRZIFBBTkVMOiBDb21wcmVoZW5zaXZlIGRlYnVnIGJsb2NrIHBlciB5ZWFyXG4gIGNvbnN0IHNhbml0eVBhbmVsID0ge1xuICAgIGdyb3VuZDoge1xuICAgICAgZWZmZWN0aXZlR2Zsb3BzUGVyVzogZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyVyxcbiAgICAgIGVuZXJneUNvc3RQZXJQZmxvcFllYXI6IGdyb3VuZFJlc3VsdC5lbmVyZ3lDb3N0LFxuICAgICAgc2l0ZUNhcGV4QW1vcnQ6IGdyb3VuZFJlc3VsdC5zaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciA/PyAoZ3JvdW5kUmVzdWx0LnNpdGVDb3N0IC0gKGdyb3VuZFJlc3VsdC5jYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSA/PyAwKSAtIChncm91bmRSZXN1bHQudGltZVRvRW5lcmdpemVQZW5hbHR5ID8/IDApKSxcbiAgICAgIGRlbGF5UGVuYWx0eTogZ3JvdW5kUmVzdWx0LnRpbWVUb0VuZXJnaXplUGVuYWx0eSA/PyAwLFxuICAgICAgY2FwYWNpdHlQcmVtaXVtOiBncm91bmRSZXN1bHQuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gPz8gMCxcbiAgICAgIGNvbnN0cmFpbnRNdWx0aXBsaWVyOiBncm91bmRSZXN1bHQuY29uc3RyYWludE11bHRpcGxpZXIsXG4gICAgICB0b3RhbDogZ3JvdW5kVG90YWxDb3N0LFxuICAgIH0sXG4gICAgb3JiaXQ6IHtcbiAgICAgIC8vIFJFTU9WRUQ6IGVmZmVjdGl2ZVNwZWNpZmljUG93ZXIgKGR1cGxpY2F0ZSBvZiBzcGVjaWZpY1Bvd2VyX2VmZmVjdGl2ZV9XUGVyS2cpXG4gICAgICAvLyBVc2Ugc3BlY2lmaWNQb3dlcl9lZmZlY3RpdmVfV1BlcktnIGluc3RlYWQgKGNhbm9uaWNhbCBmaWVsZClcbiAgICAgIG1hc3NNdWx0aXBsaWVyOiBoeWJyaWRSZXN1bHQuc3BlY2lmaWNQb3dlck11bHRpcGxpZXJzPy5tYXNzTXVsdGlwbGllciA/PyAxLjAsXG4gICAgICByZXF1aXJlZEFyZWFNMjogaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0ucVBlck0yX1cgPyAoaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0ud2FzdGVIZWF0VyA/PyBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS53YXN0ZUhlYXRLdyAqIDEwMDApIC8gKGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnFQZXJNMl9XID8/IDEpIDogaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0ucGh5c2ljYWxBcmVhTTIsXG4gICAgICBhcmVhQXZhaWxhYmxlTTI6IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLmFyZWFBdmFpbGFibGVNMiA/PyBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS5waHlzaWNhbEFyZWFNMixcbiAgICAgIHRoZXJtYWxDYXBGYWN0b3I6IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnRoZXJtYWxDYXBGYWN0b3IsXG4gICAgICB0b3RhbDogcmVhbGlzdGljQ29zdFBlclBmbG9wLFxuICAgIH0sXG4gICAgYWxsSW52YXJpYW50c1Bhc3NlZDogKCgpID0+IHtcbiAgICAgIC8vIENoZWNrIGtleSBpbnZhcmlhbnRzXG4gICAgICBjb25zdCBzaXRlQ29zdENoZWNrID0gTWF0aC5hYnMoZ3JvdW5kUmVzdWx0LnNpdGVDb3N0IC0gKChncm91bmRSZXN1bHQuc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgPz8gMCkgKyAoZ3JvdW5kUmVzdWx0LnRpbWVUb0VuZXJnaXplUGVuYWx0eSA/PyAwKSArIChncm91bmRSZXN1bHQuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gPz8gMCkpKSA8IDAuMDE7XG4gICAgICBjb25zdCB0aGVybWFsQXJlYUNoZWNrID0gaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0uYXJlYUF2YWlsYWJsZU0yID8gTWF0aC5hYnMoaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0uYXJlYUF2YWlsYWJsZU0yIC0gaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0ucGh5c2ljYWxBcmVhTTIpIC8gaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0ucGh5c2ljYWxBcmVhTTIgPCAwLjAxIDogdHJ1ZTtcbiAgICAgIGNvbnN0IHNwZWNpZmljUG93ZXJDaGVjayA9IGh5YnJpZFJlc3VsdC5zcGVjaWZpY1Bvd2VyTXVsdGlwbGllcnMgPyBoeWJyaWRSZXN1bHQuc3BlY2lmaWNQb3dlck11bHRpcGxpZXJzLmVmZmVjdGl2ZSA8PSBoeWJyaWRSZXN1bHQuc3BlY2lmaWNQb3dlck11bHRpcGxpZXJzLmJhc2VTcGVjaWZpY1Bvd2VyICogMS4wMSA6IHRydWU7XG4gICAgICBjb25zdCB0aGVybWFsQ2FwQ2hlY2sgPSBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS50aGVybWFsQ2FwRmFjdG9yID49IDAgJiYgaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0udGhlcm1hbENhcEZhY3RvciA8PSAxO1xuICAgICAgcmV0dXJuIHNpdGVDb3N0Q2hlY2sgJiYgdGhlcm1hbEFyZWFDaGVjayAmJiBzcGVjaWZpY1Bvd2VyQ2hlY2sgJiYgdGhlcm1hbENhcENoZWNrO1xuICAgIH0pKCksXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICB5ZWFyLFxuICAgIG1vZGU6IHBhcmFtcy5pc1N0YXRpY01vZGUgPyAnU1RBVElDJyA6ICdEWU5BTUlDJyxcbiAgICBzYW5pdHlQYW5lbCxcbiAgICBncm91bmQ6IHtcbiAgICAgIGVsZWN0cmljaXR5UHJpY2VQZXJNd2g6IGdyb3VuZEVsZWN0cmljaXR5UHJpY2VQZXJNd2gsXG4gICAgICBwdWU6IGVmZmVjdGl2ZVB1ZUdyb3VuZCxcbiAgICAgIGNhcGFjaXR5RmFjdG9yOiBjYXBhY2l0eUZhY3Rvckdyb3VuZCxcbiAgICAgIC8vIEhBUkQgQVNTRVJUOiBBbGwgZ3JvdW5kIGVmZmljaWVuY3kgZmllbGRzIG11c3QgYmUgcG9wdWxhdGVkIGFuZCBmaW5pdGVcbiAgICAgIGdmbG9wc1BlcldhdHQ6ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyVztcbiAgICAgICAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkgfHwgdmFsdWUgPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZ3JvdW5kLmdmbG9wc1BlcldhdHQgaXMgaW52YWxpZDogJHt2YWx1ZX0uIGFjdHVhbEdyb3VuZElucHV0PSR7YWN0dWFsR3JvdW5kSW5wdXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSkoKSwgLy8gRWZmZWN0aXZlIChzeXN0ZW0pIEdGTE9QUy9XXG4gICAgICBjb21wdXRlRGVmaW5pdGlvbjogKCgpID0+IHtcbiAgICAgICAgLy8gQ1JJVElDQUwgRklYOiBWYWxpZGF0ZSBhbGwgY29tcHV0ZURlZmluaXRpb24gZmllbGRzIHRvIGNhdGNoIHVuaXQgY29ycnVwdGlvblxuICAgICAgICBjb25zdCBwZWFrID0gdmFsaWRhdGVHZmxvcHNQZXJXYXR0KFxuICAgICAgICAgIGdyb3VuZEVmZmljaWVuY3lSZXN1bHQuZGVidWcuY2hpcFBlYWtHZmxvcHNQZXJXLFxuICAgICAgICAgICdncm91bmQuY29tcHV0ZURlZmluaXRpb24ucGVha0dmbG9wc1BlcldhdHQnXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZSA9IHZhbGlkYXRlR2Zsb3BzUGVyV2F0dChcbiAgICAgICAgICBncm91bmRFZmZpY2llbmN5UmVzdWx0LmRlYnVnLmVmZmVjdGl2ZUdmbG9wc1BlclcsXG4gICAgICAgICAgJ2dyb3VuZC5jb21wdXRlRGVmaW5pdGlvbi5lZmZlY3RpdmVHZmxvcHNQZXJXYXR0J1xuICAgICAgICApO1xuICAgICAgICBjb25zdCB1dGlsaXphdGlvbiA9IGdyb3VuZEVmZmljaWVuY3lSZXN1bHQuZGVidWcudXRpbGl6YXRpb25GYWN0b3I7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWlzRmluaXRlKHV0aWxpemF0aW9uKSB8fCB1dGlsaXphdGlvbiA8PSAwIHx8IHV0aWxpemF0aW9uID4gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZ3JvdW5kLmNvbXB1dGVEZWZpbml0aW9uLnV0aWxpemF0aW9uRmFjdG9yIGlzIGludmFsaWQ6ICR7dXRpbGl6YXRpb259YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hpcE5hbWU6ICdOVklESUEgSDEwMCBTWE0nLFxuICAgICAgICAgIHByZWNpc2lvbjogJ0ZQMTYnLFxuICAgICAgICAgIHBlYWtHZmxvcHNQZXJXYXR0OiBwZWFrLFxuICAgICAgICAgIHV0aWxpemF0aW9uRmFjdG9yOiB1dGlsaXphdGlvbixcbiAgICAgICAgICBlZmZlY3RpdmVHZmxvcHNQZXJXYXR0OiBlZmZlY3RpdmUsXG4gICAgICAgICAgbm90ZXM6ICdEYXRhY2VudGVyIGRlcGxveW1lbnQsIHN5c3RlbS1sZXZlbCBlZmZpY2llbmN5JyxcbiAgICAgICAgfTtcbiAgICAgIH0pKCksXG4gICAgICBlbmVyZ3lDb3N0UGVyUGZsb3BZZWFyOiAoKCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdyb3VuZFJlc3VsdC5lbmVyZ3lDb3N0O1xuICAgICAgICBpZiAoIWlzRmluaXRlKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgZ3JvdW5kLmVuZXJneUNvc3RQZXJQZmxvcFllYXIgaXMgaW52YWxpZDogJHt2YWx1ZX0uIGAgK1xuICAgICAgICAgICAgYENoZWNrOiBncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXPSR7Z3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyV30sIGAgK1xuICAgICAgICAgICAgYGdyb3VuZEVsZWN0cmljaXR5UHJpY2VQZXJNd2g9JHtncm91bmRFbGVjdHJpY2l0eVByaWNlUGVyTXdofSwgYCArXG4gICAgICAgICAgICBgZWZmZWN0aXZlUHVlR3JvdW5kPSR7ZWZmZWN0aXZlUHVlR3JvdW5kfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pKCksIC8vIFJhdyBlbGVjdHJpY2l0eSAoTk8gY29uc3RyYWludCBtdWx0aXBsaWVyKVxuICAgICAgc2l0ZUNvc3RQZXJQZmxvcFllYXI6ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ3JvdW5kUmVzdWx0LnNpdGVDb3N0O1xuICAgICAgICBpZiAoIWlzRmluaXRlKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGdyb3VuZC5zaXRlQ29zdFBlclBmbG9wWWVhciBpcyBpbnZhbGlkOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pKCksIC8vIFNpdGUgY29zdHMgPSBzdW0gb2YgY29tcG9uZW50cyAoSU5WQVJJQU5UKVxuICAgICAgc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXI6IGdyb3VuZFJlc3VsdC5zaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciA/PyAoZ3JvdW5kUmVzdWx0LnNpdGVDb3N0IC0gKGdyb3VuZFJlc3VsdC5jYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSA/PyAwKSAtIChncm91bmRSZXN1bHQudGltZVRvRW5lcmdpemVQZW5hbHR5ID8/IDApKSwgLy8gUHVyZSBjYXBleCBhbW9ydGl6YXRpb25cbiAgICAgIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtOiBncm91bmRSZXN1bHQuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gPz8gMCwgLy8gRXhwbGljaXQgY2FwYWNpdHkvZGVsaXZlcnkgcHJlbWl1bSAoaW5kZXBlbmRlbnQpXG4gICAgICB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHk6IGdyb3VuZFJlc3VsdC50aW1lVG9FbmVyZ2l6ZVBlbmFsdHkgPz8gMCwgLy8gUXVldWUgZGVsYXkgcGVuYWx0eSAoV0FDQy1iYXNlZCwgaW5kZXBlbmRlbnQpXG4gICAgICBoYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyOiBncm91bmRSZXN1bHQuaGFyZHdhcmVDb3N0LFxuICAgICAgY29uc3RyYWludE11bHRpcGxpZXI6IDEuMCwgLy8gTk9UIEFQUExJRUQgLSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXQgb25seVxuICAgICAgY29uc3RyYWludEJyZWFrZG93bjoge1xuICAgICAgICAuLi5jb25zdHJhaW50QnJlYWtkb3duLFxuICAgICAgICBjYXBhY2l0eURlbGl2ZXJ5TXVsdGlwbGllcjogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgfSxcbiAgICAgIGNvbnN0cmFpbnRzOiAoZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRzID8ge1xuICAgICAgICAuLi5ncm91bmRSZXN1bHQuY29uc3RyYWludHMsXG4gICAgICAgIG1ldGhvZDogJ2FkZGVycycgYXMgY29uc3QsXG4gICAgICB9IDoge1xuICAgICAgICBtZXRob2Q6ICdhZGRlcnMnIGFzIGNvbnN0LFxuICAgICAgICBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bTogKGdyb3VuZFJlc3VsdC5jYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSB8fCAwKSxcbiAgICAgICAgZGVsYXlQZW5hbHR5OiAoZ3JvdW5kUmVzdWx0LnRpbWVUb0VuZXJnaXplUGVuYWx0eSB8fCAwKSxcbiAgICAgICAgYXBwbGllZE11bHRpcGxpZXJzOiB7XG4gICAgICAgICAgY29uc3RyYWludE11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgICBlbmVyZ3lNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgICAgc2l0ZU11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgIH0pIGFzIHsgbWV0aG9kOiAnYWRkZXJzJzsgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW06IG51bWJlcjsgZGVsYXlQZW5hbHR5OiBudW1iZXI7IGFwcGxpZWRNdWx0aXBsaWVyczogeyBjb25zdHJhaW50TXVsdGlwbGllclVzZWQ6IGJvb2xlYW47IGVuZXJneU11bHRpcGxpZXJVc2VkOiBib29sZWFuOyBzaXRlTXVsdGlwbGllclVzZWQ6IGJvb2xlYW47IH07IGRlYnVnPzogYW55IH0sXG4gICAgICBzdXBwbHlNZXRyaWNzOiAoZ3JvdW5kUmVzdWx0IGFzIGFueSkuc3VwcGx5TWV0cmljcyxcbiAgICAgIGNvbnN0cmFpbnRDb21wb25lbnRzOiAoZ3JvdW5kUmVzdWx0IGFzIGFueSkuY29uc3RyYWludENvbXBvbmVudHMsXG4gICAgICB0b3RhbENvc3RQZXJQZmxvcFllYXI6ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ3JvdW5kVG90YWxDb3N0O1xuICAgICAgICBpZiAoIWlzRmluaXRlKHZhbHVlKSB8fCB2YWx1ZSA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYGdyb3VuZC50b3RhbENvc3RQZXJQZmxvcFllYXIgaXMgaW52YWxpZDogJHt2YWx1ZX0uIGAgK1xuICAgICAgICAgICAgYENvbXBvbmVudHM6IGVuZXJneT0ke2dyb3VuZFJlc3VsdC5lbmVyZ3lDb3N0fSwgc2l0ZT0ke2dyb3VuZFJlc3VsdC5zaXRlQ29zdH0sIGhhcmR3YXJlPSR7Z3JvdW5kUmVzdWx0LmhhcmR3YXJlQ29zdH0sIGAgK1xuICAgICAgICAgICAgYGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1Blclc9JHtncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXfSwgYWN0dWFsR3JvdW5kSW5wdXQ9JHthY3R1YWxHcm91bmRJbnB1dH1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KSgpLFxuICAgICAgZ3B1SG91clByaWNpbmc6IHtcbiAgICAgICAgYmFzaWM6IGdyb3VuZEdwdUhvdXIoU0xBX1RJRVJTLmJhc2ljKSxcbiAgICAgICAgc3RhbmRhcmQ6IGdyb3VuZEdwdUhvdXIoU0xBX1RJRVJTLnN0YW5kYXJkKSxcbiAgICAgICAgcHJlbWl1bTogZ3JvdW5kR3B1SG91cihTTEFfVElFUlMucHJlbWl1bSksXG4gICAgICB9LFxuICAgICAgdG9rZW5QcmljaW5nOiBncm91bmRUb2tlbnMsXG4gICAgICBzbXJFbmFibGVkOiBncm91bmRSZXN1bHQuc21yRW5hYmxlZCxcbiAgICAgIHNtclJhbXBGYWN0b3I6IGdyb3VuZFJlc3VsdC5zbXJSYW1wRmFjdG9yLFxuICAgICAgZWZmZWN0aXZlRWxlY3RyaWNpdHlDb3N0OiBncm91bmRSZXN1bHQuZWZmZWN0aXZlRWxlY3RyaWNpdHlDb3N0LFxuICAgICAgY29uc3RyYWludFJlbGllZjogZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRSZWxpZWZcbiAgICB9LFxuICAgIG9yYml0OiB7XG4gICAgICBsY29lUGVyTXdoOiAoaHlicmlkUmVzdWx0LnBvd2VyU3lzdGVtLnRvdGFsQ29zdFVzZCkgLyAoc2F0ZWxsaXRlUG93ZXJLVyAqIFBIWVNJQ1NfQ09OU1RBTlRTLkhPVVJTX1BFUl9ZRUFSICogbGlmZXRpbWVZZWFycyAqIGh5YnJpZFJlc3VsdC5jYXBhY2l0eUZhY3RvciAvIDEwMDApLFxuICAgICAgcHVlOiBwdWVPcmJpdGFsLFxuICAgICAgY2FwYWNpdHlGYWN0b3I6IGh5YnJpZFJlc3VsdC5jYXBhY2l0eUZhY3RvcixcbiAgICAgIGNhcGFjaXR5RmFjdG9yUHJvdmVuYW5jZTogaHlicmlkUmVzdWx0LmNvbXB1dGVQYXlsb2FkPy5jYXBhY2l0eUZhY3RvclByb3ZlbmFuY2UsIC8vIERlYnVnOiBDRiBicmVha2Rvd25cbiAgICAgIGdmbG9wc1BlcldhdHQ6IG9yYml0RWZmZWN0aXZlR2Zsb3BzUGVyVywgLy8gRGVsaXZlcmVkIEdGTE9QUy9XIChzeXN0ZW1FZmZlY3RpdmUgw5cgdGhlcm1hbENhcCDDlyByYWRpYXRpb25EZXJhdGUgw5cgYXZhaWxhYmlsaXR5KVxuICAgICAgY29tcHV0ZURlZmluaXRpb246IHtcbiAgICAgICAgY2hpcE5hbWU6ICdIMTAwLWVxdWl2YWxlbnQgKHJhZC10b2xlcmFudCknLFxuICAgICAgICBwcmVjaXNpb246ICdGUDE2JyxcbiAgICAgICAgcGVha0dmbG9wc1BlcldhdHQ6IHZhbGlkYXRlR2Zsb3BzUGVyV2F0dChcbiAgICAgICAgICBvcmJpdFBlYWtHZmxvcHNQZXJXYXR0LFxuICAgICAgICAgICdvcmJpdC5jb21wdXRlRGVmaW5pdGlvbi5wZWFrR2Zsb3BzUGVyV2F0dCdcbiAgICAgICAgKSxcbiAgICAgICAgdXRpbGl6YXRpb25GYWN0b3I6IG9yYml0YWxFZmZpY2llbmN5UmVzdWx0LmRlYnVnLnV0aWxpemF0aW9uRmFjdG9yLFxuICAgICAgICBlZmZlY3RpdmVHZmxvcHNQZXJXYXR0OiBvcmJpdFN5c3RlbUVmZmVjdGl2ZUdmbG9wc1BlcldhdHQsIC8vIFN5c3RlbS1lZmZlY3RpdmUgPSBwZWFrICogdXRpbGl6YXRpb24gLyBzeXN0ZW1PdmVyaGVhZEZhY3RvciAoU1lTVEVNLUxFVkVMIEVGRkVDVElWRSlcbiAgICAgICAgLy8gZGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCBpcyBzdG9yZWQgaW4gb3JiaXQuY29tcHV0ZUVmZmljaWVuY3kuZ2Zsb3BzUGVyV2F0dCwgbm90IGhlcmVcbiAgICAgICAgbm90ZXM6ICdDb21tZXJjaWFsIHJhZC10b2xlcmFudCB2YXJpYW50LiBwZWFrR2Zsb3BzUGVyV2F0dCA9IGNoaXAgcGVhay4gZWZmZWN0aXZlR2Zsb3BzUGVyV2F0dCA9IHBlYWsgKiB1dGlsaXphdGlvbiAvIHN5c3RlbU92ZXJoZWFkRmFjdG9yIChzeXN0ZW0tbGV2ZWwgZWZmZWN0aXZlKS4gZGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCA9IHN5c3RlbUVmZmVjdGl2ZSDDlyB0aGVybWFsQ2FwRmFjdG9yIMOXIHJhZGlhdGlvbkRlcmF0ZSDDlyBhdmFpbGFiaWxpdHknLFxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVFZmZpY2llbmN5UHJvdmVuYW5jZToge1xuICAgICAgICBwZWFrR2Zsb3BzUGVyV2F0dDogb3JiaXRhbEVmZmljaWVuY3lSZXN1bHQuZGVidWcuY2hpcFBlYWtHZmxvcHNQZXJXLFxuICAgICAgICB1dGlsaXphdGlvbkZhY3Rvcjogb3JiaXRhbEVmZmljaWVuY3lSZXN1bHQuZGVidWcudXRpbGl6YXRpb25GYWN0b3IsXG4gICAgICAgIHN5c3RlbU92ZXJoZWFkRmFjdG9yOiBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5kZWJ1Zy5zeXN0ZW1PdmVyaGVhZEZhY3RvcixcbiAgICAgICAgZWZmZWN0aXZlR2Zsb3BzUGVyV2F0dDogb3JiaXRhbEVmZmljaWVuY3lSZXN1bHQuZGVidWcuZWZmZWN0aXZlR2Zsb3BzUGVyVyxcbiAgICAgIH0sIC8vIERlYnVnOiBHRkxPUFMvVyBicmVha2Rvd25cbiAgICAgIGxhdW5jaENvc3RQZXJLZzogbGF1bmNoQ29zdFBlcktnLFxuICAgICAgc3BlY2lmaWNQb3dlcldQZXJLZzogaHlicmlkUmVzdWx0LnNwZWNpZmljUG93ZXJXUGVyS2csIC8vIERlcHJlY2F0ZWQ6IHVzZSBzcGVjaWZpY1Bvd2VyX3N1YnN5c3RlbV9XUGVyS2dcbiAgICAgIHNwZWNpZmljUG93ZXJfc3Vic3lzdGVtX1dQZXJLZzogaHlicmlkUmVzdWx0LnNwZWNpZmljUG93ZXJXUGVyS2csIC8vIFN1YnN5c3RlbS1sZXZlbCAoc29sYXIgYXJyYXkgb25seSlcbiAgICAgIHNwZWNpZmljUG93ZXJfZWZmZWN0aXZlX1dQZXJLZzogaHlicmlkUmVzdWx0LnNwZWNpZmljUG93ZXJNdWx0aXBsaWVycz8uZWZmZWN0aXZlID8/IHNjYWxpbmdSZXN1bHQuZWZmZWN0aXZlU3BlY2lmaWNQb3dlciwgLy8gRWZmZWN0aXZlIHNwYWNlY3JhZnQtbGV2ZWwgKGZyb20gbXVsdGlwbGllcnMgY2FsY3VsYXRpb24pXG4gICAgICAvLyBVc2Ugc3BlY2lmaWNQb3dlck11bHRpcGxpZXJzIGZyb20gaHlicmlkUmVzdWx0IChjYWxjdWxhdGVkIGluIG9yYml0YWxQaHlzaWNzLnRzIHdpdGggY29ycmVjdCBtYXNzIGZyYWN0aW9uIGFjY291bnRpbmcpXG4gICAgICBzcGVjaWZpY1Bvd2VyTXVsdGlwbGllcnM6IGh5YnJpZFJlc3VsdC5zcGVjaWZpY1Bvd2VyTXVsdGlwbGllcnMsXG4gICAgICBlbmVyZ3lDb3N0UGVyUGZsb3BZZWFyOiBvcmJpdGFsQnJlYWtkb3duLnBvd2VyLFxuICAgICAgaGFyZHdhcmVDb3N0UGVyUGZsb3BZZWFyOiBvcmJpdGFsQnJlYWtkb3duLmNvbXB1dGUsXG4gICAgICBsYXVuY2hDb3N0UGVyUGZsb3BZZWFyOiBvcmJpdGFsQnJlYWtkb3duLmxhdW5jaCxcbiAgICAgIHJhZGlhdGlvbk11bHRpcGxpZXI6IDEuMCxcbiAgICAgIHRoZXJtYWxDYXBGYWN0b3I6IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnRoZXJtYWxDYXBGYWN0b3IsXG4gICAgICBjb25nZXN0aW9uQ29zdFBlclBmbG9wWWVhcjogb3JiaXRhbEJyZWFrZG93bi5jb25nZXN0aW9uLFxuICAgICAgdG90YWxDb3N0UGVyUGZsb3BZZWFyOiByZWFsaXN0aWNDb3N0UGVyUGZsb3AsIFxuICAgICAgdGhlcm1hbENhcHBlZDogaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0udGhlcm1hbENhcHBlZCxcbiAgICAgIGNvbXB1dGVQb3dlckt3OiB0YXJnZXRDb21wdXRlS3csIC8vIFRvdGFsIGNvbnN0ZWxsYXRpb24gY29tcHV0ZSBwb3dlclxuICAgICAgbWF4UmVqZWN0YWJsZUt3OiBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS5tYXhSZWplY3RhYmxlS3cgfHwgaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0ud2FzdGVIZWF0S3cgKiAxLjI1LFxuICAgICAgY29sbGlzaW9uUmlzazogY29uZ2VzdGlvbi5jb2xsaXNpb25SaXNrLFxuICAgICAgYm9keU1vdW50ZWRBcmVhTTI6IDAsXG4gICAgICBkZXBsb3lhYmxlQXJlYU0yOiBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS5waHlzaWNhbEFyZWFNMixcbiAgICAgIHRvdGFsUmFkaWF0b3JBcmVhTTI6IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnBoeXNpY2FsQXJlYU0yLFxuICAgICAgcmFkaWF0b3JDb3N0UGVyUGZsb3BZZWFyOiAoaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0udG90YWxDb3N0VXNkICogY29uc3RlbGxhdGlvbkNvc3RNdWx0aXBsaWVyKSAvIHRvdGFsRWZmZWN0aXZlUGZsb3BzIC8gbGlmZXRpbWVZZWFycyxcbiAgICAgIHJhZGlhdG9yTWFzc0tnOiBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS50b3RhbE1hc3NLZyxcbiAgICAgIG9wdGltaXN0aWNDb3N0UGVyUGZsb3A6IG9yYml0YWxCcmVha2Rvd24ucG93ZXIgKyBvcmJpdGFsQnJlYWtkb3duLmNvbXB1dGUgKyBvcmJpdGFsQnJlYWtkb3duLmJ1cyxcbiAgICAgIHJhZGlhdGlvblNoaWVsZGluZ0Nvc3Q6IG9yYml0YWxCcmVha2Rvd24ucmFkaWF0aW9uLFxuICAgICAgdGhlcm1hbFN5c3RlbUNvc3Q6IG9yYml0YWxCcmVha2Rvd24udGhlcm1hbCxcbiAgICAgIHJlcGxhY2VtZW50UmF0ZUNvc3Q6IG9yYml0YWxCcmVha2Rvd24ub3BzLFxuICAgICAgZWNjT3ZlcmhlYWRDb3N0OiAwLFxuICAgICAgcmVkdW5kYW5jeUNvc3Q6IDAsXG4gICAgICByZWFsaXN0aWNDb3N0UGVyUGZsb3AsXG4gICAgICBoeWJyaWRCcmVha2Rvd246IG9yYml0YWxCcmVha2Rvd24sXG4gICAgICBncHVIb3VyUHJpY2luZzoge1xuICAgICAgICBiYXNpYzogb3JiaXRhbEdwdUhvdXIoU0xBX1RJRVJTLmJhc2ljKSxcbiAgICAgICAgc3RhbmRhcmQ6IG9yYml0YWxHcHVIb3VyKFNMQV9USUVSUy5zdGFuZGFyZCksXG4gICAgICAgIHByZW1pdW06IG9yYml0YWxHcHVIb3VyKFNMQV9USUVSUy5wcmVtaXVtKSxcbiAgICAgIH0sXG4gICAgICB0b2tlblByaWNpbmc6IG9yYml0YWxUb2tlbnMsXG4gICAgICByYWRpYXRpb25EZWdyYWRhdGlvbjoge1xuICAgICAgICBhbm51YWxGYWlsdXJlUmF0ZTogdXNlUmFkSGFyZENoaXBzID8gMC4wOSA6IDAuMTUsXG4gICAgICAgIGVmZmVjdGl2ZUNvbXB1dGVQZXJjZW50OiBoeWJyaWRSZXN1bHQuZGVncmFkYXRpb25GYWN0b3IsXG4gICAgICAgIGVjY092ZXJoZWFkUGN0OiAwLjA1LFxuICAgICAgICBhcHBsaWVkOiB0cnVlXG4gICAgICB9LFxuICAgICAgcG93ZXJTeXN0ZW1UeXBlOiBoeWJyaWRSZXN1bHQucG93ZXJTeXN0ZW1UeXBlLFxuICAgICAgc2NhbGluZ1BlbmFsdHk6IHNjYWxpbmdSZXN1bHQuc2NhbGluZ1BlbmFsdHksXG4gICAgICAvLyBSRU1PVkVEOiBlZmZlY3RpdmVTcGVjaWZpY1Bvd2VyIChkdXBsaWNhdGUgb2Ygc3BlY2lmaWNQb3dlcl9lZmZlY3RpdmVfV1BlcktnKVxuICAgICAgLy8gVXNlIHNwZWNpZmljUG93ZXJfZWZmZWN0aXZlX1dQZXJLZyBpbnN0ZWFkIChjYW5vbmljYWwgZmllbGQpXG4gICAgICBmdXNpb25EZXRhaWxzOiBoeWJyaWRSZXN1bHQuZnVzaW9uRGV0YWlscyxcbiAgICAgIFxuICAgICAgLy8gQ29uc3RlbGxhdGlvbiBzaXppbmdcbiAgICAgIGNvbnN0ZWxsYXRpb246IHtcbiAgICAgICAgZGVzaWduOiB7XG4gICAgICAgICAgbnVtU2F0ZWxsaXRlczogY29uc3RlbGxhdGlvbi5udW1TYXRlbGxpdGVzLFxuICAgICAgICAgIGNvbXB1dGVQZXJTYXRLdzogY29uc3RlbGxhdGlvbi5jb21wdXRlUGVyU2F0S3csXG4gICAgICAgICAgbWFzc1BlclNhdEtnOiBtYXNzUGVyU2F0S2csXG4gICAgICAgICAgcmFkaWF0b3JBcmVhUGVyU2F0TTI6IGNvbnN0ZWxsYXRpb24ucmFkaWF0b3JBcmVhUGVyU2F0TTIsXG4gICAgICAgIH0sXG4gICAgICAgIGxhdW5jaDoge1xuICAgICAgICAgIHNhdHNQZXJMYXVuY2g6IGNvbnN0ZWxsYXRpb24uc2F0c1BlckxhdW5jaCxcbiAgICAgICAgICBsYXVuY2hlc1JlcXVpcmVkOiBjb25zdGVsbGF0aW9uLmxhdW5jaGVzUmVxdWlyZWQsXG4gICAgICAgICAgdG90YWxNYXNzS2c6IGVmZmVjdGl2ZVRvdGFsTWFzc0tnLFxuICAgICAgICB9LFxuICAgICAgICBzY2FsaW5nOiB7XG4gICAgICAgICAgY29uc3RlbGxhdGlvbk92ZXJoZWFkOiBjb25zdGVsbGF0aW9uLmNvbnN0ZWxsYXRpb25PdmVyaGVhZCxcbiAgICAgICAgICBzY2FsaW5nRWZmaWNpZW5jeTogY29uc3RlbGxhdGlvbi5zY2FsaW5nRWZmaWNpZW5jeSxcbiAgICAgICAgfSxcbiAgICAgICAgd2FybmluZ3M6IGNvbnN0ZWxsYXRpb24ud2FybmluZ3MsXG4gICAgICB9LFxuICAgICAgXG4gICAgICAvLyBEZWJ1ZyBibG9ja3MgZm9yIGFuYWx5c2lzIC0gZXhwbGljaXRseSB0cmFjayBhbGwgZWZmaWNpZW5jeSBsZXZlbHNcbiAgICAgIC8vIFNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGg6IGRlZmluZSBvcmJpdC5jb21wdXRlRWZmaWNpZW5jeUxldmVscyBlYWNoIHllYXJcbiAgICAgIC8vIE5vdGU6IGNvbXB1dGVFZmZpY2llbmN5TGV2ZWxzIGlzIHN0b3JlZCBpbiBtZXRhZGF0YSwgbm90IGRpcmVjdGx5IG9uIG9yYml0XG4gICAgICBlZmZlY3RpdmVDb21wdXRlTXVsdGlwbGllcnM6IHtcbiAgICAgICAgdGhlcm1hbENhcEZhY3RvcjogaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0udGhlcm1hbENhcEZhY3RvcixcbiAgICAgICAgcmFkaWF0aW9uRGVyYXRlOiBoeWJyaWRSZXN1bHQuZGVncmFkYXRpb25GYWN0b3IgfHwgMS4wLFxuICAgICAgICBhdmFpbGFiaWxpdHk6IGh5YnJpZFJlc3VsdC5jYXBhY2l0eUZhY3RvciB8fCAxLjAsXG4gICAgICAgIHV0aWxpemF0aW9uOiBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5kZWJ1Zy51dGlsaXphdGlvbkZhY3RvcixcbiAgICAgIH0sXG4gICAgICBjb3N0U2hhcmVzOiAoKCkgPT4ge1xuICAgICAgICBjb25zdCB0b3RhbCA9IHJlYWxpc3RpY0Nvc3RQZXJQZmxvcDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsYXVuY2g6IChvcmJpdGFsQnJlYWtkb3duLmxhdW5jaCAvIHRvdGFsKSAqIDEwMCxcbiAgICAgICAgICBwb3dlcjogKG9yYml0YWxCcmVha2Rvd24ucG93ZXIgLyB0b3RhbCkgKiAxMDAsXG4gICAgICAgICAgY29tcHV0ZTogKG9yYml0YWxCcmVha2Rvd24uY29tcHV0ZSAvIHRvdGFsKSAqIDEwMCxcbiAgICAgICAgICB0aGVybWFsOiAob3JiaXRhbEJyZWFrZG93bi50aGVybWFsIC8gdG90YWwpICogMTAwLFxuICAgICAgICAgIGJ1czogKG9yYml0YWxCcmVha2Rvd24uYnVzIC8gdG90YWwpICogMTAwLFxuICAgICAgICAgIG9wczogKG9yYml0YWxCcmVha2Rvd24ub3BzIC8gdG90YWwpICogMTAwLFxuICAgICAgICAgIG5ldHdvcmtpbmc6IChvcmJpdGFsQnJlYWtkb3duLm5ldHdvcmtpbmcgLyB0b3RhbCkgKiAxMDAsXG4gICAgICAgICAgZ3JvdW5kU2VnbWVudDogKG9yYml0YWxCcmVha2Rvd24ucmVndWxhdG9yeSAvIHRvdGFsKSAqIDEwMCwgLy8gUmVndWxhdG9yeSBpbmNsdWRlcyBncm91bmQgc2VnbWVudFxuICAgICAgICB9O1xuICAgICAgfSkoKSxcbiAgICAgIGxvY2FsU2Vuc2l0aXZpdHk6ICgoKSA9PiB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBsb2NhbCBzZW5zaXRpdml0eTogZENvc3QvZFBhcmFtZXRlciAoYXBwcm94aW1hdGUgZGVyaXZhdGl2ZXMpXG4gICAgICAgIFxuICAgICAgICAvLyBkQ29zdF9kTGF1bmNoOiBsYXVuY2ggY29zdCBzY2FsZXMgbGluZWFybHkgd2l0aCBsYXVuY2hDb3N0UGVyS2dcbiAgICAgICAgY29uc3QgZENvc3RfZExhdW5jaCA9IG9yYml0YWxCcmVha2Rvd24ubGF1bmNoIC8gbGF1bmNoQ29zdFBlcktnO1xuICAgICAgICBcbiAgICAgICAgLy8gZENvc3RfZFNwZWNpZmljUG93ZXI6IHBvd2VyIGNvc3Qgc2NhbGVzIGludmVyc2VseSB3aXRoIHNwZWNpZmljIHBvd2VyIChuZWdhdGl2ZSlcbiAgICAgICAgY29uc3QgZENvc3RfZFNwZWNpZmljUG93ZXIgPSAtKG9yYml0YWxCcmVha2Rvd24ucG93ZXIgLyB0cmFqU3BlY2lmaWNQb3dlcik7XG4gICAgICAgIFxuICAgICAgICAvLyBkQ29zdF9kR2Zsb3BzUGVyVzogcG93ZXIgY29zdCBzY2FsZXMgaW52ZXJzZWx5IHdpdGggR0ZMT1BTL1cgKG5lZ2F0aXZlKVxuICAgICAgICBjb25zdCBkQ29zdF9kR2Zsb3BzUGVyVyA9IC0ob3JiaXRhbEJyZWFrZG93bi5wb3dlciAvIG9yYml0RWZmZWN0aXZlR2Zsb3BzUGVyVyk7XG4gICAgICAgIFxuICAgICAgICAvLyBkQ29zdF9kRmFpbHVyZVJhdGU6IG9wcyBjb3N0IHNjYWxlcyB3aXRoIGZhaWx1cmUgcmF0ZVxuICAgICAgICBjb25zdCBiYXNlRmFpbHVyZVJhdGUgPSB1c2VSYWRIYXJkQ2hpcHMgPyAwLjA5IDogMC4xNTtcbiAgICAgICAgY29uc3QgZENvc3RfZEZhaWx1cmVSYXRlID0gb3JiaXRhbEJyZWFrZG93bi5vcHMgLyBiYXNlRmFpbHVyZVJhdGU7XG4gICAgICAgIFxuICAgICAgICAvLyBkQ29zdF9kUHVlOiBwb3dlciBjb3N0IHNjYWxlcyBsaW5lYXJseSB3aXRoIFBVRVxuICAgICAgICBjb25zdCBkQ29zdF9kUHVlID0gb3JiaXRhbEJyZWFrZG93bi5wb3dlciAvIHB1ZU9yYml0YWw7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRDb3N0X2RMYXVuY2gsXG4gICAgICAgICAgZENvc3RfZFNwZWNpZmljUG93ZXIsXG4gICAgICAgICAgZENvc3RfZEdmbG9wc1BlclcsXG4gICAgICAgICAgZENvc3RfZEZhaWx1cmVSYXRlLFxuICAgICAgICAgIGRDb3N0X2RQdWUsXG4gICAgICAgIH07XG4gICAgICB9KSgpLFxuICAgIH0sXG4gICAgZWRnZUluZmVyZW5jZSxcbiAgICBjcm9zc292ZXI6IHJlYWxpc3RpY0Nvc3RQZXJQZmxvcCA8IGdyb3VuZENvbXBhcmF0b3JDb3N0UGVyUGZsb3BZZWFyLFxuICAgIGNyb3Nzb3ZlckRldGFpbHM6IHtcbiAgICAgIGdwdUhvdXJDcm9zc292ZXIsXG4gICAgICB0b2tlbkNyb3Nzb3Zlcjogb3JiaXRhbFRva2Vucy5sbGFtYTcwQi5jb3N0UGVyMWtUb2tlbnMgPCBncm91bmRUb2tlbnMubGxhbWE3MEIuY29zdFBlcjFrVG9rZW5zLFxuICAgICAgbWFya2V0UG9zaXRpb246IGdwdUhvdXJDcm9zc292ZXIgXG4gICAgICAgID8gYE9yYml0YWwgJHsoKDEgLSBvcmJpdGFsR3B1SG91cihTTEFfVElFUlMuc3RhbmRhcmQpLnByaWNlUGVyR3B1SG91ciAvIGdyb3VuZEdwdUhvdXIoU0xBX1RJRVJTLnN0YW5kYXJkKS5wcmljZVBlckdwdUhvdXIpICogMTAwKS50b0ZpeGVkKDEpfSUgY2hlYXBlcmBcbiAgICAgICAgOiBgR3JvdW5kICR7KCgxIC0gZ3JvdW5kR3B1SG91cihTTEFfVElFUlMuc3RhbmRhcmQpLnByaWNlUGVyR3B1SG91ciAvIG9yYml0YWxHcHVIb3VyKFNMQV9USUVSUy5zdGFuZGFyZCkucHJpY2VQZXJHcHVIb3VyKSAqIDEwMCkudG9GaXhlZCgxKX0lIGNoZWFwZXJgLFxuICAgIH0sXG4gICAgY29zdEFjY291bnRpbmdWYWxpZCxcbiAgICBjb3N0QWNjb3VudGluZ0Vycm9yUGN0LFxuICAgIG1ldGFkYXRhOiB7XG4gICAgICBncm91bmRVbml0czogW1xuICAgICAgICB7XG4gICAgICAgICAgbWV0cmljOiAnZ2Zsb3BzUGVyV2F0dCcsXG4gICAgICAgICAgdW5pdDogJ0dGTE9QUy9XJyxcbiAgICAgICAgICBsZXZlbDogJ3N5c3RlbScsXG4gICAgICAgICAgbm90ZXM6ICdHcm91bmQgc3lzdGVtLWxldmVsIGVmZmljaWVuY3kgaW5jbHVkaW5nIG1lbW9yeSwgbmV0d29yaywgcG93ZXIgZGVsaXZlcnkgb3ZlcmhlYWQnLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIG9yYml0VW5pdHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG1ldHJpYzogJ2dmbG9wc1BlcldhdHQnLFxuICAgICAgICAgIHVuaXQ6ICdHRkxPUFMvVycsXG4gICAgICAgICAgbGV2ZWw6ICdkZWxpdmVyZWQnLFxuICAgICAgICAgIG5vdGVzOiAnT3JiaXRhbCBkZWxpdmVyZWQgZWZmaWNpZW5jeTogc3lzdGVtRWZmZWN0aXZlIMOXIHRoZXJtYWxDYXBGYWN0b3Igw5cgcmFkaWF0aW9uRGVyYXRlIMOXIGF2YWlsYWJpbGl0eScsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgdW5pdHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG1ldHJpYzogJ2dmbG9wc1BlcldhdHQnLFxuICAgICAgICAgIHVuaXQ6ICdHRkxPUFMvVycsXG4gICAgICAgICAgbGV2ZWw6ICdzeXN0ZW0nLFxuICAgICAgICAgIG5vdGVzOiAnU3lzdGVtLWxldmVsIGVmZmljaWVuY3kgaW5jbHVkaW5nIG1lbW9yeSwgbmV0d29yaywgcG93ZXIgZGVsaXZlcnkgb3ZlcmhlYWQnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbWV0cmljOiAnY29zdFBlclBmbG9wWWVhcicsXG4gICAgICAgICAgdW5pdDogJ1VTRC9QRkxPUC15ZWFyJyxcbiAgICAgICAgICBsZXZlbDogJ2luZnJhc3RydWN0dXJlJyxcbiAgICAgICAgICBub3RlczogJ1RvdGFsIGNvc3QgdG8gb3BlcmF0ZSAxIFBGTE9QIG9mIHN1c3RhaW5lZCBjb21wdXRlIGZvciBvbmUgeWVhcicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRyaWM6ICdwcmljZVBlckdwdUhvdXInLFxuICAgICAgICAgIHVuaXQ6ICdVU0QvR1BVLWhvdXInLFxuICAgICAgICAgIGxldmVsOiAnbWFya2V0JyxcbiAgICAgICAgICBub3RlczogJ01hcmtldCBwcmljZSB3aXRoIFNMQSwgaW5jbHVkaW5nIG1hcmdpbiBhbmQgcmlzayBidWZmZXInLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbWV0cmljOiAnY29zdFBlcjFrVG9rZW5zJyxcbiAgICAgICAgICB1bml0OiAnVVNELzFLIHRva2VucycsXG4gICAgICAgICAgbGV2ZWw6ICdhcHBsaWNhdGlvbicsXG4gICAgICAgICAgbm90ZXM6ICdJbmZlcmVuY2UgY29zdCBmb3Igc3BlY2lmaWVkIG1vZGVsIHNpemUgKDcwQiBvciA0MDVCKScsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGVidWc6IHtcbiAgICAgICAgZ3JvdW5kTGlmZXRpbWU6IGdyb3VuZExpZmV0aW1lLFxuICAgICAgICBncHVGYWlsdXJlUmF0ZUFubnVhbDogcGFyYW1zLmdwdUZhaWx1cmVSYXRlQW5udWFsLFxuICAgICAgICB0b3RhbENvc3RFeGNsdWRlc0RlbGF5UGVuYWx0eTogdHJ1ZSwgLy8gSGVhZGxpbmUgY29zdCBleGNsdWRlcyBkZWxheSBwZW5hbHR5IChoYW5kbGVkIHZpYSBjYXBhY2l0eSBnYXRpbmcpXG4gICAgICAgIHRvdGFsQ29zdEVmZmVjdGl2ZUluY2x1ZGVzRGVsYXlQZW5hbHR5OiBncm91bmRSZXN1bHQudG90YWxDb3N0UGVyUGZsb3BZZWFyRWZmZWN0aXZlICE9PSB1bmRlZmluZWQsXG4gICAgICAgIGdyb3VuZEhhc1F1ZXVlLFxuICAgICAgICBncm91bmRDb21wYXJhdG9yQ29zdFBlclBmbG9wWWVhcixcbiAgICAgIH0sXG4gICAgICBjb21wdXRlRWZmaWNpZW5jeToge1xuICAgICAgICBnZmxvcHNQZXJXYXR0OiBvcmJpdEVmZmVjdGl2ZUdmbG9wc1BlclcsIC8vIERlbGl2ZXJlZCBlZmZpY2llbmN5IChhbGlhcylcbiAgICAgICAgZWZmaWNpZW5jeUxldmVsOiAnZGVsaXZlcmVkJywgLy8gQ2hhbmdlZCBmcm9tICdzeXN0ZW0nIHRvICdkZWxpdmVyZWQnXG4gICAgICAgIHZhbGlkYXRpb246IHtcbiAgICAgICAgICAvLyBDUklUSUNBTDogVXNlIGRlbGl2ZXJlZFZhbGlkYXRpb24gYXMgcHJpbWFyeSAtIGl0IGNvbXBhcmVzIGxpa2UtZm9yLWxpa2VcbiAgICAgICAgICAvLyBPbmx5IGZhaWwgaWYgZGVsaXZlcmVkVmFsaWRhdGlvbiBmYWlscyAocmF0aW8gbWlzbWF0Y2gpIE9SIGVmZmljaWVuY3lWYWxpZGF0aW9uIGZhaWxzIChyYW5nZSBjaGVjaylcbiAgICAgICAgICAvLyBjb25zaXN0ZW5jeUNoZWNrIGlzIGZvciBwb3dlci9jb21wdXRlIGNvbnNpc3RlbmN5LCBub3QgZWZmaWNpZW5jeSB2YWxpZGF0aW9uXG4gICAgICAgICAgdmFsaWQ6IGVmZmljaWVuY3lWYWxpZGF0aW9uLnZhbGlkICYmIGRlbGl2ZXJlZFZhbGlkYXRpb24udmFsaWQsXG4gICAgICAgICAgd2FybmluZzogZWZmaWNpZW5jeVZhbGlkYXRpb24ud2FybmluZyB8fCBkZWxpdmVyZWRWYWxpZGF0aW9uLndhcm5pbmcgfHwgdW5kZWZpbmVkLCAvLyBPbmx5IGVmZmljaWVuY3kgb3IgZGVsaXZlcmVkIG1pc21hdGNoIHdhcm5pbmdzXG4gICAgICAgICAgZXhwZWN0ZWREZWxpdmVyZWQ6IGRlbGl2ZXJlZFZhbGlkYXRpb24uZXhwZWN0ZWREZWxpdmVyZWQsXG4gICAgICAgICAgZGVsaXZlcmVkOiBkZWxpdmVyZWRWYWxpZGF0aW9uLmRlbGl2ZXJlZCxcbiAgICAgICAgICByYXRpbzogZGVsaXZlcmVkVmFsaWRhdGlvbi5yYXRpbyxcbiAgICAgICAgICBmYWN0b3JzVXNlZDogZGVsaXZlcmVkVmFsaWRhdGlvbi5mYWN0b3JzVXNlZCxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIENoYXJ0IGlucHV0cyBmb3IgcG93ZXIgYnVpbGRvdXQgY29uc3RyYWludHMgKHJlcGxhY2VzIGVuZXJneUNvc3RDb21wYXJpc29uKVxuICAgICAgY2hhcnRJbnB1dHM6IHtcbiAgICAgICAgcG93ZXJCdWlsZG91dDoge1xuICAgICAgICAgIGRlbWFuZEd3OiAoJ2J1aWxkb3V0RGVidWcnIGluIGdyb3VuZFJlc3VsdCA/IGdyb3VuZFJlc3VsdC5idWlsZG91dERlYnVnPy5kZW1hbmRHVyA6IHVuZGVmaW5lZCkgPz8gXG4gICAgICAgICAgICAgICAgICAgICgnc3VwcGx5TWV0cmljcycgaW4gZ3JvdW5kUmVzdWx0ID8gZ3JvdW5kUmVzdWx0LnN1cHBseU1ldHJpY3M/LmRlbWFuZEd3IDogdW5kZWZpbmVkKSA/PyAwLFxuICAgICAgICAgIHN1cHBseUd3OiAoJ3N1cHBseU1ldHJpY3MnIGluIGdyb3VuZFJlc3VsdCA/IGdyb3VuZFJlc3VsdC5zdXBwbHlNZXRyaWNzPy5jYXBhY2l0eUd3IDogdW5kZWZpbmVkKSA/PyAwLFxuICAgICAgICAgIG1heEJ1aWxkUmF0ZUd3WWVhcjogKCdzdXBwbHlNZXRyaWNzJyBpbiBncm91bmRSZXN1bHQgPyBncm91bmRSZXN1bHQuc3VwcGx5TWV0cmljcz8ubWF4QnVpbGRSYXRlR3dZZWFyIDogdW5kZWZpbmVkKSA/PyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgnYnVpbGRvdXREZWJ1ZycgaW4gZ3JvdW5kUmVzdWx0ID8gZ3JvdW5kUmVzdWx0LmJ1aWxkb3V0RGVidWc/LmJ1aWxkUmF0ZUdXeXIgOiB1bmRlZmluZWQpID8/IDAsXG4gICAgICAgICAgcGlwZWxpbmVHdzogKCdzdXBwbHlNZXRyaWNzJyBpbiBncm91bmRSZXN1bHQgPyBncm91bmRSZXN1bHQuc3VwcGx5TWV0cmljcz8ucGlwZWxpbmVHdyA6IHVuZGVmaW5lZCkgPz8gMCxcbiAgICAgICAgICBiYWNrbG9nR3c6ICgnYmFja2xvZ0d3JyBpbiBncm91bmRSZXN1bHQgPyBncm91bmRSZXN1bHQuYmFja2xvZ0d3IDogdW5kZWZpbmVkKSA/PyBcbiAgICAgICAgICAgICAgICAgICAgICgnYnVpbGRvdXREZWJ1ZycgaW4gZ3JvdW5kUmVzdWx0ID8gZ3JvdW5kUmVzdWx0LmJ1aWxkb3V0RGVidWc/LmJhY2tsb2dHVyA6IHVuZGVmaW5lZCkgPz8gMCxcbiAgICAgICAgICBhdmdXYWl0WWVhcnM6ICgnYXZnV2FpdFllYXJzJyBpbiBncm91bmRSZXN1bHQgPyBncm91bmRSZXN1bHQuYXZnV2FpdFllYXJzIDogdW5kZWZpbmVkKSA/PyBcbiAgICAgICAgICAgICAgICAgICAgICAgICgnYnVpbGRvdXREZWJ1ZycgaW4gZ3JvdW5kUmVzdWx0ID8gZ3JvdW5kUmVzdWx0LmJ1aWxkb3V0RGVidWc/LnRpbWVUb1Bvd2VyWWVhcnMgOiB1bmRlZmluZWQpID8/IDAsXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuIl0sIm5hbWVzIjpbImNhbGN1bGF0ZUNvbmdlc3Rpb24iLCJjb21wdXRlRWRnZUluZmVyZW5jZUNvc3RzIiwiY29tcHV0ZVNhdGVsbGl0ZUh5YnJpZENvc3QiLCJERUZBVUxUX0NPTkZJRyIsIlBIWVNJQ1NfQ09OU1RBTlRTIiwiREVGQVVMVF9GVVNJT05fUEFSQU1TIiwiREVGQVVMVF9QT1dFUl9TQ0FMSU5HIiwiY2FsY3VsYXRlU2NhbGVkTWFzcyIsImNhbGN1bGF0ZVJlZ2lvbmFsR3JvdW5kQ29zdCIsImdldEdsb2JhbERlbWFuZFBmbG9wcyIsImdlbmVyYXRlR3JvdW5kU3VwcGx5VHJhamVjdG9yeSIsImdldEdsb2JhbERlbWFuZEd3IiwiY2FsY3VsYXRlR3JvdW5kQ29uc3RyYWludFBlbmFsdGllcyIsImNhbGN1bGF0ZVNjYXJjaXR5UmVudCIsImNhbGN1bGF0ZUJ1aWxkb3V0Q29uc3RyYWludHMiLCJzdGVwTW9iaWxpemF0aW9uU3RhdGUiLCJERUZBVUxUX01PQklMSVpBVElPTl9QQVJBTVMiLCJDb21wdXRlRWZmaWNpZW5jeSIsImdldERlZmF1bHRDb21wdXRlRWZmaWNpZW5jeSIsImFzc2VydENvc3RBY2NvdW50aW5nIiwidmFsaWRhdGVHZmxvcHNQZXJXYXR0IiwiZGVzaWduQ29uc3RlbGxhdGlvbiIsIlNBVEVMTElURV9DT05TVFJBSU5UUyIsIkNPTlNUQU5UUyIsIkhPVVJTX1BFUl9ZRUFSIiwiR1JPVU5EX0hBUkRXQVJFX0NPU1RfUEZMT1BfMjAyNSIsIkdST1VORF9IQVJEV0FSRV9MSUZFVElNRSIsIk1JTl9ERUxJVkVSRURfR0ZMT1BTX1BFUl9XIiwiREVGQVVMVF9TTVJfUEFSQU1TIiwiZW5hYmxlZCIsInNtckRlcGxveW1lbnRTdGFydFllYXIiLCJzbXJSYW1wVXBZZWFycyIsImVsZWN0cmljaXR5Q29zdFdpdGhTTVIiLCJncmlkQ29uc3RyYWludFJlbGllZiIsImNvb2xpbmdDb25zdHJhaW50UmVsaWVmIiwid2F0ZXJDb25zdHJhaW50UmVsaWVmIiwibGFuZENvbnN0cmFpbnRSZWxpZWYiLCJzbXJDYXBleFByZW1pdW0iLCJHUk9VTkRfU0NFTkFSSU9TIiwidW5jb25zdHJhaW5lZCIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsImNvbnN0cmFpbnRDYXAiLCJncmlkR3Jvd3RoUmF0ZSIsImNvb2xpbmdHcm93dGhSYXRlIiwid2F0ZXJHcm93dGhSYXRlIiwibGFuZEdyb3d0aFJhdGUiLCJtb2RlcmF0ZSIsImNvbnN0cmFpbmVkIiwic2V2ZXJlIiwiY2FsY3VsYXRlR3JvdW5kQ29uc3RyYWludCIsInllYXIiLCJzY2VuYXJpb0tleSIsIm11bHRpcGxpZXIiLCJicmVha2Rvd24iLCJncmlkIiwiY29vbGluZyIsIndhdGVyIiwibGFuZCIsInNjZW5hcmlvIiwieWVhcnNGcm9tQmFzZSIsIk1hdGgiLCJtYXgiLCJwb3ciLCJtaW4iLCJ2YWxpZGF0ZUNvbXB1dGVFZmZpY2llbmN5IiwiZ2Zsb3BzUGVyV2F0dCIsImxldmVsIiwicmFuZ2VzIiwiY2hpcCIsInN5c3RlbSIsImRhdGFjZW50ZXIiLCJyYW5nZSIsInZhbGlkIiwid2FybmluZyIsInRvRml4ZWQiLCJTTEFfVElFUlMiLCJhdmFpbGFiaWxpdHlUYXJnZXQiLCJtYXhMYXRlbmN5VG9Hcm91bmRNcyIsIm1pbkJhbmR3aWR0aEdicHMiLCJtYXhSZWNvdmVyeVRpbWVNaW51dGVzIiwiY3JlZGl0UGVyVmlvbGF0aW9uUGN0IiwiYXBwbHlTdGF0aWNGcmVlemUiLCJwYXJhbXMiLCJpc1N0YXRpY01vZGUiLCJsYXVuY2hDb3N0S2ciLCJzcGVjaWZpY1Bvd2VyV0tnIiwiZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1Iiwib3JiaXRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjUiLCJncm91bmRDb25zdHJhaW50c0VuYWJsZWQiLCJwb3dlckdyaWRNdWx0aXBsaWVyIiwiY29vbGluZ011bHRpcGxpZXIiLCJ3YXRlclNjYXJjaXR5RW5hYmxlZCIsImxhbmRTY2FyY2l0eUVuYWJsZWQiLCJkZXBsb3lhYmxlQXJlYTIwMjVNMiIsImRlcGxveWFibGVBcmVhMjA0ME0yIiwicHJldkxhdW5jaENvc3RDYWNoZSIsIk1hcCIsImdldExhdW5jaENvc3RQZXJLZyIsImJhc2UyMDI1Iiwic2V0IiwiQ09NTUVSQ0lBTF9NQVJLVVAiLCJJTlNVUkFOQ0VfUENUIiwiSU5URUdSQVRJT05fQ09TVF9QRVJfTEFVTkNIIiwiQVNTVU1FRF9QQVlMT0FEX0tHIiwiaW50ZXJuYWxCYXNlMjAyNSIsIm5vcm1hbGl6ZWRCYXNlIiwiaW50ZXJuYWxXYXlwb2ludHMiLCJpbnRlcm5hbENvc3RQZXJLZyIsImkiLCJsZW5ndGgiLCJ5MSIsImMxIiwieTIiLCJjMiIsInQiLCJ3aXRoTWFya3VwIiwid2l0aEluc3VyYW5jZSIsImludGVncmF0aW9uUGVyS2ciLCJjb21tZXJjaWFsQ29zdFBlcktnIiwicmVzdWx0IiwicHJldlllYXIiLCJwcmV2Q29zdCIsImdldCIsInVuZGVmaW5lZCIsImNhbGN1bGF0ZVRva2VuUHJpY2luZyIsImNvc3RQZXJQZmxvcFllYXIiLCJtb2RlbENvbmZpZyIsImJhc2VGTE9QUyIsInByZWNpc2lvbk11bHRpcGxpZXIiLCJwcmVjaXNpb24iLCJmbG9wc1BlclRva2VuIiwic2Vjb25kc1BlclllYXIiLCJmbG9wc1BlclBmbG9wWWVhciIsInRva2Vuc1BlclBmbG9wWWVhciIsImNvc3RQZXJUb2tlbiIsIm1vZGVsUGFyYW1zIiwiY29zdFBlcjFrVG9rZW5zIiwiY29zdFBlcjFtVG9rZW5zIiwiY2FsY3VsYXRlR3B1SG91clByaWNpbmciLCJjb3N0QnJlYWtkb3duIiwiaG91cnNQZXJZZWFyIiwiY29zdFBlckdwdVllYXIiLCJwZmxvcHNQZXJHcHUiLCJlZmZlY3RpdmVIb3VycyIsInV0aWxpemF0aW9uVGFyZ2V0IiwiYmFzZVBlckhvdXIiLCJwcm9jZXNzIiwiY29uc29sZSIsImVycm9yIiwiY2xhbXBlZENvc3RQZXJQZmxvcFllYXIiLCJjbGFtcGVkQ29zdFBlckdwdVllYXIiLCJjbGFtcGVkQmFzZVBlckhvdXIiLCJFcnJvciIsInBvd2VyUGVySG91ciIsImNvb2xpbmdQZXJIb3VyIiwiaW50ZXJjb25uZWN0UGVySG91ciIsIm9wc1BlckhvdXIiLCJjb21wdXRlUGVySG91ciIsInRvdGFsQmFzZSIsInBvd2VyIiwidGhlcm1hbCIsImludGVyY29ubmVjdCIsIm9wcyIsImNvbXB1dGUiLCJzY2FsZSIsIm5pbmVzIiwibG9nMTAiLCJzbGEiLCJzcGFyZXNSYXRpbyIsInNwYXJlc1BlckhvdXIiLCJ2aW9sYXRpb25Qcm9iIiwiZXhwZWN0ZWRDcmVkaXRQZXJIb3VyIiwic2xhUmlza0J1ZmZlciIsInRvdGFsQ29zdFBlckhvdXIiLCJtYXJnaW4iLCJvcGVyYXRvck1hcmdpblBjdCIsInByaWNlUGVyR3B1SG91ciIsIk1BWF9SRUFTT05BQkxFX0dQVV9IT1VSX1BSSUNFIiwiTUlOX1JFQVNPTkFCTEVfR1BVX0hPVVJfUFJJQ0UiLCJncHVUeXBlIiwibG9jYXRpb24iLCJoYXJkd2FyZUFtb3J0aXphdGlvbiIsIm9wZXJhdGlvbnMiLCJzcGFyZXMiLCJlZmZlY3RpdmVVdGlsaXphdGlvbiIsIk1PREVMX1VOSVRTIiwicGZsb3BEZWZpbml0aW9uIiwic3VzdGFpbmVkVnNQZWFrIiwiZ2Zsb3BzUGVyV2F0dExldmVsIiwiaW5jbHVkZXNOZXR3b3JraW5nT3ZlcmhlYWQiLCJhc3NlcnRDb21wdXRlUG93ZXJDb25zaXN0ZW5jeSIsImNvbXB1dGVQb3dlckt3IiwiZWZmZWN0aXZlUGZsb3BzIiwidW5pdHMiLCJleHBlY3RlZEt3IiwiZGlzY3JlcGFuY3kiLCJyYXRpbyIsIkJBU0VfU0lURV8yMDI1IiwiY2FsY3VsYXRlR3JvdW5kVG90YWwiLCJlbmVyZ3lDb3N0QmFzZSIsImhhcmR3YXJlQ29zdEJhc2UiLCJlZmZlY3RpdmVTY2VuYXJpbyIsImxhdGVuY3lQZW5hbHR5Iiwic21yUGFyYW1zIiwiZmlyc3RDYXBZZWFyIiwiYWN0dWFsRW5lcmd5Q29zdFBlclBmbG9wWWVhciIsImFjdHVhbEVsZWN0cmljaXR5UHJpY2VQZXJNd2giLCJzaXRlQ29zdEJhc2UiLCJzbXJFbmFibGVkIiwic21yUmFtcEZhY3RvciIsImNvbnN0cmFpbnRSZWxpZWYiLCJ5ZWFyc0FjdGl2ZSIsImVuZXJneUNvc3QiLCJlZmZlY3RpdmVFbGVjdHJpY2l0eVByaWNlIiwidG90YWwiLCJzaXRlQ29zdCIsImhhcmR3YXJlQ29zdCIsImNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtIiwidGltZVRvRW5lcmdpemVQZW5hbHR5IiwidG90YWxDb3N0UGVyUGZsb3BZZWFyIiwiY29uc3RyYWludE11bHRpcGxpZXIiLCJlbmVyZ3lNdWx0aXBsaWVyIiwic2l0ZU11bHRpcGxpZXIiLCJjYXBhY2l0eURlbGl2ZXJ5TXVsdGlwbGllciIsImVmZmVjdGl2ZUVsZWN0cmljaXR5Q29zdCIsInNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyIiwiY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXIiLCJ0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIiLCJzaXRlQ29zdFBlclBmbG9wWWVhcl9iYXNlIiwic2l0ZUNvc3RQZXJQZmxvcFllYXJfZWZmZWN0aXZlIiwic2l0ZUNvc3RDaGVjayIsImFicyIsImhhcmR3YXJlIiwidG90YWxFZmZlY3RpdmUiLCJ0b3RhbENvc3RQZXJQZmxvcFllYXJFZmZlY3RpdmUiLCJjb25zdHJhaW50cyIsIm1ldGhvZCIsImRlbGF5UGVuYWx0eSIsImFwcGxpZWRNdWx0aXBsaWVycyIsImNvbnN0cmFpbnRNdWx0aXBsaWVyVXNlZCIsImVuZXJneU11bHRpcGxpZXJVc2VkIiwic2l0ZU11bHRpcGxpZXJVc2VkIiwiZGVidWciLCJkb3VibGVDb3VudENoZWNrIiwibW9kZSIsIm11bHRpcGxpZXJBcHBsaWVkIiwiYWRkZXJzQXBwbGllZCIsImludmFyaWFudE9rIiwibm90ZXMiLCJjb21wdXRlUGh5c2ljc0Nvc3QiLCJyYXdQYXJhbXMiLCJoeWJyaWRSZXN1bHQiLCJncm91bmRSZXN1bHQiLCJiYXNlTGF1bmNoQ29zdCIsInRyYWpTcGVjaWZpY1Bvd2VyIiwicmF3R3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1IiwicmF3T3JiaXRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjUiLCJwdWVHcm91bmQiLCJwdWVPcmJpdGFsIiwiY2FwYWNpdHlGYWN0b3JHcm91bmQiLCJ0YXJnZXRHVyIsInNhdGVsbGl0ZVBvd2VyS1ciLCJzcGFjZVRyYWZmaWNFbmFibGVkIiwib3JiaXRhbEFsdGl0dWRlIiwidXNlUmFkSGFyZENoaXBzIiwic3VuRnJhY3Rpb24iLCJncm91bmRTY2VuYXJpbyIsInNtck1pdGlnYXRpb25FbmFibGVkIiwid29ya2xvYWRUeXBlIiwiZWxvblNjZW5hcmlvRW5hYmxlZCIsImdsb2JhbExhdGVuY3lSZXF1aXJlbWVudEVuYWJsZWQiLCJzcGFjZU1hbnVmYWN0dXJpbmdFbmFibGVkIiwiYWlXaW50ZXJFbmFibGVkIiwiYWN0dWFsR3JvdW5kSW5wdXQiLCJnZmxvcHNQZXJXYXR0R3JvdW5kMjAyNSIsImZsb3BzUGVyV2F0dEdyb3VuZCIsImFjdHVhbE9yYml0SW5wdXQiLCJnZmxvcHNQZXJXYXR0T3JiaXRhbDIwMjUiLCJmbG9wc1BlcldhdHRPcmJpdGFsIiwiZ3JvdW5kRWZmaWNpZW5jeVJlc3VsdCIsIm9yYml0YWxFZmZpY2llbmN5UmVzdWx0IiwiaXNGaW5pdGUiLCJzeXN0ZW1PdmVyaGVhZEZhY3RvciIsInV0aWxpemF0aW9uRmFjdG9yIiwiY2hpcFBlYWtHZmxvcHNQZXJXIiwiZWZmZWN0aXZlR2Zsb3BzUGVyVyIsIkpTT04iLCJzdHJpbmdpZnkiLCJncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXIiwib3JiaXRQZWFrR2Zsb3BzUGVyV2F0dCIsIm9yYml0U3lzdGVtRWZmZWN0aXZlR2Zsb3BzUGVyV2F0dCIsImVmZmVjdGl2ZUdyb3VuZFNjZW5hcmlvIiwibGF1bmNoRGlzY291bnQiLCJwb3dlckRpc2NvdW50IiwibmV0d29ya2luZ0Rpc2NvdW50Iiwib3BlcmF0b3JNYXJnaW4iLCJncm91bmRMYXRlbmN5UGVuYWx0eSIsIm1hc3NNdWx0aXBsaWVyIiwieWVhcnNTaW5jZVN0YXJ0IiwicmFtcCIsIkJBU0VfRU5FUkdZXzIwMjUiLCJFTkVSR1lfQ09TVF9CQVNFXzIwMjUiLCJCQVNFX0VMRUNUUklDSVRZX1BSSUNFXzIwMjUiLCJncm91bmRFbGVjdHJpY2l0eVByaWNlUGVyTXdoIiwiZWZmZWN0aXZlUHVlR3JvdW5kIiwiZ3JvdW5kRW5lcmd5TVdoUGVyUGZsb3BZZWFyIiwiZ3JvdW5kRW5lcmd5Q29zdFBlclBmbG9wWWVhciIsImNvbXB1dGVHcm91bmRIYXJkd2FyZUNvc3QiLCJ5IiwiYmFzZUNvc3QiLCJ5ZWFySW5kZXgiLCJjb3N0IiwiYW5udWFsRGVjbGluZSIsImdyb3VuZExpZmV0aW1lIiwiZ3JvdW5kSGFyZHdhcmVMaWZldGltZVllYXJzIiwiZ3JvdW5kSGFyZHdhcmVDYXBleFBlclBmbG9wWWVhciIsInNtclRvZ2dsZUVuYWJsZWQiLCJzbXJUb2dnbGVQYXJhbXMiLCJncm91bmRUb3RhbENvc3QiLCJncm91bmRDb21wYXJhdG9yQ29zdFBlclBmbG9wWWVhciIsImdyb3VuZEhhc1F1ZXVlIiwiZW5lcmd5Q29uc3RyYWludE11bHRpcGxpZXIiLCJjb25zdHJhaW50QnJlYWtkb3duIiwidXNlUmVnaW9uYWxNb2RlbCIsInVzZVJlZ2lvbmFsR3JvdW5kTW9kZWwiLCJ1c2VRdWV1ZU1vZGVsIiwidXNlUXVldWVCYXNlZENvbnN0cmFpbnQiLCJ1c2VCdWlsZG91dE1vZGVsIiwid2FybiIsInJlc3BvbnNpdmVEZW1hbmRHVyIsIm9yYml0YWxTdWJzdGl0dXRpb25HVyIsImRlbWFuZEJ5WWVhciIsIm9yYml0YWxTdWJzdGl0dXRpb25CeVllYXIiLCJzdXBwbHlUcmFqZWN0b3J5IiwiY3VycmVudFN1cHBseVN0YXRlIiwiaGFyZGNvZGVkRGVtYW5kIiwiZGVtYW5kR3ciLCJsb2ciLCJ3YWNjUGFyYW1zIiwiYmFzZVdhY2MiLCJ3YWNjIiwid2FjY0JhY2tsb2dLIiwid2FjY0JhY2tsb2dFeHBvbmVudCIsImNyaXRpY2FsQmFja2xvZ0dXIiwicGVuYWx0aWVzIiwiY2FwZXhBbm51YWxCYXNlUGVyUGZsb3BZZWFyIiwic2NhcmNpdHlSZW50UmVzdWx0IiwiYXZnV2FpdFllYXJzIiwidXRpbGl6YXRpb25QY3QiLCJ3YWl0VGhyZXNob2xkWWVhcnMiLCJyZW50TWF4TXVsdGlwbGllciIsInV0aWxpemF0aW9uVGhyZXNob2xkIiwic2NhcmNpdHlNdWx0aXBsaWVyIiwic2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyIiwidW5zZXJ2ZWRHdyIsImNhcGFjaXR5R3ciLCJiYWNrbG9nR3ciLCJleHBlY3RlZEVmZmVjdGl2ZSIsInRvdGFsQ29zdFBlclBmbG9wWWVhckFsbEluIiwic2NhcmNpdHlIaWxsIiwiYXZnV2FpdFllYXJzUmF3IiwiYXZnV2FpdFllYXJzQ2xhbXBlZCIsInJlbnRGcmFjIiwiZGVsaXZlcmVkRnJvbUJhY2tsb2dHdyIsImJhc2VDb3N0UGVyUGZsb3BZZWFyIiwic3VwcGx5TWV0cmljcyIsInBpcGVsaW5lR3ciLCJtYXhCdWlsZFJhdGVHd1llYXIiLCJjb25zdHJhaW50Q29tcG9uZW50cyIsInF1ZXVlUHJlc3N1cmUiLCJ1dGlsaXphdGlvblByZXNzdXJlIiwic2NhcmNpdHlQcmVtaXVtIiwiY2FwZXhBdFJpc2tQZXJNVyIsImNhcnJ5Q29zdFBlck1XIiwibG9zdE1hcmdpblBlck1XIiwicHVlTXVsdGlwbGllciIsIm1vYmlsaXphdGlvblBhcmFtcyIsImRlbWFuZEN1cnZlIiwicHJldk1vYmlsaXphdGlvblN0YXRlIiwibW9iaWxpemF0aW9uUmVzdWx0IiwiZGVtYW5kTmV3R1ciLCJidWlsZFJhdGVHV3lyIiwiYnVpbGRhYmxlR1ciLCJjYXBhY2l0eUdXIiwicGlwZWxpbmVHVyIsImJhY2tsb2dHVyIsIlBST0pFQ1RfTElGRVRJTUUiLCJCVUlMRE9VVF9DQVBFWF9CQVNFIiwiREVGQVVMVF9TQ0FSQ0lUWV9DVVJWRSIsImsiLCJleHBvbmVudCIsInRocmVzaG9sZFV0aWwiLCJQQU5JQ19FWFBPTkVOVCIsImJhY2tsb2dSYXRpbyIsIndhY2NNdWx0aXBsaWVyIiwid2FjY0VmZmVjdGl2ZSIsImJ1aWxkb3V0UGFyYW1zIiwiZGVtYW5kTmV3R1dCeVllYXIiLCJidWlsZGFibGVHV0J5WWVhciIsImJhc2VFbmVyZ3lQcmljZVBlck13aEJ5WWVhciIsInB1ZUdyb3VuZEJ5WWVhciIsInByb2plY3RMaWZldGltZVllYXJzIiwiYnVpbGRvdXRQcm9qZWN0TGlmZXRpbWVZZWFycyIsInZhbHVlT2ZUaW1lTW9kZSIsImJ1aWxkb3V0Q2FwZXhCYXNlXyRQZXJrVyIsImJ1aWxkb3V0Q2FwZXhTY2FyY2l0eUN1cnZlIiwicGFuaWNFeHBvbmVudCIsImJ1aWxkb3V0UGFuaWNFeHBvbmVudCIsImhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXIiLCJjb21wdXRlSGFyZHdhcmVDYXBleCIsInNpdGVDYXBleCIsIm1hcmdpblBlckdwdUhvdXIiLCJhbm51YWxHcHVIb3Vyc0RlbGl2ZXJlZCIsImh5YnJpZFdlaWdodHMiLCJidWlsZG91dEh5YnJpZFdlaWdodHMiLCJ3YWNjV2VpZ2h0IiwibWFyZ2luV2VpZ2h0IiwiYnVpbGRvdXRSZXN1bHQiLCJidWlsZG91dFByZW1pdW1QZXJQZmxvcFllYXIiLCJkZWxheVBlbmFsdHlQZXJQZmxvcFllYXIiLCJzY2FyY2l0eVJlbnRXYWl0VGhyZXNob2xkWWVhcnMiLCJzY2FyY2l0eVJlbnRNYXhNdWx0aXBsaWVyIiwicmVwbGFjZW1lbnRDb3N0UGVyUGZsb3BZZWFyIiwic3BhcmVzQ2FycnlDb3N0UGVyUGZsb3BZZWFyIiwiZ3JvdW5kT3BzQ29zdFBlclBmbG9wWWVhciIsImhhcmR3YXJlQ29zdFdpdGhSZXBsYWNlbWVudCIsImdyb3VuZFRvdGFsQ29zdF9iYXNlIiwiZ3JvdW5kVG90YWxDb3N0X2VmZmVjdGl2ZSIsImJ1aWxkb3V0RGVidWciLCJyZXBsYWNlbWVudENvc3QiLCJzcGFyZXNDYXJyeUNvc3QiLCJvcHNDb3N0IiwidG90YWxDb3N0UGVyUGZsb3BZZWFyQmFzZSIsInByaWNpbmdDb21wb25lbnRzIiwiZGVsYXlQZW5hbHR5V2VpZ2h0ZWQiLCJwcmljaW5nTW9kZSIsImdyb3VuZENvbnN0cmFpbnRQcmljaW5nTW9kZSIsImRlbGF5UGVuYWx0eVdlaWdodCIsImdyb3VuZERlbGF5UGVuYWx0eVdlaWdodCIsIndhaXRFZmZZZWFycyIsImRlbWFuZEdXIiwic2NhcmNpdHlJbmRleCIsImZhY3RvcnMiLCJidWlsZG91dENhcGV4XyRQZXJrVyIsImFubnVhbGl6ZWRCdWlsZG91dFByZW1pdW1fJFBlcmtXeXIiLCJ0aW1lVG9Qb3dlclllYXJzIiwidmFsdWVPZlRpbWVfJFBlclllYXIiLCJkZWxheVBlbmFsdHlfJFBlclllYXIiLCJkZW1hbmRHcm93dGhSYXRlIiwid2FjY0Jhc2UiLCJ3YWl0WWVhcnNVc2VkIiwiaGFzTXVsdGlwbGllciIsImhhc0FkZGVyIiwicmVnaW9uYWxSZXN1bHQiLCJkZW1hbmRQZmxvcHMiLCJlbmVyZ3lDb3N0UGVyUGZsb3BZZWFyIiwic2l0ZUNvc3RQZXJQZmxvcFllYXIiLCJhdmVyYWdlRW5lcmd5Q29zdE13aCIsImdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nIiwiaGFzUHJlbWl1bSIsImxhdW5jaENvc3RQZXJLZyIsImxpZmV0aW1lWWVhcnMiLCJmdXNpb25QYXJhbXMiLCJmdXNpb25Ub2dnbGVFbmFibGVkIiwiZnVzaW9uVG9nZ2xlUGFyYW1zIiwidGFyZ2V0Q29tcHV0ZUt3IiwiY29uc3RlbGxhdGlvbiIsImNvbXB1dGVQb3dlclBlclNhdEt3IiwiY29tcHV0ZVBlclNhdEt3IiwiYWx0aXR1ZGVLbSIsInVzZUNvcnJlY3RlZFNwZWNpZmljUG93ZXIiLCJ1c2VDb3JyZWN0ZWRUaGVybWFsIiwidGhlcm1hbENhcEZhY3RvciIsInRoZXJtYWxTeXN0ZW0iLCJyYWRpYXRpb25EZXJhdGUiLCJkZWdyYWRhdGlvbkZhY3RvciIsImF2YWlsYWJpbGl0eSIsImNhcGFjaXR5RmFjdG9yIiwib3JiaXREZWxpdmVyZWRHZmxvcHNQZXJXYXR0Iiwib3JpZ2luYWxEZWxpdmVyZWQiLCJvcmJpdEVmZmVjdGl2ZUdmbG9wc1BlclciLCJwb3dlclNjYWxpbmdQYXJhbXMiLCJzY2FsaW5nUmVzdWx0IiwibWFzc1BlclNhdEtnIiwidG90YWxNYXNzS2ciLCJNQVhfU0FURUxMSVRFX01BU1NfS0ciLCJtYXhNYXNzS2ciLCJtYXNzUGVyS3ciLCJtYXhDb21wdXRlUGVyU2F0S3ciLCJhZGp1c3RlZENvbnN0ZWxsYXRpb24iLCJtYXhDb21wdXRlS3ciLCJhZGp1c3RlZEh5YnJpZFJlc3VsdCIsImFkanVzdGVkTWFzc1BlclNhdEtnIiwiYWRqdXN0ZWRUaGVybWFsQ2FwRmFjdG9yIiwiYWRqdXN0ZWRSYWRpYXRpb25EZXJhdGUiLCJhZGp1c3RlZEF2YWlsYWJpbGl0eSIsImFkanVzdGVkRGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCIsImNvbnN0ZWxsYXRpb25NdWx0aXBsaWVyIiwibnVtU2F0ZWxsaXRlcyIsImNvbnN0ZWxsYXRpb25PdmVyaGVhZE11bHRpcGxpZXIiLCJjb25zdGVsbGF0aW9uT3ZlcmhlYWQiLCJlZmZlY3RpdmVUb3RhbE1hc3NLZyIsImVmZmVjdGl2ZVRvdGFsTGF1bmNoQ29zdCIsImVmZmVjdGl2ZVBvd2VyRmFiQ29zdCIsInBvd2VyU3lzdGVtIiwiZmFiQ29zdFVzZCIsImVmZmVjdGl2ZU5ldHdvcmtpbmdGYWJDb3N0IiwibmV0d29ya2luZyIsImVmZmVjdGl2ZU5ldHdvcmtpbmdPcEV4IiwiYW5udWFsT3BFeFVzZCIsImVmZmVjdGl2ZVBmbG9wc1BlclNhdCIsInRvdGFsRWZmZWN0aXZlUGZsb3BzIiwibGF1bmNoQ29zdFBlclBmbG9wWWVhciIsImNvbnN0ZWxsYXRpb25Db3N0TXVsdGlwbGllciIsInBvd2VyQ29zdCIsImNvbXB1dGVDb3N0IiwiY29tcHV0ZVBheWxvYWQiLCJjaGlwQ29zdFVzZCIsInF1YWxpZmljYXRpb25Db3N0VXNkIiwidGhlcm1hbENvc3QiLCJyYWRpYXRpb25Db3N0IiwicmFkaWF0aW9uUHJvdGVjdGlvbiIsImJ1c0Nvc3QiLCJidXMiLCJuZXR3b3JraW5nQ29zdCIsImludGVyY29ubmVjdENvc3QiLCJ0b3RhbEFubnVhbENvc3QiLCJyZWd1bGF0b3J5Q29zdCIsInJlZ3VsYXRvcnkiLCJhbm51YWxDb3N0VXNkIiwiYmFzZU9wc0Nvc3RQZXJTYXQiLCJvcHNQZXJQZmxvcFllYXIiLCJuZXR3b3JraW5nT3BzQ29zdFBlclNhdCIsImFkanVzdGVkTmV0d29ya2luZ09wc0Nvc3RQZXJTYXQiLCJvcHNDb3N0UGVyU2F0Iiwib3BzQ29zdE11bHRpcGxpZXIiLCJvcmJpdGFsQnJlYWtkb3duIiwicmFkaWF0aW9uIiwiY29uZ2VzdGlvbiIsImxhdW5jaCIsInRvdGFsU2F0ZWxsaXRlQ29zdCIsInNhdGVsbGl0ZUNvdW50IiwiY29uZ2VzdGlvbkNvc3RQZXJQZmxvcFllYXIiLCJvcmJpdGFsQ29tcG9uZW50cyIsInZhbHVlIiwiYnJlYWtkb3duU3VtIiwiT2JqZWN0IiwidmFsdWVzIiwicmVkdWNlIiwiYSIsImIiLCJyZWFsaXN0aWNDb3N0UGVyUGZsb3AiLCJhcHBsaWVkVG8iLCJvcmJpdGFsQWNjb3VudGluZyIsImNvc3RBY2NvdW50aW5nVmFsaWQiLCJjb3N0QWNjb3VudGluZ0Vycm9yUGN0IiwiZXJyb3JQY3QiLCJhbm51YWxHcHVIb3Vyc1BlclBGTE9QIiwiZGVsYXlQZW5hbHR5QWRkZXJQZXJHcHVIb3VyIiwiZ3JvdW5kQ29zdEJhc2VGb3JQcmljaW5nIiwiZ3JvdW5kR3B1SG91ciIsImJhc2VQcmljaW5nIiwic2l0ZSIsInByZU1hcmdpbkJhc2UiLCJTQ0FSQ0lUWV9SRUZFUkVOQ0VfQkFTRSIsImNvc3RXaXRoU2NhcmNpdHkiLCJjb3N0V2l0aFNjYXJjaXR5QW5kRGVsYXkiLCJzY2FyY2l0eSIsIm9yYml0YWxHcHVIb3VyIiwiZ3JvdW5kVG9rZW5zIiwibGxhbWE3MEIiLCJsbGFtYTQwNUIiLCJvcmJpdGFsVG9rZW5zIiwiZWRnZUluZmVyZW5jZSIsImdwdUhvdXJDcm9zc292ZXIiLCJzdGFuZGFyZCIsImdyb3VuZEVmZmVjdGl2ZSIsImdyb3VuZEhlYWRsaW5lIiwiZWZmZWN0aXZlRXJyb3IiLCJleHBlY3RlZERlbGl2ZXJlZCIsIlRPTEVSQU5DRSIsInJhdGlvRXJyb3IiLCJpc1JhdGlvVmFsaWQiLCJFU0NBTEFURV9USFJFU0hPTEQiLCJpc0ludmFsaWQiLCJkZWxpdmVyZWRWc1N5c3RlbUVycm9yIiwiZGVsaXZlcmVkVmFsaWRhdGlvbiIsImRlbGl2ZXJlZCIsImZhY3RvcnNVc2VkIiwidXRpbGl6YXRpb24iLCJpbnZhbGlkIiwiZWZmaWNpZW5jeVZhbGlkYXRpb24iLCJlZmZpY2llbmN5TGV2ZWwiLCJjb25zaXN0ZW5jeUNoZWNrIiwic2FuaXR5UGFuZWwiLCJncm91bmQiLCJzaXRlQ2FwZXhBbW9ydCIsImNhcGFjaXR5UHJlbWl1bSIsIm9yYml0Iiwic3BlY2lmaWNQb3dlck11bHRpcGxpZXJzIiwicmVxdWlyZWRBcmVhTTIiLCJxUGVyTTJfVyIsIndhc3RlSGVhdFciLCJ3YXN0ZUhlYXRLdyIsInBoeXNpY2FsQXJlYU0yIiwiYXJlYUF2YWlsYWJsZU0yIiwiYWxsSW52YXJpYW50c1Bhc3NlZCIsInRoZXJtYWxBcmVhQ2hlY2siLCJzcGVjaWZpY1Bvd2VyQ2hlY2siLCJlZmZlY3RpdmUiLCJiYXNlU3BlY2lmaWNQb3dlciIsInRoZXJtYWxDYXBDaGVjayIsImVsZWN0cmljaXR5UHJpY2VQZXJNd2giLCJwdWUiLCJjb21wdXRlRGVmaW5pdGlvbiIsInBlYWsiLCJjaGlwTmFtZSIsInBlYWtHZmxvcHNQZXJXYXR0IiwiZWZmZWN0aXZlR2Zsb3BzUGVyV2F0dCIsImdwdUhvdXJQcmljaW5nIiwiYmFzaWMiLCJwcmVtaXVtIiwidG9rZW5QcmljaW5nIiwibGNvZVBlck13aCIsInRvdGFsQ29zdFVzZCIsImNhcGFjaXR5RmFjdG9yUHJvdmVuYW5jZSIsImNvbXB1dGVFZmZpY2llbmN5UHJvdmVuYW5jZSIsInNwZWNpZmljUG93ZXJXUGVyS2ciLCJzcGVjaWZpY1Bvd2VyX3N1YnN5c3RlbV9XUGVyS2ciLCJzcGVjaWZpY1Bvd2VyX2VmZmVjdGl2ZV9XUGVyS2ciLCJlZmZlY3RpdmVTcGVjaWZpY1Bvd2VyIiwiaGFyZHdhcmVDb3N0UGVyUGZsb3BZZWFyIiwicmFkaWF0aW9uTXVsdGlwbGllciIsInRoZXJtYWxDYXBwZWQiLCJtYXhSZWplY3RhYmxlS3ciLCJjb2xsaXNpb25SaXNrIiwiYm9keU1vdW50ZWRBcmVhTTIiLCJkZXBsb3lhYmxlQXJlYU0yIiwidG90YWxSYWRpYXRvckFyZWFNMiIsInJhZGlhdG9yQ29zdFBlclBmbG9wWWVhciIsInJhZGlhdG9yTWFzc0tnIiwib3B0aW1pc3RpY0Nvc3RQZXJQZmxvcCIsInJhZGlhdGlvblNoaWVsZGluZ0Nvc3QiLCJ0aGVybWFsU3lzdGVtQ29zdCIsInJlcGxhY2VtZW50UmF0ZUNvc3QiLCJlY2NPdmVyaGVhZENvc3QiLCJyZWR1bmRhbmN5Q29zdCIsImh5YnJpZEJyZWFrZG93biIsInJhZGlhdGlvbkRlZ3JhZGF0aW9uIiwiYW5udWFsRmFpbHVyZVJhdGUiLCJlZmZlY3RpdmVDb21wdXRlUGVyY2VudCIsImVjY092ZXJoZWFkUGN0IiwiYXBwbGllZCIsInBvd2VyU3lzdGVtVHlwZSIsInNjYWxpbmdQZW5hbHR5IiwiZnVzaW9uRGV0YWlscyIsImRlc2lnbiIsInJhZGlhdG9yQXJlYVBlclNhdE0yIiwic2F0c1BlckxhdW5jaCIsImxhdW5jaGVzUmVxdWlyZWQiLCJzY2FsaW5nIiwic2NhbGluZ0VmZmljaWVuY3kiLCJ3YXJuaW5ncyIsImVmZmVjdGl2ZUNvbXB1dGVNdWx0aXBsaWVycyIsImNvc3RTaGFyZXMiLCJncm91bmRTZWdtZW50IiwibG9jYWxTZW5zaXRpdml0eSIsImRDb3N0X2RMYXVuY2giLCJkQ29zdF9kU3BlY2lmaWNQb3dlciIsImRDb3N0X2RHZmxvcHNQZXJXIiwiYmFzZUZhaWx1cmVSYXRlIiwiZENvc3RfZEZhaWx1cmVSYXRlIiwiZENvc3RfZFB1ZSIsImNyb3Nzb3ZlciIsImNyb3Nzb3ZlckRldGFpbHMiLCJ0b2tlbkNyb3Nzb3ZlciIsIm1hcmtldFBvc2l0aW9uIiwibWV0YWRhdGEiLCJncm91bmRVbml0cyIsIm1ldHJpYyIsInVuaXQiLCJvcmJpdFVuaXRzIiwiZ3B1RmFpbHVyZVJhdGVBbm51YWwiLCJ0b3RhbENvc3RFeGNsdWRlc0RlbGF5UGVuYWx0eSIsInRvdGFsQ29zdEVmZmVjdGl2ZUluY2x1ZGVzRGVsYXlQZW5hbHR5IiwiY29tcHV0ZUVmZmljaWVuY3kiLCJ2YWxpZGF0aW9uIiwiY2hhcnRJbnB1dHMiLCJwb3dlckJ1aWxkb3V0Iiwic3VwcGx5R3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/physicsCost.ts\n"));

/***/ })

});