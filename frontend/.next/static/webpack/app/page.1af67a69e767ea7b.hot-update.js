"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/model/ground_constraint_penalties.ts":
/*!******************************************************!*\
  !*** ./app/lib/model/ground_constraint_penalties.ts ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateGroundConstraintPenalties: function() { return /* binding */ calculateGroundConstraintPenalties; },\n/* harmony export */   calculateHillScarcityPremium: function() { return /* binding */ calculateHillScarcityPremium; },\n/* harmony export */   calculateScarcityRent: function() { return /* binding */ calculateScarcityRent; }\n/* harmony export */ });\n/**\n * Ground Constraint Penalties Model\n * \n * Calculates WACC-based penalties and multipliers from backlog/wait time:\n * - timeToEnergizePenaltyPerPflopYear: WACC carry + lost margin\n * - siteMultiplier: land + interconnect scarcity\n * - pueMultiplier: cooling/water stress\n */ /**\n * Hill function: saturating sigmoid-like curve\n * @param x Input value\n * @param x50 Half-saturation point\n * @param n Hill coefficient (steepness)\n * @returns Value between 0 and 1\n */ function hill(x, x50, n) {\n    if (x <= 0) return 0;\n    const xn = Math.pow(x, n);\n    const x50n = Math.pow(x50, n);\n    return xn / (x50n + xn);\n}\n/**\n * Threshold Hill function: 0 until x exceeds x0, then Hill on the excess\n * @param x Input value\n * @param x0 Threshold (must exceed this before Hill activates)\n * @param x50 Half-saturation point for excess\n * @param n Hill coefficient\n * @returns Value between 0 and 1\n */ function thresholdHill(x, x0, x50, n) {\n    const excess = Math.max(0, x - x0);\n    return hill(excess, x50, n);\n}\n/**\n * Calculate saturating scarcity rent using Hill function (prevents exponential blow-up)\n * \n * @param waitYears Average wait time (years) - NO CLAMP applied\n * @param utilizationPct Utilization percentage (0-1) - optional threshold gate\n * @param waitThresholdYears Threshold for half-saturation (default 3.0)\n * @param rentMaxFracOfCapexAnnual Maximum rent as fraction of reference base (default 0.65)\n * @param rentShapeP Hill function shape parameter (default 2.0)\n * @returns Scarcity rent per PFLOP-year and debug fields\n */ function calculateScarcityRent(waitYears, utilizationPct, params) {\n    // THRESHOLD GATE: No scarcity rent until utilization > 85%\n    const UTIL_THRESHOLD = 0.85;\n    if (utilizationPct !== undefined && utilizationPct < UTIL_THRESHOLD) {\n        return {\n            scarcityRentPerPflopYear: 0,\n            rentFrac: 0,\n            waitEffYears: waitYears,\n            scarcityHill: {\n                h: 0,\n                rentFrac: 0\n            },\n            avgWaitYearsRaw: waitYears,\n            avgWaitYearsClamped: waitYears\n        };\n    }\n    // THRESHOLD GATE: No scarcity rent until wait > 1 year\n    if (waitYears < 1.0) {\n        return {\n            scarcityRentPerPflopYear: 0,\n            rentFrac: 0,\n            waitEffYears: waitYears,\n            scarcityHill: {\n                h: 0,\n                rentFrac: 0\n            },\n            avgWaitYearsRaw: waitYears,\n            avgWaitYearsClamped: waitYears\n        };\n    }\n    var _params_waitThresholdYears;\n    // Hill function parameters: w50=3.0, n=2.0, rentMax=0.65\n    const w50 = (_params_waitThresholdYears = params === null || params === void 0 ? void 0 : params.waitThresholdYears) !== null && _params_waitThresholdYears !== void 0 ? _params_waitThresholdYears : 3.0; // Half-saturation point (years) - increased from 2.0\n    var _params_rentShapeP;\n    const n = (_params_rentShapeP = params === null || params === void 0 ? void 0 : params.rentShapeP) !== null && _params_rentShapeP !== void 0 ? _params_rentShapeP : 2.0; // Hill coefficient\n    var _params_rentMaxFracOfCapexAnnual;\n    const rentMax = (_params_rentMaxFracOfCapexAnnual = params === null || params === void 0 ? void 0 : params.rentMaxFracOfCapexAnnual) !== null && _params_rentMaxFracOfCapexAnnual !== void 0 ? _params_rentMaxFracOfCapexAnnual : 0.65; // Max rent = 65% of reference base\n    // Store raw wait years for debug (NO CLAMP)\n    const avgWaitYearsRaw = waitYears;\n    const avgWaitYearsClamped = waitYears; // No clamp - preserves scarcity signal\n    // Hill function: h = (w/w50)^n / (1 + (w/w50)^n)\n    // This saturates at 1 as wait increases, preventing exponential growth\n    const w = avgWaitYearsClamped;\n    const x = w / w50;\n    const h = x > 0 ? Math.pow(x, n) / (1 + Math.pow(x, n)) : 0;\n    // Rent fraction: max fraction of reference base\n    const rentFrac = rentMax * h;\n    // FIX: Use fixed reference base that doesn't decline with tech (market clearing price)\n    // This ensures scarcity rent INCREASES with scarcity, not decreases\n    const SCARCITY_RENT_REFERENCE_BASE = 6500; // $/PFLOP-yr (fixed market clearing reference)\n    const scarcityRentPerPflopYear = rentFrac * SCARCITY_RENT_REFERENCE_BASE;\n    return {\n        scarcityRentPerPflopYear,\n        rentFrac,\n        waitEffYears: avgWaitYearsClamped,\n        scarcityHill: {\n            h,\n            rentFrac\n        },\n        avgWaitYearsRaw,\n        avgWaitYearsClamped\n    };\n}\n/**\n * Calculate ground constraint penalties from supply state\n * \n * @param state Current ground supply state\n * @param flopsPerWattGround GFLOPS/W for ground compute\n * @param pueGround PUE for ground datacenters\n * @param capacityFactorGround Capacity factor for ground\n * @param waccParams Optional WACC parameters for capital rationing\n * @returns Penalties and multipliers\n */ function calculateGroundConstraintPenalties(state, flopsPerWattGround, pueGround, capacityFactorGround, waccParams) {\n    const backlogGw = state.backlogGw; // Pipeline is not backlog. If backlog is missing, treat as 0 and let chartInputs/buildoutDebug supply the real number elsewhere.\n    const avgWaitYears = state.avgWaitYears;\n    const maxBuildRateGwYear = state.maxBuildRateGwYear;\n    const utilizationPct = state.utilizationPct;\n    // Convert GW to MW\n    const backlogMw = backlogGw * 1000;\n    // UNIT GUARD: Fix units mismatch (flopsPerWattGround might be TFLOPS/W instead of GFLOPS/W)\n    let gflopsPerWatt = flopsPerWattGround;\n    if (flopsPerWattGround < 50) {\n        // Likely TFLOPS/W (e.g., 2 TFLOPS/W), convert to GFLOPS/W\n        gflopsPerWatt = flopsPerWattGround * 1000;\n        if (true) {\n            console.warn(\"[UNIT CONVERSION] flopsPerWattGround=\".concat(flopsPerWattGround, \" < 50, treating as TFLOPS/W and converting to \").concat(gflopsPerWatt, \" GFLOPS/W\"));\n        }\n    }\n    // Clamp insane values\n    if (gflopsPerWatt > 20000) {\n        if (true) {\n            console.warn(\"[UNIT CLAMP] gflopsPerWatt=\".concat(gflopsPerWatt, \" > 20000, clamping to 20000\"));\n        }\n        gflopsPerWatt = 20000;\n    }\n    var _waccParams_baseWacc;\n    // WACC parameters (capital rationing: WACC rises with backlog)\n    const baseWacc = (_waccParams_baseWacc = waccParams === null || waccParams === void 0 ? void 0 : waccParams.baseWacc) !== null && _waccParams_baseWacc !== void 0 ? _waccParams_baseWacc : 0.10; // 10% base WACC\n    var _waccParams_waccBacklogK;\n    const waccBacklogK = (_waccParams_waccBacklogK = waccParams === null || waccParams === void 0 ? void 0 : waccParams.waccBacklogK) !== null && _waccParams_waccBacklogK !== void 0 ? _waccParams_waccBacklogK : 0.5; // Scaling factor\n    var _waccParams_waccBacklogExponent;\n    const waccBacklogExponent = (_waccParams_waccBacklogExponent = waccParams === null || waccParams === void 0 ? void 0 : waccParams.waccBacklogExponent) !== null && _waccParams_waccBacklogExponent !== void 0 ? _waccParams_waccBacklogExponent : 1.2; // Exponent for convexity\n    var _waccParams_criticalBacklogGW;\n    const criticalBacklogGW = (_waccParams_criticalBacklogGW = waccParams === null || waccParams === void 0 ? void 0 : waccParams.criticalBacklogGW) !== null && _waccParams_criticalBacklogGW !== void 0 ? _waccParams_criticalBacklogGW : 50; // Critical backlog threshold\n    // Compute effective WACC (rises with backlog)\n    // waccEffective = baseWacc * (1 + waccBacklogK * (backlogGW/criticalBacklogGW)^waccBacklogExponent)\n    const backlogRatio = Math.max(0, backlogGw / criticalBacklogGW);\n    const waccMultiplier = 1 + waccBacklogK * Math.pow(backlogRatio, waccBacklogExponent);\n    const waccEffective = baseWacc * waccMultiplier;\n    // Constants\n    const WACC = 0.10;\n    const CAPEX_PER_MW = 3000000; // $3M/MW capex at risk\n    // Replace the huge lost-margin number with something defensible + capped\n    const LOST_MARGIN_PER_MW_YEAR = 600000; // was 2,000,000, now 600k\n    const LOST_MARGIN_CAP_PER_MW = 1800000; // cap total lost margin component\n    const MAX_WAIT_FOR_CARRY = 4; // years, cap compounding horizon\n    const MAX_TOTAL_PENALTY_PER_MW_YEAR = 2500000; // hard cap so it never goes vertical\n    const BASE_SITE_COST_PER_MW_YEAR = 150000; // $150k/MW-year base site cost\n    const BASE_PUE = 1.3; // Baseline PUE\n    // Reference capex amort for capping (used to prevent penalty from dominating)\n    const CAPEX_AMORT_PER_PFLOP_YEAR_REFERENCE = 1500; // Base site cost per PFLOP-year\n    // 1. Bounded Delay Penalty: Linear WACC carry (NOT exponential)\n    // delayPenaltyPerPflopYear = capexPerPflopYear * wacc * avgWaitYears\n    // Cap it: delayPenaltyPerPflopYear = min(delayPenaltyPerPflopYear, delayCapFrac * capexPerPflopYear)\n    let timeToEnergizePenaltyPerPflopYear = 0;\n    let capexAtRiskPerMW = 0;\n    let carryCostPerMW = 0;\n    let lostMarginPerMW = 0;\n    // Convert capex to per-PFLOP-year for penalty calculation\n    const pflopsPerMW = gflopsPerWatt * capacityFactorGround / pueGround;\n    const CAPEX_PER_PFLOP_YEAR = CAPEX_PER_MW / Math.max(pflopsPerMW, 1e-6);\n    if (avgWaitYears > 0.01) {\n        // Linear delay penalty: WACC * capex * waitYears (NOT exponential)\n        const delayPenaltyUncapped = CAPEX_PER_PFLOP_YEAR * baseWacc * avgWaitYears;\n        // Cap at delayCapFrac of capex (0.5-1.0 range)\n        const DELAY_CAP_FRAC = 0.75; // Cap at 75% of capex\n        timeToEnergizePenaltyPerPflopYear = Math.min(delayPenaltyUncapped, DELAY_CAP_FRAC * CAPEX_PER_PFLOP_YEAR);\n        // For debug fields (MW-based)\n        capexAtRiskPerMW = CAPEX_PER_MW;\n        carryCostPerMW = CAPEX_PER_MW * baseWacc * avgWaitYears;\n        lostMarginPerMW = 0; // Not used in bounded model\n    }\n    // 2. Site Multiplier: land + interconnect scarcity (Hill-shaped, thresholded)\n    // Backlog rent: Hill on avgWaitYears (this creates the \"hump\" shape)\n    const waitRent = hill(avgWaitYears, 2.0, 2.0); // 50% rent at 2 years\n    const backlogRent = hill(backlogGw, 30, 2.0); // kicks in around ~30 GW backlog\n    // Utilization rent: strictly 0 until > 85% utilization\n    const utilRent = thresholdHill(utilizationPct, 0.85, 0.05, 2.0); // x50 is 5% above threshold\n    const landScarcityFactor = 1 + 0.35 * backlogRent;\n    const interconnectScarcityFactor = 1 + 0.45 * Math.max(waitRent, utilRent);\n    // Site multiplier should be ~1 when backlog=0, wait=0, util<0.85\n    const siteMultiplier = landScarcityFactor * interconnectScarcityFactor;\n    // 3. PUE Multiplier: cooling/water stress (thresholded)\n    const coolingStressFactor = 1 + 0.25 * utilRent;\n    const waterStressFactor = 1 + 0.20 * backlogRent;\n    const pueMultiplier = 1 + (coolingStressFactor - 1) + (waterStressFactor - 1); // Additive stress\n    return {\n        timeToEnergizePenaltyPerPflopYear,\n        siteMultiplier,\n        pueMultiplier,\n        backlogGw,\n        avgWaitYears,\n        capexAtRiskPerMW,\n        carryCostPerMW,\n        lostMarginPerMW,\n        waccBase: baseWacc,\n        waccEffective\n    };\n}\n/**\n * Calculate Hill-based scarcity premium from queue pressure + utilization\n * \n * Scarcity multiplier (NOT exponential):\n * - queuePressure = backlogGW / (backlogGW + K_backlogGW) where K_backlogGW ~ 50-150\n * - utilPressure = 1 / (1 + exp(-k*(utilizationPct - u0))) with u0 ~ 0.85-0.92, k ~ 12-20\n * - scarcity = 1 + rentFracMax * (queuePressure^h) * utilPressure\n * \n * @param backlogGw Backlog in GW\n * @param utilizationPct Utilization percentage (0-1)\n * @param baseCostPerPflopYear Base cost per PFLOP-year (for rent calculation)\n * @param params Optional parameters\n * @returns Scarcity rent and debug fields\n */ function calculateHillScarcityPremium(backlogGw, utilizationPct, baseCostPerPflopYear, params) {\n    var _params_kBacklogGw;\n    const kBacklogGw = (_params_kBacklogGw = params === null || params === void 0 ? void 0 : params.kBacklogGw) !== null && _params_kBacklogGw !== void 0 ? _params_kBacklogGw : 100; // K_backlogGW ~ 50-150\n    var _params_u0;\n    const u0 = (_params_u0 = params === null || params === void 0 ? void 0 : params.u0) !== null && _params_u0 !== void 0 ? _params_u0 : 0.88; // u0 ~ 0.85-0.92 (scarcity starts at 88% utilization)\n    var _params_k;\n    const k = (_params_k = params === null || params === void 0 ? void 0 : params.k) !== null && _params_k !== void 0 ? _params_k : 16; // k ~ 12-20 (steepness of utilization curve)\n    var _params_rentFracMax;\n    const rentFracMax = (_params_rentFracMax = params === null || params === void 0 ? void 0 : params.rentFracMax) !== null && _params_rentFracMax !== void 0 ? _params_rentFracMax : 0.5; // rentFracMax ~ 0.3-0.8 (max rent fraction)\n    var _params_h;\n    const h = (_params_h = params === null || params === void 0 ? void 0 : params.h) !== null && _params_h !== void 0 ? _params_h : 2.0; // h ~ 1-3 (steepness of queue pressure)\n    // Queue pressure: backlogGW / (backlogGW + K_backlogGW)\n    // Saturates at 1 as backlog grows\n    const queuePressure = backlogGw / (backlogGw + kBacklogGw);\n    // Utilization pressure: 1 / (1 + exp(-k*(utilizationPct - u0)))\n    // Sigmoid that rises sharply around u0\n    const utilExcess = utilizationPct - u0;\n    const utilPressure = 1 / (1 + Math.exp(-k * utilExcess));\n    // Scarcity multiplier: 1 + rentFracMax * (queuePressure^h) * utilPressure\n    const scarcityMultiplier = 1 + rentFracMax * Math.pow(queuePressure, h) * utilPressure;\n    // Scarcity rent = base cost * (scarcity - 1)\n    const scarcityRentPerPflopYear = baseCostPerPflopYear * (scarcityMultiplier - 1);\n    return {\n        scarcityRentPerPflopYear,\n        scarcityMultiplier,\n        queuePressure,\n        utilPressure\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX2NvbnN0cmFpbnRfcGVuYWx0aWVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7O0NBT0MsR0FJRDs7Ozs7O0NBTUMsR0FDRCxTQUFTQSxLQUFLQyxDQUFTLEVBQUVDLEdBQVcsRUFBRUMsQ0FBUztJQUM3QyxJQUFJRixLQUFLLEdBQUcsT0FBTztJQUNuQixNQUFNRyxLQUFLQyxLQUFLQyxHQUFHLENBQUNMLEdBQUdFO0lBQ3ZCLE1BQU1JLE9BQU9GLEtBQUtDLEdBQUcsQ0FBQ0osS0FBS0M7SUFDM0IsT0FBT0MsS0FBTUcsQ0FBQUEsT0FBT0gsRUFBQztBQUN2QjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTSSxjQUFjUCxDQUFTLEVBQUVRLEVBQVUsRUFBRVAsR0FBVyxFQUFFQyxDQUFTO0lBQ2xFLE1BQU1PLFNBQVNMLEtBQUtNLEdBQUcsQ0FBQyxHQUFHVixJQUFJUTtJQUMvQixPQUFPVCxLQUFLVSxRQUFRUixLQUFLQztBQUMzQjtBQXVCQTs7Ozs7Ozs7O0NBU0MsR0FDTSxTQUFTUyxzQkFDZEMsU0FBaUIsRUFDakJDLGNBQXVCLEVBQ3ZCQyxNQUlDO0lBYUQsMkRBQTJEO0lBQzNELE1BQU1DLGlCQUFpQjtJQUN2QixJQUFJRixtQkFBbUJHLGFBQWFILGlCQUFpQkUsZ0JBQWdCO1FBQ25FLE9BQU87WUFDTEUsMEJBQTBCO1lBQzFCQyxVQUFVO1lBQ1ZDLGNBQWNQO1lBQ2RRLGNBQWM7Z0JBQUVDLEdBQUc7Z0JBQUdILFVBQVU7WUFBRTtZQUNsQ0ksaUJBQWlCVjtZQUNqQlcscUJBQXFCWDtRQUN2QjtJQUNGO0lBRUEsdURBQXVEO0lBQ3ZELElBQUlBLFlBQVksS0FBSztRQUNuQixPQUFPO1lBQ0xLLDBCQUEwQjtZQUMxQkMsVUFBVTtZQUNWQyxjQUFjUDtZQUNkUSxjQUFjO2dCQUFFQyxHQUFHO2dCQUFHSCxVQUFVO1lBQUU7WUFDbENJLGlCQUFpQlY7WUFDakJXLHFC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SUFBcEIsTUFBTXVFLGNBQWN2RSxDQUFBQSxzQkFBQUEsbUJBQUFBLDZCQUFBQSxPQUFRdUUsV0FBVyxjQUFuQnZFLGlDQUFBQSxzQkFBdUIsS0FBSyw0Q0FBNEM7UUFDbEZBO0lBQVYsTUFBTU8sSUFBSVAsQ0FBQUEsWUFBQUEsbUJBQUFBLDZCQUFBQSxPQUFRTyxDQUFDLGNBQVRQLHVCQUFBQSxZQUFhLEtBQUssd0NBQXdDO0lBRXBFLHdEQUF3RDtJQUN4RCxrQ0FBa0M7SUFDbEMsTUFBTXdFLGdCQUFnQmpELFlBQWFBLENBQUFBLFlBQVk2QyxVQUFTO0lBRXhELGdFQUFnRTtJQUNoRSx1Q0FBdUM7SUFDdkMsTUFBTUssYUFBYTFFLGlCQUFpQnNFO0lBQ3BDLE1BQU1LLGVBQWUsSUFBSyxLQUFJcEYsS0FBS3FGLEdBQUcsQ0FBQyxDQUFDTCxJQUFJRyxXQUFVO0lBRXRELDBFQUEwRTtJQUMxRSxNQUFNRyxxQkFBcUIsSUFBSUwsY0FBY2pGLEtBQUtDLEdBQUcsQ0FBQ2lGLGVBQWVqRSxLQUFLbUU7SUFFMUUsNkNBQTZDO0lBQzdDLE1BQU12RSwyQkFBMkJnRSx1QkFBd0JTLENBQUFBLHFCQUFxQjtJQUU5RSxPQUFPO1FBQ0x6RTtRQUNBeUU7UUFDQUo7UUFDQUU7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX2NvbnN0cmFpbnRfcGVuYWx0aWVzLnRzPzIzZmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHcm91bmQgQ29uc3RyYWludCBQZW5hbHRpZXMgTW9kZWxcbiAqIFxuICogQ2FsY3VsYXRlcyBXQUNDLWJhc2VkIHBlbmFsdGllcyBhbmQgbXVsdGlwbGllcnMgZnJvbSBiYWNrbG9nL3dhaXQgdGltZTpcbiAqIC0gdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyOiBXQUNDIGNhcnJ5ICsgbG9zdCBtYXJnaW5cbiAqIC0gc2l0ZU11bHRpcGxpZXI6IGxhbmQgKyBpbnRlcmNvbm5lY3Qgc2NhcmNpdHlcbiAqIC0gcHVlTXVsdGlwbGllcjogY29vbGluZy93YXRlciBzdHJlc3NcbiAqL1xuXG5pbXBvcnQgeyBHcm91bmRTdXBwbHlTdGF0ZSB9IGZyb20gJy4vZ3JvdW5kX3F1ZXVlX21vZGVsJztcblxuLyoqXG4gKiBIaWxsIGZ1bmN0aW9uOiBzYXR1cmF0aW5nIHNpZ21vaWQtbGlrZSBjdXJ2ZVxuICogQHBhcmFtIHggSW5wdXQgdmFsdWVcbiAqIEBwYXJhbSB4NTAgSGFsZi1zYXR1cmF0aW9uIHBvaW50XG4gKiBAcGFyYW0gbiBIaWxsIGNvZWZmaWNpZW50IChzdGVlcG5lc3MpXG4gKiBAcmV0dXJucyBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDFcbiAqL1xuZnVuY3Rpb24gaGlsbCh4OiBudW1iZXIsIHg1MDogbnVtYmVyLCBuOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoeCA8PSAwKSByZXR1cm4gMDtcbiAgY29uc3QgeG4gPSBNYXRoLnBvdyh4LCBuKTtcbiAgY29uc3QgeDUwbiA9IE1hdGgucG93KHg1MCwgbik7XG4gIHJldHVybiB4biAvICh4NTBuICsgeG4pO1xufVxuXG4vKipcbiAqIFRocmVzaG9sZCBIaWxsIGZ1bmN0aW9uOiAwIHVudGlsIHggZXhjZWVkcyB4MCwgdGhlbiBIaWxsIG9uIHRoZSBleGNlc3NcbiAqIEBwYXJhbSB4IElucHV0IHZhbHVlXG4gKiBAcGFyYW0geDAgVGhyZXNob2xkIChtdXN0IGV4Y2VlZCB0aGlzIGJlZm9yZSBIaWxsIGFjdGl2YXRlcylcbiAqIEBwYXJhbSB4NTAgSGFsZi1zYXR1cmF0aW9uIHBvaW50IGZvciBleGNlc3NcbiAqIEBwYXJhbSBuIEhpbGwgY29lZmZpY2llbnRcbiAqIEByZXR1cm5zIFZhbHVlIGJldHdlZW4gMCBhbmQgMVxuICovXG5mdW5jdGlvbiB0aHJlc2hvbGRIaWxsKHg6IG51bWJlciwgeDA6IG51bWJlciwgeDUwOiBudW1iZXIsIG46IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IGV4Y2VzcyA9IE1hdGgubWF4KDAsIHggLSB4MCk7XG4gIHJldHVybiBoaWxsKGV4Y2VzcywgeDUwLCBuKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcm91bmRDb25zdHJhaW50UGVuYWx0aWVzIHtcbiAgLy8gVGltZS10by1lbmVyZ2l6ZSBwZW5hbHR5IChXQUNDIGNhcnJ5ICsgbG9zdCBtYXJnaW4pXG4gIHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhcjogbnVtYmVyO1xuICBcbiAgLy8gU2l0ZSBtdWx0aXBsaWVyIChsYW5kICsgaW50ZXJjb25uZWN0IHNjYXJjaXR5KVxuICBzaXRlTXVsdGlwbGllcjogbnVtYmVyO1xuICBcbiAgLy8gUFVFIG11bHRpcGxpZXIgKGNvb2xpbmcvd2F0ZXIgc3RyZXNzKVxuICBwdWVNdWx0aXBsaWVyOiBudW1iZXI7XG4gIFxuICAvLyBEZWJ1ZyBmaWVsZHNcbiAgYmFja2xvZ0d3OiBudW1iZXI7XG4gIGF2Z1dhaXRZZWFyczogbnVtYmVyO1xuICBjYXBleEF0Umlza1Blck1XOiBudW1iZXI7XG4gIGNhcnJ5Q29zdFBlck1XOiBudW1iZXI7XG4gIGxvc3RNYXJnaW5QZXJNVzogbnVtYmVyO1xuICAvLyBXQUNDIGRlYnVnIGZpZWxkc1xuICB3YWNjQmFzZT86IG51bWJlcjtcbiAgd2FjY0VmZmVjdGl2ZT86IG51bWJlcjtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgc2F0dXJhdGluZyBzY2FyY2l0eSByZW50IHVzaW5nIEhpbGwgZnVuY3Rpb24gKHByZXZlbnRzIGV4cG9uZW50aWFsIGJsb3ctdXApXG4gKiBcbiAqIEBwYXJhbSB3YWl0WWVhcnMgQXZlcmFnZSB3YWl0IHRpbWUgKHllYXJzKSAtIE5PIENMQU1QIGFwcGxpZWRcbiAqIEBwYXJhbSB1dGlsaXphdGlvblBjdCBVdGlsaXphdGlvbiBwZXJjZW50YWdlICgwLTEpIC0gb3B0aW9uYWwgdGhyZXNob2xkIGdhdGVcbiAqIEBwYXJhbSB3YWl0VGhyZXNob2xkWWVhcnMgVGhyZXNob2xkIGZvciBoYWxmLXNhdHVyYXRpb24gKGRlZmF1bHQgMy4wKVxuICogQHBhcmFtIHJlbnRNYXhGcmFjT2ZDYXBleEFubnVhbCBNYXhpbXVtIHJlbnQgYXMgZnJhY3Rpb24gb2YgcmVmZXJlbmNlIGJhc2UgKGRlZmF1bHQgMC42NSlcbiAqIEBwYXJhbSByZW50U2hhcGVQIEhpbGwgZnVuY3Rpb24gc2hhcGUgcGFyYW1ldGVyIChkZWZhdWx0IDIuMClcbiAqIEByZXR1cm5zIFNjYXJjaXR5IHJlbnQgcGVyIFBGTE9QLXllYXIgYW5kIGRlYnVnIGZpZWxkc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlU2NhcmNpdHlSZW50KFxuICB3YWl0WWVhcnM6IG51bWJlcixcbiAgdXRpbGl6YXRpb25QY3Q/OiBudW1iZXIsXG4gIHBhcmFtcz86IHtcbiAgICB3YWl0VGhyZXNob2xkWWVhcnM/OiBudW1iZXI7IC8vIHc1MCBwYXJhbWV0ZXIgZm9yIEhpbGwgZnVuY3Rpb25cbiAgICByZW50TWF4RnJhY09mQ2FwZXhBbm51YWw/OiBudW1iZXI7IC8vIHJlbnRNYXggcGFyYW1ldGVyXG4gICAgcmVudFNoYXBlUD86IG51bWJlcjsgLy8gbiBwYXJhbWV0ZXIgZm9yIEhpbGwgZnVuY3Rpb25cbiAgfVxuKToge1xuICBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXI6IG51bWJlcjtcbiAgcmVudEZyYWM6IG51bWJlcjtcbiAgd2FpdEVmZlllYXJzOiBudW1iZXI7XG4gIC8vIERlYnVnIGZpZWxkc1xuICBzY2FyY2l0eUhpbGw6IHtcbiAgICBoOiBudW1iZXI7IC8vIEhpbGwgZnVuY3Rpb24gdmFsdWVcbiAgICByZW50RnJhYzogbnVtYmVyOyAvLyBSZW50IGZyYWN0aW9uIGFmdGVyIGFwcGx5aW5nIHJlbnRNYXhcbiAgfTtcbiAgYXZnV2FpdFllYXJzUmF3OiBudW1iZXI7IC8vIFJhdyB3YWl0IHllYXJzIChubyBjbGFtcClcbiAgYXZnV2FpdFllYXJzQ2xhbXBlZDogbnVtYmVyOyAvLyBTYW1lIGFzIHJhdyAobm8gY2xhbXAgYXBwbGllZClcbn0ge1xuICAvLyBUSFJFU0hPTEQgR0FURTogTm8gc2NhcmNpdHkgcmVudCB1bnRpbCB1dGlsaXphdGlvbiA+IDg1JVxuICBjb25zdCBVVElMX1RIUkVTSE9MRCA9IDAuODU7XG4gIGlmICh1dGlsaXphdGlvblBjdCAhPT0gdW5kZWZpbmVkICYmIHV0aWxpemF0aW9uUGN0IDwgVVRJTF9USFJFU0hPTEQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyOiAwLFxuICAgICAgcmVudEZyYWM6IDAsXG4gICAgICB3YWl0RWZmWWVhcnM6IHdhaXRZZWFycyxcbiAgICAgIHNjYXJjaXR5SGlsbDogeyBoOiAwLCByZW50RnJhYzogMCB9LFxuICAgICAgYXZnV2FpdFllYXJzUmF3OiB3YWl0WWVhcnMsXG4gICAgICBhdmdXYWl0WWVhcnNDbGFtcGVkOiB3YWl0WWVhcnMsXG4gICAgfTtcbiAgfVxuICBcbiAgLy8gVEhSRVNIT0xEIEdBVEU6IE5vIHNjYXJjaXR5IHJlbnQgdW50aWwgd2FpdCA+IDEgeWVhclxuICBpZiAod2FpdFllYXJzIDwgMS4wKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjYXJjaXR5UmVudFBlclBmbG9wWWVhcjogMCxcbiAgICAgIHJlbnRGcmFjOiAwLFxuICAgICAgd2FpdEVmZlllYXJzOiB3YWl0WWVhcnMsXG4gICAgICBzY2FyY2l0eUhpbGw6IHsgaDogMCwgcmVudEZyYWM6IDAgfSxcbiAgICAgIGF2Z1dhaXRZZWFyc1Jhdzogd2FpdFllYXJzLFxuICAgICAgYXZnV2FpdFllYXJzQ2xhbXBlZDogd2FpdFllYXJzLFxuICAgIH07XG4gIH1cbiAgXG4gIC8vIEhpbGwgZnVuY3Rpb24gcGFyYW1ldGVyczogdzUwPTMuMCwgbj0yLjAsIHJlbnRNYXg9MC42NVxuICBjb25zdCB3NTAgPSBwYXJhbXM/LndhaXRUaHJlc2hvbGRZZWFycyA/PyAzLjA7IC8vIEhhbGYtc2F0dXJhdGlvbiBwb2ludCAoeWVhcnMpIC0gaW5jcmVhc2VkIGZyb20gMi4wXG4gIGNvbnN0IG4gPSBwYXJhbXM/LnJlbnRTaGFwZVAgPz8gMi4wOyAvLyBIaWxsIGNvZWZmaWNpZW50XG4gIGNvbnN0IHJlbnRNYXggPSBwYXJhbXM/LnJlbnRNYXhGcmFjT2ZDYXBleEFubnVhbCA/PyAwLjY1OyAvLyBNYXggcmVudCA9IDY1JSBvZiByZWZlcmVuY2UgYmFzZVxuICBcbiAgLy8gU3RvcmUgcmF3IHdhaXQgeWVhcnMgZm9yIGRlYnVnIChOTyBDTEFNUClcbiAgY29uc3QgYXZnV2FpdFllYXJzUmF3ID0gd2FpdFllYXJzO1xuICBjb25zdCBhdmdXYWl0WWVhcnNDbGFtcGVkID0gd2FpdFllYXJzOyAvLyBObyBjbGFtcCAtIHByZXNlcnZlcyBzY2FyY2l0eSBzaWduYWxcbiAgXG4gIC8vIEhpbGwgZnVuY3Rpb246IGggPSAody93NTApXm4gLyAoMSArICh3L3c1MClebilcbiAgLy8gVGhpcyBzYXR1cmF0ZXMgYXQgMSBhcyB3YWl0IGluY3JlYXNlcywgcHJldmVudGluZyBleHBvbmVudGlhbCBncm93dGhcbiAgY29uc3QgdyA9IGF2Z1dhaXRZZWFyc0NsYW1wZWQ7XG4gIGNvbnN0IHggPSB3IC8gdzUwO1xuICBjb25zdCBoID0geCA+IDAgPyBNYXRoLnBvdyh4LCBuKSAvICgxICsgTWF0aC5wb3coeCwgbikpIDogMDtcbiAgXG4gIC8vIFJlbnQgZnJhY3Rpb246IG1heCBmcmFjdGlvbiBvZiByZWZlcmVuY2UgYmFzZVxuICBjb25zdCByZW50RnJhYyA9IHJlbnRNYXggKiBoO1xuICBcbiAgLy8gRklYOiBVc2UgZml4ZWQgcmVmZXJlbmNlIGJhc2UgdGhhdCBkb2Vzbid0IGRlY2xpbmUgd2l0aCB0ZWNoIChtYXJrZXQgY2xlYXJpbmcgcHJpY2UpXG4gIC8vIFRoaXMgZW5zdXJlcyBzY2FyY2l0eSByZW50IElOQ1JFQVNFUyB3aXRoIHNjYXJjaXR5LCBub3QgZGVjcmVhc2VzXG4gIGNvbnN0IFNDQVJDSVRZX1JFTlRfUkVGRVJFTkNFX0JBU0UgPSA2NTAwOyAvLyAkL1BGTE9QLXlyIChmaXhlZCBtYXJrZXQgY2xlYXJpbmcgcmVmZXJlbmNlKVxuICBjb25zdCBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXIgPSByZW50RnJhYyAqIFNDQVJDSVRZX1JFTlRfUkVGRVJFTkNFX0JBU0U7XG4gIFxuICByZXR1cm4ge1xuICAgIHNjYXJjaXR5UmVudFBlclBmbG9wWWVhcixcbiAgICByZW50RnJhYyxcbiAgICB3YWl0RWZmWWVhcnM6IGF2Z1dhaXRZZWFyc0NsYW1wZWQsXG4gICAgc2NhcmNpdHlIaWxsOiB7XG4gICAgICBoLFxuICAgICAgcmVudEZyYWMsXG4gICAgfSxcbiAgICBhdmdXYWl0WWVhcnNSYXcsXG4gICAgYXZnV2FpdFllYXJzQ2xhbXBlZCxcbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgZ3JvdW5kIGNvbnN0cmFpbnQgcGVuYWx0aWVzIGZyb20gc3VwcGx5IHN0YXRlXG4gKiBcbiAqIEBwYXJhbSBzdGF0ZSBDdXJyZW50IGdyb3VuZCBzdXBwbHkgc3RhdGVcbiAqIEBwYXJhbSBmbG9wc1BlcldhdHRHcm91bmQgR0ZMT1BTL1cgZm9yIGdyb3VuZCBjb21wdXRlXG4gKiBAcGFyYW0gcHVlR3JvdW5kIFBVRSBmb3IgZ3JvdW5kIGRhdGFjZW50ZXJzXG4gKiBAcGFyYW0gY2FwYWNpdHlGYWN0b3JHcm91bmQgQ2FwYWNpdHkgZmFjdG9yIGZvciBncm91bmRcbiAqIEBwYXJhbSB3YWNjUGFyYW1zIE9wdGlvbmFsIFdBQ0MgcGFyYW1ldGVycyBmb3IgY2FwaXRhbCByYXRpb25pbmdcbiAqIEByZXR1cm5zIFBlbmFsdGllcyBhbmQgbXVsdGlwbGllcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUdyb3VuZENvbnN0cmFpbnRQZW5hbHRpZXMoXG4gIHN0YXRlOiBHcm91bmRTdXBwbHlTdGF0ZSxcbiAgZmxvcHNQZXJXYXR0R3JvdW5kOiBudW1iZXIsXG4gIHB1ZUdyb3VuZDogbnVtYmVyLFxuICBjYXBhY2l0eUZhY3Rvckdyb3VuZDogbnVtYmVyLFxuICB3YWNjUGFyYW1zPzoge1xuICAgIGJhc2VXYWNjPzogbnVtYmVyO1xuICAgIHdhY2NCYWNrbG9nSz86IG51bWJlcjtcbiAgICB3YWNjQmFja2xvZ0V4cG9uZW50PzogbnVtYmVyO1xuICAgIGNyaXRpY2FsQmFja2xvZ0dXPzogbnVtYmVyO1xuICB9XG4pOiBHcm91bmRDb25zdHJhaW50UGVuYWx0aWVzIHtcbiAgY29uc3QgYmFja2xvZ0d3ID0gc3RhdGUuYmFja2xvZ0d3OyAvLyBQaXBlbGluZSBpcyBub3QgYmFja2xvZy4gSWYgYmFja2xvZyBpcyBtaXNzaW5nLCB0cmVhdCBhcyAwIGFuZCBsZXQgY2hhcnRJbnB1dHMvYnVpbGRvdXREZWJ1ZyBzdXBwbHkgdGhlIHJlYWwgbnVtYmVyIGVsc2V3aGVyZS5cbiAgY29uc3QgYXZnV2FpdFllYXJzID0gc3RhdGUuYXZnV2FpdFllYXJzO1xuICBjb25zdCBtYXhCdWlsZFJhdGVHd1llYXIgPSBzdGF0ZS5tYXhCdWlsZFJhdGVHd1llYXI7XG4gIGNvbnN0IHV0aWxpemF0aW9uUGN0ID0gc3RhdGUudXRpbGl6YXRpb25QY3Q7XG4gIFxuICAvLyBDb252ZXJ0IEdXIHRvIE1XXG4gIGNvbnN0IGJhY2tsb2dNdyA9IGJhY2tsb2dHdyAqIDEwMDA7XG4gIFxuICAvLyBVTklUIEdVQVJEOiBGaXggdW5pdHMgbWlzbWF0Y2ggKGZsb3BzUGVyV2F0dEdyb3VuZCBtaWdodCBiZSBURkxPUFMvVyBpbnN0ZWFkIG9mIEdGTE9QUy9XKVxuICBsZXQgZ2Zsb3BzUGVyV2F0dCA9IGZsb3BzUGVyV2F0dEdyb3VuZDtcbiAgaWYgKGZsb3BzUGVyV2F0dEdyb3VuZCA8IDUwKSB7XG4gICAgLy8gTGlrZWx5IFRGTE9QUy9XIChlLmcuLCAyIFRGTE9QUy9XKSwgY29udmVydCB0byBHRkxPUFMvV1xuICAgIGdmbG9wc1BlcldhdHQgPSBmbG9wc1BlcldhdHRHcm91bmQgKiAxMDAwO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgY29uc29sZS53YXJuKGBbVU5JVCBDT05WRVJTSU9OXSBmbG9wc1BlcldhdHRHcm91bmQ9JHtmbG9wc1BlcldhdHRHcm91bmR9IDwgNTAsIHRyZWF0aW5nIGFzIFRGTE9QUy9XIGFuZCBjb252ZXJ0aW5nIHRvICR7Z2Zsb3BzUGVyV2F0dH0gR0ZMT1BTL1dgKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2xhbXAgaW5zYW5lIHZhbHVlc1xuICBpZiAoZ2Zsb3BzUGVyV2F0dCA+IDIwMDAwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFtVTklUIENMQU1QXSBnZmxvcHNQZXJXYXR0PSR7Z2Zsb3BzUGVyV2F0dH0gPiAyMDAwMCwgY2xhbXBpbmcgdG8gMjAwMDBgKTtcbiAgICB9XG4gICAgZ2Zsb3BzUGVyV2F0dCA9IDIwMDAwO1xuICB9XG4gIFxuICAvLyBXQUNDIHBhcmFtZXRlcnMgKGNhcGl0YWwgcmF0aW9uaW5nOiBXQUNDIHJpc2VzIHdpdGggYmFja2xvZylcbiAgY29uc3QgYmFzZVdhY2MgPSB3YWNjUGFyYW1zPy5iYXNlV2FjYyA/PyAwLjEwOyAvLyAxMCUgYmFzZSBXQUNDXG4gIGNvbnN0IHdhY2NCYWNrbG9nSyA9IHdhY2NQYXJhbXM/LndhY2NCYWNrbG9nSyA/PyAwLjU7IC8vIFNjYWxpbmcgZmFjdG9yXG4gIGNvbnN0IHdhY2NCYWNrbG9nRXhwb25lbnQgPSB3YWNjUGFyYW1zPy53YWNjQmFja2xvZ0V4cG9uZW50ID8/IDEuMjsgLy8gRXhwb25lbnQgZm9yIGNvbnZleGl0eVxuICBjb25zdCBjcml0aWNhbEJhY2tsb2dHVyA9IHdhY2NQYXJhbXM/LmNyaXRpY2FsQmFja2xvZ0dXID8/IDUwOyAvLyBDcml0aWNhbCBiYWNrbG9nIHRocmVzaG9sZFxuICBcbiAgLy8gQ29tcHV0ZSBlZmZlY3RpdmUgV0FDQyAocmlzZXMgd2l0aCBiYWNrbG9nKVxuICAvLyB3YWNjRWZmZWN0aXZlID0gYmFzZVdhY2MgKiAoMSArIHdhY2NCYWNrbG9nSyAqIChiYWNrbG9nR1cvY3JpdGljYWxCYWNrbG9nR1cpXndhY2NCYWNrbG9nRXhwb25lbnQpXG4gIGNvbnN0IGJhY2tsb2dSYXRpbyA9IE1hdGgubWF4KDAsIGJhY2tsb2dHdyAvIGNyaXRpY2FsQmFja2xvZ0dXKTtcbiAgY29uc3Qgd2FjY011bHRpcGxpZXIgPSAxICsgd2FjY0JhY2tsb2dLICogTWF0aC5wb3coYmFja2xvZ1JhdGlvLCB3YWNjQmFja2xvZ0V4cG9uZW50KTtcbiAgY29uc3Qgd2FjY0VmZmVjdGl2ZSA9IGJhc2VXYWNjICogd2FjY011bHRpcGxpZXI7XG4gIFxuICAvLyBDb25zdGFudHNcbiAgY29uc3QgV0FDQyA9IDAuMTA7XG4gIGNvbnN0IENBUEVYX1BFUl9NVyA9IDNfMDAwXzAwMDsgLy8gJDNNL01XIGNhcGV4IGF0IHJpc2tcbiAgXG4gIC8vIFJlcGxhY2UgdGhlIGh1Z2UgbG9zdC1tYXJnaW4gbnVtYmVyIHdpdGggc29tZXRoaW5nIGRlZmVuc2libGUgKyBjYXBwZWRcbiAgY29uc3QgTE9TVF9NQVJHSU5fUEVSX01XX1lFQVIgPSA2MDBfMDAwOyAgICAgIC8vIHdhcyAyLDAwMCwwMDAsIG5vdyA2MDBrXG4gIGNvbnN0IExPU1RfTUFSR0lOX0NBUF9QRVJfTVcgPSAxXzgwMF8wMDA7ICAgICAvLyBjYXAgdG90YWwgbG9zdCBtYXJnaW4gY29tcG9uZW50XG4gIFxuICBjb25zdCBNQVhfV0FJVF9GT1JfQ0FSUlkgPSA0OyAgICAgICAgICAgICAgICAgLy8geWVhcnMsIGNhcCBjb21wb3VuZGluZyBob3Jpem9uXG4gIGNvbnN0IE1BWF9UT1RBTF9QRU5BTFRZX1BFUl9NV19ZRUFSID0gMl81MDBfMDAwOyAvLyBoYXJkIGNhcCBzbyBpdCBuZXZlciBnb2VzIHZlcnRpY2FsXG4gIFxuICBjb25zdCBCQVNFX1NJVEVfQ09TVF9QRVJfTVdfWUVBUiA9IDE1MF8wMDA7IC8vICQxNTBrL01XLXllYXIgYmFzZSBzaXRlIGNvc3RcbiAgY29uc3QgQkFTRV9QVUUgPSAxLjM7IC8vIEJhc2VsaW5lIFBVRVxuICBcbiAgLy8gUmVmZXJlbmNlIGNhcGV4IGFtb3J0IGZvciBjYXBwaW5nICh1c2VkIHRvIHByZXZlbnQgcGVuYWx0eSBmcm9tIGRvbWluYXRpbmcpXG4gIGNvbnN0IENBUEVYX0FNT1JUX1BFUl9QRkxPUF9ZRUFSX1JFRkVSRU5DRSA9IDE1MDA7IC8vIEJhc2Ugc2l0ZSBjb3N0IHBlciBQRkxPUC15ZWFyXG4gIFxuICAvLyAxLiBCb3VuZGVkIERlbGF5IFBlbmFsdHk6IExpbmVhciBXQUNDIGNhcnJ5IChOT1QgZXhwb25lbnRpYWwpXG4gIC8vIGRlbGF5UGVuYWx0eVBlclBmbG9wWWVhciA9IGNhcGV4UGVyUGZsb3BZZWFyICogd2FjYyAqIGF2Z1dhaXRZZWFyc1xuICAvLyBDYXAgaXQ6IGRlbGF5UGVuYWx0eVBlclBmbG9wWWVhciA9IG1pbihkZWxheVBlbmFsdHlQZXJQZmxvcFllYXIsIGRlbGF5Q2FwRnJhYyAqIGNhcGV4UGVyUGZsb3BZZWFyKVxuICBsZXQgdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyID0gMDtcbiAgbGV0IGNhcGV4QXRSaXNrUGVyTVcgPSAwO1xuICBsZXQgY2FycnlDb3N0UGVyTVcgPSAwO1xuICBsZXQgbG9zdE1hcmdpblBlck1XID0gMDtcbiAgXG4gIC8vIENvbnZlcnQgY2FwZXggdG8gcGVyLVBGTE9QLXllYXIgZm9yIHBlbmFsdHkgY2FsY3VsYXRpb25cbiAgY29uc3QgcGZsb3BzUGVyTVcgPSAoZ2Zsb3BzUGVyV2F0dCAqIGNhcGFjaXR5RmFjdG9yR3JvdW5kKSAvIHB1ZUdyb3VuZDtcbiAgY29uc3QgQ0FQRVhfUEVSX1BGTE9QX1lFQVIgPSAoQ0FQRVhfUEVSX01XIC8gTWF0aC5tYXgocGZsb3BzUGVyTVcsIDFlLTYpKTtcbiAgXG4gIGlmIChhdmdXYWl0WWVhcnMgPiAwLjAxKSB7XG4gICAgLy8gTGluZWFyIGRlbGF5IHBlbmFsdHk6IFdBQ0MgKiBjYXBleCAqIHdhaXRZZWFycyAoTk9UIGV4cG9uZW50aWFsKVxuICAgIGNvbnN0IGRlbGF5UGVuYWx0eVVuY2FwcGVkID0gQ0FQRVhfUEVSX1BGTE9QX1lFQVIgKiBiYXNlV2FjYyAqIGF2Z1dhaXRZZWFycztcbiAgICBcbiAgICAvLyBDYXAgYXQgZGVsYXlDYXBGcmFjIG9mIGNhcGV4ICgwLjUtMS4wIHJhbmdlKVxuICAgIGNvbnN0IERFTEFZX0NBUF9GUkFDID0gMC43NTsgLy8gQ2FwIGF0IDc1JSBvZiBjYXBleFxuICAgIHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciA9IE1hdGgubWluKGRlbGF5UGVuYWx0eVVuY2FwcGVkLCBERUxBWV9DQVBfRlJBQyAqIENBUEVYX1BFUl9QRkxPUF9ZRUFSKTtcbiAgICBcbiAgICAvLyBGb3IgZGVidWcgZmllbGRzIChNVy1iYXNlZClcbiAgICBjYXBleEF0Umlza1Blck1XID0gQ0FQRVhfUEVSX01XO1xuICAgIGNhcnJ5Q29zdFBlck1XID0gQ0FQRVhfUEVSX01XICogYmFzZVdhY2MgKiBhdmdXYWl0WWVhcnM7XG4gICAgbG9zdE1hcmdpblBlck1XID0gMDsgLy8gTm90IHVzZWQgaW4gYm91bmRlZCBtb2RlbFxuICB9XG4gIFxuICAvLyAyLiBTaXRlIE11bHRpcGxpZXI6IGxhbmQgKyBpbnRlcmNvbm5lY3Qgc2NhcmNpdHkgKEhpbGwtc2hhcGVkLCB0aHJlc2hvbGRlZClcbiAgLy8gQmFja2xvZyByZW50OiBIaWxsIG9uIGF2Z1dhaXRZZWFycyAodGhpcyBjcmVhdGVzIHRoZSBcImh1bXBcIiBzaGFwZSlcbiAgY29uc3Qgd2FpdFJlbnQgPSBoaWxsKGF2Z1dhaXRZZWFycywgMi4wLCAyLjApOyAgICAgICAgICAvLyA1MCUgcmVudCBhdCAyIHllYXJzXG4gIGNvbnN0IGJhY2tsb2dSZW50ID0gaGlsbChiYWNrbG9nR3csIDMwLCAyLjApOyAgICAgICAgICAgLy8ga2lja3MgaW4gYXJvdW5kIH4zMCBHVyBiYWNrbG9nXG4gIFxuICAvLyBVdGlsaXphdGlvbiByZW50OiBzdHJpY3RseSAwIHVudGlsID4gODUlIHV0aWxpemF0aW9uXG4gIGNvbnN0IHV0aWxSZW50ID0gdGhyZXNob2xkSGlsbCh1dGlsaXphdGlvblBjdCwgMC44NSwgMC4wNSwgMi4wKTsgLy8geDUwIGlzIDUlIGFib3ZlIHRocmVzaG9sZFxuICBcbiAgY29uc3QgbGFuZFNjYXJjaXR5RmFjdG9yID0gMSArIDAuMzUgKiBiYWNrbG9nUmVudDtcbiAgY29uc3QgaW50ZXJjb25uZWN0U2NhcmNpdHlGYWN0b3IgPSAxICsgMC40NSAqIE1hdGgubWF4KHdhaXRSZW50LCB1dGlsUmVudCk7XG4gIFxuICAvLyBTaXRlIG11bHRpcGxpZXIgc2hvdWxkIGJlIH4xIHdoZW4gYmFja2xvZz0wLCB3YWl0PTAsIHV0aWw8MC44NVxuICBjb25zdCBzaXRlTXVsdGlwbGllciA9IGxhbmRTY2FyY2l0eUZhY3RvciAqIGludGVyY29ubmVjdFNjYXJjaXR5RmFjdG9yO1xuICBcbiAgLy8gMy4gUFVFIE11bHRpcGxpZXI6IGNvb2xpbmcvd2F0ZXIgc3RyZXNzICh0aHJlc2hvbGRlZClcbiAgY29uc3QgY29vbGluZ1N0cmVzc0ZhY3RvciA9IDEgKyAwLjI1ICogdXRpbFJlbnQ7XG4gIGNvbnN0IHdhdGVyU3RyZXNzRmFjdG9yID0gMSArIDAuMjAgKiBiYWNrbG9nUmVudDtcbiAgY29uc3QgcHVlTXVsdGlwbGllciA9IDEgKyAoY29vbGluZ1N0cmVzc0ZhY3RvciAtIDEpICsgKHdhdGVyU3RyZXNzRmFjdG9yIC0gMSk7IC8vIEFkZGl0aXZlIHN0cmVzc1xuICBcbiAgcmV0dXJuIHtcbiAgICB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIsXG4gICAgc2l0ZU11bHRpcGxpZXIsXG4gICAgcHVlTXVsdGlwbGllcixcbiAgICBiYWNrbG9nR3csXG4gICAgYXZnV2FpdFllYXJzLFxuICAgIGNhcGV4QXRSaXNrUGVyTVcsXG4gICAgY2FycnlDb3N0UGVyTVcsXG4gICAgbG9zdE1hcmdpblBlck1XLFxuICAgIHdhY2NCYXNlOiBiYXNlV2FjYyxcbiAgICB3YWNjRWZmZWN0aXZlLFxuICB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBIaWxsLWJhc2VkIHNjYXJjaXR5IHByZW1pdW0gZnJvbSBxdWV1ZSBwcmVzc3VyZSArIHV0aWxpemF0aW9uXG4gKiBcbiAqIFNjYXJjaXR5IG11bHRpcGxpZXIgKE5PVCBleHBvbmVudGlhbCk6XG4gKiAtIHF1ZXVlUHJlc3N1cmUgPSBiYWNrbG9nR1cgLyAoYmFja2xvZ0dXICsgS19iYWNrbG9nR1cpIHdoZXJlIEtfYmFja2xvZ0dXIH4gNTAtMTUwXG4gKiAtIHV0aWxQcmVzc3VyZSA9IDEgLyAoMSArIGV4cCgtayoodXRpbGl6YXRpb25QY3QgLSB1MCkpKSB3aXRoIHUwIH4gMC44NS0wLjkyLCBrIH4gMTItMjBcbiAqIC0gc2NhcmNpdHkgPSAxICsgcmVudEZyYWNNYXggKiAocXVldWVQcmVzc3VyZV5oKSAqIHV0aWxQcmVzc3VyZVxuICogXG4gKiBAcGFyYW0gYmFja2xvZ0d3IEJhY2tsb2cgaW4gR1dcbiAqIEBwYXJhbSB1dGlsaXphdGlvblBjdCBVdGlsaXphdGlvbiBwZXJjZW50YWdlICgwLTEpXG4gKiBAcGFyYW0gYmFzZUNvc3RQZXJQZmxvcFllYXIgQmFzZSBjb3N0IHBlciBQRkxPUC15ZWFyIChmb3IgcmVudCBjYWxjdWxhdGlvbilcbiAqIEBwYXJhbSBwYXJhbXMgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICogQHJldHVybnMgU2NhcmNpdHkgcmVudCBhbmQgZGVidWcgZmllbGRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVIaWxsU2NhcmNpdHlQcmVtaXVtKFxuICBiYWNrbG9nR3c6IG51bWJlcixcbiAgdXRpbGl6YXRpb25QY3Q6IG51bWJlcixcbiAgYmFzZUNvc3RQZXJQZmxvcFllYXI6IG51bWJlcixcbiAgcGFyYW1zPzoge1xuICAgIGtCYWNrbG9nR3c/OiBudW1iZXI7IC8vIEtfYmFja2xvZ0dXIH4gNTAtMTUwXG4gICAgdTA/OiBudW1iZXI7IC8vIHUwIH4gMC44NS0wLjkyXG4gICAgaz86IG51bWJlcjsgLy8gayB+IDEyLTIwXG4gICAgcmVudEZyYWNNYXg/OiBudW1iZXI7IC8vIHJlbnRGcmFjTWF4IH4gMC4zLTAuOFxuICAgIGg/OiBudW1iZXI7IC8vIGggfiAxLTMgKHN0ZWVwbmVzcylcbiAgfVxuKToge1xuICBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXI6IG51bWJlcjtcbiAgc2NhcmNpdHlNdWx0aXBsaWVyOiBudW1iZXI7XG4gIHF1ZXVlUHJlc3N1cmU6IG51bWJlcjtcbiAgdXRpbFByZXNzdXJlOiBudW1iZXI7XG59IHtcbiAgY29uc3Qga0JhY2tsb2dHdyA9IHBhcmFtcz8ua0JhY2tsb2dHdyA/PyAxMDA7IC8vIEtfYmFja2xvZ0dXIH4gNTAtMTUwXG4gIGNvbnN0IHUwID0gcGFyYW1zPy51MCA/PyAwLjg4OyAvLyB1MCB+IDAuODUtMC45MiAoc2NhcmNpdHkgc3RhcnRzIGF0IDg4JSB1dGlsaXphdGlvbilcbiAgY29uc3QgayA9IHBhcmFtcz8uayA/PyAxNjsgLy8gayB+IDEyLTIwIChzdGVlcG5lc3Mgb2YgdXRpbGl6YXRpb24gY3VydmUpXG4gIGNvbnN0IHJlbnRGcmFjTWF4ID0gcGFyYW1zPy5yZW50RnJhY01heCA/PyAwLjU7IC8vIHJlbnRGcmFjTWF4IH4gMC4zLTAuOCAobWF4IHJlbnQgZnJhY3Rpb24pXG4gIGNvbnN0IGggPSBwYXJhbXM/LmggPz8gMi4wOyAvLyBoIH4gMS0zIChzdGVlcG5lc3Mgb2YgcXVldWUgcHJlc3N1cmUpXG4gIFxuICAvLyBRdWV1ZSBwcmVzc3VyZTogYmFja2xvZ0dXIC8gKGJhY2tsb2dHVyArIEtfYmFja2xvZ0dXKVxuICAvLyBTYXR1cmF0ZXMgYXQgMSBhcyBiYWNrbG9nIGdyb3dzXG4gIGNvbnN0IHF1ZXVlUHJlc3N1cmUgPSBiYWNrbG9nR3cgLyAoYmFja2xvZ0d3ICsga0JhY2tsb2dHdyk7XG4gIFxuICAvLyBVdGlsaXphdGlvbiBwcmVzc3VyZTogMSAvICgxICsgZXhwKC1rKih1dGlsaXphdGlvblBjdCAtIHUwKSkpXG4gIC8vIFNpZ21vaWQgdGhhdCByaXNlcyBzaGFycGx5IGFyb3VuZCB1MFxuICBjb25zdCB1dGlsRXhjZXNzID0gdXRpbGl6YXRpb25QY3QgLSB1MDtcbiAgY29uc3QgdXRpbFByZXNzdXJlID0gMSAvICgxICsgTWF0aC5leHAoLWsgKiB1dGlsRXhjZXNzKSk7XG4gIFxuICAvLyBTY2FyY2l0eSBtdWx0aXBsaWVyOiAxICsgcmVudEZyYWNNYXggKiAocXVldWVQcmVzc3VyZV5oKSAqIHV0aWxQcmVzc3VyZVxuICBjb25zdCBzY2FyY2l0eU11bHRpcGxpZXIgPSAxICsgcmVudEZyYWNNYXggKiBNYXRoLnBvdyhxdWV1ZVByZXNzdXJlLCBoKSAqIHV0aWxQcmVzc3VyZTtcbiAgXG4gIC8vIFNjYXJjaXR5IHJlbnQgPSBiYXNlIGNvc3QgKiAoc2NhcmNpdHkgLSAxKVxuICBjb25zdCBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXIgPSBiYXNlQ29zdFBlclBmbG9wWWVhciAqIChzY2FyY2l0eU11bHRpcGxpZXIgLSAxKTtcbiAgXG4gIHJldHVybiB7XG4gICAgc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyLFxuICAgIHNjYXJjaXR5TXVsdGlwbGllcixcbiAgICBxdWV1ZVByZXNzdXJlLFxuICAgIHV0aWxQcmVzc3VyZSxcbiAgfTtcbn1cblxuIl0sIm5hbWVzIjpbImhpbGwiLCJ4IiwieDUwIiwibiIsInhuIiwiTWF0aCIsInBvdyIsIng1MG4iLCJ0aHJlc2hvbGRIaWxsIiwieDAiLCJleGNlc3MiLCJtYXgiLCJjYWxjdWxhdGVTY2FyY2l0eVJlbnQiLCJ3YWl0WWVhcnMiLCJ1dGlsaXphdGlvblBjdCIsInBhcmFtcyIsIlVUSUxfVEhSRVNIT0xEIiwidW5kZWZpbmVkIiwic2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyIiwicmVudEZyYWMiLCJ3YWl0RWZmWWVhcnMiLCJzY2FyY2l0eUhpbGwiLCJoIiwiYXZnV2FpdFllYXJzUmF3IiwiYXZnV2FpdFllYXJzQ2xhbXBlZCIsInc1MCIsIndhaXRUaHJlc2hvbGRZZWFycyIsInJlbnRTaGFwZVAiLCJyZW50TWF4IiwicmVudE1heEZyYWNPZkNhcGV4QW5udWFsIiwidyIsIlNDQVJDSVRZX1JFTlRfUkVGRVJFTkNFX0JBU0UiLCJjYWxjdWxhdGVHcm91bmRDb25zdHJhaW50UGVuYWx0aWVzIiwic3RhdGUiLCJmbG9wc1BlcldhdHRHcm91bmQiLCJwdWVHcm91bmQiLCJjYXBhY2l0eUZhY3Rvckdyb3VuZCIsIndhY2NQYXJhbXMiLCJiYWNrbG9nR3ciLCJhdmdXYWl0WWVhcnMiLCJtYXhCdWlsZFJhdGVHd1llYXIiLCJiYWNrbG9nTXciLCJnZmxvcHNQZXJXYXR0IiwicHJvY2VzcyIsImNvbnNvbGUiLCJ3YXJuIiwiYmFzZVdhY2MiLCJ3YWNjQmFja2xvZ0siLCJ3YWNjQmFja2xvZ0V4cG9uZW50IiwiY3JpdGljYWxCYWNrbG9nR1ciLCJiYWNrbG9nUmF0aW8iLCJ3YWNjTXVsdGlwbGllciIsIndhY2NFZmZlY3RpdmUiLCJXQUNDIiwiQ0FQRVhfUEVSX01XIiwiTE9TVF9NQVJHSU5fUEVSX01XX1lFQVIiLCJMT1NUX01BUkdJTl9DQVBfUEVSX01XIiwiTUFYX1dBSVRfRk9SX0NBUlJZIiwiTUFYX1RPVEFMX1BFTkFMVFlfUEVSX01XX1lFQVIiLCJCQVNFX1NJVEVfQ09TVF9QRVJfTVdfWUVBUiIsIkJBU0VfUFVFIiwiQ0FQRVhfQU1PUlRfUEVSX1BGTE9QX1lFQVJfUkVGRVJFTkNFIiwidGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyIiwiY2FwZXhBdFJpc2tQZXJNVyIsImNhcnJ5Q29zdFBlck1XIiwibG9zdE1hcmdpblBlck1XIiwicGZsb3BzUGVyTVciLCJDQVBFWF9QRVJfUEZMT1BfWUVBUiIsImRlbGF5UGVuYWx0eVVuY2FwcGVkIiwiREVMQVlfQ0FQX0ZSQUMiLCJtaW4iLCJ3YWl0UmVudCIsImJhY2tsb2dSZW50IiwidXRpbFJlbnQiLCJsYW5kU2NhcmNpdHlGYWN0b3IiLCJpbnRlcmNvbm5lY3RTY2FyY2l0eUZhY3RvciIsInNpdGVNdWx0aXBsaWVyIiwiY29vbGluZ1N0cmVzc0ZhY3RvciIsIndhdGVyU3RyZXNzRmFjdG9yIiwicHVlTXVsdGlwbGllciIsIndhY2NCYXNlIiwiY2FsY3VsYXRlSGlsbFNjYXJjaXR5UHJlbWl1bSIsImJhc2VDb3N0UGVyUGZsb3BZZWFyIiwia0JhY2tsb2dHdyIsInUwIiwiayIsInJlbnRGcmFjTWF4IiwicXVldWVQcmVzc3VyZSIsInV0aWxFeGNlc3MiLCJ1dGlsUHJlc3N1cmUiLCJleHAiLCJzY2FyY2l0eU11bHRpcGxpZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/ground_constraint_penalties.ts\n"));

/***/ })

});