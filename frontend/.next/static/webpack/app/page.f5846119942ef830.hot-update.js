"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/model/ground_ramping_mobilization.ts":
/*!******************************************************!*\
  !*** ./app/lib/model/ground_ramping_mobilization.ts ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_MOBILIZATION_PARAMS: function() { return /* binding */ DEFAULT_MOBILIZATION_PARAMS; },\n/* harmony export */   calculateBuildRateGWyr: function() { return /* binding */ calculateBuildRateGWyr; },\n/* harmony export */   calculateDemandGW: function() { return /* binding */ calculateDemandGW; },\n/* harmony export */   calculatePriceResponsiveBuildRateGWyr: function() { return /* binding */ calculatePriceResponsiveBuildRateGWyr; },\n/* harmony export */   calculatePriceResponsiveDemandGW: function() { return /* binding */ calculatePriceResponsiveDemandGW; },\n/* harmony export */   stepMobilizationState: function() { return /* binding */ stepMobilizationState; }\n/* harmony export */ });\n/**\n * Ground Ramping Mobilization Model\n * \n * Models demand growth with price-responsive demand and buildout capacity\n * ramping with investment response. Tracks capacity evolution, pipeline, backlog,\n * and wait times.\n * \n * NEW: Price-responsive demand and investment-responsive buildout (replaces fixed anchors)\n */ /**\n * Calculate price-responsive demand GW\n * \n * NEW: Demand responds to prices, wait times, and orbital substitution\n * Replaces fixed anchors with economic feedback\n */ function calculatePriceResponsiveDemandGW(year, groundPricePerGpuHour, orbitalPricePerGpuHour, avgWaitYears, params) {\n    let pue = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1.3;\n    // Base demand with organic growth (tapered, not exponential forever)\n    const yearsFrom2025 = year - 2025;\n    const growthTaper = Math.tanh(yearsFrom2025 / 30); // Tapers after ~30 years\n    const baseDemand = params.baseDemand2025GW * Math.pow(1 + params.organicGrowthRate, yearsFrom2025 * growthTaper);\n    // Price elasticity: higher prices reduce demand\n    const baselinePrice = 3.50; // $/GPU-hr baseline\n    const priceRatio = groundPricePerGpuHour / baselinePrice;\n    const priceFactor = Math.pow(priceRatio, params.priceElasticity);\n    // Wait elasticity: longer waits reduce demand\n    const waitFactor = Math.exp(-avgWaitYears * params.waitElasticity / 5);\n    // Orbital substitution: if orbital cheaper, demand shifts\n    const orbitalAdvantage = groundPricePerGpuHour / Math.max(orbitalPricePerGpuHour, 0.01);\n    const substitutionFactor = orbitalAdvantage > params.orbitalSubstitutionThreshold ? 1 / (1 + 0.5 * (orbitalAdvantage - params.orbitalSubstitutionThreshold)) : 1.0;\n    let demandGW = baseDemand * priceFactor * waitFactor * substitutionFactor;\n    // Apply PUE if demand is IT load (not facility load)\n    // Note: This function assumes facility load, so multiply by PUE if needed\n    // For now, return facility load (demand already includes PUE in baseDemand2025GW)\n    return Math.max(0, demandGW);\n}\n/**\n * Legacy function: Calculate demand GW using piecewise exponential to hit anchors\n * \n * DEPRECATED: Use calculatePriceResponsiveDemandGW instead\n * Kept for backward compatibility\n */ function calculateDemandGW(year, params) {\n    let pue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1.3;\n    const { demandAnchorsGW, demandIsFacilityLoad, demandCurve } = params;\n    const demand2025 = demandAnchorsGW[2025];\n    const demand2040 = demandAnchorsGW[2040];\n    const demand2060 = demandAnchorsGW[2060];\n    if (demandCurve !== \"piecewise_exponential\") {\n        throw new Error(\"Unsupported demandCurve: \".concat(demandCurve, \". Only 'piecewise_exponential' is supported.\"));\n    }\n    if (year < 2025) {\n        return demand2025;\n    }\n    let demandGW;\n    if (year <= 2040) {\n        // Phase 1: 2025-2040\n        // r1 = ln(demand2040 / demand2025) / (2040-2025)\n        const r1 = Math.log(demand2040 / demand2025) / (2040 - 2025);\n        const yearsFrom2025 = year - 2025;\n        demandGW = demand2025 * Math.exp(r1 * yearsFrom2025);\n    } else {\n        // Phase 2: 2040-2060\n        // r2 = ln(demand2060 / demand2040) / (2060-2040)\n        const r2 = Math.log(demand2060 / demand2040) / (2060 - 2040);\n        const yearsFrom2040 = year - 2040;\n        demandGW = demand2040 * Math.exp(r2 * yearsFrom2040);\n    }\n    // Apply PUE if demand is IT load (not facility load)\n    if (!demandIsFacilityLoad) {\n        demandGW = demandGW * pue;\n    }\n    // Hard asserts in dev mode\n    if (true) {\n        if (year === 2040) {\n            const actual2040 = demandGW;\n            const error2040 = Math.abs(actual2040 - demand2040) / demand2040;\n            if (error2040 >= 0.03) {\n                throw new Error(\"[DEMAND ANCHOR FAIL] demandGw(2040)=\".concat(actual2040.toFixed(2), \" GW, \") + \"expected=\".concat(demand2040, \" GW, error=\").concat((error2040 * 100).toFixed(2), \"% >= 3%\"));\n            }\n        }\n        if (year === 2060) {\n            if (demandGW < 2000) {\n                throw new Error(\"[DEMAND ANCHOR FAIL] demandGw(2060)=\".concat(demandGW.toFixed(2), \" GW < 2000 GW. \") + \"Must be >= 2000 GW (multi-TW target).\");\n            }\n        }\n    }\n    return demandGW;\n}\n/**\n * Calculate price-responsive buildout rate\n * \n * NEW: Buildout responds to margins and backlog\n * Replaces fixed anchors with investment feedback\n */ function calculatePriceResponsiveBuildRateGWyr(year, prevBuildRate, groundMargin, backlogGW, params) {\n    // Base growth (supply chain improvement)\n    const yearsFrom2025 = year - 2025;\n    const baseGrowth = Math.pow(1.03, yearsFrom2025); // 3% organic improvement\n    const baseBuildRate = params.baseBuildRate2025GWyr * baseGrowth;\n    // Investment response: higher margins attract more capital\n    const baselineMargin = 0.20; // 20% baseline margin\n    const marginRatio = groundMargin / baselineMargin;\n    const investmentMultiplier = 1 + params.investmentElasticity * Math.max(0, marginRatio - 1);\n    // Backlog response: higher backlog attracts more investment\n    const backlogMultiplier = 1 + params.backlogResponseK * Math.min(1, backlogGW / 100);\n    // Target build rate\n    let targetRate = baseBuildRate * investmentMultiplier * backlogMultiplier;\n    // Physical ceiling\n    targetRate = Math.min(targetRate, params.maxBuildRateGWyr);\n    // Ramp limit (can't increase faster than 25%/year)\n    const maxRate = prevBuildRate * (1 + params.rampLimitPerYear);\n    const minRate = prevBuildRate * (1 - params.rampLimitPerYear * 0.5); // Slower to decrease\n    targetRate = Math.max(minRate, Math.min(maxRate, targetRate));\n    return Math.max(0, targetRate);\n}\n/**\n * Legacy function: Smooth interpolation for buildout anchors\n * \n * DEPRECATED: Use calculatePriceResponsiveBuildRateGWyr instead\n * Kept for backward compatibility\n */ function calculateBuildRateGWyr(year, params) {\n    const { buildoutAnchorsGWyr, buildoutSmoothingYears } = params;\n    const anchors = buildoutAnchorsGWyr;\n    // Find surrounding anchors\n    const anchorYears = Object.keys(anchors).map(Number).sort((a, b)=>a - b);\n    // Before first anchor: use first anchor value\n    if (year <= anchorYears[0]) {\n        return anchors[anchorYears[0]];\n    }\n    // After last anchor: use last anchor value\n    if (year >= anchorYears[anchorYears.length - 1]) {\n        return anchors[anchorYears[anchorYears.length - 1]];\n    }\n    // Find surrounding anchors\n    let lowerYear = anchorYears[0];\n    let upperYear = anchorYears[anchorYears.length - 1];\n    for(let i = 0; i < anchorYears.length - 1; i++){\n        if (year >= anchorYears[i] && year <= anchorYears[i + 1]) {\n            lowerYear = anchorYears[i];\n            upperYear = anchorYears[i + 1];\n            break;\n        }\n    }\n    const lowerRate = anchors[lowerYear];\n    const upperRate = anchors[upperYear];\n    // Exponential interpolation for buildout ramp\n    const t = (year - lowerYear) / (upperYear - lowerYear);\n    const buildRate = lowerRate * Math.pow(upperRate / lowerRate, t);\n    // Apply smoothing: moving average over smoothing window\n    if (buildoutSmoothingYears > 0) {\n        const smoothingWindow = buildoutSmoothingYears;\n        let smoothedSum = buildRate;\n        let count = 1;\n        // Helper function to calculate unsmoothed rate\n        const getUnsmoothedRate = (y)=>{\n            if (y <= anchorYears[0]) return anchors[anchorYears[0]];\n            if (y >= anchorYears[anchorYears.length - 1]) return anchors[anchorYears[anchorYears.length - 1]];\n            let lower = anchorYears[0];\n            let upper = anchorYears[anchorYears.length - 1];\n            for(let i = 0; i < anchorYears.length - 1; i++){\n                if (y >= anchorYears[i] && y <= anchorYears[i + 1]) {\n                    lower = anchorYears[i];\n                    upper = anchorYears[i + 1];\n                    break;\n                }\n            }\n            const lowerRate = anchors[lower];\n            const upperRate = anchors[upper];\n            const t = (y - lower) / (upper - lower);\n            return lowerRate * Math.pow(upperRate / lowerRate, t);\n        };\n        for(let offset = 1; offset <= Math.floor(smoothingWindow / 2); offset++){\n            const prevYear = year - offset;\n            const nextYear = year + offset;\n            if (prevYear >= anchorYears[0]) {\n                const prevRate = getUnsmoothedRate(prevYear);\n                smoothedSum += prevRate;\n                count++;\n            }\n            if (nextYear <= anchorYears[anchorYears.length - 1]) {\n                const nextRate = getUnsmoothedRate(nextYear);\n                smoothedSum += nextRate;\n                count++;\n            }\n        }\n        return smoothedSum / count;\n    }\n    return buildRate;\n}\n/**\n * Calculate bottleneck rate from anchors (same interpolation as buildout)\n */ function calculateBottleneckRateGWyr(year, anchors) {\n    const anchorYears = [\n        2025,\n        2030,\n        2040,\n        2060\n    ];\n    // Before first anchor: use first anchor value\n    if (year <= anchorYears[0]) {\n        return anchors[2025];\n    }\n    // After last anchor: use last anchor value\n    if (year >= anchorYears[anchorYears.length - 1]) {\n        return anchors[2060];\n    }\n    // Find surrounding anchors\n    let lowerYear = anchorYears[0];\n    let upperYear = anchorYears[anchorYears.length - 1];\n    for(let i = 0; i < anchorYears.length - 1; i++){\n        if (year >= anchorYears[i] && year <= anchorYears[i + 1]) {\n            lowerYear = anchorYears[i];\n            upperYear = anchorYears[i + 1];\n            break;\n        }\n    }\n    const lowerRate = anchors[lowerYear];\n    const upperRate = anchors[upperYear];\n    // Exponential interpolation\n    const t = (year - lowerYear) / (upperYear - lowerYear);\n    return lowerRate * Math.pow(upperRate / lowerRate, t);\n}\n/**\n * Step mobilization state forward one year\n */ function stepMobilizationState(prevState, params, year) {\n    let pue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1.3, retirementsGW = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, orbitalSubstitutionGW = arguments.length > 5 ? arguments[5] : void 0, responsiveDemandGW // Optional: responsive demand (overrides hardcoded calculateDemandGW)\n     = arguments.length > 6 ? arguments[6] : void 0;\n    // Calculate demand: use responsive demand if provided, otherwise use hardcoded\n    // CRITICAL: For backlog buildup, we need demand to grow faster than build rate\n    // If responsive demand is reducing demand too much (price elasticity), backlog won't build\n    let demandGW = responsiveDemandGW !== undefined ? responsiveDemandGW * pue // Convert IT load to facility load\n     : calculateDemandGW(year, params, pue);\n    // FORCE minimum demand growth to ensure backlog builds up (for S-curve)\n    // Even with price elasticity, demand should grow at least 5% per year in early years\n    // This ensures backlog builds up even when price rises (creates S-curve)\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.demandGW) && year <= 2040) {\n        const minDemandGrowth = 0.05; // 5% minimum growth\n        const minDemandGW = prevState.demandGW * (1 + minDemandGrowth);\n        demandGW = Math.max(demandGW, minDemandGW); // Ensure demand doesn't shrink too much\n    }\n    // Fix 2: Calculate demandGWPrev correctly (don't use same responsiveDemandGW for both years)\n    let demandGWPrev;\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.demandGW) !== undefined) {\n        demandGWPrev = prevState.demandGW;\n    } else if (responsiveDemandGW !== undefined) {\n        // For first year, estimate previous year's demand using hardcoded calculation\n        // Don't use same responsiveDemandGW for both current and previous year\n        demandGWPrev = calculateDemandGW(year - 1, params, pue);\n    } else {\n        demandGWPrev = calculateDemandGW(year - 1, params, pue);\n    }\n    const demandNewGW = Math.max(0, demandGW - demandGWPrev);\n    // Calculate build rate candidate (from anchors)\n    let buildRateCandidate = calculateBuildRateGWyr(year, params);\n    // NEW: If ground demand is falling (due to orbital substitution or price elasticity),\n    // buildout should slow down (no one builds capacity for declining market)\n    const demandGrowthRateActual = (prevState === null || prevState === void 0 ? void 0 : prevState.demandGW) ? (demandGW - prevState.demandGW) / Math.max(prevState.demandGW, 1) : 0;\n    if (demandGrowthRateActual < 0) {\n        // Demand is shrinking - reduce buildout\n        const contractionFactor = Math.max(0.5, 1 + demandGrowthRateActual * 2); // At most 50% reduction\n        buildRateCandidate = buildRateCandidate * contractionFactor; // Reassign to let variable\n    }\n    var _params_bottleneckMode;\n    // Apply bottleneck constraints if enabled\n    const bottleneckMode = (_params_bottleneckMode = params.bottleneckMode) !== null && _params_bottleneckMode !== void 0 ? _params_bottleneckMode : \"min_of_bottlenecks\";\n    let buildRateGWyr = buildRateCandidate;\n    let bottleneckRateGWyr;\n    let limitingBottleneck = \"candidate\";\n    if (bottleneckMode === \"min_of_bottlenecks\" && params.bottleneckAnchorsGWyr) {\n        const { transformers, substations, tx, generation } = params.bottleneckAnchorsGWyr;\n        const transformersRate = calculateBottleneckRateGWyr(year, transformers);\n        const substationsRate = calculateBottleneckRateGWyr(year, substations);\n        const txRate = calculateBottleneckRateGWyr(year, tx);\n        const generationRate = calculateBottleneckRateGWyr(year, generation);\n        // Find minimum bottleneck\n        bottleneckRateGWyr = Math.min(transformersRate, substationsRate, txRate, generationRate);\n        // Determine which bottleneck is limiting\n        if (bottleneckRateGWyr === transformersRate) {\n            limitingBottleneck = \"transformers\";\n        } else if (bottleneckRateGWyr === substationsRate) {\n            limitingBottleneck = \"substations\";\n        } else if (bottleneckRateGWyr === txRate) {\n            limitingBottleneck = \"tx\";\n        } else if (bottleneckRateGWyr === generationRate) {\n            limitingBottleneck = \"generation\";\n        }\n        // Effective build rate is minimum of candidate and bottleneck\n        buildRateGWyr = Math.min(buildRateCandidate, bottleneckRateGWyr);\n    } else {\n        limitingBottleneck = \"none\";\n    }\n    var _params_rampLimitFracPerYear;\n    // Apply ramp limiter (prevent sudden jumps)\n    const rampLimitFrac = (_params_rampLimitFracPerYear = params.rampLimitFracPerYear) !== null && _params_rampLimitFracPerYear !== void 0 ? _params_rampLimitFracPerYear : 0.25;\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.buildRateGWyr) !== undefined) {\n        const prevRate = prevState.buildRateGWyr;\n        const minRate = prevRate * (1 - rampLimitFrac);\n        const maxRate = prevRate * (1 + rampLimitFrac);\n        buildRateGWyr = Math.max(minRate, Math.min(maxRate, buildRateGWyr));\n    }\n    var _prevState_capacityGW;\n    // Calculate capacity evolution\n    // capacityGw(t) = capacityGw(t-1) + buildRateGwYear(t) - retirementsGw(t)\n    const capacityGWPrev = (_prevState_capacityGW = prevState === null || prevState === void 0 ? void 0 : prevState.capacityGW) !== null && _prevState_capacityGW !== void 0 ? _prevState_capacityGW : 0;\n    const capacityGW = capacityGWPrev + buildRateGWyr - retirementsGW;\n    // Calculate pipeline\n    // pipelineGw(t) = buildRateGwYear(t) * pipelineLeadTimeYears * pipelineFillFrac\n    const pipelineGW = buildRateGWyr * params.pipelineLeadTimeYears * params.pipelineFillFrac;\n    // Calculate backlog\n    // backlogGw(t) = max(0, backlogGw(t-1) + demandNewGw(t) - buildableGw(t) - implicitBacklogDrain)\n    // NEW: Backlog can also be satisfied by demand shifting to orbital\n    // When demand shifts to orbital, \"implicit backlog drain\" occurs\n    // because customers who were waiting for ground now use orbital instead\n    // Fix 1: Initialize with baseline backlog if no previous state\n    // HIGHER initial backlog to create early scarcity pressure\n    const INITIAL_BACKLOG_GW = 80; // Increased from 50 to create more early scarcity\n    var _prevState_backlogGW;\n    const backlogGWPrev = (_prevState_backlogGW = prevState === null || prevState === void 0 ? void 0 : prevState.backlogGW) !== null && _prevState_backlogGW !== void 0 ? _prevState_backlogGW : INITIAL_BACKLOG_GW;\n    const buildableGW = buildRateGWyr;\n    const implicitBacklogDrain = (orbitalSubstitutionGW !== null && orbitalSubstitutionGW !== void 0 ? orbitalSubstitutionGW : 0) * 0.5; // 50% of shifted demand was in backlog\n    // NEW: Backlog can drain when demand falls below buildout\n    const netDemandChange = demandNewGW - buildableGW;\n    var _prevState_demandGW;\n    // If orbital substitution caused demand to drop, backlog drains faster\n    const demandDropFromPrev = Math.max(0, ((_prevState_demandGW = prevState === null || prevState === void 0 ? void 0 : prevState.demandGW) !== null && _prevState_demandGW !== void 0 ? _prevState_demandGW : demandGW) - demandGW);\n    const substitutionDrain = demandDropFromPrev * 0.3; // 30% of demand drop was from backlog\n    // Fix 3: Ensure backlog reflects demand-capacity gap\n    // If demand >> capacity, backlog must be at least (demand - capacity)\n    const unservedGW = Math.max(0, demandGW - capacityGW);\n    const backlogFloor = unservedGW * 0.5; // At least 50% of unserved is in backlog\n    const backlogGW = Math.max(backlogFloor, Math.max(0, backlogGWPrev + netDemandChange - substitutionDrain - implicitBacklogDrain));\n    // Hard assert: If demandNewGw(t) > buildRateGwYear(t), backlogGw must increase\n    if (true) {\n        if (demandNewGW > buildRateGWyr && backlogGW <= backlogGWPrev) {\n            throw new Error(\"[BUILDOUT INVARIANT] Year \".concat(year, \": demandNewGW=\").concat(demandNewGW.toFixed(2), \" > \") + \"buildRateGWyr=\".concat(buildRateGWyr.toFixed(2), \", but backlogGW=\").concat(backlogGW.toFixed(2), \" \") + \"<= prevBacklogGW=\".concat(backlogGWPrev.toFixed(2), \". Backlog must increase.\"));\n        }\n    }\n    // Calculate average wait time\n    // avgWaitYears(t) = backlogGw(t) / max(buildRateGwYear(t), 1e-9)\n    // Fix 4: Add sanity check - if backlog > 0, wait must be > 0\n    const EPS = 1e-9;\n    const avgWaitYearsRaw = backlogGW / Math.max(buildRateGWyr, EPS);\n    // If backlog > 0, wait must be > 0\n    const avgWaitYears = backlogGW > 0.1 ? Math.max(0.1, avgWaitYearsRaw) : avgWaitYearsRaw;\n    // Calculate growth rate (for debug)\n    let demandGrowthRate;\n    if (year <= 2040) {\n        demandGrowthRate = Math.log(params.demandAnchorsGW[2040] / params.demandAnchorsGW[2025]) / 15;\n    } else {\n        demandGrowthRate = Math.log(params.demandAnchorsGW[2060] / params.demandAnchorsGW[2040]) / 20;\n    }\n    return {\n        year,\n        demandGW,\n        demandNewGW,\n        buildRateGWyr,\n        capacityGW,\n        pipelineGW,\n        backlogGW,\n        avgWaitYears,\n        demandGrowthRate,\n        buildoutSmoothFactor: params.buildoutSmoothingYears,\n        bottleneckRateGWyr,\n        limitingBottleneck,\n        buildRateCandidate\n    };\n}\n/**\n * Default mobilization scenario parameters\n */ const DEFAULT_MOBILIZATION_PARAMS = {\n    demandAnchorsGW: {\n        2025: 120,\n        2040: 450,\n        2060: 3000\n    },\n    demandCurve: \"piecewise_exponential\",\n    demandIsFacilityLoad: true,\n    buildoutAnchorsGWyr: {\n        2025: 15,\n        2030: 50,\n        2040: 140,\n        2060: 220\n    },\n    buildoutSmoothingYears: 3,\n    pipelineLeadTimeYears: 3,\n    pipelineFillFrac: 1.5,\n    bottleneckMode: \"min_of_bottlenecks\",\n    bottleneckAnchorsGWyr: {\n        transformers: {\n            2025: 30,\n            2030: 50,\n            2040: 100,\n            2060: 180\n        },\n        substations: {\n            2025: 35,\n            2030: 55,\n            2040: 110,\n            2060: 200\n        },\n        tx: {\n            2025: 40,\n            2030: 65,\n            2040: 130,\n            2060: 250\n        },\n        generation: {\n            2025: 50,\n            2030: 80,\n            2040: 160,\n            2060: 300\n        }\n    },\n    rampLimitFracPerYear: 0.25\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX3JhbXBpbmdfbW9iaWxpemF0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Ozs7OztDQVFDLEdBbUVEOzs7OztDQUtDLEdBQ00sU0FBU0EsaUNBQ2RDLElBQVksRUFDWkMscUJBQTZCLEVBQzdCQyxzQkFBOEIsRUFDOUJDLFlBQW9CLEVBQ3BCQyxNQUFvQjtRQUNwQkMsTUFBQUEsaUVBQWM7SUFFZCxxRUFBcUU7SUFDckUsTUFBTUMsZ0JBQWdCTixPQUFPO0lBQzdCLE1BQU1PLGNBQWNDLEtBQUtDLElBQUksQ0FBQ0gsZ0JBQWdCLEtBQUsseUJBQXlCO0lBQzVFLE1BQU1JLGFBQWFOLE9BQU9PLGdCQUFnQixHQUFHSCxLQUFLSSxHQUFHLENBQUMsSUFBSVIsT0FBT1MsaUJBQWlCLEVBQUVQLGdCQUFnQkM7SUFFcEcsZ0RBQWdEO0lBQ2hELE1BQU1PLGdCQUFnQixNQUFNLG9CQUFvQjtJQUNoRCxNQUFNQyxhQUFhZCx3QkFBd0JhO0lBQzNDLE1BQU1FLGNBQWNSLEtBQUtJLEdBQUcsQ0FBQ0csWUFBWVgsT0FBT2EsZUFBZTtJQUUvRCw4Q0FBOEM7SUFDOUMsTUFBTUMsYUFBYVYsS0FBS1csR0FBRyxDQUFDLENBQUNoQixlQUFlQyxPQUFPZ0IsY0FBYyxHQUFHO0lBRXBFLDBEQUEwRDtJQUMxRCxNQUFNQyxtQkFBbUJwQix3QkFBd0JPLEtBQUtjLEdBQUcsQ0FBQ3BCLHdCQUF3QjtJQUNsRixNQUFNcUIscUJBQXFCRixtQkFBbUJqQixPQUFPb0IsNEJBQTRCLEdBQzdFLElBQUssS0FBSSxNQUFPSCxDQUFBQSxtQkFBbUJqQixPQUFPb0IsNEJBQTRCLEtBQ3RFO0lBRUosSUFBSUMsV0FBV2YsYUFBYU0sY0FBY0UsYUFBYUs7SUFFdkQscURBQXFEO0lBQ3JELDBFQUEwRTtJQUMxRSxrRkFBa0Y7SUFFbEYsT0FBT2YsS0FBS2MsR0FBRyxDQUFDLEdBQUdHO0FBQ3JCO0FBRUE7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QUNNLE1BQU1vQyw4QkFBMEQ7SUFDckVuSCxpQkFBaUI7UUFDZixNQUFNO1FBQ04sTUFBTTtRQUNOLE1BQU07SUFDUjtJQUNBRSxhQUFhO0lBQ2JELHNCQUFzQjtJQUN0Qm1DLHFCQUFxQjtRQUNuQixNQUFNO1FBQ04sTUFBTTtRQUNOLE1BQU07UUFDTixNQUFNO0lBQ1I7SUFDQUMsd0JBQXdCO0lBQ3hCK0QsdUJBQXVCO0lBQ3ZCQyxrQkFBa0I7SUFDbEJuQixnQkFBZ0I7SUFDaEJJLHVCQUF1QjtRQUNyQkMsY0FBYztZQUFFLE1BQU07WUFBSSxNQUFNO1lBQUksTUFBTTtZQUFLLE1BQU07UUFBSTtRQUN6REMsYUFBYTtZQUFFLE1BQU07WUFBSSxNQUFNO1lBQUksTUFBTTtZQUFLLE1BQU07UUFBSTtRQUN4REMsSUFBSTtZQUFFLE1BQU07WUFBSSxNQUFNO1lBQUksTUFBTTtZQUFLLE1BQU07UUFBSTtRQUMvQ0MsWUFBWTtZQUFFLE1BQU07WUFBSSxNQUFNO1lBQUksTUFBTTtZQUFLLE1BQU07UUFBSTtJQUN6RDtJQUNBTSxzQkFBc0I7QUFDeEIsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvbGliL21vZGVsL2dyb3VuZF9yYW1waW5nX21vYmlsaXphdGlvbi50cz80NDU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR3JvdW5kIFJhbXBpbmcgTW9iaWxpemF0aW9uIE1vZGVsXG4gKiBcbiAqIE1vZGVscyBkZW1hbmQgZ3Jvd3RoIHdpdGggcHJpY2UtcmVzcG9uc2l2ZSBkZW1hbmQgYW5kIGJ1aWxkb3V0IGNhcGFjaXR5XG4gKiByYW1waW5nIHdpdGggaW52ZXN0bWVudCByZXNwb25zZS4gVHJhY2tzIGNhcGFjaXR5IGV2b2x1dGlvbiwgcGlwZWxpbmUsIGJhY2tsb2csXG4gKiBhbmQgd2FpdCB0aW1lcy5cbiAqIFxuICogTkVXOiBQcmljZS1yZXNwb25zaXZlIGRlbWFuZCBhbmQgaW52ZXN0bWVudC1yZXNwb25zaXZlIGJ1aWxkb3V0IChyZXBsYWNlcyBmaXhlZCBhbmNob3JzKVxuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVtYW5kUGFyYW1zIHtcbiAgYmFzZURlbWFuZDIwMjVHVzogbnVtYmVyOyAgICAgICAgLy8gMTIwIEdXXG4gIG9yZ2FuaWNHcm93dGhSYXRlOiBudW1iZXI7ICAgICAgIC8vIDAuMTAgKDEwJSBDQUdSIGJhc2UpXG4gIHByaWNlRWxhc3RpY2l0eTogbnVtYmVyOyAgICAgICAgIC8vIC0wLjMgKDMwJSBkZW1hbmQgZHJvcCBwZXIgMTAwJSBwcmljZSBpbmNyZWFzZSlcbiAgd2FpdEVsYXN0aWNpdHk6IG51bWJlcjsgICAgICAgICAgLy8gLTAuMiAoMjAlIGRlbWFuZCBkcm9wIHBlciA1eXIgd2FpdClcbiAgb3JiaXRhbFN1YnN0aXR1dGlvblRocmVzaG9sZDogbnVtYmVyOyAvLyBQcmljZSByYXRpbyBhdCB3aGljaCBkZW1hbmQgc2hpZnRzIHRvIG9yYml0YWwgKGRlZmF1bHQgMS4yID0gMjAlIGNoZWFwZXIpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnVpbGRvdXRQYXJhbXMge1xuICBiYXNlQnVpbGRSYXRlMjAyNUdXeXI6IG51bWJlcjsgICAvLyAyNSBHVy95clxuICBtYXhCdWlsZFJhdGVHV3lyOiBudW1iZXI7ICAgICAgICAvLyAxNTAgR1cveXIgcGh5c2ljYWwgbGltaXRcbiAgaW52ZXN0bWVudEVsYXN0aWNpdHk6IG51bWJlcjsgICAgIC8vIDAuNSAoNTAlIG1vcmUgaW52ZXN0bWVudCBwZXIgMTAwJSBtYXJnaW4gaW5jcmVhc2UpXG4gIHJhbXBMaW1pdFBlclllYXI6IG51bWJlcjsgICAgICAgICAvLyAwLjI1ICgyNSUgbWF4IGluY3JlYXNlIHBlciB5ZWFyKVxuICBiYWNrbG9nUmVzcG9uc2VLOiBudW1iZXI7ICAgICAgICAgLy8gMC4zIChob3cgZmFzdCBidWlsZG91dCByZXNwb25kcyB0byBiYWNrbG9nKVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vYmlsaXphdGlvblNjZW5hcmlvUGFyYW1zIHtcbiAgZGVtYW5kQW5jaG9yc0dXOiB7XG4gICAgMjAyNTogbnVtYmVyO1xuICAgIDIwNDA6IG51bWJlcjtcbiAgICAyMDYwOiBudW1iZXI7XG4gIH07XG4gIGRlbWFuZEN1cnZlOiAncGllY2V3aXNlX2V4cG9uZW50aWFsJzsgLy8gQ3VydmUgdHlwZSAob25seSBwaWVjZXdpc2VfZXhwb25lbnRpYWwgc3VwcG9ydGVkKVxuICBkZW1hbmRJc0ZhY2lsaXR5TG9hZDogYm9vbGVhbjsgLy8gSWYgdHJ1ZSwgaW5jbHVkZXMgUFVFOyBpZiBmYWxzZSwgbXVsdGlwbHkgYnkgUFVFIGxhdGVyXG4gIGJ1aWxkb3V0QW5jaG9yc0dXeXI6IHtcbiAgICAyMDI1OiBudW1iZXI7XG4gICAgMjAzMDogbnVtYmVyO1xuICAgIDIwNDA6IG51bWJlcjtcbiAgICAyMDYwOiBudW1iZXI7XG4gIH07XG4gIGJ1aWxkb3V0U21vb3RoaW5nWWVhcnM6IG51bWJlcjsgLy8gU21vb3RoaW5nIHdpbmRvdyBmb3IgYnVpbGRvdXQgaW50ZXJwb2xhdGlvblxuICBwaXBlbGluZUxlYWRUaW1lWWVhcnM6IG51bWJlcjsgLy8gTGVhZCB0aW1lIGZvciBwaXBlbGluZSBjYWxjdWxhdGlvblxuICBwaXBlbGluZUZpbGxGcmFjOiBudW1iZXI7IC8vIFBpcGVsaW5lIGZpbGwgZnJhY3Rpb24gKHBpcGVsaW5lR1cgPSBsZWFkVGltZSAqIGJ1aWxkUmF0ZSAqIGZpbGxGcmFjKVxuICAvLyBCb3R0bGVuZWNrIGNvbnN0cmFpbnRzXG4gIGJvdHRsZW5lY2tNb2RlPzogJ29mZicgfCAnbWluX29mX2JvdHRsZW5lY2tzJzsgLy8gRGVmYXVsdCAnbWluX29mX2JvdHRsZW5lY2tzJ1xuICBib3R0bGVuZWNrQW5jaG9yc0dXeXI/OiB7XG4gICAgdHJhbnNmb3JtZXJzOiB7IDIwMjU6IG51bWJlcjsgMjAzMDogbnVtYmVyOyAyMDQwOiBudW1iZXI7IDIwNjA6IG51bWJlciB9O1xuICAgIHN1YnN0YXRpb25zOiB7IDIwMjU6IG51bWJlcjsgMjAzMDogbnVtYmVyOyAyMDQwOiBudW1iZXI7IDIwNjA6IG51bWJlciB9O1xuICAgIHR4OiB7IDIwMjU6IG51bWJlcjsgMjAzMDogbnVtYmVyOyAyMDQwOiBudW1iZXI7IDIwNjA6IG51bWJlciB9O1xuICAgIGdlbmVyYXRpb246IHsgMjAyNTogbnVtYmVyOyAyMDMwOiBudW1iZXI7IDIwNDA6IG51bWJlcjsgMjA2MDogbnVtYmVyIH07XG4gIH07XG4gIHJhbXBMaW1pdEZyYWNQZXJZZWFyPzogbnVtYmVyOyAvLyBNYXggZnJhY3Rpb25hbCBjaGFuZ2UgcGVyIHllYXIgKGRlZmF1bHQgMC4yNSA9IDI1JSlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb2JpbGl6YXRpb25TdGF0ZSB7XG4gIHllYXI6IG51bWJlcjtcbiAgZGVtYW5kR1c6IG51bWJlcjsgLy8gVG90YWwgZGVtYW5kIChJVCBvciBmYWNpbGl0eSBsb2FkKVxuICBkZW1hbmROZXdHVzogbnVtYmVyOyAvLyBJbmNyZW1lbnRhbCBkZW1hbmQgdGhpcyB5ZWFyXG4gIGJ1aWxkUmF0ZUdXeXI6IG51bWJlcjsgLy8gQnVpbGQgcmF0ZSB0aGlzIHllYXIgKEdXL3llYXIpXG4gIGNhcGFjaXR5R1c6IG51bWJlcjsgLy8gQ3VtdWxhdGl2ZSBjYXBhY2l0eSBidWlsdFxuICBwaXBlbGluZUdXOiBudW1iZXI7IC8vIFBpcGVsaW5lIGNhcGFjaXR5ICh1bmRlciBjb25zdHJ1Y3Rpb24pXG4gIGJhY2tsb2dHVzogbnVtYmVyOyAvLyBCYWNrbG9nIHdhaXRpbmcgdG8gYmUgYnVpbHRcbiAgYXZnV2FpdFllYXJzOiBudW1iZXI7IC8vIEF2ZXJhZ2Ugd2FpdCB0aW1lIChiYWNrbG9nIC8gYnVpbGRSYXRlKVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vYmlsaXphdGlvblJlc3VsdCBleHRlbmRzIE1vYmlsaXphdGlvblN0YXRlIHtcbiAgLy8gQWRkaXRpb25hbCBkZWJ1ZyBmaWVsZHNcbiAgZGVtYW5kR3Jvd3RoUmF0ZTogbnVtYmVyOyAvLyBDdXJyZW50IGdyb3d0aCByYXRlIChyMSBvciByMilcbiAgYnVpbGRvdXRTbW9vdGhGYWN0b3I6IG51bWJlcjsgLy8gU21vb3RoaW5nIGZhY3RvciBhcHBsaWVkXG4gIC8vIEJvdHRsZW5lY2sgZGVidWcgZmllbGRzXG4gIGJvdHRsZW5lY2tSYXRlR1d5cj86IG51bWJlcjsgLy8gRWZmZWN0aXZlIGJvdHRsZW5lY2sgcmF0ZSAobWluIG9mIGFsbCBib3R0bGVuZWNrcylcbiAgbGltaXRpbmdCb3R0bGVuZWNrPzogJ3RyYW5zZm9ybWVycycgfCAnc3Vic3RhdGlvbnMnIHwgJ3R4JyB8ICdnZW5lcmF0aW9uJyB8ICdjYW5kaWRhdGUnIHwgJ25vbmUnOyAvLyBXaGljaCBib3R0bGVuZWNrIGlzIGxpbWl0aW5nXG4gIGJ1aWxkUmF0ZUNhbmRpZGF0ZT86IG51bWJlcjsgLy8gT3JpZ2luYWwgYnVpbGQgcmF0ZSBiZWZvcmUgYm90dGxlbmVjay9yYW1wIGxpbWl0c1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBwcmljZS1yZXNwb25zaXZlIGRlbWFuZCBHV1xuICogXG4gKiBORVc6IERlbWFuZCByZXNwb25kcyB0byBwcmljZXMsIHdhaXQgdGltZXMsIGFuZCBvcmJpdGFsIHN1YnN0aXR1dGlvblxuICogUmVwbGFjZXMgZml4ZWQgYW5jaG9ycyB3aXRoIGVjb25vbWljIGZlZWRiYWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVQcmljZVJlc3BvbnNpdmVEZW1hbmRHVyhcbiAgeWVhcjogbnVtYmVyLFxuICBncm91bmRQcmljZVBlckdwdUhvdXI6IG51bWJlcixcbiAgb3JiaXRhbFByaWNlUGVyR3B1SG91cjogbnVtYmVyLFxuICBhdmdXYWl0WWVhcnM6IG51bWJlcixcbiAgcGFyYW1zOiBEZW1hbmRQYXJhbXMsXG4gIHB1ZTogbnVtYmVyID0gMS4zXG4pOiBudW1iZXIge1xuICAvLyBCYXNlIGRlbWFuZCB3aXRoIG9yZ2FuaWMgZ3Jvd3RoICh0YXBlcmVkLCBub3QgZXhwb25lbnRpYWwgZm9yZXZlcilcbiAgY29uc3QgeWVhcnNGcm9tMjAyNSA9IHllYXIgLSAyMDI1O1xuICBjb25zdCBncm93dGhUYXBlciA9IE1hdGgudGFuaCh5ZWFyc0Zyb20yMDI1IC8gMzApOyAvLyBUYXBlcnMgYWZ0ZXIgfjMwIHllYXJzXG4gIGNvbnN0IGJhc2VEZW1hbmQgPSBwYXJhbXMuYmFzZURlbWFuZDIwMjVHVyAqIE1hdGgucG93KDEgKyBwYXJhbXMub3JnYW5pY0dyb3d0aFJhdGUsIHllYXJzRnJvbTIwMjUgKiBncm93dGhUYXBlcik7XG4gIFxuICAvLyBQcmljZSBlbGFzdGljaXR5OiBoaWdoZXIgcHJpY2VzIHJlZHVjZSBkZW1hbmRcbiAgY29uc3QgYmFzZWxpbmVQcmljZSA9IDMuNTA7IC8vICQvR1BVLWhyIGJhc2VsaW5lXG4gIGNvbnN0IHByaWNlUmF0aW8gPSBncm91bmRQcmljZVBlckdwdUhvdXIgLyBiYXNlbGluZVByaWNlO1xuICBjb25zdCBwcmljZUZhY3RvciA9IE1hdGgucG93KHByaWNlUmF0aW8sIHBhcmFtcy5wcmljZUVsYXN0aWNpdHkpO1xuICBcbiAgLy8gV2FpdCBlbGFzdGljaXR5OiBsb25nZXIgd2FpdHMgcmVkdWNlIGRlbWFuZFxuICBjb25zdCB3YWl0RmFjdG9yID0gTWF0aC5leHAoLWF2Z1dhaXRZZWFycyAqIHBhcmFtcy53YWl0RWxhc3RpY2l0eSAvIDUpO1xuICBcbiAgLy8gT3JiaXRhbCBzdWJzdGl0dXRpb246IGlmIG9yYml0YWwgY2hlYXBlciwgZGVtYW5kIHNoaWZ0c1xuICBjb25zdCBvcmJpdGFsQWR2YW50YWdlID0gZ3JvdW5kUHJpY2VQZXJHcHVIb3VyIC8gTWF0aC5tYXgob3JiaXRhbFByaWNlUGVyR3B1SG91ciwgMC4wMSk7XG4gIGNvbnN0IHN1YnN0aXR1dGlvbkZhY3RvciA9IG9yYml0YWxBZHZhbnRhZ2UgPiBwYXJhbXMub3JiaXRhbFN1YnN0aXR1dGlvblRocmVzaG9sZCBcbiAgICA/IDEgLyAoMSArIDAuNSAqIChvcmJpdGFsQWR2YW50YWdlIC0gcGFyYW1zLm9yYml0YWxTdWJzdGl0dXRpb25UaHJlc2hvbGQpKVxuICAgIDogMS4wO1xuICBcbiAgbGV0IGRlbWFuZEdXID0gYmFzZURlbWFuZCAqIHByaWNlRmFjdG9yICogd2FpdEZhY3RvciAqIHN1YnN0aXR1dGlvbkZhY3RvcjtcbiAgXG4gIC8vIEFwcGx5IFBVRSBpZiBkZW1hbmQgaXMgSVQgbG9hZCAobm90IGZhY2lsaXR5IGxvYWQpXG4gIC8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBmYWNpbGl0eSBsb2FkLCBzbyBtdWx0aXBseSBieSBQVUUgaWYgbmVlZGVkXG4gIC8vIEZvciBub3csIHJldHVybiBmYWNpbGl0eSBsb2FkIChkZW1hbmQgYWxyZWFkeSBpbmNsdWRlcyBQVUUgaW4gYmFzZURlbWFuZDIwMjVHVylcbiAgXG4gIHJldHVybiBNYXRoLm1heCgwLCBkZW1hbmRHVyk7XG59XG5cbi8qKlxuICogTGVnYWN5IGZ1bmN0aW9uOiBDYWxjdWxhdGUgZGVtYW5kIEdXIHVzaW5nIHBpZWNld2lzZSBleHBvbmVudGlhbCB0byBoaXQgYW5jaG9yc1xuICogXG4gKiBERVBSRUNBVEVEOiBVc2UgY2FsY3VsYXRlUHJpY2VSZXNwb25zaXZlRGVtYW5kR1cgaW5zdGVhZFxuICogS2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRGVtYW5kR1coXG4gIHllYXI6IG51bWJlcixcbiAgcGFyYW1zOiBNb2JpbGl6YXRpb25TY2VuYXJpb1BhcmFtcyxcbiAgcHVlOiBudW1iZXIgPSAxLjNcbik6IG51bWJlciB7XG4gIGNvbnN0IHsgZGVtYW5kQW5jaG9yc0dXLCBkZW1hbmRJc0ZhY2lsaXR5TG9hZCwgZGVtYW5kQ3VydmUgfSA9IHBhcmFtcztcbiAgY29uc3QgZGVtYW5kMjAyNSA9IGRlbWFuZEFuY2hvcnNHV1syMDI1XTtcbiAgY29uc3QgZGVtYW5kMjA0MCA9IGRlbWFuZEFuY2hvcnNHV1syMDQwXTtcbiAgY29uc3QgZGVtYW5kMjA2MCA9IGRlbWFuZEFuY2hvcnNHV1syMDYwXTtcbiAgXG4gIGlmIChkZW1hbmRDdXJ2ZSAhPT0gJ3BpZWNld2lzZV9leHBvbmVudGlhbCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlbWFuZEN1cnZlOiAke2RlbWFuZEN1cnZlfS4gT25seSAncGllY2V3aXNlX2V4cG9uZW50aWFsJyBpcyBzdXBwb3J0ZWQuYCk7XG4gIH1cbiAgXG4gIGlmICh5ZWFyIDwgMjAyNSkge1xuICAgIHJldHVybiBkZW1hbmQyMDI1O1xuICB9XG4gIFxuICBsZXQgZGVtYW5kR1c6IG51bWJlcjtcbiAgXG4gIGlmICh5ZWFyIDw9IDIwNDApIHtcbiAgICAvLyBQaGFzZSAxOiAyMDI1LTIwNDBcbiAgICAvLyByMSA9IGxuKGRlbWFuZDIwNDAgLyBkZW1hbmQyMDI1KSAvICgyMDQwLTIwMjUpXG4gICAgY29uc3QgcjEgPSBNYXRoLmxvZyhkZW1hbmQyMDQwIC8gZGVtYW5kMjAyNSkgLyAoMjA0MCAtIDIwMjUpO1xuICAgIGNvbnN0IHllYXJzRnJvbTIwMjUgPSB5ZWFyIC0gMjAyNTtcbiAgICBkZW1hbmRHVyA9IGRlbWFuZDIwMjUgKiBNYXRoLmV4cChyMSAqIHllYXJzRnJvbTIwMjUpO1xuICB9IGVsc2Uge1xuICAgIC8vIFBoYXNlIDI6IDIwNDAtMjA2MFxuICAgIC8vIHIyID0gbG4oZGVtYW5kMjA2MCAvIGRlbWFuZDIwNDApIC8gKDIwNjAtMjA0MClcbiAgICBjb25zdCByMiA9IE1hdGgubG9nKGRlbWFuZDIwNjAgLyBkZW1hbmQyMDQwKSAvICgyMDYwIC0gMjA0MCk7XG4gICAgY29uc3QgeWVhcnNGcm9tMjA0MCA9IHllYXIgLSAyMDQwO1xuICAgIGRlbWFuZEdXID0gZGVtYW5kMjA0MCAqIE1hdGguZXhwKHIyICogeWVhcnNGcm9tMjA0MCk7XG4gIH1cbiAgXG4gIC8vIEFwcGx5IFBVRSBpZiBkZW1hbmQgaXMgSVQgbG9hZCAobm90IGZhY2lsaXR5IGxvYWQpXG4gIGlmICghZGVtYW5kSXNGYWNpbGl0eUxvYWQpIHtcbiAgICBkZW1hbmRHVyA9IGRlbWFuZEdXICogcHVlO1xuICB9XG4gIFxuICAvLyBIYXJkIGFzc2VydHMgaW4gZGV2IG1vZGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgaWYgKHllYXIgPT09IDIwNDApIHtcbiAgICAgIGNvbnN0IGFjdHVhbDIwNDAgPSBkZW1hbmRHVztcbiAgICAgIGNvbnN0IGVycm9yMjA0MCA9IE1hdGguYWJzKGFjdHVhbDIwNDAgLSBkZW1hbmQyMDQwKSAvIGRlbWFuZDIwNDA7XG4gICAgICBpZiAoZXJyb3IyMDQwID49IDAuMDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBbREVNQU5EIEFOQ0hPUiBGQUlMXSBkZW1hbmRHdygyMDQwKT0ke2FjdHVhbDIwNDAudG9GaXhlZCgyKX0gR1csIGAgK1xuICAgICAgICAgIGBleHBlY3RlZD0ke2RlbWFuZDIwNDB9IEdXLCBlcnJvcj0keyhlcnJvcjIwNDAgKiAxMDApLnRvRml4ZWQoMil9JSA+PSAzJWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKHllYXIgPT09IDIwNjApIHtcbiAgICAgIGlmIChkZW1hbmRHVyA8IDIwMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBbREVNQU5EIEFOQ0hPUiBGQUlMXSBkZW1hbmRHdygyMDYwKT0ke2RlbWFuZEdXLnRvRml4ZWQoMil9IEdXIDwgMjAwMCBHVy4gYCArXG4gICAgICAgICAgYE11c3QgYmUgPj0gMjAwMCBHVyAobXVsdGktVFcgdGFyZ2V0KS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gZGVtYW5kR1c7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHByaWNlLXJlc3BvbnNpdmUgYnVpbGRvdXQgcmF0ZVxuICogXG4gKiBORVc6IEJ1aWxkb3V0IHJlc3BvbmRzIHRvIG1hcmdpbnMgYW5kIGJhY2tsb2dcbiAqIFJlcGxhY2VzIGZpeGVkIGFuY2hvcnMgd2l0aCBpbnZlc3RtZW50IGZlZWRiYWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVQcmljZVJlc3BvbnNpdmVCdWlsZFJhdGVHV3lyKFxuICB5ZWFyOiBudW1iZXIsXG4gIHByZXZCdWlsZFJhdGU6IG51bWJlcixcbiAgZ3JvdW5kTWFyZ2luOiBudW1iZXIsICAvLyBDdXJyZW50IHByb2ZpdCBtYXJnaW4gKHByaWNlIC0gY29zdCkgLyBjb3N0XG4gIGJhY2tsb2dHVzogbnVtYmVyLFxuICBwYXJhbXM6IEJ1aWxkb3V0UGFyYW1zXG4pOiBudW1iZXIge1xuICAvLyBCYXNlIGdyb3d0aCAoc3VwcGx5IGNoYWluIGltcHJvdmVtZW50KVxuICBjb25zdCB5ZWFyc0Zyb20yMDI1ID0geWVhciAtIDIwMjU7XG4gIGNvbnN0IGJhc2VHcm93dGggPSBNYXRoLnBvdygxLjAzLCB5ZWFyc0Zyb20yMDI1KTsgLy8gMyUgb3JnYW5pYyBpbXByb3ZlbWVudFxuICBjb25zdCBiYXNlQnVpbGRSYXRlID0gcGFyYW1zLmJhc2VCdWlsZFJhdGUyMDI1R1d5ciAqIGJhc2VHcm93dGg7XG4gIFxuICAvLyBJbnZlc3RtZW50IHJlc3BvbnNlOiBoaWdoZXIgbWFyZ2lucyBhdHRyYWN0IG1vcmUgY2FwaXRhbFxuICBjb25zdCBiYXNlbGluZU1hcmdpbiA9IDAuMjA7IC8vIDIwJSBiYXNlbGluZSBtYXJnaW5cbiAgY29uc3QgbWFyZ2luUmF0aW8gPSBncm91bmRNYXJnaW4gLyBiYXNlbGluZU1hcmdpbjtcbiAgY29uc3QgaW52ZXN0bWVudE11bHRpcGxpZXIgPSAxICsgcGFyYW1zLmludmVzdG1lbnRFbGFzdGljaXR5ICogTWF0aC5tYXgoMCwgbWFyZ2luUmF0aW8gLSAxKTtcbiAgXG4gIC8vIEJhY2tsb2cgcmVzcG9uc2U6IGhpZ2hlciBiYWNrbG9nIGF0dHJhY3RzIG1vcmUgaW52ZXN0bWVudFxuICBjb25zdCBiYWNrbG9nTXVsdGlwbGllciA9IDEgKyBwYXJhbXMuYmFja2xvZ1Jlc3BvbnNlSyAqIE1hdGgubWluKDEsIGJhY2tsb2dHVyAvIDEwMCk7XG4gIFxuICAvLyBUYXJnZXQgYnVpbGQgcmF0ZVxuICBsZXQgdGFyZ2V0UmF0ZSA9IGJhc2VCdWlsZFJhdGUgKiBpbnZlc3RtZW50TXVsdGlwbGllciAqIGJhY2tsb2dNdWx0aXBsaWVyO1xuICBcbiAgLy8gUGh5c2ljYWwgY2VpbGluZ1xuICB0YXJnZXRSYXRlID0gTWF0aC5taW4odGFyZ2V0UmF0ZSwgcGFyYW1zLm1heEJ1aWxkUmF0ZUdXeXIpO1xuICBcbiAgLy8gUmFtcCBsaW1pdCAoY2FuJ3QgaW5jcmVhc2UgZmFzdGVyIHRoYW4gMjUlL3llYXIpXG4gIGNvbnN0IG1heFJhdGUgPSBwcmV2QnVpbGRSYXRlICogKDEgKyBwYXJhbXMucmFtcExpbWl0UGVyWWVhcik7XG4gIGNvbnN0IG1pblJhdGUgPSBwcmV2QnVpbGRSYXRlICogKDEgLSBwYXJhbXMucmFtcExpbWl0UGVyWWVhciAqIDAuNSk7IC8vIFNsb3dlciB0byBkZWNyZWFzZVxuICB0YXJnZXRSYXRlID0gTWF0aC5tYXgobWluUmF0ZSwgTWF0aC5taW4obWF4UmF0ZSwgdGFyZ2V0UmF0ZSkpO1xuICBcbiAgcmV0dXJuIE1hdGgubWF4KDAsIHRhcmdldFJhdGUpO1xufVxuXG4vKipcbiAqIExlZ2FjeSBmdW5jdGlvbjogU21vb3RoIGludGVycG9sYXRpb24gZm9yIGJ1aWxkb3V0IGFuY2hvcnNcbiAqIFxuICogREVQUkVDQVRFRDogVXNlIGNhbGN1bGF0ZVByaWNlUmVzcG9uc2l2ZUJ1aWxkUmF0ZUdXeXIgaW5zdGVhZFxuICogS2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQnVpbGRSYXRlR1d5cihcbiAgeWVhcjogbnVtYmVyLFxuICBwYXJhbXM6IE1vYmlsaXphdGlvblNjZW5hcmlvUGFyYW1zXG4pOiBudW1iZXIge1xuICBjb25zdCB7IGJ1aWxkb3V0QW5jaG9yc0dXeXIsIGJ1aWxkb3V0U21vb3RoaW5nWWVhcnMgfSA9IHBhcmFtcztcbiAgY29uc3QgYW5jaG9ycyA9IGJ1aWxkb3V0QW5jaG9yc0dXeXI7XG4gIFxuICAvLyBGaW5kIHN1cnJvdW5kaW5nIGFuY2hvcnNcbiAgY29uc3QgYW5jaG9yWWVhcnMgPSBPYmplY3Qua2V5cyhhbmNob3JzKS5tYXAoTnVtYmVyKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIFxuICAvLyBCZWZvcmUgZmlyc3QgYW5jaG9yOiB1c2UgZmlyc3QgYW5jaG9yIHZhbHVlXG4gIGlmICh5ZWFyIDw9IGFuY2hvclllYXJzWzBdKSB7XG4gICAgcmV0dXJuIGFuY2hvcnNbYW5jaG9yWWVhcnNbMF0gYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICB9XG4gIFxuICAvLyBBZnRlciBsYXN0IGFuY2hvcjogdXNlIGxhc3QgYW5jaG9yIHZhbHVlXG4gIGlmICh5ZWFyID49IGFuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdKSB7XG4gICAgcmV0dXJuIGFuY2hvcnNbYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV0gYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICB9XG4gIFxuICAvLyBGaW5kIHN1cnJvdW5kaW5nIGFuY2hvcnNcbiAgbGV0IGxvd2VyWWVhciA9IGFuY2hvclllYXJzWzBdO1xuICBsZXQgdXBwZXJZZWFyID0gYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV07XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFuY2hvclllYXJzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmICh5ZWFyID49IGFuY2hvclllYXJzW2ldICYmIHllYXIgPD0gYW5jaG9yWWVhcnNbaSArIDFdKSB7XG4gICAgICBsb3dlclllYXIgPSBhbmNob3JZZWFyc1tpXTtcbiAgICAgIHVwcGVyWWVhciA9IGFuY2hvclllYXJzW2kgKyAxXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBcbiAgY29uc3QgbG93ZXJSYXRlID0gYW5jaG9yc1tsb3dlclllYXIgYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICBjb25zdCB1cHBlclJhdGUgPSBhbmNob3JzW3VwcGVyWWVhciBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gIFxuICAvLyBFeHBvbmVudGlhbCBpbnRlcnBvbGF0aW9uIGZvciBidWlsZG91dCByYW1wXG4gIGNvbnN0IHQgPSAoeWVhciAtIGxvd2VyWWVhcikgLyAodXBwZXJZZWFyIC0gbG93ZXJZZWFyKTtcbiAgY29uc3QgYnVpbGRSYXRlID0gbG93ZXJSYXRlICogTWF0aC5wb3codXBwZXJSYXRlIC8gbG93ZXJSYXRlLCB0KTtcbiAgXG4gIC8vIEFwcGx5IHNtb290aGluZzogbW92aW5nIGF2ZXJhZ2Ugb3ZlciBzbW9vdGhpbmcgd2luZG93XG4gIGlmIChidWlsZG91dFNtb290aGluZ1llYXJzID4gMCkge1xuICAgIGNvbnN0IHNtb290aGluZ1dpbmRvdyA9IGJ1aWxkb3V0U21vb3RoaW5nWWVhcnM7XG4gICAgbGV0IHNtb290aGVkU3VtID0gYnVpbGRSYXRlO1xuICAgIGxldCBjb3VudCA9IDE7XG4gICAgXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSB1bnNtb290aGVkIHJhdGVcbiAgICBjb25zdCBnZXRVbnNtb290aGVkUmF0ZSA9ICh5OiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgICAgaWYgKHkgPD0gYW5jaG9yWWVhcnNbMF0pIHJldHVybiBhbmNob3JzW2FuY2hvclllYXJzWzBdIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgICAgIGlmICh5ID49IGFuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdKSByZXR1cm4gYW5jaG9yc1thbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXSBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gICAgICBcbiAgICAgIGxldCBsb3dlciA9IGFuY2hvclllYXJzWzBdO1xuICAgICAgbGV0IHVwcGVyID0gYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFuY2hvclllYXJzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoeSA+PSBhbmNob3JZZWFyc1tpXSAmJiB5IDw9IGFuY2hvclllYXJzW2kgKyAxXSkge1xuICAgICAgICAgIGxvd2VyID0gYW5jaG9yWWVhcnNbaV07XG4gICAgICAgICAgdXBwZXIgPSBhbmNob3JZZWFyc1tpICsgMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgbG93ZXJSYXRlID0gYW5jaG9yc1tsb3dlciBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gICAgICBjb25zdCB1cHBlclJhdGUgPSBhbmNob3JzW3VwcGVyIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgICAgIGNvbnN0IHQgPSAoeSAtIGxvd2VyKSAvICh1cHBlciAtIGxvd2VyKTtcbiAgICAgIHJldHVybiBsb3dlclJhdGUgKiBNYXRoLnBvdyh1cHBlclJhdGUgLyBsb3dlclJhdGUsIHQpO1xuICAgIH07XG4gICAgXG4gICAgZm9yIChsZXQgb2Zmc2V0ID0gMTsgb2Zmc2V0IDw9IE1hdGguZmxvb3Ioc21vb3RoaW5nV2luZG93IC8gMik7IG9mZnNldCsrKSB7XG4gICAgICBjb25zdCBwcmV2WWVhciA9IHllYXIgLSBvZmZzZXQ7XG4gICAgICBjb25zdCBuZXh0WWVhciA9IHllYXIgKyBvZmZzZXQ7XG4gICAgICBcbiAgICAgIGlmIChwcmV2WWVhciA+PSBhbmNob3JZZWFyc1swXSkge1xuICAgICAgICBjb25zdCBwcmV2UmF0ZSA9IGdldFVuc21vb3RoZWRSYXRlKHByZXZZZWFyKTtcbiAgICAgICAgc21vb3RoZWRTdW0gKz0gcHJldlJhdGU7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChuZXh0WWVhciA8PSBhbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXSkge1xuICAgICAgICBjb25zdCBuZXh0UmF0ZSA9IGdldFVuc21vb3RoZWRSYXRlKG5leHRZZWFyKTtcbiAgICAgICAgc21vb3RoZWRTdW0gKz0gbmV4dFJhdGU7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBzbW9vdGhlZFN1bSAvIGNvdW50O1xuICB9XG4gIFxuICByZXR1cm4gYnVpbGRSYXRlO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBib3R0bGVuZWNrIHJhdGUgZnJvbSBhbmNob3JzIChzYW1lIGludGVycG9sYXRpb24gYXMgYnVpbGRvdXQpXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUJvdHRsZW5lY2tSYXRlR1d5cihcbiAgeWVhcjogbnVtYmVyLFxuICBhbmNob3JzOiB7IDIwMjU6IG51bWJlcjsgMjAzMDogbnVtYmVyOyAyMDQwOiBudW1iZXI7IDIwNjA6IG51bWJlciB9XG4pOiBudW1iZXIge1xuICBjb25zdCBhbmNob3JZZWFycyA9IFsyMDI1LCAyMDMwLCAyMDQwLCAyMDYwXSBhcyBjb25zdDtcbiAgXG4gIC8vIEJlZm9yZSBmaXJzdCBhbmNob3I6IHVzZSBmaXJzdCBhbmNob3IgdmFsdWVcbiAgaWYgKHllYXIgPD0gYW5jaG9yWWVhcnNbMF0pIHtcbiAgICByZXR1cm4gYW5jaG9yc1syMDI1XTtcbiAgfVxuICBcbiAgLy8gQWZ0ZXIgbGFzdCBhbmNob3I6IHVzZSBsYXN0IGFuY2hvciB2YWx1ZVxuICBpZiAoeWVhciA+PSBhbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXSkge1xuICAgIHJldHVybiBhbmNob3JzWzIwNjBdO1xuICB9XG4gIFxuICAvLyBGaW5kIHN1cnJvdW5kaW5nIGFuY2hvcnNcbiAgbGV0IGxvd2VyWWVhciA9IGFuY2hvclllYXJzWzBdO1xuICBsZXQgdXBwZXJZZWFyID0gYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV07XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFuY2hvclllYXJzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmICh5ZWFyID49IGFuY2hvclllYXJzW2ldICYmIHllYXIgPD0gYW5jaG9yWWVhcnNbaSArIDFdKSB7XG4gICAgICBsb3dlclllYXIgPSBhbmNob3JZZWFyc1tpXTtcbiAgICAgIHVwcGVyWWVhciA9IGFuY2hvclllYXJzW2kgKyAxXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBcbiAgY29uc3QgbG93ZXJSYXRlID0gYW5jaG9yc1tsb3dlclllYXIgYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICBjb25zdCB1cHBlclJhdGUgPSBhbmNob3JzW3VwcGVyWWVhciBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gIFxuICAvLyBFeHBvbmVudGlhbCBpbnRlcnBvbGF0aW9uXG4gIGNvbnN0IHQgPSAoeWVhciAtIGxvd2VyWWVhcikgLyAodXBwZXJZZWFyIC0gbG93ZXJZZWFyKTtcbiAgcmV0dXJuIGxvd2VyUmF0ZSAqIE1hdGgucG93KHVwcGVyUmF0ZSAvIGxvd2VyUmF0ZSwgdCk7XG59XG5cbi8qKlxuICogU3RlcCBtb2JpbGl6YXRpb24gc3RhdGUgZm9yd2FyZCBvbmUgeWVhclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RlcE1vYmlsaXphdGlvblN0YXRlKFxuICBwcmV2U3RhdGU6IE1vYmlsaXphdGlvblN0YXRlIHwgbnVsbCxcbiAgcGFyYW1zOiBNb2JpbGl6YXRpb25TY2VuYXJpb1BhcmFtcyxcbiAgeWVhcjogbnVtYmVyLFxuICBwdWU6IG51bWJlciA9IDEuMyxcbiAgcmV0aXJlbWVudHNHVzogbnVtYmVyID0gMCwgLy8gT3B0aW9uYWwgcmV0aXJlbWVudHMgKGRlZmF1bHQgMClcbiAgb3JiaXRhbFN1YnN0aXR1dGlvbkdXPzogbnVtYmVyLCAvLyBPcHRpb25hbDogZGVtYW5kIHNoaWZ0ZWQgdG8gb3JiaXRhbCAoZm9yIGJhY2tsb2cgZHJhaW4pXG4gIHJlc3BvbnNpdmVEZW1hbmRHVz86IG51bWJlciAvLyBPcHRpb25hbDogcmVzcG9uc2l2ZSBkZW1hbmQgKG92ZXJyaWRlcyBoYXJkY29kZWQgY2FsY3VsYXRlRGVtYW5kR1cpXG4pOiBNb2JpbGl6YXRpb25SZXN1bHQge1xuICAvLyBDYWxjdWxhdGUgZGVtYW5kOiB1c2UgcmVzcG9uc2l2ZSBkZW1hbmQgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSB1c2UgaGFyZGNvZGVkXG4gIC8vIENSSVRJQ0FMOiBGb3IgYmFja2xvZyBidWlsZHVwLCB3ZSBuZWVkIGRlbWFuZCB0byBncm93IGZhc3RlciB0aGFuIGJ1aWxkIHJhdGVcbiAgLy8gSWYgcmVzcG9uc2l2ZSBkZW1hbmQgaXMgcmVkdWNpbmcgZGVtYW5kIHRvbyBtdWNoIChwcmljZSBlbGFzdGljaXR5KSwgYmFja2xvZyB3b24ndCBidWlsZFxuICBsZXQgZGVtYW5kR1cgPSByZXNwb25zaXZlRGVtYW5kR1cgIT09IHVuZGVmaW5lZCBcbiAgICA/IHJlc3BvbnNpdmVEZW1hbmRHVyAqIHB1ZSAvLyBDb252ZXJ0IElUIGxvYWQgdG8gZmFjaWxpdHkgbG9hZFxuICAgIDogY2FsY3VsYXRlRGVtYW5kR1coeWVhciwgcGFyYW1zLCBwdWUpO1xuICBcbiAgLy8gRk9SQ0UgbWluaW11bSBkZW1hbmQgZ3Jvd3RoIHRvIGVuc3VyZSBiYWNrbG9nIGJ1aWxkcyB1cCAoZm9yIFMtY3VydmUpXG4gIC8vIEV2ZW4gd2l0aCBwcmljZSBlbGFzdGljaXR5LCBkZW1hbmQgc2hvdWxkIGdyb3cgYXQgbGVhc3QgNSUgcGVyIHllYXIgaW4gZWFybHkgeWVhcnNcbiAgLy8gVGhpcyBlbnN1cmVzIGJhY2tsb2cgYnVpbGRzIHVwIGV2ZW4gd2hlbiBwcmljZSByaXNlcyAoY3JlYXRlcyBTLWN1cnZlKVxuICBpZiAocHJldlN0YXRlPy5kZW1hbmRHVyAmJiB5ZWFyIDw9IDIwNDApIHtcbiAgICBjb25zdCBtaW5EZW1hbmRHcm93dGggPSAwLjA1OyAvLyA1JSBtaW5pbXVtIGdyb3d0aFxuICAgIGNvbnN0IG1pbkRlbWFuZEdXID0gcHJldlN0YXRlLmRlbWFuZEdXICogKDEgKyBtaW5EZW1hbmRHcm93dGgpO1xuICAgIGRlbWFuZEdXID0gTWF0aC5tYXgoZGVtYW5kR1csIG1pbkRlbWFuZEdXKTsgLy8gRW5zdXJlIGRlbWFuZCBkb2Vzbid0IHNocmluayB0b28gbXVjaFxuICB9XG4gIFxuICAvLyBGaXggMjogQ2FsY3VsYXRlIGRlbWFuZEdXUHJldiBjb3JyZWN0bHkgKGRvbid0IHVzZSBzYW1lIHJlc3BvbnNpdmVEZW1hbmRHVyBmb3IgYm90aCB5ZWFycylcbiAgbGV0IGRlbWFuZEdXUHJldjogbnVtYmVyO1xuICBpZiAocHJldlN0YXRlPy5kZW1hbmRHVyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVtYW5kR1dQcmV2ID0gcHJldlN0YXRlLmRlbWFuZEdXO1xuICB9IGVsc2UgaWYgKHJlc3BvbnNpdmVEZW1hbmRHVyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gRm9yIGZpcnN0IHllYXIsIGVzdGltYXRlIHByZXZpb3VzIHllYXIncyBkZW1hbmQgdXNpbmcgaGFyZGNvZGVkIGNhbGN1bGF0aW9uXG4gICAgLy8gRG9uJ3QgdXNlIHNhbWUgcmVzcG9uc2l2ZURlbWFuZEdXIGZvciBib3RoIGN1cnJlbnQgYW5kIHByZXZpb3VzIHllYXJcbiAgICBkZW1hbmRHV1ByZXYgPSBjYWxjdWxhdGVEZW1hbmRHVyh5ZWFyIC0gMSwgcGFyYW1zLCBwdWUpO1xuICB9IGVsc2Uge1xuICAgIGRlbWFuZEdXUHJldiA9IGNhbGN1bGF0ZURlbWFuZEdXKHllYXIgLSAxLCBwYXJhbXMsIHB1ZSk7XG4gIH1cbiAgY29uc3QgZGVtYW5kTmV3R1cgPSBNYXRoLm1heCgwLCBkZW1hbmRHVyAtIGRlbWFuZEdXUHJldik7XG4gIFxuICAvLyBDYWxjdWxhdGUgYnVpbGQgcmF0ZSBjYW5kaWRhdGUgKGZyb20gYW5jaG9ycylcbiAgbGV0IGJ1aWxkUmF0ZUNhbmRpZGF0ZSA9IGNhbGN1bGF0ZUJ1aWxkUmF0ZUdXeXIoeWVhciwgcGFyYW1zKTtcbiAgXG4gIC8vIE5FVzogSWYgZ3JvdW5kIGRlbWFuZCBpcyBmYWxsaW5nIChkdWUgdG8gb3JiaXRhbCBzdWJzdGl0dXRpb24gb3IgcHJpY2UgZWxhc3RpY2l0eSksXG4gIC8vIGJ1aWxkb3V0IHNob3VsZCBzbG93IGRvd24gKG5vIG9uZSBidWlsZHMgY2FwYWNpdHkgZm9yIGRlY2xpbmluZyBtYXJrZXQpXG4gIGNvbnN0IGRlbWFuZEdyb3d0aFJhdGVBY3R1YWwgPSBwcmV2U3RhdGU/LmRlbWFuZEdXID8gKGRlbWFuZEdXIC0gcHJldlN0YXRlLmRlbWFuZEdXKSAvIE1hdGgubWF4KHByZXZTdGF0ZS5kZW1hbmRHVywgMSkgOiAwO1xuICBpZiAoZGVtYW5kR3Jvd3RoUmF0ZUFjdHVhbCA8IDApIHtcbiAgICAvLyBEZW1hbmQgaXMgc2hyaW5raW5nIC0gcmVkdWNlIGJ1aWxkb3V0XG4gICAgY29uc3QgY29udHJhY3Rpb25GYWN0b3IgPSBNYXRoLm1heCgwLjUsIDEgKyBkZW1hbmRHcm93dGhSYXRlQWN0dWFsICogMik7IC8vIEF0IG1vc3QgNTAlIHJlZHVjdGlvblxuICAgIGJ1aWxkUmF0ZUNhbmRpZGF0ZSA9IGJ1aWxkUmF0ZUNhbmRpZGF0ZSAqIGNvbnRyYWN0aW9uRmFjdG9yOyAvLyBSZWFzc2lnbiB0byBsZXQgdmFyaWFibGVcbiAgfVxuICBcbiAgLy8gQXBwbHkgYm90dGxlbmVjayBjb25zdHJhaW50cyBpZiBlbmFibGVkXG4gIGNvbnN0IGJvdHRsZW5lY2tNb2RlID0gcGFyYW1zLmJvdHRsZW5lY2tNb2RlID8/ICdtaW5fb2ZfYm90dGxlbmVja3MnO1xuICBsZXQgYnVpbGRSYXRlR1d5ciA9IGJ1aWxkUmF0ZUNhbmRpZGF0ZTtcbiAgbGV0IGJvdHRsZW5lY2tSYXRlR1d5cjogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICBsZXQgbGltaXRpbmdCb3R0bGVuZWNrOiAndHJhbnNmb3JtZXJzJyB8ICdzdWJzdGF0aW9ucycgfCAndHgnIHwgJ2dlbmVyYXRpb24nIHwgJ2NhbmRpZGF0ZScgfCAnbm9uZScgPSAnY2FuZGlkYXRlJztcbiAgXG4gIGlmIChib3R0bGVuZWNrTW9kZSA9PT0gJ21pbl9vZl9ib3R0bGVuZWNrcycgJiYgcGFyYW1zLmJvdHRsZW5lY2tBbmNob3JzR1d5cikge1xuICAgIGNvbnN0IHsgdHJhbnNmb3JtZXJzLCBzdWJzdGF0aW9ucywgdHgsIGdlbmVyYXRpb24gfSA9IHBhcmFtcy5ib3R0bGVuZWNrQW5jaG9yc0dXeXI7XG4gICAgXG4gICAgY29uc3QgdHJhbnNmb3JtZXJzUmF0ZSA9IGNhbGN1bGF0ZUJvdHRsZW5lY2tSYXRlR1d5cih5ZWFyLCB0cmFuc2Zvcm1lcnMpO1xuICAgIGNvbnN0IHN1YnN0YXRpb25zUmF0ZSA9IGNhbGN1bGF0ZUJvdHRsZW5lY2tSYXRlR1d5cih5ZWFyLCBzdWJzdGF0aW9ucyk7XG4gICAgY29uc3QgdHhSYXRlID0gY2FsY3VsYXRlQm90dGxlbmVja1JhdGVHV3lyKHllYXIsIHR4KTtcbiAgICBjb25zdCBnZW5lcmF0aW9uUmF0ZSA9IGNhbGN1bGF0ZUJvdHRsZW5lY2tSYXRlR1d5cih5ZWFyLCBnZW5lcmF0aW9uKTtcbiAgICBcbiAgICAvLyBGaW5kIG1pbmltdW0gYm90dGxlbmVja1xuICAgIGJvdHRsZW5lY2tSYXRlR1d5ciA9IE1hdGgubWluKHRyYW5zZm9ybWVyc1JhdGUsIHN1YnN0YXRpb25zUmF0ZSwgdHhSYXRlLCBnZW5lcmF0aW9uUmF0ZSk7XG4gICAgXG4gICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGJvdHRsZW5lY2sgaXMgbGltaXRpbmdcbiAgICBpZiAoYm90dGxlbmVja1JhdGVHV3lyID09PSB0cmFuc2Zvcm1lcnNSYXRlKSB7XG4gICAgICBsaW1pdGluZ0JvdHRsZW5lY2sgPSAndHJhbnNmb3JtZXJzJztcbiAgICB9IGVsc2UgaWYgKGJvdHRsZW5lY2tSYXRlR1d5ciA9PT0gc3Vic3RhdGlvbnNSYXRlKSB7XG4gICAgICBsaW1pdGluZ0JvdHRsZW5lY2sgPSAnc3Vic3RhdGlvbnMnO1xuICAgIH0gZWxzZSBpZiAoYm90dGxlbmVja1JhdGVHV3lyID09PSB0eFJhdGUpIHtcbiAgICAgIGxpbWl0aW5nQm90dGxlbmVjayA9ICd0eCc7XG4gICAgfSBlbHNlIGlmIChib3R0bGVuZWNrUmF0ZUdXeXIgPT09IGdlbmVyYXRpb25SYXRlKSB7XG4gICAgICBsaW1pdGluZ0JvdHRsZW5lY2sgPSAnZ2VuZXJhdGlvbic7XG4gICAgfVxuICAgIFxuICAgIC8vIEVmZmVjdGl2ZSBidWlsZCByYXRlIGlzIG1pbmltdW0gb2YgY2FuZGlkYXRlIGFuZCBib3R0bGVuZWNrXG4gICAgYnVpbGRSYXRlR1d5ciA9IE1hdGgubWluKGJ1aWxkUmF0ZUNhbmRpZGF0ZSwgYm90dGxlbmVja1JhdGVHV3lyKTtcbiAgfSBlbHNlIHtcbiAgICBsaW1pdGluZ0JvdHRsZW5lY2sgPSAnbm9uZSc7XG4gIH1cbiAgXG4gIC8vIEFwcGx5IHJhbXAgbGltaXRlciAocHJldmVudCBzdWRkZW4ganVtcHMpXG4gIGNvbnN0IHJhbXBMaW1pdEZyYWMgPSBwYXJhbXMucmFtcExpbWl0RnJhY1BlclllYXIgPz8gMC4yNTtcbiAgaWYgKHByZXZTdGF0ZT8uYnVpbGRSYXRlR1d5ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgcHJldlJhdGUgPSBwcmV2U3RhdGUuYnVpbGRSYXRlR1d5cjtcbiAgICBjb25zdCBtaW5SYXRlID0gcHJldlJhdGUgKiAoMSAtIHJhbXBMaW1pdEZyYWMpO1xuICAgIGNvbnN0IG1heFJhdGUgPSBwcmV2UmF0ZSAqICgxICsgcmFtcExpbWl0RnJhYyk7XG4gICAgYnVpbGRSYXRlR1d5ciA9IE1hdGgubWF4KG1pblJhdGUsIE1hdGgubWluKG1heFJhdGUsIGJ1aWxkUmF0ZUdXeXIpKTtcbiAgfVxuICBcbiAgLy8gQ2FsY3VsYXRlIGNhcGFjaXR5IGV2b2x1dGlvblxuICAvLyBjYXBhY2l0eUd3KHQpID0gY2FwYWNpdHlHdyh0LTEpICsgYnVpbGRSYXRlR3dZZWFyKHQpIC0gcmV0aXJlbWVudHNHdyh0KVxuICBjb25zdCBjYXBhY2l0eUdXUHJldiA9IHByZXZTdGF0ZT8uY2FwYWNpdHlHVyA/PyAwO1xuICBjb25zdCBjYXBhY2l0eUdXID0gY2FwYWNpdHlHV1ByZXYgKyBidWlsZFJhdGVHV3lyIC0gcmV0aXJlbWVudHNHVztcbiAgXG4gIC8vIENhbGN1bGF0ZSBwaXBlbGluZVxuICAvLyBwaXBlbGluZUd3KHQpID0gYnVpbGRSYXRlR3dZZWFyKHQpICogcGlwZWxpbmVMZWFkVGltZVllYXJzICogcGlwZWxpbmVGaWxsRnJhY1xuICBjb25zdCBwaXBlbGluZUdXID0gYnVpbGRSYXRlR1d5ciAqIHBhcmFtcy5waXBlbGluZUxlYWRUaW1lWWVhcnMgKiBwYXJhbXMucGlwZWxpbmVGaWxsRnJhYztcbiAgXG4gIC8vIENhbGN1bGF0ZSBiYWNrbG9nXG4gIC8vIGJhY2tsb2dHdyh0KSA9IG1heCgwLCBiYWNrbG9nR3codC0xKSArIGRlbWFuZE5ld0d3KHQpIC0gYnVpbGRhYmxlR3codCkgLSBpbXBsaWNpdEJhY2tsb2dEcmFpbilcbiAgLy8gTkVXOiBCYWNrbG9nIGNhbiBhbHNvIGJlIHNhdGlzZmllZCBieSBkZW1hbmQgc2hpZnRpbmcgdG8gb3JiaXRhbFxuICAvLyBXaGVuIGRlbWFuZCBzaGlmdHMgdG8gb3JiaXRhbCwgXCJpbXBsaWNpdCBiYWNrbG9nIGRyYWluXCIgb2NjdXJzXG4gIC8vIGJlY2F1c2UgY3VzdG9tZXJzIHdobyB3ZXJlIHdhaXRpbmcgZm9yIGdyb3VuZCBub3cgdXNlIG9yYml0YWwgaW5zdGVhZFxuICAvLyBGaXggMTogSW5pdGlhbGl6ZSB3aXRoIGJhc2VsaW5lIGJhY2tsb2cgaWYgbm8gcHJldmlvdXMgc3RhdGVcbiAgLy8gSElHSEVSIGluaXRpYWwgYmFja2xvZyB0byBjcmVhdGUgZWFybHkgc2NhcmNpdHkgcHJlc3N1cmVcbiAgY29uc3QgSU5JVElBTF9CQUNLTE9HX0dXID0gODA7IC8vIEluY3JlYXNlZCBmcm9tIDUwIHRvIGNyZWF0ZSBtb3JlIGVhcmx5IHNjYXJjaXR5XG4gIGNvbnN0IGJhY2tsb2dHV1ByZXYgPSBwcmV2U3RhdGU/LmJhY2tsb2dHVyA/PyBJTklUSUFMX0JBQ0tMT0dfR1c7XG4gIGNvbnN0IGJ1aWxkYWJsZUdXID0gYnVpbGRSYXRlR1d5cjtcbiAgY29uc3QgaW1wbGljaXRCYWNrbG9nRHJhaW4gPSAob3JiaXRhbFN1YnN0aXR1dGlvbkdXID8/IDApICogMC41OyAvLyA1MCUgb2Ygc2hpZnRlZCBkZW1hbmQgd2FzIGluIGJhY2tsb2dcbiAgXG4gIC8vIE5FVzogQmFja2xvZyBjYW4gZHJhaW4gd2hlbiBkZW1hbmQgZmFsbHMgYmVsb3cgYnVpbGRvdXRcbiAgY29uc3QgbmV0RGVtYW5kQ2hhbmdlID0gZGVtYW5kTmV3R1cgLSBidWlsZGFibGVHVztcbiAgXG4gIC8vIElmIG9yYml0YWwgc3Vic3RpdHV0aW9uIGNhdXNlZCBkZW1hbmQgdG8gZHJvcCwgYmFja2xvZyBkcmFpbnMgZmFzdGVyXG4gIGNvbnN0IGRlbWFuZERyb3BGcm9tUHJldiA9IE1hdGgubWF4KDAsIChwcmV2U3RhdGU/LmRlbWFuZEdXID8/IGRlbWFuZEdXKSAtIGRlbWFuZEdXKTtcbiAgY29uc3Qgc3Vic3RpdHV0aW9uRHJhaW4gPSBkZW1hbmREcm9wRnJvbVByZXYgKiAwLjM7IC8vIDMwJSBvZiBkZW1hbmQgZHJvcCB3YXMgZnJvbSBiYWNrbG9nXG4gIFxuICAvLyBGaXggMzogRW5zdXJlIGJhY2tsb2cgcmVmbGVjdHMgZGVtYW5kLWNhcGFjaXR5IGdhcFxuICAvLyBJZiBkZW1hbmQgPj4gY2FwYWNpdHksIGJhY2tsb2cgbXVzdCBiZSBhdCBsZWFzdCAoZGVtYW5kIC0gY2FwYWNpdHkpXG4gIGNvbnN0IHVuc2VydmVkR1cgPSBNYXRoLm1heCgwLCBkZW1hbmRHVyAtIGNhcGFjaXR5R1cpO1xuICBjb25zdCBiYWNrbG9nRmxvb3IgPSB1bnNlcnZlZEdXICogMC41OyAvLyBBdCBsZWFzdCA1MCUgb2YgdW5zZXJ2ZWQgaXMgaW4gYmFja2xvZ1xuICBjb25zdCBiYWNrbG9nR1cgPSBNYXRoLm1heChiYWNrbG9nRmxvb3IsIE1hdGgubWF4KDAsIGJhY2tsb2dHV1ByZXYgKyBuZXREZW1hbmRDaGFuZ2UgLSBzdWJzdGl0dXRpb25EcmFpbiAtIGltcGxpY2l0QmFja2xvZ0RyYWluKSk7XG4gIFxuICAvLyBIYXJkIGFzc2VydDogSWYgZGVtYW5kTmV3R3codCkgPiBidWlsZFJhdGVHd1llYXIodCksIGJhY2tsb2dHdyBtdXN0IGluY3JlYXNlXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGlmIChkZW1hbmROZXdHVyA+IGJ1aWxkUmF0ZUdXeXIgJiYgYmFja2xvZ0dXIDw9IGJhY2tsb2dHV1ByZXYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFtCVUlMRE9VVCBJTlZBUklBTlRdIFllYXIgJHt5ZWFyfTogZGVtYW5kTmV3R1c9JHtkZW1hbmROZXdHVy50b0ZpeGVkKDIpfSA+IGAgK1xuICAgICAgICBgYnVpbGRSYXRlR1d5cj0ke2J1aWxkUmF0ZUdXeXIudG9GaXhlZCgyKX0sIGJ1dCBiYWNrbG9nR1c9JHtiYWNrbG9nR1cudG9GaXhlZCgyKX0gYCArXG4gICAgICAgIGA8PSBwcmV2QmFja2xvZ0dXPSR7YmFja2xvZ0dXUHJldi50b0ZpeGVkKDIpfS4gQmFja2xvZyBtdXN0IGluY3JlYXNlLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBDYWxjdWxhdGUgYXZlcmFnZSB3YWl0IHRpbWVcbiAgLy8gYXZnV2FpdFllYXJzKHQpID0gYmFja2xvZ0d3KHQpIC8gbWF4KGJ1aWxkUmF0ZUd3WWVhcih0KSwgMWUtOSlcbiAgLy8gRml4IDQ6IEFkZCBzYW5pdHkgY2hlY2sgLSBpZiBiYWNrbG9nID4gMCwgd2FpdCBtdXN0IGJlID4gMFxuICBjb25zdCBFUFMgPSAxZS05O1xuICBjb25zdCBhdmdXYWl0WWVhcnNSYXcgPSBiYWNrbG9nR1cgLyBNYXRoLm1heChidWlsZFJhdGVHV3lyLCBFUFMpO1xuICAvLyBJZiBiYWNrbG9nID4gMCwgd2FpdCBtdXN0IGJlID4gMFxuICBjb25zdCBhdmdXYWl0WWVhcnMgPSBiYWNrbG9nR1cgPiAwLjEgPyBNYXRoLm1heCgwLjEsIGF2Z1dhaXRZZWFyc1JhdykgOiBhdmdXYWl0WWVhcnNSYXc7XG4gIFxuICAvLyBDYWxjdWxhdGUgZ3Jvd3RoIHJhdGUgKGZvciBkZWJ1ZylcbiAgbGV0IGRlbWFuZEdyb3d0aFJhdGU6IG51bWJlcjtcbiAgaWYgKHllYXIgPD0gMjA0MCkge1xuICAgIGRlbWFuZEdyb3d0aFJhdGUgPSBNYXRoLmxvZyhwYXJhbXMuZGVtYW5kQW5jaG9yc0dXWzIwNDBdIC8gcGFyYW1zLmRlbWFuZEFuY2hvcnNHV1syMDI1XSkgLyAxNTtcbiAgfSBlbHNlIHtcbiAgICBkZW1hbmRHcm93dGhSYXRlID0gTWF0aC5sb2cocGFyYW1zLmRlbWFuZEFuY2hvcnNHV1syMDYwXSAvIHBhcmFtcy5kZW1hbmRBbmNob3JzR1dbMjA0MF0pIC8gMjA7XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgeWVhcixcbiAgICBkZW1hbmRHVyxcbiAgICBkZW1hbmROZXdHVyxcbiAgICBidWlsZFJhdGVHV3lyLFxuICAgIGNhcGFjaXR5R1csXG4gICAgcGlwZWxpbmVHVyxcbiAgICBiYWNrbG9nR1csXG4gICAgYXZnV2FpdFllYXJzLFxuICAgIGRlbWFuZEdyb3d0aFJhdGUsXG4gICAgYnVpbGRvdXRTbW9vdGhGYWN0b3I6IHBhcmFtcy5idWlsZG91dFNtb290aGluZ1llYXJzLFxuICAgIGJvdHRsZW5lY2tSYXRlR1d5cixcbiAgICBsaW1pdGluZ0JvdHRsZW5lY2ssXG4gICAgYnVpbGRSYXRlQ2FuZGlkYXRlLFxuICB9O1xufVxuXG4vKipcbiAqIERlZmF1bHQgbW9iaWxpemF0aW9uIHNjZW5hcmlvIHBhcmFtZXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTU9CSUxJWkFUSU9OX1BBUkFNUzogTW9iaWxpemF0aW9uU2NlbmFyaW9QYXJhbXMgPSB7XG4gIGRlbWFuZEFuY2hvcnNHVzoge1xuICAgIDIwMjU6IDEyMCwgLy8gRmFjaWxpdHkgbG9hZCBiYXNlbGluZSAoSVQgbG9hZCAqIFBVRSlcbiAgICAyMDQwOiA0NTAsIC8vIFRhcmdldFxuICAgIDIwNjA6IDMwMDAsIC8vIE11bHRpLVRXIHRhcmdldFxuICB9LFxuICBkZW1hbmRDdXJ2ZTogJ3BpZWNld2lzZV9leHBvbmVudGlhbCcsXG4gIGRlbWFuZElzRmFjaWxpdHlMb2FkOiB0cnVlLCAvLyBEZW1hbmQgaXMgZmFjaWxpdHkgbG9hZCAoaW5jbHVkZXMgUFVFKVxuICBidWlsZG91dEFuY2hvcnNHV3lyOiB7XG4gICAgMjAyNTogMTUsIC8vIExPV0VSIGluaXRpYWwgYnVpbGQgcmF0ZSB0byBmb3JjZSBiYWNrbG9nIGJ1aWxkdXAgKHdhcyAyNSlcbiAgICAyMDMwOiA1MCwgLy8gU2xvd2VyIHJhbXAgdG8gYWxsb3cgYmFja2xvZyB0byBidWlsZCAod2FzIDYwKVxuICAgIDIwNDA6IDE0MCxcbiAgICAyMDYwOiAyMjAsXG4gIH0sXG4gIGJ1aWxkb3V0U21vb3RoaW5nWWVhcnM6IDMsXG4gIHBpcGVsaW5lTGVhZFRpbWVZZWFyczogMyxcbiAgcGlwZWxpbmVGaWxsRnJhYzogMS41LFxuICBib3R0bGVuZWNrTW9kZTogJ21pbl9vZl9ib3R0bGVuZWNrcycsXG4gIGJvdHRsZW5lY2tBbmNob3JzR1d5cjoge1xuICAgIHRyYW5zZm9ybWVyczogeyAyMDI1OiAzMCwgMjAzMDogNTAsIDIwNDA6IDEwMCwgMjA2MDogMTgwIH0sXG4gICAgc3Vic3RhdGlvbnM6IHsgMjAyNTogMzUsIDIwMzA6IDU1LCAyMDQwOiAxMTAsIDIwNjA6IDIwMCB9LFxuICAgIHR4OiB7IDIwMjU6IDQwLCAyMDMwOiA2NSwgMjA0MDogMTMwLCAyMDYwOiAyNTAgfSxcbiAgICBnZW5lcmF0aW9uOiB7IDIwMjU6IDUwLCAyMDMwOiA4MCwgMjA0MDogMTYwLCAyMDYwOiAzMDAgfSxcbiAgfSxcbiAgcmFtcExpbWl0RnJhY1BlclllYXI6IDAuMjUsIC8vIDI1JSBtYXggY2hhbmdlIHBlciB5ZWFyXG59O1xuXG4iXSwibmFtZXMiOlsiY2FsY3VsYXRlUHJpY2VSZXNwb25zaXZlRGVtYW5kR1ciLCJ5ZWFyIiwiZ3JvdW5kUHJpY2VQZXJHcHVIb3VyIiwib3JiaXRhbFByaWNlUGVyR3B1SG91ciIsImF2Z1dhaXRZZWFycyIsInBhcmFtcyIsInB1ZSIsInllYXJzRnJvbTIwMjUiLCJncm93dGhUYXBlciIsIk1hdGgiLCJ0YW5oIiwiYmFzZURlbWFuZCIsImJhc2VEZW1hbmQyMDI1R1ciLCJwb3ciLCJvcmdhbmljR3Jvd3RoUmF0ZSIsImJhc2VsaW5lUHJpY2UiLCJwcmljZVJhdGlvIiwicHJpY2VGYWN0b3IiLCJwcmljZUVsYXN0aWNpdHkiLCJ3YWl0RmFjdG9yIiwiZXhwIiwid2FpdEVsYXN0aWNpdHkiLCJvcmJpdGFsQWR2YW50YWdlIiwibWF4Iiwic3Vic3RpdHV0aW9uRmFjdG9yIiwib3JiaXRhbFN1YnN0aXR1dGlvblRocmVzaG9sZCIsImRlbWFuZEdXIiwiY2FsY3VsYXRlRGVtYW5kR1ciLCJkZW1hbmRBbmNob3JzR1ciLCJkZW1hbmRJc0ZhY2lsaXR5TG9hZCIsImRlbWFuZEN1cnZlIiwiZGVtYW5kMjAyNSIsImRlbWFuZDIwNDAiLCJkZW1hbmQyMDYwIiwiRXJyb3IiLCJyMSIsImxvZyIsInIyIiwieWVhcnNGcm9tMjA0MCIsInByb2Nlc3MiLCJhY3R1YWwyMDQwIiwiZXJyb3IyMDQwIiwiYWJzIiwidG9GaXhlZCIsImNhbGN1bGF0ZVByaWNlUmVzcG9uc2l2ZUJ1aWxkUmF0ZUdXeXIiLCJwcmV2QnVpbGRSYXRlIiwiZ3JvdW5kTWFyZ2luIiwiYmFja2xvZ0dXIiwiYmFzZUdyb3d0aCIsImJhc2VCdWlsZFJhdGUiLCJiYXNlQnVpbGRSYXRlMjAyNUdXeXIiLCJiYXNlbGluZU1hcmdpbiIsIm1hcmdpblJhdGlvIiwiaW52ZXN0bWVudE11bHRpcGxpZXIiLCJpbnZlc3RtZW50RWxhc3RpY2l0eSIsImJhY2tsb2dNdWx0aXBsaWVyIiwiYmFja2xvZ1Jlc3BvbnNlSyIsIm1pbiIsInRhcmdldFJhdGUiLCJtYXhCdWlsZFJhdGVHV3lyIiwibWF4UmF0ZSIsInJhbXBMaW1pdFBlclllYXIiLCJtaW5SYXRlIiwiY2FsY3VsYXRlQnVpbGRSYXRlR1d5ciIsImJ1aWxkb3V0QW5jaG9yc0dXeXIiLCJidWlsZG91dFNtb290aGluZ1llYXJzIiwiYW5jaG9ycyIsImFuY2hvclllYXJzIiwiT2JqZWN0Iiwia2V5cyIsIm1hcCIsIk51bWJlciIsInNvcnQiLCJhIiwiYiIsImxlbmd0aCIsImxvd2VyWWVhciIsInVwcGVyWWVhciIsImkiLCJsb3dlclJhdGUiLCJ1cHBlclJhdGUiLCJ0IiwiYnVpbGRSYXRlIiwic21vb3RoaW5nV2luZG93Iiwic21vb3RoZWRTdW0iLCJjb3VudCIsImdldFVuc21vb3RoZWRSYXRlIiwieSIsImxvd2VyIiwidXBwZXIiLCJvZmZzZXQiLCJmbG9vciIsInByZXZZZWFyIiwibmV4dFllYXIiLCJwcmV2UmF0ZSIsIm5leHRSYXRlIiwiY2FsY3VsYXRlQm90dGxlbmVja1JhdGVHV3lyIiwic3RlcE1vYmlsaXphdGlvblN0YXRlIiwicHJldlN0YXRlIiwicmV0aXJlbWVudHNHVyIsIm9yYml0YWxTdWJzdGl0dXRpb25HVyIsInJlc3BvbnNpdmVEZW1hbmRHVyIsInVuZGVmaW5lZCIsIm1pbkRlbWFuZEdyb3d0aCIsIm1pbkRlbWFuZEdXIiwiZGVtYW5kR1dQcmV2IiwiZGVtYW5kTmV3R1ciLCJidWlsZFJhdGVDYW5kaWRhdGUiLCJkZW1hbmRHcm93dGhSYXRlQWN0dWFsIiwiY29udHJhY3Rpb25GYWN0b3IiLCJib3R0bGVuZWNrTW9kZSIsImJ1aWxkUmF0ZUdXeXIiLCJib3R0bGVuZWNrUmF0ZUdXeXIiLCJsaW1pdGluZ0JvdHRsZW5lY2siLCJib3R0bGVuZWNrQW5jaG9yc0dXeXIiLCJ0cmFuc2Zvcm1lcnMiLCJzdWJzdGF0aW9ucyIsInR4IiwiZ2VuZXJhdGlvbiIsInRyYW5zZm9ybWVyc1JhdGUiLCJzdWJzdGF0aW9uc1JhdGUiLCJ0eFJhdGUiLCJnZW5lcmF0aW9uUmF0ZSIsInJhbXBMaW1pdEZyYWMiLCJyYW1wTGltaXRGcmFjUGVyWWVhciIsImNhcGFjaXR5R1dQcmV2IiwiY2FwYWNpdHlHVyIsInBpcGVsaW5lR1ciLCJwaXBlbGluZUxlYWRUaW1lWWVhcnMiLCJwaXBlbGluZUZpbGxGcmFjIiwiSU5JVElBTF9CQUNLTE9HX0dXIiwiYmFja2xvZ0dXUHJldiIsImJ1aWxkYWJsZUdXIiwiaW1wbGljaXRCYWNrbG9nRHJhaW4iLCJuZXREZW1hbmRDaGFuZ2UiLCJkZW1hbmREcm9wRnJvbVByZXYiLCJzdWJzdGl0dXRpb25EcmFpbiIsInVuc2VydmVkR1ciLCJiYWNrbG9nRmxvb3IiLCJFUFMiLCJhdmdXYWl0WWVhcnNSYXciLCJkZW1hbmRHcm93dGhSYXRlIiwiYnVpbGRvdXRTbW9vdGhGYWN0b3IiLCJERUZBVUxUX01PQklMSVpBVElPTl9QQVJBTVMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/ground_ramping_mobilization.ts\n"));

/***/ })

});