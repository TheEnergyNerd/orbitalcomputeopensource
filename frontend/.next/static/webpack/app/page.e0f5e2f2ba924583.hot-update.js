"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/model/ground_constraint_penalties.ts":
/*!******************************************************!*\
  !*** ./app/lib/model/ground_constraint_penalties.ts ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateGroundConstraintPenalties: function() { return /* binding */ calculateGroundConstraintPenalties; },\n/* harmony export */   calculateHillScarcityPremium: function() { return /* binding */ calculateHillScarcityPremium; },\n/* harmony export */   calculateScarcityRent: function() { return /* binding */ calculateScarcityRent; }\n/* harmony export */ });\n/**\n * Ground Constraint Penalties Model\n * \n * Calculates WACC-based penalties and multipliers from backlog/wait time:\n * - timeToEnergizePenaltyPerPflopYear: WACC carry + lost margin\n * - siteMultiplier: land + interconnect scarcity\n * - pueMultiplier: cooling/water stress\n */ /**\n * Hill function: saturating sigmoid-like curve\n * @param x Input value\n * @param x50 Half-saturation point\n * @param n Hill coefficient (steepness)\n * @returns Value between 0 and 1\n */ function hill(x, x50, n) {\n    if (x <= 0) return 0;\n    const xn = Math.pow(x, n);\n    const x50n = Math.pow(x50, n);\n    return xn / (x50n + xn);\n}\n/**\n * Threshold Hill function: 0 until x exceeds x0, then Hill on the excess\n * @param x Input value\n * @param x0 Threshold (must exceed this before Hill activates)\n * @param x50 Half-saturation point for excess\n * @param n Hill coefficient\n * @returns Value between 0 and 1\n */ function thresholdHill(x, x0, x50, n) {\n    const excess = Math.max(0, x - x0);\n    return hill(excess, x50, n);\n}\n/**\n * Calculate scarcity multiplier using LOG-BASED function (never fully saturates)\n * \n * Replaces Hill function with log-based approach that can distinguish between\n * wait=20yr and wait=254yr (unlike Hill which saturates early).\n * \n * @param waitYears Average wait time (years) - NO CLAMP applied\n * @param utilizationPct Utilization percentage (0-1) - optional threshold gate\n * @param params Optional parameters\n * @returns Scarcity multiplier (1.0 = no scarcity, 2.0 = 2x price) and debug fields\n */ function calculateScarcityRent(waitYears, utilizationPct, params) {\n    var _params_utilizationThreshold;\n    const UTIL_THRESHOLD = (_params_utilizationThreshold = params === null || params === void 0 ? void 0 : params.utilizationThreshold) !== null && _params_utilizationThreshold !== void 0 ? _params_utilizationThreshold : 0.85;\n    var _params_waitThresholdYears;\n    const WAIT_THRESHOLD = (_params_waitThresholdYears = params === null || params === void 0 ? void 0 : params.waitThresholdYears) !== null && _params_waitThresholdYears !== void 0 ? _params_waitThresholdYears : 1.0;\n    var _params_rentMaxMultiplier;\n    // Dynamic rent max that scales with wait time (prevents Moore's Law from canceling scarcity)\n    // OLD: baseMax=2.0, cap=5.0\n    // NEW: baseMax=2.0, cap=4.0, scaling=0.3 per log10 (more conservative)\n    // At wait=10yr: ~2.3x, wait=50yr: ~2.6x, wait=100yr: ~2.9x (log-based, never fully saturates)\n    const baseMax = (_params_rentMaxMultiplier = params === null || params === void 0 ? void 0 : params.rentMaxMultiplier) !== null && _params_rentMaxMultiplier !== void 0 ? _params_rentMaxMultiplier : 2.0;\n    const waitScaling = waitYears > 1 ? Math.log10(waitYears) * 0.3 : 0; // +0.3x per order of magnitude\n    const RENT_MAX = Math.min(4.0, baseMax + waitScaling); // Cap at 4x total\n    // Gate: no scarcity if utilization < 85% AND wait < 1 year\n    if (utilizationPct !== undefined && utilizationPct < UTIL_THRESHOLD && waitYears < WAIT_THRESHOLD) {\n        return {\n            scarcityMultiplier: 1.0,\n            rentFrac: 0,\n            waitEffYears: waitYears,\n            scarcityHill: {\n                h: 0,\n                rentFrac: 0\n            },\n            avgWaitYearsRaw: waitYears,\n            avgWaitYearsClamped: waitYears\n        };\n    }\n    // Wait term: LOG-BASED (never saturates, but grows slowly)\n    // At wait=1yr: 0, wait=3yr: 0.48, wait=10yr: 1.0, wait=100yr: 2.0, wait=1000yr: 3.0\n    const waitTerm = waitYears > WAIT_THRESHOLD ? Math.log10(waitYears / WAIT_THRESHOLD) : 0;\n    // Utilization term: sigmoid above threshold\n    const utilExcess = Math.max(0, (utilizationPct !== null && utilizationPct !== void 0 ? utilizationPct : 0) - UTIL_THRESHOLD);\n    const utilTerm = utilExcess > 0 ? 1 / (1 + Math.exp(-20 * (utilExcess - 0.05)) // Sharp rise at 90%\n    ) : 0;\n    // Combined: scarcity = 1 + min(RENT_MAX - 1, waitTerm * (1 + utilTerm))\n    const rawRent = waitTerm * (1 + utilTerm);\n    const rentFrac = Math.min(RENT_MAX - 1, rawRent);\n    const scarcityMultiplier = 1 + rentFrac;\n    // For backward compatibility: return scarcityRentPerPflopYear = 0\n    // (scarcity is now multiplicative, not additive)\n    return {\n        scarcityMultiplier,\n        rentFrac,\n        waitEffYears: waitYears,\n        scarcityHill: {\n            h: waitTerm,\n            rentFrac\n        },\n        avgWaitYearsRaw: waitYears,\n        avgWaitYearsClamped: waitYears\n    };\n}\n/**\n * Calculate ground constraint penalties from supply state\n * \n * @param state Current ground supply state\n * @param flopsPerWattGround GFLOPS/W for ground compute\n * @param pueGround PUE for ground datacenters\n * @param capacityFactorGround Capacity factor for ground\n * @param waccParams Optional WACC parameters for capital rationing\n * @returns Penalties and multipliers\n */ function calculateGroundConstraintPenalties(state, flopsPerWattGround, pueGround, capacityFactorGround, waccParams) {\n    const backlogGw = state.backlogGw; // Pipeline is not backlog. If backlog is missing, treat as 0 and let chartInputs/buildoutDebug supply the real number elsewhere.\n    const avgWaitYears = state.avgWaitYears;\n    const maxBuildRateGwYear = state.maxBuildRateGwYear;\n    const utilizationPct = state.utilizationPct;\n    // Convert GW to MW\n    const backlogMw = backlogGw * 1000;\n    // UNIT GUARD: Fix units mismatch (flopsPerWattGround might be TFLOPS/W instead of GFLOPS/W)\n    let gflopsPerWatt = flopsPerWattGround;\n    if (flopsPerWattGround < 50) {\n        // Likely TFLOPS/W (e.g., 2 TFLOPS/W), convert to GFLOPS/W\n        gflopsPerWatt = flopsPerWattGround * 1000;\n        if (true) {\n            console.warn(\"[UNIT CONVERSION] flopsPerWattGround=\".concat(flopsPerWattGround, \" < 50, treating as TFLOPS/W and converting to \").concat(gflopsPerWatt, \" GFLOPS/W\"));\n        }\n    }\n    // Clamp insane values\n    if (gflopsPerWatt > 20000) {\n        if (true) {\n            console.warn(\"[UNIT CLAMP] gflopsPerWatt=\".concat(gflopsPerWatt, \" > 20000, clamping to 20000\"));\n        }\n        gflopsPerWatt = 20000;\n    }\n    var _waccParams_baseWacc;\n    // WACC parameters (capital rationing: WACC rises with backlog)\n    const baseWacc = (_waccParams_baseWacc = waccParams === null || waccParams === void 0 ? void 0 : waccParams.baseWacc) !== null && _waccParams_baseWacc !== void 0 ? _waccParams_baseWacc : 0.10; // 10% base WACC\n    var _waccParams_waccBacklogK;\n    const waccBacklogK = (_waccParams_waccBacklogK = waccParams === null || waccParams === void 0 ? void 0 : waccParams.waccBacklogK) !== null && _waccParams_waccBacklogK !== void 0 ? _waccParams_waccBacklogK : 0.5; // Scaling factor\n    var _waccParams_waccBacklogExponent;\n    const waccBacklogExponent = (_waccParams_waccBacklogExponent = waccParams === null || waccParams === void 0 ? void 0 : waccParams.waccBacklogExponent) !== null && _waccParams_waccBacklogExponent !== void 0 ? _waccParams_waccBacklogExponent : 1.2; // Exponent for convexity\n    var _waccParams_criticalBacklogGW;\n    const criticalBacklogGW = (_waccParams_criticalBacklogGW = waccParams === null || waccParams === void 0 ? void 0 : waccParams.criticalBacklogGW) !== null && _waccParams_criticalBacklogGW !== void 0 ? _waccParams_criticalBacklogGW : 50; // Critical backlog threshold\n    // Compute effective WACC (rises with backlog)\n    // waccEffective = baseWacc * (1 + waccBacklogK * (backlogGW/criticalBacklogGW)^waccBacklogExponent)\n    const backlogRatio = Math.max(0, backlogGw / criticalBacklogGW);\n    const waccMultiplier = 1 + waccBacklogK * Math.pow(backlogRatio, waccBacklogExponent);\n    const waccEffective = baseWacc * waccMultiplier;\n    // Constants\n    const WACC = 0.10;\n    const CAPEX_PER_MW = 3000000; // $3M/MW capex at risk\n    // Replace the huge lost-margin number with something defensible + capped\n    const LOST_MARGIN_PER_MW_YEAR = 600000; // was 2,000,000, now 600k\n    const LOST_MARGIN_CAP_PER_MW = 1800000; // cap total lost margin component\n    const MAX_WAIT_FOR_CARRY = 4; // years, cap compounding horizon\n    const MAX_TOTAL_PENALTY_PER_MW_YEAR = 2500000; // hard cap so it never goes vertical\n    const BASE_SITE_COST_PER_MW_YEAR = 150000; // $150k/MW-year base site cost\n    const BASE_PUE = 1.3; // Baseline PUE\n    // Reference capex amort for capping (used to prevent penalty from dominating)\n    const CAPEX_AMORT_PER_PFLOP_YEAR_REFERENCE = 1500; // Base site cost per PFLOP-year\n    // 1. Bounded Delay Penalty: Linear WACC carry (NOT exponential)\n    // delayPenaltyPerPflopYear = capexPerPflopYear * wacc * avgWaitYears\n    // Cap it: delayPenaltyPerPflopYear = min(delayPenaltyPerPflopYear, delayCapFrac * capexPerPflopYear)\n    let timeToEnergizePenaltyPerPflopYear = 0;\n    let capexAtRiskPerMW = 0;\n    let carryCostPerMW = 0;\n    let lostMarginPerMW = 0;\n    // Convert capex to per-PFLOP-year for penalty calculation\n    const pflopsPerMW = gflopsPerWatt * capacityFactorGround / pueGround;\n    const CAPEX_PER_PFLOP_YEAR = CAPEX_PER_MW / Math.max(pflopsPerMW, 1e-6);\n    if (avgWaitYears > 0.01) {\n        // Linear delay penalty: WACC * capex * waitYears (NOT exponential)\n        const delayPenaltyUncapped = CAPEX_PER_PFLOP_YEAR * baseWacc * avgWaitYears;\n        // Cap at delayCapFrac of capex (0.5-1.0 range)\n        const DELAY_CAP_FRAC = 0.75; // Cap at 75% of capex\n        timeToEnergizePenaltyPerPflopYear = Math.min(delayPenaltyUncapped, DELAY_CAP_FRAC * CAPEX_PER_PFLOP_YEAR);\n        // For debug fields (MW-based)\n        capexAtRiskPerMW = CAPEX_PER_MW;\n        carryCostPerMW = CAPEX_PER_MW * baseWacc * avgWaitYears;\n        lostMarginPerMW = 0; // Not used in bounded model\n    }\n    // 2. Site Multiplier: land + interconnect scarcity (Hill-shaped, thresholded)\n    // Backlog rent: Hill on avgWaitYears (this creates the \"hump\" shape)\n    const waitRent = hill(avgWaitYears, 2.0, 2.0); // 50% rent at 2 years\n    const backlogRent = hill(backlogGw, 30, 2.0); // kicks in around ~30 GW backlog\n    // Utilization rent: strictly 0 until > 85% utilization\n    const utilRent = thresholdHill(utilizationPct, 0.85, 0.05, 2.0); // x50 is 5% above threshold\n    const landScarcityFactor = 1 + 0.35 * backlogRent;\n    const interconnectScarcityFactor = 1 + 0.45 * Math.max(waitRent, utilRent);\n    // Site multiplier should be ~1 when backlog=0, wait=0, util<0.85\n    const siteMultiplier = landScarcityFactor * interconnectScarcityFactor;\n    // 3. PUE Multiplier: cooling/water stress (thresholded)\n    const coolingStressFactor = 1 + 0.25 * utilRent;\n    const waterStressFactor = 1 + 0.20 * backlogRent;\n    const pueMultiplier = 1 + (coolingStressFactor - 1) + (waterStressFactor - 1); // Additive stress\n    return {\n        timeToEnergizePenaltyPerPflopYear,\n        siteMultiplier,\n        pueMultiplier,\n        backlogGw,\n        avgWaitYears,\n        capexAtRiskPerMW,\n        carryCostPerMW,\n        lostMarginPerMW,\n        waccBase: baseWacc,\n        waccEffective\n    };\n}\n/**\n * Calculate Hill-based scarcity premium from queue pressure + utilization\n * \n * Scarcity multiplier (NOT exponential):\n * - queuePressure = backlogGW / (backlogGW + K_backlogGW) where K_backlogGW ~ 50-150\n * - utilPressure = 1 / (1 + exp(-k*(utilizationPct - u0))) with u0 ~ 0.85-0.92, k ~ 12-20\n * - scarcity = 1 + rentFracMax * (queuePressure^h) * utilPressure\n * \n * @param backlogGw Backlog in GW\n * @param utilizationPct Utilization percentage (0-1)\n * @param baseCostPerPflopYear Base cost per PFLOP-year (for rent calculation)\n * @param params Optional parameters\n * @returns Scarcity rent and debug fields\n */ function calculateHillScarcityPremium(backlogGw, utilizationPct, baseCostPerPflopYear, params) {\n    var _params_kBacklogGw;\n    const kBacklogGw = (_params_kBacklogGw = params === null || params === void 0 ? void 0 : params.kBacklogGw) !== null && _params_kBacklogGw !== void 0 ? _params_kBacklogGw : 100; // K_backlogGW ~ 50-150\n    var _params_u0;\n    const u0 = (_params_u0 = params === null || params === void 0 ? void 0 : params.u0) !== null && _params_u0 !== void 0 ? _params_u0 : 0.88; // u0 ~ 0.85-0.92 (scarcity starts at 88% utilization)\n    var _params_k;\n    const k = (_params_k = params === null || params === void 0 ? void 0 : params.k) !== null && _params_k !== void 0 ? _params_k : 16; // k ~ 12-20 (steepness of utilization curve)\n    var _params_rentFracMax;\n    const rentFracMax = (_params_rentFracMax = params === null || params === void 0 ? void 0 : params.rentFracMax) !== null && _params_rentFracMax !== void 0 ? _params_rentFracMax : 0.5; // rentFracMax ~ 0.3-0.8 (max rent fraction)\n    var _params_h;\n    const h = (_params_h = params === null || params === void 0 ? void 0 : params.h) !== null && _params_h !== void 0 ? _params_h : 2.0; // h ~ 1-3 (steepness of queue pressure)\n    // Queue pressure: backlogGW / (backlogGW + K_backlogGW)\n    // Saturates at 1 as backlog grows\n    const queuePressure = backlogGw / (backlogGw + kBacklogGw);\n    // Utilization pressure: 1 / (1 + exp(-k*(utilizationPct - u0)))\n    // Sigmoid that rises sharply around u0\n    const utilExcess = utilizationPct - u0;\n    const utilPressure = 1 / (1 + Math.exp(-k * utilExcess));\n    // Scarcity multiplier: 1 + rentFracMax * (queuePressure^h) * utilPressure\n    const scarcityMultiplier = 1 + rentFracMax * Math.pow(queuePressure, h) * utilPressure;\n    // Scarcity rent = base cost * (scarcity - 1)\n    const scarcityRentPerPflopYear = baseCostPerPflopYear * (scarcityMultiplier - 1);\n    return {\n        scarcityRentPerPflopYear,\n        scarcityMultiplier,\n        queuePressure,\n        utilPressure\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX2NvbnN0cmFpbnRfcGVuYWx0aWVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7O0NBT0MsR0FJRDs7Ozs7O0NBTUMsR0FDRCxTQUFTQSxLQUFLQyxDQUFTLEVBQUVDLEdBQVcsRUFBRUMsQ0FBUztJQUM3QyxJQUFJRixLQUFLLEdBQUcsT0FBTztJQUNuQixNQUFNRyxLQUFLQyxLQUFLQyxHQUFHLENBQUNMLEdBQUdFO0lBQ3ZCLE1BQU1JLE9BQU9GLEtBQUtDLEdBQUcsQ0FBQ0osS0FBS0M7SUFDM0IsT0FBT0MsS0FBTUcsQ0FBQUEsT0FBT0gsRUFBQztBQUN2QjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTSSxjQUFjUCxDQUFTLEVBQUVRLEVBQVUsRUFBRVAsR0FBVyxFQUFFQyxDQUFTO0lBQ2xFLE1BQU1PLFNBQVNMLEtBQUtNLEdBQUcsQ0FBQyxHQUFHVixJQUFJUTtJQUMvQixPQUFPVCxLQUFLVSxRQUFRUixLQUFLQztBQUMzQjtBQXVCQTs7Ozs7Ozs7OztDQVVDLEdBQ00sU0FBU1Msc0JBQ2RDLFNBQWlCLEVBQ2pCQyxjQUF1QixFQUN2QkMsTUFJQztRQWFzQkE7SUFBdkIsTUFBTUMsaUJBQWlCRCxDQUFBQSwrQkFBQUEsbUJBQUFBLDZCQUFBQSxPQUFRRSxvQkFBb0IsY0FBNUJGLDBDQUFBQSwrQkFBZ0M7UUFDaENBO0lBQXZCLE1BQU1HLGlCQUFpQkgsQ0FBQUEsNkJBQUFBLG1CQUFBQSw2QkFBQUEsT0FBUUksa0JBQWtCLGNBQTFCSix3Q0FBQUEsNkJBQThCO1FBTXJDQTtJQUpoQiw2RkFBNkY7SUFDN0YsNEJBQTRCO0lBQzVCLHVFQUF1RTtJQUN2RSw4RkFBOEY7SUFDOUYsTUFBTUssVUFBVUwsQ0FBQUEsNEJBQUFBLG1CQUFBQSw2QkFBQUEsT0FBUU0saUJBQWlCLGNBQXpCTix1Q0FBQUEsNEJBQTZCO0lBQzdDLE1BQU1PLGNBQWNULFlBQVksSUFBSVIsS0FB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TUFBTTRFLElBQUk1RSxDQUFBQSxZQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVE0RSxDQUFDLGNBQVQ1RSx1QkFBQUEsWUFBYSxJQUFJLDZDQUE2QztRQUNwREE7SUFBcEIsTUFBTTZFLGNBQWM3RSxDQUFBQSxzQkFBQUEsbUJBQUFBLDZCQUFBQSxPQUFRNkUsV0FBVyxjQUFuQjdFLGlDQUFBQSxzQkFBdUIsS0FBSyw0Q0FBNEM7UUFDbEZBO0lBQVYsTUFBTWdCLElBQUloQixDQUFBQSxZQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFnQixDQUFDLGNBQVRoQix1QkFBQUEsWUFBYSxLQUFLLHdDQUF3QztJQUVwRSx3REFBd0Q7SUFDeEQsa0NBQWtDO0lBQ2xDLE1BQU04RSxnQkFBZ0JoRCxZQUFhQSxDQUFBQSxZQUFZNEMsVUFBUztJQUV4RCxnRUFBZ0U7SUFDaEUsdUNBQXVDO0lBQ3ZDLE1BQU10RCxhQUFhckIsaUJBQWlCNEU7SUFDcEMsTUFBTUksZUFBZSxJQUFLLEtBQUl6RixLQUFLZ0MsR0FBRyxDQUFDLENBQUNzRCxJQUFJeEQsV0FBVTtJQUV0RCwwRUFBMEU7SUFDMUUsTUFBTVIscUJBQXFCLElBQUlpRSxjQUFjdkYsS0FBS0MsR0FBRyxDQUFDdUYsZUFBZTlELEtBQUsrRDtJQUUxRSw2Q0FBNkM7SUFDN0MsTUFBTUMsMkJBQTJCUCx1QkFBd0I3RCxDQUFBQSxxQkFBcUI7SUFFOUUsT0FBTztRQUNMb0U7UUFDQXBFO1FBQ0FrRTtRQUNBQztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9tb2RlbC9ncm91bmRfY29uc3RyYWludF9wZW5hbHRpZXMudHM/MjNmZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdyb3VuZCBDb25zdHJhaW50IFBlbmFsdGllcyBNb2RlbFxuICogXG4gKiBDYWxjdWxhdGVzIFdBQ0MtYmFzZWQgcGVuYWx0aWVzIGFuZCBtdWx0aXBsaWVycyBmcm9tIGJhY2tsb2cvd2FpdCB0aW1lOlxuICogLSB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXI6IFdBQ0MgY2FycnkgKyBsb3N0IG1hcmdpblxuICogLSBzaXRlTXVsdGlwbGllcjogbGFuZCArIGludGVyY29ubmVjdCBzY2FyY2l0eVxuICogLSBwdWVNdWx0aXBsaWVyOiBjb29saW5nL3dhdGVyIHN0cmVzc1xuICovXG5cbmltcG9ydCB7IEdyb3VuZFN1cHBseVN0YXRlIH0gZnJvbSAnLi9ncm91bmRfcXVldWVfbW9kZWwnO1xuXG4vKipcbiAqIEhpbGwgZnVuY3Rpb246IHNhdHVyYXRpbmcgc2lnbW9pZC1saWtlIGN1cnZlXG4gKiBAcGFyYW0geCBJbnB1dCB2YWx1ZVxuICogQHBhcmFtIHg1MCBIYWxmLXNhdHVyYXRpb24gcG9pbnRcbiAqIEBwYXJhbSBuIEhpbGwgY29lZmZpY2llbnQgKHN0ZWVwbmVzcylcbiAqIEByZXR1cm5zIFZhbHVlIGJldHdlZW4gMCBhbmQgMVxuICovXG5mdW5jdGlvbiBoaWxsKHg6IG51bWJlciwgeDUwOiBudW1iZXIsIG46IG51bWJlcik6IG51bWJlciB7XG4gIGlmICh4IDw9IDApIHJldHVybiAwO1xuICBjb25zdCB4biA9IE1hdGgucG93KHgsIG4pO1xuICBjb25zdCB4NTBuID0gTWF0aC5wb3coeDUwLCBuKTtcbiAgcmV0dXJuIHhuIC8gKHg1MG4gKyB4bik7XG59XG5cbi8qKlxuICogVGhyZXNob2xkIEhpbGwgZnVuY3Rpb246IDAgdW50aWwgeCBleGNlZWRzIHgwLCB0aGVuIEhpbGwgb24gdGhlIGV4Y2Vzc1xuICogQHBhcmFtIHggSW5wdXQgdmFsdWVcbiAqIEBwYXJhbSB4MCBUaHJlc2hvbGQgKG11c3QgZXhjZWVkIHRoaXMgYmVmb3JlIEhpbGwgYWN0aXZhdGVzKVxuICogQHBhcmFtIHg1MCBIYWxmLXNhdHVyYXRpb24gcG9pbnQgZm9yIGV4Y2Vzc1xuICogQHBhcmFtIG4gSGlsbCBjb2VmZmljaWVudFxuICogQHJldHVybnMgVmFsdWUgYmV0d2VlbiAwIGFuZCAxXG4gKi9cbmZ1bmN0aW9uIHRocmVzaG9sZEhpbGwoeDogbnVtYmVyLCB4MDogbnVtYmVyLCB4NTA6IG51bWJlciwgbjogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgZXhjZXNzID0gTWF0aC5tYXgoMCwgeCAtIHgwKTtcbiAgcmV0dXJuIGhpbGwoZXhjZXNzLCB4NTAsIG4pO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyb3VuZENvbnN0cmFpbnRQZW5hbHRpZXMge1xuICAvLyBUaW1lLXRvLWVuZXJnaXplIHBlbmFsdHkgKFdBQ0MgY2FycnkgKyBsb3N0IG1hcmdpbilcbiAgdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyOiBudW1iZXI7XG4gIFxuICAvLyBTaXRlIG11bHRpcGxpZXIgKGxhbmQgKyBpbnRlcmNvbm5lY3Qgc2NhcmNpdHkpXG4gIHNpdGVNdWx0aXBsaWVyOiBudW1iZXI7XG4gIFxuICAvLyBQVUUgbXVsdGlwbGllciAoY29vbGluZy93YXRlciBzdHJlc3MpXG4gIHB1ZU11bHRpcGxpZXI6IG51bWJlcjtcbiAgXG4gIC8vIERlYnVnIGZpZWxkc1xuICBiYWNrbG9nR3c6IG51bWJlcjtcbiAgYXZnV2FpdFllYXJzOiBudW1iZXI7XG4gIGNhcGV4QXRSaXNrUGVyTVc6IG51bWJlcjtcbiAgY2FycnlDb3N0UGVyTVc6IG51bWJlcjtcbiAgbG9zdE1hcmdpblBlck1XOiBudW1iZXI7XG4gIC8vIFdBQ0MgZGVidWcgZmllbGRzXG4gIHdhY2NCYXNlPzogbnVtYmVyO1xuICB3YWNjRWZmZWN0aXZlPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBzY2FyY2l0eSBtdWx0aXBsaWVyIHVzaW5nIExPRy1CQVNFRCBmdW5jdGlvbiAobmV2ZXIgZnVsbHkgc2F0dXJhdGVzKVxuICogXG4gKiBSZXBsYWNlcyBIaWxsIGZ1bmN0aW9uIHdpdGggbG9nLWJhc2VkIGFwcHJvYWNoIHRoYXQgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAqIHdhaXQ9MjB5ciBhbmQgd2FpdD0yNTR5ciAodW5saWtlIEhpbGwgd2hpY2ggc2F0dXJhdGVzIGVhcmx5KS5cbiAqIFxuICogQHBhcmFtIHdhaXRZZWFycyBBdmVyYWdlIHdhaXQgdGltZSAoeWVhcnMpIC0gTk8gQ0xBTVAgYXBwbGllZFxuICogQHBhcmFtIHV0aWxpemF0aW9uUGN0IFV0aWxpemF0aW9uIHBlcmNlbnRhZ2UgKDAtMSkgLSBvcHRpb25hbCB0aHJlc2hvbGQgZ2F0ZVxuICogQHBhcmFtIHBhcmFtcyBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyBTY2FyY2l0eSBtdWx0aXBsaWVyICgxLjAgPSBubyBzY2FyY2l0eSwgMi4wID0gMnggcHJpY2UpIGFuZCBkZWJ1ZyBmaWVsZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVNjYXJjaXR5UmVudChcbiAgd2FpdFllYXJzOiBudW1iZXIsXG4gIHV0aWxpemF0aW9uUGN0PzogbnVtYmVyLFxuICBwYXJhbXM/OiB7XG4gICAgd2FpdFRocmVzaG9sZFllYXJzPzogbnVtYmVyOyAvLyBNaW5pbXVtIHdhaXQgYmVmb3JlIHNjYXJjaXR5IGFjdGl2YXRlcyAoZGVmYXVsdCAxLjApXG4gICAgcmVudE1heE11bHRpcGxpZXI/OiBudW1iZXI7IC8vIE1heGltdW0gcHJpY2UgbXVsdGlwbGllciAoZGVmYXVsdCAyLjAgPSAyeCBwcmljZSlcbiAgICB1dGlsaXphdGlvblRocmVzaG9sZD86IG51bWJlcjsgLy8gVXRpbGl6YXRpb24gdGhyZXNob2xkIChkZWZhdWx0IDAuODUpXG4gIH1cbik6IHtcbiAgc2NhcmNpdHlNdWx0aXBsaWVyOiBudW1iZXI7IC8vIFByaWNlIG11bHRpcGxpZXIgKDEuMCA9IG5vIHNjYXJjaXR5LCAyLjAgPSAyeClcbiAgcmVudEZyYWM6IG51bWJlcjsgLy8gUmVudCBmcmFjdGlvbiAoMCA9IG5vIHJlbnQsIDEuMCA9IG1heCByZW50KVxuICB3YWl0RWZmWWVhcnM6IG51bWJlcjtcbiAgLy8gRGVidWcgZmllbGRzXG4gIHNjYXJjaXR5SGlsbDoge1xuICAgIGg6IG51bWJlcjsgLy8gV2FpdCB0ZXJtIChsb2ctYmFzZWQpXG4gICAgcmVudEZyYWM6IG51bWJlcjsgLy8gUmVudCBmcmFjdGlvbiBhZnRlciBhcHBseWluZyByZW50TWF4XG4gIH07XG4gIGF2Z1dhaXRZZWFyc1JhdzogbnVtYmVyOyAvLyBSYXcgd2FpdCB5ZWFycyAobm8gY2xhbXApXG4gIGF2Z1dhaXRZZWFyc0NsYW1wZWQ6IG51bWJlcjsgLy8gU2FtZSBhcyByYXcgKG5vIGNsYW1wIGFwcGxpZWQpXG59IHtcbiAgY29uc3QgVVRJTF9USFJFU0hPTEQgPSBwYXJhbXM/LnV0aWxpemF0aW9uVGhyZXNob2xkID8/IDAuODU7XG4gIGNvbnN0IFdBSVRfVEhSRVNIT0xEID0gcGFyYW1zPy53YWl0VGhyZXNob2xkWWVhcnMgPz8gMS4wO1xuICBcbiAgLy8gRHluYW1pYyByZW50IG1heCB0aGF0IHNjYWxlcyB3aXRoIHdhaXQgdGltZSAocHJldmVudHMgTW9vcmUncyBMYXcgZnJvbSBjYW5jZWxpbmcgc2NhcmNpdHkpXG4gIC8vIE9MRDogYmFzZU1heD0yLjAsIGNhcD01LjBcbiAgLy8gTkVXOiBiYXNlTWF4PTIuMCwgY2FwPTQuMCwgc2NhbGluZz0wLjMgcGVyIGxvZzEwIChtb3JlIGNvbnNlcnZhdGl2ZSlcbiAgLy8gQXQgd2FpdD0xMHlyOiB+Mi4zeCwgd2FpdD01MHlyOiB+Mi42eCwgd2FpdD0xMDB5cjogfjIuOXggKGxvZy1iYXNlZCwgbmV2ZXIgZnVsbHkgc2F0dXJhdGVzKVxuICBjb25zdCBiYXNlTWF4ID0gcGFyYW1zPy5yZW50TWF4TXVsdGlwbGllciA/PyAyLjA7XG4gIGNvbnN0IHdhaXRTY2FsaW5nID0gd2FpdFllYXJzID4gMSA/IE1hdGgubG9nMTAod2FpdFllYXJzKSAqIDAuMyA6IDA7IC8vICswLjN4IHBlciBvcmRlciBvZiBtYWduaXR1ZGVcbiAgY29uc3QgUkVOVF9NQVggPSBNYXRoLm1pbig0LjAsIGJhc2VNYXggKyB3YWl0U2NhbGluZyk7IC8vIENhcCBhdCA0eCB0b3RhbFxuICBcbiAgLy8gR2F0ZTogbm8gc2NhcmNpdHkgaWYgdXRpbGl6YXRpb24gPCA4NSUgQU5EIHdhaXQgPCAxIHllYXJcbiAgaWYgKHV0aWxpemF0aW9uUGN0ICE9PSB1bmRlZmluZWQgJiYgdXRpbGl6YXRpb25QY3QgPCBVVElMX1RIUkVTSE9MRCAmJiB3YWl0WWVhcnMgPCBXQUlUX1RIUkVTSE9MRCkge1xuICAgIHJldHVybiB7XG4gICAgICBzY2FyY2l0eU11bHRpcGxpZXI6IDEuMCxcbiAgICAgIHJlbnRGcmFjOiAwLFxuICAgICAgd2FpdEVmZlllYXJzOiB3YWl0WWVhcnMsXG4gICAgICBzY2FyY2l0eUhpbGw6IHsgaDogMCwgcmVudEZyYWM6IDAgfSxcbiAgICAgIGF2Z1dhaXRZZWFyc1Jhdzogd2FpdFllYXJzLFxuICAgICAgYXZnV2FpdFllYXJzQ2xhbXBlZDogd2FpdFllYXJzLFxuICAgIH07XG4gIH1cbiAgXG4gIC8vIFdhaXQgdGVybTogTE9HLUJBU0VEIChuZXZlciBzYXR1cmF0ZXMsIGJ1dCBncm93cyBzbG93bHkpXG4gIC8vIEF0IHdhaXQ9MXlyOiAwLCB3YWl0PTN5cjogMC40OCwgd2FpdD0xMHlyOiAxLjAsIHdhaXQ9MTAweXI6IDIuMCwgd2FpdD0xMDAweXI6IDMuMFxuICBjb25zdCB3YWl0VGVybSA9IHdhaXRZZWFycyA+IFdBSVRfVEhSRVNIT0xEIFxuICAgID8gTWF0aC5sb2cxMCh3YWl0WWVhcnMgLyBXQUlUX1RIUkVTSE9MRCkgXG4gICAgOiAwO1xuICBcbiAgLy8gVXRpbGl6YXRpb24gdGVybTogc2lnbW9pZCBhYm92ZSB0aHJlc2hvbGRcbiAgY29uc3QgdXRpbEV4Y2VzcyA9IE1hdGgubWF4KDAsICh1dGlsaXphdGlvblBjdCA/PyAwKSAtIFVUSUxfVEhSRVNIT0xEKTtcbiAgY29uc3QgdXRpbFRlcm0gPSB1dGlsRXhjZXNzID4gMCBcbiAgICA/IDEgLyAoMSArIE1hdGguZXhwKC0yMCAqICh1dGlsRXhjZXNzIC0gMC4wNSkpKSAvLyBTaGFycCByaXNlIGF0IDkwJVxuICAgIDogMDtcbiAgXG4gIC8vIENvbWJpbmVkOiBzY2FyY2l0eSA9IDEgKyBtaW4oUkVOVF9NQVggLSAxLCB3YWl0VGVybSAqICgxICsgdXRpbFRlcm0pKVxuICBjb25zdCByYXdSZW50ID0gd2FpdFRlcm0gKiAoMSArIHV0aWxUZXJtKTtcbiAgY29uc3QgcmVudEZyYWMgPSBNYXRoLm1pbihSRU5UX01BWCAtIDEsIHJhd1JlbnQpO1xuICBjb25zdCBzY2FyY2l0eU11bHRpcGxpZXIgPSAxICsgcmVudEZyYWM7XG4gIFxuICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eTogcmV0dXJuIHNjYXJjaXR5UmVudFBlclBmbG9wWWVhciA9IDBcbiAgLy8gKHNjYXJjaXR5IGlzIG5vdyBtdWx0aXBsaWNhdGl2ZSwgbm90IGFkZGl0aXZlKVxuICByZXR1cm4ge1xuICAgIHNjYXJjaXR5TXVsdGlwbGllcixcbiAgICByZW50RnJhYyxcbiAgICB3YWl0RWZmWWVhcnM6IHdhaXRZZWFycyxcbiAgICBzY2FyY2l0eUhpbGw6IHsgaDogd2FpdFRlcm0sIHJlbnRGcmFjIH0sXG4gICAgYXZnV2FpdFllYXJzUmF3OiB3YWl0WWVhcnMsXG4gICAgYXZnV2FpdFllYXJzQ2xhbXBlZDogd2FpdFllYXJzLFxuICB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBncm91bmQgY29uc3RyYWludCBwZW5hbHRpZXMgZnJvbSBzdXBwbHkgc3RhdGVcbiAqIFxuICogQHBhcmFtIHN0YXRlIEN1cnJlbnQgZ3JvdW5kIHN1cHBseSBzdGF0ZVxuICogQHBhcmFtIGZsb3BzUGVyV2F0dEdyb3VuZCBHRkxPUFMvVyBmb3IgZ3JvdW5kIGNvbXB1dGVcbiAqIEBwYXJhbSBwdWVHcm91bmQgUFVFIGZvciBncm91bmQgZGF0YWNlbnRlcnNcbiAqIEBwYXJhbSBjYXBhY2l0eUZhY3Rvckdyb3VuZCBDYXBhY2l0eSBmYWN0b3IgZm9yIGdyb3VuZFxuICogQHBhcmFtIHdhY2NQYXJhbXMgT3B0aW9uYWwgV0FDQyBwYXJhbWV0ZXJzIGZvciBjYXBpdGFsIHJhdGlvbmluZ1xuICogQHJldHVybnMgUGVuYWx0aWVzIGFuZCBtdWx0aXBsaWVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlR3JvdW5kQ29uc3RyYWludFBlbmFsdGllcyhcbiAgc3RhdGU6IEdyb3VuZFN1cHBseVN0YXRlLFxuICBmbG9wc1BlcldhdHRHcm91bmQ6IG51bWJlcixcbiAgcHVlR3JvdW5kOiBudW1iZXIsXG4gIGNhcGFjaXR5RmFjdG9yR3JvdW5kOiBudW1iZXIsXG4gIHdhY2NQYXJhbXM/OiB7XG4gICAgYmFzZVdhY2M/OiBudW1iZXI7XG4gICAgd2FjY0JhY2tsb2dLPzogbnVtYmVyO1xuICAgIHdhY2NCYWNrbG9nRXhwb25lbnQ/OiBudW1iZXI7XG4gICAgY3JpdGljYWxCYWNrbG9nR1c/OiBudW1iZXI7XG4gIH1cbik6IEdyb3VuZENvbnN0cmFpbnRQZW5hbHRpZXMge1xuICBjb25zdCBiYWNrbG9nR3cgPSBzdGF0ZS5iYWNrbG9nR3c7IC8vIFBpcGVsaW5lIGlzIG5vdCBiYWNrbG9nLiBJZiBiYWNrbG9nIGlzIG1pc3NpbmcsIHRyZWF0IGFzIDAgYW5kIGxldCBjaGFydElucHV0cy9idWlsZG91dERlYnVnIHN1cHBseSB0aGUgcmVhbCBudW1iZXIgZWxzZXdoZXJlLlxuICBjb25zdCBhdmdXYWl0WWVhcnMgPSBzdGF0ZS5hdmdXYWl0WWVhcnM7XG4gIGNvbnN0IG1heEJ1aWxkUmF0ZUd3WWVhciA9IHN0YXRlLm1heEJ1aWxkUmF0ZUd3WWVhcjtcbiAgY29uc3QgdXRpbGl6YXRpb25QY3QgPSBzdGF0ZS51dGlsaXphdGlvblBjdDtcbiAgXG4gIC8vIENvbnZlcnQgR1cgdG8gTVdcbiAgY29uc3QgYmFja2xvZ013ID0gYmFja2xvZ0d3ICogMTAwMDtcbiAgXG4gIC8vIFVOSVQgR1VBUkQ6IEZpeCB1bml0cyBtaXNtYXRjaCAoZmxvcHNQZXJXYXR0R3JvdW5kIG1pZ2h0IGJlIFRGTE9QUy9XIGluc3RlYWQgb2YgR0ZMT1BTL1cpXG4gIGxldCBnZmxvcHNQZXJXYXR0ID0gZmxvcHNQZXJXYXR0R3JvdW5kO1xuICBpZiAoZmxvcHNQZXJXYXR0R3JvdW5kIDwgNTApIHtcbiAgICAvLyBMaWtlbHkgVEZMT1BTL1cgKGUuZy4sIDIgVEZMT1BTL1cpLCBjb252ZXJ0IHRvIEdGTE9QUy9XXG4gICAgZ2Zsb3BzUGVyV2F0dCA9IGZsb3BzUGVyV2F0dEdyb3VuZCAqIDEwMDA7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFtVTklUIENPTlZFUlNJT05dIGZsb3BzUGVyV2F0dEdyb3VuZD0ke2Zsb3BzUGVyV2F0dEdyb3VuZH0gPCA1MCwgdHJlYXRpbmcgYXMgVEZMT1BTL1cgYW5kIGNvbnZlcnRpbmcgdG8gJHtnZmxvcHNQZXJXYXR0fSBHRkxPUFMvV2ApO1xuICAgIH1cbiAgfVxuICAvLyBDbGFtcCBpbnNhbmUgdmFsdWVzXG4gIGlmIChnZmxvcHNQZXJXYXR0ID4gMjAwMDApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihgW1VOSVQgQ0xBTVBdIGdmbG9wc1BlcldhdHQ9JHtnZmxvcHNQZXJXYXR0fSA+IDIwMDAwLCBjbGFtcGluZyB0byAyMDAwMGApO1xuICAgIH1cbiAgICBnZmxvcHNQZXJXYXR0ID0gMjAwMDA7XG4gIH1cbiAgXG4gIC8vIFdBQ0MgcGFyYW1ldGVycyAoY2FwaXRhbCByYXRpb25pbmc6IFdBQ0MgcmlzZXMgd2l0aCBiYWNrbG9nKVxuICBjb25zdCBiYXNlV2FjYyA9IHdhY2NQYXJhbXM/LmJhc2VXYWNjID8/IDAuMTA7IC8vIDEwJSBiYXNlIFdBQ0NcbiAgY29uc3Qgd2FjY0JhY2tsb2dLID0gd2FjY1BhcmFtcz8ud2FjY0JhY2tsb2dLID8/IDAuNTsgLy8gU2NhbGluZyBmYWN0b3JcbiAgY29uc3Qgd2FjY0JhY2tsb2dFeHBvbmVudCA9IHdhY2NQYXJhbXM/LndhY2NCYWNrbG9nRXhwb25lbnQgPz8gMS4yOyAvLyBFeHBvbmVudCBmb3IgY29udmV4aXR5XG4gIGNvbnN0IGNyaXRpY2FsQmFja2xvZ0dXID0gd2FjY1BhcmFtcz8uY3JpdGljYWxCYWNrbG9nR1cgPz8gNTA7IC8vIENyaXRpY2FsIGJhY2tsb2cgdGhyZXNob2xkXG4gIFxuICAvLyBDb21wdXRlIGVmZmVjdGl2ZSBXQUNDIChyaXNlcyB3aXRoIGJhY2tsb2cpXG4gIC8vIHdhY2NFZmZlY3RpdmUgPSBiYXNlV2FjYyAqICgxICsgd2FjY0JhY2tsb2dLICogKGJhY2tsb2dHVy9jcml0aWNhbEJhY2tsb2dHVyled2FjY0JhY2tsb2dFeHBvbmVudClcbiAgY29uc3QgYmFja2xvZ1JhdGlvID0gTWF0aC5tYXgoMCwgYmFja2xvZ0d3IC8gY3JpdGljYWxCYWNrbG9nR1cpO1xuICBjb25zdCB3YWNjTXVsdGlwbGllciA9IDEgKyB3YWNjQmFja2xvZ0sgKiBNYXRoLnBvdyhiYWNrbG9nUmF0aW8sIHdhY2NCYWNrbG9nRXhwb25lbnQpO1xuICBjb25zdCB3YWNjRWZmZWN0aXZlID0gYmFzZVdhY2MgKiB3YWNjTXVsdGlwbGllcjtcbiAgXG4gIC8vIENvbnN0YW50c1xuICBjb25zdCBXQUNDID0gMC4xMDtcbiAgY29uc3QgQ0FQRVhfUEVSX01XID0gM18wMDBfMDAwOyAvLyAkM00vTVcgY2FwZXggYXQgcmlza1xuICBcbiAgLy8gUmVwbGFjZSB0aGUgaHVnZSBsb3N0LW1hcmdpbiBudW1iZXIgd2l0aCBzb21ldGhpbmcgZGVmZW5zaWJsZSArIGNhcHBlZFxuICBjb25zdCBMT1NUX01BUkdJTl9QRVJfTVdfWUVBUiA9IDYwMF8wMDA7ICAgICAgLy8gd2FzIDIsMDAwLDAwMCwgbm93IDYwMGtcbiAgY29uc3QgTE9TVF9NQVJHSU5fQ0FQX1BFUl9NVyA9IDFfODAwXzAwMDsgICAgIC8vIGNhcCB0b3RhbCBsb3N0IG1hcmdpbiBjb21wb25lbnRcbiAgXG4gIGNvbnN0IE1BWF9XQUlUX0ZPUl9DQVJSWSA9IDQ7ICAgICAgICAgICAgICAgICAvLyB5ZWFycywgY2FwIGNvbXBvdW5kaW5nIGhvcml6b25cbiAgY29uc3QgTUFYX1RPVEFMX1BFTkFMVFlfUEVSX01XX1lFQVIgPSAyXzUwMF8wMDA7IC8vIGhhcmQgY2FwIHNvIGl0IG5ldmVyIGdvZXMgdmVydGljYWxcbiAgXG4gIGNvbnN0IEJBU0VfU0lURV9DT1NUX1BFUl9NV19ZRUFSID0gMTUwXzAwMDsgLy8gJDE1MGsvTVcteWVhciBiYXNlIHNpdGUgY29zdFxuICBjb25zdCBCQVNFX1BVRSA9IDEuMzsgLy8gQmFzZWxpbmUgUFVFXG4gIFxuICAvLyBSZWZlcmVuY2UgY2FwZXggYW1vcnQgZm9yIGNhcHBpbmcgKHVzZWQgdG8gcHJldmVudCBwZW5hbHR5IGZyb20gZG9taW5hdGluZylcbiAgY29uc3QgQ0FQRVhfQU1PUlRfUEVSX1BGTE9QX1lFQVJfUkVGRVJFTkNFID0gMTUwMDsgLy8gQmFzZSBzaXRlIGNvc3QgcGVyIFBGTE9QLXllYXJcbiAgXG4gIC8vIDEuIEJvdW5kZWQgRGVsYXkgUGVuYWx0eTogTGluZWFyIFdBQ0MgY2FycnkgKE5PVCBleHBvbmVudGlhbClcbiAgLy8gZGVsYXlQZW5hbHR5UGVyUGZsb3BZZWFyID0gY2FwZXhQZXJQZmxvcFllYXIgKiB3YWNjICogYXZnV2FpdFllYXJzXG4gIC8vIENhcCBpdDogZGVsYXlQZW5hbHR5UGVyUGZsb3BZZWFyID0gbWluKGRlbGF5UGVuYWx0eVBlclBmbG9wWWVhciwgZGVsYXlDYXBGcmFjICogY2FwZXhQZXJQZmxvcFllYXIpXG4gIGxldCB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgPSAwO1xuICBsZXQgY2FwZXhBdFJpc2tQZXJNVyA9IDA7XG4gIGxldCBjYXJyeUNvc3RQZXJNVyA9IDA7XG4gIGxldCBsb3N0TWFyZ2luUGVyTVcgPSAwO1xuICBcbiAgLy8gQ29udmVydCBjYXBleCB0byBwZXItUEZMT1AteWVhciBmb3IgcGVuYWx0eSBjYWxjdWxhdGlvblxuICBjb25zdCBwZmxvcHNQZXJNVyA9IChnZmxvcHNQZXJXYXR0ICogY2FwYWNpdHlGYWN0b3JHcm91bmQpIC8gcHVlR3JvdW5kO1xuICBjb25zdCBDQVBFWF9QRVJfUEZMT1BfWUVBUiA9IChDQVBFWF9QRVJfTVcgLyBNYXRoLm1heChwZmxvcHNQZXJNVywgMWUtNikpO1xuICBcbiAgaWYgKGF2Z1dhaXRZZWFycyA+IDAuMDEpIHtcbiAgICAvLyBMaW5lYXIgZGVsYXkgcGVuYWx0eTogV0FDQyAqIGNhcGV4ICogd2FpdFllYXJzIChOT1QgZXhwb25lbnRpYWwpXG4gICAgY29uc3QgZGVsYXlQZW5hbHR5VW5jYXBwZWQgPSBDQVBFWF9QRVJfUEZMT1BfWUVBUiAqIGJhc2VXYWNjICogYXZnV2FpdFllYXJzO1xuICAgIFxuICAgIC8vIENhcCBhdCBkZWxheUNhcEZyYWMgb2YgY2FwZXggKDAuNS0xLjAgcmFuZ2UpXG4gICAgY29uc3QgREVMQVlfQ0FQX0ZSQUMgPSAwLjc1OyAvLyBDYXAgYXQgNzUlIG9mIGNhcGV4XG4gICAgdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyID0gTWF0aC5taW4oZGVsYXlQZW5hbHR5VW5jYXBwZWQsIERFTEFZX0NBUF9GUkFDICogQ0FQRVhfUEVSX1BGTE9QX1lFQVIpO1xuICAgIFxuICAgIC8vIEZvciBkZWJ1ZyBmaWVsZHMgKE1XLWJhc2VkKVxuICAgIGNhcGV4QXRSaXNrUGVyTVcgPSBDQVBFWF9QRVJfTVc7XG4gICAgY2FycnlDb3N0UGVyTVcgPSBDQVBFWF9QRVJfTVcgKiBiYXNlV2FjYyAqIGF2Z1dhaXRZZWFycztcbiAgICBsb3N0TWFyZ2luUGVyTVcgPSAwOyAvLyBOb3QgdXNlZCBpbiBib3VuZGVkIG1vZGVsXG4gIH1cbiAgXG4gIC8vIDIuIFNpdGUgTXVsdGlwbGllcjogbGFuZCArIGludGVyY29ubmVjdCBzY2FyY2l0eSAoSGlsbC1zaGFwZWQsIHRocmVzaG9sZGVkKVxuICAvLyBCYWNrbG9nIHJlbnQ6IEhpbGwgb24gYXZnV2FpdFllYXJzICh0aGlzIGNyZWF0ZXMgdGhlIFwiaHVtcFwiIHNoYXBlKVxuICBjb25zdCB3YWl0UmVudCA9IGhpbGwoYXZnV2FpdFllYXJzLCAyLjAsIDIuMCk7ICAgICAgICAgIC8vIDUwJSByZW50IGF0IDIgeWVhcnNcbiAgY29uc3QgYmFja2xvZ1JlbnQgPSBoaWxsKGJhY2tsb2dHdywgMzAsIDIuMCk7ICAgICAgICAgICAvLyBraWNrcyBpbiBhcm91bmQgfjMwIEdXIGJhY2tsb2dcbiAgXG4gIC8vIFV0aWxpemF0aW9uIHJlbnQ6IHN0cmljdGx5IDAgdW50aWwgPiA4NSUgdXRpbGl6YXRpb25cbiAgY29uc3QgdXRpbFJlbnQgPSB0aHJlc2hvbGRIaWxsKHV0aWxpemF0aW9uUGN0LCAwLjg1LCAwLjA1LCAyLjApOyAvLyB4NTAgaXMgNSUgYWJvdmUgdGhyZXNob2xkXG4gIFxuICBjb25zdCBsYW5kU2NhcmNpdHlGYWN0b3IgPSAxICsgMC4zNSAqIGJhY2tsb2dSZW50O1xuICBjb25zdCBpbnRlcmNvbm5lY3RTY2FyY2l0eUZhY3RvciA9IDEgKyAwLjQ1ICogTWF0aC5tYXgod2FpdFJlbnQsIHV0aWxSZW50KTtcbiAgXG4gIC8vIFNpdGUgbXVsdGlwbGllciBzaG91bGQgYmUgfjEgd2hlbiBiYWNrbG9nPTAsIHdhaXQ9MCwgdXRpbDwwLjg1XG4gIGNvbnN0IHNpdGVNdWx0aXBsaWVyID0gbGFuZFNjYXJjaXR5RmFjdG9yICogaW50ZXJjb25uZWN0U2NhcmNpdHlGYWN0b3I7XG4gIFxuICAvLyAzLiBQVUUgTXVsdGlwbGllcjogY29vbGluZy93YXRlciBzdHJlc3MgKHRocmVzaG9sZGVkKVxuICBjb25zdCBjb29saW5nU3RyZXNzRmFjdG9yID0gMSArIDAuMjUgKiB1dGlsUmVudDtcbiAgY29uc3Qgd2F0ZXJTdHJlc3NGYWN0b3IgPSAxICsgMC4yMCAqIGJhY2tsb2dSZW50O1xuICBjb25zdCBwdWVNdWx0aXBsaWVyID0gMSArIChjb29saW5nU3RyZXNzRmFjdG9yIC0gMSkgKyAod2F0ZXJTdHJlc3NGYWN0b3IgLSAxKTsgLy8gQWRkaXRpdmUgc3RyZXNzXG4gIFxuICByZXR1cm4ge1xuICAgIHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhcixcbiAgICBzaXRlTXVsdGlwbGllcixcbiAgICBwdWVNdWx0aXBsaWVyLFxuICAgIGJhY2tsb2dHdyxcbiAgICBhdmdXYWl0WWVhcnMsXG4gICAgY2FwZXhBdFJpc2tQZXJNVyxcbiAgICBjYXJyeUNvc3RQZXJNVyxcbiAgICBsb3N0TWFyZ2luUGVyTVcsXG4gICAgd2FjY0Jhc2U6IGJhc2VXYWNjLFxuICAgIHdhY2NFZmZlY3RpdmUsXG4gIH07XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIEhpbGwtYmFzZWQgc2NhcmNpdHkgcHJlbWl1bSBmcm9tIHF1ZXVlIHByZXNzdXJlICsgdXRpbGl6YXRpb25cbiAqIFxuICogU2NhcmNpdHkgbXVsdGlwbGllciAoTk9UIGV4cG9uZW50aWFsKTpcbiAqIC0gcXVldWVQcmVzc3VyZSA9IGJhY2tsb2dHVyAvIChiYWNrbG9nR1cgKyBLX2JhY2tsb2dHVykgd2hlcmUgS19iYWNrbG9nR1cgfiA1MC0xNTBcbiAqIC0gdXRpbFByZXNzdXJlID0gMSAvICgxICsgZXhwKC1rKih1dGlsaXphdGlvblBjdCAtIHUwKSkpIHdpdGggdTAgfiAwLjg1LTAuOTIsIGsgfiAxMi0yMFxuICogLSBzY2FyY2l0eSA9IDEgKyByZW50RnJhY01heCAqIChxdWV1ZVByZXNzdXJlXmgpICogdXRpbFByZXNzdXJlXG4gKiBcbiAqIEBwYXJhbSBiYWNrbG9nR3cgQmFja2xvZyBpbiBHV1xuICogQHBhcmFtIHV0aWxpemF0aW9uUGN0IFV0aWxpemF0aW9uIHBlcmNlbnRhZ2UgKDAtMSlcbiAqIEBwYXJhbSBiYXNlQ29zdFBlclBmbG9wWWVhciBCYXNlIGNvc3QgcGVyIFBGTE9QLXllYXIgKGZvciByZW50IGNhbGN1bGF0aW9uKVxuICogQHBhcmFtIHBhcmFtcyBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyBTY2FyY2l0eSByZW50IGFuZCBkZWJ1ZyBmaWVsZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUhpbGxTY2FyY2l0eVByZW1pdW0oXG4gIGJhY2tsb2dHdzogbnVtYmVyLFxuICB1dGlsaXphdGlvblBjdDogbnVtYmVyLFxuICBiYXNlQ29zdFBlclBmbG9wWWVhcjogbnVtYmVyLFxuICBwYXJhbXM/OiB7XG4gICAga0JhY2tsb2dHdz86IG51bWJlcjsgLy8gS19iYWNrbG9nR1cgfiA1MC0xNTBcbiAgICB1MD86IG51bWJlcjsgLy8gdTAgfiAwLjg1LTAuOTJcbiAgICBrPzogbnVtYmVyOyAvLyBrIH4gMTItMjBcbiAgICByZW50RnJhY01heD86IG51bWJlcjsgLy8gcmVudEZyYWNNYXggfiAwLjMtMC44XG4gICAgaD86IG51bWJlcjsgLy8gaCB+IDEtMyAoc3RlZXBuZXNzKVxuICB9XG4pOiB7XG4gIHNjYXJjaXR5UmVudFBlclBmbG9wWWVhcjogbnVtYmVyO1xuICBzY2FyY2l0eU11bHRpcGxpZXI6IG51bWJlcjtcbiAgcXVldWVQcmVzc3VyZTogbnVtYmVyO1xuICB1dGlsUHJlc3N1cmU6IG51bWJlcjtcbn0ge1xuICBjb25zdCBrQmFja2xvZ0d3ID0gcGFyYW1zPy5rQmFja2xvZ0d3ID8/IDEwMDsgLy8gS19iYWNrbG9nR1cgfiA1MC0xNTBcbiAgY29uc3QgdTAgPSBwYXJhbXM/LnUwID8/IDAuODg7IC8vIHUwIH4gMC44NS0wLjkyIChzY2FyY2l0eSBzdGFydHMgYXQgODglIHV0aWxpemF0aW9uKVxuICBjb25zdCBrID0gcGFyYW1zPy5rID8/IDE2OyAvLyBrIH4gMTItMjAgKHN0ZWVwbmVzcyBvZiB1dGlsaXphdGlvbiBjdXJ2ZSlcbiAgY29uc3QgcmVudEZyYWNNYXggPSBwYXJhbXM/LnJlbnRGcmFjTWF4ID8/IDAuNTsgLy8gcmVudEZyYWNNYXggfiAwLjMtMC44IChtYXggcmVudCBmcmFjdGlvbilcbiAgY29uc3QgaCA9IHBhcmFtcz8uaCA/PyAyLjA7IC8vIGggfiAxLTMgKHN0ZWVwbmVzcyBvZiBxdWV1ZSBwcmVzc3VyZSlcbiAgXG4gIC8vIFF1ZXVlIHByZXNzdXJlOiBiYWNrbG9nR1cgLyAoYmFja2xvZ0dXICsgS19iYWNrbG9nR1cpXG4gIC8vIFNhdHVyYXRlcyBhdCAxIGFzIGJhY2tsb2cgZ3Jvd3NcbiAgY29uc3QgcXVldWVQcmVzc3VyZSA9IGJhY2tsb2dHdyAvIChiYWNrbG9nR3cgKyBrQmFja2xvZ0d3KTtcbiAgXG4gIC8vIFV0aWxpemF0aW9uIHByZXNzdXJlOiAxIC8gKDEgKyBleHAoLWsqKHV0aWxpemF0aW9uUGN0IC0gdTApKSlcbiAgLy8gU2lnbW9pZCB0aGF0IHJpc2VzIHNoYXJwbHkgYXJvdW5kIHUwXG4gIGNvbnN0IHV0aWxFeGNlc3MgPSB1dGlsaXphdGlvblBjdCAtIHUwO1xuICBjb25zdCB1dGlsUHJlc3N1cmUgPSAxIC8gKDEgKyBNYXRoLmV4cCgtayAqIHV0aWxFeGNlc3MpKTtcbiAgXG4gIC8vIFNjYXJjaXR5IG11bHRpcGxpZXI6IDEgKyByZW50RnJhY01heCAqIChxdWV1ZVByZXNzdXJlXmgpICogdXRpbFByZXNzdXJlXG4gIGNvbnN0IHNjYXJjaXR5TXVsdGlwbGllciA9IDEgKyByZW50RnJhY01heCAqIE1hdGgucG93KHF1ZXVlUHJlc3N1cmUsIGgpICogdXRpbFByZXNzdXJlO1xuICBcbiAgLy8gU2NhcmNpdHkgcmVudCA9IGJhc2UgY29zdCAqIChzY2FyY2l0eSAtIDEpXG4gIGNvbnN0IHNjYXJjaXR5UmVudFBlclBmbG9wWWVhciA9IGJhc2VDb3N0UGVyUGZsb3BZZWFyICogKHNjYXJjaXR5TXVsdGlwbGllciAtIDEpO1xuICBcbiAgcmV0dXJuIHtcbiAgICBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXIsXG4gICAgc2NhcmNpdHlNdWx0aXBsaWVyLFxuICAgIHF1ZXVlUHJlc3N1cmUsXG4gICAgdXRpbFByZXNzdXJlLFxuICB9O1xufVxuXG4iXSwibmFtZXMiOlsiaGlsbCIsIngiLCJ4NTAiLCJuIiwieG4iLCJNYXRoIiwicG93IiwieDUwbiIsInRocmVzaG9sZEhpbGwiLCJ4MCIsImV4Y2VzcyIsIm1heCIsImNhbGN1bGF0ZVNjYXJjaXR5UmVudCIsIndhaXRZZWFycyIsInV0aWxpemF0aW9uUGN0IiwicGFyYW1zIiwiVVRJTF9USFJFU0hPTEQiLCJ1dGlsaXphdGlvblRocmVzaG9sZCIsIldBSVRfVEhSRVNIT0xEIiwid2FpdFRocmVzaG9sZFllYXJzIiwiYmFzZU1heCIsInJlbnRNYXhNdWx0aXBsaWVyIiwid2FpdFNjYWxpbmciLCJsb2cxMCIsIlJFTlRfTUFYIiwibWluIiwidW5kZWZpbmVkIiwic2NhcmNpdHlNdWx0aXBsaWVyIiwicmVudEZyYWMiLCJ3YWl0RWZmWWVhcnMiLCJzY2FyY2l0eUhpbGwiLCJoIiwiYXZnV2FpdFllYXJzUmF3IiwiYXZnV2FpdFllYXJzQ2xhbXBlZCIsIndhaXRUZXJtIiwidXRpbEV4Y2VzcyIsInV0aWxUZXJtIiwiZXhwIiwicmF3UmVudCIsImNhbGN1bGF0ZUdyb3VuZENvbnN0cmFpbnRQZW5hbHRpZXMiLCJzdGF0ZSIsImZsb3BzUGVyV2F0dEdyb3VuZCIsInB1ZUdyb3VuZCIsImNhcGFjaXR5RmFjdG9yR3JvdW5kIiwid2FjY1BhcmFtcyIsImJhY2tsb2dHdyIsImF2Z1dhaXRZZWFycyIsIm1heEJ1aWxkUmF0ZUd3WWVhciIsImJhY2tsb2dNdyIsImdmbG9wc1BlcldhdHQiLCJwcm9jZXNzIiwiY29uc29sZSIsIndhcm4iLCJiYXNlV2FjYyIsIndhY2NCYWNrbG9nSyIsIndhY2NCYWNrbG9nRXhwb25lbnQiLCJjcml0aWNhbEJhY2tsb2dHVyIsImJhY2tsb2dSYXRpbyIsIndhY2NNdWx0aXBsaWVyIiwid2FjY0VmZmVjdGl2ZSIsIldBQ0MiLCJDQVBFWF9QRVJfTVciLCJMT1NUX01BUkdJTl9QRVJfTVdfWUVBUiIsIkxPU1RfTUFSR0lOX0NBUF9QRVJfTVciLCJNQVhfV0FJVF9GT1JfQ0FSUlkiLCJNQVhfVE9UQUxfUEVOQUxUWV9QRVJfTVdfWUVBUiIsIkJBU0VfU0lURV9DT1NUX1BFUl9NV19ZRUFSIiwiQkFTRV9QVUUiLCJDQVBFWF9BTU9SVF9QRVJfUEZMT1BfWUVBUl9SRUZFUkVOQ0UiLCJ0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIiLCJjYXBleEF0Umlza1Blck1XIiwiY2FycnlDb3N0UGVyTVciLCJsb3N0TWFyZ2luUGVyTVciLCJwZmxvcHNQZXJNVyIsIkNBUEVYX1BFUl9QRkxPUF9ZRUFSIiwiZGVsYXlQZW5hbHR5VW5jYXBwZWQiLCJERUxBWV9DQVBfRlJBQyIsIndhaXRSZW50IiwiYmFja2xvZ1JlbnQiLCJ1dGlsUmVudCIsImxhbmRTY2FyY2l0eUZhY3RvciIsImludGVyY29ubmVjdFNjYXJjaXR5RmFjdG9yIiwic2l0ZU11bHRpcGxpZXIiLCJjb29saW5nU3RyZXNzRmFjdG9yIiwid2F0ZXJTdHJlc3NGYWN0b3IiLCJwdWVNdWx0aXBsaWVyIiwid2FjY0Jhc2UiLCJjYWxjdWxhdGVIaWxsU2NhcmNpdHlQcmVtaXVtIiwiYmFzZUNvc3RQZXJQZmxvcFllYXIiLCJrQmFja2xvZ0d3IiwidTAiLCJrIiwicmVudEZyYWNNYXgiLCJxdWV1ZVByZXNzdXJlIiwidXRpbFByZXNzdXJlIiwic2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/ground_constraint_penalties.ts\n"));

/***/ })

});