"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/model/ground_ramping_mobilization.ts":
/*!******************************************************!*\
  !*** ./app/lib/model/ground_ramping_mobilization.ts ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_MOBILIZATION_PARAMS: function() { return /* binding */ DEFAULT_MOBILIZATION_PARAMS; },\n/* harmony export */   calculateBuildRateGWyr: function() { return /* binding */ calculateBuildRateGWyr; },\n/* harmony export */   calculateDemandGW: function() { return /* binding */ calculateDemandGW; },\n/* harmony export */   stepMobilizationState: function() { return /* binding */ stepMobilizationState; }\n/* harmony export */ });\n/**\n * Ground Ramping Mobilization Model\n * \n * Models demand growth with price-responsive demand and buildout capacity\n * ramping with investment response. Tracks capacity evolution, pipeline, backlog,\n * and wait times.\n * \n * NEW: Price-responsive demand and investment-responsive buildout (replaces fixed anchors)\n */ /**\n * Calculate demand GW using piecewise exponential to hit anchors\n * \n * r1 = ln(450 / demand2025) / (2040-2025)\n * r2 = ln(demand2060 / 450) / (2060-2040)\n * demandGw(t) = t<=2040 ? demand2025*exp(r1*(t-2025)) : 450*exp(r2*(t-2040))\n */ function calculateDemandGW(year, params) {\n    let pue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1.3;\n    const { demandAnchorsGW, demandIsFacilityLoad, demandCurve } = params;\n    const demand2025 = demandAnchorsGW[2025];\n    const demand2040 = demandAnchorsGW[2040];\n    const demand2060 = demandAnchorsGW[2060];\n    if (demandCurve !== \"piecewise_exponential\") {\n        throw new Error(\"Unsupported demandCurve: \".concat(demandCurve, \". Only 'piecewise_exponential' is supported.\"));\n    }\n    if (year < 2025) {\n        return demand2025;\n    }\n    let demandGW;\n    if (year <= 2040) {\n        // Phase 1: 2025-2040\n        // r1 = ln(demand2040 / demand2025) / (2040-2025)\n        const r1 = Math.log(demand2040 / demand2025) / (2040 - 2025);\n        const yearsFrom2025 = year - 2025;\n        demandGW = demand2025 * Math.exp(r1 * yearsFrom2025);\n    } else {\n        // Phase 2: 2040-2060\n        // r2 = ln(demand2060 / demand2040) / (2060-2040)\n        const r2 = Math.log(demand2060 / demand2040) / (2060 - 2040);\n        const yearsFrom2040 = year - 2040;\n        demandGW = demand2040 * Math.exp(r2 * yearsFrom2040);\n    }\n    // Apply PUE if demand is IT load (not facility load)\n    if (!demandIsFacilityLoad) {\n        demandGW = demandGW * pue;\n    }\n    // Hard asserts in dev mode\n    if (true) {\n        if (year === 2040) {\n            const actual2040 = demandGW;\n            const error2040 = Math.abs(actual2040 - demand2040) / demand2040;\n            if (error2040 >= 0.03) {\n                throw new Error(\"[DEMAND ANCHOR FAIL] demandGw(2040)=\".concat(actual2040.toFixed(2), \" GW, \") + \"expected=\".concat(demand2040, \" GW, error=\").concat((error2040 * 100).toFixed(2), \"% >= 3%\"));\n            }\n        }\n        if (year === 2060) {\n            if (demandGW < 2000) {\n                throw new Error(\"[DEMAND ANCHOR FAIL] demandGw(2060)=\".concat(demandGW.toFixed(2), \" GW < 2000 GW. \") + \"Must be >= 2000 GW (multi-TW target).\");\n            }\n        }\n    }\n    return demandGW;\n}\n/**\n * Smooth interpolation for buildout anchors\n * Uses moving average with smoothing window\n */ function calculateBuildRateGWyr(year, params) {\n    const { buildoutAnchorsGWyr, buildoutSmoothingYears } = params;\n    const anchors = buildoutAnchorsGWyr;\n    // Find surrounding anchors\n    const anchorYears = Object.keys(anchors).map(Number).sort((a, b)=>a - b);\n    // Before first anchor: use first anchor value\n    if (year <= anchorYears[0]) {\n        return anchors[anchorYears[0]];\n    }\n    // After last anchor: use last anchor value\n    if (year >= anchorYears[anchorYears.length - 1]) {\n        return anchors[anchorYears[anchorYears.length - 1]];\n    }\n    // Find surrounding anchors\n    let lowerYear = anchorYears[0];\n    let upperYear = anchorYears[anchorYears.length - 1];\n    for(let i = 0; i < anchorYears.length - 1; i++){\n        if (year >= anchorYears[i] && year <= anchorYears[i + 1]) {\n            lowerYear = anchorYears[i];\n            upperYear = anchorYears[i + 1];\n            break;\n        }\n    }\n    const lowerRate = anchors[lowerYear];\n    const upperRate = anchors[upperYear];\n    // Exponential interpolation for buildout ramp\n    const t = (year - lowerYear) / (upperYear - lowerYear);\n    const buildRate = lowerRate * Math.pow(upperRate / lowerRate, t);\n    // Apply smoothing: moving average over smoothing window\n    if (buildoutSmoothingYears > 0) {\n        const smoothingWindow = buildoutSmoothingYears;\n        let smoothedSum = buildRate;\n        let count = 1;\n        // Helper function to calculate unsmoothed rate\n        const getUnsmoothedRate = (y)=>{\n            if (y <= anchorYears[0]) return anchors[anchorYears[0]];\n            if (y >= anchorYears[anchorYears.length - 1]) return anchors[anchorYears[anchorYears.length - 1]];\n            let lower = anchorYears[0];\n            let upper = anchorYears[anchorYears.length - 1];\n            for(let i = 0; i < anchorYears.length - 1; i++){\n                if (y >= anchorYears[i] && y <= anchorYears[i + 1]) {\n                    lower = anchorYears[i];\n                    upper = anchorYears[i + 1];\n                    break;\n                }\n            }\n            const lowerRate = anchors[lower];\n            const upperRate = anchors[upper];\n            const t = (y - lower) / (upper - lower);\n            return lowerRate * Math.pow(upperRate / lowerRate, t);\n        };\n        for(let offset = 1; offset <= Math.floor(smoothingWindow / 2); offset++){\n            const prevYear = year - offset;\n            const nextYear = year + offset;\n            if (prevYear >= anchorYears[0]) {\n                const prevRate = getUnsmoothedRate(prevYear);\n                smoothedSum += prevRate;\n                count++;\n            }\n            if (nextYear <= anchorYears[anchorYears.length - 1]) {\n                const nextRate = getUnsmoothedRate(nextYear);\n                smoothedSum += nextRate;\n                count++;\n            }\n        }\n        return smoothedSum / count;\n    }\n    return buildRate;\n}\n/**\n * Calculate bottleneck rate from anchors (same interpolation as buildout)\n */ function calculateBottleneckRateGWyr(year, anchors) {\n    const anchorYears = [\n        2025,\n        2030,\n        2040,\n        2060\n    ];\n    // Before first anchor: use first anchor value\n    if (year <= anchorYears[0]) {\n        return anchors[2025];\n    }\n    // After last anchor: use last anchor value\n    if (year >= anchorYears[anchorYears.length - 1]) {\n        return anchors[2060];\n    }\n    // Find surrounding anchors\n    let lowerYear = anchorYears[0];\n    let upperYear = anchorYears[anchorYears.length - 1];\n    for(let i = 0; i < anchorYears.length - 1; i++){\n        if (year >= anchorYears[i] && year <= anchorYears[i + 1]) {\n            lowerYear = anchorYears[i];\n            upperYear = anchorYears[i + 1];\n            break;\n        }\n    }\n    const lowerRate = anchors[lowerYear];\n    const upperRate = anchors[upperYear];\n    // Exponential interpolation\n    const t = (year - lowerYear) / (upperYear - lowerYear);\n    return lowerRate * Math.pow(upperRate / lowerRate, t);\n}\n/**\n * Step mobilization state forward one year\n */ function stepMobilizationState(prevState, params, year) {\n    let pue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1.3, retirementsGW = arguments.length > 4 && arguments[4] !== void 0 // Optional retirements (default 0)\n     ? arguments[4] : 0;\n    // Calculate demand\n    const demandGW = calculateDemandGW(year, params, pue);\n    var _prevState_demandGW;\n    const demandGWPrev = (_prevState_demandGW = prevState === null || prevState === void 0 ? void 0 : prevState.demandGW) !== null && _prevState_demandGW !== void 0 ? _prevState_demandGW : calculateDemandGW(year - 1, params, pue);\n    const demandNewGW = Math.max(0, demandGW - demandGWPrev);\n    // Calculate build rate candidate (from anchors)\n    const buildRateCandidate = calculateBuildRateGWyr(year, params);\n    var _params_bottleneckMode;\n    // Apply bottleneck constraints if enabled\n    const bottleneckMode = (_params_bottleneckMode = params.bottleneckMode) !== null && _params_bottleneckMode !== void 0 ? _params_bottleneckMode : \"min_of_bottlenecks\";\n    let buildRateGWyr = buildRateCandidate;\n    let bottleneckRateGWyr;\n    let limitingBottleneck = \"candidate\";\n    if (bottleneckMode === \"min_of_bottlenecks\" && params.bottleneckAnchorsGWyr) {\n        const { transformers, substations, tx, generation } = params.bottleneckAnchorsGWyr;\n        const transformersRate = calculateBottleneckRateGWyr(year, transformers);\n        const substationsRate = calculateBottleneckRateGWyr(year, substations);\n        const txRate = calculateBottleneckRateGWyr(year, tx);\n        const generationRate = calculateBottleneckRateGWyr(year, generation);\n        // Find minimum bottleneck\n        bottleneckRateGWyr = Math.min(transformersRate, substationsRate, txRate, generationRate);\n        // Determine which bottleneck is limiting\n        if (bottleneckRateGWyr === transformersRate) {\n            limitingBottleneck = \"transformers\";\n        } else if (bottleneckRateGWyr === substationsRate) {\n            limitingBottleneck = \"substations\";\n        } else if (bottleneckRateGWyr === txRate) {\n            limitingBottleneck = \"tx\";\n        } else if (bottleneckRateGWyr === generationRate) {\n            limitingBottleneck = \"generation\";\n        }\n        // Effective build rate is minimum of candidate and bottleneck\n        buildRateGWyr = Math.min(buildRateCandidate, bottleneckRateGWyr);\n    } else {\n        limitingBottleneck = \"none\";\n    }\n    var _params_rampLimitFracPerYear;\n    // Apply ramp limiter (prevent sudden jumps)\n    const rampLimitFrac = (_params_rampLimitFracPerYear = params.rampLimitFracPerYear) !== null && _params_rampLimitFracPerYear !== void 0 ? _params_rampLimitFracPerYear : 0.25;\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.buildRateGWyr) !== undefined) {\n        const prevRate = prevState.buildRateGWyr;\n        const minRate = prevRate * (1 - rampLimitFrac);\n        const maxRate = prevRate * (1 + rampLimitFrac);\n        buildRateGWyr = Math.max(minRate, Math.min(maxRate, buildRateGWyr));\n    }\n    var _prevState_capacityGW;\n    // Calculate capacity evolution\n    // capacityGw(t) = capacityGw(t-1) + buildRateGwYear(t) - retirementsGw(t)\n    const capacityGWPrev = (_prevState_capacityGW = prevState === null || prevState === void 0 ? void 0 : prevState.capacityGW) !== null && _prevState_capacityGW !== void 0 ? _prevState_capacityGW : 0;\n    const capacityGW = capacityGWPrev + buildRateGWyr - retirementsGW;\n    // Calculate pipeline\n    // pipelineGw(t) = buildRateGwYear(t) * pipelineLeadTimeYears * pipelineFillFrac\n    const pipelineGW = buildRateGWyr * params.pipelineLeadTimeYears * params.pipelineFillFrac;\n    var _prevState_backlogGW;\n    // Calculate backlog\n    // backlogGw(t) = max(0, backlogGw(t-1) + demandNewGw(t) - buildableGw(t))\n    const backlogGWPrev = (_prevState_backlogGW = prevState === null || prevState === void 0 ? void 0 : prevState.backlogGW) !== null && _prevState_backlogGW !== void 0 ? _prevState_backlogGW : 0;\n    const buildableGW = buildRateGWyr;\n    const backlogGW = Math.max(0, backlogGWPrev + demandNewGW - buildableGW);\n    // Hard assert: If demandNewGw(t) > buildRateGwYear(t), backlogGw must increase\n    if (true) {\n        if (demandNewGW > buildRateGWyr && backlogGW <= backlogGWPrev) {\n            throw new Error(\"[BUILDOUT INVARIANT] Year \".concat(year, \": demandNewGW=\").concat(demandNewGW.toFixed(2), \" > \") + \"buildRateGWyr=\".concat(buildRateGWyr.toFixed(2), \", but backlogGW=\").concat(backlogGW.toFixed(2), \" \") + \"<= prevBacklogGW=\".concat(backlogGWPrev.toFixed(2), \". Backlog must increase.\"));\n        }\n    }\n    // Calculate average wait time\n    // avgWaitYears(t) = backlogGw(t) / max(buildRateGwYear(t), 1e-9)\n    const EPS = 1e-9;\n    const avgWaitYears = backlogGW / Math.max(buildRateGWyr, EPS);\n    // Calculate growth rate (for debug)\n    let demandGrowthRate;\n    if (year <= 2040) {\n        demandGrowthRate = Math.log(params.demandAnchorsGW[2040] / params.demandAnchorsGW[2025]) / 15;\n    } else {\n        demandGrowthRate = Math.log(params.demandAnchorsGW[2060] / params.demandAnchorsGW[2040]) / 20;\n    }\n    return {\n        year,\n        demandGW,\n        demandNewGW,\n        buildRateGWyr,\n        capacityGW,\n        pipelineGW,\n        backlogGW,\n        avgWaitYears,\n        demandGrowthRate,\n        buildoutSmoothFactor: params.buildoutSmoothingYears,\n        bottleneckRateGWyr,\n        limitingBottleneck,\n        buildRateCandidate\n    };\n}\n/**\n * Default mobilization scenario parameters\n */ const DEFAULT_MOBILIZATION_PARAMS = {\n    demandAnchorsGW: {\n        2025: 120,\n        2040: 450,\n        2060: 3000\n    },\n    demandCurve: \"piecewise_exponential\",\n    demandIsFacilityLoad: true,\n    buildoutAnchorsGWyr: {\n        2025: 25,\n        2030: 60,\n        2040: 140,\n        2060: 220\n    },\n    buildoutSmoothingYears: 3,\n    pipelineLeadTimeYears: 3,\n    pipelineFillFrac: 1.5,\n    bottleneckMode: \"min_of_bottlenecks\",\n    bottleneckAnchorsGWyr: {\n        transformers: {\n            2025: 30,\n            2030: 50,\n            2040: 100,\n            2060: 180\n        },\n        substations: {\n            2025: 35,\n            2030: 55,\n            2040: 110,\n            2060: 200\n        },\n        tx: {\n            2025: 40,\n            2030: 65,\n            2040: 130,\n            2060: 250\n        },\n        generation: {\n            2025: 50,\n            2030: 80,\n            2040: 160,\n            2060: 300\n        }\n    },\n    rampLimitFracPerYear: 0.25\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX3JhbXBpbmdfbW9iaWxpemF0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Q0FRQyxHQW1FRDs7Ozs7O0NBTUMsR0FDTSxTQUFTQSxrQkFDZEMsSUFBWSxFQUNaQyxNQUFrQztRQUNsQ0MsTUFBQUEsaUVBQWM7SUFFZCxNQUFNLEVBQUVDLGVBQWUsRUFBRUMsb0JBQW9CLEVBQUVDLFdBQVcsRUFBRSxHQUFHSjtJQUMvRCxNQUFNSyxhQUFhSCxlQUFlLENBQUMsS0FBSztJQUN4QyxNQUFNSSxhQUFhSixlQUFlLENBQUMsS0FBSztJQUN4QyxNQUFNSyxhQUFhTCxlQUFlLENBQUMsS0FBSztJQUV4QyxJQUFJRSxnQkFBZ0IseUJBQXlCO1FBQzNDLE1BQU0sSUFBSUksTUFBTSw0QkFBd0MsT0FBWkosYUFBWTtJQUMxRDtJQUVBLElBQUlMLE9BQU8sTUFBTTtRQUNmLE9BQU9NO0lBQ1Q7SUFFQSxJQUFJSTtJQUVKLElBQUlWLFFBQVEsTUFBTTtRQUNoQixxQkFBcUI7UUFDckIsaURBQWlEO1FBQ2pELE1BQU1XLEtBQUtDLEtBQUtDLEdBQUcsQ0FBQ04sYUFBYUQsY0FBZSxRQUFPLElBQUc7UUFDMUQsTUFBTVEsZ0JBQWdCZCxPQUFPO1FBQzdCVSxXQUFXSixhQUFhTSxLQUFLRyxHQUFHLENBQUNKLEtBQUtHO0lBQ3hDLE9BQU87UUFDTCxxQkFBcUI7UUFDckIsaURBQWlEO1FBQ2pELE1BQU1FLEtBQUtKLEtBQUtDLEdBQUcsQ0FBQ0wsYUFBYUQsY0FBZSxRQUFPLElBQUc7UUFDMUQsTUFBTVUsZ0JBQWdCakIsT0FBTztRQUM3QlUsV0FBV0gsYUFBYUssS0FBS0csR0FBRyxDQUFDQyxLQUFLQztJQUN4QztJQUVBLHFEQUFxRDtJQUNyRCxJQUFJLENBQUNiLHNCQUFzQjtRQUN6Qk0sV0FBV0EsV0FBV1I7SUFDeEI7SUFFQSwyQkFBMkI7SUFDM0IsSUFBSWdCLElBQXlCLEVB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QUksTUFBTTtZQUFJLE1BQU07WUFBSyxNQUFNO1FBQUk7UUFDeERDLElBQUk7WUFBRSxNQUFNO1lBQUksTUFBTTtZQUFJLE1BQU07WUFBSyxNQUFNO1FBQUk7UUFDL0NDLFlBQVk7WUFBRSxNQUFNO1lBQUksTUFBTTtZQUFJLE1BQU07WUFBSyxNQUFNO1FBQUk7SUFDekQ7SUFDQU8sc0JBQXNCO0FBQ3hCLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9tb2RlbC9ncm91bmRfcmFtcGluZ19tb2JpbGl6YXRpb24udHM/NDQ1OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdyb3VuZCBSYW1waW5nIE1vYmlsaXphdGlvbiBNb2RlbFxuICogXG4gKiBNb2RlbHMgZGVtYW5kIGdyb3d0aCB3aXRoIHByaWNlLXJlc3BvbnNpdmUgZGVtYW5kIGFuZCBidWlsZG91dCBjYXBhY2l0eVxuICogcmFtcGluZyB3aXRoIGludmVzdG1lbnQgcmVzcG9uc2UuIFRyYWNrcyBjYXBhY2l0eSBldm9sdXRpb24sIHBpcGVsaW5lLCBiYWNrbG9nLFxuICogYW5kIHdhaXQgdGltZXMuXG4gKiBcbiAqIE5FVzogUHJpY2UtcmVzcG9uc2l2ZSBkZW1hbmQgYW5kIGludmVzdG1lbnQtcmVzcG9uc2l2ZSBidWlsZG91dCAocmVwbGFjZXMgZml4ZWQgYW5jaG9ycylcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIERlbWFuZFBhcmFtcyB7XG4gIGJhc2VEZW1hbmQyMDI1R1c6IG51bWJlcjsgICAgICAgIC8vIDEyMCBHV1xuICBvcmdhbmljR3Jvd3RoUmF0ZTogbnVtYmVyOyAgICAgICAvLyAwLjEwICgxMCUgQ0FHUiBiYXNlKVxuICBwcmljZUVsYXN0aWNpdHk6IG51bWJlcjsgICAgICAgICAvLyAtMC4zICgzMCUgZGVtYW5kIGRyb3AgcGVyIDEwMCUgcHJpY2UgaW5jcmVhc2UpXG4gIHdhaXRFbGFzdGljaXR5OiBudW1iZXI7ICAgICAgICAgIC8vIC0wLjIgKDIwJSBkZW1hbmQgZHJvcCBwZXIgNXlyIHdhaXQpXG4gIG9yYml0YWxTdWJzdGl0dXRpb25UaHJlc2hvbGQ6IG51bWJlcjsgLy8gUHJpY2UgcmF0aW8gYXQgd2hpY2ggZGVtYW5kIHNoaWZ0cyB0byBvcmJpdGFsIChkZWZhdWx0IDEuMiA9IDIwJSBjaGVhcGVyKVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJ1aWxkb3V0UGFyYW1zIHtcbiAgYmFzZUJ1aWxkUmF0ZTIwMjVHV3lyOiBudW1iZXI7ICAgLy8gMjUgR1cveXJcbiAgbWF4QnVpbGRSYXRlR1d5cjogbnVtYmVyOyAgICAgICAgLy8gMTUwIEdXL3lyIHBoeXNpY2FsIGxpbWl0XG4gIGludmVzdG1lbnRFbGFzdGljaXR5OiBudW1iZXI7ICAgICAvLyAwLjUgKDUwJSBtb3JlIGludmVzdG1lbnQgcGVyIDEwMCUgbWFyZ2luIGluY3JlYXNlKVxuICByYW1wTGltaXRQZXJZZWFyOiBudW1iZXI7ICAgICAgICAgLy8gMC4yNSAoMjUlIG1heCBpbmNyZWFzZSBwZXIgeWVhcilcbiAgYmFja2xvZ1Jlc3BvbnNlSzogbnVtYmVyOyAgICAgICAgIC8vIDAuMyAoaG93IGZhc3QgYnVpbGRvdXQgcmVzcG9uZHMgdG8gYmFja2xvZylcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb2JpbGl6YXRpb25TY2VuYXJpb1BhcmFtcyB7XG4gIGRlbWFuZEFuY2hvcnNHVzoge1xuICAgIDIwMjU6IG51bWJlcjtcbiAgICAyMDQwOiBudW1iZXI7XG4gICAgMjA2MDogbnVtYmVyO1xuICB9O1xuICBkZW1hbmRDdXJ2ZTogJ3BpZWNld2lzZV9leHBvbmVudGlhbCc7IC8vIEN1cnZlIHR5cGUgKG9ubHkgcGllY2V3aXNlX2V4cG9uZW50aWFsIHN1cHBvcnRlZClcbiAgZGVtYW5kSXNGYWNpbGl0eUxvYWQ6IGJvb2xlYW47IC8vIElmIHRydWUsIGluY2x1ZGVzIFBVRTsgaWYgZmFsc2UsIG11bHRpcGx5IGJ5IFBVRSBsYXRlclxuICBidWlsZG91dEFuY2hvcnNHV3lyOiB7XG4gICAgMjAyNTogbnVtYmVyO1xuICAgIDIwMzA6IG51bWJlcjtcbiAgICAyMDQwOiBudW1iZXI7XG4gICAgMjA2MDogbnVtYmVyO1xuICB9O1xuICBidWlsZG91dFNtb290aGluZ1llYXJzOiBudW1iZXI7IC8vIFNtb290aGluZyB3aW5kb3cgZm9yIGJ1aWxkb3V0IGludGVycG9sYXRpb25cbiAgcGlwZWxpbmVMZWFkVGltZVllYXJzOiBudW1iZXI7IC8vIExlYWQgdGltZSBmb3IgcGlwZWxpbmUgY2FsY3VsYXRpb25cbiAgcGlwZWxpbmVGaWxsRnJhYzogbnVtYmVyOyAvLyBQaXBlbGluZSBmaWxsIGZyYWN0aW9uIChwaXBlbGluZUdXID0gbGVhZFRpbWUgKiBidWlsZFJhdGUgKiBmaWxsRnJhYylcbiAgLy8gQm90dGxlbmVjayBjb25zdHJhaW50c1xuICBib3R0bGVuZWNrTW9kZT86ICdvZmYnIHwgJ21pbl9vZl9ib3R0bGVuZWNrcyc7IC8vIERlZmF1bHQgJ21pbl9vZl9ib3R0bGVuZWNrcydcbiAgYm90dGxlbmVja0FuY2hvcnNHV3lyPzoge1xuICAgIHRyYW5zZm9ybWVyczogeyAyMDI1OiBudW1iZXI7IDIwMzA6IG51bWJlcjsgMjA0MDogbnVtYmVyOyAyMDYwOiBudW1iZXIgfTtcbiAgICBzdWJzdGF0aW9uczogeyAyMDI1OiBudW1iZXI7IDIwMzA6IG51bWJlcjsgMjA0MDogbnVtYmVyOyAyMDYwOiBudW1iZXIgfTtcbiAgICB0eDogeyAyMDI1OiBudW1iZXI7IDIwMzA6IG51bWJlcjsgMjA0MDogbnVtYmVyOyAyMDYwOiBudW1iZXIgfTtcbiAgICBnZW5lcmF0aW9uOiB7IDIwMjU6IG51bWJlcjsgMjAzMDogbnVtYmVyOyAyMDQwOiBudW1iZXI7IDIwNjA6IG51bWJlciB9O1xuICB9O1xuICByYW1wTGltaXRGcmFjUGVyWWVhcj86IG51bWJlcjsgLy8gTWF4IGZyYWN0aW9uYWwgY2hhbmdlIHBlciB5ZWFyIChkZWZhdWx0IDAuMjUgPSAyNSUpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9iaWxpemF0aW9uU3RhdGUge1xuICB5ZWFyOiBudW1iZXI7XG4gIGRlbWFuZEdXOiBudW1iZXI7IC8vIFRvdGFsIGRlbWFuZCAoSVQgb3IgZmFjaWxpdHkgbG9hZClcbiAgZGVtYW5kTmV3R1c6IG51bWJlcjsgLy8gSW5jcmVtZW50YWwgZGVtYW5kIHRoaXMgeWVhclxuICBidWlsZFJhdGVHV3lyOiBudW1iZXI7IC8vIEJ1aWxkIHJhdGUgdGhpcyB5ZWFyIChHVy95ZWFyKVxuICBjYXBhY2l0eUdXOiBudW1iZXI7IC8vIEN1bXVsYXRpdmUgY2FwYWNpdHkgYnVpbHRcbiAgcGlwZWxpbmVHVzogbnVtYmVyOyAvLyBQaXBlbGluZSBjYXBhY2l0eSAodW5kZXIgY29uc3RydWN0aW9uKVxuICBiYWNrbG9nR1c6IG51bWJlcjsgLy8gQmFja2xvZyB3YWl0aW5nIHRvIGJlIGJ1aWx0XG4gIGF2Z1dhaXRZZWFyczogbnVtYmVyOyAvLyBBdmVyYWdlIHdhaXQgdGltZSAoYmFja2xvZyAvIGJ1aWxkUmF0ZSlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb2JpbGl6YXRpb25SZXN1bHQgZXh0ZW5kcyBNb2JpbGl6YXRpb25TdGF0ZSB7XG4gIC8vIEFkZGl0aW9uYWwgZGVidWcgZmllbGRzXG4gIGRlbWFuZEdyb3d0aFJhdGU6IG51bWJlcjsgLy8gQ3VycmVudCBncm93dGggcmF0ZSAocjEgb3IgcjIpXG4gIGJ1aWxkb3V0U21vb3RoRmFjdG9yOiBudW1iZXI7IC8vIFNtb290aGluZyBmYWN0b3IgYXBwbGllZFxuICAvLyBCb3R0bGVuZWNrIGRlYnVnIGZpZWxkc1xuICBib3R0bGVuZWNrUmF0ZUdXeXI/OiBudW1iZXI7IC8vIEVmZmVjdGl2ZSBib3R0bGVuZWNrIHJhdGUgKG1pbiBvZiBhbGwgYm90dGxlbmVja3MpXG4gIGxpbWl0aW5nQm90dGxlbmVjaz86ICd0cmFuc2Zvcm1lcnMnIHwgJ3N1YnN0YXRpb25zJyB8ICd0eCcgfCAnZ2VuZXJhdGlvbicgfCAnY2FuZGlkYXRlJyB8ICdub25lJzsgLy8gV2hpY2ggYm90dGxlbmVjayBpcyBsaW1pdGluZ1xuICBidWlsZFJhdGVDYW5kaWRhdGU/OiBudW1iZXI7IC8vIE9yaWdpbmFsIGJ1aWxkIHJhdGUgYmVmb3JlIGJvdHRsZW5lY2svcmFtcCBsaW1pdHNcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgZGVtYW5kIEdXIHVzaW5nIHBpZWNld2lzZSBleHBvbmVudGlhbCB0byBoaXQgYW5jaG9yc1xuICogXG4gKiByMSA9IGxuKDQ1MCAvIGRlbWFuZDIwMjUpIC8gKDIwNDAtMjAyNSlcbiAqIHIyID0gbG4oZGVtYW5kMjA2MCAvIDQ1MCkgLyAoMjA2MC0yMDQwKVxuICogZGVtYW5kR3codCkgPSB0PD0yMDQwID8gZGVtYW5kMjAyNSpleHAocjEqKHQtMjAyNSkpIDogNDUwKmV4cChyMioodC0yMDQwKSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZURlbWFuZEdXKFxuICB5ZWFyOiBudW1iZXIsXG4gIHBhcmFtczogTW9iaWxpemF0aW9uU2NlbmFyaW9QYXJhbXMsXG4gIHB1ZTogbnVtYmVyID0gMS4zXG4pOiBudW1iZXIge1xuICBjb25zdCB7IGRlbWFuZEFuY2hvcnNHVywgZGVtYW5kSXNGYWNpbGl0eUxvYWQsIGRlbWFuZEN1cnZlIH0gPSBwYXJhbXM7XG4gIGNvbnN0IGRlbWFuZDIwMjUgPSBkZW1hbmRBbmNob3JzR1dbMjAyNV07XG4gIGNvbnN0IGRlbWFuZDIwNDAgPSBkZW1hbmRBbmNob3JzR1dbMjA0MF07XG4gIGNvbnN0IGRlbWFuZDIwNjAgPSBkZW1hbmRBbmNob3JzR1dbMjA2MF07XG4gIFxuICBpZiAoZGVtYW5kQ3VydmUgIT09ICdwaWVjZXdpc2VfZXhwb25lbnRpYWwnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkZW1hbmRDdXJ2ZTogJHtkZW1hbmRDdXJ2ZX0uIE9ubHkgJ3BpZWNld2lzZV9leHBvbmVudGlhbCcgaXMgc3VwcG9ydGVkLmApO1xuICB9XG4gIFxuICBpZiAoeWVhciA8IDIwMjUpIHtcbiAgICByZXR1cm4gZGVtYW5kMjAyNTtcbiAgfVxuICBcbiAgbGV0IGRlbWFuZEdXOiBudW1iZXI7XG4gIFxuICBpZiAoeWVhciA8PSAyMDQwKSB7XG4gICAgLy8gUGhhc2UgMTogMjAyNS0yMDQwXG4gICAgLy8gcjEgPSBsbihkZW1hbmQyMDQwIC8gZGVtYW5kMjAyNSkgLyAoMjA0MC0yMDI1KVxuICAgIGNvbnN0IHIxID0gTWF0aC5sb2coZGVtYW5kMjA0MCAvIGRlbWFuZDIwMjUpIC8gKDIwNDAgLSAyMDI1KTtcbiAgICBjb25zdCB5ZWFyc0Zyb20yMDI1ID0geWVhciAtIDIwMjU7XG4gICAgZGVtYW5kR1cgPSBkZW1hbmQyMDI1ICogTWF0aC5leHAocjEgKiB5ZWFyc0Zyb20yMDI1KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQaGFzZSAyOiAyMDQwLTIwNjBcbiAgICAvLyByMiA9IGxuKGRlbWFuZDIwNjAgLyBkZW1hbmQyMDQwKSAvICgyMDYwLTIwNDApXG4gICAgY29uc3QgcjIgPSBNYXRoLmxvZyhkZW1hbmQyMDYwIC8gZGVtYW5kMjA0MCkgLyAoMjA2MCAtIDIwNDApO1xuICAgIGNvbnN0IHllYXJzRnJvbTIwNDAgPSB5ZWFyIC0gMjA0MDtcbiAgICBkZW1hbmRHVyA9IGRlbWFuZDIwNDAgKiBNYXRoLmV4cChyMiAqIHllYXJzRnJvbTIwNDApO1xuICB9XG4gIFxuICAvLyBBcHBseSBQVUUgaWYgZGVtYW5kIGlzIElUIGxvYWQgKG5vdCBmYWNpbGl0eSBsb2FkKVxuICBpZiAoIWRlbWFuZElzRmFjaWxpdHlMb2FkKSB7XG4gICAgZGVtYW5kR1cgPSBkZW1hbmRHVyAqIHB1ZTtcbiAgfVxuICBcbiAgLy8gSGFyZCBhc3NlcnRzIGluIGRldiBtb2RlXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGlmICh5ZWFyID09PSAyMDQwKSB7XG4gICAgICBjb25zdCBhY3R1YWwyMDQwID0gZGVtYW5kR1c7XG4gICAgICBjb25zdCBlcnJvcjIwNDAgPSBNYXRoLmFicyhhY3R1YWwyMDQwIC0gZGVtYW5kMjA0MCkgLyBkZW1hbmQyMDQwO1xuICAgICAgaWYgKGVycm9yMjA0MCA+PSAwLjAzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgW0RFTUFORCBBTkNIT1IgRkFJTF0gZGVtYW5kR3coMjA0MCk9JHthY3R1YWwyMDQwLnRvRml4ZWQoMil9IEdXLCBgICtcbiAgICAgICAgICBgZXhwZWN0ZWQ9JHtkZW1hbmQyMDQwfSBHVywgZXJyb3I9JHsoZXJyb3IyMDQwICogMTAwKS50b0ZpeGVkKDIpfSUgPj0gMyVgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmICh5ZWFyID09PSAyMDYwKSB7XG4gICAgICBpZiAoZGVtYW5kR1cgPCAyMDAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgW0RFTUFORCBBTkNIT1IgRkFJTF0gZGVtYW5kR3coMjA2MCk9JHtkZW1hbmRHVy50b0ZpeGVkKDIpfSBHVyA8IDIwMDAgR1cuIGAgK1xuICAgICAgICAgIGBNdXN0IGJlID49IDIwMDAgR1cgKG11bHRpLVRXIHRhcmdldCkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIGRlbWFuZEdXO1xufVxuXG4vKipcbiAqIFNtb290aCBpbnRlcnBvbGF0aW9uIGZvciBidWlsZG91dCBhbmNob3JzXG4gKiBVc2VzIG1vdmluZyBhdmVyYWdlIHdpdGggc21vb3RoaW5nIHdpbmRvd1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQnVpbGRSYXRlR1d5cihcbiAgeWVhcjogbnVtYmVyLFxuICBwYXJhbXM6IE1vYmlsaXphdGlvblNjZW5hcmlvUGFyYW1zXG4pOiBudW1iZXIge1xuICBjb25zdCB7IGJ1aWxkb3V0QW5jaG9yc0dXeXIsIGJ1aWxkb3V0U21vb3RoaW5nWWVhcnMgfSA9IHBhcmFtcztcbiAgY29uc3QgYW5jaG9ycyA9IGJ1aWxkb3V0QW5jaG9yc0dXeXI7XG4gIFxuICAvLyBGaW5kIHN1cnJvdW5kaW5nIGFuY2hvcnNcbiAgY29uc3QgYW5jaG9yWWVhcnMgPSBPYmplY3Qua2V5cyhhbmNob3JzKS5tYXAoTnVtYmVyKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIFxuICAvLyBCZWZvcmUgZmlyc3QgYW5jaG9yOiB1c2UgZmlyc3QgYW5jaG9yIHZhbHVlXG4gIGlmICh5ZWFyIDw9IGFuY2hvclllYXJzWzBdKSB7XG4gICAgcmV0dXJuIGFuY2hvcnNbYW5jaG9yWWVhcnNbMF0gYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICB9XG4gIFxuICAvLyBBZnRlciBsYXN0IGFuY2hvcjogdXNlIGxhc3QgYW5jaG9yIHZhbHVlXG4gIGlmICh5ZWFyID49IGFuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdKSB7XG4gICAgcmV0dXJuIGFuY2hvcnNbYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV0gYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICB9XG4gIFxuICAvLyBGaW5kIHN1cnJvdW5kaW5nIGFuY2hvcnNcbiAgbGV0IGxvd2VyWWVhciA9IGFuY2hvclllYXJzWzBdO1xuICBsZXQgdXBwZXJZZWFyID0gYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV07XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFuY2hvclllYXJzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmICh5ZWFyID49IGFuY2hvclllYXJzW2ldICYmIHllYXIgPD0gYW5jaG9yWWVhcnNbaSArIDFdKSB7XG4gICAgICBsb3dlclllYXIgPSBhbmNob3JZZWFyc1tpXTtcbiAgICAgIHVwcGVyWWVhciA9IGFuY2hvclllYXJzW2kgKyAxXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBcbiAgY29uc3QgbG93ZXJSYXRlID0gYW5jaG9yc1tsb3dlclllYXIgYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICBjb25zdCB1cHBlclJhdGUgPSBhbmNob3JzW3VwcGVyWWVhciBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gIFxuICAvLyBFeHBvbmVudGlhbCBpbnRlcnBvbGF0aW9uIGZvciBidWlsZG91dCByYW1wXG4gIGNvbnN0IHQgPSAoeWVhciAtIGxvd2VyWWVhcikgLyAodXBwZXJZZWFyIC0gbG93ZXJZZWFyKTtcbiAgY29uc3QgYnVpbGRSYXRlID0gbG93ZXJSYXRlICogTWF0aC5wb3codXBwZXJSYXRlIC8gbG93ZXJSYXRlLCB0KTtcbiAgXG4gIC8vIEFwcGx5IHNtb290aGluZzogbW92aW5nIGF2ZXJhZ2Ugb3ZlciBzbW9vdGhpbmcgd2luZG93XG4gIGlmIChidWlsZG91dFNtb290aGluZ1llYXJzID4gMCkge1xuICAgIGNvbnN0IHNtb290aGluZ1dpbmRvdyA9IGJ1aWxkb3V0U21vb3RoaW5nWWVhcnM7XG4gICAgbGV0IHNtb290aGVkU3VtID0gYnVpbGRSYXRlO1xuICAgIGxldCBjb3VudCA9IDE7XG4gICAgXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSB1bnNtb290aGVkIHJhdGVcbiAgICBjb25zdCBnZXRVbnNtb290aGVkUmF0ZSA9ICh5OiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgICAgaWYgKHkgPD0gYW5jaG9yWWVhcnNbMF0pIHJldHVybiBhbmNob3JzW2FuY2hvclllYXJzWzBdIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgICAgIGlmICh5ID49IGFuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdKSByZXR1cm4gYW5jaG9yc1thbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXSBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gICAgICBcbiAgICAgIGxldCBsb3dlciA9IGFuY2hvclllYXJzWzBdO1xuICAgICAgbGV0IHVwcGVyID0gYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFuY2hvclllYXJzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoeSA+PSBhbmNob3JZZWFyc1tpXSAmJiB5IDw9IGFuY2hvclllYXJzW2kgKyAxXSkge1xuICAgICAgICAgIGxvd2VyID0gYW5jaG9yWWVhcnNbaV07XG4gICAgICAgICAgdXBwZXIgPSBhbmNob3JZZWFyc1tpICsgMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgbG93ZXJSYXRlID0gYW5jaG9yc1tsb3dlciBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gICAgICBjb25zdCB1cHBlclJhdGUgPSBhbmNob3JzW3VwcGVyIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgICAgIGNvbnN0IHQgPSAoeSAtIGxvd2VyKSAvICh1cHBlciAtIGxvd2VyKTtcbiAgICAgIHJldHVybiBsb3dlclJhdGUgKiBNYXRoLnBvdyh1cHBlclJhdGUgLyBsb3dlclJhdGUsIHQpO1xuICAgIH07XG4gICAgXG4gICAgZm9yIChsZXQgb2Zmc2V0ID0gMTsgb2Zmc2V0IDw9IE1hdGguZmxvb3Ioc21vb3RoaW5nV2luZG93IC8gMik7IG9mZnNldCsrKSB7XG4gICAgICBjb25zdCBwcmV2WWVhciA9IHllYXIgLSBvZmZzZXQ7XG4gICAgICBjb25zdCBuZXh0WWVhciA9IHllYXIgKyBvZmZzZXQ7XG4gICAgICBcbiAgICAgIGlmIChwcmV2WWVhciA+PSBhbmNob3JZZWFyc1swXSkge1xuICAgICAgICBjb25zdCBwcmV2UmF0ZSA9IGdldFVuc21vb3RoZWRSYXRlKHByZXZZZWFyKTtcbiAgICAgICAgc21vb3RoZWRTdW0gKz0gcHJldlJhdGU7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChuZXh0WWVhciA8PSBhbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXSkge1xuICAgICAgICBjb25zdCBuZXh0UmF0ZSA9IGdldFVuc21vb3RoZWRSYXRlKG5leHRZZWFyKTtcbiAgICAgICAgc21vb3RoZWRTdW0gKz0gbmV4dFJhdGU7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBzbW9vdGhlZFN1bSAvIGNvdW50O1xuICB9XG4gIFxuICByZXR1cm4gYnVpbGRSYXRlO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBib3R0bGVuZWNrIHJhdGUgZnJvbSBhbmNob3JzIChzYW1lIGludGVycG9sYXRpb24gYXMgYnVpbGRvdXQpXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUJvdHRsZW5lY2tSYXRlR1d5cihcbiAgeWVhcjogbnVtYmVyLFxuICBhbmNob3JzOiB7IDIwMjU6IG51bWJlcjsgMjAzMDogbnVtYmVyOyAyMDQwOiBudW1iZXI7IDIwNjA6IG51bWJlciB9XG4pOiBudW1iZXIge1xuICBjb25zdCBhbmNob3JZZWFycyA9IFsyMDI1LCAyMDMwLCAyMDQwLCAyMDYwXSBhcyBjb25zdDtcbiAgXG4gIC8vIEJlZm9yZSBmaXJzdCBhbmNob3I6IHVzZSBmaXJzdCBhbmNob3IgdmFsdWVcbiAgaWYgKHllYXIgPD0gYW5jaG9yWWVhcnNbMF0pIHtcbiAgICByZXR1cm4gYW5jaG9yc1syMDI1XTtcbiAgfVxuICBcbiAgLy8gQWZ0ZXIgbGFzdCBhbmNob3I6IHVzZSBsYXN0IGFuY2hvciB2YWx1ZVxuICBpZiAoeWVhciA+PSBhbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXSkge1xuICAgIHJldHVybiBhbmNob3JzWzIwNjBdO1xuICB9XG4gIFxuICAvLyBGaW5kIHN1cnJvdW5kaW5nIGFuY2hvcnNcbiAgbGV0IGxvd2VyWWVhciA9IGFuY2hvclllYXJzWzBdO1xuICBsZXQgdXBwZXJZZWFyID0gYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV07XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFuY2hvclllYXJzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmICh5ZWFyID49IGFuY2hvclllYXJzW2ldICYmIHllYXIgPD0gYW5jaG9yWWVhcnNbaSArIDFdKSB7XG4gICAgICBsb3dlclllYXIgPSBhbmNob3JZZWFyc1tpXTtcbiAgICAgIHVwcGVyWWVhciA9IGFuY2hvclllYXJzW2kgKyAxXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBcbiAgY29uc3QgbG93ZXJSYXRlID0gYW5jaG9yc1tsb3dlclllYXIgYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICBjb25zdCB1cHBlclJhdGUgPSBhbmNob3JzW3VwcGVyWWVhciBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gIFxuICAvLyBFeHBvbmVudGlhbCBpbnRlcnBvbGF0aW9uXG4gIGNvbnN0IHQgPSAoeWVhciAtIGxvd2VyWWVhcikgLyAodXBwZXJZZWFyIC0gbG93ZXJZZWFyKTtcbiAgcmV0dXJuIGxvd2VyUmF0ZSAqIE1hdGgucG93KHVwcGVyUmF0ZSAvIGxvd2VyUmF0ZSwgdCk7XG59XG5cbi8qKlxuICogU3RlcCBtb2JpbGl6YXRpb24gc3RhdGUgZm9yd2FyZCBvbmUgeWVhclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RlcE1vYmlsaXphdGlvblN0YXRlKFxuICBwcmV2U3RhdGU6IE1vYmlsaXphdGlvblN0YXRlIHwgbnVsbCxcbiAgcGFyYW1zOiBNb2JpbGl6YXRpb25TY2VuYXJpb1BhcmFtcyxcbiAgeWVhcjogbnVtYmVyLFxuICBwdWU6IG51bWJlciA9IDEuMyxcbiAgcmV0aXJlbWVudHNHVzogbnVtYmVyID0gMCAvLyBPcHRpb25hbCByZXRpcmVtZW50cyAoZGVmYXVsdCAwKVxuKTogTW9iaWxpemF0aW9uUmVzdWx0IHtcbiAgLy8gQ2FsY3VsYXRlIGRlbWFuZFxuICBjb25zdCBkZW1hbmRHVyA9IGNhbGN1bGF0ZURlbWFuZEdXKHllYXIsIHBhcmFtcywgcHVlKTtcbiAgY29uc3QgZGVtYW5kR1dQcmV2ID0gcHJldlN0YXRlPy5kZW1hbmRHVyA/PyBjYWxjdWxhdGVEZW1hbmRHVyh5ZWFyIC0gMSwgcGFyYW1zLCBwdWUpO1xuICBjb25zdCBkZW1hbmROZXdHVyA9IE1hdGgubWF4KDAsIGRlbWFuZEdXIC0gZGVtYW5kR1dQcmV2KTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBidWlsZCByYXRlIGNhbmRpZGF0ZSAoZnJvbSBhbmNob3JzKVxuICBjb25zdCBidWlsZFJhdGVDYW5kaWRhdGUgPSBjYWxjdWxhdGVCdWlsZFJhdGVHV3lyKHllYXIsIHBhcmFtcyk7XG4gIFxuICAvLyBBcHBseSBib3R0bGVuZWNrIGNvbnN0cmFpbnRzIGlmIGVuYWJsZWRcbiAgY29uc3QgYm90dGxlbmVja01vZGUgPSBwYXJhbXMuYm90dGxlbmVja01vZGUgPz8gJ21pbl9vZl9ib3R0bGVuZWNrcyc7XG4gIGxldCBidWlsZFJhdGVHV3lyID0gYnVpbGRSYXRlQ2FuZGlkYXRlO1xuICBsZXQgYm90dGxlbmVja1JhdGVHV3lyOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIGxldCBsaW1pdGluZ0JvdHRsZW5lY2s6ICd0cmFuc2Zvcm1lcnMnIHwgJ3N1YnN0YXRpb25zJyB8ICd0eCcgfCAnZ2VuZXJhdGlvbicgfCAnY2FuZGlkYXRlJyB8ICdub25lJyA9ICdjYW5kaWRhdGUnO1xuICBcbiAgaWYgKGJvdHRsZW5lY2tNb2RlID09PSAnbWluX29mX2JvdHRsZW5lY2tzJyAmJiBwYXJhbXMuYm90dGxlbmVja0FuY2hvcnNHV3lyKSB7XG4gICAgY29uc3QgeyB0cmFuc2Zvcm1lcnMsIHN1YnN0YXRpb25zLCB0eCwgZ2VuZXJhdGlvbiB9ID0gcGFyYW1zLmJvdHRsZW5lY2tBbmNob3JzR1d5cjtcbiAgICBcbiAgICBjb25zdCB0cmFuc2Zvcm1lcnNSYXRlID0gY2FsY3VsYXRlQm90dGxlbmVja1JhdGVHV3lyKHllYXIsIHRyYW5zZm9ybWVycyk7XG4gICAgY29uc3Qgc3Vic3RhdGlvbnNSYXRlID0gY2FsY3VsYXRlQm90dGxlbmVja1JhdGVHV3lyKHllYXIsIHN1YnN0YXRpb25zKTtcbiAgICBjb25zdCB0eFJhdGUgPSBjYWxjdWxhdGVCb3R0bGVuZWNrUmF0ZUdXeXIoeWVhciwgdHgpO1xuICAgIGNvbnN0IGdlbmVyYXRpb25SYXRlID0gY2FsY3VsYXRlQm90dGxlbmVja1JhdGVHV3lyKHllYXIsIGdlbmVyYXRpb24pO1xuICAgIFxuICAgIC8vIEZpbmQgbWluaW11bSBib3R0bGVuZWNrXG4gICAgYm90dGxlbmVja1JhdGVHV3lyID0gTWF0aC5taW4odHJhbnNmb3JtZXJzUmF0ZSwgc3Vic3RhdGlvbnNSYXRlLCB0eFJhdGUsIGdlbmVyYXRpb25SYXRlKTtcbiAgICBcbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggYm90dGxlbmVjayBpcyBsaW1pdGluZ1xuICAgIGlmIChib3R0bGVuZWNrUmF0ZUdXeXIgPT09IHRyYW5zZm9ybWVyc1JhdGUpIHtcbiAgICAgIGxpbWl0aW5nQm90dGxlbmVjayA9ICd0cmFuc2Zvcm1lcnMnO1xuICAgIH0gZWxzZSBpZiAoYm90dGxlbmVja1JhdGVHV3lyID09PSBzdWJzdGF0aW9uc1JhdGUpIHtcbiAgICAgIGxpbWl0aW5nQm90dGxlbmVjayA9ICdzdWJzdGF0aW9ucyc7XG4gICAgfSBlbHNlIGlmIChib3R0bGVuZWNrUmF0ZUdXeXIgPT09IHR4UmF0ZSkge1xuICAgICAgbGltaXRpbmdCb3R0bGVuZWNrID0gJ3R4JztcbiAgICB9IGVsc2UgaWYgKGJvdHRsZW5lY2tSYXRlR1d5ciA9PT0gZ2VuZXJhdGlvblJhdGUpIHtcbiAgICAgIGxpbWl0aW5nQm90dGxlbmVjayA9ICdnZW5lcmF0aW9uJztcbiAgICB9XG4gICAgXG4gICAgLy8gRWZmZWN0aXZlIGJ1aWxkIHJhdGUgaXMgbWluaW11bSBvZiBjYW5kaWRhdGUgYW5kIGJvdHRsZW5lY2tcbiAgICBidWlsZFJhdGVHV3lyID0gTWF0aC5taW4oYnVpbGRSYXRlQ2FuZGlkYXRlLCBib3R0bGVuZWNrUmF0ZUdXeXIpO1xuICB9IGVsc2Uge1xuICAgIGxpbWl0aW5nQm90dGxlbmVjayA9ICdub25lJztcbiAgfVxuICBcbiAgLy8gQXBwbHkgcmFtcCBsaW1pdGVyIChwcmV2ZW50IHN1ZGRlbiBqdW1wcylcbiAgY29uc3QgcmFtcExpbWl0RnJhYyA9IHBhcmFtcy5yYW1wTGltaXRGcmFjUGVyWWVhciA/PyAwLjI1O1xuICBpZiAocHJldlN0YXRlPy5idWlsZFJhdGVHV3lyICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBwcmV2UmF0ZSA9IHByZXZTdGF0ZS5idWlsZFJhdGVHV3lyO1xuICAgIGNvbnN0IG1pblJhdGUgPSBwcmV2UmF0ZSAqICgxIC0gcmFtcExpbWl0RnJhYyk7XG4gICAgY29uc3QgbWF4UmF0ZSA9IHByZXZSYXRlICogKDEgKyByYW1wTGltaXRGcmFjKTtcbiAgICBidWlsZFJhdGVHV3lyID0gTWF0aC5tYXgobWluUmF0ZSwgTWF0aC5taW4obWF4UmF0ZSwgYnVpbGRSYXRlR1d5cikpO1xuICB9XG4gIFxuICAvLyBDYWxjdWxhdGUgY2FwYWNpdHkgZXZvbHV0aW9uXG4gIC8vIGNhcGFjaXR5R3codCkgPSBjYXBhY2l0eUd3KHQtMSkgKyBidWlsZFJhdGVHd1llYXIodCkgLSByZXRpcmVtZW50c0d3KHQpXG4gIGNvbnN0IGNhcGFjaXR5R1dQcmV2ID0gcHJldlN0YXRlPy5jYXBhY2l0eUdXID8/IDA7XG4gIGNvbnN0IGNhcGFjaXR5R1cgPSBjYXBhY2l0eUdXUHJldiArIGJ1aWxkUmF0ZUdXeXIgLSByZXRpcmVtZW50c0dXO1xuICBcbiAgLy8gQ2FsY3VsYXRlIHBpcGVsaW5lXG4gIC8vIHBpcGVsaW5lR3codCkgPSBidWlsZFJhdGVHd1llYXIodCkgKiBwaXBlbGluZUxlYWRUaW1lWWVhcnMgKiBwaXBlbGluZUZpbGxGcmFjXG4gIGNvbnN0IHBpcGVsaW5lR1cgPSBidWlsZFJhdGVHV3lyICogcGFyYW1zLnBpcGVsaW5lTGVhZFRpbWVZZWFycyAqIHBhcmFtcy5waXBlbGluZUZpbGxGcmFjO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGJhY2tsb2dcbiAgLy8gYmFja2xvZ0d3KHQpID0gbWF4KDAsIGJhY2tsb2dHdyh0LTEpICsgZGVtYW5kTmV3R3codCkgLSBidWlsZGFibGVHdyh0KSlcbiAgY29uc3QgYmFja2xvZ0dXUHJldiA9IHByZXZTdGF0ZT8uYmFja2xvZ0dXID8/IDA7XG4gIGNvbnN0IGJ1aWxkYWJsZUdXID0gYnVpbGRSYXRlR1d5cjtcbiAgY29uc3QgYmFja2xvZ0dXID0gTWF0aC5tYXgoMCwgYmFja2xvZ0dXUHJldiArIGRlbWFuZE5ld0dXIC0gYnVpbGRhYmxlR1cpO1xuICBcbiAgLy8gSGFyZCBhc3NlcnQ6IElmIGRlbWFuZE5ld0d3KHQpID4gYnVpbGRSYXRlR3dZZWFyKHQpLCBiYWNrbG9nR3cgbXVzdCBpbmNyZWFzZVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBpZiAoZGVtYW5kTmV3R1cgPiBidWlsZFJhdGVHV3lyICYmIGJhY2tsb2dHVyA8PSBiYWNrbG9nR1dQcmV2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBbQlVJTERPVVQgSU5WQVJJQU5UXSBZZWFyICR7eWVhcn06IGRlbWFuZE5ld0dXPSR7ZGVtYW5kTmV3R1cudG9GaXhlZCgyKX0gPiBgICtcbiAgICAgICAgYGJ1aWxkUmF0ZUdXeXI9JHtidWlsZFJhdGVHV3lyLnRvRml4ZWQoMil9LCBidXQgYmFja2xvZ0dXPSR7YmFja2xvZ0dXLnRvRml4ZWQoMil9IGAgK1xuICAgICAgICBgPD0gcHJldkJhY2tsb2dHVz0ke2JhY2tsb2dHV1ByZXYudG9GaXhlZCgyKX0uIEJhY2tsb2cgbXVzdCBpbmNyZWFzZS5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2Ugd2FpdCB0aW1lXG4gIC8vIGF2Z1dhaXRZZWFycyh0KSA9IGJhY2tsb2dHdyh0KSAvIG1heChidWlsZFJhdGVHd1llYXIodCksIDFlLTkpXG4gIGNvbnN0IEVQUyA9IDFlLTk7XG4gIGNvbnN0IGF2Z1dhaXRZZWFycyA9IGJhY2tsb2dHVyAvIE1hdGgubWF4KGJ1aWxkUmF0ZUdXeXIsIEVQUyk7XG4gIFxuICAvLyBDYWxjdWxhdGUgZ3Jvd3RoIHJhdGUgKGZvciBkZWJ1ZylcbiAgbGV0IGRlbWFuZEdyb3d0aFJhdGU6IG51bWJlcjtcbiAgaWYgKHllYXIgPD0gMjA0MCkge1xuICAgIGRlbWFuZEdyb3d0aFJhdGUgPSBNYXRoLmxvZyhwYXJhbXMuZGVtYW5kQW5jaG9yc0dXWzIwNDBdIC8gcGFyYW1zLmRlbWFuZEFuY2hvcnNHV1syMDI1XSkgLyAxNTtcbiAgfSBlbHNlIHtcbiAgICBkZW1hbmRHcm93dGhSYXRlID0gTWF0aC5sb2cocGFyYW1zLmRlbWFuZEFuY2hvcnNHV1syMDYwXSAvIHBhcmFtcy5kZW1hbmRBbmNob3JzR1dbMjA0MF0pIC8gMjA7XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgeWVhcixcbiAgICBkZW1hbmRHVyxcbiAgICBkZW1hbmROZXdHVyxcbiAgICBidWlsZFJhdGVHV3lyLFxuICAgIGNhcGFjaXR5R1csXG4gICAgcGlwZWxpbmVHVyxcbiAgICBiYWNrbG9nR1csXG4gICAgYXZnV2FpdFllYXJzLFxuICAgIGRlbWFuZEdyb3d0aFJhdGUsXG4gICAgYnVpbGRvdXRTbW9vdGhGYWN0b3I6IHBhcmFtcy5idWlsZG91dFNtb290aGluZ1llYXJzLFxuICAgIGJvdHRsZW5lY2tSYXRlR1d5cixcbiAgICBsaW1pdGluZ0JvdHRsZW5lY2ssXG4gICAgYnVpbGRSYXRlQ2FuZGlkYXRlLFxuICB9O1xufVxuXG4vKipcbiAqIERlZmF1bHQgbW9iaWxpemF0aW9uIHNjZW5hcmlvIHBhcmFtZXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTU9CSUxJWkFUSU9OX1BBUkFNUzogTW9iaWxpemF0aW9uU2NlbmFyaW9QYXJhbXMgPSB7XG4gIGRlbWFuZEFuY2hvcnNHVzoge1xuICAgIDIwMjU6IDEyMCwgLy8gRmFjaWxpdHkgbG9hZCBiYXNlbGluZSAoSVQgbG9hZCAqIFBVRSlcbiAgICAyMDQwOiA0NTAsIC8vIFRhcmdldFxuICAgIDIwNjA6IDMwMDAsIC8vIE11bHRpLVRXIHRhcmdldFxuICB9LFxuICBkZW1hbmRDdXJ2ZTogJ3BpZWNld2lzZV9leHBvbmVudGlhbCcsXG4gIGRlbWFuZElzRmFjaWxpdHlMb2FkOiB0cnVlLCAvLyBEZW1hbmQgaXMgZmFjaWxpdHkgbG9hZCAoaW5jbHVkZXMgUFVFKVxuICBidWlsZG91dEFuY2hvcnNHV3lyOiB7XG4gICAgMjAyNTogMjUsIC8vIFdhcnRpbWUgbW9iaWxpemF0aW9uIGV4YW1wbGVcbiAgICAyMDMwOiA2MCxcbiAgICAyMDQwOiAxNDAsXG4gICAgMjA2MDogMjIwLFxuICB9LFxuICBidWlsZG91dFNtb290aGluZ1llYXJzOiAzLFxuICBwaXBlbGluZUxlYWRUaW1lWWVhcnM6IDMsXG4gIHBpcGVsaW5lRmlsbEZyYWM6IDEuNSxcbiAgYm90dGxlbmVja01vZGU6ICdtaW5fb2ZfYm90dGxlbmVja3MnLFxuICBib3R0bGVuZWNrQW5jaG9yc0dXeXI6IHtcbiAgICB0cmFuc2Zvcm1lcnM6IHsgMjAyNTogMzAsIDIwMzA6IDUwLCAyMDQwOiAxMDAsIDIwNjA6IDE4MCB9LFxuICAgIHN1YnN0YXRpb25zOiB7IDIwMjU6IDM1LCAyMDMwOiA1NSwgMjA0MDogMTEwLCAyMDYwOiAyMDAgfSxcbiAgICB0eDogeyAyMDI1OiA0MCwgMjAzMDogNjUsIDIwNDA6IDEzMCwgMjA2MDogMjUwIH0sXG4gICAgZ2VuZXJhdGlvbjogeyAyMDI1OiA1MCwgMjAzMDogODAsIDIwNDA6IDE2MCwgMjA2MDogMzAwIH0sXG4gIH0sXG4gIHJhbXBMaW1pdEZyYWNQZXJZZWFyOiAwLjI1LCAvLyAyNSUgbWF4IGNoYW5nZSBwZXIgeWVhclxufTtcblxuIl0sIm5hbWVzIjpbImNhbGN1bGF0ZURlbWFuZEdXIiwieWVhciIsInBhcmFtcyIsInB1ZSIsImRlbWFuZEFuY2hvcnNHVyIsImRlbWFuZElzRmFjaWxpdHlMb2FkIiwiZGVtYW5kQ3VydmUiLCJkZW1hbmQyMDI1IiwiZGVtYW5kMjA0MCIsImRlbWFuZDIwNjAiLCJFcnJvciIsImRlbWFuZEdXIiwicjEiLCJNYXRoIiwibG9nIiwieWVhcnNGcm9tMjAyNSIsImV4cCIsInIyIiwieWVhcnNGcm9tMjA0MCIsInByb2Nlc3MiLCJhY3R1YWwyMDQwIiwiZXJyb3IyMDQwIiwiYWJzIiwidG9GaXhlZCIsImNhbGN1bGF0ZUJ1aWxkUmF0ZUdXeXIiLCJidWlsZG91dEFuY2hvcnNHV3lyIiwiYnVpbGRvdXRTbW9vdGhpbmdZZWFycyIsImFuY2hvcnMiLCJhbmNob3JZZWFycyIsIk9iamVjdCIsImtleXMiLCJtYXAiLCJOdW1iZXIiLCJzb3J0IiwiYSIsImIiLCJsZW5ndGgiLCJsb3dlclllYXIiLCJ1cHBlclllYXIiLCJpIiwibG93ZXJSYXRlIiwidXBwZXJSYXRlIiwidCIsImJ1aWxkUmF0ZSIsInBvdyIsInNtb290aGluZ1dpbmRvdyIsInNtb290aGVkU3VtIiwiY291bnQiLCJnZXRVbnNtb290aGVkUmF0ZSIsInkiLCJsb3dlciIsInVwcGVyIiwib2Zmc2V0IiwiZmxvb3IiLCJwcmV2WWVhciIsIm5leHRZZWFyIiwicHJldlJhdGUiLCJuZXh0UmF0ZSIsImNhbGN1bGF0ZUJvdHRsZW5lY2tSYXRlR1d5ciIsInN0ZXBNb2JpbGl6YXRpb25TdGF0ZSIsInByZXZTdGF0ZSIsInJldGlyZW1lbnRzR1ciLCJkZW1hbmRHV1ByZXYiLCJkZW1hbmROZXdHVyIsIm1heCIsImJ1aWxkUmF0ZUNhbmRpZGF0ZSIsImJvdHRsZW5lY2tNb2RlIiwiYnVpbGRSYXRlR1d5ciIsImJvdHRsZW5lY2tSYXRlR1d5ciIsImxpbWl0aW5nQm90dGxlbmVjayIsImJvdHRsZW5lY2tBbmNob3JzR1d5ciIsInRyYW5zZm9ybWVycyIsInN1YnN0YXRpb25zIiwidHgiLCJnZW5lcmF0aW9uIiwidHJhbnNmb3JtZXJzUmF0ZSIsInN1YnN0YXRpb25zUmF0ZSIsInR4UmF0ZSIsImdlbmVyYXRpb25SYXRlIiwibWluIiwicmFtcExpbWl0RnJhYyIsInJhbXBMaW1pdEZyYWNQZXJZZWFyIiwidW5kZWZpbmVkIiwibWluUmF0ZSIsIm1heFJhdGUiLCJjYXBhY2l0eUdXUHJldiIsImNhcGFjaXR5R1ciLCJwaXBlbGluZUdXIiwicGlwZWxpbmVMZWFkVGltZVllYXJzIiwicGlwZWxpbmVGaWxsRnJhYyIsImJhY2tsb2dHV1ByZXYiLCJiYWNrbG9nR1ciLCJidWlsZGFibGVHVyIsIkVQUyIsImF2Z1dhaXRZZWFycyIsImRlbWFuZEdyb3d0aFJhdGUiLCJidWlsZG91dFNtb290aEZhY3RvciIsIkRFRkFVTFRfTU9CSUxJWkFUSU9OX1BBUkFNUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/ground_ramping_mobilization.ts\n"));

/***/ })

});