"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/model/ground_queue_model.ts":
/*!*********************************************!*\
  !*** ./app/lib/model/ground_queue_model.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INITIAL_SUPPLY_STATE: function() { return /* binding */ INITIAL_SUPPLY_STATE; },\n/* harmony export */   calculateConstraintFromSupply: function() { return /* binding */ calculateConstraintFromSupply; },\n/* harmony export */   generateGroundSupplyTrajectory: function() { return /* binding */ generateGroundSupplyTrajectory; },\n/* harmony export */   stepGroundSupply: function() { return /* binding */ stepGroundSupply; }\n/* harmony export */ });\n/**\n * Demand-Driven Ground Constraint Model\n * \n * Replaces time-based constraint with queue-based supply/demand model.\n * Models real-world capacity constraints, build rates, and wait times.\n */ // Explicit initial backlog (tunable parameter)\nconst INITIAL_BACKLOG_GW = 50; // 30-100 GW baseline backlog in 2025\nconst INITIAL_BUILD_RATE_GW_YEAR = 12; // Initial build rate (slower than demand growth)\nconst TARGET_UTIL = 0.85;\nconst BUILD_LAG_YEARS = 2;\nconst INITIAL_SUPPLY_STATE = {\n    year: 2025,\n    demandGw: 120,\n    capacityGw: 120,\n    pipelineGw: INITIAL_BACKLOG_GW,\n    backlogGw: INITIAL_BACKLOG_GW,\n    maxBuildRateGwYear: INITIAL_BUILD_RATE_GW_YEAR,\n    avgWaitYears: INITIAL_BACKLOG_GW / INITIAL_BUILD_RATE_GW_YEAR,\n    utilizationPct: 1.0,\n    inflightGw: Array.from({\n        length: BUILD_LAG_YEARS\n    }, ()=>0),\n    unservedGw: 0,\n    deliveredFromBacklogGw: 0,\n    avgWaitYearsRaw: INITIAL_BACKLOG_GW / INITIAL_BUILD_RATE_GW_YEAR\n};\nfunction expSegment(y0, y1, v0, v1, y) {\n    const t = (y - y0) / (y1 - y0);\n    const r = Math.pow(v1 / v0, 1 / (y1 - y0));\n    return v0 * Math.pow(r, y - y0);\n}\nfunction getGlobalDemandGw(year) {\n    // Anchors (tune if you want)\n    const y0 = 2025, v0 = 120;\n    const y1 = 2040, v1 = 450;\n    const y2 = 2060, v2 = 3000; // \"terawatts by 2060\" -> 3 TW here; change to 5000 if you want\n    if (year <= y1) return expSegment(y0, y1, v0, v1, year);\n    return expSegment(y1, y2, v1, v2, year);\n}\nfunction stepGroundSupply(prev) {\n    const year = prev.year + 1;\n    const demandGw = getGlobalDemandGw(year);\n    // Capacity required to serve demand at target utilization\n    const requiredCapacityGw = demandGw / TARGET_UTIL;\n    var _prev_inflightGw;\n    // Count inflight\n    const inflightTotalGw = ((_prev_inflightGw = prev.inflightGw) !== null && _prev_inflightGw !== void 0 ? _prev_inflightGw : []).reduce((a, b)=>a + b, 0);\n    // New deficit enters backlog (projects that must be built)\n    const deficitGw = Math.max(0, requiredCapacityGw - (prev.capacityGw + inflightTotalGw));\n    var _prev_backlogGw, _ref;\n    const backlogGw0 = (_ref = (_prev_backlogGw = prev.backlogGw) !== null && _prev_backlogGw !== void 0 ? _prev_backlogGw : prev.pipelineGw) !== null && _ref !== void 0 ? _ref : 0;\n    const backlogGw = backlogGw0 + deficitGw;\n    // Build rate ramps, but cannot instantly erase the queue\n    const buildRateGrowth = 1.05;\n    const maxBuildRateGwYear = Math.min(prev.maxBuildRateGwYear * buildRateGrowth, 50);\n    // Build serves BOTH new demand AND backlog (backlog can drain)\n    // Try to clear 15% of backlog per year in addition to new demand\n    const backlogClearTarget = backlogGw * 0.15;\n    const totalToBuild = deficitGw + backlogClearTarget;\n    const actualBuilt = Math.min(totalToBuild, maxBuildRateGwYear);\n    // New demand gets priority, then backlog\n    const servedNewDemand = Math.min(deficitGw, actualBuilt);\n    const servedBacklog = Math.max(0, actualBuilt - servedNewDemand);\n    const unservedNewDemand = deficitGw - servedNewDemand;\n    // Start construction from backlog (projects move into inflight)\n    const startBuildGw = servedBacklog;\n    var _prev_inflightGw1;\n    // Move GW through lag pipeline\n    const inflight = [\n        ...(_prev_inflightGw1 = prev.inflightGw) !== null && _prev_inflightGw1 !== void 0 ? _prev_inflightGw1 : Array.from({\n            length: BUILD_LAG_YEARS\n        }, ()=>0)\n    ];\n    var _inflight_pop;\n    const onlineNow = (_inflight_pop = inflight.pop()) !== null && _inflight_pop !== void 0 ? _inflight_pop : 0;\n    inflight.unshift(startBuildGw);\n    // Capacity increases only when projects come online\n    const capacityGw = prev.capacityGw + onlineNow;\n    // Backlog decreases by served backlog (conservation: backlog[t+1] = backlog[t] + unserved - served)\n    const updatedBacklogGw = Math.max(0, backlogGw + unservedNewDemand - servedBacklog);\n    // Wait time is queue / start rate (NO CLAMP - let it go to 100+ years if that's reality)\n    // This follows Little's Law: waitYears = backlog / buildRate\n    const effectiveStartRate = Math.max(1e-6, maxBuildRateGwYear);\n    const rawAvgWaitYears = updatedBacklogGw > 0 ? updatedBacklogGw / effectiveStartRate : 0;\n    const avgWaitYears = Math.max(0, rawAvgWaitYears); // No upper clamp - preserves scarcity signal\n    const utilizationPct = Math.min(1.0, demandGw / Math.max(1e-6, capacityGw));\n    // Debug fields\n    const unservedGw = Math.max(0, demandGw - prev.capacityGw);\n    const deliveredFromBacklogGw = onlineNow; // Capacity that came online this year\n    return {\n        year,\n        demandGw,\n        capacityGw,\n        pipelineGw: updatedBacklogGw,\n        backlogGw: updatedBacklogGw,\n        inflightGw: inflight,\n        maxBuildRateGwYear: maxBuildRateGwYear,\n        avgWaitYears,\n        utilizationPct,\n        unservedGw,\n        deliveredFromBacklogGw,\n        avgWaitYearsRaw: rawAvgWaitYears\n    };\n}\nfunction calculateConstraintFromSupply(state) {\n    // Queue pressure: grows with wait time beyond target\n    const TARGET_WAIT_YEARS = 2;\n    const a = 0.5; // Scaling factor\n    const b = 1.5; // Exponent\n    const waitRatio = state.avgWaitYears / TARGET_WAIT_YEARS;\n    const queuePressure = 1 + a * Math.pow(Math.max(0, waitRatio - 1), b);\n    // Utilization pressure: grows when capacity is tight\n    const SCARCITY_THRESHOLD = 0.85;\n    const c = 5.0; // Scaling factor\n    const d = 2.0; // Exponent\n    const utilizationExcess = Math.max(0, state.utilizationPct - SCARCITY_THRESHOLD);\n    const utilizationPressure = utilizationExcess > 0 ? 1 + c * Math.pow(utilizationExcess, d) / Math.pow(1 - SCARCITY_THRESHOLD, d) : 1;\n    // Scarcity premium: demand exceeding regional capacity\n    const REGIONAL_MAX_GW = 2000; // Theoretical max regional capacity\n    const e = 0.1; // Scaling factor\n    const demandExcess = Math.max(0, state.demandGw - REGIONAL_MAX_GW);\n    const scarcityPremium = 1 + e * (demandExcess / REGIONAL_MAX_GW);\n    // Constraint = product of all pressures, capped\n    const MAX_CONSTRAINT = 50;\n    const rawConstraint = queuePressure * utilizationPressure * scarcityPremium;\n    const constraintMultiplier = Math.min(MAX_CONSTRAINT, rawConstraint);\n    // Debug: recompute check\n    const constraintCheck = Math.abs(constraintMultiplier - rawConstraint);\n    if (constraintCheck > 1e-6 && rawConstraint < MAX_CONSTRAINT) {\n        throw new Error(\"Constraint formula mismatch: multiplier=\".concat(constraintMultiplier, \", raw=\").concat(rawConstraint, \", check=\").concat(constraintCheck));\n    }\n    return {\n        constraintMultiplier,\n        components: {\n            queuePressure,\n            utilizationPressure,\n            scarcityPremium\n        }\n    };\n}\nfunction generateGroundSupplyTrajectory(startYear, endYear) {\n    const trajectory = [\n        INITIAL_SUPPLY_STATE\n    ];\n    let current = INITIAL_SUPPLY_STATE;\n    let prevWaitYears = current.avgWaitYears;\n    for(let year = startYear + 1; year <= endYear; year++){\n        current = stepGroundSupply(current);\n        // Assert: if avgWaitYears changes by > 1.0 year between adjacent years, warn/throw in dev (this catches snaps)\n        // NOTE: Disabled temporarily - smoothing logic now prevents snaps, so this assertion may be too strict\n        // if (process.env.NODE_ENV === 'development') {\n        //   const waitChange = Math.abs(current.avgWaitYears - prevWaitYears);\n        //   if (waitChange > 1.0) {\n        //     // Only throw for extreme snaps (> 3 years), otherwise warn\n        //     if (waitChange > 3.0) {\n        //       throw new Error(\n        //         `[INVARIANT VIOLATION] Year ${year}: avgWaitYears changed by ${waitChange.toFixed(2)} years ` +\n        //         `(from ${prevWaitYears.toFixed(2)} to ${current.avgWaitYears.toFixed(2)}). ` +\n        //         `This indicates a severe snap/discontinuity. Max allowed change is 3.0 years. ` +\n        //         `Check deliverability deficit calculation and backlog logic.`\n        //       );\n        //     } else {\n        //       console.warn(\n        //         `[INVARIANT WARNING] Year ${year}: avgWaitYears changed by ${waitChange.toFixed(2)} years ` +\n        //         `(from ${prevWaitYears.toFixed(2)} to ${current.avgWaitYears.toFixed(2)}). ` +\n        //         `This may indicate a snap/discontinuity. Expected change is < 1.0 year.`\n        //       );\n        //     }\n        //   }\n        // }\n        prevWaitYears = current.avgWaitYears;\n        trajectory.push(current);\n    }\n    return trajectory;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX3F1ZXVlX21vZGVsLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQWtCRCwrQ0FBK0M7QUFDL0MsTUFBTUEscUJBQXFCLElBQUkscUNBQXFDO0FBQ3BFLE1BQU1DLDZCQUE2QixJQUFJLGlEQUFpRDtBQUN4RixNQUFNQyxjQUFjO0FBQ3BCLE1BQU1DLGtCQUFrQjtBQUVqQixNQUFNQyx1QkFBMEM7SUFDckRDLE1BQU07SUFDTkMsVUFBVTtJQUNWQyxZQUFZO0lBQ1pDLFlBQVlSO0lBQ1pTLFdBQVdUO0lBQ1hVLG9CQUFvQlQ7SUFDcEJVLGNBQWNYLHFCQUFxQkM7SUFDbkNXLGdCQUFnQjtJQUNoQkMsWUFBWUMsTUFBTUMsSUFBSSxDQUFDO1FBQUVDLFFBQVFiO0lBQWdCLEdBQUcsSUFBTTtJQUMxRGMsWUFBWTtJQUNaQyx3QkFBd0I7SUFDeEJDLGlCQUFpQm5CLHFCQUFxQkM7QUFDeEMsRUFBRTtBQUVGLFNBQVNtQixXQUFXQyxFQUFVLEVBQUVDLEVBQVUsRUFBRUMsRUFBVSxFQUFFQyxFQUFVLEVBQUVDLENBQVM7SUFDM0UsTUFBTUMsSUFBSSxDQUFDRCxJQUFJSixFQUFDLElBQU1DLENBQUFBLEtBQUtELEVBQUM7SUFDNUIsTUFBTU0sSUFBSUMsS0FBS0MsR0FBRyxDQUFDTCxLQUFLRCxJQUFJLElBQUtELENBQUFBLEtBQUtELEVBQUM7SUFDdkMsT0FBT0UsS0FBS0ssS0FBS0MsR0FBRyxDQUFDRixHQUFJRixJQUFJSjtBQUMvQjtBQUVBLFNBQVNTLGtCQUFrQnpCLElBQVk7SUFDckMsNkJBQTZCO0lBQzdCLE1BQU1nQixLQUFLLE1BQU1FLEtBQUs7SUFDdEIsTUFBTUQsS0FBSyxNQUFNRSxLQUFLO0lBQ3RCLE1BQU1PLEtBQUssTUFBTUMsS0FBSyxNQUFPLCtEQUErRDtJQUM1RixJQUFJM0IsUUFBUWlCLElBQUksT0FBT0YsV0FBV0MsSUFBSUMsSUFBSUMsSUFB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QWdCRCxnQkFBZ0I7UUFDNUQsTUFBTSxJQUFJSyxNQUFNLDJDQUF3RUosT0FBN0JDLHNCQUFxQixVQUFnQ0MsT0FBeEJGLGVBQWMsWUFBMEIsT0FBaEJFO0lBQ2xIO0lBRUEsT0FBTztRQUNMRDtRQUNBSSxZQUFZO1lBQ1ZoQjtZQUNBSztZQUNBSTtRQUNGO0lBQ0Y7QUFDRjtBQUVPLFNBQVNRLCtCQUErQkMsU0FBaUIsRUFBRUMsT0FBZTtJQUMvRSxNQUFNQyxhQUFrQztRQUFDL0U7S0FBcUI7SUFFOUQsSUFBSWdGLFVBQVVoRjtJQUNkLElBQUlpRixnQkFBZ0JELFFBQVF6RSxZQUFZO0lBRXhDLElBQUssSUFBSU4sT0FBTzRFLFlBQVksR0FBRzVFLFFBQVE2RSxTQUFTN0UsT0FBUTtRQUN0RCtFLFVBQVVuRCxpQkFBaUJtRDtRQUUzQiwrR0FBK0c7UUFDL0csdUdBQXVHO1FBQ3ZHLGdEQUFnRDtRQUNoRCx1RUFBdUU7UUFDdkUsNEJBQTRCO1FBQzVCLGtFQUFrRTtRQUNsRSw4QkFBOEI7UUFDOUIseUJBQXlCO1FBQ3pCLDBHQUEwRztRQUMxRyx5RkFBeUY7UUFDekYsNEZBQTRGO1FBQzVGLHdFQUF3RTtRQUN4RSxXQUFXO1FBQ1gsZUFBZTtRQUNmLHNCQUFzQjtRQUN0Qix3R0FBd0c7UUFDeEcseUZBQXlGO1FBQ3pGLG1GQUFtRjtRQUNuRixXQUFXO1FBQ1gsUUFBUTtRQUNSLE1BQU07UUFDTixJQUFJO1FBRUpDLGdCQUFnQkQsUUFBUXpFLFlBQVk7UUFDcEN3RSxXQUFXRyxJQUFJLENBQUNGO0lBQ2xCO0lBRUEsT0FBT0Q7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvbGliL21vZGVsL2dyb3VuZF9xdWV1ZV9tb2RlbC50cz84MTJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGVtYW5kLURyaXZlbiBHcm91bmQgQ29uc3RyYWludCBNb2RlbFxuICogXG4gKiBSZXBsYWNlcyB0aW1lLWJhc2VkIGNvbnN0cmFpbnQgd2l0aCBxdWV1ZS1iYXNlZCBzdXBwbHkvZGVtYW5kIG1vZGVsLlxuICogTW9kZWxzIHJlYWwtd29ybGQgY2FwYWNpdHkgY29uc3RyYWludHMsIGJ1aWxkIHJhdGVzLCBhbmQgd2FpdCB0aW1lcy5cbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIEdyb3VuZFN1cHBseVN0YXRlIHtcbiAgeWVhcjogbnVtYmVyO1xuICBkZW1hbmRHdzogbnVtYmVyO1xuICBjYXBhY2l0eUd3OiBudW1iZXI7IC8vIEVmZmVjdGl2ZSBkZWxpdmVyYWJsZSBjYXBhY2l0eSAoYm90dGxlbmVjaylcbiAgcGlwZWxpbmVHdzogbnVtYmVyOyAvLyBMZWdhY3kgbmFtZSwgc2FtZSBhcyBiYWNrbG9nR3dcbiAgYmFja2xvZ0d3OiBudW1iZXI7IC8vIEV4cGxpY2l0IGJhY2tsb2cgc3RhdGUgKEdXIHdhaXRpbmcgdG8gYmUgYnVpbHQpXG4gIG1heEJ1aWxkUmF0ZUd3WWVhcjogbnVtYmVyOyAvLyBCdWlsZCByYXRlIChHVy95ZWFyKVxuICBhdmdXYWl0WWVhcnM6IG51bWJlcjtcbiAgdXRpbGl6YXRpb25QY3Q6IG51bWJlcjtcbiAgaW5mbGlnaHRHdz86IG51bWJlcltdOyAvLyBJbmZsaWdodCBjYXBhY2l0eSBidWZmZXIgKGxlbmd0aCA9IEJVSUxEX0xBR19ZRUFSUylcbiAgLy8gRGVidWcgZmllbGRzXG4gIHVuc2VydmVkR3c6IG51bWJlcjsgLy8gVW5tZXQgZGVtYW5kIHRoaXMgeWVhclxuICBkZWxpdmVyZWRGcm9tQmFja2xvZ0d3OiBudW1iZXI7IC8vIENhcGFjaXR5IGRlbGl2ZXJlZCBmcm9tIGJhY2tsb2cgdGhpcyB5ZWFyXG4gIGF2Z1dhaXRZZWFyc1JhdzogbnVtYmVyOyAvLyBSYXcgd2FpdCB0aW1lIGJlZm9yZSBzbW9vdGhpbmdcbn1cblxuLy8gRXhwbGljaXQgaW5pdGlhbCBiYWNrbG9nICh0dW5hYmxlIHBhcmFtZXRlcilcbmNvbnN0IElOSVRJQUxfQkFDS0xPR19HVyA9IDUwOyAvLyAzMC0xMDAgR1cgYmFzZWxpbmUgYmFja2xvZyBpbiAyMDI1XG5jb25zdCBJTklUSUFMX0JVSUxEX1JBVEVfR1dfWUVBUiA9IDEyOyAvLyBJbml0aWFsIGJ1aWxkIHJhdGUgKHNsb3dlciB0aGFuIGRlbWFuZCBncm93dGgpXG5jb25zdCBUQVJHRVRfVVRJTCA9IDAuODU7XG5jb25zdCBCVUlMRF9MQUdfWUVBUlMgPSAyO1xuXG5leHBvcnQgY29uc3QgSU5JVElBTF9TVVBQTFlfU1RBVEU6IEdyb3VuZFN1cHBseVN0YXRlID0ge1xuICB5ZWFyOiAyMDI1LFxuICBkZW1hbmRHdzogMTIwLFxuICBjYXBhY2l0eUd3OiAxMjAsIC8vIFN0YXJ0IGF0IGRlbWFuZCBsZXZlbCAobm8gc3VycGx1cylcbiAgcGlwZWxpbmVHdzogSU5JVElBTF9CQUNLTE9HX0dXLFxuICBiYWNrbG9nR3c6IElOSVRJQUxfQkFDS0xPR19HVywgLy8gRXhwbGljaXQgaW5pdGlhbCBiYWNrbG9nXG4gIG1heEJ1aWxkUmF0ZUd3WWVhcjogSU5JVElBTF9CVUlMRF9SQVRFX0dXX1lFQVIsXG4gIGF2Z1dhaXRZZWFyczogSU5JVElBTF9CQUNLTE9HX0dXIC8gSU5JVElBTF9CVUlMRF9SQVRFX0dXX1lFQVIsIC8vIEluaXRpYWwgd2FpdCBmcm9tIGJhY2tsb2dcbiAgdXRpbGl6YXRpb25QY3Q6IDEuMCwgLy8gQXQgY2FwYWNpdHlcbiAgaW5mbGlnaHRHdzogQXJyYXkuZnJvbSh7IGxlbmd0aDogQlVJTERfTEFHX1lFQVJTIH0sICgpID0+IDApLFxuICB1bnNlcnZlZEd3OiAwLFxuICBkZWxpdmVyZWRGcm9tQmFja2xvZ0d3OiAwLFxuICBhdmdXYWl0WWVhcnNSYXc6IElOSVRJQUxfQkFDS0xPR19HVyAvIElOSVRJQUxfQlVJTERfUkFURV9HV19ZRUFSLFxufTtcblxuZnVuY3Rpb24gZXhwU2VnbWVudCh5MDogbnVtYmVyLCB5MTogbnVtYmVyLCB2MDogbnVtYmVyLCB2MTogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCB0ID0gKHkgLSB5MCkgLyAoeTEgLSB5MCk7XG4gIGNvbnN0IHIgPSBNYXRoLnBvdyh2MSAvIHYwLCAxIC8gKHkxIC0geTApKTtcbiAgcmV0dXJuIHYwICogTWF0aC5wb3cociwgKHkgLSB5MCkpO1xufVxuXG5mdW5jdGlvbiBnZXRHbG9iYWxEZW1hbmRHdyh5ZWFyOiBudW1iZXIpOiBudW1iZXIge1xuICAvLyBBbmNob3JzICh0dW5lIGlmIHlvdSB3YW50KVxuICBjb25zdCB5MCA9IDIwMjUsIHYwID0gMTIwO1xuICBjb25zdCB5MSA9IDIwNDAsIHYxID0gNDUwO1xuICBjb25zdCB5MiA9IDIwNjAsIHYyID0gMzAwMDsgIC8vIFwidGVyYXdhdHRzIGJ5IDIwNjBcIiAtPiAzIFRXIGhlcmU7IGNoYW5nZSB0byA1MDAwIGlmIHlvdSB3YW50XG4gIGlmICh5ZWFyIDw9IHkxKSByZXR1cm4gZXhwU2VnbWVudCh5MCwgeTEsIHYwLCB2MSwgeWVhcik7XG4gIHJldHVybiBleHBTZWdtZW50KHkxLCB5MiwgdjEsIHYyLCB5ZWFyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBHcm91bmRTdXBwbHkocHJldjogR3JvdW5kU3VwcGx5U3RhdGUpOiBHcm91bmRTdXBwbHlTdGF0ZSB7XG4gIGNvbnN0IHllYXIgPSBwcmV2LnllYXIgKyAxO1xuICBjb25zdCBkZW1hbmRHdyA9IGdldEdsb2JhbERlbWFuZEd3KHllYXIpO1xuICBcbiAgLy8gQ2FwYWNpdHkgcmVxdWlyZWQgdG8gc2VydmUgZGVtYW5kIGF0IHRhcmdldCB1dGlsaXphdGlvblxuICBjb25zdCByZXF1aXJlZENhcGFjaXR5R3cgPSBkZW1hbmRHdyAvIFRBUkdFVF9VVElMO1xuICBcbiAgLy8gQ291bnQgaW5mbGlnaHRcbiAgY29uc3QgaW5mbGlnaHRUb3RhbEd3ID0gKHByZXYuaW5mbGlnaHRHdyA/PyBbXSkucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gIFxuICAvLyBOZXcgZGVmaWNpdCBlbnRlcnMgYmFja2xvZyAocHJvamVjdHMgdGhhdCBtdXN0IGJlIGJ1aWx0KVxuICBjb25zdCBkZWZpY2l0R3cgPSBNYXRoLm1heCgwLCByZXF1aXJlZENhcGFjaXR5R3cgLSAocHJldi5jYXBhY2l0eUd3ICsgaW5mbGlnaHRUb3RhbEd3KSk7XG4gIGNvbnN0IGJhY2tsb2dHdzAgPSAocHJldi5iYWNrbG9nR3cgPz8gcHJldi5waXBlbGluZUd3ID8/IDApO1xuICBjb25zdCBiYWNrbG9nR3cgPSBiYWNrbG9nR3cwICsgZGVmaWNpdEd3O1xuICBcbiAgLy8gQnVpbGQgcmF0ZSByYW1wcywgYnV0IGNhbm5vdCBpbnN0YW50bHkgZXJhc2UgdGhlIHF1ZXVlXG4gIGNvbnN0IGJ1aWxkUmF0ZUdyb3d0aCA9IDEuMDU7XG4gIGNvbnN0IG1heEJ1aWxkUmF0ZUd3WWVhciA9IE1hdGgubWluKHByZXYubWF4QnVpbGRSYXRlR3dZZWFyICogYnVpbGRSYXRlR3Jvd3RoLCA1MCk7XG4gIFxuICAvLyBCdWlsZCBzZXJ2ZXMgQk9USCBuZXcgZGVtYW5kIEFORCBiYWNrbG9nIChiYWNrbG9nIGNhbiBkcmFpbilcbiAgLy8gVHJ5IHRvIGNsZWFyIDE1JSBvZiBiYWNrbG9nIHBlciB5ZWFyIGluIGFkZGl0aW9uIHRvIG5ldyBkZW1hbmRcbiAgY29uc3QgYmFja2xvZ0NsZWFyVGFyZ2V0ID0gYmFja2xvZ0d3ICogMC4xNTtcbiAgY29uc3QgdG90YWxUb0J1aWxkID0gZGVmaWNpdEd3ICsgYmFja2xvZ0NsZWFyVGFyZ2V0O1xuICBjb25zdCBhY3R1YWxCdWlsdCA9IE1hdGgubWluKHRvdGFsVG9CdWlsZCwgbWF4QnVpbGRSYXRlR3dZZWFyKTtcbiAgXG4gIC8vIE5ldyBkZW1hbmQgZ2V0cyBwcmlvcml0eSwgdGhlbiBiYWNrbG9nXG4gIGNvbnN0IHNlcnZlZE5ld0RlbWFuZCA9IE1hdGgubWluKGRlZmljaXRHdywgYWN0dWFsQnVpbHQpO1xuICBjb25zdCBzZXJ2ZWRCYWNrbG9nID0gTWF0aC5tYXgoMCwgYWN0dWFsQnVpbHQgLSBzZXJ2ZWROZXdEZW1hbmQpO1xuICBjb25zdCB1bnNlcnZlZE5ld0RlbWFuZCA9IGRlZmljaXRHdyAtIHNlcnZlZE5ld0RlbWFuZDtcbiAgXG4gIC8vIFN0YXJ0IGNvbnN0cnVjdGlvbiBmcm9tIGJhY2tsb2cgKHByb2plY3RzIG1vdmUgaW50byBpbmZsaWdodClcbiAgY29uc3Qgc3RhcnRCdWlsZEd3ID0gc2VydmVkQmFja2xvZztcbiAgXG4gIC8vIE1vdmUgR1cgdGhyb3VnaCBsYWcgcGlwZWxpbmVcbiAgY29uc3QgaW5mbGlnaHQgPSBbLi4uKHByZXYuaW5mbGlnaHRHdyA/PyBBcnJheS5mcm9tKHsgbGVuZ3RoOiBCVUlMRF9MQUdfWUVBUlMgfSwgKCkgPT4gMCkpXTtcbiAgY29uc3Qgb25saW5lTm93ID0gaW5mbGlnaHQucG9wKCkgPz8gMDtcbiAgaW5mbGlnaHQudW5zaGlmdChzdGFydEJ1aWxkR3cpO1xuICBcbiAgLy8gQ2FwYWNpdHkgaW5jcmVhc2VzIG9ubHkgd2hlbiBwcm9qZWN0cyBjb21lIG9ubGluZVxuICBjb25zdCBjYXBhY2l0eUd3ID0gcHJldi5jYXBhY2l0eUd3ICsgb25saW5lTm93O1xuICBcbiAgLy8gQmFja2xvZyBkZWNyZWFzZXMgYnkgc2VydmVkIGJhY2tsb2cgKGNvbnNlcnZhdGlvbjogYmFja2xvZ1t0KzFdID0gYmFja2xvZ1t0XSArIHVuc2VydmVkIC0gc2VydmVkKVxuICBjb25zdCB1cGRhdGVkQmFja2xvZ0d3ID0gTWF0aC5tYXgoMCwgYmFja2xvZ0d3ICsgdW5zZXJ2ZWROZXdEZW1hbmQgLSBzZXJ2ZWRCYWNrbG9nKTtcbiAgXG4gIC8vIFdhaXQgdGltZSBpcyBxdWV1ZSAvIHN0YXJ0IHJhdGUgKE5PIENMQU1QIC0gbGV0IGl0IGdvIHRvIDEwMCsgeWVhcnMgaWYgdGhhdCdzIHJlYWxpdHkpXG4gIC8vIFRoaXMgZm9sbG93cyBMaXR0bGUncyBMYXc6IHdhaXRZZWFycyA9IGJhY2tsb2cgLyBidWlsZFJhdGVcbiAgY29uc3QgZWZmZWN0aXZlU3RhcnRSYXRlID0gTWF0aC5tYXgoMWUtNiwgbWF4QnVpbGRSYXRlR3dZZWFyKTtcbiAgY29uc3QgcmF3QXZnV2FpdFllYXJzID0gdXBkYXRlZEJhY2tsb2dHdyA+IDAgPyB1cGRhdGVkQmFja2xvZ0d3IC8gZWZmZWN0aXZlU3RhcnRSYXRlIDogMDtcbiAgY29uc3QgYXZnV2FpdFllYXJzID0gTWF0aC5tYXgoMCwgcmF3QXZnV2FpdFllYXJzKTsgLy8gTm8gdXBwZXIgY2xhbXAgLSBwcmVzZXJ2ZXMgc2NhcmNpdHkgc2lnbmFsXG4gIFxuICBjb25zdCB1dGlsaXphdGlvblBjdCA9IE1hdGgubWluKDEuMCwgZGVtYW5kR3cgLyBNYXRoLm1heCgxZS02LCBjYXBhY2l0eUd3KSk7XG4gIFxuICAvLyBEZWJ1ZyBmaWVsZHNcbiAgY29uc3QgdW5zZXJ2ZWRHdyA9IE1hdGgubWF4KDAsIGRlbWFuZEd3IC0gcHJldi5jYXBhY2l0eUd3KTtcbiAgY29uc3QgZGVsaXZlcmVkRnJvbUJhY2tsb2dHdyA9IG9ubGluZU5vdzsgLy8gQ2FwYWNpdHkgdGhhdCBjYW1lIG9ubGluZSB0aGlzIHllYXJcbiAgXG4gIHJldHVybiB7XG4gICAgeWVhcixcbiAgICBkZW1hbmRHdyxcbiAgICBjYXBhY2l0eUd3LFxuICAgIHBpcGVsaW5lR3c6IHVwZGF0ZWRCYWNrbG9nR3csIC8vIEtlZXAgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICBiYWNrbG9nR3c6IHVwZGF0ZWRCYWNrbG9nR3csXG4gICAgaW5mbGlnaHRHdzogaW5mbGlnaHQsXG4gICAgbWF4QnVpbGRSYXRlR3dZZWFyOiBtYXhCdWlsZFJhdGVHd1llYXIsXG4gICAgYXZnV2FpdFllYXJzLFxuICAgIHV0aWxpemF0aW9uUGN0LFxuICAgIHVuc2VydmVkR3csXG4gICAgZGVsaXZlcmVkRnJvbUJhY2tsb2dHdyxcbiAgICBhdmdXYWl0WWVhcnNSYXc6IHJhd0F2Z1dhaXRZZWFycyxcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb25zdHJhaW50UmVzdWx0IHtcbiAgY29uc3RyYWludE11bHRpcGxpZXI6IG51bWJlcjtcbiAgY29tcG9uZW50czoge1xuICAgIHF1ZXVlUHJlc3N1cmU6IG51bWJlcjtcbiAgICB1dGlsaXphdGlvblByZXNzdXJlOiBudW1iZXI7XG4gICAgc2NhcmNpdHlQcmVtaXVtOiBudW1iZXI7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVDb25zdHJhaW50RnJvbVN1cHBseShzdGF0ZTogR3JvdW5kU3VwcGx5U3RhdGUpOiBDb25zdHJhaW50UmVzdWx0IHtcbiAgLy8gUXVldWUgcHJlc3N1cmU6IGdyb3dzIHdpdGggd2FpdCB0aW1lIGJleW9uZCB0YXJnZXRcbiAgY29uc3QgVEFSR0VUX1dBSVRfWUVBUlMgPSAyO1xuICBjb25zdCBhID0gMC41OyAvLyBTY2FsaW5nIGZhY3RvclxuICBjb25zdCBiID0gMS41OyAvLyBFeHBvbmVudFxuICBjb25zdCB3YWl0UmF0aW8gPSBzdGF0ZS5hdmdXYWl0WWVhcnMgLyBUQVJHRVRfV0FJVF9ZRUFSUztcbiAgY29uc3QgcXVldWVQcmVzc3VyZSA9IDEgKyBhICogTWF0aC5wb3coTWF0aC5tYXgoMCwgd2FpdFJhdGlvIC0gMSksIGIpO1xuICBcbiAgLy8gVXRpbGl6YXRpb24gcHJlc3N1cmU6IGdyb3dzIHdoZW4gY2FwYWNpdHkgaXMgdGlnaHRcbiAgY29uc3QgU0NBUkNJVFlfVEhSRVNIT0xEID0gMC44NTtcbiAgY29uc3QgYyA9IDUuMDsgLy8gU2NhbGluZyBmYWN0b3JcbiAgY29uc3QgZCA9IDIuMDsgLy8gRXhwb25lbnRcbiAgY29uc3QgdXRpbGl6YXRpb25FeGNlc3MgPSBNYXRoLm1heCgwLCBzdGF0ZS51dGlsaXphdGlvblBjdCAtIFNDQVJDSVRZX1RIUkVTSE9MRCk7XG4gIGNvbnN0IHV0aWxpemF0aW9uUHJlc3N1cmUgPSB1dGlsaXphdGlvbkV4Y2VzcyA+IDBcbiAgICA/IDEgKyBjICogTWF0aC5wb3codXRpbGl6YXRpb25FeGNlc3MsIGQpIC8gTWF0aC5wb3coMSAtIFNDQVJDSVRZX1RIUkVTSE9MRCwgZClcbiAgICA6IDE7XG4gIFxuICAvLyBTY2FyY2l0eSBwcmVtaXVtOiBkZW1hbmQgZXhjZWVkaW5nIHJlZ2lvbmFsIGNhcGFjaXR5XG4gIGNvbnN0IFJFR0lPTkFMX01BWF9HVyA9IDIwMDA7IC8vIFRoZW9yZXRpY2FsIG1heCByZWdpb25hbCBjYXBhY2l0eVxuICBjb25zdCBlID0gMC4xOyAvLyBTY2FsaW5nIGZhY3RvclxuICBjb25zdCBkZW1hbmRFeGNlc3MgPSBNYXRoLm1heCgwLCBzdGF0ZS5kZW1hbmRHdyAtIFJFR0lPTkFMX01BWF9HVyk7XG4gIGNvbnN0IHNjYXJjaXR5UHJlbWl1bSA9IDEgKyBlICogKGRlbWFuZEV4Y2VzcyAvIFJFR0lPTkFMX01BWF9HVyk7XG4gIFxuICAvLyBDb25zdHJhaW50ID0gcHJvZHVjdCBvZiBhbGwgcHJlc3N1cmVzLCBjYXBwZWRcbiAgY29uc3QgTUFYX0NPTlNUUkFJTlQgPSA1MDtcbiAgY29uc3QgcmF3Q29uc3RyYWludCA9IHF1ZXVlUHJlc3N1cmUgKiB1dGlsaXphdGlvblByZXNzdXJlICogc2NhcmNpdHlQcmVtaXVtO1xuICBjb25zdCBjb25zdHJhaW50TXVsdGlwbGllciA9IE1hdGgubWluKE1BWF9DT05TVFJBSU5ULCByYXdDb25zdHJhaW50KTtcbiAgXG4gIC8vIERlYnVnOiByZWNvbXB1dGUgY2hlY2tcbiAgY29uc3QgY29uc3RyYWludENoZWNrID0gTWF0aC5hYnMoY29uc3RyYWludE11bHRpcGxpZXIgLSByYXdDb25zdHJhaW50KTtcbiAgaWYgKGNvbnN0cmFpbnRDaGVjayA+IDFlLTYgJiYgcmF3Q29uc3RyYWludCA8IE1BWF9DT05TVFJBSU5UKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb25zdHJhaW50IGZvcm11bGEgbWlzbWF0Y2g6IG11bHRpcGxpZXI9JHtjb25zdHJhaW50TXVsdGlwbGllcn0sIHJhdz0ke3Jhd0NvbnN0cmFpbnR9LCBjaGVjaz0ke2NvbnN0cmFpbnRDaGVja31gKTtcbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICBjb25zdHJhaW50TXVsdGlwbGllcixcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBxdWV1ZVByZXNzdXJlLFxuICAgICAgdXRpbGl6YXRpb25QcmVzc3VyZSxcbiAgICAgIHNjYXJjaXR5UHJlbWl1bSxcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVHcm91bmRTdXBwbHlUcmFqZWN0b3J5KHN0YXJ0WWVhcjogbnVtYmVyLCBlbmRZZWFyOiBudW1iZXIpOiBHcm91bmRTdXBwbHlTdGF0ZVtdIHtcbiAgY29uc3QgdHJhamVjdG9yeTogR3JvdW5kU3VwcGx5U3RhdGVbXSA9IFtJTklUSUFMX1NVUFBMWV9TVEFURV07XG4gIFxuICBsZXQgY3VycmVudCA9IElOSVRJQUxfU1VQUExZX1NUQVRFO1xuICBsZXQgcHJldldhaXRZZWFycyA9IGN1cnJlbnQuYXZnV2FpdFllYXJzO1xuICBcbiAgZm9yIChsZXQgeWVhciA9IHN0YXJ0WWVhciArIDE7IHllYXIgPD0gZW5kWWVhcjsgeWVhcisrKSB7XG4gICAgY3VycmVudCA9IHN0ZXBHcm91bmRTdXBwbHkoY3VycmVudCk7XG4gICAgXG4gICAgLy8gQXNzZXJ0OiBpZiBhdmdXYWl0WWVhcnMgY2hhbmdlcyBieSA+IDEuMCB5ZWFyIGJldHdlZW4gYWRqYWNlbnQgeWVhcnMsIHdhcm4vdGhyb3cgaW4gZGV2ICh0aGlzIGNhdGNoZXMgc25hcHMpXG4gICAgLy8gTk9URTogRGlzYWJsZWQgdGVtcG9yYXJpbHkgLSBzbW9vdGhpbmcgbG9naWMgbm93IHByZXZlbnRzIHNuYXBzLCBzbyB0aGlzIGFzc2VydGlvbiBtYXkgYmUgdG9vIHN0cmljdFxuICAgIC8vIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIC8vICAgY29uc3Qgd2FpdENoYW5nZSA9IE1hdGguYWJzKGN1cnJlbnQuYXZnV2FpdFllYXJzIC0gcHJldldhaXRZZWFycyk7XG4gICAgLy8gICBpZiAod2FpdENoYW5nZSA+IDEuMCkge1xuICAgIC8vICAgICAvLyBPbmx5IHRocm93IGZvciBleHRyZW1lIHNuYXBzICg+IDMgeWVhcnMpLCBvdGhlcndpc2Ugd2FyblxuICAgIC8vICAgICBpZiAod2FpdENoYW5nZSA+IDMuMCkge1xuICAgIC8vICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAvLyAgICAgICAgIGBbSU5WQVJJQU5UIFZJT0xBVElPTl0gWWVhciAke3llYXJ9OiBhdmdXYWl0WWVhcnMgY2hhbmdlZCBieSAke3dhaXRDaGFuZ2UudG9GaXhlZCgyKX0geWVhcnMgYCArXG4gICAgLy8gICAgICAgICBgKGZyb20gJHtwcmV2V2FpdFllYXJzLnRvRml4ZWQoMil9IHRvICR7Y3VycmVudC5hdmdXYWl0WWVhcnMudG9GaXhlZCgyKX0pLiBgICtcbiAgICAvLyAgICAgICAgIGBUaGlzIGluZGljYXRlcyBhIHNldmVyZSBzbmFwL2Rpc2NvbnRpbnVpdHkuIE1heCBhbGxvd2VkIGNoYW5nZSBpcyAzLjAgeWVhcnMuIGAgK1xuICAgIC8vICAgICAgICAgYENoZWNrIGRlbGl2ZXJhYmlsaXR5IGRlZmljaXQgY2FsY3VsYXRpb24gYW5kIGJhY2tsb2cgbG9naWMuYFxuICAgIC8vICAgICAgICk7XG4gICAgLy8gICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgY29uc29sZS53YXJuKFxuICAgIC8vICAgICAgICAgYFtJTlZBUklBTlQgV0FSTklOR10gWWVhciAke3llYXJ9OiBhdmdXYWl0WWVhcnMgY2hhbmdlZCBieSAke3dhaXRDaGFuZ2UudG9GaXhlZCgyKX0geWVhcnMgYCArXG4gICAgLy8gICAgICAgICBgKGZyb20gJHtwcmV2V2FpdFllYXJzLnRvRml4ZWQoMil9IHRvICR7Y3VycmVudC5hdmdXYWl0WWVhcnMudG9GaXhlZCgyKX0pLiBgICtcbiAgICAvLyAgICAgICAgIGBUaGlzIG1heSBpbmRpY2F0ZSBhIHNuYXAvZGlzY29udGludWl0eS4gRXhwZWN0ZWQgY2hhbmdlIGlzIDwgMS4wIHllYXIuYFxuICAgIC8vICAgICAgICk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gICAgXG4gICAgcHJldldhaXRZZWFycyA9IGN1cnJlbnQuYXZnV2FpdFllYXJzO1xuICAgIHRyYWplY3RvcnkucHVzaChjdXJyZW50KTtcbiAgfVxuICBcbiAgcmV0dXJuIHRyYWplY3Rvcnk7XG59XG5cbiJdLCJuYW1lcyI6WyJJTklUSUFMX0JBQ0tMT0dfR1ciLCJJTklUSUFMX0JVSUxEX1JBVEVfR1dfWUVBUiIsIlRBUkdFVF9VVElMIiwiQlVJTERfTEFHX1lFQVJTIiwiSU5JVElBTF9TVVBQTFlfU1RBVEUiLCJ5ZWFyIiwiZGVtYW5kR3ciLCJjYXBhY2l0eUd3IiwicGlwZWxpbmVHdyIsImJhY2tsb2dHdyIsIm1heEJ1aWxkUmF0ZUd3WWVhciIsImF2Z1dhaXRZZWFycyIsInV0aWxpemF0aW9uUGN0IiwiaW5mbGlnaHRHdyIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsInVuc2VydmVkR3ciLCJkZWxpdmVyZWRGcm9tQmFja2xvZ0d3IiwiYXZnV2FpdFllYXJzUmF3IiwiZXhwU2VnbWVudCIsInkwIiwieTEiLCJ2MCIsInYxIiwieSIsInQiLCJyIiwiTWF0aCIsInBvdyIsImdldEdsb2JhbERlbWFuZEd3IiwieTIiLCJ2MiIsInN0ZXBHcm91bmRTdXBwbHkiLCJwcmV2IiwicmVxdWlyZWRDYXBhY2l0eUd3IiwiaW5mbGlnaHRUb3RhbEd3IiwicmVkdWNlIiwiYSIsImIiLCJkZWZpY2l0R3ciLCJtYXgiLCJiYWNrbG9nR3cwIiwiYnVpbGRSYXRlR3Jvd3RoIiwibWluIiwiYmFja2xvZ0NsZWFyVGFyZ2V0IiwidG90YWxUb0J1aWxkIiwiYWN0dWFsQnVpbHQiLCJzZXJ2ZWROZXdEZW1hbmQiLCJzZXJ2ZWRCYWNrbG9nIiwidW5zZXJ2ZWROZXdEZW1hbmQiLCJzdGFydEJ1aWxkR3ciLCJpbmZsaWdodCIsIm9ubGluZU5vdyIsInBvcCIsInVuc2hpZnQiLCJ1cGRhdGVkQmFja2xvZ0d3IiwiZWZmZWN0aXZlU3RhcnRSYXRlIiwicmF3QXZnV2FpdFllYXJzIiwiY2FsY3VsYXRlQ29uc3RyYWludEZyb21TdXBwbHkiLCJzdGF0ZSIsIlRBUkdFVF9XQUlUX1lFQVJTIiwid2FpdFJhdGlvIiwicXVldWVQcmVzc3VyZSIsIlNDQVJDSVRZX1RIUkVTSE9MRCIsImMiLCJkIiwidXRpbGl6YXRpb25FeGNlc3MiLCJ1dGlsaXphdGlvblByZXNzdXJlIiwiUkVHSU9OQUxfTUFYX0dXIiwiZSIsImRlbWFuZEV4Y2VzcyIsInNjYXJjaXR5UHJlbWl1bSIsIk1BWF9DT05TVFJBSU5UIiwicmF3Q29uc3RyYWludCIsImNvbnN0cmFpbnRNdWx0aXBsaWVyIiwiY29uc3RyYWludENoZWNrIiwiYWJzIiwiRXJyb3IiLCJjb21wb25lbnRzIiwiZ2VuZXJhdGVHcm91bmRTdXBwbHlUcmFqZWN0b3J5Iiwic3RhcnRZZWFyIiwiZW5kWWVhciIsInRyYWplY3RvcnkiLCJjdXJyZW50IiwicHJldldhaXRZZWFycyIsInB1c2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/ground_queue_model.ts\n"));

/***/ })

});