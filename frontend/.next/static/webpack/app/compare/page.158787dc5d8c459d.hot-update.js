"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/compare/page",{

/***/ "(app-pages-browser)/./app/lib/model/ground_constraint_penalties.ts":
/*!******************************************************!*\
  !*** ./app/lib/model/ground_constraint_penalties.ts ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateGroundConstraintPenalties: function() { return /* binding */ calculateGroundConstraintPenalties; },\n/* harmony export */   calculateHillScarcityPremium: function() { return /* binding */ calculateHillScarcityPremium; },\n/* harmony export */   calculateScarcityRent: function() { return /* binding */ calculateScarcityRent; }\n/* harmony export */ });\n/**\n * Ground Constraint Penalties Model\n * \n * Calculates WACC-based penalties and multipliers from backlog/wait time:\n * - timeToEnergizePenaltyPerPflopYear: WACC carry + lost margin\n * - siteMultiplier: land + interconnect scarcity\n * - pueMultiplier: cooling/water stress\n */ /**\n * Hill function: saturating sigmoid-like curve\n * @param x Input value\n * @param x50 Half-saturation point\n * @param n Hill coefficient (steepness)\n * @returns Value between 0 and 1\n */ function hill(x, x50, n) {\n    if (x <= 0) return 0;\n    const xn = Math.pow(x, n);\n    const x50n = Math.pow(x50, n);\n    return xn / (x50n + xn);\n}\n/**\n * Threshold Hill function: 0 until x exceeds x0, then Hill on the excess\n * @param x Input value\n * @param x0 Threshold (must exceed this before Hill activates)\n * @param x50 Half-saturation point for excess\n * @param n Hill coefficient\n * @returns Value between 0 and 1\n */ function thresholdHill(x, x0, x50, n) {\n    const excess = Math.max(0, x - x0);\n    return hill(excess, x50, n);\n}\n/**\n * Calculate scarcity multiplier using LOG-BASED function (never fully saturates)\n * \n * Replaces Hill function with log-based approach that can distinguish between\n * wait=20yr and wait=254yr (unlike Hill which saturates early).\n * \n * @param waitYears Average wait time (years) - NO CLAMP applied\n * @param utilizationPct Utilization percentage (0-1) - optional threshold gate\n * @param params Optional parameters\n * @returns Scarcity multiplier (1.0 = no scarcity, 2.0 = 2x price) and debug fields\n */ function calculateScarcityRent(waitYears, utilizationPct, params) {\n    var _params_utilizationThreshold;\n    const UTIL_THRESHOLD = (_params_utilizationThreshold = params === null || params === void 0 ? void 0 : params.utilizationThreshold) !== null && _params_utilizationThreshold !== void 0 ? _params_utilizationThreshold : 0.85;\n    var _params_waitThresholdYears;\n    const WAIT_THRESHOLD = (_params_waitThresholdYears = params === null || params === void 0 ? void 0 : params.waitThresholdYears) !== null && _params_waitThresholdYears !== void 0 ? _params_waitThresholdYears : 1.0;\n    var _params_rentMaxMultiplier;\n    // Dynamic rent max that scales with wait time (prevents Moore's Law from canceling scarcity)\n    // OLD: baseMax=2.0, cap=5.0\n    // NEW: baseMax=2.0, cap=4.0, scaling=0.3 per log10 (more conservative)\n    // At wait=10yr: ~2.3x, wait=50yr: ~2.6x, wait=100yr: ~2.9x (log-based, never fully saturates)\n    const baseMax = (_params_rentMaxMultiplier = params === null || params === void 0 ? void 0 : params.rentMaxMultiplier) !== null && _params_rentMaxMultiplier !== void 0 ? _params_rentMaxMultiplier : 2.0;\n    const waitScaling = waitYears > 1 ? Math.log10(waitYears) * 0.3 : 0; // +0.3x per order of magnitude\n    const RENT_MAX = Math.min(4.0, baseMax + waitScaling); // Cap at 4x total\n    // Gate: no scarcity if utilization < 85% AND wait < 1 year\n    if (utilizationPct !== undefined && utilizationPct < UTIL_THRESHOLD && waitYears < WAIT_THRESHOLD) {\n        return {\n            scarcityMultiplier: 1.0,\n            rentFrac: 0,\n            waitEffYears: waitYears,\n            scarcityHill: {\n                h: 0,\n                rentFrac: 0\n            },\n            avgWaitYearsRaw: waitYears,\n            avgWaitYearsClamped: waitYears\n        };\n    }\n    // Wait term: LOG-BASED (never saturates, but grows slowly)\n    // At wait=1yr: 0, wait=3yr: 0.48, wait=10yr: 1.0, wait=100yr: 2.0, wait=1000yr: 3.0\n    const waitTerm = waitYears > WAIT_THRESHOLD ? Math.log10(waitYears / WAIT_THRESHOLD) : 0;\n    // Utilization term: sigmoid above threshold\n    const utilExcess = Math.max(0, (utilizationPct !== null && utilizationPct !== void 0 ? utilizationPct : 0) - UTIL_THRESHOLD);\n    const utilTerm = utilExcess > 0 ? 1 / (1 + Math.exp(-20 * (utilExcess - 0.05)) // Sharp rise at 90%\n    ) : 0;\n    // Combined: scarcity = 1 + min(RENT_MAX - 1, waitTerm * (1 + utilTerm))\n    const rawRent = waitTerm * (1 + utilTerm);\n    const rentFrac = Math.min(RENT_MAX - 1, rawRent);\n    const scarcityMultiplier = 1 + rentFrac;\n    // For backward compatibility: return scarcityRentPerPflopYear = 0\n    // (scarcity is now multiplicative, not additive)\n    return {\n        scarcityMultiplier,\n        rentFrac,\n        waitEffYears: waitYears,\n        scarcityHill: {\n            h: waitTerm,\n            rentFrac\n        },\n        avgWaitYearsRaw: waitYears,\n        avgWaitYearsClamped: waitYears\n    };\n}\n/**\n * Calculate ground constraint penalties from supply state\n * \n * @param state Current ground supply state\n * @param flopsPerWattGround GFLOPS/W for ground compute\n * @param pueGround PUE for ground datacenters\n * @param capacityFactorGround Capacity factor for ground\n * @param waccParams Optional WACC parameters for capital rationing\n * @returns Penalties and multipliers\n */ function calculateGroundConstraintPenalties(state, flopsPerWattGround, pueGround, capacityFactorGround, waccParams) {\n    const backlogGw = state.backlogGw; // Pipeline is not backlog. If backlog is missing, treat as 0 and let chartInputs/buildoutDebug supply the real number elsewhere.\n    // Fix 5: Add fallback calculation for avgWaitYears if it's 0 but backlog exists\n    // Sanity check: if backlog > buildRate, wait should be > 0\n    const impliedWait = backlogGw > 0 && state.maxBuildRateGwYear > 0 ? backlogGw / Math.max(state.maxBuildRateGwYear, 1) : 0;\n    const avgWaitYears = Math.max(state.avgWaitYears, impliedWait > 0.1 ? impliedWait : 0);\n    const maxBuildRateGwYear = state.maxBuildRateGwYear;\n    const utilizationPct = state.utilizationPct;\n    // Convert GW to MW\n    const backlogMw = backlogGw * 1000;\n    // UNIT GUARD: Fix units mismatch (flopsPerWattGround might be TFLOPS/W instead of GFLOPS/W)\n    let gflopsPerWatt = flopsPerWattGround;\n    if (flopsPerWattGround < 50) {\n        // Likely TFLOPS/W (e.g., 2 TFLOPS/W), convert to GFLOPS/W\n        gflopsPerWatt = flopsPerWattGround * 1000;\n        if (true) {\n            console.warn(\"[UNIT CONVERSION] flopsPerWattGround=\".concat(flopsPerWattGround, \" < 50, treating as TFLOPS/W and converting to \").concat(gflopsPerWatt, \" GFLOPS/W\"));\n        }\n    }\n    // Clamp insane values\n    if (gflopsPerWatt > 20000) {\n        if (true) {\n            console.warn(\"[UNIT CLAMP] gflopsPerWatt=\".concat(gflopsPerWatt, \" > 20000, clamping to 20000\"));\n        }\n        gflopsPerWatt = 20000;\n    }\n    var _waccParams_baseWacc;\n    // WACC parameters (capital rationing: WACC rises with backlog)\n    const baseWacc = (_waccParams_baseWacc = waccParams === null || waccParams === void 0 ? void 0 : waccParams.baseWacc) !== null && _waccParams_baseWacc !== void 0 ? _waccParams_baseWacc : 0.10; // 10% base WACC\n    var _waccParams_waccBacklogK;\n    const waccBacklogK = (_waccParams_waccBacklogK = waccParams === null || waccParams === void 0 ? void 0 : waccParams.waccBacklogK) !== null && _waccParams_waccBacklogK !== void 0 ? _waccParams_waccBacklogK : 0.5; // Scaling factor\n    var _waccParams_waccBacklogExponent;\n    const waccBacklogExponent = (_waccParams_waccBacklogExponent = waccParams === null || waccParams === void 0 ? void 0 : waccParams.waccBacklogExponent) !== null && _waccParams_waccBacklogExponent !== void 0 ? _waccParams_waccBacklogExponent : 1.2; // Exponent for convexity\n    var _waccParams_criticalBacklogGW;\n    const criticalBacklogGW = (_waccParams_criticalBacklogGW = waccParams === null || waccParams === void 0 ? void 0 : waccParams.criticalBacklogGW) !== null && _waccParams_criticalBacklogGW !== void 0 ? _waccParams_criticalBacklogGW : 50; // Critical backlog threshold\n    // Compute effective WACC (rises with backlog)\n    // waccEffective = baseWacc * (1 + waccBacklogK * (backlogGW/criticalBacklogGW)^waccBacklogExponent)\n    const backlogRatio = Math.max(0, backlogGw / criticalBacklogGW);\n    const waccMultiplier = 1 + waccBacklogK * Math.pow(backlogRatio, waccBacklogExponent);\n    const waccEffective = baseWacc * waccMultiplier;\n    // Constants\n    const WACC = 0.10;\n    const CAPEX_PER_MW = 3000000; // $3M/MW capex at risk\n    // Replace the huge lost-margin number with something defensible + capped\n    const LOST_MARGIN_PER_MW_YEAR = 600000; // was 2,000,000, now 600k\n    const LOST_MARGIN_CAP_PER_MW = 1800000; // cap total lost margin component\n    const MAX_WAIT_FOR_CARRY = 4; // years, cap compounding horizon\n    const MAX_TOTAL_PENALTY_PER_MW_YEAR = 2500000; // hard cap so it never goes vertical\n    const BASE_SITE_COST_PER_MW_YEAR = 150000; // $150k/MW-year base site cost\n    const BASE_PUE = 1.3; // Baseline PUE\n    // Reference capex amort for capping (used to prevent penalty from dominating)\n    const CAPEX_AMORT_PER_PFLOP_YEAR_REFERENCE = 1500; // Base site cost per PFLOP-year\n    // 1. Bounded Delay Penalty: Linear WACC carry (NOT exponential)\n    // delayPenaltyPerPflopYear = capexPerPflopYear * wacc * avgWaitYears\n    // Cap it: delayPenaltyPerPflopYear = min(delayPenaltyPerPflopYear, delayCapFrac * capexPerPflopYear)\n    let timeToEnergizePenaltyPerPflopYear = 0;\n    let capexAtRiskPerMW = 0;\n    let carryCostPerMW = 0;\n    let lostMarginPerMW = 0;\n    // Convert capex to per-PFLOP-year for penalty calculation\n    const pflopsPerMW = gflopsPerWatt * capacityFactorGround / pueGround;\n    const CAPEX_PER_PFLOP_YEAR = CAPEX_PER_MW / Math.max(pflopsPerMW, 1e-6);\n    if (avgWaitYears > 0.01) {\n        // Linear delay penalty: WACC * capex * waitYears (NOT exponential)\n        const delayPenaltyUncapped = CAPEX_PER_PFLOP_YEAR * baseWacc * avgWaitYears;\n        // Cap at delayCapFrac of capex (0.5-1.0 range)\n        const DELAY_CAP_FRAC = 0.75; // Cap at 75% of capex\n        timeToEnergizePenaltyPerPflopYear = Math.min(delayPenaltyUncapped, DELAY_CAP_FRAC * CAPEX_PER_PFLOP_YEAR);\n        // For debug fields (MW-based)\n        capexAtRiskPerMW = CAPEX_PER_MW;\n        carryCostPerMW = CAPEX_PER_MW * baseWacc * avgWaitYears;\n        lostMarginPerMW = 0; // Not used in bounded model\n    }\n    // 2. Site Multiplier: land + interconnect scarcity (Hill-shaped, thresholded)\n    // Backlog rent: Hill on avgWaitYears (this creates the \"hump\" shape)\n    const waitRent = hill(avgWaitYears, 2.0, 2.0); // 50% rent at 2 years\n    const backlogRent = hill(backlogGw, 30, 2.0); // kicks in around ~30 GW backlog\n    // Utilization rent: strictly 0 until > 85% utilization\n    const utilRent = thresholdHill(utilizationPct, 0.85, 0.05, 2.0); // x50 is 5% above threshold\n    const landScarcityFactor = 1 + 0.35 * backlogRent;\n    const interconnectScarcityFactor = 1 + 0.45 * Math.max(waitRent, utilRent);\n    // Site multiplier should be ~1 when backlog=0, wait=0, util<0.85\n    const siteMultiplier = landScarcityFactor * interconnectScarcityFactor;\n    // 3. PUE Multiplier: cooling/water stress (thresholded)\n    const coolingStressFactor = 1 + 0.25 * utilRent;\n    const waterStressFactor = 1 + 0.20 * backlogRent;\n    const pueMultiplier = 1 + (coolingStressFactor - 1) + (waterStressFactor - 1); // Additive stress\n    return {\n        timeToEnergizePenaltyPerPflopYear,\n        siteMultiplier,\n        pueMultiplier,\n        backlogGw,\n        avgWaitYears,\n        capexAtRiskPerMW,\n        carryCostPerMW,\n        lostMarginPerMW,\n        waccBase: baseWacc,\n        waccEffective\n    };\n}\n/**\n * Calculate Hill-based scarcity premium from queue pressure + utilization\n * \n * Scarcity multiplier (NOT exponential):\n * - queuePressure = backlogGW / (backlogGW + K_backlogGW) where K_backlogGW ~ 50-150\n * - utilPressure = 1 / (1 + exp(-k*(utilizationPct - u0))) with u0 ~ 0.85-0.92, k ~ 12-20\n * - scarcity = 1 + rentFracMax * (queuePressure^h) * utilPressure\n * \n * @param backlogGw Backlog in GW\n * @param utilizationPct Utilization percentage (0-1)\n * @param baseCostPerPflopYear Base cost per PFLOP-year (for rent calculation)\n * @param params Optional parameters\n * @returns Scarcity rent and debug fields\n */ function calculateHillScarcityPremium(backlogGw, utilizationPct, baseCostPerPflopYear, params) {\n    var _params_kBacklogGw;\n    const kBacklogGw = (_params_kBacklogGw = params === null || params === void 0 ? void 0 : params.kBacklogGw) !== null && _params_kBacklogGw !== void 0 ? _params_kBacklogGw : 100; // K_backlogGW ~ 50-150\n    var _params_u0;\n    const u0 = (_params_u0 = params === null || params === void 0 ? void 0 : params.u0) !== null && _params_u0 !== void 0 ? _params_u0 : 0.88; // u0 ~ 0.85-0.92 (scarcity starts at 88% utilization)\n    var _params_k;\n    const k = (_params_k = params === null || params === void 0 ? void 0 : params.k) !== null && _params_k !== void 0 ? _params_k : 16; // k ~ 12-20 (steepness of utilization curve)\n    var _params_rentFracMax;\n    const rentFracMax = (_params_rentFracMax = params === null || params === void 0 ? void 0 : params.rentFracMax) !== null && _params_rentFracMax !== void 0 ? _params_rentFracMax : 0.5; // rentFracMax ~ 0.3-0.8 (max rent fraction)\n    var _params_h;\n    const h = (_params_h = params === null || params === void 0 ? void 0 : params.h) !== null && _params_h !== void 0 ? _params_h : 2.0; // h ~ 1-3 (steepness of queue pressure)\n    // Queue pressure: backlogGW / (backlogGW + K_backlogGW)\n    // Saturates at 1 as backlog grows\n    const queuePressure = backlogGw / (backlogGw + kBacklogGw);\n    // Utilization pressure: 1 / (1 + exp(-k*(utilizationPct - u0)))\n    // Sigmoid that rises sharply around u0\n    const utilExcess = utilizationPct - u0;\n    const utilPressure = 1 / (1 + Math.exp(-k * utilExcess));\n    // Scarcity multiplier: 1 + rentFracMax * (queuePressure^h) * utilPressure\n    const scarcityMultiplier = 1 + rentFracMax * Math.pow(queuePressure, h) * utilPressure;\n    // Scarcity rent = base cost * (scarcity - 1)\n    const scarcityRentPerPflopYear = baseCostPerPflopYear * (scarcityMultiplier - 1);\n    return {\n        scarcityRentPerPflopYear,\n        scarcityMultiplier,\n        queuePressure,\n        utilPressure\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX2NvbnN0cmFpbnRfcGVuYWx0aWVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7O0NBT0MsR0FJRDs7Ozs7O0NBTUMsR0FDRCxTQUFTQSxLQUFLQyxDQUFTLEVBQUVDLEdBQVcsRUFBRUMsQ0FBUztJQUM3QyxJQUFJRixLQUFLLEdBQUcsT0FBTztJQUNuQixNQUFNRyxLQUFLQyxLQUFLQyxHQUFHLENBQUNMLEdBQUdFO0lBQ3ZCLE1BQU1JLE9BQU9GLEtBQUtDLEdBQUcsQ0FBQ0osS0FBS0M7SUFDM0IsT0FBT0MsS0FBTUcsQ0FBQUEsT0FBT0gsRUFBQztBQUN2QjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTSSxjQUFjUCxDQUFTLEVBQUVRLEVBQVUsRUFBRVAsR0FBVyxFQUFFQyxDQUFTO0lBQ2xFLE1BQU1PLFNBQVNMLEtBQUtNLEdBQUcsQ0FBQyxHQUFHVixJQUFJUTtJQUMvQixPQUFPVCxLQUFLVSxRQUFRUixLQUFLQztBQUMzQjtBQXVCQTs7Ozs7Ozs7OztDQVVDLEdBQ00sU0FBU1Msc0JBQ2RDLFNBQWlCLEVBQ2pCQyxjQUF1QixFQUN2QkMsTUFJQztRQWFzQkE7SUFBdkIsTUFBTUMsaUJBQWlCRCxDQUFBQSwrQkFBQUEsbUJBQUFBLDZCQUFBQSxPQUFRRSxvQkFBb0IsY0FBNUJGLDBDQUFBQSwrQkFBZ0M7UUFDaENBO0lBQXZCLE1BQU1HLGlCQUFpQkgsQ0FBQUEsNkJBQUFBLG1CQUFBQSw2QkFBQUEsT0FBUUksa0JBQWtCLGNBQTFCSix3Q0FBQUEsNkJBQThCO1FBTXJDQTtJQUpoQiw2RkFBNkY7SUFDN0YsNEJBQTRCO0lBQzVCLHVFQUF1RTtJQUN2RSw4RkFBOEY7SUFDOUYsTUFBTUssVUFBVUwsQ0FBQUEsNEJBQUFBLG1CQUFBQSw2QkFBQUEsT0FBUU0saUJBQWlCLGNBQXpCTix1Q0FBQUEsNEJBQTZCO0lBQzdDLE1BQU1PLGNBQWNULFlBQVksSUFBSVIsS0FB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QSxtQkFBQUEsNkJBQUFBLE9BQVEyRSxVQUFVLGNBQWxCM0UsZ0NBQUFBLHFCQUFzQixLQUFLLHVCQUF1QjtRQUMxREE7SUFBWCxNQUFNNEUsS0FBSzVFLENBQUFBLGFBQUFBLG1CQUFBQSw2QkFBQUEsT0FBUTRFLEVBQUUsY0FBVjVFLHdCQUFBQSxhQUFjLE1BQU0sc0RBQXNEO1FBQzNFQTtJQUFWLE1BQU02RSxJQUFJN0UsQ0FBQUEsWUFBQUEsbUJBQUFBLDZCQUFBQSxPQUFRNkUsQ0FBQyxjQUFUN0UsdUJBQUFBLFlBQWEsSUFBSSw2Q0FBNkM7UUFDcERBO0lBQXBCLE1BQU04RSxjQUFjOUUsQ0FBQUEsc0JBQUFBLG1CQUFBQSw2QkFBQUEsT0FBUThFLFdBQVcsY0FBbkI5RSxpQ0FBQUEsc0JBQXVCLEtBQUssNENBQTRDO1FBQ2xGQTtJQUFWLE1BQU1nQixJQUFJaEIsQ0FBQUEsWUFBQUEsbUJBQUFBLDZCQUFBQSxPQUFRZ0IsQ0FBQyxjQUFUaEIsdUJBQUFBLFlBQWEsS0FBSyx3Q0FBd0M7SUFFcEUsd0RBQXdEO0lBQ3hELGtDQUFrQztJQUNsQyxNQUFNK0UsZ0JBQWdCakQsWUFBYUEsQ0FBQUEsWUFBWTZDLFVBQVM7SUFFeEQsZ0VBQWdFO0lBQ2hFLHVDQUF1QztJQUN2QyxNQUFNdkQsYUFBYXJCLGlCQUFpQjZFO0lBQ3BDLE1BQU1JLGVBQWUsSUFBSyxLQUFJMUYsS0FBS2dDLEdBQUcsQ0FBQyxDQUFDdUQsSUFBSXpELFdBQVU7SUFFdEQsMEVBQTBFO0lBQzFFLE1BQU1SLHFCQUFxQixJQUFJa0UsY0FBY3hGLEtBQUtDLEdBQUcsQ0FBQ3dGLGVBQWUvRCxLQUFLZ0U7SUFFMUUsNkNBQTZDO0lBQzdDLE1BQU1DLDJCQUEyQlAsdUJBQXdCOUQsQ0FBQUEscUJBQXFCO0lBRTlFLE9BQU87UUFDTHFFO1FBQ0FyRTtRQUNBbUU7UUFDQUM7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX2NvbnN0cmFpbnRfcGVuYWx0aWVzLnRzPzIzZmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHcm91bmQgQ29uc3RyYWludCBQZW5hbHRpZXMgTW9kZWxcbiAqIFxuICogQ2FsY3VsYXRlcyBXQUNDLWJhc2VkIHBlbmFsdGllcyBhbmQgbXVsdGlwbGllcnMgZnJvbSBiYWNrbG9nL3dhaXQgdGltZTpcbiAqIC0gdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyOiBXQUNDIGNhcnJ5ICsgbG9zdCBtYXJnaW5cbiAqIC0gc2l0ZU11bHRpcGxpZXI6IGxhbmQgKyBpbnRlcmNvbm5lY3Qgc2NhcmNpdHlcbiAqIC0gcHVlTXVsdGlwbGllcjogY29vbGluZy93YXRlciBzdHJlc3NcbiAqL1xuXG5pbXBvcnQgeyBHcm91bmRTdXBwbHlTdGF0ZSB9IGZyb20gJy4vZ3JvdW5kX3F1ZXVlX21vZGVsJztcblxuLyoqXG4gKiBIaWxsIGZ1bmN0aW9uOiBzYXR1cmF0aW5nIHNpZ21vaWQtbGlrZSBjdXJ2ZVxuICogQHBhcmFtIHggSW5wdXQgdmFsdWVcbiAqIEBwYXJhbSB4NTAgSGFsZi1zYXR1cmF0aW9uIHBvaW50XG4gKiBAcGFyYW0gbiBIaWxsIGNvZWZmaWNpZW50IChzdGVlcG5lc3MpXG4gKiBAcmV0dXJucyBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDFcbiAqL1xuZnVuY3Rpb24gaGlsbCh4OiBudW1iZXIsIHg1MDogbnVtYmVyLCBuOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoeCA8PSAwKSByZXR1cm4gMDtcbiAgY29uc3QgeG4gPSBNYXRoLnBvdyh4LCBuKTtcbiAgY29uc3QgeDUwbiA9IE1hdGgucG93KHg1MCwgbik7XG4gIHJldHVybiB4biAvICh4NTBuICsgeG4pO1xufVxuXG4vKipcbiAqIFRocmVzaG9sZCBIaWxsIGZ1bmN0aW9uOiAwIHVudGlsIHggZXhjZWVkcyB4MCwgdGhlbiBIaWxsIG9uIHRoZSBleGNlc3NcbiAqIEBwYXJhbSB4IElucHV0IHZhbHVlXG4gKiBAcGFyYW0geDAgVGhyZXNob2xkIChtdXN0IGV4Y2VlZCB0aGlzIGJlZm9yZSBIaWxsIGFjdGl2YXRlcylcbiAqIEBwYXJhbSB4NTAgSGFsZi1zYXR1cmF0aW9uIHBvaW50IGZvciBleGNlc3NcbiAqIEBwYXJhbSBuIEhpbGwgY29lZmZpY2llbnRcbiAqIEByZXR1cm5zIFZhbHVlIGJldHdlZW4gMCBhbmQgMVxuICovXG5mdW5jdGlvbiB0aHJlc2hvbGRIaWxsKHg6IG51bWJlciwgeDA6IG51bWJlciwgeDUwOiBudW1iZXIsIG46IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IGV4Y2VzcyA9IE1hdGgubWF4KDAsIHggLSB4MCk7XG4gIHJldHVybiBoaWxsKGV4Y2VzcywgeDUwLCBuKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcm91bmRDb25zdHJhaW50UGVuYWx0aWVzIHtcbiAgLy8gVGltZS10by1lbmVyZ2l6ZSBwZW5hbHR5IChXQUNDIGNhcnJ5ICsgbG9zdCBtYXJnaW4pXG4gIHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhcjogbnVtYmVyO1xuICBcbiAgLy8gU2l0ZSBtdWx0aXBsaWVyIChsYW5kICsgaW50ZXJjb25uZWN0IHNjYXJjaXR5KVxuICBzaXRlTXVsdGlwbGllcjogbnVtYmVyO1xuICBcbiAgLy8gUFVFIG11bHRpcGxpZXIgKGNvb2xpbmcvd2F0ZXIgc3RyZXNzKVxuICBwdWVNdWx0aXBsaWVyOiBudW1iZXI7XG4gIFxuICAvLyBEZWJ1ZyBmaWVsZHNcbiAgYmFja2xvZ0d3OiBudW1iZXI7XG4gIGF2Z1dhaXRZZWFyczogbnVtYmVyO1xuICBjYXBleEF0Umlza1Blck1XOiBudW1iZXI7XG4gIGNhcnJ5Q29zdFBlck1XOiBudW1iZXI7XG4gIGxvc3RNYXJnaW5QZXJNVzogbnVtYmVyO1xuICAvLyBXQUNDIGRlYnVnIGZpZWxkc1xuICB3YWNjQmFzZT86IG51bWJlcjtcbiAgd2FjY0VmZmVjdGl2ZT86IG51bWJlcjtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgc2NhcmNpdHkgbXVsdGlwbGllciB1c2luZyBMT0ctQkFTRUQgZnVuY3Rpb24gKG5ldmVyIGZ1bGx5IHNhdHVyYXRlcylcbiAqIFxuICogUmVwbGFjZXMgSGlsbCBmdW5jdGlvbiB3aXRoIGxvZy1iYXNlZCBhcHByb2FjaCB0aGF0IGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gKiB3YWl0PTIweXIgYW5kIHdhaXQ9MjU0eXIgKHVubGlrZSBIaWxsIHdoaWNoIHNhdHVyYXRlcyBlYXJseSkuXG4gKiBcbiAqIEBwYXJhbSB3YWl0WWVhcnMgQXZlcmFnZSB3YWl0IHRpbWUgKHllYXJzKSAtIE5PIENMQU1QIGFwcGxpZWRcbiAqIEBwYXJhbSB1dGlsaXphdGlvblBjdCBVdGlsaXphdGlvbiBwZXJjZW50YWdlICgwLTEpIC0gb3B0aW9uYWwgdGhyZXNob2xkIGdhdGVcbiAqIEBwYXJhbSBwYXJhbXMgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICogQHJldHVybnMgU2NhcmNpdHkgbXVsdGlwbGllciAoMS4wID0gbm8gc2NhcmNpdHksIDIuMCA9IDJ4IHByaWNlKSBhbmQgZGVidWcgZmllbGRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVTY2FyY2l0eVJlbnQoXG4gIHdhaXRZZWFyczogbnVtYmVyLFxuICB1dGlsaXphdGlvblBjdD86IG51bWJlcixcbiAgcGFyYW1zPzoge1xuICAgIHdhaXRUaHJlc2hvbGRZZWFycz86IG51bWJlcjsgLy8gTWluaW11bSB3YWl0IGJlZm9yZSBzY2FyY2l0eSBhY3RpdmF0ZXMgKGRlZmF1bHQgMS4wKVxuICAgIHJlbnRNYXhNdWx0aXBsaWVyPzogbnVtYmVyOyAvLyBNYXhpbXVtIHByaWNlIG11bHRpcGxpZXIgKGRlZmF1bHQgMi4wID0gMnggcHJpY2UpXG4gICAgdXRpbGl6YXRpb25UaHJlc2hvbGQ/OiBudW1iZXI7IC8vIFV0aWxpemF0aW9uIHRocmVzaG9sZCAoZGVmYXVsdCAwLjg1KVxuICB9XG4pOiB7XG4gIHNjYXJjaXR5TXVsdGlwbGllcjogbnVtYmVyOyAvLyBQcmljZSBtdWx0aXBsaWVyICgxLjAgPSBubyBzY2FyY2l0eSwgMi4wID0gMngpXG4gIHJlbnRGcmFjOiBudW1iZXI7IC8vIFJlbnQgZnJhY3Rpb24gKDAgPSBubyByZW50LCAxLjAgPSBtYXggcmVudClcbiAgd2FpdEVmZlllYXJzOiBudW1iZXI7XG4gIC8vIERlYnVnIGZpZWxkc1xuICBzY2FyY2l0eUhpbGw6IHtcbiAgICBoOiBudW1iZXI7IC8vIFdhaXQgdGVybSAobG9nLWJhc2VkKVxuICAgIHJlbnRGcmFjOiBudW1iZXI7IC8vIFJlbnQgZnJhY3Rpb24gYWZ0ZXIgYXBwbHlpbmcgcmVudE1heFxuICB9O1xuICBhdmdXYWl0WWVhcnNSYXc6IG51bWJlcjsgLy8gUmF3IHdhaXQgeWVhcnMgKG5vIGNsYW1wKVxuICBhdmdXYWl0WWVhcnNDbGFtcGVkOiBudW1iZXI7IC8vIFNhbWUgYXMgcmF3IChubyBjbGFtcCBhcHBsaWVkKVxufSB7XG4gIGNvbnN0IFVUSUxfVEhSRVNIT0xEID0gcGFyYW1zPy51dGlsaXphdGlvblRocmVzaG9sZCA/PyAwLjg1O1xuICBjb25zdCBXQUlUX1RIUkVTSE9MRCA9IHBhcmFtcz8ud2FpdFRocmVzaG9sZFllYXJzID8/IDEuMDtcbiAgXG4gIC8vIER5bmFtaWMgcmVudCBtYXggdGhhdCBzY2FsZXMgd2l0aCB3YWl0IHRpbWUgKHByZXZlbnRzIE1vb3JlJ3MgTGF3IGZyb20gY2FuY2VsaW5nIHNjYXJjaXR5KVxuICAvLyBPTEQ6IGJhc2VNYXg9Mi4wLCBjYXA9NS4wXG4gIC8vIE5FVzogYmFzZU1heD0yLjAsIGNhcD00LjAsIHNjYWxpbmc9MC4zIHBlciBsb2cxMCAobW9yZSBjb25zZXJ2YXRpdmUpXG4gIC8vIEF0IHdhaXQ9MTB5cjogfjIuM3gsIHdhaXQ9NTB5cjogfjIuNngsIHdhaXQ9MTAweXI6IH4yLjl4IChsb2ctYmFzZWQsIG5ldmVyIGZ1bGx5IHNhdHVyYXRlcylcbiAgY29uc3QgYmFzZU1heCA9IHBhcmFtcz8ucmVudE1heE11bHRpcGxpZXIgPz8gMi4wO1xuICBjb25zdCB3YWl0U2NhbGluZyA9IHdhaXRZZWFycyA+IDEgPyBNYXRoLmxvZzEwKHdhaXRZZWFycykgKiAwLjMgOiAwOyAvLyArMC4zeCBwZXIgb3JkZXIgb2YgbWFnbml0dWRlXG4gIGNvbnN0IFJFTlRfTUFYID0gTWF0aC5taW4oNC4wLCBiYXNlTWF4ICsgd2FpdFNjYWxpbmcpOyAvLyBDYXAgYXQgNHggdG90YWxcbiAgXG4gIC8vIEdhdGU6IG5vIHNjYXJjaXR5IGlmIHV0aWxpemF0aW9uIDwgODUlIEFORCB3YWl0IDwgMSB5ZWFyXG4gIGlmICh1dGlsaXphdGlvblBjdCAhPT0gdW5kZWZpbmVkICYmIHV0aWxpemF0aW9uUGN0IDwgVVRJTF9USFJFU0hPTEQgJiYgd2FpdFllYXJzIDwgV0FJVF9USFJFU0hPTEQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2NhcmNpdHlNdWx0aXBsaWVyOiAxLjAsXG4gICAgICByZW50RnJhYzogMCxcbiAgICAgIHdhaXRFZmZZZWFyczogd2FpdFllYXJzLFxuICAgICAgc2NhcmNpdHlIaWxsOiB7IGg6IDAsIHJlbnRGcmFjOiAwIH0sXG4gICAgICBhdmdXYWl0WWVhcnNSYXc6IHdhaXRZZWFycyxcbiAgICAgIGF2Z1dhaXRZZWFyc0NsYW1wZWQ6IHdhaXRZZWFycyxcbiAgICB9O1xuICB9XG4gIFxuICAvLyBXYWl0IHRlcm06IExPRy1CQVNFRCAobmV2ZXIgc2F0dXJhdGVzLCBidXQgZ3Jvd3Mgc2xvd2x5KVxuICAvLyBBdCB3YWl0PTF5cjogMCwgd2FpdD0zeXI6IDAuNDgsIHdhaXQ9MTB5cjogMS4wLCB3YWl0PTEwMHlyOiAyLjAsIHdhaXQ9MTAwMHlyOiAzLjBcbiAgY29uc3Qgd2FpdFRlcm0gPSB3YWl0WWVhcnMgPiBXQUlUX1RIUkVTSE9MRCBcbiAgICA/IE1hdGgubG9nMTAod2FpdFllYXJzIC8gV0FJVF9USFJFU0hPTEQpIFxuICAgIDogMDtcbiAgXG4gIC8vIFV0aWxpemF0aW9uIHRlcm06IHNpZ21vaWQgYWJvdmUgdGhyZXNob2xkXG4gIGNvbnN0IHV0aWxFeGNlc3MgPSBNYXRoLm1heCgwLCAodXRpbGl6YXRpb25QY3QgPz8gMCkgLSBVVElMX1RIUkVTSE9MRCk7XG4gIGNvbnN0IHV0aWxUZXJtID0gdXRpbEV4Y2VzcyA+IDAgXG4gICAgPyAxIC8gKDEgKyBNYXRoLmV4cCgtMjAgKiAodXRpbEV4Y2VzcyAtIDAuMDUpKSkgLy8gU2hhcnAgcmlzZSBhdCA5MCVcbiAgICA6IDA7XG4gIFxuICAvLyBDb21iaW5lZDogc2NhcmNpdHkgPSAxICsgbWluKFJFTlRfTUFYIC0gMSwgd2FpdFRlcm0gKiAoMSArIHV0aWxUZXJtKSlcbiAgY29uc3QgcmF3UmVudCA9IHdhaXRUZXJtICogKDEgKyB1dGlsVGVybSk7XG4gIGNvbnN0IHJlbnRGcmFjID0gTWF0aC5taW4oUkVOVF9NQVggLSAxLCByYXdSZW50KTtcbiAgY29uc3Qgc2NhcmNpdHlNdWx0aXBsaWVyID0gMSArIHJlbnRGcmFjO1xuICBcbiAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IHJldHVybiBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXIgPSAwXG4gIC8vIChzY2FyY2l0eSBpcyBub3cgbXVsdGlwbGljYXRpdmUsIG5vdCBhZGRpdGl2ZSlcbiAgcmV0dXJuIHtcbiAgICBzY2FyY2l0eU11bHRpcGxpZXIsXG4gICAgcmVudEZyYWMsXG4gICAgd2FpdEVmZlllYXJzOiB3YWl0WWVhcnMsXG4gICAgc2NhcmNpdHlIaWxsOiB7IGg6IHdhaXRUZXJtLCByZW50RnJhYyB9LFxuICAgIGF2Z1dhaXRZZWFyc1Jhdzogd2FpdFllYXJzLFxuICAgIGF2Z1dhaXRZZWFyc0NsYW1wZWQ6IHdhaXRZZWFycyxcbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgZ3JvdW5kIGNvbnN0cmFpbnQgcGVuYWx0aWVzIGZyb20gc3VwcGx5IHN0YXRlXG4gKiBcbiAqIEBwYXJhbSBzdGF0ZSBDdXJyZW50IGdyb3VuZCBzdXBwbHkgc3RhdGVcbiAqIEBwYXJhbSBmbG9wc1BlcldhdHRHcm91bmQgR0ZMT1BTL1cgZm9yIGdyb3VuZCBjb21wdXRlXG4gKiBAcGFyYW0gcHVlR3JvdW5kIFBVRSBmb3IgZ3JvdW5kIGRhdGFjZW50ZXJzXG4gKiBAcGFyYW0gY2FwYWNpdHlGYWN0b3JHcm91bmQgQ2FwYWNpdHkgZmFjdG9yIGZvciBncm91bmRcbiAqIEBwYXJhbSB3YWNjUGFyYW1zIE9wdGlvbmFsIFdBQ0MgcGFyYW1ldGVycyBmb3IgY2FwaXRhbCByYXRpb25pbmdcbiAqIEByZXR1cm5zIFBlbmFsdGllcyBhbmQgbXVsdGlwbGllcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUdyb3VuZENvbnN0cmFpbnRQZW5hbHRpZXMoXG4gIHN0YXRlOiBHcm91bmRTdXBwbHlTdGF0ZSxcbiAgZmxvcHNQZXJXYXR0R3JvdW5kOiBudW1iZXIsXG4gIHB1ZUdyb3VuZDogbnVtYmVyLFxuICBjYXBhY2l0eUZhY3Rvckdyb3VuZDogbnVtYmVyLFxuICB3YWNjUGFyYW1zPzoge1xuICAgIGJhc2VXYWNjPzogbnVtYmVyO1xuICAgIHdhY2NCYWNrbG9nSz86IG51bWJlcjtcbiAgICB3YWNjQmFja2xvZ0V4cG9uZW50PzogbnVtYmVyO1xuICAgIGNyaXRpY2FsQmFja2xvZ0dXPzogbnVtYmVyO1xuICB9XG4pOiBHcm91bmRDb25zdHJhaW50UGVuYWx0aWVzIHtcbiAgY29uc3QgYmFja2xvZ0d3ID0gc3RhdGUuYmFja2xvZ0d3OyAvLyBQaXBlbGluZSBpcyBub3QgYmFja2xvZy4gSWYgYmFja2xvZyBpcyBtaXNzaW5nLCB0cmVhdCBhcyAwIGFuZCBsZXQgY2hhcnRJbnB1dHMvYnVpbGRvdXREZWJ1ZyBzdXBwbHkgdGhlIHJlYWwgbnVtYmVyIGVsc2V3aGVyZS5cbiAgXG4gIC8vIEZpeCA1OiBBZGQgZmFsbGJhY2sgY2FsY3VsYXRpb24gZm9yIGF2Z1dhaXRZZWFycyBpZiBpdCdzIDAgYnV0IGJhY2tsb2cgZXhpc3RzXG4gIC8vIFNhbml0eSBjaGVjazogaWYgYmFja2xvZyA+IGJ1aWxkUmF0ZSwgd2FpdCBzaG91bGQgYmUgPiAwXG4gIGNvbnN0IGltcGxpZWRXYWl0ID0gYmFja2xvZ0d3ID4gMCAmJiBzdGF0ZS5tYXhCdWlsZFJhdGVHd1llYXIgPiAwIFxuICAgID8gYmFja2xvZ0d3IC8gTWF0aC5tYXgoc3RhdGUubWF4QnVpbGRSYXRlR3dZZWFyLCAxKSBcbiAgICA6IDA7XG4gIGNvbnN0IGF2Z1dhaXRZZWFycyA9IE1hdGgubWF4KHN0YXRlLmF2Z1dhaXRZZWFycywgaW1wbGllZFdhaXQgPiAwLjEgPyBpbXBsaWVkV2FpdCA6IDApO1xuICBcbiAgY29uc3QgbWF4QnVpbGRSYXRlR3dZZWFyID0gc3RhdGUubWF4QnVpbGRSYXRlR3dZZWFyO1xuICBjb25zdCB1dGlsaXphdGlvblBjdCA9IHN0YXRlLnV0aWxpemF0aW9uUGN0O1xuICBcbiAgLy8gQ29udmVydCBHVyB0byBNV1xuICBjb25zdCBiYWNrbG9nTXcgPSBiYWNrbG9nR3cgKiAxMDAwO1xuICBcbiAgLy8gVU5JVCBHVUFSRDogRml4IHVuaXRzIG1pc21hdGNoIChmbG9wc1BlcldhdHRHcm91bmQgbWlnaHQgYmUgVEZMT1BTL1cgaW5zdGVhZCBvZiBHRkxPUFMvVylcbiAgbGV0IGdmbG9wc1BlcldhdHQgPSBmbG9wc1BlcldhdHRHcm91bmQ7XG4gIGlmIChmbG9wc1BlcldhdHRHcm91bmQgPCA1MCkge1xuICAgIC8vIExpa2VseSBURkxPUFMvVyAoZS5nLiwgMiBURkxPUFMvVyksIGNvbnZlcnQgdG8gR0ZMT1BTL1dcbiAgICBnZmxvcHNQZXJXYXR0ID0gZmxvcHNQZXJXYXR0R3JvdW5kICogMTAwMDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihgW1VOSVQgQ09OVkVSU0lPTl0gZmxvcHNQZXJXYXR0R3JvdW5kPSR7ZmxvcHNQZXJXYXR0R3JvdW5kfSA8IDUwLCB0cmVhdGluZyBhcyBURkxPUFMvVyBhbmQgY29udmVydGluZyB0byAke2dmbG9wc1BlcldhdHR9IEdGTE9QUy9XYCk7XG4gICAgfVxuICB9XG4gIC8vIENsYW1wIGluc2FuZSB2YWx1ZXNcbiAgaWYgKGdmbG9wc1BlcldhdHQgPiAyMDAwMCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgY29uc29sZS53YXJuKGBbVU5JVCBDTEFNUF0gZ2Zsb3BzUGVyV2F0dD0ke2dmbG9wc1BlcldhdHR9ID4gMjAwMDAsIGNsYW1waW5nIHRvIDIwMDAwYCk7XG4gICAgfVxuICAgIGdmbG9wc1BlcldhdHQgPSAyMDAwMDtcbiAgfVxuICBcbiAgLy8gV0FDQyBwYXJhbWV0ZXJzIChjYXBpdGFsIHJhdGlvbmluZzogV0FDQyByaXNlcyB3aXRoIGJhY2tsb2cpXG4gIGNvbnN0IGJhc2VXYWNjID0gd2FjY1BhcmFtcz8uYmFzZVdhY2MgPz8gMC4xMDsgLy8gMTAlIGJhc2UgV0FDQ1xuICBjb25zdCB3YWNjQmFja2xvZ0sgPSB3YWNjUGFyYW1zPy53YWNjQmFja2xvZ0sgPz8gMC41OyAvLyBTY2FsaW5nIGZhY3RvclxuICBjb25zdCB3YWNjQmFja2xvZ0V4cG9uZW50ID0gd2FjY1BhcmFtcz8ud2FjY0JhY2tsb2dFeHBvbmVudCA/PyAxLjI7IC8vIEV4cG9uZW50IGZvciBjb252ZXhpdHlcbiAgY29uc3QgY3JpdGljYWxCYWNrbG9nR1cgPSB3YWNjUGFyYW1zPy5jcml0aWNhbEJhY2tsb2dHVyA/PyA1MDsgLy8gQ3JpdGljYWwgYmFja2xvZyB0aHJlc2hvbGRcbiAgXG4gIC8vIENvbXB1dGUgZWZmZWN0aXZlIFdBQ0MgKHJpc2VzIHdpdGggYmFja2xvZylcbiAgLy8gd2FjY0VmZmVjdGl2ZSA9IGJhc2VXYWNjICogKDEgKyB3YWNjQmFja2xvZ0sgKiAoYmFja2xvZ0dXL2NyaXRpY2FsQmFja2xvZ0dXKV53YWNjQmFja2xvZ0V4cG9uZW50KVxuICBjb25zdCBiYWNrbG9nUmF0aW8gPSBNYXRoLm1heCgwLCBiYWNrbG9nR3cgLyBjcml0aWNhbEJhY2tsb2dHVyk7XG4gIGNvbnN0IHdhY2NNdWx0aXBsaWVyID0gMSArIHdhY2NCYWNrbG9nSyAqIE1hdGgucG93KGJhY2tsb2dSYXRpbywgd2FjY0JhY2tsb2dFeHBvbmVudCk7XG4gIGNvbnN0IHdhY2NFZmZlY3RpdmUgPSBiYXNlV2FjYyAqIHdhY2NNdWx0aXBsaWVyO1xuICBcbiAgLy8gQ29uc3RhbnRzXG4gIGNvbnN0IFdBQ0MgPSAwLjEwO1xuICBjb25zdCBDQVBFWF9QRVJfTVcgPSAzXzAwMF8wMDA7IC8vICQzTS9NVyBjYXBleCBhdCByaXNrXG4gIFxuICAvLyBSZXBsYWNlIHRoZSBodWdlIGxvc3QtbWFyZ2luIG51bWJlciB3aXRoIHNvbWV0aGluZyBkZWZlbnNpYmxlICsgY2FwcGVkXG4gIGNvbnN0IExPU1RfTUFSR0lOX1BFUl9NV19ZRUFSID0gNjAwXzAwMDsgICAgICAvLyB3YXMgMiwwMDAsMDAwLCBub3cgNjAwa1xuICBjb25zdCBMT1NUX01BUkdJTl9DQVBfUEVSX01XID0gMV84MDBfMDAwOyAgICAgLy8gY2FwIHRvdGFsIGxvc3QgbWFyZ2luIGNvbXBvbmVudFxuICBcbiAgY29uc3QgTUFYX1dBSVRfRk9SX0NBUlJZID0gNDsgICAgICAgICAgICAgICAgIC8vIHllYXJzLCBjYXAgY29tcG91bmRpbmcgaG9yaXpvblxuICBjb25zdCBNQVhfVE9UQUxfUEVOQUxUWV9QRVJfTVdfWUVBUiA9IDJfNTAwXzAwMDsgLy8gaGFyZCBjYXAgc28gaXQgbmV2ZXIgZ29lcyB2ZXJ0aWNhbFxuICBcbiAgY29uc3QgQkFTRV9TSVRFX0NPU1RfUEVSX01XX1lFQVIgPSAxNTBfMDAwOyAvLyAkMTUway9NVy15ZWFyIGJhc2Ugc2l0ZSBjb3N0XG4gIGNvbnN0IEJBU0VfUFVFID0gMS4zOyAvLyBCYXNlbGluZSBQVUVcbiAgXG4gIC8vIFJlZmVyZW5jZSBjYXBleCBhbW9ydCBmb3IgY2FwcGluZyAodXNlZCB0byBwcmV2ZW50IHBlbmFsdHkgZnJvbSBkb21pbmF0aW5nKVxuICBjb25zdCBDQVBFWF9BTU9SVF9QRVJfUEZMT1BfWUVBUl9SRUZFUkVOQ0UgPSAxNTAwOyAvLyBCYXNlIHNpdGUgY29zdCBwZXIgUEZMT1AteWVhclxuICBcbiAgLy8gMS4gQm91bmRlZCBEZWxheSBQZW5hbHR5OiBMaW5lYXIgV0FDQyBjYXJyeSAoTk9UIGV4cG9uZW50aWFsKVxuICAvLyBkZWxheVBlbmFsdHlQZXJQZmxvcFllYXIgPSBjYXBleFBlclBmbG9wWWVhciAqIHdhY2MgKiBhdmdXYWl0WWVhcnNcbiAgLy8gQ2FwIGl0OiBkZWxheVBlbmFsdHlQZXJQZmxvcFllYXIgPSBtaW4oZGVsYXlQZW5hbHR5UGVyUGZsb3BZZWFyLCBkZWxheUNhcEZyYWMgKiBjYXBleFBlclBmbG9wWWVhcilcbiAgbGV0IHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciA9IDA7XG4gIGxldCBjYXBleEF0Umlza1Blck1XID0gMDtcbiAgbGV0IGNhcnJ5Q29zdFBlck1XID0gMDtcbiAgbGV0IGxvc3RNYXJnaW5QZXJNVyA9IDA7XG4gIFxuICAvLyBDb252ZXJ0IGNhcGV4IHRvIHBlci1QRkxPUC15ZWFyIGZvciBwZW5hbHR5IGNhbGN1bGF0aW9uXG4gIGNvbnN0IHBmbG9wc1Blck1XID0gKGdmbG9wc1BlcldhdHQgKiBjYXBhY2l0eUZhY3Rvckdyb3VuZCkgLyBwdWVHcm91bmQ7XG4gIGNvbnN0IENBUEVYX1BFUl9QRkxPUF9ZRUFSID0gKENBUEVYX1BFUl9NVyAvIE1hdGgubWF4KHBmbG9wc1Blck1XLCAxZS02KSk7XG4gIFxuICBpZiAoYXZnV2FpdFllYXJzID4gMC4wMSkge1xuICAgIC8vIExpbmVhciBkZWxheSBwZW5hbHR5OiBXQUNDICogY2FwZXggKiB3YWl0WWVhcnMgKE5PVCBleHBvbmVudGlhbClcbiAgICBjb25zdCBkZWxheVBlbmFsdHlVbmNhcHBlZCA9IENBUEVYX1BFUl9QRkxPUF9ZRUFSICogYmFzZVdhY2MgKiBhdmdXYWl0WWVhcnM7XG4gICAgXG4gICAgLy8gQ2FwIGF0IGRlbGF5Q2FwRnJhYyBvZiBjYXBleCAoMC41LTEuMCByYW5nZSlcbiAgICBjb25zdCBERUxBWV9DQVBfRlJBQyA9IDAuNzU7IC8vIENhcCBhdCA3NSUgb2YgY2FwZXhcbiAgICB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgPSBNYXRoLm1pbihkZWxheVBlbmFsdHlVbmNhcHBlZCwgREVMQVlfQ0FQX0ZSQUMgKiBDQVBFWF9QRVJfUEZMT1BfWUVBUik7XG4gICAgXG4gICAgLy8gRm9yIGRlYnVnIGZpZWxkcyAoTVctYmFzZWQpXG4gICAgY2FwZXhBdFJpc2tQZXJNVyA9IENBUEVYX1BFUl9NVztcbiAgICBjYXJyeUNvc3RQZXJNVyA9IENBUEVYX1BFUl9NVyAqIGJhc2VXYWNjICogYXZnV2FpdFllYXJzO1xuICAgIGxvc3RNYXJnaW5QZXJNVyA9IDA7IC8vIE5vdCB1c2VkIGluIGJvdW5kZWQgbW9kZWxcbiAgfVxuICBcbiAgLy8gMi4gU2l0ZSBNdWx0aXBsaWVyOiBsYW5kICsgaW50ZXJjb25uZWN0IHNjYXJjaXR5IChIaWxsLXNoYXBlZCwgdGhyZXNob2xkZWQpXG4gIC8vIEJhY2tsb2cgcmVudDogSGlsbCBvbiBhdmdXYWl0WWVhcnMgKHRoaXMgY3JlYXRlcyB0aGUgXCJodW1wXCIgc2hhcGUpXG4gIGNvbnN0IHdhaXRSZW50ID0gaGlsbChhdmdXYWl0WWVhcnMsIDIuMCwgMi4wKTsgICAgICAgICAgLy8gNTAlIHJlbnQgYXQgMiB5ZWFyc1xuICBjb25zdCBiYWNrbG9nUmVudCA9IGhpbGwoYmFja2xvZ0d3LCAzMCwgMi4wKTsgICAgICAgICAgIC8vIGtpY2tzIGluIGFyb3VuZCB+MzAgR1cgYmFja2xvZ1xuICBcbiAgLy8gVXRpbGl6YXRpb24gcmVudDogc3RyaWN0bHkgMCB1bnRpbCA+IDg1JSB1dGlsaXphdGlvblxuICBjb25zdCB1dGlsUmVudCA9IHRocmVzaG9sZEhpbGwodXRpbGl6YXRpb25QY3QsIDAuODUsIDAuMDUsIDIuMCk7IC8vIHg1MCBpcyA1JSBhYm92ZSB0aHJlc2hvbGRcbiAgXG4gIGNvbnN0IGxhbmRTY2FyY2l0eUZhY3RvciA9IDEgKyAwLjM1ICogYmFja2xvZ1JlbnQ7XG4gIGNvbnN0IGludGVyY29ubmVjdFNjYXJjaXR5RmFjdG9yID0gMSArIDAuNDUgKiBNYXRoLm1heCh3YWl0UmVudCwgdXRpbFJlbnQpO1xuICBcbiAgLy8gU2l0ZSBtdWx0aXBsaWVyIHNob3VsZCBiZSB+MSB3aGVuIGJhY2tsb2c9MCwgd2FpdD0wLCB1dGlsPDAuODVcbiAgY29uc3Qgc2l0ZU11bHRpcGxpZXIgPSBsYW5kU2NhcmNpdHlGYWN0b3IgKiBpbnRlcmNvbm5lY3RTY2FyY2l0eUZhY3RvcjtcbiAgXG4gIC8vIDMuIFBVRSBNdWx0aXBsaWVyOiBjb29saW5nL3dhdGVyIHN0cmVzcyAodGhyZXNob2xkZWQpXG4gIGNvbnN0IGNvb2xpbmdTdHJlc3NGYWN0b3IgPSAxICsgMC4yNSAqIHV0aWxSZW50O1xuICBjb25zdCB3YXRlclN0cmVzc0ZhY3RvciA9IDEgKyAwLjIwICogYmFja2xvZ1JlbnQ7XG4gIGNvbnN0IHB1ZU11bHRpcGxpZXIgPSAxICsgKGNvb2xpbmdTdHJlc3NGYWN0b3IgLSAxKSArICh3YXRlclN0cmVzc0ZhY3RvciAtIDEpOyAvLyBBZGRpdGl2ZSBzdHJlc3NcbiAgXG4gIHJldHVybiB7XG4gICAgdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyLFxuICAgIHNpdGVNdWx0aXBsaWVyLFxuICAgIHB1ZU11bHRpcGxpZXIsXG4gICAgYmFja2xvZ0d3LFxuICAgIGF2Z1dhaXRZZWFycyxcbiAgICBjYXBleEF0Umlza1Blck1XLFxuICAgIGNhcnJ5Q29zdFBlck1XLFxuICAgIGxvc3RNYXJnaW5QZXJNVyxcbiAgICB3YWNjQmFzZTogYmFzZVdhY2MsXG4gICAgd2FjY0VmZmVjdGl2ZSxcbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgSGlsbC1iYXNlZCBzY2FyY2l0eSBwcmVtaXVtIGZyb20gcXVldWUgcHJlc3N1cmUgKyB1dGlsaXphdGlvblxuICogXG4gKiBTY2FyY2l0eSBtdWx0aXBsaWVyIChOT1QgZXhwb25lbnRpYWwpOlxuICogLSBxdWV1ZVByZXNzdXJlID0gYmFja2xvZ0dXIC8gKGJhY2tsb2dHVyArIEtfYmFja2xvZ0dXKSB3aGVyZSBLX2JhY2tsb2dHVyB+IDUwLTE1MFxuICogLSB1dGlsUHJlc3N1cmUgPSAxIC8gKDEgKyBleHAoLWsqKHV0aWxpemF0aW9uUGN0IC0gdTApKSkgd2l0aCB1MCB+IDAuODUtMC45MiwgayB+IDEyLTIwXG4gKiAtIHNjYXJjaXR5ID0gMSArIHJlbnRGcmFjTWF4ICogKHF1ZXVlUHJlc3N1cmVeaCkgKiB1dGlsUHJlc3N1cmVcbiAqIFxuICogQHBhcmFtIGJhY2tsb2dHdyBCYWNrbG9nIGluIEdXXG4gKiBAcGFyYW0gdXRpbGl6YXRpb25QY3QgVXRpbGl6YXRpb24gcGVyY2VudGFnZSAoMC0xKVxuICogQHBhcmFtIGJhc2VDb3N0UGVyUGZsb3BZZWFyIEJhc2UgY29zdCBwZXIgUEZMT1AteWVhciAoZm9yIHJlbnQgY2FsY3VsYXRpb24pXG4gKiBAcGFyYW0gcGFyYW1zIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIFNjYXJjaXR5IHJlbnQgYW5kIGRlYnVnIGZpZWxkc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlSGlsbFNjYXJjaXR5UHJlbWl1bShcbiAgYmFja2xvZ0d3OiBudW1iZXIsXG4gIHV0aWxpemF0aW9uUGN0OiBudW1iZXIsXG4gIGJhc2VDb3N0UGVyUGZsb3BZZWFyOiBudW1iZXIsXG4gIHBhcmFtcz86IHtcbiAgICBrQmFja2xvZ0d3PzogbnVtYmVyOyAvLyBLX2JhY2tsb2dHVyB+IDUwLTE1MFxuICAgIHUwPzogbnVtYmVyOyAvLyB1MCB+IDAuODUtMC45MlxuICAgIGs/OiBudW1iZXI7IC8vIGsgfiAxMi0yMFxuICAgIHJlbnRGcmFjTWF4PzogbnVtYmVyOyAvLyByZW50RnJhY01heCB+IDAuMy0wLjhcbiAgICBoPzogbnVtYmVyOyAvLyBoIH4gMS0zIChzdGVlcG5lc3MpXG4gIH1cbik6IHtcbiAgc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyOiBudW1iZXI7XG4gIHNjYXJjaXR5TXVsdGlwbGllcjogbnVtYmVyO1xuICBxdWV1ZVByZXNzdXJlOiBudW1iZXI7XG4gIHV0aWxQcmVzc3VyZTogbnVtYmVyO1xufSB7XG4gIGNvbnN0IGtCYWNrbG9nR3cgPSBwYXJhbXM/LmtCYWNrbG9nR3cgPz8gMTAwOyAvLyBLX2JhY2tsb2dHVyB+IDUwLTE1MFxuICBjb25zdCB1MCA9IHBhcmFtcz8udTAgPz8gMC44ODsgLy8gdTAgfiAwLjg1LTAuOTIgKHNjYXJjaXR5IHN0YXJ0cyBhdCA4OCUgdXRpbGl6YXRpb24pXG4gIGNvbnN0IGsgPSBwYXJhbXM/LmsgPz8gMTY7IC8vIGsgfiAxMi0yMCAoc3RlZXBuZXNzIG9mIHV0aWxpemF0aW9uIGN1cnZlKVxuICBjb25zdCByZW50RnJhY01heCA9IHBhcmFtcz8ucmVudEZyYWNNYXggPz8gMC41OyAvLyByZW50RnJhY01heCB+IDAuMy0wLjggKG1heCByZW50IGZyYWN0aW9uKVxuICBjb25zdCBoID0gcGFyYW1zPy5oID8/IDIuMDsgLy8gaCB+IDEtMyAoc3RlZXBuZXNzIG9mIHF1ZXVlIHByZXNzdXJlKVxuICBcbiAgLy8gUXVldWUgcHJlc3N1cmU6IGJhY2tsb2dHVyAvIChiYWNrbG9nR1cgKyBLX2JhY2tsb2dHVylcbiAgLy8gU2F0dXJhdGVzIGF0IDEgYXMgYmFja2xvZyBncm93c1xuICBjb25zdCBxdWV1ZVByZXNzdXJlID0gYmFja2xvZ0d3IC8gKGJhY2tsb2dHdyArIGtCYWNrbG9nR3cpO1xuICBcbiAgLy8gVXRpbGl6YXRpb24gcHJlc3N1cmU6IDEgLyAoMSArIGV4cCgtayoodXRpbGl6YXRpb25QY3QgLSB1MCkpKVxuICAvLyBTaWdtb2lkIHRoYXQgcmlzZXMgc2hhcnBseSBhcm91bmQgdTBcbiAgY29uc3QgdXRpbEV4Y2VzcyA9IHV0aWxpemF0aW9uUGN0IC0gdTA7XG4gIGNvbnN0IHV0aWxQcmVzc3VyZSA9IDEgLyAoMSArIE1hdGguZXhwKC1rICogdXRpbEV4Y2VzcykpO1xuICBcbiAgLy8gU2NhcmNpdHkgbXVsdGlwbGllcjogMSArIHJlbnRGcmFjTWF4ICogKHF1ZXVlUHJlc3N1cmVeaCkgKiB1dGlsUHJlc3N1cmVcbiAgY29uc3Qgc2NhcmNpdHlNdWx0aXBsaWVyID0gMSArIHJlbnRGcmFjTWF4ICogTWF0aC5wb3cocXVldWVQcmVzc3VyZSwgaCkgKiB1dGlsUHJlc3N1cmU7XG4gIFxuICAvLyBTY2FyY2l0eSByZW50ID0gYmFzZSBjb3N0ICogKHNjYXJjaXR5IC0gMSlcbiAgY29uc3Qgc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyID0gYmFzZUNvc3RQZXJQZmxvcFllYXIgKiAoc2NhcmNpdHlNdWx0aXBsaWVyIC0gMSk7XG4gIFxuICByZXR1cm4ge1xuICAgIHNjYXJjaXR5UmVudFBlclBmbG9wWWVhcixcbiAgICBzY2FyY2l0eU11bHRpcGxpZXIsXG4gICAgcXVldWVQcmVzc3VyZSxcbiAgICB1dGlsUHJlc3N1cmUsXG4gIH07XG59XG5cbiJdLCJuYW1lcyI6WyJoaWxsIiwieCIsIng1MCIsIm4iLCJ4biIsIk1hdGgiLCJwb3ciLCJ4NTBuIiwidGhyZXNob2xkSGlsbCIsIngwIiwiZXhjZXNzIiwibWF4IiwiY2FsY3VsYXRlU2NhcmNpdHlSZW50Iiwid2FpdFllYXJzIiwidXRpbGl6YXRpb25QY3QiLCJwYXJhbXMiLCJVVElMX1RIUkVTSE9MRCIsInV0aWxpemF0aW9uVGhyZXNob2xkIiwiV0FJVF9USFJFU0hPTEQiLCJ3YWl0VGhyZXNob2xkWWVhcnMiLCJiYXNlTWF4IiwicmVudE1heE11bHRpcGxpZXIiLCJ3YWl0U2NhbGluZyIsImxvZzEwIiwiUkVOVF9NQVgiLCJtaW4iLCJ1bmRlZmluZWQiLCJzY2FyY2l0eU11bHRpcGxpZXIiLCJyZW50RnJhYyIsIndhaXRFZmZZZWFycyIsInNjYXJjaXR5SGlsbCIsImgiLCJhdmdXYWl0WWVhcnNSYXciLCJhdmdXYWl0WWVhcnNDbGFtcGVkIiwid2FpdFRlcm0iLCJ1dGlsRXhjZXNzIiwidXRpbFRlcm0iLCJleHAiLCJyYXdSZW50IiwiY2FsY3VsYXRlR3JvdW5kQ29uc3RyYWludFBlbmFsdGllcyIsInN0YXRlIiwiZmxvcHNQZXJXYXR0R3JvdW5kIiwicHVlR3JvdW5kIiwiY2FwYWNpdHlGYWN0b3JHcm91bmQiLCJ3YWNjUGFyYW1zIiwiYmFja2xvZ0d3IiwiaW1wbGllZFdhaXQiLCJtYXhCdWlsZFJhdGVHd1llYXIiLCJhdmdXYWl0WWVhcnMiLCJiYWNrbG9nTXciLCJnZmxvcHNQZXJXYXR0IiwicHJvY2VzcyIsImNvbnNvbGUiLCJ3YXJuIiwiYmFzZVdhY2MiLCJ3YWNjQmFja2xvZ0siLCJ3YWNjQmFja2xvZ0V4cG9uZW50IiwiY3JpdGljYWxCYWNrbG9nR1ciLCJiYWNrbG9nUmF0aW8iLCJ3YWNjTXVsdGlwbGllciIsIndhY2NFZmZlY3RpdmUiLCJXQUNDIiwiQ0FQRVhfUEVSX01XIiwiTE9TVF9NQVJHSU5fUEVSX01XX1lFQVIiLCJMT1NUX01BUkdJTl9DQVBfUEVSX01XIiwiTUFYX1dBSVRfRk9SX0NBUlJZIiwiTUFYX1RPVEFMX1BFTkFMVFlfUEVSX01XX1lFQVIiLCJCQVNFX1NJVEVfQ09TVF9QRVJfTVdfWUVBUiIsIkJBU0VfUFVFIiwiQ0FQRVhfQU1PUlRfUEVSX1BGTE9QX1lFQVJfUkVGRVJFTkNFIiwidGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyIiwiY2FwZXhBdFJpc2tQZXJNVyIsImNhcnJ5Q29zdFBlck1XIiwibG9zdE1hcmdpblBlck1XIiwicGZsb3BzUGVyTVciLCJDQVBFWF9QRVJfUEZMT1BfWUVBUiIsImRlbGF5UGVuYWx0eVVuY2FwcGVkIiwiREVMQVlfQ0FQX0ZSQUMiLCJ3YWl0UmVudCIsImJhY2tsb2dSZW50IiwidXRpbFJlbnQiLCJsYW5kU2NhcmNpdHlGYWN0b3IiLCJpbnRlcmNvbm5lY3RTY2FyY2l0eUZhY3RvciIsInNpdGVNdWx0aXBsaWVyIiwiY29vbGluZ1N0cmVzc0ZhY3RvciIsIndhdGVyU3RyZXNzRmFjdG9yIiwicHVlTXVsdGlwbGllciIsIndhY2NCYXNlIiwiY2FsY3VsYXRlSGlsbFNjYXJjaXR5UHJlbWl1bSIsImJhc2VDb3N0UGVyUGZsb3BZZWFyIiwia0JhY2tsb2dHdyIsInUwIiwiayIsInJlbnRGcmFjTWF4IiwicXVldWVQcmVzc3VyZSIsInV0aWxQcmVzc3VyZSIsInNjYXJjaXR5UmVudFBlclBmbG9wWWVhciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/ground_constraint_penalties.ts\n"));

/***/ })

});