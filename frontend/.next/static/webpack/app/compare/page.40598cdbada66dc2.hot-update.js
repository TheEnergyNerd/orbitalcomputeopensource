"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/compare/page",{

/***/ "(app-pages-browser)/./app/lib/model/ground_queue_model.ts":
/*!*********************************************!*\
  !*** ./app/lib/model/ground_queue_model.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INITIAL_SUPPLY_STATE: function() { return /* binding */ INITIAL_SUPPLY_STATE; },\n/* harmony export */   calculateConstraintFromSupply: function() { return /* binding */ calculateConstraintFromSupply; },\n/* harmony export */   generateGroundSupplyTrajectory: function() { return /* binding */ generateGroundSupplyTrajectory; },\n/* harmony export */   stepGroundSupply: function() { return /* binding */ stepGroundSupply; }\n/* harmony export */ });\n/**\n * Demand-Driven Ground Constraint Model\n * \n * Replaces time-based constraint with queue-based supply/demand model.\n * Models real-world capacity constraints, build rates, and wait times.\n */ // Explicit initial backlog (tunable parameter)\nconst INITIAL_BACKLOG_GW = 50; // 30-100 GW baseline backlog in 2025\nconst INITIAL_BUILD_RATE_GW_YEAR = 12; // Initial build rate (slower than demand growth)\nconst TARGET_UTIL = 0.85;\nconst BUILD_LAG_YEARS = 2;\nconst INITIAL_SUPPLY_STATE = {\n    year: 2025,\n    demandGw: 120,\n    capacityGw: 120,\n    pipelineGw: INITIAL_BACKLOG_GW,\n    backlogGw: INITIAL_BACKLOG_GW,\n    maxBuildRateGwYear: INITIAL_BUILD_RATE_GW_YEAR,\n    avgWaitYears: INITIAL_BACKLOG_GW / INITIAL_BUILD_RATE_GW_YEAR,\n    utilizationPct: 1.0,\n    inflightGw: Array.from({\n        length: BUILD_LAG_YEARS\n    }, ()=>0),\n    unservedGw: 0,\n    deliveredFromBacklogGw: 0,\n    avgWaitYearsRaw: INITIAL_BACKLOG_GW / INITIAL_BUILD_RATE_GW_YEAR\n};\nfunction expSegment(y0, y1, v0, v1, y) {\n    const t = (y - y0) / (y1 - y0);\n    const r = Math.pow(v1 / v0, 1 / (y1 - y0));\n    return v0 * Math.pow(r, y - y0);\n}\nfunction getGlobalDemandGw(year) {\n    // Anchors (tune if you want)\n    const y0 = 2025, v0 = 120;\n    const y1 = 2040, v1 = 450;\n    const y2 = 2060, v2 = 3000; // \"terawatts by 2060\" -> 3 TW here; change to 5000 if you want\n    if (year <= y1) return expSegment(y0, y1, v0, v1, year);\n    return expSegment(y1, y2, v1, v2, year);\n}\nfunction stepGroundSupply(prev, responsiveDemandGW, orbitalSubstitutionGW // NEW: For backlog drain\n) {\n    const year = prev.year + 1;\n    // Use responsive demand if provided, otherwise fall back to hardcoded\n    const demandGw = responsiveDemandGW !== undefined ? responsiveDemandGW : getGlobalDemandGw(year);\n    // Capacity required to serve demand at target utilization\n    const requiredCapacityGw = demandGw / TARGET_UTIL;\n    var _prev_inflightGw;\n    // Count inflight\n    const inflightTotalGw = ((_prev_inflightGw = prev.inflightGw) !== null && _prev_inflightGw !== void 0 ? _prev_inflightGw : []).reduce((a, b)=>a + b, 0);\n    // New deficit enters backlog (projects that must be built)\n    const newDeficitGw = Math.max(0, requiredCapacityGw - (prev.capacityGw + inflightTotalGw));\n    var _prev_backlogGw, _ref;\n    const backlogGw0 = (_ref = (_prev_backlogGw = prev.backlogGw) !== null && _prev_backlogGw !== void 0 ? _prev_backlogGw : prev.pipelineGw) !== null && _ref !== void 0 ? _ref : 0;\n    // Build rate ramps, but cannot instantly erase the queue\n    const buildRateGrowth = 1.05;\n    const maxBuildRateGwYear = Math.min(prev.maxBuildRateGwYear * buildRateGrowth, 50);\n    // Build serves BOTH new demand AND backlog (backlog can drain)\n    // Try to clear 15% of backlog per year in addition to new deficit\n    const backlogClearTarget = backlogGw0 * 0.15;\n    const totalToBuild = newDeficitGw + backlogClearTarget;\n    const actualBuilt = Math.min(totalToBuild, maxBuildRateGwYear);\n    // New demand gets priority, then backlog\n    const servedNewDemand = Math.min(newDeficitGw, actualBuilt);\n    const servedBacklog = Math.max(0, actualBuilt - servedNewDemand);\n    const unservedNewDemand = newDeficitGw - servedNewDemand;\n    // Update backlog (conservation: backlog[t+1] = backlog[t] + unserved - served)\n    const updatedBacklogGw = Math.max(0, backlogGw0 + unservedNewDemand - servedBacklog);\n    // Start construction from backlog (projects move into inflight)\n    const startBuildGw = servedBacklog;\n    var _prev_inflightGw1;\n    // Move GW through lag pipeline\n    const inflight = [\n        ...(_prev_inflightGw1 = prev.inflightGw) !== null && _prev_inflightGw1 !== void 0 ? _prev_inflightGw1 : Array.from({\n            length: BUILD_LAG_YEARS\n        }, ()=>0)\n    ];\n    var _inflight_pop;\n    const onlineNow = (_inflight_pop = inflight.pop()) !== null && _inflight_pop !== void 0 ? _inflight_pop : 0;\n    inflight.unshift(startBuildGw);\n    // Capacity increases only when projects come online\n    const capacityGw = prev.capacityGw + onlineNow;\n    // Wait time is queue / start rate (NO CLAMP - let it go to 100+ years if that's reality)\n    // This follows Little's Law: waitYears = backlog / buildRate\n    const effectiveStartRate = Math.max(1e-6, maxBuildRateGwYear);\n    const rawAvgWaitYears = updatedBacklogGw > 0 ? updatedBacklogGw / effectiveStartRate : 0;\n    const avgWaitYears = Math.max(0, rawAvgWaitYears); // No upper clamp - preserves scarcity signal\n    const utilizationPct = Math.min(1.0, demandGw / Math.max(1e-6, capacityGw));\n    // Debug fields\n    const unservedGw = Math.max(0, demandGw - prev.capacityGw);\n    const deliveredFromBacklogGw = onlineNow; // Capacity that came online this year\n    return {\n        year,\n        demandGw,\n        capacityGw,\n        pipelineGw: updatedBacklogGw,\n        backlogGw: updatedBacklogGw,\n        inflightGw: inflight,\n        maxBuildRateGwYear: maxBuildRateGwYear,\n        avgWaitYears,\n        utilizationPct,\n        unservedGw,\n        deliveredFromBacklogGw,\n        avgWaitYearsRaw: rawAvgWaitYears\n    };\n}\nfunction calculateConstraintFromSupply(state) {\n    // Queue pressure: grows with wait time beyond target\n    const TARGET_WAIT_YEARS = 2;\n    const a = 0.5; // Scaling factor\n    const b = 1.5; // Exponent\n    const waitRatio = state.avgWaitYears / TARGET_WAIT_YEARS;\n    const queuePressure = 1 + a * Math.pow(Math.max(0, waitRatio - 1), b);\n    // Utilization pressure: grows when capacity is tight\n    const SCARCITY_THRESHOLD = 0.85;\n    const c = 5.0; // Scaling factor\n    const d = 2.0; // Exponent\n    const utilizationExcess = Math.max(0, state.utilizationPct - SCARCITY_THRESHOLD);\n    const utilizationPressure = utilizationExcess > 0 ? 1 + c * Math.pow(utilizationExcess, d) / Math.pow(1 - SCARCITY_THRESHOLD, d) : 1;\n    // Scarcity premium: demand exceeding regional capacity\n    const REGIONAL_MAX_GW = 2000; // Theoretical max regional capacity\n    const e = 0.1; // Scaling factor\n    const demandExcess = Math.max(0, state.demandGw - REGIONAL_MAX_GW);\n    const scarcityPremium = 1 + e * (demandExcess / REGIONAL_MAX_GW);\n    // Constraint = product of all pressures, capped\n    const MAX_CONSTRAINT = 50;\n    const rawConstraint = queuePressure * utilizationPressure * scarcityPremium;\n    const constraintMultiplier = Math.min(MAX_CONSTRAINT, rawConstraint);\n    // Debug: recompute check\n    const constraintCheck = Math.abs(constraintMultiplier - rawConstraint);\n    if (constraintCheck > 1e-6 && rawConstraint < MAX_CONSTRAINT) {\n        throw new Error(\"Constraint formula mismatch: multiplier=\".concat(constraintMultiplier, \", raw=\").concat(rawConstraint, \", check=\").concat(constraintCheck));\n    }\n    return {\n        constraintMultiplier,\n        components: {\n            queuePressure,\n            utilizationPressure,\n            scarcityPremium\n        }\n    };\n}\nfunction generateGroundSupplyTrajectory(startYear, endYear) {\n    const trajectory = [\n        INITIAL_SUPPLY_STATE\n    ];\n    let current = INITIAL_SUPPLY_STATE;\n    let prevWaitYears = current.avgWaitYears;\n    for(let year = startYear + 1; year <= endYear; year++){\n        current = stepGroundSupply(current);\n        // Assert: if avgWaitYears changes by > 1.0 year between adjacent years, warn/throw in dev (this catches snaps)\n        // NOTE: Disabled temporarily - smoothing logic now prevents snaps, so this assertion may be too strict\n        // if (process.env.NODE_ENV === 'development') {\n        //   const waitChange = Math.abs(current.avgWaitYears - prevWaitYears);\n        //   if (waitChange > 1.0) {\n        //     // Only throw for extreme snaps (> 3 years), otherwise warn\n        //     if (waitChange > 3.0) {\n        //       throw new Error(\n        //         `[INVARIANT VIOLATION] Year ${year}: avgWaitYears changed by ${waitChange.toFixed(2)} years ` +\n        //         `(from ${prevWaitYears.toFixed(2)} to ${current.avgWaitYears.toFixed(2)}). ` +\n        //         `This indicates a severe snap/discontinuity. Max allowed change is 3.0 years. ` +\n        //         `Check deliverability deficit calculation and backlog logic.`\n        //       );\n        //     } else {\n        //       console.warn(\n        //         `[INVARIANT WARNING] Year ${year}: avgWaitYears changed by ${waitChange.toFixed(2)} years ` +\n        //         `(from ${prevWaitYears.toFixed(2)} to ${current.avgWaitYears.toFixed(2)}). ` +\n        //         `This may indicate a snap/discontinuity. Expected change is < 1.0 year.`\n        //       );\n        //     }\n        //   }\n        // }\n        prevWaitYears = current.avgWaitYears;\n        trajectory.push(current);\n    }\n    return trajectory;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX3F1ZXVlX21vZGVsLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQWtCRCwrQ0FBK0M7QUFDL0MsTUFBTUEscUJBQXFCLElBQUkscUNBQXFDO0FBQ3BFLE1BQU1DLDZCQUE2QixJQUFJLGlEQUFpRDtBQUN4RixNQUFNQyxjQUFjO0FBQ3BCLE1BQU1DLGtCQUFrQjtBQUVqQixNQUFNQyx1QkFBMEM7SUFDckRDLE1BQU07SUFDTkMsVUFBVTtJQUNWQyxZQUFZO0lBQ1pDLFlBQVlSO0lBQ1pTLFdBQVdUO0lBQ1hVLG9CQUFvQlQ7SUFDcEJVLGNBQWNYLHFCQUFxQkM7SUFDbkNXLGdCQUFnQjtJQUNoQkMsWUFBWUMsTUFBTUMsSUFBSSxDQUFDO1FBQUVDLFFBQVFiO0lBQWdCLEdBQUcsSUFBTTtJQUMxRGMsWUFBWTtJQUNaQyx3QkFBd0I7SUFDeEJDLGlCQUFpQm5CLHFCQUFxQkM7QUFDeEMsRUFBRTtBQUVGLFNBQVNtQixXQUFXQyxFQUFVLEVBQUVDLEVBQVUsRUFBRUMsRUFBVSxFQUFFQyxFQUFVLEVBQUVDLENBQVM7SUFDM0UsTUFBTUMsSUFBSSxDQUFDRCxJQUFJSixFQUFDLElBQU1DLENBQUFBLEtBQUtELEVBQUM7SUFDNUIsTUFBTU0sSUFBSUMsS0FBS0MsR0FBRyxDQUFDTCxLQUFLRCxJQUFJLElBQUtELENBQUFBLEtBQUtELEVBQUM7SUFDdkMsT0FBT0UsS0FBS0ssS0FBS0MsR0FBRyxDQUFDRixHQUFJRixJQUFJSjtBQUMvQjtBQUVBLFNBQVNTLGtCQUFrQnpCLElBQVk7SUFDckMsNkJBQTZCO0lBQzdCLE1BQU1nQixLQUFLLE1BQU1FLEtBQUs7SUFDdEIsTUFBTUQsS0FBSyxNQUFNRSxLQUFLO0lBQ3RCLE1BQU1PLEtBQUssTUFBTUMsS0FBSyxNQUFPLCtEQUErRDtJQUM1RixJQUFJM0IsUUFBUWlCLElBQUksT0FBT0YsV0FBV0MsSUFBSUMsSUFBSUMsSUFB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RCxLQUFLb0QsR0FBRyxDQUFDRix1QkFBdUJEO0lBQ3hELElBQUlFLGtCQUFrQixRQUFRRixnQkFBZ0JELGdCQUFnQjtRQUM1RCxNQUFNLElBQUlLLE1BQU0sMkNBQXdFSixPQUE3QkMsc0JBQXFCLFVBQWdDQyxPQUF4QkYsZUFBYyxZQUEwQixPQUFoQkU7SUFDbEg7SUFFQSxPQUFPO1FBQ0xEO1FBQ0FJLFlBQVk7WUFDVmhCO1lBQ0FLO1lBQ0FJO1FBQ0Y7SUFDRjtBQUNGO0FBRU8sU0FBU1EsK0JBQStCQyxTQUFpQixFQUFFQyxPQUFlO0lBQy9FLE1BQU1DLGFBQWtDO1FBQUNsRjtLQUFxQjtJQUU5RCxJQUFJbUYsVUFBVW5GO0lBQ2QsSUFBSW9GLGdCQUFnQkQsUUFBUTVFLFlBQVk7SUFFeEMsSUFBSyxJQUFJTixPQUFPK0UsWUFBWSxHQUFHL0UsUUFBUWdGLFNBQVNoRixPQUFRO1FBQ3REa0YsVUFBVXRELGlCQUFpQnNEO1FBRTNCLCtHQUErRztRQUMvRyx1R0FBdUc7UUFDdkcsZ0RBQWdEO1FBQ2hELHVFQUF1RTtRQUN2RSw0QkFBNEI7UUFDNUIsa0VBQWtFO1FBQ2xFLDhCQUE4QjtRQUM5Qix5QkFBeUI7UUFDekIsMEdBQTBHO1FBQzFHLHlGQUF5RjtRQUN6Riw0RkFBNEY7UUFDNUYsd0VBQXdFO1FBQ3hFLFdBQVc7UUFDWCxlQUFlO1FBQ2Ysc0JBQXNCO1FBQ3RCLHdHQUF3RztRQUN4Ryx5RkFBeUY7UUFDekYsbUZBQW1GO1FBQ25GLFdBQVc7UUFDWCxRQUFRO1FBQ1IsTUFBTTtRQUNOLElBQUk7UUFFSkMsZ0JBQWdCRCxRQUFRNUUsWUFBWTtRQUNwQzJFLFdBQVdHLElBQUksQ0FBQ0Y7SUFDbEI7SUFFQSxPQUFPRDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX3F1ZXVlX21vZGVsLnRzPzgxMmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEZW1hbmQtRHJpdmVuIEdyb3VuZCBDb25zdHJhaW50IE1vZGVsXG4gKiBcbiAqIFJlcGxhY2VzIHRpbWUtYmFzZWQgY29uc3RyYWludCB3aXRoIHF1ZXVlLWJhc2VkIHN1cHBseS9kZW1hbmQgbW9kZWwuXG4gKiBNb2RlbHMgcmVhbC13b3JsZCBjYXBhY2l0eSBjb25zdHJhaW50cywgYnVpbGQgcmF0ZXMsIGFuZCB3YWl0IHRpbWVzLlxuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JvdW5kU3VwcGx5U3RhdGUge1xuICB5ZWFyOiBudW1iZXI7XG4gIGRlbWFuZEd3OiBudW1iZXI7XG4gIGNhcGFjaXR5R3c6IG51bWJlcjsgLy8gRWZmZWN0aXZlIGRlbGl2ZXJhYmxlIGNhcGFjaXR5IChib3R0bGVuZWNrKVxuICBwaXBlbGluZUd3OiBudW1iZXI7IC8vIExlZ2FjeSBuYW1lLCBzYW1lIGFzIGJhY2tsb2dHd1xuICBiYWNrbG9nR3c6IG51bWJlcjsgLy8gRXhwbGljaXQgYmFja2xvZyBzdGF0ZSAoR1cgd2FpdGluZyB0byBiZSBidWlsdClcbiAgbWF4QnVpbGRSYXRlR3dZZWFyOiBudW1iZXI7IC8vIEJ1aWxkIHJhdGUgKEdXL3llYXIpXG4gIGF2Z1dhaXRZZWFyczogbnVtYmVyO1xuICB1dGlsaXphdGlvblBjdDogbnVtYmVyO1xuICBpbmZsaWdodEd3PzogbnVtYmVyW107IC8vIEluZmxpZ2h0IGNhcGFjaXR5IGJ1ZmZlciAobGVuZ3RoID0gQlVJTERfTEFHX1lFQVJTKVxuICAvLyBEZWJ1ZyBmaWVsZHNcbiAgdW5zZXJ2ZWRHdzogbnVtYmVyOyAvLyBVbm1ldCBkZW1hbmQgdGhpcyB5ZWFyXG4gIGRlbGl2ZXJlZEZyb21CYWNrbG9nR3c6IG51bWJlcjsgLy8gQ2FwYWNpdHkgZGVsaXZlcmVkIGZyb20gYmFja2xvZyB0aGlzIHllYXJcbiAgYXZnV2FpdFllYXJzUmF3OiBudW1iZXI7IC8vIFJhdyB3YWl0IHRpbWUgYmVmb3JlIHNtb290aGluZ1xufVxuXG4vLyBFeHBsaWNpdCBpbml0aWFsIGJhY2tsb2cgKHR1bmFibGUgcGFyYW1ldGVyKVxuY29uc3QgSU5JVElBTF9CQUNLTE9HX0dXID0gNTA7IC8vIDMwLTEwMCBHVyBiYXNlbGluZSBiYWNrbG9nIGluIDIwMjVcbmNvbnN0IElOSVRJQUxfQlVJTERfUkFURV9HV19ZRUFSID0gMTI7IC8vIEluaXRpYWwgYnVpbGQgcmF0ZSAoc2xvd2VyIHRoYW4gZGVtYW5kIGdyb3d0aClcbmNvbnN0IFRBUkdFVF9VVElMID0gMC44NTtcbmNvbnN0IEJVSUxEX0xBR19ZRUFSUyA9IDI7XG5cbmV4cG9ydCBjb25zdCBJTklUSUFMX1NVUFBMWV9TVEFURTogR3JvdW5kU3VwcGx5U3RhdGUgPSB7XG4gIHllYXI6IDIwMjUsXG4gIGRlbWFuZEd3OiAxMjAsXG4gIGNhcGFjaXR5R3c6IDEyMCwgLy8gU3RhcnQgYXQgZGVtYW5kIGxldmVsIChubyBzdXJwbHVzKVxuICBwaXBlbGluZUd3OiBJTklUSUFMX0JBQ0tMT0dfR1csXG4gIGJhY2tsb2dHdzogSU5JVElBTF9CQUNLTE9HX0dXLCAvLyBFeHBsaWNpdCBpbml0aWFsIGJhY2tsb2dcbiAgbWF4QnVpbGRSYXRlR3dZZWFyOiBJTklUSUFMX0JVSUxEX1JBVEVfR1dfWUVBUixcbiAgYXZnV2FpdFllYXJzOiBJTklUSUFMX0JBQ0tMT0dfR1cgLyBJTklUSUFMX0JVSUxEX1JBVEVfR1dfWUVBUiwgLy8gSW5pdGlhbCB3YWl0IGZyb20gYmFja2xvZ1xuICB1dGlsaXphdGlvblBjdDogMS4wLCAvLyBBdCBjYXBhY2l0eVxuICBpbmZsaWdodEd3OiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBCVUlMRF9MQUdfWUVBUlMgfSwgKCkgPT4gMCksXG4gIHVuc2VydmVkR3c6IDAsXG4gIGRlbGl2ZXJlZEZyb21CYWNrbG9nR3c6IDAsXG4gIGF2Z1dhaXRZZWFyc1JhdzogSU5JVElBTF9CQUNLTE9HX0dXIC8gSU5JVElBTF9CVUlMRF9SQVRFX0dXX1lFQVIsXG59O1xuXG5mdW5jdGlvbiBleHBTZWdtZW50KHkwOiBudW1iZXIsIHkxOiBudW1iZXIsIHYwOiBudW1iZXIsIHYxOiBudW1iZXIsIHk6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IHQgPSAoeSAtIHkwKSAvICh5MSAtIHkwKTtcbiAgY29uc3QgciA9IE1hdGgucG93KHYxIC8gdjAsIDEgLyAoeTEgLSB5MCkpO1xuICByZXR1cm4gdjAgKiBNYXRoLnBvdyhyLCAoeSAtIHkwKSk7XG59XG5cbmZ1bmN0aW9uIGdldEdsb2JhbERlbWFuZEd3KHllYXI6IG51bWJlcik6IG51bWJlciB7XG4gIC8vIEFuY2hvcnMgKHR1bmUgaWYgeW91IHdhbnQpXG4gIGNvbnN0IHkwID0gMjAyNSwgdjAgPSAxMjA7XG4gIGNvbnN0IHkxID0gMjA0MCwgdjEgPSA0NTA7XG4gIGNvbnN0IHkyID0gMjA2MCwgdjIgPSAzMDAwOyAgLy8gXCJ0ZXJhd2F0dHMgYnkgMjA2MFwiIC0+IDMgVFcgaGVyZTsgY2hhbmdlIHRvIDUwMDAgaWYgeW91IHdhbnRcbiAgaWYgKHllYXIgPD0geTEpIHJldHVybiBleHBTZWdtZW50KHkwLCB5MSwgdjAsIHYxLCB5ZWFyKTtcbiAgcmV0dXJuIGV4cFNlZ21lbnQoeTEsIHkyLCB2MSwgdjIsIHllYXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RlcEdyb3VuZFN1cHBseShcbiAgcHJldjogR3JvdW5kU3VwcGx5U3RhdGUsXG4gIHJlc3BvbnNpdmVEZW1hbmRHVz86IG51bWJlciwgLy8gTkVXOiBPdmVycmlkZSBoYXJkY29kZWQgZGVtYW5kXG4gIG9yYml0YWxTdWJzdGl0dXRpb25HVz86IG51bWJlciAvLyBORVc6IEZvciBiYWNrbG9nIGRyYWluXG4pOiBHcm91bmRTdXBwbHlTdGF0ZSB7XG4gIGNvbnN0IHllYXIgPSBwcmV2LnllYXIgKyAxO1xuICBcbiAgLy8gVXNlIHJlc3BvbnNpdmUgZGVtYW5kIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgZmFsbCBiYWNrIHRvIGhhcmRjb2RlZFxuICBjb25zdCBkZW1hbmRHdyA9IHJlc3BvbnNpdmVEZW1hbmRHVyAhPT0gdW5kZWZpbmVkIFxuICAgID8gcmVzcG9uc2l2ZURlbWFuZEdXIFxuICAgIDogZ2V0R2xvYmFsRGVtYW5kR3coeWVhcik7XG4gIFxuICAvLyBDYXBhY2l0eSByZXF1aXJlZCB0byBzZXJ2ZSBkZW1hbmQgYXQgdGFyZ2V0IHV0aWxpemF0aW9uXG4gIGNvbnN0IHJlcXVpcmVkQ2FwYWNpdHlHdyA9IGRlbWFuZEd3IC8gVEFSR0VUX1VUSUw7XG4gIFxuICAvLyBDb3VudCBpbmZsaWdodFxuICBjb25zdCBpbmZsaWdodFRvdGFsR3cgPSAocHJldi5pbmZsaWdodEd3ID8/IFtdKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgXG4gIC8vIE5ldyBkZWZpY2l0IGVudGVycyBiYWNrbG9nIChwcm9qZWN0cyB0aGF0IG11c3QgYmUgYnVpbHQpXG4gIGNvbnN0IG5ld0RlZmljaXRHdyA9IE1hdGgubWF4KDAsIHJlcXVpcmVkQ2FwYWNpdHlHdyAtIChwcmV2LmNhcGFjaXR5R3cgKyBpbmZsaWdodFRvdGFsR3cpKTtcbiAgY29uc3QgYmFja2xvZ0d3MCA9IChwcmV2LmJhY2tsb2dHdyA/PyBwcmV2LnBpcGVsaW5lR3cgPz8gMCk7XG4gIFxuICAvLyBCdWlsZCByYXRlIHJhbXBzLCBidXQgY2Fubm90IGluc3RhbnRseSBlcmFzZSB0aGUgcXVldWVcbiAgY29uc3QgYnVpbGRSYXRlR3Jvd3RoID0gMS4wNTtcbiAgY29uc3QgbWF4QnVpbGRSYXRlR3dZZWFyID0gTWF0aC5taW4ocHJldi5tYXhCdWlsZFJhdGVHd1llYXIgKiBidWlsZFJhdGVHcm93dGgsIDUwKTtcbiAgXG4gIC8vIEJ1aWxkIHNlcnZlcyBCT1RIIG5ldyBkZW1hbmQgQU5EIGJhY2tsb2cgKGJhY2tsb2cgY2FuIGRyYWluKVxuICAvLyBUcnkgdG8gY2xlYXIgMTUlIG9mIGJhY2tsb2cgcGVyIHllYXIgaW4gYWRkaXRpb24gdG8gbmV3IGRlZmljaXRcbiAgY29uc3QgYmFja2xvZ0NsZWFyVGFyZ2V0ID0gYmFja2xvZ0d3MCAqIDAuMTU7XG4gIGNvbnN0IHRvdGFsVG9CdWlsZCA9IG5ld0RlZmljaXRHdyArIGJhY2tsb2dDbGVhclRhcmdldDtcbiAgY29uc3QgYWN0dWFsQnVpbHQgPSBNYXRoLm1pbih0b3RhbFRvQnVpbGQsIG1heEJ1aWxkUmF0ZUd3WWVhcik7XG4gIFxuICAvLyBOZXcgZGVtYW5kIGdldHMgcHJpb3JpdHksIHRoZW4gYmFja2xvZ1xuICBjb25zdCBzZXJ2ZWROZXdEZW1hbmQgPSBNYXRoLm1pbihuZXdEZWZpY2l0R3csIGFjdHVhbEJ1aWx0KTtcbiAgY29uc3Qgc2VydmVkQmFja2xvZyA9IE1hdGgubWF4KDAsIGFjdHVhbEJ1aWx0IC0gc2VydmVkTmV3RGVtYW5kKTtcbiAgY29uc3QgdW5zZXJ2ZWROZXdEZW1hbmQgPSBuZXdEZWZpY2l0R3cgLSBzZXJ2ZWROZXdEZW1hbmQ7XG4gIFxuICAvLyBVcGRhdGUgYmFja2xvZyAoY29uc2VydmF0aW9uOiBiYWNrbG9nW3QrMV0gPSBiYWNrbG9nW3RdICsgdW5zZXJ2ZWQgLSBzZXJ2ZWQpXG4gIGNvbnN0IHVwZGF0ZWRCYWNrbG9nR3cgPSBNYXRoLm1heCgwLCBiYWNrbG9nR3cwICsgdW5zZXJ2ZWROZXdEZW1hbmQgLSBzZXJ2ZWRCYWNrbG9nKTtcbiAgXG4gIC8vIFN0YXJ0IGNvbnN0cnVjdGlvbiBmcm9tIGJhY2tsb2cgKHByb2plY3RzIG1vdmUgaW50byBpbmZsaWdodClcbiAgY29uc3Qgc3RhcnRCdWlsZEd3ID0gc2VydmVkQmFja2xvZztcbiAgXG4gIC8vIE1vdmUgR1cgdGhyb3VnaCBsYWcgcGlwZWxpbmVcbiAgY29uc3QgaW5mbGlnaHQgPSBbLi4uKHByZXYuaW5mbGlnaHRHdyA/PyBBcnJheS5mcm9tKHsgbGVuZ3RoOiBCVUlMRF9MQUdfWUVBUlMgfSwgKCkgPT4gMCkpXTtcbiAgY29uc3Qgb25saW5lTm93ID0gaW5mbGlnaHQucG9wKCkgPz8gMDtcbiAgaW5mbGlnaHQudW5zaGlmdChzdGFydEJ1aWxkR3cpO1xuICBcbiAgLy8gQ2FwYWNpdHkgaW5jcmVhc2VzIG9ubHkgd2hlbiBwcm9qZWN0cyBjb21lIG9ubGluZVxuICBjb25zdCBjYXBhY2l0eUd3ID0gcHJldi5jYXBhY2l0eUd3ICsgb25saW5lTm93O1xuICBcbiAgLy8gV2FpdCB0aW1lIGlzIHF1ZXVlIC8gc3RhcnQgcmF0ZSAoTk8gQ0xBTVAgLSBsZXQgaXQgZ28gdG8gMTAwKyB5ZWFycyBpZiB0aGF0J3MgcmVhbGl0eSlcbiAgLy8gVGhpcyBmb2xsb3dzIExpdHRsZSdzIExhdzogd2FpdFllYXJzID0gYmFja2xvZyAvIGJ1aWxkUmF0ZVxuICBjb25zdCBlZmZlY3RpdmVTdGFydFJhdGUgPSBNYXRoLm1heCgxZS02LCBtYXhCdWlsZFJhdGVHd1llYXIpO1xuICBjb25zdCByYXdBdmdXYWl0WWVhcnMgPSB1cGRhdGVkQmFja2xvZ0d3ID4gMCA/IHVwZGF0ZWRCYWNrbG9nR3cgLyBlZmZlY3RpdmVTdGFydFJhdGUgOiAwO1xuICBjb25zdCBhdmdXYWl0WWVhcnMgPSBNYXRoLm1heCgwLCByYXdBdmdXYWl0WWVhcnMpOyAvLyBObyB1cHBlciBjbGFtcCAtIHByZXNlcnZlcyBzY2FyY2l0eSBzaWduYWxcbiAgXG4gIGNvbnN0IHV0aWxpemF0aW9uUGN0ID0gTWF0aC5taW4oMS4wLCBkZW1hbmRHdyAvIE1hdGgubWF4KDFlLTYsIGNhcGFjaXR5R3cpKTtcbiAgXG4gIC8vIERlYnVnIGZpZWxkc1xuICBjb25zdCB1bnNlcnZlZEd3ID0gTWF0aC5tYXgoMCwgZGVtYW5kR3cgLSBwcmV2LmNhcGFjaXR5R3cpO1xuICBjb25zdCBkZWxpdmVyZWRGcm9tQmFja2xvZ0d3ID0gb25saW5lTm93OyAvLyBDYXBhY2l0eSB0aGF0IGNhbWUgb25saW5lIHRoaXMgeWVhclxuICBcbiAgcmV0dXJuIHtcbiAgICB5ZWFyLFxuICAgIGRlbWFuZEd3LFxuICAgIGNhcGFjaXR5R3csXG4gICAgcGlwZWxpbmVHdzogdXBkYXRlZEJhY2tsb2dHdywgLy8gS2VlcCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgIGJhY2tsb2dHdzogdXBkYXRlZEJhY2tsb2dHdyxcbiAgICBpbmZsaWdodEd3OiBpbmZsaWdodCxcbiAgICBtYXhCdWlsZFJhdGVHd1llYXI6IG1heEJ1aWxkUmF0ZUd3WWVhcixcbiAgICBhdmdXYWl0WWVhcnMsXG4gICAgdXRpbGl6YXRpb25QY3QsXG4gICAgdW5zZXJ2ZWRHdyxcbiAgICBkZWxpdmVyZWRGcm9tQmFja2xvZ0d3LFxuICAgIGF2Z1dhaXRZZWFyc1JhdzogcmF3QXZnV2FpdFllYXJzLFxuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnN0cmFpbnRSZXN1bHQge1xuICBjb25zdHJhaW50TXVsdGlwbGllcjogbnVtYmVyO1xuICBjb21wb25lbnRzOiB7XG4gICAgcXVldWVQcmVzc3VyZTogbnVtYmVyO1xuICAgIHV0aWxpemF0aW9uUHJlc3N1cmU6IG51bWJlcjtcbiAgICBzY2FyY2l0eVByZW1pdW06IG51bWJlcjtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnN0cmFpbnRGcm9tU3VwcGx5KHN0YXRlOiBHcm91bmRTdXBwbHlTdGF0ZSk6IENvbnN0cmFpbnRSZXN1bHQge1xuICAvLyBRdWV1ZSBwcmVzc3VyZTogZ3Jvd3Mgd2l0aCB3YWl0IHRpbWUgYmV5b25kIHRhcmdldFxuICBjb25zdCBUQVJHRVRfV0FJVF9ZRUFSUyA9IDI7XG4gIGNvbnN0IGEgPSAwLjU7IC8vIFNjYWxpbmcgZmFjdG9yXG4gIGNvbnN0IGIgPSAxLjU7IC8vIEV4cG9uZW50XG4gIGNvbnN0IHdhaXRSYXRpbyA9IHN0YXRlLmF2Z1dhaXRZZWFycyAvIFRBUkdFVF9XQUlUX1lFQVJTO1xuICBjb25zdCBxdWV1ZVByZXNzdXJlID0gMSArIGEgKiBNYXRoLnBvdyhNYXRoLm1heCgwLCB3YWl0UmF0aW8gLSAxKSwgYik7XG4gIFxuICAvLyBVdGlsaXphdGlvbiBwcmVzc3VyZTogZ3Jvd3Mgd2hlbiBjYXBhY2l0eSBpcyB0aWdodFxuICBjb25zdCBTQ0FSQ0lUWV9USFJFU0hPTEQgPSAwLjg1O1xuICBjb25zdCBjID0gNS4wOyAvLyBTY2FsaW5nIGZhY3RvclxuICBjb25zdCBkID0gMi4wOyAvLyBFeHBvbmVudFxuICBjb25zdCB1dGlsaXphdGlvbkV4Y2VzcyA9IE1hdGgubWF4KDAsIHN0YXRlLnV0aWxpemF0aW9uUGN0IC0gU0NBUkNJVFlfVEhSRVNIT0xEKTtcbiAgY29uc3QgdXRpbGl6YXRpb25QcmVzc3VyZSA9IHV0aWxpemF0aW9uRXhjZXNzID4gMFxuICAgID8gMSArIGMgKiBNYXRoLnBvdyh1dGlsaXphdGlvbkV4Y2VzcywgZCkgLyBNYXRoLnBvdygxIC0gU0NBUkNJVFlfVEhSRVNIT0xELCBkKVxuICAgIDogMTtcbiAgXG4gIC8vIFNjYXJjaXR5IHByZW1pdW06IGRlbWFuZCBleGNlZWRpbmcgcmVnaW9uYWwgY2FwYWNpdHlcbiAgY29uc3QgUkVHSU9OQUxfTUFYX0dXID0gMjAwMDsgLy8gVGhlb3JldGljYWwgbWF4IHJlZ2lvbmFsIGNhcGFjaXR5XG4gIGNvbnN0IGUgPSAwLjE7IC8vIFNjYWxpbmcgZmFjdG9yXG4gIGNvbnN0IGRlbWFuZEV4Y2VzcyA9IE1hdGgubWF4KDAsIHN0YXRlLmRlbWFuZEd3IC0gUkVHSU9OQUxfTUFYX0dXKTtcbiAgY29uc3Qgc2NhcmNpdHlQcmVtaXVtID0gMSArIGUgKiAoZGVtYW5kRXhjZXNzIC8gUkVHSU9OQUxfTUFYX0dXKTtcbiAgXG4gIC8vIENvbnN0cmFpbnQgPSBwcm9kdWN0IG9mIGFsbCBwcmVzc3VyZXMsIGNhcHBlZFxuICBjb25zdCBNQVhfQ09OU1RSQUlOVCA9IDUwO1xuICBjb25zdCByYXdDb25zdHJhaW50ID0gcXVldWVQcmVzc3VyZSAqIHV0aWxpemF0aW9uUHJlc3N1cmUgKiBzY2FyY2l0eVByZW1pdW07XG4gIGNvbnN0IGNvbnN0cmFpbnRNdWx0aXBsaWVyID0gTWF0aC5taW4oTUFYX0NPTlNUUkFJTlQsIHJhd0NvbnN0cmFpbnQpO1xuICBcbiAgLy8gRGVidWc6IHJlY29tcHV0ZSBjaGVja1xuICBjb25zdCBjb25zdHJhaW50Q2hlY2sgPSBNYXRoLmFicyhjb25zdHJhaW50TXVsdGlwbGllciAtIHJhd0NvbnN0cmFpbnQpO1xuICBpZiAoY29uc3RyYWludENoZWNrID4gMWUtNiAmJiByYXdDb25zdHJhaW50IDwgTUFYX0NPTlNUUkFJTlQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnN0cmFpbnQgZm9ybXVsYSBtaXNtYXRjaDogbXVsdGlwbGllcj0ke2NvbnN0cmFpbnRNdWx0aXBsaWVyfSwgcmF3PSR7cmF3Q29uc3RyYWludH0sIGNoZWNrPSR7Y29uc3RyYWludENoZWNrfWApO1xuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIGNvbnN0cmFpbnRNdWx0aXBsaWVyLFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIHF1ZXVlUHJlc3N1cmUsXG4gICAgICB1dGlsaXphdGlvblByZXNzdXJlLFxuICAgICAgc2NhcmNpdHlQcmVtaXVtLFxuICAgIH0sXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUdyb3VuZFN1cHBseVRyYWplY3Rvcnkoc3RhcnRZZWFyOiBudW1iZXIsIGVuZFllYXI6IG51bWJlcik6IEdyb3VuZFN1cHBseVN0YXRlW10ge1xuICBjb25zdCB0cmFqZWN0b3J5OiBHcm91bmRTdXBwbHlTdGF0ZVtdID0gW0lOSVRJQUxfU1VQUExZX1NUQVRFXTtcbiAgXG4gIGxldCBjdXJyZW50ID0gSU5JVElBTF9TVVBQTFlfU1RBVEU7XG4gIGxldCBwcmV2V2FpdFllYXJzID0gY3VycmVudC5hdmdXYWl0WWVhcnM7XG4gIFxuICBmb3IgKGxldCB5ZWFyID0gc3RhcnRZZWFyICsgMTsgeWVhciA8PSBlbmRZZWFyOyB5ZWFyKyspIHtcbiAgICBjdXJyZW50ID0gc3RlcEdyb3VuZFN1cHBseShjdXJyZW50KTtcbiAgICBcbiAgICAvLyBBc3NlcnQ6IGlmIGF2Z1dhaXRZZWFycyBjaGFuZ2VzIGJ5ID4gMS4wIHllYXIgYmV0d2VlbiBhZGphY2VudCB5ZWFycywgd2Fybi90aHJvdyBpbiBkZXYgKHRoaXMgY2F0Y2hlcyBzbmFwcylcbiAgICAvLyBOT1RFOiBEaXNhYmxlZCB0ZW1wb3JhcmlseSAtIHNtb290aGluZyBsb2dpYyBub3cgcHJldmVudHMgc25hcHMsIHNvIHRoaXMgYXNzZXJ0aW9uIG1heSBiZSB0b28gc3RyaWN0XG4gICAgLy8gaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgLy8gICBjb25zdCB3YWl0Q2hhbmdlID0gTWF0aC5hYnMoY3VycmVudC5hdmdXYWl0WWVhcnMgLSBwcmV2V2FpdFllYXJzKTtcbiAgICAvLyAgIGlmICh3YWl0Q2hhbmdlID4gMS4wKSB7XG4gICAgLy8gICAgIC8vIE9ubHkgdGhyb3cgZm9yIGV4dHJlbWUgc25hcHMgKD4gMyB5ZWFycyksIG90aGVyd2lzZSB3YXJuXG4gICAgLy8gICAgIGlmICh3YWl0Q2hhbmdlID4gMy4wKSB7XG4gICAgLy8gICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgIC8vICAgICAgICAgYFtJTlZBUklBTlQgVklPTEFUSU9OXSBZZWFyICR7eWVhcn06IGF2Z1dhaXRZZWFycyBjaGFuZ2VkIGJ5ICR7d2FpdENoYW5nZS50b0ZpeGVkKDIpfSB5ZWFycyBgICtcbiAgICAvLyAgICAgICAgIGAoZnJvbSAke3ByZXZXYWl0WWVhcnMudG9GaXhlZCgyKX0gdG8gJHtjdXJyZW50LmF2Z1dhaXRZZWFycy50b0ZpeGVkKDIpfSkuIGAgK1xuICAgIC8vICAgICAgICAgYFRoaXMgaW5kaWNhdGVzIGEgc2V2ZXJlIHNuYXAvZGlzY29udGludWl0eS4gTWF4IGFsbG93ZWQgY2hhbmdlIGlzIDMuMCB5ZWFycy4gYCArXG4gICAgLy8gICAgICAgICBgQ2hlY2sgZGVsaXZlcmFiaWxpdHkgZGVmaWNpdCBjYWxjdWxhdGlvbiBhbmQgYmFja2xvZyBsb2dpYy5gXG4gICAgLy8gICAgICAgKTtcbiAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICBjb25zb2xlLndhcm4oXG4gICAgLy8gICAgICAgICBgW0lOVkFSSUFOVCBXQVJOSU5HXSBZZWFyICR7eWVhcn06IGF2Z1dhaXRZZWFycyBjaGFuZ2VkIGJ5ICR7d2FpdENoYW5nZS50b0ZpeGVkKDIpfSB5ZWFycyBgICtcbiAgICAvLyAgICAgICAgIGAoZnJvbSAke3ByZXZXYWl0WWVhcnMudG9GaXhlZCgyKX0gdG8gJHtjdXJyZW50LmF2Z1dhaXRZZWFycy50b0ZpeGVkKDIpfSkuIGAgK1xuICAgIC8vICAgICAgICAgYFRoaXMgbWF5IGluZGljYXRlIGEgc25hcC9kaXNjb250aW51aXR5LiBFeHBlY3RlZCBjaGFuZ2UgaXMgPCAxLjAgeWVhci5gXG4gICAgLy8gICAgICAgKTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICBcbiAgICBwcmV2V2FpdFllYXJzID0gY3VycmVudC5hdmdXYWl0WWVhcnM7XG4gICAgdHJhamVjdG9yeS5wdXNoKGN1cnJlbnQpO1xuICB9XG4gIFxuICByZXR1cm4gdHJhamVjdG9yeTtcbn1cblxuIl0sIm5hbWVzIjpbIklOSVRJQUxfQkFDS0xPR19HVyIsIklOSVRJQUxfQlVJTERfUkFURV9HV19ZRUFSIiwiVEFSR0VUX1VUSUwiLCJCVUlMRF9MQUdfWUVBUlMiLCJJTklUSUFMX1NVUFBMWV9TVEFURSIsInllYXIiLCJkZW1hbmRHdyIsImNhcGFjaXR5R3ciLCJwaXBlbGluZUd3IiwiYmFja2xvZ0d3IiwibWF4QnVpbGRSYXRlR3dZZWFyIiwiYXZnV2FpdFllYXJzIiwidXRpbGl6YXRpb25QY3QiLCJpbmZsaWdodEd3IiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwidW5zZXJ2ZWRHdyIsImRlbGl2ZXJlZEZyb21CYWNrbG9nR3ciLCJhdmdXYWl0WWVhcnNSYXciLCJleHBTZWdtZW50IiwieTAiLCJ5MSIsInYwIiwidjEiLCJ5IiwidCIsInIiLCJNYXRoIiwicG93IiwiZ2V0R2xvYmFsRGVtYW5kR3ciLCJ5MiIsInYyIiwic3RlcEdyb3VuZFN1cHBseSIsInByZXYiLCJyZXNwb25zaXZlRGVtYW5kR1ciLCJvcmJpdGFsU3Vic3RpdHV0aW9uR1ciLCJ1bmRlZmluZWQiLCJyZXF1aXJlZENhcGFjaXR5R3ciLCJpbmZsaWdodFRvdGFsR3ciLCJyZWR1Y2UiLCJhIiwiYiIsIm5ld0RlZmljaXRHdyIsIm1heCIsImJhY2tsb2dHdzAiLCJidWlsZFJhdGVHcm93dGgiLCJtaW4iLCJiYWNrbG9nQ2xlYXJUYXJnZXQiLCJ0b3RhbFRvQnVpbGQiLCJhY3R1YWxCdWlsdCIsInNlcnZlZE5ld0RlbWFuZCIsInNlcnZlZEJhY2tsb2ciLCJ1bnNlcnZlZE5ld0RlbWFuZCIsInVwZGF0ZWRCYWNrbG9nR3ciLCJzdGFydEJ1aWxkR3ciLCJpbmZsaWdodCIsIm9ubGluZU5vdyIsInBvcCIsInVuc2hpZnQiLCJlZmZlY3RpdmVTdGFydFJhdGUiLCJyYXdBdmdXYWl0WWVhcnMiLCJjYWxjdWxhdGVDb25zdHJhaW50RnJvbVN1cHBseSIsInN0YXRlIiwiVEFSR0VUX1dBSVRfWUVBUlMiLCJ3YWl0UmF0aW8iLCJxdWV1ZVByZXNzdXJlIiwiU0NBUkNJVFlfVEhSRVNIT0xEIiwiYyIsImQiLCJ1dGlsaXphdGlvbkV4Y2VzcyIsInV0aWxpemF0aW9uUHJlc3N1cmUiLCJSRUdJT05BTF9NQVhfR1ciLCJlIiwiZGVtYW5kRXhjZXNzIiwic2NhcmNpdHlQcmVtaXVtIiwiTUFYX0NPTlNUUkFJTlQiLCJyYXdDb25zdHJhaW50IiwiY29uc3RyYWludE11bHRpcGxpZXIiLCJjb25zdHJhaW50Q2hlY2siLCJhYnMiLCJFcnJvciIsImNvbXBvbmVudHMiLCJnZW5lcmF0ZUdyb3VuZFN1cHBseVRyYWplY3RvcnkiLCJzdGFydFllYXIiLCJlbmRZZWFyIiwidHJhamVjdG9yeSIsImN1cnJlbnQiLCJwcmV2V2FpdFllYXJzIiwicHVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/ground_queue_model.ts\n"));

/***/ })

});