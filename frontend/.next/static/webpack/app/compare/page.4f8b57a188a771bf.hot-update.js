"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/compare/page",{

/***/ "(app-pages-browser)/./app/lib/model/ground_ramping_mobilization.ts":
/*!******************************************************!*\
  !*** ./app/lib/model/ground_ramping_mobilization.ts ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_MOBILIZATION_PARAMS: function() { return /* binding */ DEFAULT_MOBILIZATION_PARAMS; },\n/* harmony export */   calculateBuildRateGWyr: function() { return /* binding */ calculateBuildRateGWyr; },\n/* harmony export */   calculateDemandGW: function() { return /* binding */ calculateDemandGW; },\n/* harmony export */   calculatePriceResponsiveDemandGW: function() { return /* binding */ calculatePriceResponsiveDemandGW; },\n/* harmony export */   stepMobilizationState: function() { return /* binding */ stepMobilizationState; }\n/* harmony export */ });\n/**\n * Ground Ramping Mobilization Model\n * \n * Models demand growth with price-responsive demand and buildout capacity\n * ramping with investment response. Tracks capacity evolution, pipeline, backlog,\n * and wait times.\n * \n * NEW: Price-responsive demand and investment-responsive buildout (replaces fixed anchors)\n */ /**\n * Calculate price-responsive demand GW\n * \n * NEW: Demand responds to prices, wait times, and orbital substitution\n * Replaces fixed anchors with economic feedback\n */ function calculatePriceResponsiveDemandGW(year, groundPricePerGpuHour, orbitalPricePerGpuHour, avgWaitYears, params) {\n    let pue = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1.3;\n    // Base demand with organic growth (tapered, not exponential forever)\n    const yearsFrom2025 = year - 2025;\n    const growthTaper = Math.tanh(yearsFrom2025 / 30); // Tapers after ~30 years\n    const baseDemand = params.baseDemand2025GW * Math.pow(1 + params.organicGrowthRate, yearsFrom2025 * growthTaper);\n    // Price elasticity: higher prices reduce demand\n    const baselinePrice = 3.50; // $/GPU-hr baseline\n    const priceRatio = groundPricePerGpuHour / baselinePrice;\n    const priceFactor = Math.pow(priceRatio, params.priceElasticity);\n    // Wait elasticity: longer waits reduce demand\n    const waitFactor = Math.exp(-avgWaitYears * params.waitElasticity / 5);\n    // Orbital substitution: if orbital cheaper, demand shifts\n    const orbitalAdvantage = groundPricePerGpuHour / Math.max(orbitalPricePerGpuHour, 0.01);\n    const substitutionFactor = orbitalAdvantage > params.orbitalSubstitutionThreshold ? 1 / (1 + 0.5 * (orbitalAdvantage - params.orbitalSubstitutionThreshold)) : 1.0;\n    let demandGW = baseDemand * priceFactor * waitFactor * substitutionFactor;\n    // Apply PUE if demand is IT load (not facility load)\n    // Note: This function assumes facility load, so multiply by PUE if needed\n    // For now, return facility load (demand already includes PUE in baseDemand2025GW)\n    return Math.max(0, demandGW);\n}\n/**\n * Legacy function: Calculate demand GW using piecewise exponential to hit anchors\n * \n * DEPRECATED: Use calculatePriceResponsiveDemandGW instead\n * Kept for backward compatibility\n */ function calculateDemandGW(year, params) {\n    let pue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1.3;\n    const { demandAnchorsGW, demandIsFacilityLoad, demandCurve } = params;\n    const demand2025 = demandAnchorsGW[2025];\n    const demand2040 = demandAnchorsGW[2040];\n    const demand2060 = demandAnchorsGW[2060];\n    if (demandCurve !== \"piecewise_exponential\") {\n        throw new Error(\"Unsupported demandCurve: \".concat(demandCurve, \". Only 'piecewise_exponential' is supported.\"));\n    }\n    if (year < 2025) {\n        return demand2025;\n    }\n    let demandGW;\n    if (year <= 2040) {\n        // Phase 1: 2025-2040\n        // r1 = ln(demand2040 / demand2025) / (2040-2025)\n        const r1 = Math.log(demand2040 / demand2025) / (2040 - 2025);\n        const yearsFrom2025 = year - 2025;\n        demandGW = demand2025 * Math.exp(r1 * yearsFrom2025);\n    } else {\n        // Phase 2: 2040-2060\n        // r2 = ln(demand2060 / demand2040) / (2060-2040)\n        const r2 = Math.log(demand2060 / demand2040) / (2060 - 2040);\n        const yearsFrom2040 = year - 2040;\n        demandGW = demand2040 * Math.exp(r2 * yearsFrom2040);\n    }\n    // Apply PUE if demand is IT load (not facility load)\n    if (!demandIsFacilityLoad) {\n        demandGW = demandGW * pue;\n    }\n    // Hard asserts in dev mode\n    if (true) {\n        if (year === 2040) {\n            const actual2040 = demandGW;\n            const error2040 = Math.abs(actual2040 - demand2040) / demand2040;\n            if (error2040 >= 0.03) {\n                throw new Error(\"[DEMAND ANCHOR FAIL] demandGw(2040)=\".concat(actual2040.toFixed(2), \" GW, \") + \"expected=\".concat(demand2040, \" GW, error=\").concat((error2040 * 100).toFixed(2), \"% >= 3%\"));\n            }\n        }\n        if (year === 2060) {\n            if (demandGW < 2000) {\n                throw new Error(\"[DEMAND ANCHOR FAIL] demandGw(2060)=\".concat(demandGW.toFixed(2), \" GW < 2000 GW. \") + \"Must be >= 2000 GW (multi-TW target).\");\n            }\n        }\n    }\n    return demandGW;\n}\n/**\n * Smooth interpolation for buildout anchors\n * Uses moving average with smoothing window\n */ function calculateBuildRateGWyr(year, params) {\n    const { buildoutAnchorsGWyr, buildoutSmoothingYears } = params;\n    const anchors = buildoutAnchorsGWyr;\n    // Find surrounding anchors\n    const anchorYears = Object.keys(anchors).map(Number).sort((a, b)=>a - b);\n    // Before first anchor: use first anchor value\n    if (year <= anchorYears[0]) {\n        return anchors[anchorYears[0]];\n    }\n    // After last anchor: use last anchor value\n    if (year >= anchorYears[anchorYears.length - 1]) {\n        return anchors[anchorYears[anchorYears.length - 1]];\n    }\n    // Find surrounding anchors\n    let lowerYear = anchorYears[0];\n    let upperYear = anchorYears[anchorYears.length - 1];\n    for(let i = 0; i < anchorYears.length - 1; i++){\n        if (year >= anchorYears[i] && year <= anchorYears[i + 1]) {\n            lowerYear = anchorYears[i];\n            upperYear = anchorYears[i + 1];\n            break;\n        }\n    }\n    const lowerRate = anchors[lowerYear];\n    const upperRate = anchors[upperYear];\n    // Exponential interpolation for buildout ramp\n    const t = (year - lowerYear) / (upperYear - lowerYear);\n    const buildRate = lowerRate * Math.pow(upperRate / lowerRate, t);\n    // Apply smoothing: moving average over smoothing window\n    if (buildoutSmoothingYears > 0) {\n        const smoothingWindow = buildoutSmoothingYears;\n        let smoothedSum = buildRate;\n        let count = 1;\n        // Helper function to calculate unsmoothed rate\n        const getUnsmoothedRate = (y)=>{\n            if (y <= anchorYears[0]) return anchors[anchorYears[0]];\n            if (y >= anchorYears[anchorYears.length - 1]) return anchors[anchorYears[anchorYears.length - 1]];\n            let lower = anchorYears[0];\n            let upper = anchorYears[anchorYears.length - 1];\n            for(let i = 0; i < anchorYears.length - 1; i++){\n                if (y >= anchorYears[i] && y <= anchorYears[i + 1]) {\n                    lower = anchorYears[i];\n                    upper = anchorYears[i + 1];\n                    break;\n                }\n            }\n            const lowerRate = anchors[lower];\n            const upperRate = anchors[upper];\n            const t = (y - lower) / (upper - lower);\n            return lowerRate * Math.pow(upperRate / lowerRate, t);\n        };\n        for(let offset = 1; offset <= Math.floor(smoothingWindow / 2); offset++){\n            const prevYear = year - offset;\n            const nextYear = year + offset;\n            if (prevYear >= anchorYears[0]) {\n                const prevRate = getUnsmoothedRate(prevYear);\n                smoothedSum += prevRate;\n                count++;\n            }\n            if (nextYear <= anchorYears[anchorYears.length - 1]) {\n                const nextRate = getUnsmoothedRate(nextYear);\n                smoothedSum += nextRate;\n                count++;\n            }\n        }\n        return smoothedSum / count;\n    }\n    return buildRate;\n}\n/**\n * Calculate bottleneck rate from anchors (same interpolation as buildout)\n */ function calculateBottleneckRateGWyr(year, anchors) {\n    const anchorYears = [\n        2025,\n        2030,\n        2040,\n        2060\n    ];\n    // Before first anchor: use first anchor value\n    if (year <= anchorYears[0]) {\n        return anchors[2025];\n    }\n    // After last anchor: use last anchor value\n    if (year >= anchorYears[anchorYears.length - 1]) {\n        return anchors[2060];\n    }\n    // Find surrounding anchors\n    let lowerYear = anchorYears[0];\n    let upperYear = anchorYears[anchorYears.length - 1];\n    for(let i = 0; i < anchorYears.length - 1; i++){\n        if (year >= anchorYears[i] && year <= anchorYears[i + 1]) {\n            lowerYear = anchorYears[i];\n            upperYear = anchorYears[i + 1];\n            break;\n        }\n    }\n    const lowerRate = anchors[lowerYear];\n    const upperRate = anchors[upperYear];\n    // Exponential interpolation\n    const t = (year - lowerYear) / (upperYear - lowerYear);\n    return lowerRate * Math.pow(upperRate / lowerRate, t);\n}\n/**\n * Step mobilization state forward one year\n */ function stepMobilizationState(prevState, params, year) {\n    let pue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1.3, retirementsGW = arguments.length > 4 && arguments[4] !== void 0 // Optional retirements (default 0)\n     ? arguments[4] : 0;\n    // Calculate demand\n    const demandGW = calculateDemandGW(year, params, pue);\n    var _prevState_demandGW;\n    const demandGWPrev = (_prevState_demandGW = prevState === null || prevState === void 0 ? void 0 : prevState.demandGW) !== null && _prevState_demandGW !== void 0 ? _prevState_demandGW : calculateDemandGW(year - 1, params, pue);\n    const demandNewGW = Math.max(0, demandGW - demandGWPrev);\n    // Calculate build rate candidate (from anchors)\n    const buildRateCandidate = calculateBuildRateGWyr(year, params);\n    var _params_bottleneckMode;\n    // Apply bottleneck constraints if enabled\n    const bottleneckMode = (_params_bottleneckMode = params.bottleneckMode) !== null && _params_bottleneckMode !== void 0 ? _params_bottleneckMode : \"min_of_bottlenecks\";\n    let buildRateGWyr = buildRateCandidate;\n    let bottleneckRateGWyr;\n    let limitingBottleneck = \"candidate\";\n    if (bottleneckMode === \"min_of_bottlenecks\" && params.bottleneckAnchorsGWyr) {\n        const { transformers, substations, tx, generation } = params.bottleneckAnchorsGWyr;\n        const transformersRate = calculateBottleneckRateGWyr(year, transformers);\n        const substationsRate = calculateBottleneckRateGWyr(year, substations);\n        const txRate = calculateBottleneckRateGWyr(year, tx);\n        const generationRate = calculateBottleneckRateGWyr(year, generation);\n        // Find minimum bottleneck\n        bottleneckRateGWyr = Math.min(transformersRate, substationsRate, txRate, generationRate);\n        // Determine which bottleneck is limiting\n        if (bottleneckRateGWyr === transformersRate) {\n            limitingBottleneck = \"transformers\";\n        } else if (bottleneckRateGWyr === substationsRate) {\n            limitingBottleneck = \"substations\";\n        } else if (bottleneckRateGWyr === txRate) {\n            limitingBottleneck = \"tx\";\n        } else if (bottleneckRateGWyr === generationRate) {\n            limitingBottleneck = \"generation\";\n        }\n        // Effective build rate is minimum of candidate and bottleneck\n        buildRateGWyr = Math.min(buildRateCandidate, bottleneckRateGWyr);\n    } else {\n        limitingBottleneck = \"none\";\n    }\n    var _params_rampLimitFracPerYear;\n    // Apply ramp limiter (prevent sudden jumps)\n    const rampLimitFrac = (_params_rampLimitFracPerYear = params.rampLimitFracPerYear) !== null && _params_rampLimitFracPerYear !== void 0 ? _params_rampLimitFracPerYear : 0.25;\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.buildRateGWyr) !== undefined) {\n        const prevRate = prevState.buildRateGWyr;\n        const minRate = prevRate * (1 - rampLimitFrac);\n        const maxRate = prevRate * (1 + rampLimitFrac);\n        buildRateGWyr = Math.max(minRate, Math.min(maxRate, buildRateGWyr));\n    }\n    var _prevState_capacityGW;\n    // Calculate capacity evolution\n    // capacityGw(t) = capacityGw(t-1) + buildRateGwYear(t) - retirementsGw(t)\n    const capacityGWPrev = (_prevState_capacityGW = prevState === null || prevState === void 0 ? void 0 : prevState.capacityGW) !== null && _prevState_capacityGW !== void 0 ? _prevState_capacityGW : 0;\n    const capacityGW = capacityGWPrev + buildRateGWyr - retirementsGW;\n    // Calculate pipeline\n    // pipelineGw(t) = buildRateGwYear(t) * pipelineLeadTimeYears * pipelineFillFrac\n    const pipelineGW = buildRateGWyr * params.pipelineLeadTimeYears * params.pipelineFillFrac;\n    var _prevState_backlogGW;\n    // Calculate backlog\n    // backlogGw(t) = max(0, backlogGw(t-1) + demandNewGw(t) - buildableGw(t))\n    const backlogGWPrev = (_prevState_backlogGW = prevState === null || prevState === void 0 ? void 0 : prevState.backlogGW) !== null && _prevState_backlogGW !== void 0 ? _prevState_backlogGW : 0;\n    const buildableGW = buildRateGWyr;\n    const backlogGW = Math.max(0, backlogGWPrev + demandNewGW - buildableGW);\n    // Hard assert: If demandNewGw(t) > buildRateGwYear(t), backlogGw must increase\n    if (true) {\n        if (demandNewGW > buildRateGWyr && backlogGW <= backlogGWPrev) {\n            throw new Error(\"[BUILDOUT INVARIANT] Year \".concat(year, \": demandNewGW=\").concat(demandNewGW.toFixed(2), \" > \") + \"buildRateGWyr=\".concat(buildRateGWyr.toFixed(2), \", but backlogGW=\").concat(backlogGW.toFixed(2), \" \") + \"<= prevBacklogGW=\".concat(backlogGWPrev.toFixed(2), \". Backlog must increase.\"));\n        }\n    }\n    // Calculate average wait time\n    // avgWaitYears(t) = backlogGw(t) / max(buildRateGwYear(t), 1e-9)\n    const EPS = 1e-9;\n    const avgWaitYears = backlogGW / Math.max(buildRateGWyr, EPS);\n    // Calculate growth rate (for debug)\n    let demandGrowthRate;\n    if (year <= 2040) {\n        demandGrowthRate = Math.log(params.demandAnchorsGW[2040] / params.demandAnchorsGW[2025]) / 15;\n    } else {\n        demandGrowthRate = Math.log(params.demandAnchorsGW[2060] / params.demandAnchorsGW[2040]) / 20;\n    }\n    return {\n        year,\n        demandGW,\n        demandNewGW,\n        buildRateGWyr,\n        capacityGW,\n        pipelineGW,\n        backlogGW,\n        avgWaitYears,\n        demandGrowthRate,\n        buildoutSmoothFactor: params.buildoutSmoothingYears,\n        bottleneckRateGWyr,\n        limitingBottleneck,\n        buildRateCandidate\n    };\n}\n/**\n * Default mobilization scenario parameters\n */ const DEFAULT_MOBILIZATION_PARAMS = {\n    demandAnchorsGW: {\n        2025: 120,\n        2040: 450,\n        2060: 3000\n    },\n    demandCurve: \"piecewise_exponential\",\n    demandIsFacilityLoad: true,\n    buildoutAnchorsGWyr: {\n        2025: 25,\n        2030: 60,\n        2040: 140,\n        2060: 220\n    },\n    buildoutSmoothingYears: 3,\n    pipelineLeadTimeYears: 3,\n    pipelineFillFrac: 1.5,\n    bottleneckMode: \"min_of_bottlenecks\",\n    bottleneckAnchorsGWyr: {\n        transformers: {\n            2025: 30,\n            2030: 50,\n            2040: 100,\n            2060: 180\n        },\n        substations: {\n            2025: 35,\n            2030: 55,\n            2040: 110,\n            2060: 200\n        },\n        tx: {\n            2025: 40,\n            2030: 65,\n            2040: 130,\n            2060: 250\n        },\n        generation: {\n            2025: 50,\n            2030: 80,\n            2040: 160,\n            2060: 300\n        }\n    },\n    rampLimitFracPerYear: 0.25\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX3JhbXBpbmdfbW9iaWxpemF0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0NBUUMsR0FtRUQ7Ozs7O0NBS0MsR0FDTSxTQUFTQSxpQ0FDZEMsSUFBWSxFQUNaQyxxQkFBNkIsRUFDN0JDLHNCQUE4QixFQUM5QkMsWUFBb0IsRUFDcEJDLE1BQW9CO1FBQ3BCQyxNQUFBQSxpRUFBYztJQUVkLHFFQUFxRTtJQUNyRSxNQUFNQyxnQkFBZ0JOLE9BQU87SUFDN0IsTUFBTU8sY0FBY0MsS0FBS0MsSUFBSSxDQUFDSCxnQkFBZ0IsS0FBSyx5QkFBeUI7SUFDNUUsTUFBTUksYUFBYU4sT0FBT08sZ0JBQWdCLEdBQUdILEtBQUtJLEdBQUcsQ0FBQyxJQUFJUixPQUFPUyxpQkFBaUIsRUFBRVAsZ0JBQWdCQztJQUVwRyxnREFBZ0Q7SUFDaEQsTUFBTU8sZ0JBQWdCLE1BQU0sb0JBQW9CO0lBQ2hELE1BQU1DLGFBQWFkLHdCQUF3QmE7SUFDM0MsTUFBTUUsY0FBY1IsS0FBS0ksR0FBRyxDQUFDRyxZQUFZWCxPQUFPYSxlQUFlO0lBRS9ELDhDQUE4QztJQUM5QyxNQUFNQyxhQUFhVixLQUFLVyxHQUFHLENBQUMsQ0FBQ2hCLGVBQWVDLE9BQU9nQixjQUFjLEdBQUc7SUFFcEUsMERBQTBEO0lBQzFELE1BQU1DLG1CQUFtQnBCLHdCQUF3Qk8sS0FBS2MsR0FBRyxDQUFDcEIsd0JBQXdCO0lBQ2xGLE1BQU1xQixxQkFBcUJGLG1CQUFtQmpCLE9BQU9vQiw0QkFBNEIsR0FDN0UsSUFBSyxLQUFJLE1BQU9ILENBQUFBLG1CQUFtQmpCLE9BQU9vQiw0QkFBNEIsS0FDdEU7SUFFSixJQUFJQyxXQUFXZixhQUFhTSxjQUFjRSxhQUFhSztJQUV2RCxxREFBcUQ7SUFDckQsMEVBQTBFO0lBQzFFLGtGQUFrRjtJQUVsRixPQUFPZixLQUFLYyxHQUFHLENBQUMsR0FBR0c7QUFDckI7QUFFQTs7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Qy9DQyxZQUFZO1lBQUUsTUFBTTtZQUFJLE1BQU07WUFBSSxNQUFNO1lBQUssTUFBTTtRQUFJO0lBQ3pEO0lBQ0FPLHNCQUFzQjtBQUN4QixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX3JhbXBpbmdfbW9iaWxpemF0aW9uLnRzPzQ0NTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHcm91bmQgUmFtcGluZyBNb2JpbGl6YXRpb24gTW9kZWxcbiAqIFxuICogTW9kZWxzIGRlbWFuZCBncm93dGggd2l0aCBwcmljZS1yZXNwb25zaXZlIGRlbWFuZCBhbmQgYnVpbGRvdXQgY2FwYWNpdHlcbiAqIHJhbXBpbmcgd2l0aCBpbnZlc3RtZW50IHJlc3BvbnNlLiBUcmFja3MgY2FwYWNpdHkgZXZvbHV0aW9uLCBwaXBlbGluZSwgYmFja2xvZyxcbiAqIGFuZCB3YWl0IHRpbWVzLlxuICogXG4gKiBORVc6IFByaWNlLXJlc3BvbnNpdmUgZGVtYW5kIGFuZCBpbnZlc3RtZW50LXJlc3BvbnNpdmUgYnVpbGRvdXQgKHJlcGxhY2VzIGZpeGVkIGFuY2hvcnMpXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBEZW1hbmRQYXJhbXMge1xuICBiYXNlRGVtYW5kMjAyNUdXOiBudW1iZXI7ICAgICAgICAvLyAxMjAgR1dcbiAgb3JnYW5pY0dyb3d0aFJhdGU6IG51bWJlcjsgICAgICAgLy8gMC4xMCAoMTAlIENBR1IgYmFzZSlcbiAgcHJpY2VFbGFzdGljaXR5OiBudW1iZXI7ICAgICAgICAgLy8gLTAuMyAoMzAlIGRlbWFuZCBkcm9wIHBlciAxMDAlIHByaWNlIGluY3JlYXNlKVxuICB3YWl0RWxhc3RpY2l0eTogbnVtYmVyOyAgICAgICAgICAvLyAtMC4yICgyMCUgZGVtYW5kIGRyb3AgcGVyIDV5ciB3YWl0KVxuICBvcmJpdGFsU3Vic3RpdHV0aW9uVGhyZXNob2xkOiBudW1iZXI7IC8vIFByaWNlIHJhdGlvIGF0IHdoaWNoIGRlbWFuZCBzaGlmdHMgdG8gb3JiaXRhbCAoZGVmYXVsdCAxLjIgPSAyMCUgY2hlYXBlcilcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCdWlsZG91dFBhcmFtcyB7XG4gIGJhc2VCdWlsZFJhdGUyMDI1R1d5cjogbnVtYmVyOyAgIC8vIDI1IEdXL3lyXG4gIG1heEJ1aWxkUmF0ZUdXeXI6IG51bWJlcjsgICAgICAgIC8vIDE1MCBHVy95ciBwaHlzaWNhbCBsaW1pdFxuICBpbnZlc3RtZW50RWxhc3RpY2l0eTogbnVtYmVyOyAgICAgLy8gMC41ICg1MCUgbW9yZSBpbnZlc3RtZW50IHBlciAxMDAlIG1hcmdpbiBpbmNyZWFzZSlcbiAgcmFtcExpbWl0UGVyWWVhcjogbnVtYmVyOyAgICAgICAgIC8vIDAuMjUgKDI1JSBtYXggaW5jcmVhc2UgcGVyIHllYXIpXG4gIGJhY2tsb2dSZXNwb25zZUs6IG51bWJlcjsgICAgICAgICAvLyAwLjMgKGhvdyBmYXN0IGJ1aWxkb3V0IHJlc3BvbmRzIHRvIGJhY2tsb2cpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9iaWxpemF0aW9uU2NlbmFyaW9QYXJhbXMge1xuICBkZW1hbmRBbmNob3JzR1c6IHtcbiAgICAyMDI1OiBudW1iZXI7XG4gICAgMjA0MDogbnVtYmVyO1xuICAgIDIwNjA6IG51bWJlcjtcbiAgfTtcbiAgZGVtYW5kQ3VydmU6ICdwaWVjZXdpc2VfZXhwb25lbnRpYWwnOyAvLyBDdXJ2ZSB0eXBlIChvbmx5IHBpZWNld2lzZV9leHBvbmVudGlhbCBzdXBwb3J0ZWQpXG4gIGRlbWFuZElzRmFjaWxpdHlMb2FkOiBib29sZWFuOyAvLyBJZiB0cnVlLCBpbmNsdWRlcyBQVUU7IGlmIGZhbHNlLCBtdWx0aXBseSBieSBQVUUgbGF0ZXJcbiAgYnVpbGRvdXRBbmNob3JzR1d5cjoge1xuICAgIDIwMjU6IG51bWJlcjtcbiAgICAyMDMwOiBudW1iZXI7XG4gICAgMjA0MDogbnVtYmVyO1xuICAgIDIwNjA6IG51bWJlcjtcbiAgfTtcbiAgYnVpbGRvdXRTbW9vdGhpbmdZZWFyczogbnVtYmVyOyAvLyBTbW9vdGhpbmcgd2luZG93IGZvciBidWlsZG91dCBpbnRlcnBvbGF0aW9uXG4gIHBpcGVsaW5lTGVhZFRpbWVZZWFyczogbnVtYmVyOyAvLyBMZWFkIHRpbWUgZm9yIHBpcGVsaW5lIGNhbGN1bGF0aW9uXG4gIHBpcGVsaW5lRmlsbEZyYWM6IG51bWJlcjsgLy8gUGlwZWxpbmUgZmlsbCBmcmFjdGlvbiAocGlwZWxpbmVHVyA9IGxlYWRUaW1lICogYnVpbGRSYXRlICogZmlsbEZyYWMpXG4gIC8vIEJvdHRsZW5lY2sgY29uc3RyYWludHNcbiAgYm90dGxlbmVja01vZGU/OiAnb2ZmJyB8ICdtaW5fb2ZfYm90dGxlbmVja3MnOyAvLyBEZWZhdWx0ICdtaW5fb2ZfYm90dGxlbmVja3MnXG4gIGJvdHRsZW5lY2tBbmNob3JzR1d5cj86IHtcbiAgICB0cmFuc2Zvcm1lcnM6IHsgMjAyNTogbnVtYmVyOyAyMDMwOiBudW1iZXI7IDIwNDA6IG51bWJlcjsgMjA2MDogbnVtYmVyIH07XG4gICAgc3Vic3RhdGlvbnM6IHsgMjAyNTogbnVtYmVyOyAyMDMwOiBudW1iZXI7IDIwNDA6IG51bWJlcjsgMjA2MDogbnVtYmVyIH07XG4gICAgdHg6IHsgMjAyNTogbnVtYmVyOyAyMDMwOiBudW1iZXI7IDIwNDA6IG51bWJlcjsgMjA2MDogbnVtYmVyIH07XG4gICAgZ2VuZXJhdGlvbjogeyAyMDI1OiBudW1iZXI7IDIwMzA6IG51bWJlcjsgMjA0MDogbnVtYmVyOyAyMDYwOiBudW1iZXIgfTtcbiAgfTtcbiAgcmFtcExpbWl0RnJhY1BlclllYXI/OiBudW1iZXI7IC8vIE1heCBmcmFjdGlvbmFsIGNoYW5nZSBwZXIgeWVhciAoZGVmYXVsdCAwLjI1ID0gMjUlKVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vYmlsaXphdGlvblN0YXRlIHtcbiAgeWVhcjogbnVtYmVyO1xuICBkZW1hbmRHVzogbnVtYmVyOyAvLyBUb3RhbCBkZW1hbmQgKElUIG9yIGZhY2lsaXR5IGxvYWQpXG4gIGRlbWFuZE5ld0dXOiBudW1iZXI7IC8vIEluY3JlbWVudGFsIGRlbWFuZCB0aGlzIHllYXJcbiAgYnVpbGRSYXRlR1d5cjogbnVtYmVyOyAvLyBCdWlsZCByYXRlIHRoaXMgeWVhciAoR1cveWVhcilcbiAgY2FwYWNpdHlHVzogbnVtYmVyOyAvLyBDdW11bGF0aXZlIGNhcGFjaXR5IGJ1aWx0XG4gIHBpcGVsaW5lR1c6IG51bWJlcjsgLy8gUGlwZWxpbmUgY2FwYWNpdHkgKHVuZGVyIGNvbnN0cnVjdGlvbilcbiAgYmFja2xvZ0dXOiBudW1iZXI7IC8vIEJhY2tsb2cgd2FpdGluZyB0byBiZSBidWlsdFxuICBhdmdXYWl0WWVhcnM6IG51bWJlcjsgLy8gQXZlcmFnZSB3YWl0IHRpbWUgKGJhY2tsb2cgLyBidWlsZFJhdGUpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9iaWxpemF0aW9uUmVzdWx0IGV4dGVuZHMgTW9iaWxpemF0aW9uU3RhdGUge1xuICAvLyBBZGRpdGlvbmFsIGRlYnVnIGZpZWxkc1xuICBkZW1hbmRHcm93dGhSYXRlOiBudW1iZXI7IC8vIEN1cnJlbnQgZ3Jvd3RoIHJhdGUgKHIxIG9yIHIyKVxuICBidWlsZG91dFNtb290aEZhY3RvcjogbnVtYmVyOyAvLyBTbW9vdGhpbmcgZmFjdG9yIGFwcGxpZWRcbiAgLy8gQm90dGxlbmVjayBkZWJ1ZyBmaWVsZHNcbiAgYm90dGxlbmVja1JhdGVHV3lyPzogbnVtYmVyOyAvLyBFZmZlY3RpdmUgYm90dGxlbmVjayByYXRlIChtaW4gb2YgYWxsIGJvdHRsZW5lY2tzKVxuICBsaW1pdGluZ0JvdHRsZW5lY2s/OiAndHJhbnNmb3JtZXJzJyB8ICdzdWJzdGF0aW9ucycgfCAndHgnIHwgJ2dlbmVyYXRpb24nIHwgJ2NhbmRpZGF0ZScgfCAnbm9uZSc7IC8vIFdoaWNoIGJvdHRsZW5lY2sgaXMgbGltaXRpbmdcbiAgYnVpbGRSYXRlQ2FuZGlkYXRlPzogbnVtYmVyOyAvLyBPcmlnaW5hbCBidWlsZCByYXRlIGJlZm9yZSBib3R0bGVuZWNrL3JhbXAgbGltaXRzXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHByaWNlLXJlc3BvbnNpdmUgZGVtYW5kIEdXXG4gKiBcbiAqIE5FVzogRGVtYW5kIHJlc3BvbmRzIHRvIHByaWNlcywgd2FpdCB0aW1lcywgYW5kIG9yYml0YWwgc3Vic3RpdHV0aW9uXG4gKiBSZXBsYWNlcyBmaXhlZCBhbmNob3JzIHdpdGggZWNvbm9taWMgZmVlZGJhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVByaWNlUmVzcG9uc2l2ZURlbWFuZEdXKFxuICB5ZWFyOiBudW1iZXIsXG4gIGdyb3VuZFByaWNlUGVyR3B1SG91cjogbnVtYmVyLFxuICBvcmJpdGFsUHJpY2VQZXJHcHVIb3VyOiBudW1iZXIsXG4gIGF2Z1dhaXRZZWFyczogbnVtYmVyLFxuICBwYXJhbXM6IERlbWFuZFBhcmFtcyxcbiAgcHVlOiBudW1iZXIgPSAxLjNcbik6IG51bWJlciB7XG4gIC8vIEJhc2UgZGVtYW5kIHdpdGggb3JnYW5pYyBncm93dGggKHRhcGVyZWQsIG5vdCBleHBvbmVudGlhbCBmb3JldmVyKVxuICBjb25zdCB5ZWFyc0Zyb20yMDI1ID0geWVhciAtIDIwMjU7XG4gIGNvbnN0IGdyb3d0aFRhcGVyID0gTWF0aC50YW5oKHllYXJzRnJvbTIwMjUgLyAzMCk7IC8vIFRhcGVycyBhZnRlciB+MzAgeWVhcnNcbiAgY29uc3QgYmFzZURlbWFuZCA9IHBhcmFtcy5iYXNlRGVtYW5kMjAyNUdXICogTWF0aC5wb3coMSArIHBhcmFtcy5vcmdhbmljR3Jvd3RoUmF0ZSwgeWVhcnNGcm9tMjAyNSAqIGdyb3d0aFRhcGVyKTtcbiAgXG4gIC8vIFByaWNlIGVsYXN0aWNpdHk6IGhpZ2hlciBwcmljZXMgcmVkdWNlIGRlbWFuZFxuICBjb25zdCBiYXNlbGluZVByaWNlID0gMy41MDsgLy8gJC9HUFUtaHIgYmFzZWxpbmVcbiAgY29uc3QgcHJpY2VSYXRpbyA9IGdyb3VuZFByaWNlUGVyR3B1SG91ciAvIGJhc2VsaW5lUHJpY2U7XG4gIGNvbnN0IHByaWNlRmFjdG9yID0gTWF0aC5wb3cocHJpY2VSYXRpbywgcGFyYW1zLnByaWNlRWxhc3RpY2l0eSk7XG4gIFxuICAvLyBXYWl0IGVsYXN0aWNpdHk6IGxvbmdlciB3YWl0cyByZWR1Y2UgZGVtYW5kXG4gIGNvbnN0IHdhaXRGYWN0b3IgPSBNYXRoLmV4cCgtYXZnV2FpdFllYXJzICogcGFyYW1zLndhaXRFbGFzdGljaXR5IC8gNSk7XG4gIFxuICAvLyBPcmJpdGFsIHN1YnN0aXR1dGlvbjogaWYgb3JiaXRhbCBjaGVhcGVyLCBkZW1hbmQgc2hpZnRzXG4gIGNvbnN0IG9yYml0YWxBZHZhbnRhZ2UgPSBncm91bmRQcmljZVBlckdwdUhvdXIgLyBNYXRoLm1heChvcmJpdGFsUHJpY2VQZXJHcHVIb3VyLCAwLjAxKTtcbiAgY29uc3Qgc3Vic3RpdHV0aW9uRmFjdG9yID0gb3JiaXRhbEFkdmFudGFnZSA+IHBhcmFtcy5vcmJpdGFsU3Vic3RpdHV0aW9uVGhyZXNob2xkIFxuICAgID8gMSAvICgxICsgMC41ICogKG9yYml0YWxBZHZhbnRhZ2UgLSBwYXJhbXMub3JiaXRhbFN1YnN0aXR1dGlvblRocmVzaG9sZCkpXG4gICAgOiAxLjA7XG4gIFxuICBsZXQgZGVtYW5kR1cgPSBiYXNlRGVtYW5kICogcHJpY2VGYWN0b3IgKiB3YWl0RmFjdG9yICogc3Vic3RpdHV0aW9uRmFjdG9yO1xuICBcbiAgLy8gQXBwbHkgUFVFIGlmIGRlbWFuZCBpcyBJVCBsb2FkIChub3QgZmFjaWxpdHkgbG9hZClcbiAgLy8gTm90ZTogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIGZhY2lsaXR5IGxvYWQsIHNvIG11bHRpcGx5IGJ5IFBVRSBpZiBuZWVkZWRcbiAgLy8gRm9yIG5vdywgcmV0dXJuIGZhY2lsaXR5IGxvYWQgKGRlbWFuZCBhbHJlYWR5IGluY2x1ZGVzIFBVRSBpbiBiYXNlRGVtYW5kMjAyNUdXKVxuICBcbiAgcmV0dXJuIE1hdGgubWF4KDAsIGRlbWFuZEdXKTtcbn1cblxuLyoqXG4gKiBMZWdhY3kgZnVuY3Rpb246IENhbGN1bGF0ZSBkZW1hbmQgR1cgdXNpbmcgcGllY2V3aXNlIGV4cG9uZW50aWFsIHRvIGhpdCBhbmNob3JzXG4gKiBcbiAqIERFUFJFQ0FURUQ6IFVzZSBjYWxjdWxhdGVQcmljZVJlc3BvbnNpdmVEZW1hbmRHVyBpbnN0ZWFkXG4gKiBLZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVEZW1hbmRHVyhcbiAgeWVhcjogbnVtYmVyLFxuICBwYXJhbXM6IE1vYmlsaXphdGlvblNjZW5hcmlvUGFyYW1zLFxuICBwdWU6IG51bWJlciA9IDEuM1xuKTogbnVtYmVyIHtcbiAgY29uc3QgeyBkZW1hbmRBbmNob3JzR1csIGRlbWFuZElzRmFjaWxpdHlMb2FkLCBkZW1hbmRDdXJ2ZSB9ID0gcGFyYW1zO1xuICBjb25zdCBkZW1hbmQyMDI1ID0gZGVtYW5kQW5jaG9yc0dXWzIwMjVdO1xuICBjb25zdCBkZW1hbmQyMDQwID0gZGVtYW5kQW5jaG9yc0dXWzIwNDBdO1xuICBjb25zdCBkZW1hbmQyMDYwID0gZGVtYW5kQW5jaG9yc0dXWzIwNjBdO1xuICBcbiAgaWYgKGRlbWFuZEN1cnZlICE9PSAncGllY2V3aXNlX2V4cG9uZW50aWFsJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVtYW5kQ3VydmU6ICR7ZGVtYW5kQ3VydmV9LiBPbmx5ICdwaWVjZXdpc2VfZXhwb25lbnRpYWwnIGlzIHN1cHBvcnRlZC5gKTtcbiAgfVxuICBcbiAgaWYgKHllYXIgPCAyMDI1KSB7XG4gICAgcmV0dXJuIGRlbWFuZDIwMjU7XG4gIH1cbiAgXG4gIGxldCBkZW1hbmRHVzogbnVtYmVyO1xuICBcbiAgaWYgKHllYXIgPD0gMjA0MCkge1xuICAgIC8vIFBoYXNlIDE6IDIwMjUtMjA0MFxuICAgIC8vIHIxID0gbG4oZGVtYW5kMjA0MCAvIGRlbWFuZDIwMjUpIC8gKDIwNDAtMjAyNSlcbiAgICBjb25zdCByMSA9IE1hdGgubG9nKGRlbWFuZDIwNDAgLyBkZW1hbmQyMDI1KSAvICgyMDQwIC0gMjAyNSk7XG4gICAgY29uc3QgeWVhcnNGcm9tMjAyNSA9IHllYXIgLSAyMDI1O1xuICAgIGRlbWFuZEdXID0gZGVtYW5kMjAyNSAqIE1hdGguZXhwKHIxICogeWVhcnNGcm9tMjAyNSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUGhhc2UgMjogMjA0MC0yMDYwXG4gICAgLy8gcjIgPSBsbihkZW1hbmQyMDYwIC8gZGVtYW5kMjA0MCkgLyAoMjA2MC0yMDQwKVxuICAgIGNvbnN0IHIyID0gTWF0aC5sb2coZGVtYW5kMjA2MCAvIGRlbWFuZDIwNDApIC8gKDIwNjAgLSAyMDQwKTtcbiAgICBjb25zdCB5ZWFyc0Zyb20yMDQwID0geWVhciAtIDIwNDA7XG4gICAgZGVtYW5kR1cgPSBkZW1hbmQyMDQwICogTWF0aC5leHAocjIgKiB5ZWFyc0Zyb20yMDQwKTtcbiAgfVxuICBcbiAgLy8gQXBwbHkgUFVFIGlmIGRlbWFuZCBpcyBJVCBsb2FkIChub3QgZmFjaWxpdHkgbG9hZClcbiAgaWYgKCFkZW1hbmRJc0ZhY2lsaXR5TG9hZCkge1xuICAgIGRlbWFuZEdXID0gZGVtYW5kR1cgKiBwdWU7XG4gIH1cbiAgXG4gIC8vIEhhcmQgYXNzZXJ0cyBpbiBkZXYgbW9kZVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBpZiAoeWVhciA9PT0gMjA0MCkge1xuICAgICAgY29uc3QgYWN0dWFsMjA0MCA9IGRlbWFuZEdXO1xuICAgICAgY29uc3QgZXJyb3IyMDQwID0gTWF0aC5hYnMoYWN0dWFsMjA0MCAtIGRlbWFuZDIwNDApIC8gZGVtYW5kMjA0MDtcbiAgICAgIGlmIChlcnJvcjIwNDAgPj0gMC4wMykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFtERU1BTkQgQU5DSE9SIEZBSUxdIGRlbWFuZEd3KDIwNDApPSR7YWN0dWFsMjA0MC50b0ZpeGVkKDIpfSBHVywgYCArXG4gICAgICAgICAgYGV4cGVjdGVkPSR7ZGVtYW5kMjA0MH0gR1csIGVycm9yPSR7KGVycm9yMjA0MCAqIDEwMCkudG9GaXhlZCgyKX0lID49IDMlYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoeWVhciA9PT0gMjA2MCkge1xuICAgICAgaWYgKGRlbWFuZEdXIDwgMjAwMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFtERU1BTkQgQU5DSE9SIEZBSUxdIGRlbWFuZEd3KDIwNjApPSR7ZGVtYW5kR1cudG9GaXhlZCgyKX0gR1cgPCAyMDAwIEdXLiBgICtcbiAgICAgICAgICBgTXVzdCBiZSA+PSAyMDAwIEdXIChtdWx0aS1UVyB0YXJnZXQpLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBkZW1hbmRHVztcbn1cblxuLyoqXG4gKiBTbW9vdGggaW50ZXJwb2xhdGlvbiBmb3IgYnVpbGRvdXQgYW5jaG9yc1xuICogVXNlcyBtb3ZpbmcgYXZlcmFnZSB3aXRoIHNtb290aGluZyB3aW5kb3dcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUJ1aWxkUmF0ZUdXeXIoXG4gIHllYXI6IG51bWJlcixcbiAgcGFyYW1zOiBNb2JpbGl6YXRpb25TY2VuYXJpb1BhcmFtc1xuKTogbnVtYmVyIHtcbiAgY29uc3QgeyBidWlsZG91dEFuY2hvcnNHV3lyLCBidWlsZG91dFNtb290aGluZ1llYXJzIH0gPSBwYXJhbXM7XG4gIGNvbnN0IGFuY2hvcnMgPSBidWlsZG91dEFuY2hvcnNHV3lyO1xuICBcbiAgLy8gRmluZCBzdXJyb3VuZGluZyBhbmNob3JzXG4gIGNvbnN0IGFuY2hvclllYXJzID0gT2JqZWN0LmtleXMoYW5jaG9ycykubWFwKE51bWJlcikuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICBcbiAgLy8gQmVmb3JlIGZpcnN0IGFuY2hvcjogdXNlIGZpcnN0IGFuY2hvciB2YWx1ZVxuICBpZiAoeWVhciA8PSBhbmNob3JZZWFyc1swXSkge1xuICAgIHJldHVybiBhbmNob3JzW2FuY2hvclllYXJzWzBdIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgfVxuICBcbiAgLy8gQWZ0ZXIgbGFzdCBhbmNob3I6IHVzZSBsYXN0IGFuY2hvciB2YWx1ZVxuICBpZiAoeWVhciA+PSBhbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXSkge1xuICAgIHJldHVybiBhbmNob3JzW2FuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgfVxuICBcbiAgLy8gRmluZCBzdXJyb3VuZGluZyBhbmNob3JzXG4gIGxldCBsb3dlclllYXIgPSBhbmNob3JZZWFyc1swXTtcbiAgbGV0IHVwcGVyWWVhciA9IGFuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdO1xuICBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbmNob3JZZWFycy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBpZiAoeWVhciA+PSBhbmNob3JZZWFyc1tpXSAmJiB5ZWFyIDw9IGFuY2hvclllYXJzW2kgKyAxXSkge1xuICAgICAgbG93ZXJZZWFyID0gYW5jaG9yWWVhcnNbaV07XG4gICAgICB1cHBlclllYXIgPSBhbmNob3JZZWFyc1tpICsgMV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgXG4gIGNvbnN0IGxvd2VyUmF0ZSA9IGFuY2hvcnNbbG93ZXJZZWFyIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgY29uc3QgdXBwZXJSYXRlID0gYW5jaG9yc1t1cHBlclllYXIgYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICBcbiAgLy8gRXhwb25lbnRpYWwgaW50ZXJwb2xhdGlvbiBmb3IgYnVpbGRvdXQgcmFtcFxuICBjb25zdCB0ID0gKHllYXIgLSBsb3dlclllYXIpIC8gKHVwcGVyWWVhciAtIGxvd2VyWWVhcik7XG4gIGNvbnN0IGJ1aWxkUmF0ZSA9IGxvd2VyUmF0ZSAqIE1hdGgucG93KHVwcGVyUmF0ZSAvIGxvd2VyUmF0ZSwgdCk7XG4gIFxuICAvLyBBcHBseSBzbW9vdGhpbmc6IG1vdmluZyBhdmVyYWdlIG92ZXIgc21vb3RoaW5nIHdpbmRvd1xuICBpZiAoYnVpbGRvdXRTbW9vdGhpbmdZZWFycyA+IDApIHtcbiAgICBjb25zdCBzbW9vdGhpbmdXaW5kb3cgPSBidWlsZG91dFNtb290aGluZ1llYXJzO1xuICAgIGxldCBzbW9vdGhlZFN1bSA9IGJ1aWxkUmF0ZTtcbiAgICBsZXQgY291bnQgPSAxO1xuICAgIFxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdW5zbW9vdGhlZCByYXRlXG4gICAgY29uc3QgZ2V0VW5zbW9vdGhlZFJhdGUgPSAoeTogbnVtYmVyKTogbnVtYmVyID0+IHtcbiAgICAgIGlmICh5IDw9IGFuY2hvclllYXJzWzBdKSByZXR1cm4gYW5jaG9yc1thbmNob3JZZWFyc1swXSBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gICAgICBpZiAoeSA+PSBhbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXSkgcmV0dXJuIGFuY2hvcnNbYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV0gYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICAgICAgXG4gICAgICBsZXQgbG93ZXIgPSBhbmNob3JZZWFyc1swXTtcbiAgICAgIGxldCB1cHBlciA9IGFuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbmNob3JZZWFycy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKHkgPj0gYW5jaG9yWWVhcnNbaV0gJiYgeSA8PSBhbmNob3JZZWFyc1tpICsgMV0pIHtcbiAgICAgICAgICBsb3dlciA9IGFuY2hvclllYXJzW2ldO1xuICAgICAgICAgIHVwcGVyID0gYW5jaG9yWWVhcnNbaSArIDFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGxvd2VyUmF0ZSA9IGFuY2hvcnNbbG93ZXIgYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICAgICAgY29uc3QgdXBwZXJSYXRlID0gYW5jaG9yc1t1cHBlciBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gICAgICBjb25zdCB0ID0gKHkgLSBsb3dlcikgLyAodXBwZXIgLSBsb3dlcik7XG4gICAgICByZXR1cm4gbG93ZXJSYXRlICogTWF0aC5wb3codXBwZXJSYXRlIC8gbG93ZXJSYXRlLCB0KTtcbiAgICB9O1xuICAgIFxuICAgIGZvciAobGV0IG9mZnNldCA9IDE7IG9mZnNldCA8PSBNYXRoLmZsb29yKHNtb290aGluZ1dpbmRvdyAvIDIpOyBvZmZzZXQrKykge1xuICAgICAgY29uc3QgcHJldlllYXIgPSB5ZWFyIC0gb2Zmc2V0O1xuICAgICAgY29uc3QgbmV4dFllYXIgPSB5ZWFyICsgb2Zmc2V0O1xuICAgICAgXG4gICAgICBpZiAocHJldlllYXIgPj0gYW5jaG9yWWVhcnNbMF0pIHtcbiAgICAgICAgY29uc3QgcHJldlJhdGUgPSBnZXRVbnNtb290aGVkUmF0ZShwcmV2WWVhcik7XG4gICAgICAgIHNtb290aGVkU3VtICs9IHByZXZSYXRlO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAobmV4dFllYXIgPD0gYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgY29uc3QgbmV4dFJhdGUgPSBnZXRVbnNtb290aGVkUmF0ZShuZXh0WWVhcik7XG4gICAgICAgIHNtb290aGVkU3VtICs9IG5leHRSYXRlO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gc21vb3RoZWRTdW0gLyBjb3VudDtcbiAgfVxuICBcbiAgcmV0dXJuIGJ1aWxkUmF0ZTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgYm90dGxlbmVjayByYXRlIGZyb20gYW5jaG9ycyAoc2FtZSBpbnRlcnBvbGF0aW9uIGFzIGJ1aWxkb3V0KVxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVCb3R0bGVuZWNrUmF0ZUdXeXIoXG4gIHllYXI6IG51bWJlcixcbiAgYW5jaG9yczogeyAyMDI1OiBudW1iZXI7IDIwMzA6IG51bWJlcjsgMjA0MDogbnVtYmVyOyAyMDYwOiBudW1iZXIgfVxuKTogbnVtYmVyIHtcbiAgY29uc3QgYW5jaG9yWWVhcnMgPSBbMjAyNSwgMjAzMCwgMjA0MCwgMjA2MF0gYXMgY29uc3Q7XG4gIFxuICAvLyBCZWZvcmUgZmlyc3QgYW5jaG9yOiB1c2UgZmlyc3QgYW5jaG9yIHZhbHVlXG4gIGlmICh5ZWFyIDw9IGFuY2hvclllYXJzWzBdKSB7XG4gICAgcmV0dXJuIGFuY2hvcnNbMjAyNV07XG4gIH1cbiAgXG4gIC8vIEFmdGVyIGxhc3QgYW5jaG9yOiB1c2UgbGFzdCBhbmNob3IgdmFsdWVcbiAgaWYgKHllYXIgPj0gYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV0pIHtcbiAgICByZXR1cm4gYW5jaG9yc1syMDYwXTtcbiAgfVxuICBcbiAgLy8gRmluZCBzdXJyb3VuZGluZyBhbmNob3JzXG4gIGxldCBsb3dlclllYXIgPSBhbmNob3JZZWFyc1swXTtcbiAgbGV0IHVwcGVyWWVhciA9IGFuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdO1xuICBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbmNob3JZZWFycy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBpZiAoeWVhciA+PSBhbmNob3JZZWFyc1tpXSAmJiB5ZWFyIDw9IGFuY2hvclllYXJzW2kgKyAxXSkge1xuICAgICAgbG93ZXJZZWFyID0gYW5jaG9yWWVhcnNbaV07XG4gICAgICB1cHBlclllYXIgPSBhbmNob3JZZWFyc1tpICsgMV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgXG4gIGNvbnN0IGxvd2VyUmF0ZSA9IGFuY2hvcnNbbG93ZXJZZWFyIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgY29uc3QgdXBwZXJSYXRlID0gYW5jaG9yc1t1cHBlclllYXIgYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICBcbiAgLy8gRXhwb25lbnRpYWwgaW50ZXJwb2xhdGlvblxuICBjb25zdCB0ID0gKHllYXIgLSBsb3dlclllYXIpIC8gKHVwcGVyWWVhciAtIGxvd2VyWWVhcik7XG4gIHJldHVybiBsb3dlclJhdGUgKiBNYXRoLnBvdyh1cHBlclJhdGUgLyBsb3dlclJhdGUsIHQpO1xufVxuXG4vKipcbiAqIFN0ZXAgbW9iaWxpemF0aW9uIHN0YXRlIGZvcndhcmQgb25lIHllYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBNb2JpbGl6YXRpb25TdGF0ZShcbiAgcHJldlN0YXRlOiBNb2JpbGl6YXRpb25TdGF0ZSB8IG51bGwsXG4gIHBhcmFtczogTW9iaWxpemF0aW9uU2NlbmFyaW9QYXJhbXMsXG4gIHllYXI6IG51bWJlcixcbiAgcHVlOiBudW1iZXIgPSAxLjMsXG4gIHJldGlyZW1lbnRzR1c6IG51bWJlciA9IDAgLy8gT3B0aW9uYWwgcmV0aXJlbWVudHMgKGRlZmF1bHQgMClcbik6IE1vYmlsaXphdGlvblJlc3VsdCB7XG4gIC8vIENhbGN1bGF0ZSBkZW1hbmRcbiAgY29uc3QgZGVtYW5kR1cgPSBjYWxjdWxhdGVEZW1hbmRHVyh5ZWFyLCBwYXJhbXMsIHB1ZSk7XG4gIGNvbnN0IGRlbWFuZEdXUHJldiA9IHByZXZTdGF0ZT8uZGVtYW5kR1cgPz8gY2FsY3VsYXRlRGVtYW5kR1coeWVhciAtIDEsIHBhcmFtcywgcHVlKTtcbiAgY29uc3QgZGVtYW5kTmV3R1cgPSBNYXRoLm1heCgwLCBkZW1hbmRHVyAtIGRlbWFuZEdXUHJldik7XG4gIFxuICAvLyBDYWxjdWxhdGUgYnVpbGQgcmF0ZSBjYW5kaWRhdGUgKGZyb20gYW5jaG9ycylcbiAgY29uc3QgYnVpbGRSYXRlQ2FuZGlkYXRlID0gY2FsY3VsYXRlQnVpbGRSYXRlR1d5cih5ZWFyLCBwYXJhbXMpO1xuICBcbiAgLy8gQXBwbHkgYm90dGxlbmVjayBjb25zdHJhaW50cyBpZiBlbmFibGVkXG4gIGNvbnN0IGJvdHRsZW5lY2tNb2RlID0gcGFyYW1zLmJvdHRsZW5lY2tNb2RlID8/ICdtaW5fb2ZfYm90dGxlbmVja3MnO1xuICBsZXQgYnVpbGRSYXRlR1d5ciA9IGJ1aWxkUmF0ZUNhbmRpZGF0ZTtcbiAgbGV0IGJvdHRsZW5lY2tSYXRlR1d5cjogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICBsZXQgbGltaXRpbmdCb3R0bGVuZWNrOiAndHJhbnNmb3JtZXJzJyB8ICdzdWJzdGF0aW9ucycgfCAndHgnIHwgJ2dlbmVyYXRpb24nIHwgJ2NhbmRpZGF0ZScgfCAnbm9uZScgPSAnY2FuZGlkYXRlJztcbiAgXG4gIGlmIChib3R0bGVuZWNrTW9kZSA9PT0gJ21pbl9vZl9ib3R0bGVuZWNrcycgJiYgcGFyYW1zLmJvdHRsZW5lY2tBbmNob3JzR1d5cikge1xuICAgIGNvbnN0IHsgdHJhbnNmb3JtZXJzLCBzdWJzdGF0aW9ucywgdHgsIGdlbmVyYXRpb24gfSA9IHBhcmFtcy5ib3R0bGVuZWNrQW5jaG9yc0dXeXI7XG4gICAgXG4gICAgY29uc3QgdHJhbnNmb3JtZXJzUmF0ZSA9IGNhbGN1bGF0ZUJvdHRsZW5lY2tSYXRlR1d5cih5ZWFyLCB0cmFuc2Zvcm1lcnMpO1xuICAgIGNvbnN0IHN1YnN0YXRpb25zUmF0ZSA9IGNhbGN1bGF0ZUJvdHRsZW5lY2tSYXRlR1d5cih5ZWFyLCBzdWJzdGF0aW9ucyk7XG4gICAgY29uc3QgdHhSYXRlID0gY2FsY3VsYXRlQm90dGxlbmVja1JhdGVHV3lyKHllYXIsIHR4KTtcbiAgICBjb25zdCBnZW5lcmF0aW9uUmF0ZSA9IGNhbGN1bGF0ZUJvdHRsZW5lY2tSYXRlR1d5cih5ZWFyLCBnZW5lcmF0aW9uKTtcbiAgICBcbiAgICAvLyBGaW5kIG1pbmltdW0gYm90dGxlbmVja1xuICAgIGJvdHRsZW5lY2tSYXRlR1d5ciA9IE1hdGgubWluKHRyYW5zZm9ybWVyc1JhdGUsIHN1YnN0YXRpb25zUmF0ZSwgdHhSYXRlLCBnZW5lcmF0aW9uUmF0ZSk7XG4gICAgXG4gICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGJvdHRsZW5lY2sgaXMgbGltaXRpbmdcbiAgICBpZiAoYm90dGxlbmVja1JhdGVHV3lyID09PSB0cmFuc2Zvcm1lcnNSYXRlKSB7XG4gICAgICBsaW1pdGluZ0JvdHRsZW5lY2sgPSAndHJhbnNmb3JtZXJzJztcbiAgICB9IGVsc2UgaWYgKGJvdHRsZW5lY2tSYXRlR1d5ciA9PT0gc3Vic3RhdGlvbnNSYXRlKSB7XG4gICAgICBsaW1pdGluZ0JvdHRsZW5lY2sgPSAnc3Vic3RhdGlvbnMnO1xuICAgIH0gZWxzZSBpZiAoYm90dGxlbmVja1JhdGVHV3lyID09PSB0eFJhdGUpIHtcbiAgICAgIGxpbWl0aW5nQm90dGxlbmVjayA9ICd0eCc7XG4gICAgfSBlbHNlIGlmIChib3R0bGVuZWNrUmF0ZUdXeXIgPT09IGdlbmVyYXRpb25SYXRlKSB7XG4gICAgICBsaW1pdGluZ0JvdHRsZW5lY2sgPSAnZ2VuZXJhdGlvbic7XG4gICAgfVxuICAgIFxuICAgIC8vIEVmZmVjdGl2ZSBidWlsZCByYXRlIGlzIG1pbmltdW0gb2YgY2FuZGlkYXRlIGFuZCBib3R0bGVuZWNrXG4gICAgYnVpbGRSYXRlR1d5ciA9IE1hdGgubWluKGJ1aWxkUmF0ZUNhbmRpZGF0ZSwgYm90dGxlbmVja1JhdGVHV3lyKTtcbiAgfSBlbHNlIHtcbiAgICBsaW1pdGluZ0JvdHRsZW5lY2sgPSAnbm9uZSc7XG4gIH1cbiAgXG4gIC8vIEFwcGx5IHJhbXAgbGltaXRlciAocHJldmVudCBzdWRkZW4ganVtcHMpXG4gIGNvbnN0IHJhbXBMaW1pdEZyYWMgPSBwYXJhbXMucmFtcExpbWl0RnJhY1BlclllYXIgPz8gMC4yNTtcbiAgaWYgKHByZXZTdGF0ZT8uYnVpbGRSYXRlR1d5ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgcHJldlJhdGUgPSBwcmV2U3RhdGUuYnVpbGRSYXRlR1d5cjtcbiAgICBjb25zdCBtaW5SYXRlID0gcHJldlJhdGUgKiAoMSAtIHJhbXBMaW1pdEZyYWMpO1xuICAgIGNvbnN0IG1heFJhdGUgPSBwcmV2UmF0ZSAqICgxICsgcmFtcExpbWl0RnJhYyk7XG4gICAgYnVpbGRSYXRlR1d5ciA9IE1hdGgubWF4KG1pblJhdGUsIE1hdGgubWluKG1heFJhdGUsIGJ1aWxkUmF0ZUdXeXIpKTtcbiAgfVxuICBcbiAgLy8gQ2FsY3VsYXRlIGNhcGFjaXR5IGV2b2x1dGlvblxuICAvLyBjYXBhY2l0eUd3KHQpID0gY2FwYWNpdHlHdyh0LTEpICsgYnVpbGRSYXRlR3dZZWFyKHQpIC0gcmV0aXJlbWVudHNHdyh0KVxuICBjb25zdCBjYXBhY2l0eUdXUHJldiA9IHByZXZTdGF0ZT8uY2FwYWNpdHlHVyA/PyAwO1xuICBjb25zdCBjYXBhY2l0eUdXID0gY2FwYWNpdHlHV1ByZXYgKyBidWlsZFJhdGVHV3lyIC0gcmV0aXJlbWVudHNHVztcbiAgXG4gIC8vIENhbGN1bGF0ZSBwaXBlbGluZVxuICAvLyBwaXBlbGluZUd3KHQpID0gYnVpbGRSYXRlR3dZZWFyKHQpICogcGlwZWxpbmVMZWFkVGltZVllYXJzICogcGlwZWxpbmVGaWxsRnJhY1xuICBjb25zdCBwaXBlbGluZUdXID0gYnVpbGRSYXRlR1d5ciAqIHBhcmFtcy5waXBlbGluZUxlYWRUaW1lWWVhcnMgKiBwYXJhbXMucGlwZWxpbmVGaWxsRnJhYztcbiAgXG4gIC8vIENhbGN1bGF0ZSBiYWNrbG9nXG4gIC8vIGJhY2tsb2dHdyh0KSA9IG1heCgwLCBiYWNrbG9nR3codC0xKSArIGRlbWFuZE5ld0d3KHQpIC0gYnVpbGRhYmxlR3codCkpXG4gIGNvbnN0IGJhY2tsb2dHV1ByZXYgPSBwcmV2U3RhdGU/LmJhY2tsb2dHVyA/PyAwO1xuICBjb25zdCBidWlsZGFibGVHVyA9IGJ1aWxkUmF0ZUdXeXI7XG4gIGNvbnN0IGJhY2tsb2dHVyA9IE1hdGgubWF4KDAsIGJhY2tsb2dHV1ByZXYgKyBkZW1hbmROZXdHVyAtIGJ1aWxkYWJsZUdXKTtcbiAgXG4gIC8vIEhhcmQgYXNzZXJ0OiBJZiBkZW1hbmROZXdHdyh0KSA+IGJ1aWxkUmF0ZUd3WWVhcih0KSwgYmFja2xvZ0d3IG11c3QgaW5jcmVhc2VcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgaWYgKGRlbWFuZE5ld0dXID4gYnVpbGRSYXRlR1d5ciAmJiBiYWNrbG9nR1cgPD0gYmFja2xvZ0dXUHJldikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgW0JVSUxET1VUIElOVkFSSUFOVF0gWWVhciAke3llYXJ9OiBkZW1hbmROZXdHVz0ke2RlbWFuZE5ld0dXLnRvRml4ZWQoMil9ID4gYCArXG4gICAgICAgIGBidWlsZFJhdGVHV3lyPSR7YnVpbGRSYXRlR1d5ci50b0ZpeGVkKDIpfSwgYnV0IGJhY2tsb2dHVz0ke2JhY2tsb2dHVy50b0ZpeGVkKDIpfSBgICtcbiAgICAgICAgYDw9IHByZXZCYWNrbG9nR1c9JHtiYWNrbG9nR1dQcmV2LnRvRml4ZWQoMil9LiBCYWNrbG9nIG11c3QgaW5jcmVhc2UuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIENhbGN1bGF0ZSBhdmVyYWdlIHdhaXQgdGltZVxuICAvLyBhdmdXYWl0WWVhcnModCkgPSBiYWNrbG9nR3codCkgLyBtYXgoYnVpbGRSYXRlR3dZZWFyKHQpLCAxZS05KVxuICBjb25zdCBFUFMgPSAxZS05O1xuICBjb25zdCBhdmdXYWl0WWVhcnMgPSBiYWNrbG9nR1cgLyBNYXRoLm1heChidWlsZFJhdGVHV3lyLCBFUFMpO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGdyb3d0aCByYXRlIChmb3IgZGVidWcpXG4gIGxldCBkZW1hbmRHcm93dGhSYXRlOiBudW1iZXI7XG4gIGlmICh5ZWFyIDw9IDIwNDApIHtcbiAgICBkZW1hbmRHcm93dGhSYXRlID0gTWF0aC5sb2cocGFyYW1zLmRlbWFuZEFuY2hvcnNHV1syMDQwXSAvIHBhcmFtcy5kZW1hbmRBbmNob3JzR1dbMjAyNV0pIC8gMTU7XG4gIH0gZWxzZSB7XG4gICAgZGVtYW5kR3Jvd3RoUmF0ZSA9IE1hdGgubG9nKHBhcmFtcy5kZW1hbmRBbmNob3JzR1dbMjA2MF0gLyBwYXJhbXMuZGVtYW5kQW5jaG9yc0dXWzIwNDBdKSAvIDIwO1xuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIHllYXIsXG4gICAgZGVtYW5kR1csXG4gICAgZGVtYW5kTmV3R1csXG4gICAgYnVpbGRSYXRlR1d5cixcbiAgICBjYXBhY2l0eUdXLFxuICAgIHBpcGVsaW5lR1csXG4gICAgYmFja2xvZ0dXLFxuICAgIGF2Z1dhaXRZZWFycyxcbiAgICBkZW1hbmRHcm93dGhSYXRlLFxuICAgIGJ1aWxkb3V0U21vb3RoRmFjdG9yOiBwYXJhbXMuYnVpbGRvdXRTbW9vdGhpbmdZZWFycyxcbiAgICBib3R0bGVuZWNrUmF0ZUdXeXIsXG4gICAgbGltaXRpbmdCb3R0bGVuZWNrLFxuICAgIGJ1aWxkUmF0ZUNhbmRpZGF0ZSxcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWZhdWx0IG1vYmlsaXphdGlvbiBzY2VuYXJpbyBwYXJhbWV0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX01PQklMSVpBVElPTl9QQVJBTVM6IE1vYmlsaXphdGlvblNjZW5hcmlvUGFyYW1zID0ge1xuICBkZW1hbmRBbmNob3JzR1c6IHtcbiAgICAyMDI1OiAxMjAsIC8vIEZhY2lsaXR5IGxvYWQgYmFzZWxpbmUgKElUIGxvYWQgKiBQVUUpXG4gICAgMjA0MDogNDUwLCAvLyBUYXJnZXRcbiAgICAyMDYwOiAzMDAwLCAvLyBNdWx0aS1UVyB0YXJnZXRcbiAgfSxcbiAgZGVtYW5kQ3VydmU6ICdwaWVjZXdpc2VfZXhwb25lbnRpYWwnLFxuICBkZW1hbmRJc0ZhY2lsaXR5TG9hZDogdHJ1ZSwgLy8gRGVtYW5kIGlzIGZhY2lsaXR5IGxvYWQgKGluY2x1ZGVzIFBVRSlcbiAgYnVpbGRvdXRBbmNob3JzR1d5cjoge1xuICAgIDIwMjU6IDI1LCAvLyBXYXJ0aW1lIG1vYmlsaXphdGlvbiBleGFtcGxlXG4gICAgMjAzMDogNjAsXG4gICAgMjA0MDogMTQwLFxuICAgIDIwNjA6IDIyMCxcbiAgfSxcbiAgYnVpbGRvdXRTbW9vdGhpbmdZZWFyczogMyxcbiAgcGlwZWxpbmVMZWFkVGltZVllYXJzOiAzLFxuICBwaXBlbGluZUZpbGxGcmFjOiAxLjUsXG4gIGJvdHRsZW5lY2tNb2RlOiAnbWluX29mX2JvdHRsZW5lY2tzJyxcbiAgYm90dGxlbmVja0FuY2hvcnNHV3lyOiB7XG4gICAgdHJhbnNmb3JtZXJzOiB7IDIwMjU6IDMwLCAyMDMwOiA1MCwgMjA0MDogMTAwLCAyMDYwOiAxODAgfSxcbiAgICBzdWJzdGF0aW9uczogeyAyMDI1OiAzNSwgMjAzMDogNTUsIDIwNDA6IDExMCwgMjA2MDogMjAwIH0sXG4gICAgdHg6IHsgMjAyNTogNDAsIDIwMzA6IDY1LCAyMDQwOiAxMzAsIDIwNjA6IDI1MCB9LFxuICAgIGdlbmVyYXRpb246IHsgMjAyNTogNTAsIDIwMzA6IDgwLCAyMDQwOiAxNjAsIDIwNjA6IDMwMCB9LFxuICB9LFxuICByYW1wTGltaXRGcmFjUGVyWWVhcjogMC4yNSwgLy8gMjUlIG1heCBjaGFuZ2UgcGVyIHllYXJcbn07XG5cbiJdLCJuYW1lcyI6WyJjYWxjdWxhdGVQcmljZVJlc3BvbnNpdmVEZW1hbmRHVyIsInllYXIiLCJncm91bmRQcmljZVBlckdwdUhvdXIiLCJvcmJpdGFsUHJpY2VQZXJHcHVIb3VyIiwiYXZnV2FpdFllYXJzIiwicGFyYW1zIiwicHVlIiwieWVhcnNGcm9tMjAyNSIsImdyb3d0aFRhcGVyIiwiTWF0aCIsInRhbmgiLCJiYXNlRGVtYW5kIiwiYmFzZURlbWFuZDIwMjVHVyIsInBvdyIsIm9yZ2FuaWNHcm93dGhSYXRlIiwiYmFzZWxpbmVQcmljZSIsInByaWNlUmF0aW8iLCJwcmljZUZhY3RvciIsInByaWNlRWxhc3RpY2l0eSIsIndhaXRGYWN0b3IiLCJleHAiLCJ3YWl0RWxhc3RpY2l0eSIsIm9yYml0YWxBZHZhbnRhZ2UiLCJtYXgiLCJzdWJzdGl0dXRpb25GYWN0b3IiLCJvcmJpdGFsU3Vic3RpdHV0aW9uVGhyZXNob2xkIiwiZGVtYW5kR1ciLCJjYWxjdWxhdGVEZW1hbmRHVyIsImRlbWFuZEFuY2hvcnNHVyIsImRlbWFuZElzRmFjaWxpdHlMb2FkIiwiZGVtYW5kQ3VydmUiLCJkZW1hbmQyMDI1IiwiZGVtYW5kMjA0MCIsImRlbWFuZDIwNjAiLCJFcnJvciIsInIxIiwibG9nIiwicjIiLCJ5ZWFyc0Zyb20yMDQwIiwicHJvY2VzcyIsImFjdHVhbDIwNDAiLCJlcnJvcjIwNDAiLCJhYnMiLCJ0b0ZpeGVkIiwiY2FsY3VsYXRlQnVpbGRSYXRlR1d5ciIsImJ1aWxkb3V0QW5jaG9yc0dXeXIiLCJidWlsZG91dFNtb290aGluZ1llYXJzIiwiYW5jaG9ycyIsImFuY2hvclllYXJzIiwiT2JqZWN0Iiwia2V5cyIsIm1hcCIsIk51bWJlciIsInNvcnQiLCJhIiwiYiIsImxlbmd0aCIsImxvd2VyWWVhciIsInVwcGVyWWVhciIsImkiLCJsb3dlclJhdGUiLCJ1cHBlclJhdGUiLCJ0IiwiYnVpbGRSYXRlIiwic21vb3RoaW5nV2luZG93Iiwic21vb3RoZWRTdW0iLCJjb3VudCIsImdldFVuc21vb3RoZWRSYXRlIiwieSIsImxvd2VyIiwidXBwZXIiLCJvZmZzZXQiLCJmbG9vciIsInByZXZZZWFyIiwibmV4dFllYXIiLCJwcmV2UmF0ZSIsIm5leHRSYXRlIiwiY2FsY3VsYXRlQm90dGxlbmVja1JhdGVHV3lyIiwic3RlcE1vYmlsaXphdGlvblN0YXRlIiwicHJldlN0YXRlIiwicmV0aXJlbWVudHNHVyIsImRlbWFuZEdXUHJldiIsImRlbWFuZE5ld0dXIiwiYnVpbGRSYXRlQ2FuZGlkYXRlIiwiYm90dGxlbmVja01vZGUiLCJidWlsZFJhdGVHV3lyIiwiYm90dGxlbmVja1JhdGVHV3lyIiwibGltaXRpbmdCb3R0bGVuZWNrIiwiYm90dGxlbmVja0FuY2hvcnNHV3lyIiwidHJhbnNmb3JtZXJzIiwic3Vic3RhdGlvbnMiLCJ0eCIsImdlbmVyYXRpb24iLCJ0cmFuc2Zvcm1lcnNSYXRlIiwic3Vic3RhdGlvbnNSYXRlIiwidHhSYXRlIiwiZ2VuZXJhdGlvblJhdGUiLCJtaW4iLCJyYW1wTGltaXRGcmFjIiwicmFtcExpbWl0RnJhY1BlclllYXIiLCJ1bmRlZmluZWQiLCJtaW5SYXRlIiwibWF4UmF0ZSIsImNhcGFjaXR5R1dQcmV2IiwiY2FwYWNpdHlHVyIsInBpcGVsaW5lR1ciLCJwaXBlbGluZUxlYWRUaW1lWWVhcnMiLCJwaXBlbGluZUZpbGxGcmFjIiwiYmFja2xvZ0dXUHJldiIsImJhY2tsb2dHVyIsImJ1aWxkYWJsZUdXIiwiRVBTIiwiZGVtYW5kR3Jvd3RoUmF0ZSIsImJ1aWxkb3V0U21vb3RoRmFjdG9yIiwiREVGQVVMVF9NT0JJTElaQVRJT05fUEFSQU1TIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/ground_ramping_mobilization.ts\n"));

/***/ })

});