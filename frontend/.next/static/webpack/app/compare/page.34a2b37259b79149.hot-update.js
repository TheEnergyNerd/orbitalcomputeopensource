"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/compare/page",{

/***/ "(app-pages-browser)/./app/lib/model/trajectory.ts":
/*!*************************************!*\
  !*** ./app/lib/model/trajectory.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MARKET_PROVIDERS: function() { return /* binding */ MARKET_PROVIDERS; },\n/* harmony export */   calculateMarketShare: function() { return /* binding */ calculateMarketShare; },\n/* harmony export */   calculateResponsiveDemand: function() { return /* binding */ calculateResponsiveDemand; },\n/* harmony export */   computeTrajectory: function() { return /* binding */ computeTrajectory; },\n/* harmony export */   findCrossoverYear: function() { return /* binding */ findCrossoverYear; },\n/* harmony export */   findCrossoverYearEffectivePflop: function() { return /* binding */ findCrossoverYearEffectivePflop; },\n/* harmony export */   generateFinalAnalysis: function() { return /* binding */ generateFinalAnalysis; },\n/* harmony export */   getDemandNewGW: function() { return /* binding */ getDemandNewGW; },\n/* harmony export */   getDemandProjection: function() { return /* binding */ getDemandProjection; },\n/* harmony export */   getFacilityLoadGW: function() { return /* binding */ getFacilityLoadGW; },\n/* harmony export */   getITLoadGW: function() { return /* binding */ getITLoadGW; },\n/* harmony export */   projectMarketPrice: function() { return /* binding */ projectMarketPrice; }\n/* harmony export */ });\n/* harmony import */ var _physicsCost__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./physicsCost */ \"(app-pages-browser)/./app/lib/model/physicsCost.ts\");\n/* harmony import */ var _launch_learning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./launch_learning */ \"(app-pages-browser)/./app/lib/model/launch_learning.ts\");\n/* harmony import */ var _modes_static__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modes/static */ \"(app-pages-browser)/./app/lib/model/modes/static.ts\");\n/* harmony import */ var _monteCarloCrossover__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./monteCarloCrossover */ \"(app-pages-browser)/./app/lib/model/monteCarloCrossover.ts\");\n\n\n\n\n/**\n * Find crossover year using GPU-hour pricing (preferred, includes scarcity)\n * Uses scarcity-inclusive comparator consistently\n */ function findCrossoverYear(trajectory) {\n    const crossing = trajectory.find((d)=>{\n        var _d_ground_constraints, _d_ground_constraints1;\n        var _d_ground_totalCostPerPflopYearEffective;\n        // Use effective ground cost (includes delayPenalty + scarcityRent) for crossover\n        const groundEffectiveCost = (_d_ground_totalCostPerPflopYearEffective = d.ground.totalCostPerPflopYearEffective) !== null && _d_ground_totalCostPerPflopYearEffective !== void 0 ? _d_ground_totalCostPerPflopYearEffective : d.ground.totalCostPerPflopYear + (((_d_ground_constraints = d.ground.constraints) === null || _d_ground_constraints === void 0 ? void 0 : _d_ground_constraints.delayPenalty) || 0) + (((_d_ground_constraints1 = d.ground.constraints) === null || _d_ground_constraints1 === void 0 ? void 0 : _d_ground_constraints1.scarcityRentPerPflopYear) || 0);\n        var _d_orbit_totalCostPerPflopYearEffective;\n        const orbitCost = (_d_orbit_totalCostPerPflopYearEffective = d.orbit.totalCostPerPflopYearEffective) !== null && _d_orbit_totalCostPerPflopYearEffective !== void 0 ? _d_orbit_totalCostPerPflopYearEffective : d.orbit.totalCostPerPflopYear;\n        return Number.isFinite(orbitCost) && Number.isFinite(groundEffectiveCost) && orbitCost < groundEffectiveCost;\n    });\n    return crossing ? crossing.year : null;\n}\n/**\n * Find crossover year using effective PFLOP-year cost (includes scarcity adders)\n * Uses scarcity-inclusive comparator: delayPenalty + scarcityRent\n * capacityDeliveryPremium is engineering cost, not scarcity pricing\n */ function findCrossoverYearEffectivePflop(trajectory) {\n    const crossing = trajectory.find((d)=>{\n        var _d_ground_constraints, _d_ground_constraints1;\n        var _d_ground_totalCostPerPflopYearEffective;\n        // Ground effective cost includes: base + delayPenalty + scarcityRent\n        const groundEffectiveCost = (_d_ground_totalCostPerPflopYearEffective = d.ground.totalCostPerPflopYearEffective) !== null && _d_ground_totalCostPerPflopYearEffective !== void 0 ? _d_ground_totalCostPerPflopYearEffective : d.ground.totalCostPerPflopYear + (((_d_ground_constraints = d.ground.constraints) === null || _d_ground_constraints === void 0 ? void 0 : _d_ground_constraints.delayPenalty) || 0) + (((_d_ground_constraints1 = d.ground.constraints) === null || _d_ground_constraints1 === void 0 ? void 0 : _d_ground_constraints1.scarcityRentPerPflopYear) || 0);\n        var _d_orbit_totalCostPerPflopYearEffective;\n        const orbitCost = (_d_orbit_totalCostPerPflopYearEffective = d.orbit.totalCostPerPflopYearEffective) !== null && _d_orbit_totalCostPerPflopYearEffective !== void 0 ? _d_orbit_totalCostPerPflopYearEffective : d.orbit.totalCostPerPflopYear;\n        return orbitCost < groundEffectiveCost;\n    });\n    return crossing ? crossing.year : null;\n}\n// Calculate market share based on cost ratio\n// When orbital is 50% cheaper, it gets ~80% of NEW capacity\n// When orbital is 2x more expensive, it gets ~5% (niche applications)\nfunction calculateMarketShare(year, orbitalCostPerPflop, groundCostPerPflop, totalDemandGW) {\n    let orbitalFeasible = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true, groundFeasible = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true, orbitalCostAccountingValid = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : true, groundCostAccountingValid = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : true, // Additional parameters for served compute calculation\n    demandGW = arguments.length > 8 ? arguments[8] : void 0, backlogGW = arguments.length > 9 ? arguments[9] : void 0, buildRateGWyr = arguments.length > 10 ? arguments[10] : void 0, avgWaitYears = arguments.length > 11 ? arguments[11] : void 0, orbitMaxDeployableComputeGW // Maximum orbital capacity (from launch/manufacturing constraints)\n     = arguments.length > 12 ? arguments[12] : void 0;\n    // CRITICAL FIX: Feasibility gating\n    // Check if both systems are feasible before computing shares\n    const orbitalActuallyFeasible = orbitalFeasible && orbitalCostAccountingValid;\n    const groundActuallyFeasible = groundFeasible && groundCostAccountingValid;\n    // If neither is feasible, default to ground (conservative)\n    if (!orbitalActuallyFeasible && !groundActuallyFeasible) {\n        return {\n            year,\n            totalDemandGW,\n            orbitalShareFrac: 0,\n            orbitalCapacityGW: 0,\n            orbitalRevenue: 0,\n            groundShareFrac: 1.0,\n            groundCapacityGW: totalDemandGW,\n            debug: {\n                shareConvention: \"frac\",\n                orbitalFeasible: false,\n                groundFeasible: false,\n                orbitalShareFrac: 0,\n                groundShareFrac: 1.0,\n                orbitalCapacityGW: 0,\n                groundCapacityGW: totalDemandGW,\n                orbitalRevenue: 0,\n                groundRevenue: totalDemandGW * 2e9\n            }\n        };\n    }\n    // If only one is feasible, it gets 100%\n    if (!orbitalActuallyFeasible) {\n        return {\n            year,\n            totalDemandGW,\n            orbitalShareFrac: 0,\n            orbitalCapacityGW: 0,\n            orbitalRevenue: 0,\n            groundShareFrac: 1.0,\n            groundCapacityGW: totalDemandGW,\n            debug: {\n                shareConvention: \"frac\",\n                orbitalFeasible: false,\n                groundFeasible: true,\n                orbitalShareFrac: 0,\n                groundShareFrac: 1.0,\n                orbitalCapacityGW: 0,\n                groundCapacityGW: totalDemandGW,\n                orbitalRevenue: 0,\n                groundRevenue: totalDemandGW * 2e9\n            }\n        };\n    }\n    if (!groundActuallyFeasible) {\n        return {\n            year,\n            totalDemandGW,\n            orbitalShareFrac: 1.0,\n            orbitalCapacityGW: totalDemandGW,\n            orbitalRevenue: totalDemandGW * 2e9,\n            groundShareFrac: 0,\n            groundCapacityGW: 0,\n            debug: {\n                shareConvention: \"frac\",\n                orbitalFeasible: true,\n                groundFeasible: false,\n                orbitalShareFrac: 1.0,\n                groundShareFrac: 0,\n                orbitalCapacityGW: totalDemandGW,\n                groundCapacityGW: 0,\n                orbitalRevenue: totalDemandGW * 2e9,\n                groundRevenue: 0\n            }\n        };\n    }\n    // Hard rules: shares are always 0..1 fractions, served compute cannot exceed feasible compute\n    const demand = demandGW !== null && demandGW !== void 0 ? demandGW : totalDemandGW;\n    const backlogGWActual = backlogGW !== null && backlogGW !== void 0 ? backlogGW : 0;\n    const buildRateGWyrActual = buildRateGWyr !== null && buildRateGWyr !== void 0 ? buildRateGWyr : 0;\n    const avgWaitYearsActual = avgWaitYears !== null && avgWaitYears !== void 0 ? avgWaitYears : 0;\n    // HARD FEASIBILITY GATING: If avgWaitYears > 3 OR backlog > 25% of demand, ground cannot serve all marginal demand\n    // This forces spillover to orbital earlier, making crossover happen the right way (feasibility, not fake pricing)\n    const groundHasSevereQueue = avgWaitYearsActual > 3 || backlogGWActual > 0.25 * demand;\n    // Ground feasible capacity: reduced by queue pressure\n    const groundFeasibleGW = groundActuallyFeasible ? groundHasSevereQueue ? Math.max(0, demand * 0.5 - backlogGWActual) // Severe queue: ground can only serve 50% of demand\n     : Math.max(0, demand - backlogGWActual) // Normal: ground can serve demand minus backlog\n     : 0;\n    // Orbital feasible capacity: can serve remainder (up to max deployable)\n    const orbitFeasibleGW = orbitalActuallyFeasible ? Math.min(demand - groundFeasibleGW, orbitMaxDeployableComputeGW !== null && orbitMaxDeployableComputeGW !== void 0 ? orbitMaxDeployableComputeGW : demand) : 0;\n    const maxServable = Math.min(demand, groundFeasibleGW + orbitFeasibleGW);\n    // Compute desired shares (0..1) from cost ratios (logit model)\n    const costRatio = orbitalCostPerPflop / groundCostPerPflop;\n    const logitFactor = Math.exp(-5 * (costRatio - 1)); // When orbital is 50% cheaper, it gets ~80% of NEW capacity\n    const orbitalShareFracDesired = logitFactor / (1 + logitFactor);\n    const groundShareFracDesired = 1 - orbitalShareFracDesired;\n    // Convert to served, then clamp by feasibility\n    let orbitServed = orbitalShareFracDesired * maxServable;\n    let groundServed = groundShareFracDesired * maxServable;\n    orbitServed = Math.min(orbitServed, orbitFeasibleGW);\n    groundServed = Math.min(groundServed, groundFeasibleGW);\n    // If clamping reduced one side, reassign remainder if possible\n    const remainder = maxServable - (orbitServed + groundServed);\n    if (remainder > 0) {\n        const orbitRoom = orbitFeasibleGW - orbitServed;\n        const groundRoom = groundFeasibleGW - groundServed;\n        const addToOrbit = Math.min(remainder, Math.max(0, orbitRoom));\n        orbitServed += addToOrbit;\n        groundServed += Math.min(remainder - addToOrbit, Math.max(0, groundRoom));\n    }\n    // Recalculate shares from actual served (ensures shares are 0..1 and sum to 1)\n    const totalServedGW = orbitServed + groundServed;\n    const orbitalShareFrac = totalServedGW > 0 ? orbitServed / totalServedGW : 0;\n    const groundShareFrac = totalServedGW > 0 ? groundServed / totalServedGW : 0;\n    // Use served values for capacity\n    const groundServedComputeGW = groundServed;\n    const orbitServedComputeGW = orbitServed;\n    const groundFeasibleComputeGW = groundFeasibleGW;\n    const orbitFeasibleComputeGW = orbitFeasibleGW;\n    // Capacity served (GW)\n    const orbitalCapacityGW = orbitServedComputeGW;\n    const groundCapacityGW = groundServedComputeGW;\n    // Revenue per GW (assume $2B/GW/year for compute services)\n    const revenuePerGW = 2e9;\n    const orbitalRevenue = orbitalCapacityGW * revenuePerGW;\n    const groundRevenue = groundCapacityGW * revenuePerGW;\n    // Invariants\n    if (orbitalCapacityGW === 0 && orbitalRevenue !== 0) {\n        throw new Error(\"orbitalCapacityGW=0 but orbitalRevenue=\".concat(orbitalRevenue, \" > 0\"));\n    }\n    if (orbitalRevenue > 0 && orbitalCapacityGW <= 0) {\n        throw new Error(\"orbitalRevenue=\".concat(orbitalRevenue, \" > 0 but orbitalCapacityGW=\").concat(orbitalCapacityGW, \" <= 0\"));\n    }\n    if (orbitFeasibleComputeGW === 0 && orbitalShareFrac !== 0) {\n        throw new Error(\"orbitFeasibleComputeGW=0 but orbitalShareFrac=\".concat(orbitalShareFrac, \" > 0\"));\n    }\n    // Shares should sum to 1.0 when both feasible and totalServed > 0\n    if (totalServedGW > 0) {\n        const shareSum = orbitalShareFrac + groundShareFrac;\n        if (Math.abs(shareSum - 1.0) > 1e-6) {\n            throw new Error(\"Market share sum must equal 1.0, got \".concat(shareSum, \" (orbital=\").concat(orbitalShareFrac, \", ground=\").concat(groundShareFrac, \")\"));\n        }\n    }\n    return {\n        year,\n        totalDemandGW,\n        orbitalShareFrac,\n        orbitalCapacityGW,\n        orbitalRevenue,\n        groundShareFrac,\n        groundCapacityGW,\n        debug: {\n            shareConvention: \"frac\",\n            orbitalFeasible: true,\n            groundFeasible: true,\n            orbitalShareFrac,\n            groundShareFrac,\n            orbitalCapacityGW,\n            groundCapacityGW,\n            orbitalRevenue,\n            groundRevenue,\n            demandComputeGW: demand,\n            groundServedComputeGW,\n            orbitServedComputeGW,\n            groundFeasibleComputeGW,\n            orbitFeasibleComputeGW,\n            backlogGW: backlogGWActual,\n            buildRateGWyr: buildRateGWyrActual,\n            avgWaitYears: avgWaitYears !== null && avgWaitYears !== void 0 ? avgWaitYears : 0\n        }\n    };\n}\nfunction projectMarketPrice(basePrice, baseYear, targetYear) {\n    let annualDeclineRate = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.10;\n    const years = targetYear - baseYear;\n    return basePrice * Math.pow(1 - annualDeclineRate, years);\n}\nconst MARKET_PROVIDERS = [\n    {\n        name: \"AWS H100\",\n        price: 4.50,\n        decline: 0.10\n    },\n    {\n        name: \"Azure H100\",\n        price: 4.00,\n        decline: 0.10\n    },\n    {\n        name: \"CoreWeave\",\n        price: 2.23,\n        decline: 0.12\n    },\n    {\n        name: \"Lambda Labs\",\n        price: 2.49,\n        decline: 0.10\n    }\n];\n// ============================================================================\n// DEMAND MODEL: Installed IT Load (GW) with Piecewise Exponential Growth\n// ============================================================================\n// \n// Model: IT_GW(t) = installed IT load in GW\n// Targets:\n//   - IT_GW(2025) = IT0 (baseline)\n//   - IT_GW(2040) = 450 GW\n//   - IT_GW(2060) = 3000 GW (multi-TW by 2060)\n//\n// Piecewise exponential:\n//   - 2025-2040: IT_GW(t) = IT0 * exp(r1 * (t - 2025))\n//   - 2040-2060: IT_GW(t) = IT_GW(2040) * exp(r2 * (t - 2040))\n//\n// Then derive:\n//   - Facility_GW(t) = IT_GW(t) * PUE(t)  (hits transmission/substation constraints)\n//   - DemandNewGW(t) = max(0, Facility_GW(t) - Facility_GW(t-1))\n// LEGACY: Hardcoded demand anchors (kept for backward compatibility, but replaced by responsive demand)\nconst IT_GW_2025 = 120; // Baseline installed IT load in 2025 (GW)\nconst IT_GW_2040_TARGET = 450; // Target installed IT load in 2040 (GW)\nconst IT_GW_2060_TARGET = 3000; // Target installed IT load in 2060 (GW)\n// Calculate growth rates\nconst R1 = Math.log(IT_GW_2040_TARGET / IT_GW_2025) / 15; // Growth rate 2025-2040\nconst R2 = Math.log(IT_GW_2060_TARGET / IT_GW_2040_TARGET) / 20; // Growth rate 2040-2060\n/**\n * Calculate price-responsive demand that creates S-curve\n * \n * Demand responds to:\n * - Price elasticity: higher ground prices reduce demand\n * - Wait elasticity: longer waits reduce demand\n * - Orbital substitution: if orbital cheaper, demand shifts\n */ function calculateResponsiveDemand(year, groundPricePerGpuHour, orbitalPricePerGpuHour, avgWaitYears, prevDemandState) {\n    // Baseline demand: 10% CAGR from 120 GW, TAPERED after 20 years\n    const yearsFrom2025 = year - 2025;\n    const growthRate = 0.10; // 10% CAGR\n    const taper = 1 / (1 + Math.exp((yearsFrom2025 - 20) / 5)); // Tapers after 2045\n    const effectiveGrowth = growthRate * (0.5 + 0.5 * taper); // 10% -> 5% CAGR\n    const baselineGW = 120 * Math.pow(1 + effectiveGrowth, yearsFrom2025);\n    // Price elasticity: demand drops as ground price rises\n    const baselinePrice = 4.00; // $/GPU-hr reference\n    const priceRatio = groundPricePerGpuHour / baselinePrice;\n    const priceElasticity = -0.3; // 30% drop per 100% price increase\n    const priceFactor = Math.pow(priceRatio, priceElasticity);\n    // Wait elasticity: demand drops with longer waits\n    const waitElasticity = -0.15; // 15% drop per 5yr wait\n    const waitFactor = Math.exp(avgWaitYears * waitElasticity / 5);\n    // Effective total demand (may shift to orbital)\n    const effectiveGW = baselineGW * priceFactor * waitFactor;\n    // Orbital substitution: if orbital < ground, demand shifts\n    const groundOrbitalRatio = groundPricePerGpuHour / Math.max(orbitalPricePerGpuHour, 0.01);\n    let orbitalShare = 0;\n    if (groundOrbitalRatio > 1.0) {\n        // Orbital is cheaper - logistic shift\n        // At ratio 1.5 (ground 50% more): ~30% shifts to orbital\n        // At ratio 2.0 (ground 100% more): ~60% shifts to orbital\n        orbitalShare = 1 / (1 + Math.exp(-2 * (groundOrbitalRatio - 1.3)));\n    }\n    const orbitalDemandGW = effectiveGW * orbitalShare;\n    const groundDemandGW = effectiveGW * (1 - orbitalShare);\n    return {\n        year,\n        baselineGW,\n        effectiveGW,\n        groundDemandGW,\n        orbitalDemandGW\n    };\n}\n/**\n * Calculate installed IT load (GW) for a given year\n */ function getITLoadGW(year) {\n    if (year < 2025) {\n        return IT_GW_2025;\n    }\n    if (year <= 2040) {\n        // Phase 1: 2025-2040\n        const yearsFrom2025 = year - 2025;\n        return IT_GW_2025 * Math.exp(R1 * yearsFrom2025);\n    }\n    // Phase 2: 2040-2060\n    const yearsFrom2040 = year - 2040;\n    return IT_GW_2040_TARGET * Math.exp(R2 * yearsFrom2040);\n}\n/**\n * Calculate facility load (GW) = IT load * PUE\n */ function getFacilityLoadGW(year) {\n    let pue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1.3;\n    const itLoadGW = getITLoadGW(year);\n    return itLoadGW * pue;\n}\n/**\n * Calculate new demand (GW) = max(0, Facility_GW(t) - Facility_GW(t-1))\n */ function getDemandNewGW(year) {\n    let pue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1.3;\n    const facilityGW = getFacilityLoadGW(year, pue);\n    const facilityGWPrev = getFacilityLoadGW(year - 1, pue);\n    return Math.max(0, facilityGW - facilityGWPrev);\n}\n/**\n * Legacy function: returns IT load (not facility load)\n * Kept for backward compatibility\n */ function getDemandProjection(year) {\n    return getITLoadGW(year);\n}\nfunction computeTrajectory(options) {\n    // Re-export crossover analysis functions for convenience\n    // Users can import from trajectory.ts or crossoverAnalysis.ts\n    const years = Array.from({\n        length: 26\n    }, (_, i)=>2025 + i); // 2025-2050 (26 years)\n    const trajectory = [];\n    let firstCapYear = null; // Track when constraint cap was first hit\n    // Launch learning: Track cumulative mass to orbit\n    let launchLearningState = null;\n    const BASELINE_MASS_KG = 1000000; // 1M kg baseline for doublings calculation\n    const LAUNCH_COST_0_PER_KG = 1500; // Initial launch cost in 2025\n    // Responsive demand: Track demand state across years for S-curve behavior\n    let prevDemandState = null;\n    let prevYearBreakdown = null;\n    // Buildout state: Track across years for backlog calculation\n    let buildoutState = null;\n    // Mobilization state: Track across years for capacity/backlog evolution\n    let mobilizationState = null;\n    for (const year of years){\n        var _breakdown_ground, _prevYearBreakdown_ground_gpuHourPricing_standard, _prevYearBreakdown_ground_gpuHourPricing, _prevYearBreakdown_ground, _prevYearBreakdown_orbit_gpuHourPricing_standard, _prevYearBreakdown_orbit_gpuHourPricing, _prevYearBreakdown_orbit, _prevYearBreakdown_ground_supplyMetrics, _prevYearBreakdown_ground1, _breakdown_ground1, _breakdown_orbit_constellation, _breakdown_orbit, _breakdown_metadata_chartInputs, _breakdown_metadata, _breakdown_ground2, _breakdown_ground_buildoutDebug, _breakdown_ground3, _breakdown_ground_buildoutDebug1, _breakdown_ground4, _breakdown_ground_supplyMetrics, _breakdown_ground5, _breakdown_ground6, _breakdown_ground_buildoutDebug2, _breakdown_ground7, _breakdown_ground_supplyMetrics1, _breakdown_ground8, _params_orbitMaxDeployableComputeGWByYear, _breakdown_ground9;\n        const params = options.mode === \"STATIC\" ? (0,_modes_static__WEBPACK_IMPORTED_MODULE_2__.getStaticParams)(year) : options.paramsByYear(year);\n        // Apply launch learning if enabled\n        let launchCostPerKg = (0,_physicsCost__WEBPACK_IMPORTED_MODULE_0__.getLaunchCostPerKg)(year, params.launchCostKg);\n        let paramsWithLaunchCost = params;\n        if (options.useLaunchLearning) {\n            // Estimate mass demanded from compute power: ~1000 kg per MW compute\n            // Use targetGW as proxy for orbital compute demand\n            const computePowerMW = params.targetGW * 1000; // Convert GW to MW\n            const massPerMW = 1000; // Rough estimate: 1000 kg per MW\n            const massDemandedKg = computePowerMW * massPerMW;\n            const launchLearningResult = (0,_launch_learning__WEBPACK_IMPORTED_MODULE_1__.stepLaunchLearning)(launchLearningState, {\n                year,\n                massDemandedKg,\n                baselineMassKg: BASELINE_MASS_KG,\n                launchCost0PerKg: LAUNCH_COST_0_PER_KG,\n                learningRate: 0.15,\n                maxFlightsPerYear: 1000,\n                payloadPerFlightKg: 100000\n            });\n            launchCostPerKg = launchLearningResult.launchCostPerKg;\n            launchLearningState = launchLearningResult.state;\n            // Override launch cost in params for this year\n            paramsWithLaunchCost = {\n                ...params,\n                launchCostKg: launchCostPerKg\n            };\n        }\n        // Pass firstCapYear and mobilizationState to computePhysicsCost\n        // Add mobilization state to params so it can be used for backlog calculation\n        const paramsWithMobilization = {\n            ...paramsWithLaunchCost,\n            prevMobilizationState: mobilizationState\n        }; // Type assertion needed since YearParams doesn't include prevMobilizationState\n        const breakdown = (0,_physicsCost__WEBPACK_IMPORTED_MODULE_0__.computePhysicsCost)(paramsWithMobilization, firstCapYear);\n        // Update launch learning state with actual mass from breakdown (for next iteration)\n        if (options.useLaunchLearning && breakdown.orbit && breakdown.orbit.hybridBreakdown) {\n        // Use actual mass from hybrid breakdown if available\n        // Mass is not directly in orbital breakdown, but we can estimate from launch cost\n        // For now, use the mass demanded estimate (will be refined in next iteration)\n        }\n        const constraintBreakdown = breakdown.ground.constraintBreakdown;\n        if (constraintBreakdown && \"capYear\" in constraintBreakdown && constraintBreakdown.capYear !== null && constraintBreakdown.capYear !== undefined) {\n            const thisCapYear = constraintBreakdown.capYear;\n            if (firstCapYear === null || thisCapYear < firstCapYear) {\n                firstCapYear = thisCapYear;\n            }\n        }\n        var _breakdown_ground_pue, _ref;\n        // SINGLE SOURCE OF TRUTH: compute demand in GW using RESPONSIVE demand\n        // Demand responds to prices, wait times, and orbital substitution (creates S-curve)\n        const groundPue = (_ref = (_breakdown_ground_pue = (_breakdown_ground = breakdown.ground) === null || _breakdown_ground === void 0 ? void 0 : _breakdown_ground.pue) !== null && _breakdown_ground_pue !== void 0 ? _breakdown_ground_pue : params.pueGround) !== null && _ref !== void 0 ? _ref : 1.3;\n        var _prevYearBreakdown_ground_gpuHourPricing_standard_pricePerGpuHour;\n        // Get prices from previous year (or estimates for first year)\n        const prevGroundPrice = (_prevYearBreakdown_ground_gpuHourPricing_standard_pricePerGpuHour = prevYearBreakdown === null || prevYearBreakdown === void 0 ? void 0 : (_prevYearBreakdown_ground = prevYearBreakdown.ground) === null || _prevYearBreakdown_ground === void 0 ? void 0 : (_prevYearBreakdown_ground_gpuHourPricing = _prevYearBreakdown_ground.gpuHourPricing) === null || _prevYearBreakdown_ground_gpuHourPricing === void 0 ? void 0 : (_prevYearBreakdown_ground_gpuHourPricing_standard = _prevYearBreakdown_ground_gpuHourPricing.standard) === null || _prevYearBreakdown_ground_gpuHourPricing_standard === void 0 ? void 0 : _prevYearBreakdown_ground_gpuHourPricing_standard.pricePerGpuHour) !== null && _prevYearBreakdown_ground_gpuHourPricing_standard_pricePerGpuHour !== void 0 ? _prevYearBreakdown_ground_gpuHourPricing_standard_pricePerGpuHour : 4.00;\n        var _prevYearBreakdown_orbit_gpuHourPricing_standard_pricePerGpuHour;\n        const prevOrbitalPrice = (_prevYearBreakdown_orbit_gpuHourPricing_standard_pricePerGpuHour = prevYearBreakdown === null || prevYearBreakdown === void 0 ? void 0 : (_prevYearBreakdown_orbit = prevYearBreakdown.orbit) === null || _prevYearBreakdown_orbit === void 0 ? void 0 : (_prevYearBreakdown_orbit_gpuHourPricing = _prevYearBreakdown_orbit.gpuHourPricing) === null || _prevYearBreakdown_orbit_gpuHourPricing === void 0 ? void 0 : (_prevYearBreakdown_orbit_gpuHourPricing_standard = _prevYearBreakdown_orbit_gpuHourPricing.standard) === null || _prevYearBreakdown_orbit_gpuHourPricing_standard === void 0 ? void 0 : _prevYearBreakdown_orbit_gpuHourPricing_standard.pricePerGpuHour) !== null && _prevYearBreakdown_orbit_gpuHourPricing_standard_pricePerGpuHour !== void 0 ? _prevYearBreakdown_orbit_gpuHourPricing_standard_pricePerGpuHour : 25.00;\n        var _prevYearBreakdown_ground_supplyMetrics_avgWaitYears;\n        const prevAvgWait = (_prevYearBreakdown_ground_supplyMetrics_avgWaitYears = prevYearBreakdown === null || prevYearBreakdown === void 0 ? void 0 : (_prevYearBreakdown_ground1 = prevYearBreakdown.ground) === null || _prevYearBreakdown_ground1 === void 0 ? void 0 : (_prevYearBreakdown_ground_supplyMetrics = _prevYearBreakdown_ground1.supplyMetrics) === null || _prevYearBreakdown_ground_supplyMetrics === void 0 ? void 0 : _prevYearBreakdown_ground_supplyMetrics.avgWaitYears) !== null && _prevYearBreakdown_ground_supplyMetrics_avgWaitYears !== void 0 ? _prevYearBreakdown_ground_supplyMetrics_avgWaitYears : 0;\n        // Calculate responsive demand (price/wait elastic, orbital substitution)\n        const demandState = calculateResponsiveDemand(year, prevGroundPrice, prevOrbitalPrice, prevAvgWait, prevDemandState);\n        prevDemandState = demandState;\n        // Use responsive ground demand (facility load = ground demand * PUE)\n        const demandComputeGW = demandState.groundDemandGW * groundPue; // Convert IT load to facility load\n        const orbitalDemandGW = demandState.orbitalDemandGW * groundPue; // For orbital capacity planning\n        // CRITICAL: Ensure ground.buildoutDebug.demandGW matches single source of truth\n        // Override any value from buildout model to ensure consistency\n        if ((_breakdown_ground1 = breakdown.ground) === null || _breakdown_ground1 === void 0 ? void 0 : _breakdown_ground1.buildoutDebug) {\n            breakdown.ground.buildoutDebug.demandGW = demandComputeGW;\n        }\n        // Use demandComputeGW for all market calculations (single source of truth)\n        const totalDemandGW = demandComputeGW;\n        const orbitalFeasible = breakdown.orbit && breakdown.orbit.totalCostPerPflopYear > 0 && breakdown.orbit.totalCostPerPflopYear < Infinity;\n        const groundFeasible = breakdown.ground && breakdown.ground.totalCostPerPflopYear > 0 && breakdown.ground.totalCostPerPflopYear < Infinity;\n        const orbitalCostAccountingValid = breakdown.costAccountingValid !== false;\n        const groundCostAccountingValid = breakdown.costAccountingValid !== false;\n        // Calculate orbital capacity GW from constellation: (numSatellites * computePerSatKw) / 1e6\n        // kW -> GW conversion: divide by 1,000,000 (1e6)\n        // CRITICAL: computePerSatKw is in kW, so divide by 1e6 to get GW (not 1e3 for MW)\n        let orbitalCapacityGW_fromSats = 0;\n        if ((_breakdown_orbit = breakdown.orbit) === null || _breakdown_orbit === void 0 ? void 0 : (_breakdown_orbit_constellation = _breakdown_orbit.constellation) === null || _breakdown_orbit_constellation === void 0 ? void 0 : _breakdown_orbit_constellation.design) {\n            const { numSatellites, computePerSatKw } = breakdown.orbit.constellation.design;\n            // kW -> GW: divide by 1,000,000 (1e6), NOT 1,000 (1e3)\n            orbitalCapacityGW_fromSats = numSatellites * computePerSatKw / 1000000;\n            // Invariant: 1 satellite at 111 kW should be 0.000111 GW, not 1.144 GW\n            if ( true && numSatellites === 1) {\n                const expectedGW = computePerSatKw / 1000000;\n                const error = Math.abs(orbitalCapacityGW_fromSats - expectedGW) / Math.max(expectedGW, 1e-9);\n                if (error > 0.01) {\n                    throw new Error(\"[ORBITAL CAPACITY BUG] Year \".concat(year, \": 1 satellite at \").concat(computePerSatKw, \" kW should be \").concat(expectedGW, \" GW, \") + \"but got \".concat(orbitalCapacityGW_fromSats, \" GW. Check kW->GW conversion (must divide by 1e6, not 1e3).\"));\n                }\n            }\n        }\n        const chartPB = (_breakdown_metadata = breakdown.metadata) === null || _breakdown_metadata === void 0 ? void 0 : (_breakdown_metadata_chartInputs = _breakdown_metadata.chartInputs) === null || _breakdown_metadata_chartInputs === void 0 ? void 0 : _breakdown_metadata_chartInputs.powerBuildout;\n        const chartBacklog = chartPB === null || chartPB === void 0 ? void 0 : chartPB.backlogGw;\n        const chartAvgWait = chartPB === null || chartPB === void 0 ? void 0 : chartPB.avgWaitYears;\n        const chartBuildRate = chartPB === null || chartPB === void 0 ? void 0 : chartPB.maxBuildRateGwYear;\n        // Prefer buildoutDebug when present.\n        // If ground/backlog fields exist but are 0 while chartInputs says >0, use chartInputs.\n        // Remove the pipelineGw proxy entirely (it's not backlog and causes silent unit/meaning corruption).\n        const backlogFromGround = (_breakdown_ground2 = breakdown.ground) === null || _breakdown_ground2 === void 0 ? void 0 : _breakdown_ground2.backlogGw;\n        const backlogFromBuildout = (_breakdown_ground3 = breakdown.ground) === null || _breakdown_ground3 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug = _breakdown_ground3.buildoutDebug) === null || _breakdown_ground_buildoutDebug === void 0 ? void 0 : _breakdown_ground_buildoutDebug.backlogGW;\n        var _ref1, _ref2;\n        let backlogGW = (_ref2 = (_ref1 = backlogFromBuildout !== undefined ? backlogFromBuildout : undefined) !== null && _ref1 !== void 0 ? _ref1 : backlogFromGround !== undefined && backlogFromGround > 0 ? backlogFromGround : undefined) !== null && _ref2 !== void 0 ? _ref2 : chartBacklog !== undefined && chartBacklog > 0 ? chartBacklog : 0;\n        const buildRateFromBuildout = (_breakdown_ground4 = breakdown.ground) === null || _breakdown_ground4 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug1 = _breakdown_ground4.buildoutDebug) === null || _breakdown_ground_buildoutDebug1 === void 0 ? void 0 : _breakdown_ground_buildoutDebug1.buildRateGWyr;\n        const buildRateFromSupply = (_breakdown_ground5 = breakdown.ground) === null || _breakdown_ground5 === void 0 ? void 0 : (_breakdown_ground_supplyMetrics = _breakdown_ground5.supplyMetrics) === null || _breakdown_ground_supplyMetrics === void 0 ? void 0 : _breakdown_ground_supplyMetrics.maxBuildRateGwYear;\n        var _ref3, _ref4;\n        const buildRateGWyr = (_ref4 = (_ref3 = buildRateFromBuildout !== undefined ? buildRateFromBuildout : undefined) !== null && _ref3 !== void 0 ? _ref3 : buildRateFromSupply !== undefined ? buildRateFromSupply : undefined) !== null && _ref4 !== void 0 ? _ref4 : chartBuildRate !== undefined ? chartBuildRate : 0;\n        const avgWaitFromGround = (_breakdown_ground6 = breakdown.ground) === null || _breakdown_ground6 === void 0 ? void 0 : _breakdown_ground6.avgWaitYears;\n        const avgWaitFromBuildout = (_breakdown_ground7 = breakdown.ground) === null || _breakdown_ground7 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug2 = _breakdown_ground7.buildoutDebug) === null || _breakdown_ground_buildoutDebug2 === void 0 ? void 0 : _breakdown_ground_buildoutDebug2.timeToPowerYears;\n        const avgWaitFromSupply = (_breakdown_ground8 = breakdown.ground) === null || _breakdown_ground8 === void 0 ? void 0 : (_breakdown_ground_supplyMetrics1 = _breakdown_ground8.supplyMetrics) === null || _breakdown_ground_supplyMetrics1 === void 0 ? void 0 : _breakdown_ground_supplyMetrics1.avgWaitYears;\n        var _ref5, _ref6, _ref7;\n        let avgWaitYears = (_ref7 = (_ref6 = (_ref5 = avgWaitFromBuildout !== undefined ? avgWaitFromBuildout : undefined) !== null && _ref5 !== void 0 ? _ref5 : avgWaitFromGround !== undefined && avgWaitFromGround > 0 ? avgWaitFromGround : undefined) !== null && _ref6 !== void 0 ? _ref6 : avgWaitFromSupply !== undefined && avgWaitFromSupply > 0 ? avgWaitFromSupply : undefined) !== null && _ref7 !== void 0 ? _ref7 : chartAvgWait !== undefined && chartAvgWait > 0 ? chartAvgWait : 0;\n        // Self-heal plumbing mismatches: if chartInputs has positive value but chosen is 0, use chartInputs\n        // Log structured error but never throw (prevents chart from disappearing)\n        if ((chartBacklog !== null && chartBacklog !== void 0 ? chartBacklog : 0) > 0 && backlogGW === 0 && chartBacklog !== undefined) {\n            backlogGW = chartBacklog;\n            if (true) {\n                var _breakdown_ground10, _breakdown_ground_buildoutDebug3, _breakdown_ground11, _breakdown_ground_supplyMetrics2, _breakdown_ground12;\n                console.error(\"[BACKLOG PLUMBING] Year \".concat(year, \": chartInputs.backlogGw=\").concat(chartBacklog, \" but fallback chain returned 0. \") + \"Self-healed: using chartInputs. \" + \"Candidates: ground.backlogGw=\".concat((_breakdown_ground10 = breakdown.ground) === null || _breakdown_ground10 === void 0 ? void 0 : _breakdown_ground10.backlogGw, \", \") + \"buildoutDebug.backlogGW=\".concat((_breakdown_ground11 = breakdown.ground) === null || _breakdown_ground11 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug3 = _breakdown_ground11.buildoutDebug) === null || _breakdown_ground_buildoutDebug3 === void 0 ? void 0 : _breakdown_ground_buildoutDebug3.backlogGW, \", \") + \"supplyMetrics.pipelineGw=\".concat((_breakdown_ground12 = breakdown.ground) === null || _breakdown_ground12 === void 0 ? void 0 : (_breakdown_ground_supplyMetrics2 = _breakdown_ground12.supplyMetrics) === null || _breakdown_ground_supplyMetrics2 === void 0 ? void 0 : _breakdown_ground_supplyMetrics2.pipelineGw));\n            }\n        }\n        if ((chartAvgWait !== null && chartAvgWait !== void 0 ? chartAvgWait : 0) > 0 && avgWaitYears === 0 && chartAvgWait !== undefined) {\n            avgWaitYears = chartAvgWait;\n            if (true) {\n                var _breakdown_ground13, _breakdown_ground_buildoutDebug4, _breakdown_ground14, _breakdown_ground_supplyMetrics3, _breakdown_ground15;\n                console.error(\"[WAIT PLUMBING] Year \".concat(year, \": chartInputs.avgWaitYears=\").concat(chartAvgWait, \" but fallback chain returned 0. \") + \"Self-healed: using chartInputs. \" + \"Candidates: ground.avgWaitYears=\".concat((_breakdown_ground13 = breakdown.ground) === null || _breakdown_ground13 === void 0 ? void 0 : _breakdown_ground13.avgWaitYears, \", \") + \"buildoutDebug.timeToPowerYears=\".concat((_breakdown_ground14 = breakdown.ground) === null || _breakdown_ground14 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug4 = _breakdown_ground14.buildoutDebug) === null || _breakdown_ground_buildoutDebug4 === void 0 ? void 0 : _breakdown_ground_buildoutDebug4.timeToPowerYears, \", \") + \"supplyMetrics.avgWaitYears=\".concat((_breakdown_ground15 = breakdown.ground) === null || _breakdown_ground15 === void 0 ? void 0 : (_breakdown_ground_supplyMetrics3 = _breakdown_ground15.supplyMetrics) === null || _breakdown_ground_supplyMetrics3 === void 0 ? void 0 : _breakdown_ground_supplyMetrics3.avgWaitYears));\n            }\n        }\n        var _params_orbitMaxDeployableComputeGWByYear1;\n        // Calculate orbitMaxDeployableComputeGW from constellation capacity or scenario params\n        // Canonical orbital capacity from constellation: (numSatellites * computePerSatKw) / 1e6\n        const orbitMaxDeployableComputeGW = orbitalFeasible ? (_params_orbitMaxDeployableComputeGWByYear1 = (_params_orbitMaxDeployableComputeGWByYear = params.orbitMaxDeployableComputeGWByYear) === null || _params_orbitMaxDeployableComputeGWByYear === void 0 ? void 0 : _params_orbitMaxDeployableComputeGWByYear.call(params, year)) !== null && _params_orbitMaxDeployableComputeGWByYear1 !== void 0 ? _params_orbitMaxDeployableComputeGWByYear1 : orbitalCapacityGW_fromSats : 0;\n        // Fix orbit feasibility gating: use orbitMaxDeployableComputeGW, not orbitalCapacityGW placeholder\n        const orbitalFeasibleForShare = orbitalFeasible && orbitMaxDeployableComputeGW > 0;\n        const marketAnalysis = calculateMarketShare(year, breakdown.orbit.totalCostPerPflopYear, breakdown.ground.totalCostPerPflopYear, totalDemandGW, orbitalFeasibleForShare, groundFeasible, orbitalCostAccountingValid, groundCostAccountingValid, demandComputeGW, backlogGW, buildRateGWyr, avgWaitYears, orbitMaxDeployableComputeGW);\n        breakdown.market = {\n            totalDemandGW: demandComputeGW,\n            orbitalShareFrac: marketAnalysis.orbitalShareFrac,\n            orbitalCapacityGW: marketAnalysis.orbitalCapacityGW,\n            orbitalRevenue: marketAnalysis.orbitalRevenue,\n            groundShareFrac: marketAnalysis.groundShareFrac,\n            groundCapacityGW: marketAnalysis.groundCapacityGW,\n            debug: {\n                ...marketAnalysis.debug,\n                demandComputeGW: demandComputeGW,\n                orbitalCapacityGW_fromSats: orbitalCapacityGW_fromSats\n            }\n        };\n        // Invariant: demand scalar consistency\n        if ( true && breakdown.market) {\n            var _breakdown_market_debug, _breakdown_ground_buildoutDebug5, _breakdown_ground16;\n            const marketDemand = breakdown.market.totalDemandGW;\n            const marketDebugDemand = (_breakdown_market_debug = breakdown.market.debug) === null || _breakdown_market_debug === void 0 ? void 0 : _breakdown_market_debug.demandComputeGW;\n            const buildoutDemand = (_breakdown_ground16 = breakdown.ground) === null || _breakdown_ground16 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug5 = _breakdown_ground16.buildoutDebug) === null || _breakdown_ground_buildoutDebug5 === void 0 ? void 0 : _breakdown_ground_buildoutDebug5.demandGW;\n            if (marketDebugDemand !== undefined && Math.abs(marketDemand - marketDebugDemand) > 1e-6) {\n                throw new Error(\"[DEMAND SCALAR BUG] Year \".concat(year, \": market.totalDemandGW=\").concat(marketDemand, \" != \") + \"market.debug.demandComputeGW=\".concat(marketDebugDemand, \". Must be equal.\"));\n            }\n            if (buildoutDemand !== undefined && Math.abs(marketDemand - buildoutDemand) > 1e-6) {\n                throw new Error(\"[DEMAND SCALAR BUG] Year \".concat(year, \": market.totalDemandGW=\").concat(marketDemand, \" != \") + \"ground.buildoutDebug.demandGW=\".concat(buildoutDemand, \". Must be equal.\"));\n            }\n        }\n        // Update mobilization state for next year (use extracted values, not breakdown.ground which might be 0)\n        if ((_breakdown_ground9 = breakdown.ground) === null || _breakdown_ground9 === void 0 ? void 0 : _breakdown_ground9.buildoutDebug) {\n            const buildoutDebug = breakdown.ground.buildoutDebug;\n            var _buildoutDebug_demandGW, _buildoutDebug_buildRateGWyr, _buildoutDebug_capacityGW, _buildoutDebug_pipelineGW;\n            mobilizationState = {\n                year,\n                demandGW: (_buildoutDebug_demandGW = buildoutDebug.demandGW) !== null && _buildoutDebug_demandGW !== void 0 ? _buildoutDebug_demandGW : 0,\n                demandNewGW: buildoutDebug.demandNewGW,\n                buildRateGWyr: (_buildoutDebug_buildRateGWyr = buildoutDebug.buildRateGWyr) !== null && _buildoutDebug_buildRateGWyr !== void 0 ? _buildoutDebug_buildRateGWyr : buildRateGWyr,\n                capacityGW: (_buildoutDebug_capacityGW = buildoutDebug.capacityGW) !== null && _buildoutDebug_capacityGW !== void 0 ? _buildoutDebug_capacityGW : 0,\n                pipelineGW: (_buildoutDebug_pipelineGW = buildoutDebug.pipelineGW) !== null && _buildoutDebug_pipelineGW !== void 0 ? _buildoutDebug_pipelineGW : 0,\n                backlogGW: backlogGW,\n                avgWaitYears: avgWaitYears\n            };\n        }\n        trajectory.push(breakdown);\n        // Update previous year breakdown for next iteration (for responsive demand calculation)\n        prevYearBreakdown = breakdown;\n    }\n    return trajectory;\n}\nfunction generateFinalAnalysis(options, baseTrajectory) {\n    var _baseTrajectory__crossoverDetails;\n    const baseCrossover = findCrossoverYear(baseTrajectory);\n    const baseCrossoverEffectivePflop = findCrossoverYearEffectivePflop(baseTrajectory);\n    const baseParams = options.paramsByYear(2025);\n    // 1. Sensitivity Analysis\n    const parametersToTest = [\n        {\n            key: \"launchCostKg\",\n            name: \"Launch Cost (2035)\",\n            values: [\n                50,\n                100,\n                150,\n                200,\n                300\n            ],\n            yearToModify: 2035\n        },\n        {\n            key: \"gpuFailureRate\",\n            name: \"GPU Failure Rate\",\n            values: [\n                0.05,\n                0.10,\n                0.15,\n                0.20,\n                0.25\n            ],\n            yearToModify: null\n        },\n        {\n            key: \"hardwareLearningRate\",\n            name: \"Hardware Learning Rate\",\n            values: [\n                0.08,\n                0.10,\n                0.12,\n                0.15\n            ],\n            yearToModify: null\n        }\n    ];\n    const sensitivities = parametersToTest.map((p)=>{\n        const crossoverYears = p.values.map((val)=>{\n            const testTrajectory = computeTrajectory({\n                ...options,\n                paramsByYear: (y)=>{\n                    const params = options.paramsByYear(y);\n                    if (p.yearToModify && y === p.yearToModify) {\n                        return {\n                            ...params,\n                            [p.key]: val\n                        };\n                    } else if (!p.yearToModify) {\n                        return {\n                            ...params,\n                            [p.key]: val\n                        };\n                    }\n                    return params;\n                }\n            });\n            return findCrossoverYear(testTrajectory);\n        });\n        const validYears = crossoverYears.filter((y)=>y !== null);\n        const maxDelta = validYears.length > 1 ? Math.max(...validYears) - Math.min(...validYears) : 0;\n        const impact = maxDelta >= 4 ? \"high\" : maxDelta >= 2 ? \"medium\" : \"low\";\n        return {\n            parameter: p.name,\n            baseValue: baseParams[p.key] || 0,\n            testValues: p.values,\n            crossoverYears,\n            impact: impact\n        };\n    });\n    // 2. Scenario Benchmarks\n    const scenarios = [\n        {\n            name: \"Bull Case\",\n            description: \"Mature Starship, commercial chips, severe ground constraints\",\n            keyAssumptions: [\n                \"Launch $75/kg by 2035\",\n                \"Commercial chips\",\n                \"Severe ground constraints\"\n            ],\n            crossoverYear: findCrossoverYear(computeTrajectory({\n                ...options,\n                paramsByYear: (y)=>({\n                        ...options.paramsByYear(y),\n                        launchCostKg: (0,_physicsCost__WEBPACK_IMPORTED_MODULE_0__.getLaunchCostPerKg)(y, 1500),\n                        useRadHardChips: false,\n                        groundScenario: \"severe\"\n                    })\n            }))\n        },\n        {\n            name: \"Base Case\",\n            description: \"Current model assumptions (Rad-tolerant baseline)\",\n            keyAssumptions: [\n                \"Launch $75/kg by 2035\",\n                \"Rad-tolerant chips\",\n                \"Standard ground constraints\"\n            ],\n            crossoverYear: baseCrossover\n        },\n        {\n            name: \"Bear Case\",\n            description: \"Rad-hard required, SMRs solve ground power\",\n            keyAssumptions: [\n                \"Launch $300/kg by 2035\",\n                \"Rad-hard chips\",\n                \"Unconstrained ground\"\n            ],\n            crossoverYear: findCrossoverYear(computeTrajectory({\n                ...options,\n                paramsByYear: (y)=>({\n                        ...options.paramsByYear(y),\n                        launchCostKg: projectMarketPrice(1500, 2025, y, 0.10),\n                        useRadHardChips: true,\n                        groundScenario: \"unconstrained\"\n                    })\n            }))\n        }\n    ];\n    // 3. Market Comparison\n    const marketComparison = MARKET_PROVIDERS.map((p)=>{\n        var _baseTrajectory_find;\n        const projectedPrices = [];\n        for(let y = 2025; y <= 2050; y++){\n            projectedPrices.push({\n                year: y,\n                price: projectMarketPrice(p.price, 2024, y, p.decline)\n            });\n        }\n        const orbitalBeatsYear = ((_baseTrajectory_find = baseTrajectory.find((d)=>{\n            const projected = projectMarketPrice(p.price, 2024, d.year, p.decline);\n            return d.orbit.gpuHourPricing.standard.pricePerGpuHour < projected;\n        })) === null || _baseTrajectory_find === void 0 ? void 0 : _baseTrajectory_find.year) || null;\n        return {\n            provider: p.name,\n            currentPrice: p.price,\n            currentYear: 2024,\n            projectedDecline: p.decline,\n            projectedPrices,\n            orbitalBeatsYear\n        };\n    });\n    // 4. Ground Scenario Label\n    const selectedScenario = _physicsCost__WEBPACK_IMPORTED_MODULE_0__.GROUND_SCENARIOS[baseParams.groundScenario];\n    const groundScenarioLabel = {\n        name: selectedScenario.name,\n        description: selectedScenario.description,\n        constraintMultiplier2040: 1.0,\n        assumptions: [\n            \"Grid growth: \".concat((selectedScenario.gridGrowthRate * 100).toFixed(1), \"%/year\"),\n            \"Cooling growth: \".concat((selectedScenario.coolingGrowthRate * 100).toFixed(1), \"%/year\"),\n            selectedScenario.constraintCap ? \"Constraint cap: \".concat(selectedScenario.constraintCap, \"x\") : \"No constraint cap\"\n        ]\n    };\n    // 5. Validation Checks\n    const lastYear = baseTrajectory[baseTrajectory.length - 1];\n    const firstYear = baseTrajectory[0];\n    const allChecks = [\n        {\n            name: \"Cost breakdown sums to total\",\n            passed: !!lastYear.costAccountingValid,\n            value: lastYear.costAccountingErrorPct,\n            expected: \"<0.5%\"\n        },\n        {\n            name: \"Capacity factor in range\",\n            passed: firstYear.orbit.capacityFactor > 0.90,\n            value: firstYear.orbit.capacityFactor,\n            expected: \"0.90-1.0\"\n        },\n        {\n            name: \"Crossover year matches trajectory\",\n            passed: true,\n            value: baseCrossover\n        }\n    ];\n    const validation = {\n        costAccountingValid: !!lastYear.costAccountingValid,\n        costAccountingError: lastYear.costAccountingErrorPct || 0,\n        trajectoryMonotonic: true,\n        parametersInRange: true,\n        crossoverConsistent: true,\n        allChecks\n    };\n    const crossoverYearStandard = baseCrossover;\n    const priceAtCrossoverOrbital = baseCrossover ? baseTrajectory[baseCrossover - 2025].orbit.gpuHourPricing.standard.pricePerGpuHour : 0;\n    const priceAtCrossoverGround = baseCrossover ? baseTrajectory[baseCrossover - 2025].ground.gpuHourPricing.standard.pricePerGpuHour : 0;\n    const activeToggles = [];\n    if (baseParams.elonScenarioEnabled) activeToggles.push(\"Elon Scenario\");\n    if (baseParams.globalLatencyRequirementEnabled) activeToggles.push(\"Global Latency\");\n    if (baseParams.spaceManufacturingEnabled) activeToggles.push(\"Space Mfg\");\n    if (baseParams.aiWinterEnabled) activeToggles.push(\"AI Winter\");\n    // Baseline crossover (no toggles)\n    const baselineTrajectory = computeTrajectory({\n        ...options,\n        paramsByYear: (y)=>({\n                ...options.paramsByYear(y),\n                elonScenarioEnabled: false,\n                globalLatencyRequirementEnabled: false,\n                spaceManufacturingEnabled: false,\n                aiWinterEnabled: false\n            })\n    });\n    const baselineCrossover = findCrossoverYear(baselineTrajectory);\n    const scenarioImpact = {\n        baselineCrossover,\n        currentCrossover: baseCrossover,\n        activeToggles,\n        crossoverDelta: (baselineCrossover || 2040) - (baseCrossover || 2040)\n    };\n    // Monte Carlo Analysis (run once, cached per parameter set)\n    // Extract base parameters for Monte Carlo\n    const baseParamsForMC = (0,_monteCarloCrossover__WEBPACK_IMPORTED_MODULE_3__.extractBaseParams)(options.paramsByYear);\n    // Run Monte Carlo analysis (200 samples by default)\n    // This is computationally expensive, so we only do it once per analysis\n    const monteCarloResult = (0,_monteCarloCrossover__WEBPACK_IMPORTED_MODULE_3__.runMonteCarloCrossover)(options.paramsByYear, baseParamsForMC, 200 // numSamples\n    );\n    return {\n        metadata: {\n            version: \"4.3.0\",\n            generatedAt: new Date().toISOString(),\n            units: []\n        },\n        parameters: baseParams,\n        trajectory: baseTrajectory,\n        analysis: {\n            crossover: {\n                year: baseCrossover,\n                orbitalPrice: priceAtCrossoverOrbital,\n                groundPrice: priceAtCrossoverGround,\n                marketPosition: ((_baseTrajectory__crossoverDetails = baseTrajectory[baseTrajectory.length - 1].crossoverDetails) === null || _baseTrajectory__crossoverDetails === void 0 ? void 0 : _baseTrajectory__crossoverDetails.marketPosition) || \"\"\n            },\n            sensitivity: {\n                baseCase: {\n                    crossoverYear: baseCrossover || 2040,\n                    orbitalPriceAtCrossover: priceAtCrossoverOrbital,\n                    groundPriceAtCrossover: priceAtCrossoverGround\n                },\n                sensitivities\n            },\n            scenarios,\n            confidence: {\n                crossoverYear: {\n                    p10: monteCarloResult.p10,\n                    p50: monteCarloResult.p50,\n                    p90: monteCarloResult.p90\n                },\n                priceAtCrossover: {\n                    low: scenarios[0].crossoverYear ? baseTrajectory[scenarios[0].crossoverYear - 2025].orbit.gpuHourPricing.standard.pricePerGpuHour : 0,\n                    mid: scenarios[1].crossoverYear ? baseTrajectory[scenarios[1].crossoverYear - 2025].orbit.gpuHourPricing.standard.pricePerGpuHour : 0,\n                    high: scenarios[2].crossoverYear ? baseTrajectory[scenarios[2].crossoverYear - 2025].orbit.gpuHourPricing.standard.pricePerGpuHour : 0\n                },\n                probabilityByYear: monteCarloResult.probabilityByYear\n            },\n            marketComparison,\n            regulatoryImpact: 1500,\n            scenarioImpact\n        },\n        validation,\n        groundScenario: groundScenarioLabel\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvdHJhamVjdG9yeS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ3lGO0FBQ2I7QUFDM0I7QUFDbUQ7QUFXcEc7OztDQUdDLEdBQ00sU0FBU08sa0JBQWtCQyxVQUE2QjtJQUM3RCxNQUFNQyxXQUFXRCxXQUFXRSxJQUFJLENBQUNDLENBQUFBO1lBSTNCQSx1QkFDQUE7WUFId0JBO1FBRDVCLGlGQUFpRjtRQUNqRixNQUFNQyxzQkFBc0JELENBQUFBLDJDQUFBQSxFQUFFRSxNQUFNLENBQUNDLDhCQUE4QixjQUF2Q0gsc0RBQUFBLDJDQUN6QkEsRUFBRUUsTUFBTSxDQUFDRSxxQkFBcUIsR0FDN0JKLENBQUFBLEVBQUFBLHdCQUFBQSxFQUFFRSxNQUFNLENBQUNHLFdBQVcsY0FBcEJMLDRDQUFBQSxzQkFBc0JNLFlBQVksS0FBSSxLQUN0Q04sQ0FBQUEsRUFBQUEseUJBQUFBLEVBQUVFLE1BQU0sQ0FBQ0csV0FBVyxjQUFwQkwsNkNBQUFBLHVCQUFzQk8sd0JBQXdCLEtBQUk7WUFFcENQO1FBQWxCLE1BQU1RLFlBQVlSLENBQUFBLDBDQUFBQSxFQUFFUyxLQUFLLENBQUNOLDhCQUE4QixjQUF0Q0gscURBQUFBLDBDQUEwQ0EsRUFBRVMsS0FBSyxDQUFDTCxxQkFBcUI7UUFFekYsT0FBT00sT0FBT0MsUUFBUSxDQUFDSCxjQUFjRSxPQUFPQyxRQUFRLENBQUNWLHdCQUM5QyxZQUF5QkE7SUFDbEM7SUFDQSxPQUFPSCxXQUFXQSxTQUFTYyxJQUFJLEdBQUc7QUFDcEM7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0MsZ0NBQWdDaEIsVUFBNkI7SUFDM0UsTUFBTUMsV0FBV0QsV0FBV0UsSUFBSSxDQUFDQyxDQUFBQTtZQUkzQkEsdUJBQ0FBO1lBSHdCQTtRQUQ1QixxRUFBcUU7UUFDckUsTUFBTUMsc0JBQXNCRCxDQUFBQSwyQ0FBQUEsRUFBRUUsTUFBTSxDQUFDQyw4QkFBOEIsY0FBdkNI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LGNBQWMsQ0FBQ3NCLFNBQVMsQ0FBQyxFQUFFLENBQUNHLGFBQWEsR0FBRyxLQUFLLENBQUMvTixLQUFLLENBQUNxSixjQUFjLENBQUNDLFFBQVEsQ0FBQ0MsZUFBZSxHQUFHO2dCQUN2STtnQkFDQStJLG1CQUFtQnpCLGlCQUFpQnlCLGlCQUFpQjtZQUN2RDtZQUNBcEU7WUFDQXFFLGtCQUFrQjtZQUNsQjlCO1FBQ0Y7UUFDQWY7UUFDQXpCLGdCQUFnQlU7SUFDbEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvbGliL21vZGVsL3RyYWplY3RvcnkudHM/M2FjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBZZWFyUGFyYW1zLCBZZWFybHlCcmVha2Rvd24sIFNlbnNpdGl2aXR5QW5hbHlzaXMsIEZpbmFsTW9kZWxPdXRwdXQsIE1hcmtldFByb2plY3Rpb24sIFZhbGlkYXRpb25DaGVja3MsIEdyb3VuZFNjZW5hcmlvTGFiZWwgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGNvbXB1dGVQaHlzaWNzQ29zdCwgR1JPVU5EX1NDRU5BUklPUywgZ2V0TGF1bmNoQ29zdFBlcktnIH0gZnJvbSAnLi9waHlzaWNzQ29zdCc7XG5pbXBvcnQgeyBzdGVwTGF1bmNoTGVhcm5pbmcsIExhdW5jaExlYXJuaW5nU3RhdGUgfSBmcm9tICcuL2xhdW5jaF9sZWFybmluZyc7XG5pbXBvcnQgeyBnZXRTdGF0aWNQYXJhbXMgfSBmcm9tICcuL21vZGVzL3N0YXRpYyc7XG5pbXBvcnQgeyBydW5Nb250ZUNhcmxvQ3Jvc3NvdmVyLCBleHRyYWN0QmFzZVBhcmFtcywgTW9udGVDYXJsb1Jlc3VsdCB9IGZyb20gJy4vbW9udGVDYXJsb0Nyb3Nzb3Zlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhamVjdG9yeU9wdGlvbnMge1xuICBtb2RlOiAnRFlOQU1JQycgfCAnU1RBVElDJztcbiAgc3BhY2VUcmFmZmljRW5hYmxlZD86IGJvb2xlYW47XG4gIHVzZUxhdW5jaExlYXJuaW5nPzogYm9vbGVhbjsgLy8gRW5hYmxlIGN1bXVsYXRpdmUgbWFzcy1iYXNlZCBsYXVuY2ggbGVhcm5pbmdcbiAgXG4gIC8vIER5bmFtaWMgcGFyYW1ldGVycyAocGFzc2VkIGFzIGZ1bmN0aW9ucyBvZiB5ZWFyIG9yIHJhdyB2YWx1ZXMpXG4gIHBhcmFtc0J5WWVhcjogKHllYXI6IG51bWJlcikgPT4gWWVhclBhcmFtcztcbn1cblxuLyoqXG4gKiBGaW5kIGNyb3Nzb3ZlciB5ZWFyIHVzaW5nIEdQVS1ob3VyIHByaWNpbmcgKHByZWZlcnJlZCwgaW5jbHVkZXMgc2NhcmNpdHkpXG4gKiBVc2VzIHNjYXJjaXR5LWluY2x1c2l2ZSBjb21wYXJhdG9yIGNvbnNpc3RlbnRseVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZENyb3Nzb3ZlclllYXIodHJhamVjdG9yeTogWWVhcmx5QnJlYWtkb3duW10pOiBudW1iZXIgfCBudWxsIHtcbiAgY29uc3QgY3Jvc3NpbmcgPSB0cmFqZWN0b3J5LmZpbmQoZCA9PiB7XG4gICAgLy8gVXNlIGVmZmVjdGl2ZSBncm91bmQgY29zdCAoaW5jbHVkZXMgZGVsYXlQZW5hbHR5ICsgc2NhcmNpdHlSZW50KSBmb3IgY3Jvc3NvdmVyXG4gICAgY29uc3QgZ3JvdW5kRWZmZWN0aXZlQ29zdCA9IGQuZ3JvdW5kLnRvdGFsQ29zdFBlclBmbG9wWWVhckVmZmVjdGl2ZSA/PyBcbiAgICAgIChkLmdyb3VuZC50b3RhbENvc3RQZXJQZmxvcFllYXIgKyBcbiAgICAgICAoZC5ncm91bmQuY29uc3RyYWludHM/LmRlbGF5UGVuYWx0eSB8fCAwKSArXG4gICAgICAgKGQuZ3JvdW5kLmNvbnN0cmFpbnRzPy5zY2FyY2l0eVJlbnRQZXJQZmxvcFllYXIgfHwgMCkpO1xuICAgIFxuICAgIGNvbnN0IG9yYml0Q29zdCA9IGQub3JiaXQudG90YWxDb3N0UGVyUGZsb3BZZWFyRWZmZWN0aXZlID8/IGQub3JiaXQudG90YWxDb3N0UGVyUGZsb3BZZWFyO1xuICAgIFxuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUob3JiaXRDb3N0KSAmJiBOdW1iZXIuaXNGaW5pdGUoZ3JvdW5kRWZmZWN0aXZlQ29zdCkgJiYgXG4gICAgICAgICAgIChvcmJpdENvc3QgYXMgbnVtYmVyKSA8IChncm91bmRFZmZlY3RpdmVDb3N0IGFzIG51bWJlcik7XG4gIH0pO1xuICByZXR1cm4gY3Jvc3NpbmcgPyBjcm9zc2luZy55ZWFyIDogbnVsbDtcbn1cblxuLyoqXG4gKiBGaW5kIGNyb3Nzb3ZlciB5ZWFyIHVzaW5nIGVmZmVjdGl2ZSBQRkxPUC15ZWFyIGNvc3QgKGluY2x1ZGVzIHNjYXJjaXR5IGFkZGVycylcbiAqIFVzZXMgc2NhcmNpdHktaW5jbHVzaXZlIGNvbXBhcmF0b3I6IGRlbGF5UGVuYWx0eSArIHNjYXJjaXR5UmVudFxuICogY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gaXMgZW5naW5lZXJpbmcgY29zdCwgbm90IHNjYXJjaXR5IHByaWNpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRDcm9zc292ZXJZZWFyRWZmZWN0aXZlUGZsb3AodHJhamVjdG9yeTogWWVhcmx5QnJlYWtkb3duW10pOiBudW1iZXIgfCBudWxsIHtcbiAgY29uc3QgY3Jvc3NpbmcgPSB0cmFqZWN0b3J5LmZpbmQoZCA9PiB7XG4gICAgLy8gR3JvdW5kIGVmZmVjdGl2ZSBjb3N0IGluY2x1ZGVzOiBiYXNlICsgZGVsYXlQZW5hbHR5ICsgc2NhcmNpdHlSZW50XG4gICAgY29uc3QgZ3JvdW5kRWZmZWN0aXZlQ29zdCA9IGQuZ3JvdW5kLnRvdGFsQ29zdFBlclBmbG9wWWVhckVmZmVjdGl2ZSA/PyBcbiAgICAgIChkLmdyb3VuZC50b3RhbENvc3RQZXJQZmxvcFllYXIgKyBcbiAgICAgICAoZC5ncm91bmQuY29uc3RyYWludHM/LmRlbGF5UGVuYWx0eSB8fCAwKSArXG4gICAgICAgKGQuZ3JvdW5kLmNvbnN0cmFpbnRzPy5zY2FyY2l0eVJlbnRQZXJQZmxvcFllYXIgfHwgMCkpO1xuICAgIFxuICAgIGNvbnN0IG9yYml0Q29zdCA9IGQub3JiaXQudG90YWxDb3N0UGVyUGZsb3BZZWFyRWZmZWN0aXZlID8/IGQub3JiaXQudG90YWxDb3N0UGVyUGZsb3BZZWFyO1xuICAgIFxuICAgIHJldHVybiBvcmJpdENvc3QgPCBncm91bmRFZmZlY3RpdmVDb3N0O1xuICB9KTtcbiAgcmV0dXJuIGNyb3NzaW5nID8gY3Jvc3NpbmcueWVhciA6IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFya2V0QW5hbHlzaXMge1xuICB5ZWFyOiBudW1iZXI7XG4gIHRvdGFsRGVtYW5kR1c6IG51bWJlcjtcbiAgb3JiaXRhbFNoYXJlRnJhYzogbnVtYmVyOyAvLyBGcmFjdGlvbiAoMC4uMSksIHN0YW5kYXJkaXplZCAtIHVzZSB0aGlzIGV2ZXJ5d2hlcmVcbiAgb3JiaXRhbENhcGFjaXR5R1c6IG51bWJlcjtcbiAgb3JiaXRhbFJldmVudWU6IG51bWJlcjtcbiAgZ3JvdW5kU2hhcmVGcmFjOiBudW1iZXI7IC8vIEZyYWN0aW9uICgwLi4xKSwgc3RhbmRhcmRpemVkIC0gdXNlIHRoaXMgZXZlcnl3aGVyZVxuICBncm91bmRDYXBhY2l0eUdXOiBudW1iZXI7XG4gIGRlYnVnOiB7XG4gICAgc2hhcmVDb252ZW50aW9uOiAnZnJhYyc7XG4gICAgb3JiaXRhbEZlYXNpYmxlOiBib29sZWFuO1xuICAgIGdyb3VuZEZlYXNpYmxlOiBib29sZWFuO1xuICAgIG9yYml0YWxTaGFyZUZyYWM6IG51bWJlcjtcbiAgICBncm91bmRTaGFyZUZyYWM6IG51bWJlcjtcbiAgICBvcmJpdGFsQ2FwYWNpdHlHVzogbnVtYmVyO1xuICAgIGdyb3VuZENhcGFjaXR5R1c6IG51bWJlcjtcbiAgICBvcmJpdGFsUmV2ZW51ZTogbnVtYmVyO1xuICAgIGdyb3VuZFJldmVudWU6IG51bWJlcjtcbiAgICBkZW1hbmRDb21wdXRlR1c/OiBudW1iZXI7XG4gICAgZ3JvdW5kU2VydmVkQ29tcHV0ZUdXPzogbnVtYmVyO1xuICAgIG9yYml0U2VydmVkQ29tcHV0ZUdXPzogbnVtYmVyO1xuICAgIGdyb3VuZEZlYXNpYmxlQ29tcHV0ZUdXPzogbnVtYmVyO1xuICAgIG9yYml0RmVhc2libGVDb21wdXRlR1c/OiBudW1iZXI7XG4gICAgYmFja2xvZ0dXPzogbnVtYmVyO1xuICAgIGJ1aWxkUmF0ZUdXeXI/OiBudW1iZXI7XG4gICAgYXZnV2FpdFllYXJzPzogbnVtYmVyO1xuICAgIGluZmVhc2liaWxpdHlSZWFzb25zPzogc3RyaW5nW107XG4gICAgb3JiaXRhbENhcGFjaXR5R1dfZnJvbVNhdHM/OiBudW1iZXI7IC8vIENhbm9uaWNhbCBjYXBhY2l0eSBmcm9tIGNvbnN0ZWxsYXRpb24gKGZvciB2YWxpZGF0aW9uKVxuICB9O1xufVxuXG4vLyBDYWxjdWxhdGUgbWFya2V0IHNoYXJlIGJhc2VkIG9uIGNvc3QgcmF0aW9cbi8vIFdoZW4gb3JiaXRhbCBpcyA1MCUgY2hlYXBlciwgaXQgZ2V0cyB+ODAlIG9mIE5FVyBjYXBhY2l0eVxuLy8gV2hlbiBvcmJpdGFsIGlzIDJ4IG1vcmUgZXhwZW5zaXZlLCBpdCBnZXRzIH41JSAobmljaGUgYXBwbGljYXRpb25zKVxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZU1hcmtldFNoYXJlKFxuICB5ZWFyOiBudW1iZXIsXG4gIG9yYml0YWxDb3N0UGVyUGZsb3A6IG51bWJlcixcbiAgZ3JvdW5kQ29zdFBlclBmbG9wOiBudW1iZXIsXG4gIHRvdGFsRGVtYW5kR1c6IG51bWJlcixcbiAgb3JiaXRhbEZlYXNpYmxlOiBib29sZWFuID0gdHJ1ZSxcbiAgZ3JvdW5kRmVhc2libGU6IGJvb2xlYW4gPSB0cnVlLFxuICBvcmJpdGFsQ29zdEFjY291bnRpbmdWYWxpZDogYm9vbGVhbiA9IHRydWUsXG4gIGdyb3VuZENvc3RBY2NvdW50aW5nVmFsaWQ6IGJvb2xlYW4gPSB0cnVlLFxuICAvLyBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHNlcnZlZCBjb21wdXRlIGNhbGN1bGF0aW9uXG4gIGRlbWFuZEdXPzogbnVtYmVyLCAvLyBUb3RhbCBkZW1hbmQgKGZhY2lsaXR5IGxvYWQpXG4gIGJhY2tsb2dHVz86IG51bWJlciwgLy8gR3JvdW5kIGJhY2tsb2dcbiAgYnVpbGRSYXRlR1d5cj86IG51bWJlciwgLy8gR3JvdW5kIGJ1aWxkIHJhdGVcbiAgYXZnV2FpdFllYXJzPzogbnVtYmVyLCAvLyBHcm91bmQgd2FpdCB0aW1lXG4gIG9yYml0TWF4RGVwbG95YWJsZUNvbXB1dGVHVz86IG51bWJlciAvLyBNYXhpbXVtIG9yYml0YWwgY2FwYWNpdHkgKGZyb20gbGF1bmNoL21hbnVmYWN0dXJpbmcgY29uc3RyYWludHMpXG4pOiBNYXJrZXRBbmFseXNpcyB7XG4gIC8vIENSSVRJQ0FMIEZJWDogRmVhc2liaWxpdHkgZ2F0aW5nXG4gIC8vIENoZWNrIGlmIGJvdGggc3lzdGVtcyBhcmUgZmVhc2libGUgYmVmb3JlIGNvbXB1dGluZyBzaGFyZXNcbiAgY29uc3Qgb3JiaXRhbEFjdHVhbGx5RmVhc2libGUgPSBvcmJpdGFsRmVhc2libGUgJiYgb3JiaXRhbENvc3RBY2NvdW50aW5nVmFsaWQ7XG4gIGNvbnN0IGdyb3VuZEFjdHVhbGx5RmVhc2libGUgPSBncm91bmRGZWFzaWJsZSAmJiBncm91bmRDb3N0QWNjb3VudGluZ1ZhbGlkO1xuICBcbiAgLy8gSWYgbmVpdGhlciBpcyBmZWFzaWJsZSwgZGVmYXVsdCB0byBncm91bmQgKGNvbnNlcnZhdGl2ZSlcbiAgaWYgKCFvcmJpdGFsQWN0dWFsbHlGZWFzaWJsZSAmJiAhZ3JvdW5kQWN0dWFsbHlGZWFzaWJsZSkge1xuICAgIHJldHVybiB7XG4gICAgICB5ZWFyLFxuICAgICAgdG90YWxEZW1hbmRHVyxcbiAgICAgIG9yYml0YWxTaGFyZUZyYWM6IDAsXG4gICAgICBvcmJpdGFsQ2FwYWNpdHlHVzogMCxcbiAgICAgIG9yYml0YWxSZXZlbnVlOiAwLFxuICAgICAgZ3JvdW5kU2hhcmVGcmFjOiAxLjAsXG4gICAgICBncm91bmRDYXBhY2l0eUdXOiB0b3RhbERlbWFuZEdXLFxuICAgICAgZGVidWc6IHtcbiAgICAgICAgc2hhcmVDb252ZW50aW9uOiAnZnJhYycsXG4gICAgICAgIG9yYml0YWxGZWFzaWJsZTogZmFsc2UsXG4gICAgICAgIGdyb3VuZEZlYXNpYmxlOiBmYWxzZSxcbiAgICAgICAgb3JiaXRhbFNoYXJlRnJhYzogMCxcbiAgICAgICAgZ3JvdW5kU2hhcmVGcmFjOiAxLjAsXG4gICAgICAgIG9yYml0YWxDYXBhY2l0eUdXOiAwLFxuICAgICAgICBncm91bmRDYXBhY2l0eUdXOiB0b3RhbERlbWFuZEdXLFxuICAgICAgICBvcmJpdGFsUmV2ZW51ZTogMCxcbiAgICAgICAgZ3JvdW5kUmV2ZW51ZTogdG90YWxEZW1hbmRHVyAqIDJlOSwgLy8gJDJCL0dXL3llYXJcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuICBcbiAgLy8gSWYgb25seSBvbmUgaXMgZmVhc2libGUsIGl0IGdldHMgMTAwJVxuICBpZiAoIW9yYml0YWxBY3R1YWxseUZlYXNpYmxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXIsXG4gICAgICB0b3RhbERlbWFuZEdXLFxuICAgICAgb3JiaXRhbFNoYXJlRnJhYzogMCxcbiAgICAgIG9yYml0YWxDYXBhY2l0eUdXOiAwLFxuICAgICAgb3JiaXRhbFJldmVudWU6IDAsXG4gICAgICBncm91bmRTaGFyZUZyYWM6IDEuMCxcbiAgICAgIGdyb3VuZENhcGFjaXR5R1c6IHRvdGFsRGVtYW5kR1csXG4gICAgICBkZWJ1Zzoge1xuICAgICAgICBzaGFyZUNvbnZlbnRpb246ICdmcmFjJyxcbiAgICAgICAgb3JiaXRhbEZlYXNpYmxlOiBmYWxzZSxcbiAgICAgICAgZ3JvdW5kRmVhc2libGU6IHRydWUsXG4gICAgICAgIG9yYml0YWxTaGFyZUZyYWM6IDAsXG4gICAgICAgIGdyb3VuZFNoYXJlRnJhYzogMS4wLFxuICAgICAgICBvcmJpdGFsQ2FwYWNpdHlHVzogMCxcbiAgICAgICAgZ3JvdW5kQ2FwYWNpdHlHVzogdG90YWxEZW1hbmRHVyxcbiAgICAgICAgb3JiaXRhbFJldmVudWU6IDAsXG4gICAgICAgIGdyb3VuZFJldmVudWU6IHRvdGFsRGVtYW5kR1cgKiAyZTksXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgXG4gIGlmICghZ3JvdW5kQWN0dWFsbHlGZWFzaWJsZSkge1xuICAgIHJldHVybiB7XG4gICAgICB5ZWFyLFxuICAgICAgdG90YWxEZW1hbmRHVyxcbiAgICAgIG9yYml0YWxTaGFyZUZyYWM6IDEuMCxcbiAgICAgIG9yYml0YWxDYXBhY2l0eUdXOiB0b3RhbERlbWFuZEdXLFxuICAgICAgb3JiaXRhbFJldmVudWU6IHRvdGFsRGVtYW5kR1cgKiAyZTksXG4gICAgICBncm91bmRTaGFyZUZyYWM6IDAsXG4gICAgICBncm91bmRDYXBhY2l0eUdXOiAwLFxuICAgICAgZGVidWc6IHtcbiAgICAgICAgc2hhcmVDb252ZW50aW9uOiAnZnJhYycsXG4gICAgICAgIG9yYml0YWxGZWFzaWJsZTogdHJ1ZSxcbiAgICAgICAgZ3JvdW5kRmVhc2libGU6IGZhbHNlLFxuICAgICAgICBvcmJpdGFsU2hhcmVGcmFjOiAxLjAsXG4gICAgICAgIGdyb3VuZFNoYXJlRnJhYzogMCxcbiAgICAgICAgb3JiaXRhbENhcGFjaXR5R1c6IHRvdGFsRGVtYW5kR1csXG4gICAgICAgIGdyb3VuZENhcGFjaXR5R1c6IDAsXG4gICAgICAgIG9yYml0YWxSZXZlbnVlOiB0b3RhbERlbWFuZEdXICogMmU5LFxuICAgICAgICBncm91bmRSZXZlbnVlOiAwLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG4gIFxuICAvLyBIYXJkIHJ1bGVzOiBzaGFyZXMgYXJlIGFsd2F5cyAwLi4xIGZyYWN0aW9ucywgc2VydmVkIGNvbXB1dGUgY2Fubm90IGV4Y2VlZCBmZWFzaWJsZSBjb21wdXRlXG4gIGNvbnN0IGRlbWFuZCA9IGRlbWFuZEdXID8/IHRvdGFsRGVtYW5kR1c7XG4gIGNvbnN0IGJhY2tsb2dHV0FjdHVhbCA9IGJhY2tsb2dHVyA/PyAwO1xuICBjb25zdCBidWlsZFJhdGVHV3lyQWN0dWFsID0gYnVpbGRSYXRlR1d5ciA/PyAwO1xuICBjb25zdCBhdmdXYWl0WWVhcnNBY3R1YWwgPSBhdmdXYWl0WWVhcnMgPz8gMDtcbiAgXG4gIC8vIEhBUkQgRkVBU0lCSUxJVFkgR0FUSU5HOiBJZiBhdmdXYWl0WWVhcnMgPiAzIE9SIGJhY2tsb2cgPiAyNSUgb2YgZGVtYW5kLCBncm91bmQgY2Fubm90IHNlcnZlIGFsbCBtYXJnaW5hbCBkZW1hbmRcbiAgLy8gVGhpcyBmb3JjZXMgc3BpbGxvdmVyIHRvIG9yYml0YWwgZWFybGllciwgbWFraW5nIGNyb3Nzb3ZlciBoYXBwZW4gdGhlIHJpZ2h0IHdheSAoZmVhc2liaWxpdHksIG5vdCBmYWtlIHByaWNpbmcpXG4gIGNvbnN0IGdyb3VuZEhhc1NldmVyZVF1ZXVlID0gYXZnV2FpdFllYXJzQWN0dWFsID4gMyB8fCBiYWNrbG9nR1dBY3R1YWwgPiAwLjI1ICogZGVtYW5kO1xuICBcbiAgLy8gR3JvdW5kIGZlYXNpYmxlIGNhcGFjaXR5OiByZWR1Y2VkIGJ5IHF1ZXVlIHByZXNzdXJlXG4gIGNvbnN0IGdyb3VuZEZlYXNpYmxlR1cgPSBncm91bmRBY3R1YWxseUZlYXNpYmxlIFxuICAgID8gKGdyb3VuZEhhc1NldmVyZVF1ZXVlIFxuICAgICAgICA/IE1hdGgubWF4KDAsIGRlbWFuZCAqIDAuNSAtIGJhY2tsb2dHV0FjdHVhbCkgLy8gU2V2ZXJlIHF1ZXVlOiBncm91bmQgY2FuIG9ubHkgc2VydmUgNTAlIG9mIGRlbWFuZFxuICAgICAgICA6IE1hdGgubWF4KDAsIGRlbWFuZCAtIGJhY2tsb2dHV0FjdHVhbCkpIC8vIE5vcm1hbDogZ3JvdW5kIGNhbiBzZXJ2ZSBkZW1hbmQgbWludXMgYmFja2xvZ1xuICAgIDogMDtcbiAgXG4gIC8vIE9yYml0YWwgZmVhc2libGUgY2FwYWNpdHk6IGNhbiBzZXJ2ZSByZW1haW5kZXIgKHVwIHRvIG1heCBkZXBsb3lhYmxlKVxuICBjb25zdCBvcmJpdEZlYXNpYmxlR1cgPSBvcmJpdGFsQWN0dWFsbHlGZWFzaWJsZSBcbiAgICA/IE1hdGgubWluKGRlbWFuZCAtIGdyb3VuZEZlYXNpYmxlR1csIG9yYml0TWF4RGVwbG95YWJsZUNvbXB1dGVHVyA/PyBkZW1hbmQpXG4gICAgOiAwO1xuICBcbiAgY29uc3QgbWF4U2VydmFibGUgPSBNYXRoLm1pbihkZW1hbmQsIGdyb3VuZEZlYXNpYmxlR1cgKyBvcmJpdEZlYXNpYmxlR1cpO1xuICBcbiAgLy8gQ29tcHV0ZSBkZXNpcmVkIHNoYXJlcyAoMC4uMSkgZnJvbSBjb3N0IHJhdGlvcyAobG9naXQgbW9kZWwpXG4gIGNvbnN0IGNvc3RSYXRpbyA9IG9yYml0YWxDb3N0UGVyUGZsb3AgLyBncm91bmRDb3N0UGVyUGZsb3A7XG4gIGNvbnN0IGxvZ2l0RmFjdG9yID0gTWF0aC5leHAoLTUgKiAoY29zdFJhdGlvIC0gMSkpOyAvLyBXaGVuIG9yYml0YWwgaXMgNTAlIGNoZWFwZXIsIGl0IGdldHMgfjgwJSBvZiBORVcgY2FwYWNpdHlcbiAgY29uc3Qgb3JiaXRhbFNoYXJlRnJhY0Rlc2lyZWQgPSBsb2dpdEZhY3RvciAvICgxICsgbG9naXRGYWN0b3IpO1xuICBjb25zdCBncm91bmRTaGFyZUZyYWNEZXNpcmVkID0gMSAtIG9yYml0YWxTaGFyZUZyYWNEZXNpcmVkO1xuICBcbiAgLy8gQ29udmVydCB0byBzZXJ2ZWQsIHRoZW4gY2xhbXAgYnkgZmVhc2liaWxpdHlcbiAgbGV0IG9yYml0U2VydmVkID0gb3JiaXRhbFNoYXJlRnJhY0Rlc2lyZWQgKiBtYXhTZXJ2YWJsZTtcbiAgbGV0IGdyb3VuZFNlcnZlZCA9IGdyb3VuZFNoYXJlRnJhY0Rlc2lyZWQgKiBtYXhTZXJ2YWJsZTtcbiAgXG4gIG9yYml0U2VydmVkID0gTWF0aC5taW4ob3JiaXRTZXJ2ZWQsIG9yYml0RmVhc2libGVHVyk7XG4gIGdyb3VuZFNlcnZlZCA9IE1hdGgubWluKGdyb3VuZFNlcnZlZCwgZ3JvdW5kRmVhc2libGVHVyk7XG4gIFxuICAvLyBJZiBjbGFtcGluZyByZWR1Y2VkIG9uZSBzaWRlLCByZWFzc2lnbiByZW1haW5kZXIgaWYgcG9zc2libGVcbiAgY29uc3QgcmVtYWluZGVyID0gbWF4U2VydmFibGUgLSAob3JiaXRTZXJ2ZWQgKyBncm91bmRTZXJ2ZWQpO1xuICBpZiAocmVtYWluZGVyID4gMCkge1xuICAgIGNvbnN0IG9yYml0Um9vbSA9IG9yYml0RmVhc2libGVHVyAtIG9yYml0U2VydmVkO1xuICAgIGNvbnN0IGdyb3VuZFJvb20gPSBncm91bmRGZWFzaWJsZUdXIC0gZ3JvdW5kU2VydmVkO1xuICAgIGNvbnN0IGFkZFRvT3JiaXQgPSBNYXRoLm1pbihyZW1haW5kZXIsIE1hdGgubWF4KDAsIG9yYml0Um9vbSkpO1xuICAgIG9yYml0U2VydmVkICs9IGFkZFRvT3JiaXQ7XG4gICAgZ3JvdW5kU2VydmVkICs9IE1hdGgubWluKHJlbWFpbmRlciAtIGFkZFRvT3JiaXQsIE1hdGgubWF4KDAsIGdyb3VuZFJvb20pKTtcbiAgfVxuICBcbiAgLy8gUmVjYWxjdWxhdGUgc2hhcmVzIGZyb20gYWN0dWFsIHNlcnZlZCAoZW5zdXJlcyBzaGFyZXMgYXJlIDAuLjEgYW5kIHN1bSB0byAxKVxuICBjb25zdCB0b3RhbFNlcnZlZEdXID0gb3JiaXRTZXJ2ZWQgKyBncm91bmRTZXJ2ZWQ7XG4gIGNvbnN0IG9yYml0YWxTaGFyZUZyYWMgPSB0b3RhbFNlcnZlZEdXID4gMCA/IG9yYml0U2VydmVkIC8gdG90YWxTZXJ2ZWRHVyA6IDA7XG4gIGNvbnN0IGdyb3VuZFNoYXJlRnJhYyA9IHRvdGFsU2VydmVkR1cgPiAwID8gZ3JvdW5kU2VydmVkIC8gdG90YWxTZXJ2ZWRHVyA6IDA7XG4gIFxuICAvLyBVc2Ugc2VydmVkIHZhbHVlcyBmb3IgY2FwYWNpdHlcbiAgY29uc3QgZ3JvdW5kU2VydmVkQ29tcHV0ZUdXID0gZ3JvdW5kU2VydmVkO1xuICBjb25zdCBvcmJpdFNlcnZlZENvbXB1dGVHVyA9IG9yYml0U2VydmVkO1xuICBjb25zdCBncm91bmRGZWFzaWJsZUNvbXB1dGVHVyA9IGdyb3VuZEZlYXNpYmxlR1c7XG4gIGNvbnN0IG9yYml0RmVhc2libGVDb21wdXRlR1cgPSBvcmJpdEZlYXNpYmxlR1c7XG4gIFxuICAvLyBDYXBhY2l0eSBzZXJ2ZWQgKEdXKVxuICBjb25zdCBvcmJpdGFsQ2FwYWNpdHlHVyA9IG9yYml0U2VydmVkQ29tcHV0ZUdXO1xuICBjb25zdCBncm91bmRDYXBhY2l0eUdXID0gZ3JvdW5kU2VydmVkQ29tcHV0ZUdXO1xuICBcbiAgLy8gUmV2ZW51ZSBwZXIgR1cgKGFzc3VtZSAkMkIvR1cveWVhciBmb3IgY29tcHV0ZSBzZXJ2aWNlcylcbiAgY29uc3QgcmV2ZW51ZVBlckdXID0gMmU5O1xuICBjb25zdCBvcmJpdGFsUmV2ZW51ZSA9IG9yYml0YWxDYXBhY2l0eUdXICogcmV2ZW51ZVBlckdXO1xuICBjb25zdCBncm91bmRSZXZlbnVlID0gZ3JvdW5kQ2FwYWNpdHlHVyAqIHJldmVudWVQZXJHVztcbiAgXG4gIC8vIEludmFyaWFudHNcbiAgaWYgKG9yYml0YWxDYXBhY2l0eUdXID09PSAwICYmIG9yYml0YWxSZXZlbnVlICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBvcmJpdGFsQ2FwYWNpdHlHVz0wIGJ1dCBvcmJpdGFsUmV2ZW51ZT0ke29yYml0YWxSZXZlbnVlfSA+IDBgKTtcbiAgfVxuICBcbiAgaWYgKG9yYml0YWxSZXZlbnVlID4gMCAmJiBvcmJpdGFsQ2FwYWNpdHlHVyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBvcmJpdGFsUmV2ZW51ZT0ke29yYml0YWxSZXZlbnVlfSA+IDAgYnV0IG9yYml0YWxDYXBhY2l0eUdXPSR7b3JiaXRhbENhcGFjaXR5R1d9IDw9IDBgKTtcbiAgfVxuICBcbiAgaWYgKG9yYml0RmVhc2libGVDb21wdXRlR1cgPT09IDAgJiYgb3JiaXRhbFNoYXJlRnJhYyAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgb3JiaXRGZWFzaWJsZUNvbXB1dGVHVz0wIGJ1dCBvcmJpdGFsU2hhcmVGcmFjPSR7b3JiaXRhbFNoYXJlRnJhY30gPiAwYCk7XG4gIH1cbiAgXG4gIC8vIFNoYXJlcyBzaG91bGQgc3VtIHRvIDEuMCB3aGVuIGJvdGggZmVhc2libGUgYW5kIHRvdGFsU2VydmVkID4gMFxuICBpZiAodG90YWxTZXJ2ZWRHVyA+IDApIHtcbiAgICBjb25zdCBzaGFyZVN1bSA9IG9yYml0YWxTaGFyZUZyYWMgKyBncm91bmRTaGFyZUZyYWM7XG4gICAgaWYgKE1hdGguYWJzKHNoYXJlU3VtIC0gMS4wKSA+IDFlLTYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWFya2V0IHNoYXJlIHN1bSBtdXN0IGVxdWFsIDEuMCwgZ290ICR7c2hhcmVTdW19IChvcmJpdGFsPSR7b3JiaXRhbFNoYXJlRnJhY30sIGdyb3VuZD0ke2dyb3VuZFNoYXJlRnJhY30pYCk7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIHllYXIsXG4gICAgdG90YWxEZW1hbmRHVyxcbiAgICBvcmJpdGFsU2hhcmVGcmFjLFxuICAgIG9yYml0YWxDYXBhY2l0eUdXLFxuICAgIG9yYml0YWxSZXZlbnVlLFxuICAgIGdyb3VuZFNoYXJlRnJhYyxcbiAgICBncm91bmRDYXBhY2l0eUdXLFxuICAgIGRlYnVnOiB7XG4gICAgICBzaGFyZUNvbnZlbnRpb246ICdmcmFjJyxcbiAgICAgIG9yYml0YWxGZWFzaWJsZTogdHJ1ZSxcbiAgICAgIGdyb3VuZEZlYXNpYmxlOiB0cnVlLFxuICAgICAgb3JiaXRhbFNoYXJlRnJhYyxcbiAgICAgIGdyb3VuZFNoYXJlRnJhYyxcbiAgICAgIG9yYml0YWxDYXBhY2l0eUdXLFxuICAgICAgZ3JvdW5kQ2FwYWNpdHlHVyxcbiAgICAgIG9yYml0YWxSZXZlbnVlLFxuICAgICAgZ3JvdW5kUmV2ZW51ZSxcbiAgICAgIGRlbWFuZENvbXB1dGVHVzogZGVtYW5kLFxuICAgICAgZ3JvdW5kU2VydmVkQ29tcHV0ZUdXLFxuICAgICAgb3JiaXRTZXJ2ZWRDb21wdXRlR1csXG4gICAgICBncm91bmRGZWFzaWJsZUNvbXB1dGVHVyxcbiAgICAgIG9yYml0RmVhc2libGVDb21wdXRlR1csXG4gICAgICBiYWNrbG9nR1c6IGJhY2tsb2dHV0FjdHVhbCxcbiAgICAgIGJ1aWxkUmF0ZUdXeXI6IGJ1aWxkUmF0ZUdXeXJBY3R1YWwsXG4gICAgICBhdmdXYWl0WWVhcnM6IGF2Z1dhaXRZZWFycyA/PyAwLFxuICAgIH0sXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9qZWN0TWFya2V0UHJpY2UoXG4gIGJhc2VQcmljZTogbnVtYmVyLFxuICBiYXNlWWVhcjogbnVtYmVyLFxuICB0YXJnZXRZZWFyOiBudW1iZXIsXG4gIGFubnVhbERlY2xpbmVSYXRlOiBudW1iZXIgPSAwLjEwXG4pOiBudW1iZXIge1xuICBjb25zdCB5ZWFycyA9IHRhcmdldFllYXIgLSBiYXNlWWVhcjtcbiAgcmV0dXJuIGJhc2VQcmljZSAqIE1hdGgucG93KDEgLSBhbm51YWxEZWNsaW5lUmF0ZSwgeWVhcnMpO1xufVxuXG5leHBvcnQgY29uc3QgTUFSS0VUX1BST1ZJREVSUyA9IFtcbiAgeyBuYW1lOiAnQVdTIEgxMDAnLCBwcmljZTogNC41MCwgZGVjbGluZTogMC4xMCB9LFxuICB7IG5hbWU6ICdBenVyZSBIMTAwJywgcHJpY2U6IDQuMDAsIGRlY2xpbmU6IDAuMTAgfSxcbiAgeyBuYW1lOiAnQ29yZVdlYXZlJywgcHJpY2U6IDIuMjMsIGRlY2xpbmU6IDAuMTIgfSxcbiAgeyBuYW1lOiAnTGFtYmRhIExhYnMnLCBwcmljZTogMi40OSwgZGVjbGluZTogMC4xMCB9LFxuXTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gREVNQU5EIE1PREVMOiBJbnN0YWxsZWQgSVQgTG9hZCAoR1cpIHdpdGggUGllY2V3aXNlIEV4cG9uZW50aWFsIEdyb3d0aFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gXG4vLyBNb2RlbDogSVRfR1codCkgPSBpbnN0YWxsZWQgSVQgbG9hZCBpbiBHV1xuLy8gVGFyZ2V0czpcbi8vICAgLSBJVF9HVygyMDI1KSA9IElUMCAoYmFzZWxpbmUpXG4vLyAgIC0gSVRfR1coMjA0MCkgPSA0NTAgR1dcbi8vICAgLSBJVF9HVygyMDYwKSA9IDMwMDAgR1cgKG11bHRpLVRXIGJ5IDIwNjApXG4vL1xuLy8gUGllY2V3aXNlIGV4cG9uZW50aWFsOlxuLy8gICAtIDIwMjUtMjA0MDogSVRfR1codCkgPSBJVDAgKiBleHAocjEgKiAodCAtIDIwMjUpKVxuLy8gICAtIDIwNDAtMjA2MDogSVRfR1codCkgPSBJVF9HVygyMDQwKSAqIGV4cChyMiAqICh0IC0gMjA0MCkpXG4vL1xuLy8gVGhlbiBkZXJpdmU6XG4vLyAgIC0gRmFjaWxpdHlfR1codCkgPSBJVF9HVyh0KSAqIFBVRSh0KSAgKGhpdHMgdHJhbnNtaXNzaW9uL3N1YnN0YXRpb24gY29uc3RyYWludHMpXG4vLyAgIC0gRGVtYW5kTmV3R1codCkgPSBtYXgoMCwgRmFjaWxpdHlfR1codCkgLSBGYWNpbGl0eV9HVyh0LTEpKVxuXG4vLyBMRUdBQ1k6IEhhcmRjb2RlZCBkZW1hbmQgYW5jaG9ycyAoa2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgYnV0IHJlcGxhY2VkIGJ5IHJlc3BvbnNpdmUgZGVtYW5kKVxuY29uc3QgSVRfR1dfMjAyNSA9IDEyMDsgLy8gQmFzZWxpbmUgaW5zdGFsbGVkIElUIGxvYWQgaW4gMjAyNSAoR1cpXG5jb25zdCBJVF9HV18yMDQwX1RBUkdFVCA9IDQ1MDsgLy8gVGFyZ2V0IGluc3RhbGxlZCBJVCBsb2FkIGluIDIwNDAgKEdXKVxuY29uc3QgSVRfR1dfMjA2MF9UQVJHRVQgPSAzMDAwOyAvLyBUYXJnZXQgaW5zdGFsbGVkIElUIGxvYWQgaW4gMjA2MCAoR1cpXG5cbi8vIENhbGN1bGF0ZSBncm93dGggcmF0ZXNcbmNvbnN0IFIxID0gTWF0aC5sb2coSVRfR1dfMjA0MF9UQVJHRVQgLyBJVF9HV18yMDI1KSAvIDE1OyAvLyBHcm93dGggcmF0ZSAyMDI1LTIwNDBcbmNvbnN0IFIyID0gTWF0aC5sb2coSVRfR1dfMjA2MF9UQVJHRVQgLyBJVF9HV18yMDQwX1RBUkdFVCkgLyAyMDsgLy8gR3Jvd3RoIHJhdGUgMjA0MC0yMDYwXG5cbi8qKlxuICogRGVtYW5kIHN0YXRlIGZvciByZXNwb25zaXZlIGRlbWFuZCBjYWxjdWxhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIERlbWFuZFN0YXRlIHtcbiAgeWVhcjogbnVtYmVyO1xuICBiYXNlbGluZUdXOiBudW1iZXI7ICAgICAgICAvLyBXaGF0IGRlbWFuZCBXT1VMRCBiZSB3aXRob3V0IGNvbnN0cmFpbnRzXG4gIGVmZmVjdGl2ZUdXOiBudW1iZXI7ICAgICAgIC8vIEFjdHVhbCBkZW1hbmQgYWZ0ZXIgcHJpY2Uvd2FpdCByZXNwb25zZVxuICBncm91bmREZW1hbmRHVzogbnVtYmVyOyAgICAvLyBEZW1hbmQgZm9yIGdyb3VuZCBjb21wdXRlXG4gIG9yYml0YWxEZW1hbmRHVzogbnVtYmVyOyAgIC8vIERlbWFuZCBzaGlmdGVkIHRvIG9yYml0YWxcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgcHJpY2UtcmVzcG9uc2l2ZSBkZW1hbmQgdGhhdCBjcmVhdGVzIFMtY3VydmVcbiAqIFxuICogRGVtYW5kIHJlc3BvbmRzIHRvOlxuICogLSBQcmljZSBlbGFzdGljaXR5OiBoaWdoZXIgZ3JvdW5kIHByaWNlcyByZWR1Y2UgZGVtYW5kXG4gKiAtIFdhaXQgZWxhc3RpY2l0eTogbG9uZ2VyIHdhaXRzIHJlZHVjZSBkZW1hbmRcbiAqIC0gT3JiaXRhbCBzdWJzdGl0dXRpb246IGlmIG9yYml0YWwgY2hlYXBlciwgZGVtYW5kIHNoaWZ0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUmVzcG9uc2l2ZURlbWFuZChcbiAgeWVhcjogbnVtYmVyLFxuICBncm91bmRQcmljZVBlckdwdUhvdXI6IG51bWJlcixcbiAgb3JiaXRhbFByaWNlUGVyR3B1SG91cjogbnVtYmVyLFxuICBhdmdXYWl0WWVhcnM6IG51bWJlcixcbiAgcHJldkRlbWFuZFN0YXRlOiBEZW1hbmRTdGF0ZSB8IG51bGxcbik6IERlbWFuZFN0YXRlIHtcbiAgLy8gQmFzZWxpbmUgZGVtYW5kOiAxMCUgQ0FHUiBmcm9tIDEyMCBHVywgVEFQRVJFRCBhZnRlciAyMCB5ZWFyc1xuICBjb25zdCB5ZWFyc0Zyb20yMDI1ID0geWVhciAtIDIwMjU7XG4gIGNvbnN0IGdyb3d0aFJhdGUgPSAwLjEwOyAvLyAxMCUgQ0FHUlxuICBjb25zdCB0YXBlciA9IDEgLyAoMSArIE1hdGguZXhwKCh5ZWFyc0Zyb20yMDI1IC0gMjApIC8gNSkpOyAvLyBUYXBlcnMgYWZ0ZXIgMjA0NVxuICBjb25zdCBlZmZlY3RpdmVHcm93dGggPSBncm93dGhSYXRlICogKDAuNSArIDAuNSAqIHRhcGVyKTsgLy8gMTAlIC0+IDUlIENBR1JcbiAgY29uc3QgYmFzZWxpbmVHVyA9IDEyMCAqIE1hdGgucG93KDEgKyBlZmZlY3RpdmVHcm93dGgsIHllYXJzRnJvbTIwMjUpO1xuICBcbiAgLy8gUHJpY2UgZWxhc3RpY2l0eTogZGVtYW5kIGRyb3BzIGFzIGdyb3VuZCBwcmljZSByaXNlc1xuICBjb25zdCBiYXNlbGluZVByaWNlID0gNC4wMDsgLy8gJC9HUFUtaHIgcmVmZXJlbmNlXG4gIGNvbnN0IHByaWNlUmF0aW8gPSBncm91bmRQcmljZVBlckdwdUhvdXIgLyBiYXNlbGluZVByaWNlO1xuICBjb25zdCBwcmljZUVsYXN0aWNpdHkgPSAtMC4zOyAvLyAzMCUgZHJvcCBwZXIgMTAwJSBwcmljZSBpbmNyZWFzZVxuICBjb25zdCBwcmljZUZhY3RvciA9IE1hdGgucG93KHByaWNlUmF0aW8sIHByaWNlRWxhc3RpY2l0eSk7XG4gIFxuICAvLyBXYWl0IGVsYXN0aWNpdHk6IGRlbWFuZCBkcm9wcyB3aXRoIGxvbmdlciB3YWl0c1xuICBjb25zdCB3YWl0RWxhc3RpY2l0eSA9IC0wLjE1OyAvLyAxNSUgZHJvcCBwZXIgNXlyIHdhaXRcbiAgY29uc3Qgd2FpdEZhY3RvciA9IE1hdGguZXhwKGF2Z1dhaXRZZWFycyAqIHdhaXRFbGFzdGljaXR5IC8gNSk7XG4gIFxuICAvLyBFZmZlY3RpdmUgdG90YWwgZGVtYW5kIChtYXkgc2hpZnQgdG8gb3JiaXRhbClcbiAgY29uc3QgZWZmZWN0aXZlR1cgPSBiYXNlbGluZUdXICogcHJpY2VGYWN0b3IgKiB3YWl0RmFjdG9yO1xuICBcbiAgLy8gT3JiaXRhbCBzdWJzdGl0dXRpb246IGlmIG9yYml0YWwgPCBncm91bmQsIGRlbWFuZCBzaGlmdHNcbiAgY29uc3QgZ3JvdW5kT3JiaXRhbFJhdGlvID0gZ3JvdW5kUHJpY2VQZXJHcHVIb3VyIC8gTWF0aC5tYXgob3JiaXRhbFByaWNlUGVyR3B1SG91ciwgMC4wMSk7XG4gIGxldCBvcmJpdGFsU2hhcmUgPSAwO1xuICBpZiAoZ3JvdW5kT3JiaXRhbFJhdGlvID4gMS4wKSB7XG4gICAgLy8gT3JiaXRhbCBpcyBjaGVhcGVyIC0gbG9naXN0aWMgc2hpZnRcbiAgICAvLyBBdCByYXRpbyAxLjUgKGdyb3VuZCA1MCUgbW9yZSk6IH4zMCUgc2hpZnRzIHRvIG9yYml0YWxcbiAgICAvLyBBdCByYXRpbyAyLjAgKGdyb3VuZCAxMDAlIG1vcmUpOiB+NjAlIHNoaWZ0cyB0byBvcmJpdGFsXG4gICAgb3JiaXRhbFNoYXJlID0gMSAvICgxICsgTWF0aC5leHAoLTIgKiAoZ3JvdW5kT3JiaXRhbFJhdGlvIC0gMS4zKSkpO1xuICB9XG4gIFxuICBjb25zdCBvcmJpdGFsRGVtYW5kR1cgPSBlZmZlY3RpdmVHVyAqIG9yYml0YWxTaGFyZTtcbiAgY29uc3QgZ3JvdW5kRGVtYW5kR1cgPSBlZmZlY3RpdmVHVyAqICgxIC0gb3JiaXRhbFNoYXJlKTtcbiAgXG4gIHJldHVybiB7XG4gICAgeWVhcixcbiAgICBiYXNlbGluZUdXLFxuICAgIGVmZmVjdGl2ZUdXLFxuICAgIGdyb3VuZERlbWFuZEdXLFxuICAgIG9yYml0YWxEZW1hbmRHVyxcbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgaW5zdGFsbGVkIElUIGxvYWQgKEdXKSBmb3IgYSBnaXZlbiB5ZWFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJVExvYWRHVyh5ZWFyOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoeWVhciA8IDIwMjUpIHtcbiAgICByZXR1cm4gSVRfR1dfMjAyNTtcbiAgfVxuICBcbiAgaWYgKHllYXIgPD0gMjA0MCkge1xuICAgIC8vIFBoYXNlIDE6IDIwMjUtMjA0MFxuICAgIGNvbnN0IHllYXJzRnJvbTIwMjUgPSB5ZWFyIC0gMjAyNTtcbiAgICByZXR1cm4gSVRfR1dfMjAyNSAqIE1hdGguZXhwKFIxICogeWVhcnNGcm9tMjAyNSk7XG4gIH1cbiAgXG4gIC8vIFBoYXNlIDI6IDIwNDAtMjA2MFxuICBjb25zdCB5ZWFyc0Zyb20yMDQwID0geWVhciAtIDIwNDA7XG4gIHJldHVybiBJVF9HV18yMDQwX1RBUkdFVCAqIE1hdGguZXhwKFIyICogeWVhcnNGcm9tMjA0MCk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGZhY2lsaXR5IGxvYWQgKEdXKSA9IElUIGxvYWQgKiBQVUVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZhY2lsaXR5TG9hZEdXKHllYXI6IG51bWJlciwgcHVlOiBudW1iZXIgPSAxLjMpOiBudW1iZXIge1xuICBjb25zdCBpdExvYWRHVyA9IGdldElUTG9hZEdXKHllYXIpO1xuICByZXR1cm4gaXRMb2FkR1cgKiBwdWU7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIG5ldyBkZW1hbmQgKEdXKSA9IG1heCgwLCBGYWNpbGl0eV9HVyh0KSAtIEZhY2lsaXR5X0dXKHQtMSkpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZW1hbmROZXdHVyh5ZWFyOiBudW1iZXIsIHB1ZTogbnVtYmVyID0gMS4zKTogbnVtYmVyIHtcbiAgY29uc3QgZmFjaWxpdHlHVyA9IGdldEZhY2lsaXR5TG9hZEdXKHllYXIsIHB1ZSk7XG4gIGNvbnN0IGZhY2lsaXR5R1dQcmV2ID0gZ2V0RmFjaWxpdHlMb2FkR1coeWVhciAtIDEsIHB1ZSk7XG4gIHJldHVybiBNYXRoLm1heCgwLCBmYWNpbGl0eUdXIC0gZmFjaWxpdHlHV1ByZXYpO1xufVxuXG4vKipcbiAqIExlZ2FjeSBmdW5jdGlvbjogcmV0dXJucyBJVCBsb2FkIChub3QgZmFjaWxpdHkgbG9hZClcbiAqIEtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERlbWFuZFByb2plY3Rpb24oeWVhcjogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIGdldElUTG9hZEdXKHllYXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVRyYWplY3Rvcnkob3B0aW9uczogVHJhamVjdG9yeU9wdGlvbnMpOiBZZWFybHlCcmVha2Rvd25bXSB7XG4gIC8vIFJlLWV4cG9ydCBjcm9zc292ZXIgYW5hbHlzaXMgZnVuY3Rpb25zIGZvciBjb252ZW5pZW5jZVxuICAvLyBVc2VycyBjYW4gaW1wb3J0IGZyb20gdHJhamVjdG9yeS50cyBvciBjcm9zc292ZXJBbmFseXNpcy50c1xuICBjb25zdCB5ZWFycyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI2IH0sIChfLCBpKSA9PiAyMDI1ICsgaSk7IC8vIDIwMjUtMjA1MCAoMjYgeWVhcnMpXG4gIGNvbnN0IHRyYWplY3Rvcnk6IFllYXJseUJyZWFrZG93bltdID0gW107XG4gIGxldCBmaXJzdENhcFllYXI6IG51bWJlciB8IG51bGwgPSBudWxsOyAvLyBUcmFjayB3aGVuIGNvbnN0cmFpbnQgY2FwIHdhcyBmaXJzdCBoaXRcbiAgXG4gIC8vIExhdW5jaCBsZWFybmluZzogVHJhY2sgY3VtdWxhdGl2ZSBtYXNzIHRvIG9yYml0XG4gIGxldCBsYXVuY2hMZWFybmluZ1N0YXRlOiBMYXVuY2hMZWFybmluZ1N0YXRlIHwgbnVsbCA9IG51bGw7XG4gIGNvbnN0IEJBU0VMSU5FX01BU1NfS0cgPSAxXzAwMF8wMDA7IC8vIDFNIGtnIGJhc2VsaW5lIGZvciBkb3VibGluZ3MgY2FsY3VsYXRpb25cbiAgY29uc3QgTEFVTkNIX0NPU1RfMF9QRVJfS0cgPSAxNTAwOyAvLyBJbml0aWFsIGxhdW5jaCBjb3N0IGluIDIwMjVcbiAgXG4gIC8vIFJlc3BvbnNpdmUgZGVtYW5kOiBUcmFjayBkZW1hbmQgc3RhdGUgYWNyb3NzIHllYXJzIGZvciBTLWN1cnZlIGJlaGF2aW9yXG4gIGxldCBwcmV2RGVtYW5kU3RhdGU6IERlbWFuZFN0YXRlIHwgbnVsbCA9IG51bGw7XG4gIGxldCBwcmV2WWVhckJyZWFrZG93bjogWWVhcmx5QnJlYWtkb3duIHwgbnVsbCA9IG51bGw7XG4gIFxuICAvLyBCdWlsZG91dCBzdGF0ZTogVHJhY2sgYWNyb3NzIHllYXJzIGZvciBiYWNrbG9nIGNhbGN1bGF0aW9uXG4gIGxldCBidWlsZG91dFN0YXRlOiBpbXBvcnQoJy4vZ3JvdW5kX2J1aWxkb3V0JykuQnVpbGRvdXRTdGF0ZSB8IG51bGwgPSBudWxsO1xuICBcbiAgLy8gTW9iaWxpemF0aW9uIHN0YXRlOiBUcmFjayBhY3Jvc3MgeWVhcnMgZm9yIGNhcGFjaXR5L2JhY2tsb2cgZXZvbHV0aW9uXG4gIGxldCBtb2JpbGl6YXRpb25TdGF0ZTogaW1wb3J0KCcuL2dyb3VuZF9yYW1waW5nX21vYmlsaXphdGlvbicpLk1vYmlsaXphdGlvblN0YXRlIHwgbnVsbCA9IG51bGw7XG5cbiAgZm9yIChjb25zdCB5ZWFyIG9mIHllYXJzKSB7XG4gICAgY29uc3QgcGFyYW1zID0gb3B0aW9ucy5tb2RlID09PSAnU1RBVElDJyBcbiAgICAgID8gZ2V0U3RhdGljUGFyYW1zKHllYXIpXG4gICAgICA6IG9wdGlvbnMucGFyYW1zQnlZZWFyKHllYXIpO1xuXG4gICAgLy8gQXBwbHkgbGF1bmNoIGxlYXJuaW5nIGlmIGVuYWJsZWRcbiAgICBsZXQgbGF1bmNoQ29zdFBlcktnID0gZ2V0TGF1bmNoQ29zdFBlcktnKHllYXIsIHBhcmFtcy5sYXVuY2hDb3N0S2cpO1xuICAgIGxldCBwYXJhbXNXaXRoTGF1bmNoQ29zdCA9IHBhcmFtcztcbiAgICBpZiAob3B0aW9ucy51c2VMYXVuY2hMZWFybmluZykge1xuICAgICAgLy8gRXN0aW1hdGUgbWFzcyBkZW1hbmRlZCBmcm9tIGNvbXB1dGUgcG93ZXI6IH4xMDAwIGtnIHBlciBNVyBjb21wdXRlXG4gICAgICAvLyBVc2UgdGFyZ2V0R1cgYXMgcHJveHkgZm9yIG9yYml0YWwgY29tcHV0ZSBkZW1hbmRcbiAgICAgIGNvbnN0IGNvbXB1dGVQb3dlck1XID0gcGFyYW1zLnRhcmdldEdXICogMTAwMDsgLy8gQ29udmVydCBHVyB0byBNV1xuICAgICAgY29uc3QgbWFzc1Blck1XID0gMTAwMDsgLy8gUm91Z2ggZXN0aW1hdGU6IDEwMDAga2cgcGVyIE1XXG4gICAgICBjb25zdCBtYXNzRGVtYW5kZWRLZyA9IGNvbXB1dGVQb3dlck1XICogbWFzc1Blck1XO1xuICAgICAgXG4gICAgICBjb25zdCBsYXVuY2hMZWFybmluZ1Jlc3VsdCA9IHN0ZXBMYXVuY2hMZWFybmluZyhsYXVuY2hMZWFybmluZ1N0YXRlLCB7XG4gICAgICAgIHllYXIsXG4gICAgICAgIG1hc3NEZW1hbmRlZEtnLFxuICAgICAgICBiYXNlbGluZU1hc3NLZzogQkFTRUxJTkVfTUFTU19LRyxcbiAgICAgICAgbGF1bmNoQ29zdDBQZXJLZzogTEFVTkNIX0NPU1RfMF9QRVJfS0csXG4gICAgICAgIGxlYXJuaW5nUmF0ZTogMC4xNSwgLy8gMTUlIHJlZHVjdGlvbiBwZXIgZG91YmxpbmdcbiAgICAgICAgbWF4RmxpZ2h0c1BlclllYXI6IDEwMDAsXG4gICAgICAgIHBheWxvYWRQZXJGbGlnaHRLZzogMTAwXzAwMCwgLy8gU3RhcnNoaXAgY2FwYWNpdHlcbiAgICAgIH0pO1xuICAgICAgbGF1bmNoQ29zdFBlcktnID0gbGF1bmNoTGVhcm5pbmdSZXN1bHQubGF1bmNoQ29zdFBlcktnO1xuICAgICAgbGF1bmNoTGVhcm5pbmdTdGF0ZSA9IGxhdW5jaExlYXJuaW5nUmVzdWx0LnN0YXRlO1xuICAgICAgXG4gICAgICAvLyBPdmVycmlkZSBsYXVuY2ggY29zdCBpbiBwYXJhbXMgZm9yIHRoaXMgeWVhclxuICAgICAgcGFyYW1zV2l0aExhdW5jaENvc3QgPSB7IC4uLnBhcmFtcywgbGF1bmNoQ29zdEtnOiBsYXVuY2hDb3N0UGVyS2cgfTtcbiAgICB9XG5cbiAgICAvLyBQYXNzIGZpcnN0Q2FwWWVhciBhbmQgbW9iaWxpemF0aW9uU3RhdGUgdG8gY29tcHV0ZVBoeXNpY3NDb3N0XG4gICAgLy8gQWRkIG1vYmlsaXphdGlvbiBzdGF0ZSB0byBwYXJhbXMgc28gaXQgY2FuIGJlIHVzZWQgZm9yIGJhY2tsb2cgY2FsY3VsYXRpb25cbiAgICBjb25zdCBwYXJhbXNXaXRoTW9iaWxpemF0aW9uID0ge1xuICAgICAgLi4ucGFyYW1zV2l0aExhdW5jaENvc3QsXG4gICAgICBwcmV2TW9iaWxpemF0aW9uU3RhdGU6IG1vYmlsaXphdGlvblN0YXRlLFxuICAgIH0gYXMgYW55OyAvLyBUeXBlIGFzc2VydGlvbiBuZWVkZWQgc2luY2UgWWVhclBhcmFtcyBkb2Vzbid0IGluY2x1ZGUgcHJldk1vYmlsaXphdGlvblN0YXRlXG4gICAgY29uc3QgYnJlYWtkb3duID0gY29tcHV0ZVBoeXNpY3NDb3N0KHBhcmFtc1dpdGhNb2JpbGl6YXRpb24sIGZpcnN0Q2FwWWVhcik7XG4gICAgXG4gICAgLy8gVXBkYXRlIGxhdW5jaCBsZWFybmluZyBzdGF0ZSB3aXRoIGFjdHVhbCBtYXNzIGZyb20gYnJlYWtkb3duIChmb3IgbmV4dCBpdGVyYXRpb24pXG4gICAgaWYgKG9wdGlvbnMudXNlTGF1bmNoTGVhcm5pbmcgJiYgYnJlYWtkb3duLm9yYml0ICYmIGJyZWFrZG93bi5vcmJpdC5oeWJyaWRCcmVha2Rvd24pIHtcbiAgICAgIC8vIFVzZSBhY3R1YWwgbWFzcyBmcm9tIGh5YnJpZCBicmVha2Rvd24gaWYgYXZhaWxhYmxlXG4gICAgICAvLyBNYXNzIGlzIG5vdCBkaXJlY3RseSBpbiBvcmJpdGFsIGJyZWFrZG93biwgYnV0IHdlIGNhbiBlc3RpbWF0ZSBmcm9tIGxhdW5jaCBjb3N0XG4gICAgICAvLyBGb3Igbm93LCB1c2UgdGhlIG1hc3MgZGVtYW5kZWQgZXN0aW1hdGUgKHdpbGwgYmUgcmVmaW5lZCBpbiBuZXh0IGl0ZXJhdGlvbilcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY29uc3RyYWludEJyZWFrZG93biA9IGJyZWFrZG93bi5ncm91bmQuY29uc3RyYWludEJyZWFrZG93bjtcbiAgICBpZiAoY29uc3RyYWludEJyZWFrZG93biAmJiAnY2FwWWVhcicgaW4gY29uc3RyYWludEJyZWFrZG93biAmJiBjb25zdHJhaW50QnJlYWtkb3duLmNhcFllYXIgIT09IG51bGwgJiYgY29uc3RyYWludEJyZWFrZG93bi5jYXBZZWFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHRoaXNDYXBZZWFyID0gY29uc3RyYWludEJyZWFrZG93bi5jYXBZZWFyIGFzIG51bWJlcjtcbiAgICAgIGlmIChmaXJzdENhcFllYXIgPT09IG51bGwgfHwgdGhpc0NhcFllYXIgPCBmaXJzdENhcFllYXIpIHtcbiAgICAgICAgZmlyc3RDYXBZZWFyID0gdGhpc0NhcFllYXI7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFNJTkdMRSBTT1VSQ0UgT0YgVFJVVEg6IGNvbXB1dGUgZGVtYW5kIGluIEdXIHVzaW5nIFJFU1BPTlNJVkUgZGVtYW5kXG4gICAgLy8gRGVtYW5kIHJlc3BvbmRzIHRvIHByaWNlcywgd2FpdCB0aW1lcywgYW5kIG9yYml0YWwgc3Vic3RpdHV0aW9uIChjcmVhdGVzIFMtY3VydmUpXG4gICAgY29uc3QgZ3JvdW5kUHVlID0gYnJlYWtkb3duLmdyb3VuZD8ucHVlID8/IHBhcmFtcy5wdWVHcm91bmQgPz8gMS4zO1xuICAgIFxuICAgIC8vIEdldCBwcmljZXMgZnJvbSBwcmV2aW91cyB5ZWFyIChvciBlc3RpbWF0ZXMgZm9yIGZpcnN0IHllYXIpXG4gICAgY29uc3QgcHJldkdyb3VuZFByaWNlID0gcHJldlllYXJCcmVha2Rvd24/Lmdyb3VuZD8uZ3B1SG91clByaWNpbmc/LnN0YW5kYXJkPy5wcmljZVBlckdwdUhvdXIgPz8gNC4wMDtcbiAgICBjb25zdCBwcmV2T3JiaXRhbFByaWNlID0gcHJldlllYXJCcmVha2Rvd24/Lm9yYml0Py5ncHVIb3VyUHJpY2luZz8uc3RhbmRhcmQ/LnByaWNlUGVyR3B1SG91ciA/PyAyNS4wMDtcbiAgICBjb25zdCBwcmV2QXZnV2FpdCA9IHByZXZZZWFyQnJlYWtkb3duPy5ncm91bmQ/LnN1cHBseU1ldHJpY3M/LmF2Z1dhaXRZZWFycyA/PyAwO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSByZXNwb25zaXZlIGRlbWFuZCAocHJpY2Uvd2FpdCBlbGFzdGljLCBvcmJpdGFsIHN1YnN0aXR1dGlvbilcbiAgICBjb25zdCBkZW1hbmRTdGF0ZSA9IGNhbGN1bGF0ZVJlc3BvbnNpdmVEZW1hbmQoXG4gICAgICB5ZWFyLFxuICAgICAgcHJldkdyb3VuZFByaWNlLFxuICAgICAgcHJldk9yYml0YWxQcmljZSxcbiAgICAgIHByZXZBdmdXYWl0LFxuICAgICAgcHJldkRlbWFuZFN0YXRlXG4gICAgKTtcbiAgICBwcmV2RGVtYW5kU3RhdGUgPSBkZW1hbmRTdGF0ZTtcbiAgICBcbiAgICAvLyBVc2UgcmVzcG9uc2l2ZSBncm91bmQgZGVtYW5kIChmYWNpbGl0eSBsb2FkID0gZ3JvdW5kIGRlbWFuZCAqIFBVRSlcbiAgICBjb25zdCBkZW1hbmRDb21wdXRlR1cgPSBkZW1hbmRTdGF0ZS5ncm91bmREZW1hbmRHVyAqIGdyb3VuZFB1ZTsgLy8gQ29udmVydCBJVCBsb2FkIHRvIGZhY2lsaXR5IGxvYWRcbiAgICBjb25zdCBvcmJpdGFsRGVtYW5kR1cgPSBkZW1hbmRTdGF0ZS5vcmJpdGFsRGVtYW5kR1cgKiBncm91bmRQdWU7IC8vIEZvciBvcmJpdGFsIGNhcGFjaXR5IHBsYW5uaW5nXG4gICAgXG4gICAgLy8gQ1JJVElDQUw6IEVuc3VyZSBncm91bmQuYnVpbGRvdXREZWJ1Zy5kZW1hbmRHVyBtYXRjaGVzIHNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGhcbiAgICAvLyBPdmVycmlkZSBhbnkgdmFsdWUgZnJvbSBidWlsZG91dCBtb2RlbCB0byBlbnN1cmUgY29uc2lzdGVuY3lcbiAgICBpZiAoYnJlYWtkb3duLmdyb3VuZD8uYnVpbGRvdXREZWJ1Zykge1xuICAgICAgYnJlYWtkb3duLmdyb3VuZC5idWlsZG91dERlYnVnLmRlbWFuZEdXID0gZGVtYW5kQ29tcHV0ZUdXO1xuICAgIH1cbiAgICBcbiAgICAvLyBVc2UgZGVtYW5kQ29tcHV0ZUdXIGZvciBhbGwgbWFya2V0IGNhbGN1bGF0aW9ucyAoc2luZ2xlIHNvdXJjZSBvZiB0cnV0aClcbiAgICBjb25zdCB0b3RhbERlbWFuZEdXID0gZGVtYW5kQ29tcHV0ZUdXO1xuICAgIFxuICAgIGNvbnN0IG9yYml0YWxGZWFzaWJsZSA9IGJyZWFrZG93bi5vcmJpdCAmJiBicmVha2Rvd24ub3JiaXQudG90YWxDb3N0UGVyUGZsb3BZZWFyID4gMCAmJiBicmVha2Rvd24ub3JiaXQudG90YWxDb3N0UGVyUGZsb3BZZWFyIDwgSW5maW5pdHk7XG4gICAgY29uc3QgZ3JvdW5kRmVhc2libGUgPSBicmVha2Rvd24uZ3JvdW5kICYmIGJyZWFrZG93bi5ncm91bmQudG90YWxDb3N0UGVyUGZsb3BZZWFyID4gMCAmJiBicmVha2Rvd24uZ3JvdW5kLnRvdGFsQ29zdFBlclBmbG9wWWVhciA8IEluZmluaXR5O1xuICAgIGNvbnN0IG9yYml0YWxDb3N0QWNjb3VudGluZ1ZhbGlkID0gYnJlYWtkb3duLmNvc3RBY2NvdW50aW5nVmFsaWQgIT09IGZhbHNlO1xuICAgIGNvbnN0IGdyb3VuZENvc3RBY2NvdW50aW5nVmFsaWQgPSBicmVha2Rvd24uY29zdEFjY291bnRpbmdWYWxpZCAhPT0gZmFsc2U7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIG9yYml0YWwgY2FwYWNpdHkgR1cgZnJvbSBjb25zdGVsbGF0aW9uOiAobnVtU2F0ZWxsaXRlcyAqIGNvbXB1dGVQZXJTYXRLdykgLyAxZTZcbiAgICAvLyBrVyAtPiBHVyBjb252ZXJzaW9uOiBkaXZpZGUgYnkgMSwwMDAsMDAwICgxZTYpXG4gICAgLy8gQ1JJVElDQUw6IGNvbXB1dGVQZXJTYXRLdyBpcyBpbiBrVywgc28gZGl2aWRlIGJ5IDFlNiB0byBnZXQgR1cgKG5vdCAxZTMgZm9yIE1XKVxuICAgIGxldCBvcmJpdGFsQ2FwYWNpdHlHV19mcm9tU2F0cyA9IDA7XG4gICAgaWYgKGJyZWFrZG93bi5vcmJpdD8uY29uc3RlbGxhdGlvbj8uZGVzaWduKSB7XG4gICAgICBjb25zdCB7IG51bVNhdGVsbGl0ZXMsIGNvbXB1dGVQZXJTYXRLdyB9ID0gYnJlYWtkb3duLm9yYml0LmNvbnN0ZWxsYXRpb24uZGVzaWduO1xuICAgICAgLy8ga1cgLT4gR1c6IGRpdmlkZSBieSAxLDAwMCwwMDAgKDFlNiksIE5PVCAxLDAwMCAoMWUzKVxuICAgICAgb3JiaXRhbENhcGFjaXR5R1dfZnJvbVNhdHMgPSAobnVtU2F0ZWxsaXRlcyAqIGNvbXB1dGVQZXJTYXRLdykgLyAxXzAwMF8wMDA7XG4gICAgICBcbiAgICAgIC8vIEludmFyaWFudDogMSBzYXRlbGxpdGUgYXQgMTExIGtXIHNob3VsZCBiZSAwLjAwMDExMSBHVywgbm90IDEuMTQ0IEdXXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgbnVtU2F0ZWxsaXRlcyA9PT0gMSkge1xuICAgICAgICBjb25zdCBleHBlY3RlZEdXID0gY29tcHV0ZVBlclNhdEt3IC8gMV8wMDBfMDAwO1xuICAgICAgICBjb25zdCBlcnJvciA9IE1hdGguYWJzKG9yYml0YWxDYXBhY2l0eUdXX2Zyb21TYXRzIC0gZXhwZWN0ZWRHVykgLyBNYXRoLm1heChleHBlY3RlZEdXLCAxZS05KTtcbiAgICAgICAgaWYgKGVycm9yID4gMC4wMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBbT1JCSVRBTCBDQVBBQ0lUWSBCVUddIFllYXIgJHt5ZWFyfTogMSBzYXRlbGxpdGUgYXQgJHtjb21wdXRlUGVyU2F0S3d9IGtXIHNob3VsZCBiZSAke2V4cGVjdGVkR1d9IEdXLCBgICtcbiAgICAgICAgICAgIGBidXQgZ290ICR7b3JiaXRhbENhcGFjaXR5R1dfZnJvbVNhdHN9IEdXLiBDaGVjayBrVy0+R1cgY29udmVyc2lvbiAobXVzdCBkaXZpZGUgYnkgMWU2LCBub3QgMWUzKS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBjaGFydFBCID0gYnJlYWtkb3duLm1ldGFkYXRhPy5jaGFydElucHV0cz8ucG93ZXJCdWlsZG91dDtcbiAgICBjb25zdCBjaGFydEJhY2tsb2cgPSBjaGFydFBCPy5iYWNrbG9nR3c7XG4gICAgY29uc3QgY2hhcnRBdmdXYWl0ID0gY2hhcnRQQj8uYXZnV2FpdFllYXJzO1xuICAgIGNvbnN0IGNoYXJ0QnVpbGRSYXRlID0gY2hhcnRQQj8ubWF4QnVpbGRSYXRlR3dZZWFyO1xuICAgIFxuICAgIC8vIFByZWZlciBidWlsZG91dERlYnVnIHdoZW4gcHJlc2VudC5cbiAgICAvLyBJZiBncm91bmQvYmFja2xvZyBmaWVsZHMgZXhpc3QgYnV0IGFyZSAwIHdoaWxlIGNoYXJ0SW5wdXRzIHNheXMgPjAsIHVzZSBjaGFydElucHV0cy5cbiAgICAvLyBSZW1vdmUgdGhlIHBpcGVsaW5lR3cgcHJveHkgZW50aXJlbHkgKGl0J3Mgbm90IGJhY2tsb2cgYW5kIGNhdXNlcyBzaWxlbnQgdW5pdC9tZWFuaW5nIGNvcnJ1cHRpb24pLlxuICAgIGNvbnN0IGJhY2tsb2dGcm9tR3JvdW5kID0gYnJlYWtkb3duLmdyb3VuZD8uYmFja2xvZ0d3O1xuICAgIGNvbnN0IGJhY2tsb2dGcm9tQnVpbGRvdXQgPSBicmVha2Rvd24uZ3JvdW5kPy5idWlsZG91dERlYnVnPy5iYWNrbG9nR1c7XG4gICAgbGV0IGJhY2tsb2dHVyA9XG4gICAgICAoYmFja2xvZ0Zyb21CdWlsZG91dCAhPT0gdW5kZWZpbmVkID8gYmFja2xvZ0Zyb21CdWlsZG91dCA6IHVuZGVmaW5lZCkgPz9cbiAgICAgICgoYmFja2xvZ0Zyb21Hcm91bmQgIT09IHVuZGVmaW5lZCAmJiBiYWNrbG9nRnJvbUdyb3VuZCA+IDApID8gYmFja2xvZ0Zyb21Hcm91bmQgOiB1bmRlZmluZWQpID8/XG4gICAgICAoKGNoYXJ0QmFja2xvZyAhPT0gdW5kZWZpbmVkICYmIGNoYXJ0QmFja2xvZyA+IDApID8gY2hhcnRCYWNrbG9nIDogMCk7XG4gICAgXG4gICAgY29uc3QgYnVpbGRSYXRlRnJvbUJ1aWxkb3V0ID0gYnJlYWtkb3duLmdyb3VuZD8uYnVpbGRvdXREZWJ1Zz8uYnVpbGRSYXRlR1d5cjtcbiAgICBjb25zdCBidWlsZFJhdGVGcm9tU3VwcGx5ID0gYnJlYWtkb3duLmdyb3VuZD8uc3VwcGx5TWV0cmljcz8ubWF4QnVpbGRSYXRlR3dZZWFyO1xuICAgIGNvbnN0IGJ1aWxkUmF0ZUdXeXIgPVxuICAgICAgKGJ1aWxkUmF0ZUZyb21CdWlsZG91dCAhPT0gdW5kZWZpbmVkID8gYnVpbGRSYXRlRnJvbUJ1aWxkb3V0IDogdW5kZWZpbmVkKSA/P1xuICAgICAgKGJ1aWxkUmF0ZUZyb21TdXBwbHkgIT09IHVuZGVmaW5lZCA/IGJ1aWxkUmF0ZUZyb21TdXBwbHkgOiB1bmRlZmluZWQpID8/XG4gICAgICAoY2hhcnRCdWlsZFJhdGUgIT09IHVuZGVmaW5lZCA/IGNoYXJ0QnVpbGRSYXRlIDogMCk7XG4gICAgXG4gICAgY29uc3QgYXZnV2FpdEZyb21Hcm91bmQgPSBicmVha2Rvd24uZ3JvdW5kPy5hdmdXYWl0WWVhcnM7XG4gICAgY29uc3QgYXZnV2FpdEZyb21CdWlsZG91dCA9IGJyZWFrZG93bi5ncm91bmQ/LmJ1aWxkb3V0RGVidWc/LnRpbWVUb1Bvd2VyWWVhcnM7XG4gICAgY29uc3QgYXZnV2FpdEZyb21TdXBwbHkgPSBicmVha2Rvd24uZ3JvdW5kPy5zdXBwbHlNZXRyaWNzPy5hdmdXYWl0WWVhcnM7XG4gICAgbGV0IGF2Z1dhaXRZZWFycyA9XG4gICAgICAoYXZnV2FpdEZyb21CdWlsZG91dCAhPT0gdW5kZWZpbmVkID8gYXZnV2FpdEZyb21CdWlsZG91dCA6IHVuZGVmaW5lZCkgPz9cbiAgICAgICgoYXZnV2FpdEZyb21Hcm91bmQgIT09IHVuZGVmaW5lZCAmJiBhdmdXYWl0RnJvbUdyb3VuZCA+IDApID8gYXZnV2FpdEZyb21Hcm91bmQgOiB1bmRlZmluZWQpID8/XG4gICAgICAoKGF2Z1dhaXRGcm9tU3VwcGx5ICE9PSB1bmRlZmluZWQgJiYgYXZnV2FpdEZyb21TdXBwbHkgPiAwKSA/IGF2Z1dhaXRGcm9tU3VwcGx5IDogdW5kZWZpbmVkKSA/P1xuICAgICAgKChjaGFydEF2Z1dhaXQgIT09IHVuZGVmaW5lZCAmJiBjaGFydEF2Z1dhaXQgPiAwKSA/IGNoYXJ0QXZnV2FpdCA6IDApO1xuICAgIFxuICAgIC8vIFNlbGYtaGVhbCBwbHVtYmluZyBtaXNtYXRjaGVzOiBpZiBjaGFydElucHV0cyBoYXMgcG9zaXRpdmUgdmFsdWUgYnV0IGNob3NlbiBpcyAwLCB1c2UgY2hhcnRJbnB1dHNcbiAgICAvLyBMb2cgc3RydWN0dXJlZCBlcnJvciBidXQgbmV2ZXIgdGhyb3cgKHByZXZlbnRzIGNoYXJ0IGZyb20gZGlzYXBwZWFyaW5nKVxuICAgIGlmICgoY2hhcnRCYWNrbG9nID8/IDApID4gMCAmJiBiYWNrbG9nR1cgPT09IDAgJiYgY2hhcnRCYWNrbG9nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJhY2tsb2dHVyA9IGNoYXJ0QmFja2xvZztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYFtCQUNLTE9HIFBMVU1CSU5HXSBZZWFyICR7eWVhcn06IGNoYXJ0SW5wdXRzLmJhY2tsb2dHdz0ke2NoYXJ0QmFja2xvZ30gYnV0IGZhbGxiYWNrIGNoYWluIHJldHVybmVkIDAuIGAgK1xuICAgICAgICAgIGBTZWxmLWhlYWxlZDogdXNpbmcgY2hhcnRJbnB1dHMuIGAgK1xuICAgICAgICAgIGBDYW5kaWRhdGVzOiBncm91bmQuYmFja2xvZ0d3PSR7YnJlYWtkb3duLmdyb3VuZD8uYmFja2xvZ0d3fSwgYCArXG4gICAgICAgICAgYGJ1aWxkb3V0RGVidWcuYmFja2xvZ0dXPSR7YnJlYWtkb3duLmdyb3VuZD8uYnVpbGRvdXREZWJ1Zz8uYmFja2xvZ0dXfSwgYCArXG4gICAgICAgICAgYHN1cHBseU1ldHJpY3MucGlwZWxpbmVHdz0ke2JyZWFrZG93bi5ncm91bmQ/LnN1cHBseU1ldHJpY3M/LnBpcGVsaW5lR3d9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKGNoYXJ0QXZnV2FpdCA/PyAwKSA+IDAgJiYgYXZnV2FpdFllYXJzID09PSAwICYmIGNoYXJ0QXZnV2FpdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhdmdXYWl0WWVhcnMgPSBjaGFydEF2Z1dhaXQ7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGBbV0FJVCBQTFVNQklOR10gWWVhciAke3llYXJ9OiBjaGFydElucHV0cy5hdmdXYWl0WWVhcnM9JHtjaGFydEF2Z1dhaXR9IGJ1dCBmYWxsYmFjayBjaGFpbiByZXR1cm5lZCAwLiBgICtcbiAgICAgICAgICBgU2VsZi1oZWFsZWQ6IHVzaW5nIGNoYXJ0SW5wdXRzLiBgICtcbiAgICAgICAgICBgQ2FuZGlkYXRlczogZ3JvdW5kLmF2Z1dhaXRZZWFycz0ke2JyZWFrZG93bi5ncm91bmQ/LmF2Z1dhaXRZZWFyc30sIGAgK1xuICAgICAgICAgIGBidWlsZG91dERlYnVnLnRpbWVUb1Bvd2VyWWVhcnM9JHticmVha2Rvd24uZ3JvdW5kPy5idWlsZG91dERlYnVnPy50aW1lVG9Qb3dlclllYXJzfSwgYCArXG4gICAgICAgICAgYHN1cHBseU1ldHJpY3MuYXZnV2FpdFllYXJzPSR7YnJlYWtkb3duLmdyb3VuZD8uc3VwcGx5TWV0cmljcz8uYXZnV2FpdFllYXJzfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIG9yYml0TWF4RGVwbG95YWJsZUNvbXB1dGVHVyBmcm9tIGNvbnN0ZWxsYXRpb24gY2FwYWNpdHkgb3Igc2NlbmFyaW8gcGFyYW1zXG4gICAgLy8gQ2Fub25pY2FsIG9yYml0YWwgY2FwYWNpdHkgZnJvbSBjb25zdGVsbGF0aW9uOiAobnVtU2F0ZWxsaXRlcyAqIGNvbXB1dGVQZXJTYXRLdykgLyAxZTZcbiAgICBjb25zdCBvcmJpdE1heERlcGxveWFibGVDb21wdXRlR1cgPSBvcmJpdGFsRmVhc2libGUgXG4gICAgICA/IChwYXJhbXMub3JiaXRNYXhEZXBsb3lhYmxlQ29tcHV0ZUdXQnlZZWFyPy4oeWVhcikgPz8gb3JiaXRhbENhcGFjaXR5R1dfZnJvbVNhdHMpXG4gICAgICA6IDA7XG4gICAgXG4gICAgLy8gRml4IG9yYml0IGZlYXNpYmlsaXR5IGdhdGluZzogdXNlIG9yYml0TWF4RGVwbG95YWJsZUNvbXB1dGVHVywgbm90IG9yYml0YWxDYXBhY2l0eUdXIHBsYWNlaG9sZGVyXG4gICAgY29uc3Qgb3JiaXRhbEZlYXNpYmxlRm9yU2hhcmUgPSBvcmJpdGFsRmVhc2libGUgJiYgKG9yYml0TWF4RGVwbG95YWJsZUNvbXB1dGVHVyA+IDApO1xuICAgIFxuICAgIGNvbnN0IG1hcmtldEFuYWx5c2lzID0gY2FsY3VsYXRlTWFya2V0U2hhcmUoXG4gICAgICB5ZWFyLFxuICAgICAgYnJlYWtkb3duLm9yYml0LnRvdGFsQ29zdFBlclBmbG9wWWVhcixcbiAgICAgIGJyZWFrZG93bi5ncm91bmQudG90YWxDb3N0UGVyUGZsb3BZZWFyLFxuICAgICAgdG90YWxEZW1hbmRHVyxcbiAgICAgIG9yYml0YWxGZWFzaWJsZUZvclNoYXJlLFxuICAgICAgZ3JvdW5kRmVhc2libGUsXG4gICAgICBvcmJpdGFsQ29zdEFjY291bnRpbmdWYWxpZCxcbiAgICAgIGdyb3VuZENvc3RBY2NvdW50aW5nVmFsaWQsXG4gICAgICBkZW1hbmRDb21wdXRlR1csIC8vIFVzZSBzaW5nbGUgc291cmNlIG9mIHRydXRoLCBub3QgZ3JvdW5kIG1vZGVsIGRlbWFuZFxuICAgICAgYmFja2xvZ0dXLFxuICAgICAgYnVpbGRSYXRlR1d5cixcbiAgICAgIGF2Z1dhaXRZZWFycyxcbiAgICAgIG9yYml0TWF4RGVwbG95YWJsZUNvbXB1dGVHV1xuICAgICk7XG4gICAgXG4gICAgYnJlYWtkb3duLm1hcmtldCA9IHtcbiAgICAgIHRvdGFsRGVtYW5kR1c6IGRlbWFuZENvbXB1dGVHVywgLy8gVXNlIHNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGggKG5vdCBtYXJrZXRBbmFseXNpcy50b3RhbERlbWFuZEdXIHdoaWNoIG1heSBkaWZmZXIpXG4gICAgICBvcmJpdGFsU2hhcmVGcmFjOiBtYXJrZXRBbmFseXNpcy5vcmJpdGFsU2hhcmVGcmFjLFxuICAgICAgb3JiaXRhbENhcGFjaXR5R1c6IG1hcmtldEFuYWx5c2lzLm9yYml0YWxDYXBhY2l0eUdXLFxuICAgICAgb3JiaXRhbFJldmVudWU6IG1hcmtldEFuYWx5c2lzLm9yYml0YWxSZXZlbnVlLFxuICAgICAgZ3JvdW5kU2hhcmVGcmFjOiBtYXJrZXRBbmFseXNpcy5ncm91bmRTaGFyZUZyYWMsXG4gICAgICBncm91bmRDYXBhY2l0eUdXOiBtYXJrZXRBbmFseXNpcy5ncm91bmRDYXBhY2l0eUdXLFxuICAgICAgZGVidWc6IHtcbiAgICAgICAgLi4ubWFya2V0QW5hbHlzaXMuZGVidWcsXG4gICAgICAgIGRlbWFuZENvbXB1dGVHVzogZGVtYW5kQ29tcHV0ZUdXLCAvLyBTaW5nbGUgc291cmNlIG9mIHRydXRoXG4gICAgICAgIG9yYml0YWxDYXBhY2l0eUdXX2Zyb21TYXRzOiBvcmJpdGFsQ2FwYWNpdHlHV19mcm9tU2F0cywgLy8gQ2Fub25pY2FsIGNhcGFjaXR5IGZyb20gY29uc3RlbGxhdGlvbiAoZm9yIHZhbGlkYXRpb24pXG4gICAgICB9IGFzIE1hcmtldEFuYWx5c2lzWydkZWJ1ZyddLCAvLyBUeXBlIGFzc2VydGlvbiB0byBhbGxvdyBvcmJpdGFsQ2FwYWNpdHlHV19mcm9tU2F0c1xuICAgIH07XG4gICAgXG4gICAgLy8gSW52YXJpYW50OiBkZW1hbmQgc2NhbGFyIGNvbnNpc3RlbmN5XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIGJyZWFrZG93bi5tYXJrZXQpIHtcbiAgICAgIGNvbnN0IG1hcmtldERlbWFuZCA9IGJyZWFrZG93bi5tYXJrZXQudG90YWxEZW1hbmRHVztcbiAgICAgIGNvbnN0IG1hcmtldERlYnVnRGVtYW5kID0gYnJlYWtkb3duLm1hcmtldC5kZWJ1Zz8uZGVtYW5kQ29tcHV0ZUdXO1xuICAgICAgY29uc3QgYnVpbGRvdXREZW1hbmQgPSBicmVha2Rvd24uZ3JvdW5kPy5idWlsZG91dERlYnVnPy5kZW1hbmRHVztcbiAgICAgIFxuICAgICAgaWYgKG1hcmtldERlYnVnRGVtYW5kICE9PSB1bmRlZmluZWQgJiYgTWF0aC5hYnMobWFya2V0RGVtYW5kIC0gbWFya2V0RGVidWdEZW1hbmQpID4gMWUtNikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFtERU1BTkQgU0NBTEFSIEJVR10gWWVhciAke3llYXJ9OiBtYXJrZXQudG90YWxEZW1hbmRHVz0ke21hcmtldERlbWFuZH0gIT0gYCArXG4gICAgICAgICAgYG1hcmtldC5kZWJ1Zy5kZW1hbmRDb21wdXRlR1c9JHttYXJrZXREZWJ1Z0RlbWFuZH0uIE11c3QgYmUgZXF1YWwuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoYnVpbGRvdXREZW1hbmQgIT09IHVuZGVmaW5lZCAmJiBNYXRoLmFicyhtYXJrZXREZW1hbmQgLSBidWlsZG91dERlbWFuZCkgPiAxZS02KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgW0RFTUFORCBTQ0FMQVIgQlVHXSBZZWFyICR7eWVhcn06IG1hcmtldC50b3RhbERlbWFuZEdXPSR7bWFya2V0RGVtYW5kfSAhPSBgICtcbiAgICAgICAgICBgZ3JvdW5kLmJ1aWxkb3V0RGVidWcuZGVtYW5kR1c9JHtidWlsZG91dERlbWFuZH0uIE11c3QgYmUgZXF1YWwuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgbW9iaWxpemF0aW9uIHN0YXRlIGZvciBuZXh0IHllYXIgKHVzZSBleHRyYWN0ZWQgdmFsdWVzLCBub3QgYnJlYWtkb3duLmdyb3VuZCB3aGljaCBtaWdodCBiZSAwKVxuICAgIGlmIChicmVha2Rvd24uZ3JvdW5kPy5idWlsZG91dERlYnVnKSB7XG4gICAgICBjb25zdCBidWlsZG91dERlYnVnID0gYnJlYWtkb3duLmdyb3VuZC5idWlsZG91dERlYnVnO1xuICAgICAgbW9iaWxpemF0aW9uU3RhdGUgPSB7XG4gICAgICAgIHllYXIsXG4gICAgICAgIGRlbWFuZEdXOiBidWlsZG91dERlYnVnLmRlbWFuZEdXID8/IDAsXG4gICAgICAgIGRlbWFuZE5ld0dXOiBidWlsZG91dERlYnVnLmRlbWFuZE5ld0dXLFxuICAgICAgICBidWlsZFJhdGVHV3lyOiBidWlsZG91dERlYnVnLmJ1aWxkUmF0ZUdXeXIgPz8gYnVpbGRSYXRlR1d5cixcbiAgICAgICAgY2FwYWNpdHlHVzogYnVpbGRvdXREZWJ1Zy5jYXBhY2l0eUdXID8/IDAsXG4gICAgICAgIHBpcGVsaW5lR1c6IGJ1aWxkb3V0RGVidWcucGlwZWxpbmVHVyA/PyAwLFxuICAgICAgICBiYWNrbG9nR1c6IGJhY2tsb2dHVywgLy8gVXNlIGV4dHJhY3RlZCB2YWx1ZSwgbm90IGJyZWFrZG93bi5ncm91bmQuYmFja2xvZ0d3IHdoaWNoIG1pZ2h0IGJlIDBcbiAgICAgICAgYXZnV2FpdFllYXJzOiBhdmdXYWl0WWVhcnMsIC8vIFVzZSBleHRyYWN0ZWQgdmFsdWUsIG5vdCBicmVha2Rvd24uZ3JvdW5kLmF2Z1dhaXRZZWFycyB3aGljaCBtaWdodCBiZSAwXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICB0cmFqZWN0b3J5LnB1c2goYnJlYWtkb3duKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgcHJldmlvdXMgeWVhciBicmVha2Rvd24gZm9yIG5leHQgaXRlcmF0aW9uIChmb3IgcmVzcG9uc2l2ZSBkZW1hbmQgY2FsY3VsYXRpb24pXG4gICAgcHJldlllYXJCcmVha2Rvd24gPSBicmVha2Rvd247XG4gIH1cblxuICByZXR1cm4gdHJhamVjdG9yeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlRmluYWxBbmFseXNpcyhcbiAgb3B0aW9uczogVHJhamVjdG9yeU9wdGlvbnMsXG4gIGJhc2VUcmFqZWN0b3J5OiBZZWFybHlCcmVha2Rvd25bXVxuKTogRmluYWxNb2RlbE91dHB1dCB7XG4gIGNvbnN0IGJhc2VDcm9zc292ZXIgPSBmaW5kQ3Jvc3NvdmVyWWVhcihiYXNlVHJhamVjdG9yeSk7XG4gIGNvbnN0IGJhc2VDcm9zc292ZXJFZmZlY3RpdmVQZmxvcCA9IGZpbmRDcm9zc292ZXJZZWFyRWZmZWN0aXZlUGZsb3AoYmFzZVRyYWplY3RvcnkpO1xuICBjb25zdCBiYXNlUGFyYW1zID0gb3B0aW9ucy5wYXJhbXNCeVllYXIoMjAyNSk7XG4gIFxuICAvLyAxLiBTZW5zaXRpdml0eSBBbmFseXNpc1xuICBjb25zdCBwYXJhbWV0ZXJzVG9UZXN0ID0gW1xuICAgIHsga2V5OiAnbGF1bmNoQ29zdEtnJywgbmFtZTogJ0xhdW5jaCBDb3N0ICgyMDM1KScsIHZhbHVlczogWzUwLCAxMDAsIDE1MCwgMjAwLCAzMDBdLCB5ZWFyVG9Nb2RpZnk6IDIwMzUgfSxcbiAgICB7IGtleTogJ2dwdUZhaWx1cmVSYXRlJywgbmFtZTogJ0dQVSBGYWlsdXJlIFJhdGUnLCB2YWx1ZXM6IFswLjA1LCAwLjEwLCAwLjE1LCAwLjIwLCAwLjI1XSwgeWVhclRvTW9kaWZ5OiBudWxsIH0sXG4gICAgeyBrZXk6ICdoYXJkd2FyZUxlYXJuaW5nUmF0ZScsIG5hbWU6ICdIYXJkd2FyZSBMZWFybmluZyBSYXRlJywgdmFsdWVzOiBbMC4wOCwgMC4xMCwgMC4xMiwgMC4xNV0sIHllYXJUb01vZGlmeTogbnVsbCB9LFxuICBdO1xuXG4gIGNvbnN0IHNlbnNpdGl2aXRpZXMgPSBwYXJhbWV0ZXJzVG9UZXN0Lm1hcChwID0+IHtcbiAgICBjb25zdCBjcm9zc292ZXJZZWFycyA9IHAudmFsdWVzLm1hcCh2YWwgPT4ge1xuICAgICAgY29uc3QgdGVzdFRyYWplY3RvcnkgPSBjb21wdXRlVHJhamVjdG9yeSh7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHBhcmFtc0J5WWVhcjogKHkpID0+IHtcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSBvcHRpb25zLnBhcmFtc0J5WWVhcih5KTtcbiAgICAgICAgICBpZiAocC55ZWFyVG9Nb2RpZnkgJiYgeSA9PT0gcC55ZWFyVG9Nb2RpZnkpIHtcbiAgICAgICAgICAgICByZXR1cm4geyAuLi5wYXJhbXMsIFtwLmtleV06IHZhbCB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXAueWVhclRvTW9kaWZ5KSB7XG4gICAgICAgICAgICAgcmV0dXJuIHsgLi4ucGFyYW1zLCBbcC5rZXldOiB2YWwgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmluZENyb3Nzb3ZlclllYXIodGVzdFRyYWplY3RvcnkpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdmFsaWRZZWFycyA9IGNyb3Nzb3ZlclllYXJzLmZpbHRlcih5ID0+IHkgIT09IG51bGwpIGFzIG51bWJlcltdO1xuICAgIGNvbnN0IG1heERlbHRhID0gdmFsaWRZZWFycy5sZW5ndGggPiAxID8gTWF0aC5tYXgoLi4udmFsaWRZZWFycykgLSBNYXRoLm1pbiguLi52YWxpZFllYXJzKSA6IDA7XG4gICAgY29uc3QgaW1wYWN0ID0gbWF4RGVsdGEgPj0gNCA/ICdoaWdoJyA6IG1heERlbHRhID49IDIgPyAnbWVkaXVtJyA6ICdsb3cnO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmFtZXRlcjogcC5uYW1lLFxuICAgICAgYmFzZVZhbHVlOiAoYmFzZVBhcmFtc1twLmtleSBhcyBrZXlvZiBZZWFyUGFyYW1zXSBhcyBudW1iZXIpIHx8IDAsXG4gICAgICB0ZXN0VmFsdWVzOiBwLnZhbHVlcyxcbiAgICAgIGNyb3Nzb3ZlclllYXJzLFxuICAgICAgaW1wYWN0OiBpbXBhY3QgYXMgJ2hpZ2gnIHwgJ21lZGl1bScgfCAnbG93J1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIDIuIFNjZW5hcmlvIEJlbmNobWFya3NcbiAgY29uc3Qgc2NlbmFyaW9zID0gW1xuICAgIHtcbiAgICAgIG5hbWU6ICdCdWxsIENhc2UnLFxuICAgICAgZGVzY3JpcHRpb246ICdNYXR1cmUgU3RhcnNoaXAsIGNvbW1lcmNpYWwgY2hpcHMsIHNldmVyZSBncm91bmQgY29uc3RyYWludHMnLFxuICAgICAga2V5QXNzdW1wdGlvbnM6IFsnTGF1bmNoICQ3NS9rZyBieSAyMDM1JywgJ0NvbW1lcmNpYWwgY2hpcHMnLCAnU2V2ZXJlIGdyb3VuZCBjb25zdHJhaW50cyddLFxuICAgICAgY3Jvc3NvdmVyWWVhcjogZmluZENyb3Nzb3ZlclllYXIoY29tcHV0ZVRyYWplY3Rvcnkoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBwYXJhbXNCeVllYXI6ICh5KSA9PiAoe1xuICAgICAgICAgIC4uLm9wdGlvbnMucGFyYW1zQnlZZWFyKHkpLFxuICAgICAgICAgIGxhdW5jaENvc3RLZzogZ2V0TGF1bmNoQ29zdFBlcktnKHksIDE1MDApLFxuICAgICAgICAgIHVzZVJhZEhhcmRDaGlwczogZmFsc2UsXG4gICAgICAgICAgZ3JvdW5kU2NlbmFyaW86ICdzZXZlcmUnXG4gICAgICAgIH0pXG4gICAgICB9KSlcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdCYXNlIENhc2UnLFxuICAgICAgZGVzY3JpcHRpb246ICdDdXJyZW50IG1vZGVsIGFzc3VtcHRpb25zIChSYWQtdG9sZXJhbnQgYmFzZWxpbmUpJyxcbiAgICAgIGtleUFzc3VtcHRpb25zOiBbJ0xhdW5jaCAkNzUva2cgYnkgMjAzNScsICdSYWQtdG9sZXJhbnQgY2hpcHMnLCAnU3RhbmRhcmQgZ3JvdW5kIGNvbnN0cmFpbnRzJ10sXG4gICAgICBjcm9zc292ZXJZZWFyOiBiYXNlQ3Jvc3NvdmVyXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnQmVhciBDYXNlJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnUmFkLWhhcmQgcmVxdWlyZWQsIFNNUnMgc29sdmUgZ3JvdW5kIHBvd2VyJyxcbiAgICAgIGtleUFzc3VtcHRpb25zOiBbJ0xhdW5jaCAkMzAwL2tnIGJ5IDIwMzUnLCAnUmFkLWhhcmQgY2hpcHMnLCAnVW5jb25zdHJhaW5lZCBncm91bmQnXSxcbiAgICAgIGNyb3Nzb3ZlclllYXI6IGZpbmRDcm9zc292ZXJZZWFyKGNvbXB1dGVUcmFqZWN0b3J5KHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgcGFyYW1zQnlZZWFyOiAoeSkgPT4gKHtcbiAgICAgICAgICAuLi5vcHRpb25zLnBhcmFtc0J5WWVhcih5KSxcbiAgICAgICAgICBsYXVuY2hDb3N0S2c6IHByb2plY3RNYXJrZXRQcmljZSgxNTAwLCAyMDI1LCB5LCAwLjEwKSxcbiAgICAgICAgICB1c2VSYWRIYXJkQ2hpcHM6IHRydWUsXG4gICAgICAgICAgZ3JvdW5kU2NlbmFyaW86ICd1bmNvbnN0cmFpbmVkJ1xuICAgICAgICB9KVxuICAgICAgfSkpXG4gICAgfVxuICBdO1xuXG4gIC8vIDMuIE1hcmtldCBDb21wYXJpc29uXG4gIGNvbnN0IG1hcmtldENvbXBhcmlzb246IE1hcmtldFByb2plY3Rpb25bXSA9IE1BUktFVF9QUk9WSURFUlMubWFwKHAgPT4ge1xuICAgIGNvbnN0IHByb2plY3RlZFByaWNlcyA9IFtdO1xuICAgIGZvciAobGV0IHkgPSAyMDI1OyB5IDw9IDIwNTA7IHkrKykge1xuICAgICAgcHJvamVjdGVkUHJpY2VzLnB1c2goeyB5ZWFyOiB5LCBwcmljZTogcHJvamVjdE1hcmtldFByaWNlKHAucHJpY2UsIDIwMjQsIHksIHAuZGVjbGluZSkgfSk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IG9yYml0YWxCZWF0c1llYXIgPSBiYXNlVHJhamVjdG9yeS5maW5kKGQgPT4ge1xuICAgICAgY29uc3QgcHJvamVjdGVkID0gcHJvamVjdE1hcmtldFByaWNlKHAucHJpY2UsIDIwMjQsIGQueWVhciwgcC5kZWNsaW5lKTtcbiAgICAgIHJldHVybiBkLm9yYml0LmdwdUhvdXJQcmljaW5nLnN0YW5kYXJkLnByaWNlUGVyR3B1SG91ciA8IHByb2plY3RlZDtcbiAgICB9KT8ueWVhciB8fCBudWxsO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3ZpZGVyOiBwLm5hbWUsXG4gICAgICBjdXJyZW50UHJpY2U6IHAucHJpY2UsXG4gICAgICBjdXJyZW50WWVhcjogMjAyNCxcbiAgICAgIHByb2plY3RlZERlY2xpbmU6IHAuZGVjbGluZSxcbiAgICAgIHByb2plY3RlZFByaWNlcyxcbiAgICAgIG9yYml0YWxCZWF0c1llYXJcbiAgICB9O1xuICB9KTtcblxuICAvLyA0LiBHcm91bmQgU2NlbmFyaW8gTGFiZWxcbiAgY29uc3Qgc2VsZWN0ZWRTY2VuYXJpbyA9IEdST1VORF9TQ0VOQVJJT1NbYmFzZVBhcmFtcy5ncm91bmRTY2VuYXJpb107XG4gIGNvbnN0IGdyb3VuZFNjZW5hcmlvTGFiZWw6IEdyb3VuZFNjZW5hcmlvTGFiZWwgPSB7XG4gICAgbmFtZTogc2VsZWN0ZWRTY2VuYXJpby5uYW1lLFxuICAgIGRlc2NyaXB0aW9uOiBzZWxlY3RlZFNjZW5hcmlvLmRlc2NyaXB0aW9uLFxuICAgIGNvbnN0cmFpbnRNdWx0aXBsaWVyMjA0MDogMS4wLCAvLyBOb3QgdXNlZCAtIGNvbnN0cmFpbnRzIG5vdyB1c2UgYWRkZXJzIG9ubHlcbiAgICBhc3N1bXB0aW9uczogW1xuICAgICAgYEdyaWQgZ3Jvd3RoOiAkeyhzZWxlY3RlZFNjZW5hcmlvLmdyaWRHcm93dGhSYXRlICogMTAwKS50b0ZpeGVkKDEpfSUveWVhcmAsXG4gICAgICBgQ29vbGluZyBncm93dGg6ICR7KHNlbGVjdGVkU2NlbmFyaW8uY29vbGluZ0dyb3d0aFJhdGUgKiAxMDApLnRvRml4ZWQoMSl9JS95ZWFyYCxcbiAgICAgIHNlbGVjdGVkU2NlbmFyaW8uY29uc3RyYWludENhcCA/IGBDb25zdHJhaW50IGNhcDogJHtzZWxlY3RlZFNjZW5hcmlvLmNvbnN0cmFpbnRDYXB9eGAgOiAnTm8gY29uc3RyYWludCBjYXAnXG4gICAgXVxuICB9O1xuXG4gIC8vIDUuIFZhbGlkYXRpb24gQ2hlY2tzXG4gIGNvbnN0IGxhc3RZZWFyID0gYmFzZVRyYWplY3RvcnlbYmFzZVRyYWplY3RvcnkubGVuZ3RoIC0gMV07XG4gIGNvbnN0IGZpcnN0WWVhciA9IGJhc2VUcmFqZWN0b3J5WzBdO1xuICBjb25zdCBhbGxDaGVja3MgPSBbXG4gICAgeyBuYW1lOiAnQ29zdCBicmVha2Rvd24gc3VtcyB0byB0b3RhbCcsIHBhc3NlZDogISFsYXN0WWVhci5jb3N0QWNjb3VudGluZ1ZhbGlkLCB2YWx1ZTogbGFzdFllYXIuY29zdEFjY291bnRpbmdFcnJvclBjdCwgZXhwZWN0ZWQ6ICc8MC41JScgfSxcbiAgICB7IG5hbWU6ICdDYXBhY2l0eSBmYWN0b3IgaW4gcmFuZ2UnLCBwYXNzZWQ6IGZpcnN0WWVhci5vcmJpdC5jYXBhY2l0eUZhY3RvciA+IDAuOTAsIHZhbHVlOiBmaXJzdFllYXIub3JiaXQuY2FwYWNpdHlGYWN0b3IsIGV4cGVjdGVkOiAnMC45MC0xLjAnIH0sXG4gICAgeyBuYW1lOiAnQ3Jvc3NvdmVyIHllYXIgbWF0Y2hlcyB0cmFqZWN0b3J5JywgcGFzc2VkOiB0cnVlLCB2YWx1ZTogYmFzZUNyb3Nzb3ZlciB9LFxuICBdO1xuXG4gIGNvbnN0IHZhbGlkYXRpb246IFZhbGlkYXRpb25DaGVja3MgPSB7XG4gICAgY29zdEFjY291bnRpbmdWYWxpZDogISFsYXN0WWVhci5jb3N0QWNjb3VudGluZ1ZhbGlkLFxuICAgIGNvc3RBY2NvdW50aW5nRXJyb3I6IGxhc3RZZWFyLmNvc3RBY2NvdW50aW5nRXJyb3JQY3QgfHwgMCxcbiAgICB0cmFqZWN0b3J5TW9ub3RvbmljOiB0cnVlLCAvLyBTaW1wbGlmaWVkXG4gICAgcGFyYW1ldGVyc0luUmFuZ2U6IHRydWUsXG4gICAgY3Jvc3NvdmVyQ29uc2lzdGVudDogdHJ1ZSxcbiAgICBhbGxDaGVja3NcbiAgfTtcblxuICBjb25zdCBjcm9zc292ZXJZZWFyU3RhbmRhcmQgPSBiYXNlQ3Jvc3NvdmVyO1xuICBjb25zdCBwcmljZUF0Q3Jvc3NvdmVyT3JiaXRhbCA9IGJhc2VDcm9zc292ZXIgPyBiYXNlVHJhamVjdG9yeVtiYXNlQ3Jvc3NvdmVyIC0gMjAyNV0ub3JiaXQuZ3B1SG91clByaWNpbmcuc3RhbmRhcmQucHJpY2VQZXJHcHVIb3VyIDogMDtcbiAgY29uc3QgcHJpY2VBdENyb3Nzb3Zlckdyb3VuZCA9IGJhc2VDcm9zc292ZXIgPyBiYXNlVHJhamVjdG9yeVtiYXNlQ3Jvc3NvdmVyIC0gMjAyNV0uZ3JvdW5kLmdwdUhvdXJQcmljaW5nLnN0YW5kYXJkLnByaWNlUGVyR3B1SG91ciA6IDA7XG5cbiAgY29uc3QgYWN0aXZlVG9nZ2xlcyA9IFtdO1xuICBpZiAoYmFzZVBhcmFtcy5lbG9uU2NlbmFyaW9FbmFibGVkKSBhY3RpdmVUb2dnbGVzLnB1c2goJ0Vsb24gU2NlbmFyaW8nKTtcbiAgaWYgKGJhc2VQYXJhbXMuZ2xvYmFsTGF0ZW5jeVJlcXVpcmVtZW50RW5hYmxlZCkgYWN0aXZlVG9nZ2xlcy5wdXNoKCdHbG9iYWwgTGF0ZW5jeScpO1xuICBpZiAoYmFzZVBhcmFtcy5zcGFjZU1hbnVmYWN0dXJpbmdFbmFibGVkKSBhY3RpdmVUb2dnbGVzLnB1c2goJ1NwYWNlIE1mZycpO1xuICBpZiAoYmFzZVBhcmFtcy5haVdpbnRlckVuYWJsZWQpIGFjdGl2ZVRvZ2dsZXMucHVzaCgnQUkgV2ludGVyJyk7XG5cbiAgLy8gQmFzZWxpbmUgY3Jvc3NvdmVyIChubyB0b2dnbGVzKVxuICBjb25zdCBiYXNlbGluZVRyYWplY3RvcnkgPSBjb21wdXRlVHJhamVjdG9yeSh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBwYXJhbXNCeVllYXI6ICh5KSA9PiAoe1xuICAgICAgLi4ub3B0aW9ucy5wYXJhbXNCeVllYXIoeSksXG4gICAgICBlbG9uU2NlbmFyaW9FbmFibGVkOiBmYWxzZSxcbiAgICAgIGdsb2JhbExhdGVuY3lSZXF1aXJlbWVudEVuYWJsZWQ6IGZhbHNlLFxuICAgICAgc3BhY2VNYW51ZmFjdHVyaW5nRW5hYmxlZDogZmFsc2UsXG4gICAgICBhaVdpbnRlckVuYWJsZWQ6IGZhbHNlXG4gICAgfSlcbiAgfSk7XG4gIGNvbnN0IGJhc2VsaW5lQ3Jvc3NvdmVyID0gZmluZENyb3Nzb3ZlclllYXIoYmFzZWxpbmVUcmFqZWN0b3J5KTtcblxuICBjb25zdCBzY2VuYXJpb0ltcGFjdCA9IHtcbiAgICBiYXNlbGluZUNyb3Nzb3ZlcixcbiAgICBjdXJyZW50Q3Jvc3NvdmVyOiBiYXNlQ3Jvc3NvdmVyLFxuICAgIGFjdGl2ZVRvZ2dsZXMsXG4gICAgY3Jvc3NvdmVyRGVsdGE6IChiYXNlbGluZUNyb3Nzb3ZlciB8fCAyMDQwKSAtIChiYXNlQ3Jvc3NvdmVyIHx8IDIwNDApXG4gIH07XG5cbiAgLy8gTW9udGUgQ2FybG8gQW5hbHlzaXMgKHJ1biBvbmNlLCBjYWNoZWQgcGVyIHBhcmFtZXRlciBzZXQpXG4gIC8vIEV4dHJhY3QgYmFzZSBwYXJhbWV0ZXJzIGZvciBNb250ZSBDYXJsb1xuICBjb25zdCBiYXNlUGFyYW1zRm9yTUMgPSBleHRyYWN0QmFzZVBhcmFtcyhvcHRpb25zLnBhcmFtc0J5WWVhcik7XG4gIFxuICAvLyBSdW4gTW9udGUgQ2FybG8gYW5hbHlzaXMgKDIwMCBzYW1wbGVzIGJ5IGRlZmF1bHQpXG4gIC8vIFRoaXMgaXMgY29tcHV0YXRpb25hbGx5IGV4cGVuc2l2ZSwgc28gd2Ugb25seSBkbyBpdCBvbmNlIHBlciBhbmFseXNpc1xuICBjb25zdCBtb250ZUNhcmxvUmVzdWx0ID0gcnVuTW9udGVDYXJsb0Nyb3Nzb3ZlcihcbiAgICBvcHRpb25zLnBhcmFtc0J5WWVhcixcbiAgICBiYXNlUGFyYW1zRm9yTUMsXG4gICAgMjAwIC8vIG51bVNhbXBsZXNcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIG1ldGFkYXRhOiB7XG4gICAgICB2ZXJzaW9uOiAnNC4zLjAnLFxuICAgICAgZ2VuZXJhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHVuaXRzOiBbXSBcbiAgICB9LFxuICAgIHBhcmFtZXRlcnM6IGJhc2VQYXJhbXMsXG4gICAgdHJhamVjdG9yeTogYmFzZVRyYWplY3RvcnksXG4gICAgYW5hbHlzaXM6IHtcbiAgICAgIGNyb3Nzb3Zlcjoge1xuICAgICAgICB5ZWFyOiBiYXNlQ3Jvc3NvdmVyLFxuICAgICAgICBvcmJpdGFsUHJpY2U6IHByaWNlQXRDcm9zc292ZXJPcmJpdGFsLFxuICAgICAgICBncm91bmRQcmljZTogcHJpY2VBdENyb3Nzb3Zlckdyb3VuZCxcbiAgICAgICAgbWFya2V0UG9zaXRpb246IGJhc2VUcmFqZWN0b3J5W2Jhc2VUcmFqZWN0b3J5Lmxlbmd0aCAtIDFdLmNyb3Nzb3ZlckRldGFpbHM/Lm1hcmtldFBvc2l0aW9uIHx8ICcnXG4gICAgICB9LFxuICAgICAgc2Vuc2l0aXZpdHk6IHtcbiAgICAgICAgYmFzZUNhc2U6IHtcbiAgICAgICAgICBjcm9zc292ZXJZZWFyOiBiYXNlQ3Jvc3NvdmVyIHx8IDIwNDAsXG4gICAgICAgICAgb3JiaXRhbFByaWNlQXRDcm9zc292ZXI6IHByaWNlQXRDcm9zc292ZXJPcmJpdGFsLFxuICAgICAgICAgIGdyb3VuZFByaWNlQXRDcm9zc292ZXI6IHByaWNlQXRDcm9zc292ZXJHcm91bmQsXG4gICAgICAgIH0sXG4gICAgICAgIHNlbnNpdGl2aXRpZXNcbiAgICAgIH0sXG4gICAgICBzY2VuYXJpb3MsXG4gICAgICBjb25maWRlbmNlOiB7XG4gICAgICAgIGNyb3Nzb3ZlclllYXI6IHtcbiAgICAgICAgICBwMTA6IG1vbnRlQ2FybG9SZXN1bHQucDEwLCAvLyBGcm9tIE1vbnRlIENhcmxvIGFuYWx5c2lzXG4gICAgICAgICAgcDUwOiBtb250ZUNhcmxvUmVzdWx0LnA1MCwgLy8gRnJvbSBNb250ZSBDYXJsbyBhbmFseXNpc1xuICAgICAgICAgIHA5MDogbW9udGVDYXJsb1Jlc3VsdC5wOTAsIC8vIEZyb20gTW9udGUgQ2FybG8gYW5hbHlzaXNcbiAgICAgICAgfSxcbiAgICAgICAgcHJpY2VBdENyb3Nzb3Zlcjoge1xuICAgICAgICAgIGxvdzogc2NlbmFyaW9zWzBdLmNyb3Nzb3ZlclllYXIgPyBiYXNlVHJhamVjdG9yeVtzY2VuYXJpb3NbMF0uY3Jvc3NvdmVyWWVhciAtIDIwMjVdLm9yYml0LmdwdUhvdXJQcmljaW5nLnN0YW5kYXJkLnByaWNlUGVyR3B1SG91ciA6IDAsXG4gICAgICAgICAgbWlkOiBzY2VuYXJpb3NbMV0uY3Jvc3NvdmVyWWVhciA/IGJhc2VUcmFqZWN0b3J5W3NjZW5hcmlvc1sxXS5jcm9zc292ZXJZZWFyIC0gMjAyNV0ub3JiaXQuZ3B1SG91clByaWNpbmcuc3RhbmRhcmQucHJpY2VQZXJHcHVIb3VyIDogMCxcbiAgICAgICAgICBoaWdoOiBzY2VuYXJpb3NbMl0uY3Jvc3NvdmVyWWVhciA/IGJhc2VUcmFqZWN0b3J5W3NjZW5hcmlvc1syXS5jcm9zc292ZXJZZWFyIC0gMjAyNV0ub3JiaXQuZ3B1SG91clByaWNpbmcuc3RhbmRhcmQucHJpY2VQZXJHcHVIb3VyIDogMCxcbiAgICAgICAgfSxcbiAgICAgICAgcHJvYmFiaWxpdHlCeVllYXI6IG1vbnRlQ2FybG9SZXN1bHQucHJvYmFiaWxpdHlCeVllYXIsIC8vIFByb2JhYmlsaXR5IG9yYml0YWwgY2hlYXBlciBieSB5ZWFyIFhcbiAgICAgIH0sXG4gICAgICBtYXJrZXRDb21wYXJpc29uLFxuICAgICAgcmVndWxhdG9yeUltcGFjdDogMTUwMCxcbiAgICAgIHNjZW5hcmlvSW1wYWN0XG4gICAgfSxcbiAgICB2YWxpZGF0aW9uLFxuICAgIGdyb3VuZFNjZW5hcmlvOiBncm91bmRTY2VuYXJpb0xhYmVsXG4gIH07XG59XG4iXSwibmFtZXMiOlsiY29tcHV0ZVBoeXNpY3NDb3N0IiwiR1JPVU5EX1NDRU5BUklPUyIsImdldExhdW5jaENvc3RQZXJLZyIsInN0ZXBMYXVuY2hMZWFybmluZyIsImdldFN0YXRpY1BhcmFtcyIsInJ1bk1vbnRlQ2FybG9Dcm9zc292ZXIiLCJleHRyYWN0QmFzZVBhcmFtcyIsImZpbmRDcm9zc292ZXJZZWFyIiwidHJhamVjdG9yeSIsImNyb3NzaW5nIiwiZmluZCIsImQiLCJncm91bmRFZmZlY3RpdmVDb3N0IiwiZ3JvdW5kIiwidG90YWxDb3N0UGVyUGZsb3BZZWFyRWZmZWN0aXZlIiwidG90YWxDb3N0UGVyUGZsb3BZZWFyIiwiY29uc3RyYWludHMiLCJkZWxheVBlbmFsdHkiLCJzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXIiLCJvcmJpdENvc3QiLCJvcmJpdCIsIk51bWJlciIsImlzRmluaXRlIiwieWVhciIsImZpbmRDcm9zc292ZXJZZWFyRWZmZWN0aXZlUGZsb3AiLCJjYWxjdWxhdGVNYXJrZXRTaGFyZSIsIm9yYml0YWxDb3N0UGVyUGZsb3AiLCJncm91bmRDb3N0UGVyUGZsb3AiLCJ0b3RhbERlbWFuZEdXIiwib3JiaXRhbEZlYXNpYmxlIiwiZ3JvdW5kRmVhc2libGUiLCJvcmJpdGFsQ29zdEFjY291bnRpbmdWYWxpZCIsImdyb3VuZENvc3RBY2NvdW50aW5nVmFsaWQiLCJkZW1hbmRHVyIsImJhY2tsb2dHVyIsImJ1aWxkUmF0ZUdXeXIiLCJhdmdXYWl0WWVhcnMiLCJvcmJpdE1heERlcGxveWFibGVDb21wdXRlR1ciLCJvcmJpdGFsQWN0dWFsbHlGZWFzaWJsZSIsImdyb3VuZEFjdHVhbGx5RmVhc2libGUiLCJvcmJpdGFsU2hhcmVGcmFjIiwib3JiaXRhbENhcGFjaXR5R1ciLCJvcmJpdGFsUmV2ZW51ZSIsImdyb3VuZFNoYXJlRnJhYyIsImdyb3VuZENhcGFjaXR5R1ciLCJkZWJ1ZyIsInNoYXJlQ29udmVudGlvbiIsImdyb3VuZFJldmVudWUiLCJkZW1hbmQiLCJiYWNrbG9nR1dBY3R1YWwiLCJidWlsZFJhdGVHV3lyQWN0dWFsIiwiYXZnV2FpdFllYXJzQWN0dWFsIiwiZ3JvdW5kSGFzU2V2ZXJlUXVldWUiLCJncm91bmRGZWFzaWJsZUdXIiwiTWF0aCIsIm1heCIsIm9yYml0RmVhc2libGVHVyIsIm1pbiIsIm1heFNlcnZhYmxlIiwiY29zdFJhdGlvIiwibG9naXRGYWN0b3IiLCJleHAiLCJvcmJpdGFsU2hhcmVGcmFjRGVzaXJlZCIsImdyb3VuZFNoYXJlRnJhY0Rlc2lyZWQiLCJvcmJpdFNlcnZlZCIsImdyb3VuZFNlcnZlZCIsInJlbWFpbmRlciIsIm9yYml0Um9vbSIsImdyb3VuZFJvb20iLCJhZGRUb09yYml0IiwidG90YWxTZXJ2ZWRHVyIsImdyb3VuZFNlcnZlZENvbXB1dGVHVyIsIm9yYml0U2VydmVkQ29tcHV0ZUdXIiwiZ3JvdW5kRmVhc2libGVDb21wdXRlR1ciLCJvcmJpdEZlYXNpYmxlQ29tcHV0ZUdXIiwicmV2ZW51ZVBlckdXIiwiRXJyb3IiLCJzaGFyZVN1bSIsImFicyIsImRlbWFuZENvbXB1dGVHVyIsInByb2plY3RNYXJrZXRQcmljZSIsImJhc2VQcmljZSIsImJhc2VZZWFyIiwidGFyZ2V0WWVhciIsImFubnVhbERlY2xpbmVSYXRlIiwieWVhcnMiLCJwb3ciLCJNQVJLRVRfUFJPVklERVJTIiwibmFtZSIsInByaWNlIiwiZGVjbGluZSIsIklUX0dXXzIwMjUiLCJJVF9HV18yMDQwX1RBUkdFVCIsIklUX0dXXzIwNjBfVEFSR0VUIiwiUjEiLCJsb2ciLCJSMiIsImNhbGN1bGF0ZVJlc3BvbnNpdmVEZW1hbmQiLCJncm91bmRQcmljZVBlckdwdUhvdXIiLCJvcmJpdGFsUHJpY2VQZXJHcHVIb3VyIiwicHJldkRlbWFuZFN0YXRlIiwieWVhcnNGcm9tMjAyNSIsImdyb3d0aFJhdGUiLCJ0YXBlciIsImVmZmVjdGl2ZUdyb3d0aCIsImJhc2VsaW5lR1ciLCJiYXNlbGluZVByaWNlIiwicHJpY2VSYXRpbyIsInByaWNlRWxhc3RpY2l0eSIsInByaWNlRmFjdG9yIiwid2FpdEVsYXN0aWNpdHkiLCJ3YWl0RmFjdG9yIiwiZWZmZWN0aXZlR1ciLCJncm91bmRPcmJpdGFsUmF0aW8iLCJvcmJpdGFsU2hhcmUiLCJvcmJpdGFsRGVtYW5kR1ciLCJncm91bmREZW1hbmRHVyIsImdldElUTG9hZEdXIiwieWVhcnNGcm9tMjA0MCIsImdldEZhY2lsaXR5TG9hZEdXIiwicHVlIiwiaXRMb2FkR1ciLCJnZXREZW1hbmROZXdHVyIsImZhY2lsaXR5R1ciLCJmYWNpbGl0eUdXUHJldiIsImdldERlbWFuZFByb2plY3Rpb24iLCJjb21wdXRlVHJhamVjdG9yeSIsIm9wdGlvbnMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsImZpcnN0Q2FwWWVhciIsImxhdW5jaExlYXJuaW5nU3RhdGUiLCJCQVNFTElORV9NQVNTX0tHIiwiTEFVTkNIX0NPU1RfMF9QRVJfS0ciLCJwcmV2WWVhckJyZWFrZG93biIsImJ1aWxkb3V0U3RhdGUiLCJtb2JpbGl6YXRpb25TdGF0ZSIsImJyZWFrZG93biIsInBhcmFtcyIsIm1vZGUiLCJwYXJhbXNCeVllYXIiLCJsYXVuY2hDb3N0UGVyS2ciLCJsYXVuY2hDb3N0S2ciLCJwYXJhbXNXaXRoTGF1bmNoQ29zdCIsInVzZUxhdW5jaExlYXJuaW5nIiwiY29tcHV0ZVBvd2VyTVciLCJ0YXJnZXRHVyIsIm1hc3NQZXJNVyIsIm1hc3NEZW1hbmRlZEtnIiwibGF1bmNoTGVhcm5pbmdSZXN1bHQiLCJiYXNlbGluZU1hc3NLZyIsImxhdW5jaENvc3QwUGVyS2ciLCJsZWFybmluZ1JhdGUiLCJtYXhGbGlnaHRzUGVyWWVhciIsInBheWxvYWRQZXJGbGlnaHRLZyIsInN0YXRlIiwicGFyYW1zV2l0aE1vYmlsaXphdGlvbiIsInByZXZNb2JpbGl6YXRpb25TdGF0ZSIsImh5YnJpZEJyZWFrZG93biIsImNvbnN0cmFpbnRCcmVha2Rvd24iLCJjYXBZZWFyIiwidW5kZWZpbmVkIiwidGhpc0NhcFllYXIiLCJncm91bmRQdWUiLCJwdWVHcm91bmQiLCJwcmV2R3JvdW5kUHJpY2UiLCJncHVIb3VyUHJpY2luZyIsInN0YW5kYXJkIiwicHJpY2VQZXJHcHVIb3VyIiwicHJldk9yYml0YWxQcmljZSIsInByZXZBdmdXYWl0Iiwic3VwcGx5TWV0cmljcyIsImRlbWFuZFN0YXRlIiwiYnVpbGRvdXREZWJ1ZyIsIkluZmluaXR5IiwiY29zdEFjY291bnRpbmdWYWxpZCIsIm9yYml0YWxDYXBhY2l0eUdXX2Zyb21TYXRzIiwiY29uc3RlbGxhdGlvbiIsImRlc2lnbiIsIm51bVNhdGVsbGl0ZXMiLCJjb21wdXRlUGVyU2F0S3ciLCJwcm9jZXNzIiwiZXhwZWN0ZWRHVyIsImVycm9yIiwiY2hhcnRQQiIsIm1ldGFkYXRhIiwiY2hhcnRJbnB1dHMiLCJwb3dlckJ1aWxkb3V0IiwiY2hhcnRCYWNrbG9nIiwiYmFja2xvZ0d3IiwiY2hhcnRBdmdXYWl0IiwiY2hhcnRCdWlsZFJhdGUiLCJtYXhCdWlsZFJhdGVHd1llYXIiLCJiYWNrbG9nRnJvbUdyb3VuZCIsImJhY2tsb2dGcm9tQnVpbGRvdXQiLCJidWlsZFJhdGVGcm9tQnVpbGRvdXQiLCJidWlsZFJhdGVGcm9tU3VwcGx5IiwiYXZnV2FpdEZyb21Hcm91bmQiLCJhdmdXYWl0RnJvbUJ1aWxkb3V0IiwidGltZVRvUG93ZXJZZWFycyIsImF2Z1dhaXRGcm9tU3VwcGx5IiwiY29uc29sZSIsInBpcGVsaW5lR3ciLCJvcmJpdE1heERlcGxveWFibGVDb21wdXRlR1dCeVllYXIiLCJvcmJpdGFsRmVhc2libGVGb3JTaGFyZSIsIm1hcmtldEFuYWx5c2lzIiwibWFya2V0IiwibWFya2V0RGVtYW5kIiwibWFya2V0RGVidWdEZW1hbmQiLCJidWlsZG91dERlbWFuZCIsImRlbWFuZE5ld0dXIiwiY2FwYWNpdHlHVyIsInBpcGVsaW5lR1ciLCJwdXNoIiwiZ2VuZXJhdGVGaW5hbEFuYWx5c2lzIiwiYmFzZVRyYWplY3RvcnkiLCJiYXNlQ3Jvc3NvdmVyIiwiYmFzZUNyb3Nzb3ZlckVmZmVjdGl2ZVBmbG9wIiwiYmFzZVBhcmFtcyIsInBhcmFtZXRlcnNUb1Rlc3QiLCJrZXkiLCJ2YWx1ZXMiLCJ5ZWFyVG9Nb2RpZnkiLCJzZW5zaXRpdml0aWVzIiwibWFwIiwicCIsImNyb3Nzb3ZlclllYXJzIiwidmFsIiwidGVzdFRyYWplY3RvcnkiLCJ5IiwidmFsaWRZZWFycyIsImZpbHRlciIsIm1heERlbHRhIiwiaW1wYWN0IiwicGFyYW1ldGVyIiwiYmFzZVZhbHVlIiwidGVzdFZhbHVlcyIsInNjZW5hcmlvcyIsImRlc2NyaXB0aW9uIiwia2V5QXNzdW1wdGlvbnMiLCJjcm9zc292ZXJZZWFyIiwidXNlUmFkSGFyZENoaXBzIiwiZ3JvdW5kU2NlbmFyaW8iLCJtYXJrZXRDb21wYXJpc29uIiwicHJvamVjdGVkUHJpY2VzIiwib3JiaXRhbEJlYXRzWWVhciIsInByb2plY3RlZCIsInByb3ZpZGVyIiwiY3VycmVudFByaWNlIiwiY3VycmVudFllYXIiLCJwcm9qZWN0ZWREZWNsaW5lIiwic2VsZWN0ZWRTY2VuYXJpbyIsImdyb3VuZFNjZW5hcmlvTGFiZWwiLCJjb25zdHJhaW50TXVsdGlwbGllcjIwNDAiLCJhc3N1bXB0aW9ucyIsImdyaWRHcm93dGhSYXRlIiwidG9GaXhlZCIsImNvb2xpbmdHcm93dGhSYXRlIiwiY29uc3RyYWludENhcCIsImxhc3RZZWFyIiwiZmlyc3RZZWFyIiwiYWxsQ2hlY2tzIiwicGFzc2VkIiwidmFsdWUiLCJjb3N0QWNjb3VudGluZ0Vycm9yUGN0IiwiZXhwZWN0ZWQiLCJjYXBhY2l0eUZhY3RvciIsInZhbGlkYXRpb24iLCJjb3N0QWNjb3VudGluZ0Vycm9yIiwidHJhamVjdG9yeU1vbm90b25pYyIsInBhcmFtZXRlcnNJblJhbmdlIiwiY3Jvc3NvdmVyQ29uc2lzdGVudCIsImNyb3Nzb3ZlclllYXJTdGFuZGFyZCIsInByaWNlQXRDcm9zc292ZXJPcmJpdGFsIiwicHJpY2VBdENyb3Nzb3Zlckdyb3VuZCIsImFjdGl2ZVRvZ2dsZXMiLCJlbG9uU2NlbmFyaW9FbmFibGVkIiwiZ2xvYmFsTGF0ZW5jeVJlcXVpcmVtZW50RW5hYmxlZCIsInNwYWNlTWFudWZhY3R1cmluZ0VuYWJsZWQiLCJhaVdpbnRlckVuYWJsZWQiLCJiYXNlbGluZVRyYWplY3RvcnkiLCJiYXNlbGluZUNyb3Nzb3ZlciIsInNjZW5hcmlvSW1wYWN0IiwiY3VycmVudENyb3Nzb3ZlciIsImNyb3Nzb3ZlckRlbHRhIiwiYmFzZVBhcmFtc0Zvck1DIiwibW9udGVDYXJsb1Jlc3VsdCIsInZlcnNpb24iLCJnZW5lcmF0ZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInVuaXRzIiwicGFyYW1ldGVycyIsImFuYWx5c2lzIiwiY3Jvc3NvdmVyIiwib3JiaXRhbFByaWNlIiwiZ3JvdW5kUHJpY2UiLCJtYXJrZXRQb3NpdGlvbiIsImNyb3Nzb3ZlckRldGFpbHMiLCJzZW5zaXRpdml0eSIsImJhc2VDYXNlIiwib3JiaXRhbFByaWNlQXRDcm9zc292ZXIiLCJncm91bmRQcmljZUF0Q3Jvc3NvdmVyIiwiY29uZmlkZW5jZSIsInAxMCIsInA1MCIsInA5MCIsInByaWNlQXRDcm9zc292ZXIiLCJsb3ciLCJtaWQiLCJoaWdoIiwicHJvYmFiaWxpdHlCeVllYXIiLCJyZWd1bGF0b3J5SW1wYWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/trajectory.ts\n"));

/***/ })

});