"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/compare/page",{

/***/ "(app-pages-browser)/./app/lib/model/ground_ramping_mobilization.ts":
/*!******************************************************!*\
  !*** ./app/lib/model/ground_ramping_mobilization.ts ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_MOBILIZATION_PARAMS: function() { return /* binding */ DEFAULT_MOBILIZATION_PARAMS; },\n/* harmony export */   calculateBuildRateGWyr: function() { return /* binding */ calculateBuildRateGWyr; },\n/* harmony export */   calculateDemandGW: function() { return /* binding */ calculateDemandGW; },\n/* harmony export */   calculatePriceResponsiveBuildRateGWyr: function() { return /* binding */ calculatePriceResponsiveBuildRateGWyr; },\n/* harmony export */   calculatePriceResponsiveDemandGW: function() { return /* binding */ calculatePriceResponsiveDemandGW; },\n/* harmony export */   stepMobilizationState: function() { return /* binding */ stepMobilizationState; }\n/* harmony export */ });\n/**\n * Ground Ramping Mobilization Model\n * \n * Models demand growth with price-responsive demand and buildout capacity\n * ramping with investment response. Tracks capacity evolution, pipeline, backlog,\n * and wait times.\n * \n * NEW: Price-responsive demand and investment-responsive buildout (replaces fixed anchors)\n */ /**\n * Calculate price-responsive demand GW\n * \n * NEW: Demand responds to prices, wait times, and orbital substitution\n * Replaces fixed anchors with economic feedback\n */ function calculatePriceResponsiveDemandGW(year, groundPricePerGpuHour, orbitalPricePerGpuHour, avgWaitYears, params) {\n    let pue = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1.3;\n    // Base demand with organic growth (tapered, not exponential forever)\n    const yearsFrom2025 = year - 2025;\n    const growthTaper = Math.tanh(yearsFrom2025 / 30); // Tapers after ~30 years\n    const baseDemand = params.baseDemand2025GW * Math.pow(1 + params.organicGrowthRate, yearsFrom2025 * growthTaper);\n    // Price elasticity: higher prices reduce demand\n    const baselinePrice = 3.50; // $/GPU-hr baseline\n    const priceRatio = groundPricePerGpuHour / baselinePrice;\n    const priceFactor = Math.pow(priceRatio, params.priceElasticity);\n    // Wait elasticity: longer waits reduce demand\n    const waitFactor = Math.exp(-avgWaitYears * params.waitElasticity / 5);\n    // Orbital substitution: if orbital cheaper, demand shifts\n    const orbitalAdvantage = groundPricePerGpuHour / Math.max(orbitalPricePerGpuHour, 0.01);\n    const substitutionFactor = orbitalAdvantage > params.orbitalSubstitutionThreshold ? 1 / (1 + 0.5 * (orbitalAdvantage - params.orbitalSubstitutionThreshold)) : 1.0;\n    let demandGW = baseDemand * priceFactor * waitFactor * substitutionFactor;\n    // Apply PUE if demand is IT load (not facility load)\n    // Note: This function assumes facility load, so multiply by PUE if needed\n    // For now, return facility load (demand already includes PUE in baseDemand2025GW)\n    return Math.max(0, demandGW);\n}\n/**\n * Legacy function: Calculate demand GW using piecewise exponential to hit anchors\n * \n * DEPRECATED: Use calculatePriceResponsiveDemandGW instead\n * Kept for backward compatibility\n */ function calculateDemandGW(year, params) {\n    let pue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1.3;\n    const { demandAnchorsGW, demandIsFacilityLoad, demandCurve } = params;\n    const demand2025 = demandAnchorsGW[2025];\n    const demand2040 = demandAnchorsGW[2040];\n    const demand2060 = demandAnchorsGW[2060];\n    if (demandCurve !== \"piecewise_exponential\") {\n        throw new Error(\"Unsupported demandCurve: \".concat(demandCurve, \". Only 'piecewise_exponential' is supported.\"));\n    }\n    if (year < 2025) {\n        return demand2025;\n    }\n    let demandGW;\n    if (year <= 2040) {\n        // Phase 1: 2025-2040\n        // r1 = ln(demand2040 / demand2025) / (2040-2025)\n        const r1 = Math.log(demand2040 / demand2025) / (2040 - 2025);\n        const yearsFrom2025 = year - 2025;\n        demandGW = demand2025 * Math.exp(r1 * yearsFrom2025);\n    } else {\n        // Phase 2: 2040-2060\n        // r2 = ln(demand2060 / demand2040) / (2060-2040)\n        const r2 = Math.log(demand2060 / demand2040) / (2060 - 2040);\n        const yearsFrom2040 = year - 2040;\n        demandGW = demand2040 * Math.exp(r2 * yearsFrom2040);\n    }\n    // Apply PUE if demand is IT load (not facility load)\n    if (!demandIsFacilityLoad) {\n        demandGW = demandGW * pue;\n    }\n    // Hard asserts in dev mode\n    if (true) {\n        if (year === 2040) {\n            const actual2040 = demandGW;\n            const error2040 = Math.abs(actual2040 - demand2040) / demand2040;\n            if (error2040 >= 0.03) {\n                throw new Error(\"[DEMAND ANCHOR FAIL] demandGw(2040)=\".concat(actual2040.toFixed(2), \" GW, \") + \"expected=\".concat(demand2040, \" GW, error=\").concat((error2040 * 100).toFixed(2), \"% >= 3%\"));\n            }\n        }\n        if (year === 2060) {\n            if (demandGW < 2000) {\n                throw new Error(\"[DEMAND ANCHOR FAIL] demandGw(2060)=\".concat(demandGW.toFixed(2), \" GW < 2000 GW. \") + \"Must be >= 2000 GW (multi-TW target).\");\n            }\n        }\n    }\n    return demandGW;\n}\n/**\n * Calculate price-responsive buildout rate\n * \n * NEW: Buildout responds to margins and backlog\n * Replaces fixed anchors with investment feedback\n */ function calculatePriceResponsiveBuildRateGWyr(year, prevBuildRate, groundMargin, backlogGW, params) {\n    // Base growth (supply chain improvement)\n    const yearsFrom2025 = year - 2025;\n    const baseGrowth = Math.pow(1.03, yearsFrom2025); // 3% organic improvement\n    const baseBuildRate = params.baseBuildRate2025GWyr * baseGrowth;\n    // Investment response: higher margins attract more capital\n    const baselineMargin = 0.20; // 20% baseline margin\n    const marginRatio = groundMargin / baselineMargin;\n    const investmentMultiplier = 1 + params.investmentElasticity * Math.max(0, marginRatio - 1);\n    // Backlog response: higher backlog attracts more investment\n    const backlogMultiplier = 1 + params.backlogResponseK * Math.min(1, backlogGW / 100);\n    // Target build rate\n    let targetRate = baseBuildRate * investmentMultiplier * backlogMultiplier;\n    // Physical ceiling\n    targetRate = Math.min(targetRate, params.maxBuildRateGWyr);\n    // Ramp limit (can't increase faster than 25%/year)\n    const maxRate = prevBuildRate * (1 + params.rampLimitPerYear);\n    const minRate = prevBuildRate * (1 - params.rampLimitPerYear * 0.5); // Slower to decrease\n    targetRate = Math.max(minRate, Math.min(maxRate, targetRate));\n    return Math.max(0, targetRate);\n}\n/**\n * Legacy function: Smooth interpolation for buildout anchors\n * \n * DEPRECATED: Use calculatePriceResponsiveBuildRateGWyr instead\n * Kept for backward compatibility\n */ function calculateBuildRateGWyr(year, params) {\n    const { buildoutAnchorsGWyr, buildoutSmoothingYears } = params;\n    const anchors = buildoutAnchorsGWyr;\n    // Find surrounding anchors\n    const anchorYears = Object.keys(anchors).map(Number).sort((a, b)=>a - b);\n    // Before first anchor: use first anchor value\n    if (year <= anchorYears[0]) {\n        return anchors[anchorYears[0]];\n    }\n    // After last anchor: use last anchor value\n    if (year >= anchorYears[anchorYears.length - 1]) {\n        return anchors[anchorYears[anchorYears.length - 1]];\n    }\n    // Find surrounding anchors\n    let lowerYear = anchorYears[0];\n    let upperYear = anchorYears[anchorYears.length - 1];\n    for(let i = 0; i < anchorYears.length - 1; i++){\n        if (year >= anchorYears[i] && year <= anchorYears[i + 1]) {\n            lowerYear = anchorYears[i];\n            upperYear = anchorYears[i + 1];\n            break;\n        }\n    }\n    const lowerRate = anchors[lowerYear];\n    const upperRate = anchors[upperYear];\n    // Exponential interpolation for buildout ramp\n    const t = (year - lowerYear) / (upperYear - lowerYear);\n    const buildRate = lowerRate * Math.pow(upperRate / lowerRate, t);\n    // Apply smoothing: moving average over smoothing window\n    if (buildoutSmoothingYears > 0) {\n        const smoothingWindow = buildoutSmoothingYears;\n        let smoothedSum = buildRate;\n        let count = 1;\n        // Helper function to calculate unsmoothed rate\n        const getUnsmoothedRate = (y)=>{\n            if (y <= anchorYears[0]) return anchors[anchorYears[0]];\n            if (y >= anchorYears[anchorYears.length - 1]) return anchors[anchorYears[anchorYears.length - 1]];\n            let lower = anchorYears[0];\n            let upper = anchorYears[anchorYears.length - 1];\n            for(let i = 0; i < anchorYears.length - 1; i++){\n                if (y >= anchorYears[i] && y <= anchorYears[i + 1]) {\n                    lower = anchorYears[i];\n                    upper = anchorYears[i + 1];\n                    break;\n                }\n            }\n            const lowerRate = anchors[lower];\n            const upperRate = anchors[upper];\n            const t = (y - lower) / (upper - lower);\n            return lowerRate * Math.pow(upperRate / lowerRate, t);\n        };\n        for(let offset = 1; offset <= Math.floor(smoothingWindow / 2); offset++){\n            const prevYear = year - offset;\n            const nextYear = year + offset;\n            if (prevYear >= anchorYears[0]) {\n                const prevRate = getUnsmoothedRate(prevYear);\n                smoothedSum += prevRate;\n                count++;\n            }\n            if (nextYear <= anchorYears[anchorYears.length - 1]) {\n                const nextRate = getUnsmoothedRate(nextYear);\n                smoothedSum += nextRate;\n                count++;\n            }\n        }\n        return smoothedSum / count;\n    }\n    return buildRate;\n}\n/**\n * Calculate bottleneck rate from anchors (same interpolation as buildout)\n */ function calculateBottleneckRateGWyr(year, anchors) {\n    const anchorYears = [\n        2025,\n        2030,\n        2040,\n        2060\n    ];\n    // Before first anchor: use first anchor value\n    if (year <= anchorYears[0]) {\n        return anchors[2025];\n    }\n    // After last anchor: use last anchor value\n    if (year >= anchorYears[anchorYears.length - 1]) {\n        return anchors[2060];\n    }\n    // Find surrounding anchors\n    let lowerYear = anchorYears[0];\n    let upperYear = anchorYears[anchorYears.length - 1];\n    for(let i = 0; i < anchorYears.length - 1; i++){\n        if (year >= anchorYears[i] && year <= anchorYears[i + 1]) {\n            lowerYear = anchorYears[i];\n            upperYear = anchorYears[i + 1];\n            break;\n        }\n    }\n    const lowerRate = anchors[lowerYear];\n    const upperRate = anchors[upperYear];\n    // Exponential interpolation\n    const t = (year - lowerYear) / (upperYear - lowerYear);\n    return lowerRate * Math.pow(upperRate / lowerRate, t);\n}\n/**\n * Step mobilization state forward one year\n */ function stepMobilizationState(prevState, params, year) {\n    let pue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1.3, retirementsGW = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, orbitalSubstitutionGW = arguments.length > 5 ? arguments[5] : void 0, responsiveDemandGW // Optional: responsive demand (overrides hardcoded calculateDemandGW)\n     = arguments.length > 6 ? arguments[6] : void 0;\n    // Calculate demand: use responsive demand if provided, otherwise use hardcoded\n    // CRITICAL: For backlog buildup, we need demand to grow faster than build rate\n    // If responsive demand is reducing demand too much (price elasticity), backlog won't build\n    const demandGW = responsiveDemandGW !== undefined ? responsiveDemandGW * pue // Convert IT load to facility load\n     : calculateDemandGW(year, params, pue);\n    // FORCE minimum demand growth to ensure backlog builds up (for S-curve)\n    // Even with price elasticity, demand should grow at least 5% per year in early years\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.demandGW) && year <= 2040) {\n        const minDemandGrowth = 0.05; // 5% minimum growth\n        const minDemandGW = prevState.demandGW * (1 + minDemandGrowth);\n        const demandGW = Math.max(demandGW, minDemandGW); // Ensure demand doesn't shrink too much\n    }\n    // Fix 2: Calculate demandGWPrev correctly (don't use same responsiveDemandGW for both years)\n    let demandGWPrev;\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.demandGW) !== undefined) {\n        demandGWPrev = prevState.demandGW;\n    } else if (responsiveDemandGW !== undefined) {\n        // For first year, estimate previous year's demand using hardcoded calculation\n        // Don't use same responsiveDemandGW for both current and previous year\n        demandGWPrev = calculateDemandGW(year - 1, params, pue);\n    } else {\n        demandGWPrev = calculateDemandGW(year - 1, params, pue);\n    }\n    const demandNewGW = Math.max(0, demandGW - demandGWPrev);\n    // Calculate build rate candidate (from anchors)\n    let buildRateCandidate = calculateBuildRateGWyr(year, params);\n    // NEW: If ground demand is falling (due to orbital substitution or price elasticity),\n    // buildout should slow down (no one builds capacity for declining market)\n    const demandGrowthRateActual = (prevState === null || prevState === void 0 ? void 0 : prevState.demandGW) ? (demandGW - prevState.demandGW) / Math.max(prevState.demandGW, 1) : 0;\n    if (demandGrowthRateActual < 0) {\n        // Demand is shrinking - reduce buildout\n        const contractionFactor = Math.max(0.5, 1 + demandGrowthRateActual * 2); // At most 50% reduction\n        buildRateCandidate = buildRateCandidate * contractionFactor; // Reassign to let variable\n    }\n    var _params_bottleneckMode;\n    // Apply bottleneck constraints if enabled\n    const bottleneckMode = (_params_bottleneckMode = params.bottleneckMode) !== null && _params_bottleneckMode !== void 0 ? _params_bottleneckMode : \"min_of_bottlenecks\";\n    let buildRateGWyr = buildRateCandidate;\n    let bottleneckRateGWyr;\n    let limitingBottleneck = \"candidate\";\n    if (bottleneckMode === \"min_of_bottlenecks\" && params.bottleneckAnchorsGWyr) {\n        const { transformers, substations, tx, generation } = params.bottleneckAnchorsGWyr;\n        const transformersRate = calculateBottleneckRateGWyr(year, transformers);\n        const substationsRate = calculateBottleneckRateGWyr(year, substations);\n        const txRate = calculateBottleneckRateGWyr(year, tx);\n        const generationRate = calculateBottleneckRateGWyr(year, generation);\n        // Find minimum bottleneck\n        bottleneckRateGWyr = Math.min(transformersRate, substationsRate, txRate, generationRate);\n        // Determine which bottleneck is limiting\n        if (bottleneckRateGWyr === transformersRate) {\n            limitingBottleneck = \"transformers\";\n        } else if (bottleneckRateGWyr === substationsRate) {\n            limitingBottleneck = \"substations\";\n        } else if (bottleneckRateGWyr === txRate) {\n            limitingBottleneck = \"tx\";\n        } else if (bottleneckRateGWyr === generationRate) {\n            limitingBottleneck = \"generation\";\n        }\n        // Effective build rate is minimum of candidate and bottleneck\n        buildRateGWyr = Math.min(buildRateCandidate, bottleneckRateGWyr);\n    } else {\n        limitingBottleneck = \"none\";\n    }\n    var _params_rampLimitFracPerYear;\n    // Apply ramp limiter (prevent sudden jumps)\n    const rampLimitFrac = (_params_rampLimitFracPerYear = params.rampLimitFracPerYear) !== null && _params_rampLimitFracPerYear !== void 0 ? _params_rampLimitFracPerYear : 0.25;\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.buildRateGWyr) !== undefined) {\n        const prevRate = prevState.buildRateGWyr;\n        const minRate = prevRate * (1 - rampLimitFrac);\n        const maxRate = prevRate * (1 + rampLimitFrac);\n        buildRateGWyr = Math.max(minRate, Math.min(maxRate, buildRateGWyr));\n    }\n    var _prevState_capacityGW;\n    // Calculate capacity evolution\n    // capacityGw(t) = capacityGw(t-1) + buildRateGwYear(t) - retirementsGw(t)\n    const capacityGWPrev = (_prevState_capacityGW = prevState === null || prevState === void 0 ? void 0 : prevState.capacityGW) !== null && _prevState_capacityGW !== void 0 ? _prevState_capacityGW : 0;\n    const capacityGW = capacityGWPrev + buildRateGWyr - retirementsGW;\n    // Calculate pipeline\n    // pipelineGw(t) = buildRateGwYear(t) * pipelineLeadTimeYears * pipelineFillFrac\n    const pipelineGW = buildRateGWyr * params.pipelineLeadTimeYears * params.pipelineFillFrac;\n    // Calculate backlog\n    // backlogGw(t) = max(0, backlogGw(t-1) + demandNewGw(t) - buildableGw(t) - implicitBacklogDrain)\n    // NEW: Backlog can also be satisfied by demand shifting to orbital\n    // When demand shifts to orbital, \"implicit backlog drain\" occurs\n    // because customers who were waiting for ground now use orbital instead\n    // Fix 1: Initialize with baseline backlog if no previous state\n    // HIGHER initial backlog to create early scarcity pressure\n    const INITIAL_BACKLOG_GW = 80; // Increased from 50 to create more early scarcity\n    var _prevState_backlogGW;\n    const backlogGWPrev = (_prevState_backlogGW = prevState === null || prevState === void 0 ? void 0 : prevState.backlogGW) !== null && _prevState_backlogGW !== void 0 ? _prevState_backlogGW : INITIAL_BACKLOG_GW;\n    const buildableGW = buildRateGWyr;\n    const implicitBacklogDrain = (orbitalSubstitutionGW !== null && orbitalSubstitutionGW !== void 0 ? orbitalSubstitutionGW : 0) * 0.5; // 50% of shifted demand was in backlog\n    // NEW: Backlog can drain when demand falls below buildout\n    const netDemandChange = demandNewGW - buildableGW;\n    var _prevState_demandGW;\n    // If orbital substitution caused demand to drop, backlog drains faster\n    const demandDropFromPrev = Math.max(0, ((_prevState_demandGW = prevState === null || prevState === void 0 ? void 0 : prevState.demandGW) !== null && _prevState_demandGW !== void 0 ? _prevState_demandGW : demandGW) - demandGW);\n    const substitutionDrain = demandDropFromPrev * 0.3; // 30% of demand drop was from backlog\n    // Fix 3: Ensure backlog reflects demand-capacity gap\n    // If demand >> capacity, backlog must be at least (demand - capacity)\n    const unservedGW = Math.max(0, demandGW - capacityGW);\n    const backlogFloor = unservedGW * 0.5; // At least 50% of unserved is in backlog\n    const backlogGW = Math.max(backlogFloor, Math.max(0, backlogGWPrev + netDemandChange - substitutionDrain - implicitBacklogDrain));\n    // Hard assert: If demandNewGw(t) > buildRateGwYear(t), backlogGw must increase\n    if (true) {\n        if (demandNewGW > buildRateGWyr && backlogGW <= backlogGWPrev) {\n            throw new Error(\"[BUILDOUT INVARIANT] Year \".concat(year, \": demandNewGW=\").concat(demandNewGW.toFixed(2), \" > \") + \"buildRateGWyr=\".concat(buildRateGWyr.toFixed(2), \", but backlogGW=\").concat(backlogGW.toFixed(2), \" \") + \"<= prevBacklogGW=\".concat(backlogGWPrev.toFixed(2), \". Backlog must increase.\"));\n        }\n    }\n    // Calculate average wait time\n    // avgWaitYears(t) = backlogGw(t) / max(buildRateGwYear(t), 1e-9)\n    // Fix 4: Add sanity check - if backlog > 0, wait must be > 0\n    const EPS = 1e-9;\n    const avgWaitYearsRaw = backlogGW / Math.max(buildRateGWyr, EPS);\n    // If backlog > 0, wait must be > 0\n    const avgWaitYears = backlogGW > 0.1 ? Math.max(0.1, avgWaitYearsRaw) : avgWaitYearsRaw;\n    // Calculate growth rate (for debug)\n    let demandGrowthRate;\n    if (year <= 2040) {\n        demandGrowthRate = Math.log(params.demandAnchorsGW[2040] / params.demandAnchorsGW[2025]) / 15;\n    } else {\n        demandGrowthRate = Math.log(params.demandAnchorsGW[2060] / params.demandAnchorsGW[2040]) / 20;\n    }\n    return {\n        year,\n        demandGW,\n        demandNewGW,\n        buildRateGWyr,\n        capacityGW,\n        pipelineGW,\n        backlogGW,\n        avgWaitYears,\n        demandGrowthRate,\n        buildoutSmoothFactor: params.buildoutSmoothingYears,\n        bottleneckRateGWyr,\n        limitingBottleneck,\n        buildRateCandidate\n    };\n}\n/**\n * Default mobilization scenario parameters\n */ const DEFAULT_MOBILIZATION_PARAMS = {\n    demandAnchorsGW: {\n        2025: 120,\n        2040: 450,\n        2060: 3000\n    },\n    demandCurve: \"piecewise_exponential\",\n    demandIsFacilityLoad: true,\n    buildoutAnchorsGWyr: {\n        2025: 15,\n        2030: 50,\n        2040: 140,\n        2060: 220\n    },\n    buildoutSmoothingYears: 3,\n    pipelineLeadTimeYears: 3,\n    pipelineFillFrac: 1.5,\n    bottleneckMode: \"min_of_bottlenecks\",\n    bottleneckAnchorsGWyr: {\n        transformers: {\n            2025: 30,\n            2030: 50,\n            2040: 100,\n            2060: 180\n        },\n        substations: {\n            2025: 35,\n            2030: 55,\n            2040: 110,\n            2060: 200\n        },\n        tx: {\n            2025: 40,\n            2030: 65,\n            2040: 130,\n            2060: 250\n        },\n        generation: {\n            2025: 50,\n            2030: 80,\n            2040: 160,\n            2060: 300\n        }\n    },\n    rampLimitFracPerYear: 0.25\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX3JhbXBpbmdfbW9iaWxpemF0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Ozs7OztDQVFDLEdBbUVEOzs7OztDQUtDLEdBQ00sU0FBU0EsaUNBQ2RDLElBQVksRUFDWkMscUJBQTZCLEVBQzdCQyxzQkFBOEIsRUFDOUJDLFlBQW9CLEVBQ3BCQyxNQUFvQjtRQUNwQkMsTUFBQUEsaUVBQWM7SUFFZCxxRUFBcUU7SUFDckUsTUFBTUMsZ0JBQWdCTixPQUFPO0lBQzdCLE1BQU1PLGNBQWNDLEtBQUtDLElBQUksQ0FBQ0gsZ0JBQWdCLEtBQUsseUJBQXlCO0lBQzVFLE1BQU1JLGFBQWFOLE9BQU9PLGdCQUFnQixHQUFHSCxLQUFLSSxHQUFHLENBQUMsSUFBSVIsT0FBT1MsaUJBQWlCLEVBQUVQLGdCQUFnQkM7SUFFcEcsZ0RBQWdEO0lBQ2hELE1BQU1PLGdCQUFnQixNQUFNLG9CQUFvQjtJQUNoRCxNQUFNQyxhQUFhZCx3QkFBd0JhO0lBQzNDLE1BQU1FLGNBQWNSLEtBQUtJLEdBQUcsQ0FBQ0csWUFBWVgsT0FBT2EsZUFBZTtJQUUvRCw4Q0FBOEM7SUFDOUMsTUFBTUMsYUFBYVYsS0FBS1csR0FBRyxDQUFDLENBQUNoQixlQUFlQyxPQUFPZ0IsY0FBYyxHQUFHO0lBRXBFLDBEQUEwRDtJQUMxRCxNQUFNQyxtQkFBbUJwQix3QkFBd0JPLEtBQUtjLEdBQUcsQ0FBQ3BCLHdCQUF3QjtJQUNsRixNQUFNcUIscUJBQXFCRixtQkFBbUJqQixPQUFPb0IsNEJBQTRCLEdBQzdFLElBQUssS0FBSSxNQUFPSCxDQUFBQSxtQkFBbUJqQixPQUFPb0IsNEJBQTRCLEtBQ3RFO0lBRUosSUFBSUMsV0FBV2YsYUFBYU0sY0FBY0UsYUFBYUs7SUFFdkQscURBQXFEO0lBQ3JELDBFQUEwRTtJQUMxRSxrRkFBa0Y7SUFFbEYsT0FBT2YsS0FBS2MsR0FBRyxDQUFDLEdBQUdHO0FBQ3JCO0FBRUE7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b0MsOEJBQTBEO0lBQ3JFbkgsaUJBQWlCO1FBQ2YsTUFBTTtRQUNOLE1BQU07UUFDTixNQUFNO0lBQ1I7SUFDQUUsYUFBYTtJQUNiRCxzQkFBc0I7SUFDdEJtQyxxQkFBcUI7UUFDbkIsTUFBTTtRQUNOLE1BQU07UUFDTixNQUFNO1FBQ04sTUFBTTtJQUNSO0lBQ0FDLHdCQUF3QjtJQUN4QitELHVCQUF1QjtJQUN2QkMsa0JBQWtCO0lBQ2xCbkIsZ0JBQWdCO0lBQ2hCSSx1QkFBdUI7UUFDckJDLGNBQWM7WUFBRSxNQUFNO1lBQUksTUFBTTtZQUFJLE1BQU07WUFBSyxNQUFNO1FBQUk7UUFDekRDLGFBQWE7WUFBRSxNQUFNO1lBQUksTUFBTTtZQUFJLE1BQU07WUFBSyxNQUFNO1FBQUk7UUFDeERDLElBQUk7WUFBRSxNQUFNO1lBQUksTUFBTTtZQUFJLE1BQU07WUFBSyxNQUFNO1FBQUk7UUFDL0NDLFlBQVk7WUFBRSxNQUFNO1lBQUksTUFBTTtZQUFJLE1BQU07WUFBSyxNQUFNO1FBQUk7SUFDekQ7SUFDQU0sc0JBQXNCO0FBQ3hCLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9tb2RlbC9ncm91bmRfcmFtcGluZ19tb2JpbGl6YXRpb24udHM/NDQ1OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdyb3VuZCBSYW1waW5nIE1vYmlsaXphdGlvbiBNb2RlbFxuICogXG4gKiBNb2RlbHMgZGVtYW5kIGdyb3d0aCB3aXRoIHByaWNlLXJlc3BvbnNpdmUgZGVtYW5kIGFuZCBidWlsZG91dCBjYXBhY2l0eVxuICogcmFtcGluZyB3aXRoIGludmVzdG1lbnQgcmVzcG9uc2UuIFRyYWNrcyBjYXBhY2l0eSBldm9sdXRpb24sIHBpcGVsaW5lLCBiYWNrbG9nLFxuICogYW5kIHdhaXQgdGltZXMuXG4gKiBcbiAqIE5FVzogUHJpY2UtcmVzcG9uc2l2ZSBkZW1hbmQgYW5kIGludmVzdG1lbnQtcmVzcG9uc2l2ZSBidWlsZG91dCAocmVwbGFjZXMgZml4ZWQgYW5jaG9ycylcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIERlbWFuZFBhcmFtcyB7XG4gIGJhc2VEZW1hbmQyMDI1R1c6IG51bWJlcjsgICAgICAgIC8vIDEyMCBHV1xuICBvcmdhbmljR3Jvd3RoUmF0ZTogbnVtYmVyOyAgICAgICAvLyAwLjEwICgxMCUgQ0FHUiBiYXNlKVxuICBwcmljZUVsYXN0aWNpdHk6IG51bWJlcjsgICAgICAgICAvLyAtMC4zICgzMCUgZGVtYW5kIGRyb3AgcGVyIDEwMCUgcHJpY2UgaW5jcmVhc2UpXG4gIHdhaXRFbGFzdGljaXR5OiBudW1iZXI7ICAgICAgICAgIC8vIC0wLjIgKDIwJSBkZW1hbmQgZHJvcCBwZXIgNXlyIHdhaXQpXG4gIG9yYml0YWxTdWJzdGl0dXRpb25UaHJlc2hvbGQ6IG51bWJlcjsgLy8gUHJpY2UgcmF0aW8gYXQgd2hpY2ggZGVtYW5kIHNoaWZ0cyB0byBvcmJpdGFsIChkZWZhdWx0IDEuMiA9IDIwJSBjaGVhcGVyKVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJ1aWxkb3V0UGFyYW1zIHtcbiAgYmFzZUJ1aWxkUmF0ZTIwMjVHV3lyOiBudW1iZXI7ICAgLy8gMjUgR1cveXJcbiAgbWF4QnVpbGRSYXRlR1d5cjogbnVtYmVyOyAgICAgICAgLy8gMTUwIEdXL3lyIHBoeXNpY2FsIGxpbWl0XG4gIGludmVzdG1lbnRFbGFzdGljaXR5OiBudW1iZXI7ICAgICAvLyAwLjUgKDUwJSBtb3JlIGludmVzdG1lbnQgcGVyIDEwMCUgbWFyZ2luIGluY3JlYXNlKVxuICByYW1wTGltaXRQZXJZZWFyOiBudW1iZXI7ICAgICAgICAgLy8gMC4yNSAoMjUlIG1heCBpbmNyZWFzZSBwZXIgeWVhcilcbiAgYmFja2xvZ1Jlc3BvbnNlSzogbnVtYmVyOyAgICAgICAgIC8vIDAuMyAoaG93IGZhc3QgYnVpbGRvdXQgcmVzcG9uZHMgdG8gYmFja2xvZylcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb2JpbGl6YXRpb25TY2VuYXJpb1BhcmFtcyB7XG4gIGRlbWFuZEFuY2hvcnNHVzoge1xuICAgIDIwMjU6IG51bWJlcjtcbiAgICAyMDQwOiBudW1iZXI7XG4gICAgMjA2MDogbnVtYmVyO1xuICB9O1xuICBkZW1hbmRDdXJ2ZTogJ3BpZWNld2lzZV9leHBvbmVudGlhbCc7IC8vIEN1cnZlIHR5cGUgKG9ubHkgcGllY2V3aXNlX2V4cG9uZW50aWFsIHN1cHBvcnRlZClcbiAgZGVtYW5kSXNGYWNpbGl0eUxvYWQ6IGJvb2xlYW47IC8vIElmIHRydWUsIGluY2x1ZGVzIFBVRTsgaWYgZmFsc2UsIG11bHRpcGx5IGJ5IFBVRSBsYXRlclxuICBidWlsZG91dEFuY2hvcnNHV3lyOiB7XG4gICAgMjAyNTogbnVtYmVyO1xuICAgIDIwMzA6IG51bWJlcjtcbiAgICAyMDQwOiBudW1iZXI7XG4gICAgMjA2MDogbnVtYmVyO1xuICB9O1xuICBidWlsZG91dFNtb290aGluZ1llYXJzOiBudW1iZXI7IC8vIFNtb290aGluZyB3aW5kb3cgZm9yIGJ1aWxkb3V0IGludGVycG9sYXRpb25cbiAgcGlwZWxpbmVMZWFkVGltZVllYXJzOiBudW1iZXI7IC8vIExlYWQgdGltZSBmb3IgcGlwZWxpbmUgY2FsY3VsYXRpb25cbiAgcGlwZWxpbmVGaWxsRnJhYzogbnVtYmVyOyAvLyBQaXBlbGluZSBmaWxsIGZyYWN0aW9uIChwaXBlbGluZUdXID0gbGVhZFRpbWUgKiBidWlsZFJhdGUgKiBmaWxsRnJhYylcbiAgLy8gQm90dGxlbmVjayBjb25zdHJhaW50c1xuICBib3R0bGVuZWNrTW9kZT86ICdvZmYnIHwgJ21pbl9vZl9ib3R0bGVuZWNrcyc7IC8vIERlZmF1bHQgJ21pbl9vZl9ib3R0bGVuZWNrcydcbiAgYm90dGxlbmVja0FuY2hvcnNHV3lyPzoge1xuICAgIHRyYW5zZm9ybWVyczogeyAyMDI1OiBudW1iZXI7IDIwMzA6IG51bWJlcjsgMjA0MDogbnVtYmVyOyAyMDYwOiBudW1iZXIgfTtcbiAgICBzdWJzdGF0aW9uczogeyAyMDI1OiBudW1iZXI7IDIwMzA6IG51bWJlcjsgMjA0MDogbnVtYmVyOyAyMDYwOiBudW1iZXIgfTtcbiAgICB0eDogeyAyMDI1OiBudW1iZXI7IDIwMzA6IG51bWJlcjsgMjA0MDogbnVtYmVyOyAyMDYwOiBudW1iZXIgfTtcbiAgICBnZW5lcmF0aW9uOiB7IDIwMjU6IG51bWJlcjsgMjAzMDogbnVtYmVyOyAyMDQwOiBudW1iZXI7IDIwNjA6IG51bWJlciB9O1xuICB9O1xuICByYW1wTGltaXRGcmFjUGVyWWVhcj86IG51bWJlcjsgLy8gTWF4IGZyYWN0aW9uYWwgY2hhbmdlIHBlciB5ZWFyIChkZWZhdWx0IDAuMjUgPSAyNSUpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9iaWxpemF0aW9uU3RhdGUge1xuICB5ZWFyOiBudW1iZXI7XG4gIGRlbWFuZEdXOiBudW1iZXI7IC8vIFRvdGFsIGRlbWFuZCAoSVQgb3IgZmFjaWxpdHkgbG9hZClcbiAgZGVtYW5kTmV3R1c6IG51bWJlcjsgLy8gSW5jcmVtZW50YWwgZGVtYW5kIHRoaXMgeWVhclxuICBidWlsZFJhdGVHV3lyOiBudW1iZXI7IC8vIEJ1aWxkIHJhdGUgdGhpcyB5ZWFyIChHVy95ZWFyKVxuICBjYXBhY2l0eUdXOiBudW1iZXI7IC8vIEN1bXVsYXRpdmUgY2FwYWNpdHkgYnVpbHRcbiAgcGlwZWxpbmVHVzogbnVtYmVyOyAvLyBQaXBlbGluZSBjYXBhY2l0eSAodW5kZXIgY29uc3RydWN0aW9uKVxuICBiYWNrbG9nR1c6IG51bWJlcjsgLy8gQmFja2xvZyB3YWl0aW5nIHRvIGJlIGJ1aWx0XG4gIGF2Z1dhaXRZZWFyczogbnVtYmVyOyAvLyBBdmVyYWdlIHdhaXQgdGltZSAoYmFja2xvZyAvIGJ1aWxkUmF0ZSlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb2JpbGl6YXRpb25SZXN1bHQgZXh0ZW5kcyBNb2JpbGl6YXRpb25TdGF0ZSB7XG4gIC8vIEFkZGl0aW9uYWwgZGVidWcgZmllbGRzXG4gIGRlbWFuZEdyb3d0aFJhdGU6IG51bWJlcjsgLy8gQ3VycmVudCBncm93dGggcmF0ZSAocjEgb3IgcjIpXG4gIGJ1aWxkb3V0U21vb3RoRmFjdG9yOiBudW1iZXI7IC8vIFNtb290aGluZyBmYWN0b3IgYXBwbGllZFxuICAvLyBCb3R0bGVuZWNrIGRlYnVnIGZpZWxkc1xuICBib3R0bGVuZWNrUmF0ZUdXeXI/OiBudW1iZXI7IC8vIEVmZmVjdGl2ZSBib3R0bGVuZWNrIHJhdGUgKG1pbiBvZiBhbGwgYm90dGxlbmVja3MpXG4gIGxpbWl0aW5nQm90dGxlbmVjaz86ICd0cmFuc2Zvcm1lcnMnIHwgJ3N1YnN0YXRpb25zJyB8ICd0eCcgfCAnZ2VuZXJhdGlvbicgfCAnY2FuZGlkYXRlJyB8ICdub25lJzsgLy8gV2hpY2ggYm90dGxlbmVjayBpcyBsaW1pdGluZ1xuICBidWlsZFJhdGVDYW5kaWRhdGU/OiBudW1iZXI7IC8vIE9yaWdpbmFsIGJ1aWxkIHJhdGUgYmVmb3JlIGJvdHRsZW5lY2svcmFtcCBsaW1pdHNcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgcHJpY2UtcmVzcG9uc2l2ZSBkZW1hbmQgR1dcbiAqIFxuICogTkVXOiBEZW1hbmQgcmVzcG9uZHMgdG8gcHJpY2VzLCB3YWl0IHRpbWVzLCBhbmQgb3JiaXRhbCBzdWJzdGl0dXRpb25cbiAqIFJlcGxhY2VzIGZpeGVkIGFuY2hvcnMgd2l0aCBlY29ub21pYyBmZWVkYmFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUHJpY2VSZXNwb25zaXZlRGVtYW5kR1coXG4gIHllYXI6IG51bWJlcixcbiAgZ3JvdW5kUHJpY2VQZXJHcHVIb3VyOiBudW1iZXIsXG4gIG9yYml0YWxQcmljZVBlckdwdUhvdXI6IG51bWJlcixcbiAgYXZnV2FpdFllYXJzOiBudW1iZXIsXG4gIHBhcmFtczogRGVtYW5kUGFyYW1zLFxuICBwdWU6IG51bWJlciA9IDEuM1xuKTogbnVtYmVyIHtcbiAgLy8gQmFzZSBkZW1hbmQgd2l0aCBvcmdhbmljIGdyb3d0aCAodGFwZXJlZCwgbm90IGV4cG9uZW50aWFsIGZvcmV2ZXIpXG4gIGNvbnN0IHllYXJzRnJvbTIwMjUgPSB5ZWFyIC0gMjAyNTtcbiAgY29uc3QgZ3Jvd3RoVGFwZXIgPSBNYXRoLnRhbmgoeWVhcnNGcm9tMjAyNSAvIDMwKTsgLy8gVGFwZXJzIGFmdGVyIH4zMCB5ZWFyc1xuICBjb25zdCBiYXNlRGVtYW5kID0gcGFyYW1zLmJhc2VEZW1hbmQyMDI1R1cgKiBNYXRoLnBvdygxICsgcGFyYW1zLm9yZ2FuaWNHcm93dGhSYXRlLCB5ZWFyc0Zyb20yMDI1ICogZ3Jvd3RoVGFwZXIpO1xuICBcbiAgLy8gUHJpY2UgZWxhc3RpY2l0eTogaGlnaGVyIHByaWNlcyByZWR1Y2UgZGVtYW5kXG4gIGNvbnN0IGJhc2VsaW5lUHJpY2UgPSAzLjUwOyAvLyAkL0dQVS1ociBiYXNlbGluZVxuICBjb25zdCBwcmljZVJhdGlvID0gZ3JvdW5kUHJpY2VQZXJHcHVIb3VyIC8gYmFzZWxpbmVQcmljZTtcbiAgY29uc3QgcHJpY2VGYWN0b3IgPSBNYXRoLnBvdyhwcmljZVJhdGlvLCBwYXJhbXMucHJpY2VFbGFzdGljaXR5KTtcbiAgXG4gIC8vIFdhaXQgZWxhc3RpY2l0eTogbG9uZ2VyIHdhaXRzIHJlZHVjZSBkZW1hbmRcbiAgY29uc3Qgd2FpdEZhY3RvciA9IE1hdGguZXhwKC1hdmdXYWl0WWVhcnMgKiBwYXJhbXMud2FpdEVsYXN0aWNpdHkgLyA1KTtcbiAgXG4gIC8vIE9yYml0YWwgc3Vic3RpdHV0aW9uOiBpZiBvcmJpdGFsIGNoZWFwZXIsIGRlbWFuZCBzaGlmdHNcbiAgY29uc3Qgb3JiaXRhbEFkdmFudGFnZSA9IGdyb3VuZFByaWNlUGVyR3B1SG91ciAvIE1hdGgubWF4KG9yYml0YWxQcmljZVBlckdwdUhvdXIsIDAuMDEpO1xuICBjb25zdCBzdWJzdGl0dXRpb25GYWN0b3IgPSBvcmJpdGFsQWR2YW50YWdlID4gcGFyYW1zLm9yYml0YWxTdWJzdGl0dXRpb25UaHJlc2hvbGQgXG4gICAgPyAxIC8gKDEgKyAwLjUgKiAob3JiaXRhbEFkdmFudGFnZSAtIHBhcmFtcy5vcmJpdGFsU3Vic3RpdHV0aW9uVGhyZXNob2xkKSlcbiAgICA6IDEuMDtcbiAgXG4gIGxldCBkZW1hbmRHVyA9IGJhc2VEZW1hbmQgKiBwcmljZUZhY3RvciAqIHdhaXRGYWN0b3IgKiBzdWJzdGl0dXRpb25GYWN0b3I7XG4gIFxuICAvLyBBcHBseSBQVUUgaWYgZGVtYW5kIGlzIElUIGxvYWQgKG5vdCBmYWNpbGl0eSBsb2FkKVxuICAvLyBOb3RlOiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgZmFjaWxpdHkgbG9hZCwgc28gbXVsdGlwbHkgYnkgUFVFIGlmIG5lZWRlZFxuICAvLyBGb3Igbm93LCByZXR1cm4gZmFjaWxpdHkgbG9hZCAoZGVtYW5kIGFscmVhZHkgaW5jbHVkZXMgUFVFIGluIGJhc2VEZW1hbmQyMDI1R1cpXG4gIFxuICByZXR1cm4gTWF0aC5tYXgoMCwgZGVtYW5kR1cpO1xufVxuXG4vKipcbiAqIExlZ2FjeSBmdW5jdGlvbjogQ2FsY3VsYXRlIGRlbWFuZCBHVyB1c2luZyBwaWVjZXdpc2UgZXhwb25lbnRpYWwgdG8gaGl0IGFuY2hvcnNcbiAqIFxuICogREVQUkVDQVRFRDogVXNlIGNhbGN1bGF0ZVByaWNlUmVzcG9uc2l2ZURlbWFuZEdXIGluc3RlYWRcbiAqIEtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZURlbWFuZEdXKFxuICB5ZWFyOiBudW1iZXIsXG4gIHBhcmFtczogTW9iaWxpemF0aW9uU2NlbmFyaW9QYXJhbXMsXG4gIHB1ZTogbnVtYmVyID0gMS4zXG4pOiBudW1iZXIge1xuICBjb25zdCB7IGRlbWFuZEFuY2hvcnNHVywgZGVtYW5kSXNGYWNpbGl0eUxvYWQsIGRlbWFuZEN1cnZlIH0gPSBwYXJhbXM7XG4gIGNvbnN0IGRlbWFuZDIwMjUgPSBkZW1hbmRBbmNob3JzR1dbMjAyNV07XG4gIGNvbnN0IGRlbWFuZDIwNDAgPSBkZW1hbmRBbmNob3JzR1dbMjA0MF07XG4gIGNvbnN0IGRlbWFuZDIwNjAgPSBkZW1hbmRBbmNob3JzR1dbMjA2MF07XG4gIFxuICBpZiAoZGVtYW5kQ3VydmUgIT09ICdwaWVjZXdpc2VfZXhwb25lbnRpYWwnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkZW1hbmRDdXJ2ZTogJHtkZW1hbmRDdXJ2ZX0uIE9ubHkgJ3BpZWNld2lzZV9leHBvbmVudGlhbCcgaXMgc3VwcG9ydGVkLmApO1xuICB9XG4gIFxuICBpZiAoeWVhciA8IDIwMjUpIHtcbiAgICByZXR1cm4gZGVtYW5kMjAyNTtcbiAgfVxuICBcbiAgbGV0IGRlbWFuZEdXOiBudW1iZXI7XG4gIFxuICBpZiAoeWVhciA8PSAyMDQwKSB7XG4gICAgLy8gUGhhc2UgMTogMjAyNS0yMDQwXG4gICAgLy8gcjEgPSBsbihkZW1hbmQyMDQwIC8gZGVtYW5kMjAyNSkgLyAoMjA0MC0yMDI1KVxuICAgIGNvbnN0IHIxID0gTWF0aC5sb2coZGVtYW5kMjA0MCAvIGRlbWFuZDIwMjUpIC8gKDIwNDAgLSAyMDI1KTtcbiAgICBjb25zdCB5ZWFyc0Zyb20yMDI1ID0geWVhciAtIDIwMjU7XG4gICAgZGVtYW5kR1cgPSBkZW1hbmQyMDI1ICogTWF0aC5leHAocjEgKiB5ZWFyc0Zyb20yMDI1KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQaGFzZSAyOiAyMDQwLTIwNjBcbiAgICAvLyByMiA9IGxuKGRlbWFuZDIwNjAgLyBkZW1hbmQyMDQwKSAvICgyMDYwLTIwNDApXG4gICAgY29uc3QgcjIgPSBNYXRoLmxvZyhkZW1hbmQyMDYwIC8gZGVtYW5kMjA0MCkgLyAoMjA2MCAtIDIwNDApO1xuICAgIGNvbnN0IHllYXJzRnJvbTIwNDAgPSB5ZWFyIC0gMjA0MDtcbiAgICBkZW1hbmRHVyA9IGRlbWFuZDIwNDAgKiBNYXRoLmV4cChyMiAqIHllYXJzRnJvbTIwNDApO1xuICB9XG4gIFxuICAvLyBBcHBseSBQVUUgaWYgZGVtYW5kIGlzIElUIGxvYWQgKG5vdCBmYWNpbGl0eSBsb2FkKVxuICBpZiAoIWRlbWFuZElzRmFjaWxpdHlMb2FkKSB7XG4gICAgZGVtYW5kR1cgPSBkZW1hbmRHVyAqIHB1ZTtcbiAgfVxuICBcbiAgLy8gSGFyZCBhc3NlcnRzIGluIGRldiBtb2RlXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGlmICh5ZWFyID09PSAyMDQwKSB7XG4gICAgICBjb25zdCBhY3R1YWwyMDQwID0gZGVtYW5kR1c7XG4gICAgICBjb25zdCBlcnJvcjIwNDAgPSBNYXRoLmFicyhhY3R1YWwyMDQwIC0gZGVtYW5kMjA0MCkgLyBkZW1hbmQyMDQwO1xuICAgICAgaWYgKGVycm9yMjA0MCA+PSAwLjAzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgW0RFTUFORCBBTkNIT1IgRkFJTF0gZGVtYW5kR3coMjA0MCk9JHthY3R1YWwyMDQwLnRvRml4ZWQoMil9IEdXLCBgICtcbiAgICAgICAgICBgZXhwZWN0ZWQ9JHtkZW1hbmQyMDQwfSBHVywgZXJyb3I9JHsoZXJyb3IyMDQwICogMTAwKS50b0ZpeGVkKDIpfSUgPj0gMyVgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmICh5ZWFyID09PSAyMDYwKSB7XG4gICAgICBpZiAoZGVtYW5kR1cgPCAyMDAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgW0RFTUFORCBBTkNIT1IgRkFJTF0gZGVtYW5kR3coMjA2MCk9JHtkZW1hbmRHVy50b0ZpeGVkKDIpfSBHVyA8IDIwMDAgR1cuIGAgK1xuICAgICAgICAgIGBNdXN0IGJlID49IDIwMDAgR1cgKG11bHRpLVRXIHRhcmdldCkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIGRlbWFuZEdXO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBwcmljZS1yZXNwb25zaXZlIGJ1aWxkb3V0IHJhdGVcbiAqIFxuICogTkVXOiBCdWlsZG91dCByZXNwb25kcyB0byBtYXJnaW5zIGFuZCBiYWNrbG9nXG4gKiBSZXBsYWNlcyBmaXhlZCBhbmNob3JzIHdpdGggaW52ZXN0bWVudCBmZWVkYmFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUHJpY2VSZXNwb25zaXZlQnVpbGRSYXRlR1d5cihcbiAgeWVhcjogbnVtYmVyLFxuICBwcmV2QnVpbGRSYXRlOiBudW1iZXIsXG4gIGdyb3VuZE1hcmdpbjogbnVtYmVyLCAgLy8gQ3VycmVudCBwcm9maXQgbWFyZ2luIChwcmljZSAtIGNvc3QpIC8gY29zdFxuICBiYWNrbG9nR1c6IG51bWJlcixcbiAgcGFyYW1zOiBCdWlsZG91dFBhcmFtc1xuKTogbnVtYmVyIHtcbiAgLy8gQmFzZSBncm93dGggKHN1cHBseSBjaGFpbiBpbXByb3ZlbWVudClcbiAgY29uc3QgeWVhcnNGcm9tMjAyNSA9IHllYXIgLSAyMDI1O1xuICBjb25zdCBiYXNlR3Jvd3RoID0gTWF0aC5wb3coMS4wMywgeWVhcnNGcm9tMjAyNSk7IC8vIDMlIG9yZ2FuaWMgaW1wcm92ZW1lbnRcbiAgY29uc3QgYmFzZUJ1aWxkUmF0ZSA9IHBhcmFtcy5iYXNlQnVpbGRSYXRlMjAyNUdXeXIgKiBiYXNlR3Jvd3RoO1xuICBcbiAgLy8gSW52ZXN0bWVudCByZXNwb25zZTogaGlnaGVyIG1hcmdpbnMgYXR0cmFjdCBtb3JlIGNhcGl0YWxcbiAgY29uc3QgYmFzZWxpbmVNYXJnaW4gPSAwLjIwOyAvLyAyMCUgYmFzZWxpbmUgbWFyZ2luXG4gIGNvbnN0IG1hcmdpblJhdGlvID0gZ3JvdW5kTWFyZ2luIC8gYmFzZWxpbmVNYXJnaW47XG4gIGNvbnN0IGludmVzdG1lbnRNdWx0aXBsaWVyID0gMSArIHBhcmFtcy5pbnZlc3RtZW50RWxhc3RpY2l0eSAqIE1hdGgubWF4KDAsIG1hcmdpblJhdGlvIC0gMSk7XG4gIFxuICAvLyBCYWNrbG9nIHJlc3BvbnNlOiBoaWdoZXIgYmFja2xvZyBhdHRyYWN0cyBtb3JlIGludmVzdG1lbnRcbiAgY29uc3QgYmFja2xvZ011bHRpcGxpZXIgPSAxICsgcGFyYW1zLmJhY2tsb2dSZXNwb25zZUsgKiBNYXRoLm1pbigxLCBiYWNrbG9nR1cgLyAxMDApO1xuICBcbiAgLy8gVGFyZ2V0IGJ1aWxkIHJhdGVcbiAgbGV0IHRhcmdldFJhdGUgPSBiYXNlQnVpbGRSYXRlICogaW52ZXN0bWVudE11bHRpcGxpZXIgKiBiYWNrbG9nTXVsdGlwbGllcjtcbiAgXG4gIC8vIFBoeXNpY2FsIGNlaWxpbmdcbiAgdGFyZ2V0UmF0ZSA9IE1hdGgubWluKHRhcmdldFJhdGUsIHBhcmFtcy5tYXhCdWlsZFJhdGVHV3lyKTtcbiAgXG4gIC8vIFJhbXAgbGltaXQgKGNhbid0IGluY3JlYXNlIGZhc3RlciB0aGFuIDI1JS95ZWFyKVxuICBjb25zdCBtYXhSYXRlID0gcHJldkJ1aWxkUmF0ZSAqICgxICsgcGFyYW1zLnJhbXBMaW1pdFBlclllYXIpO1xuICBjb25zdCBtaW5SYXRlID0gcHJldkJ1aWxkUmF0ZSAqICgxIC0gcGFyYW1zLnJhbXBMaW1pdFBlclllYXIgKiAwLjUpOyAvLyBTbG93ZXIgdG8gZGVjcmVhc2VcbiAgdGFyZ2V0UmF0ZSA9IE1hdGgubWF4KG1pblJhdGUsIE1hdGgubWluKG1heFJhdGUsIHRhcmdldFJhdGUpKTtcbiAgXG4gIHJldHVybiBNYXRoLm1heCgwLCB0YXJnZXRSYXRlKTtcbn1cblxuLyoqXG4gKiBMZWdhY3kgZnVuY3Rpb246IFNtb290aCBpbnRlcnBvbGF0aW9uIGZvciBidWlsZG91dCBhbmNob3JzXG4gKiBcbiAqIERFUFJFQ0FURUQ6IFVzZSBjYWxjdWxhdGVQcmljZVJlc3BvbnNpdmVCdWlsZFJhdGVHV3lyIGluc3RlYWRcbiAqIEtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUJ1aWxkUmF0ZUdXeXIoXG4gIHllYXI6IG51bWJlcixcbiAgcGFyYW1zOiBNb2JpbGl6YXRpb25TY2VuYXJpb1BhcmFtc1xuKTogbnVtYmVyIHtcbiAgY29uc3QgeyBidWlsZG91dEFuY2hvcnNHV3lyLCBidWlsZG91dFNtb290aGluZ1llYXJzIH0gPSBwYXJhbXM7XG4gIGNvbnN0IGFuY2hvcnMgPSBidWlsZG91dEFuY2hvcnNHV3lyO1xuICBcbiAgLy8gRmluZCBzdXJyb3VuZGluZyBhbmNob3JzXG4gIGNvbnN0IGFuY2hvclllYXJzID0gT2JqZWN0LmtleXMoYW5jaG9ycykubWFwKE51bWJlcikuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICBcbiAgLy8gQmVmb3JlIGZpcnN0IGFuY2hvcjogdXNlIGZpcnN0IGFuY2hvciB2YWx1ZVxuICBpZiAoeWVhciA8PSBhbmNob3JZZWFyc1swXSkge1xuICAgIHJldHVybiBhbmNob3JzW2FuY2hvclllYXJzWzBdIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgfVxuICBcbiAgLy8gQWZ0ZXIgbGFzdCBhbmNob3I6IHVzZSBsYXN0IGFuY2hvciB2YWx1ZVxuICBpZiAoeWVhciA+PSBhbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXSkge1xuICAgIHJldHVybiBhbmNob3JzW2FuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgfVxuICBcbiAgLy8gRmluZCBzdXJyb3VuZGluZyBhbmNob3JzXG4gIGxldCBsb3dlclllYXIgPSBhbmNob3JZZWFyc1swXTtcbiAgbGV0IHVwcGVyWWVhciA9IGFuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdO1xuICBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbmNob3JZZWFycy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBpZiAoeWVhciA+PSBhbmNob3JZZWFyc1tpXSAmJiB5ZWFyIDw9IGFuY2hvclllYXJzW2kgKyAxXSkge1xuICAgICAgbG93ZXJZZWFyID0gYW5jaG9yWWVhcnNbaV07XG4gICAgICB1cHBlclllYXIgPSBhbmNob3JZZWFyc1tpICsgMV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgXG4gIGNvbnN0IGxvd2VyUmF0ZSA9IGFuY2hvcnNbbG93ZXJZZWFyIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgY29uc3QgdXBwZXJSYXRlID0gYW5jaG9yc1t1cHBlclllYXIgYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICBcbiAgLy8gRXhwb25lbnRpYWwgaW50ZXJwb2xhdGlvbiBmb3IgYnVpbGRvdXQgcmFtcFxuICBjb25zdCB0ID0gKHllYXIgLSBsb3dlclllYXIpIC8gKHVwcGVyWWVhciAtIGxvd2VyWWVhcik7XG4gIGNvbnN0IGJ1aWxkUmF0ZSA9IGxvd2VyUmF0ZSAqIE1hdGgucG93KHVwcGVyUmF0ZSAvIGxvd2VyUmF0ZSwgdCk7XG4gIFxuICAvLyBBcHBseSBzbW9vdGhpbmc6IG1vdmluZyBhdmVyYWdlIG92ZXIgc21vb3RoaW5nIHdpbmRvd1xuICBpZiAoYnVpbGRvdXRTbW9vdGhpbmdZZWFycyA+IDApIHtcbiAgICBjb25zdCBzbW9vdGhpbmdXaW5kb3cgPSBidWlsZG91dFNtb290aGluZ1llYXJzO1xuICAgIGxldCBzbW9vdGhlZFN1bSA9IGJ1aWxkUmF0ZTtcbiAgICBsZXQgY291bnQgPSAxO1xuICAgIFxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdW5zbW9vdGhlZCByYXRlXG4gICAgY29uc3QgZ2V0VW5zbW9vdGhlZFJhdGUgPSAoeTogbnVtYmVyKTogbnVtYmVyID0+IHtcbiAgICAgIGlmICh5IDw9IGFuY2hvclllYXJzWzBdKSByZXR1cm4gYW5jaG9yc1thbmNob3JZZWFyc1swXSBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gICAgICBpZiAoeSA+PSBhbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXSkgcmV0dXJuIGFuY2hvcnNbYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV0gYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICAgICAgXG4gICAgICBsZXQgbG93ZXIgPSBhbmNob3JZZWFyc1swXTtcbiAgICAgIGxldCB1cHBlciA9IGFuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbmNob3JZZWFycy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKHkgPj0gYW5jaG9yWWVhcnNbaV0gJiYgeSA8PSBhbmNob3JZZWFyc1tpICsgMV0pIHtcbiAgICAgICAgICBsb3dlciA9IGFuY2hvclllYXJzW2ldO1xuICAgICAgICAgIHVwcGVyID0gYW5jaG9yWWVhcnNbaSArIDFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGxvd2VyUmF0ZSA9IGFuY2hvcnNbbG93ZXIgYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICAgICAgY29uc3QgdXBwZXJSYXRlID0gYW5jaG9yc1t1cHBlciBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gICAgICBjb25zdCB0ID0gKHkgLSBsb3dlcikgLyAodXBwZXIgLSBsb3dlcik7XG4gICAgICByZXR1cm4gbG93ZXJSYXRlICogTWF0aC5wb3codXBwZXJSYXRlIC8gbG93ZXJSYXRlLCB0KTtcbiAgICB9O1xuICAgIFxuICAgIGZvciAobGV0IG9mZnNldCA9IDE7IG9mZnNldCA8PSBNYXRoLmZsb29yKHNtb290aGluZ1dpbmRvdyAvIDIpOyBvZmZzZXQrKykge1xuICAgICAgY29uc3QgcHJldlllYXIgPSB5ZWFyIC0gb2Zmc2V0O1xuICAgICAgY29uc3QgbmV4dFllYXIgPSB5ZWFyICsgb2Zmc2V0O1xuICAgICAgXG4gICAgICBpZiAocHJldlllYXIgPj0gYW5jaG9yWWVhcnNbMF0pIHtcbiAgICAgICAgY29uc3QgcHJldlJhdGUgPSBnZXRVbnNtb290aGVkUmF0ZShwcmV2WWVhcik7XG4gICAgICAgIHNtb290aGVkU3VtICs9IHByZXZSYXRlO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAobmV4dFllYXIgPD0gYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgY29uc3QgbmV4dFJhdGUgPSBnZXRVbnNtb290aGVkUmF0ZShuZXh0WWVhcik7XG4gICAgICAgIHNtb290aGVkU3VtICs9IG5leHRSYXRlO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gc21vb3RoZWRTdW0gLyBjb3VudDtcbiAgfVxuICBcbiAgcmV0dXJuIGJ1aWxkUmF0ZTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgYm90dGxlbmVjayByYXRlIGZyb20gYW5jaG9ycyAoc2FtZSBpbnRlcnBvbGF0aW9uIGFzIGJ1aWxkb3V0KVxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVCb3R0bGVuZWNrUmF0ZUdXeXIoXG4gIHllYXI6IG51bWJlcixcbiAgYW5jaG9yczogeyAyMDI1OiBudW1iZXI7IDIwMzA6IG51bWJlcjsgMjA0MDogbnVtYmVyOyAyMDYwOiBudW1iZXIgfVxuKTogbnVtYmVyIHtcbiAgY29uc3QgYW5jaG9yWWVhcnMgPSBbMjAyNSwgMjAzMCwgMjA0MCwgMjA2MF0gYXMgY29uc3Q7XG4gIFxuICAvLyBCZWZvcmUgZmlyc3QgYW5jaG9yOiB1c2UgZmlyc3QgYW5jaG9yIHZhbHVlXG4gIGlmICh5ZWFyIDw9IGFuY2hvclllYXJzWzBdKSB7XG4gICAgcmV0dXJuIGFuY2hvcnNbMjAyNV07XG4gIH1cbiAgXG4gIC8vIEFmdGVyIGxhc3QgYW5jaG9yOiB1c2UgbGFzdCBhbmNob3IgdmFsdWVcbiAgaWYgKHllYXIgPj0gYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV0pIHtcbiAgICByZXR1cm4gYW5jaG9yc1syMDYwXTtcbiAgfVxuICBcbiAgLy8gRmluZCBzdXJyb3VuZGluZyBhbmNob3JzXG4gIGxldCBsb3dlclllYXIgPSBhbmNob3JZZWFyc1swXTtcbiAgbGV0IHVwcGVyWWVhciA9IGFuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdO1xuICBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbmNob3JZZWFycy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBpZiAoeWVhciA+PSBhbmNob3JZZWFyc1tpXSAmJiB5ZWFyIDw9IGFuY2hvclllYXJzW2kgKyAxXSkge1xuICAgICAgbG93ZXJZZWFyID0gYW5jaG9yWWVhcnNbaV07XG4gICAgICB1cHBlclllYXIgPSBhbmNob3JZZWFyc1tpICsgMV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgXG4gIGNvbnN0IGxvd2VyUmF0ZSA9IGFuY2hvcnNbbG93ZXJZZWFyIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgY29uc3QgdXBwZXJSYXRlID0gYW5jaG9yc1t1cHBlclllYXIgYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICBcbiAgLy8gRXhwb25lbnRpYWwgaW50ZXJwb2xhdGlvblxuICBjb25zdCB0ID0gKHllYXIgLSBsb3dlclllYXIpIC8gKHVwcGVyWWVhciAtIGxvd2VyWWVhcik7XG4gIHJldHVybiBsb3dlclJhdGUgKiBNYXRoLnBvdyh1cHBlclJhdGUgLyBsb3dlclJhdGUsIHQpO1xufVxuXG4vKipcbiAqIFN0ZXAgbW9iaWxpemF0aW9uIHN0YXRlIGZvcndhcmQgb25lIHllYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBNb2JpbGl6YXRpb25TdGF0ZShcbiAgcHJldlN0YXRlOiBNb2JpbGl6YXRpb25TdGF0ZSB8IG51bGwsXG4gIHBhcmFtczogTW9iaWxpemF0aW9uU2NlbmFyaW9QYXJhbXMsXG4gIHllYXI6IG51bWJlcixcbiAgcHVlOiBudW1iZXIgPSAxLjMsXG4gIHJldGlyZW1lbnRzR1c6IG51bWJlciA9IDAsIC8vIE9wdGlvbmFsIHJldGlyZW1lbnRzIChkZWZhdWx0IDApXG4gIG9yYml0YWxTdWJzdGl0dXRpb25HVz86IG51bWJlciwgLy8gT3B0aW9uYWw6IGRlbWFuZCBzaGlmdGVkIHRvIG9yYml0YWwgKGZvciBiYWNrbG9nIGRyYWluKVxuICByZXNwb25zaXZlRGVtYW5kR1c/OiBudW1iZXIgLy8gT3B0aW9uYWw6IHJlc3BvbnNpdmUgZGVtYW5kIChvdmVycmlkZXMgaGFyZGNvZGVkIGNhbGN1bGF0ZURlbWFuZEdXKVxuKTogTW9iaWxpemF0aW9uUmVzdWx0IHtcbiAgLy8gQ2FsY3VsYXRlIGRlbWFuZDogdXNlIHJlc3BvbnNpdmUgZGVtYW5kIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgdXNlIGhhcmRjb2RlZFxuICAvLyBDUklUSUNBTDogRm9yIGJhY2tsb2cgYnVpbGR1cCwgd2UgbmVlZCBkZW1hbmQgdG8gZ3JvdyBmYXN0ZXIgdGhhbiBidWlsZCByYXRlXG4gIC8vIElmIHJlc3BvbnNpdmUgZGVtYW5kIGlzIHJlZHVjaW5nIGRlbWFuZCB0b28gbXVjaCAocHJpY2UgZWxhc3RpY2l0eSksIGJhY2tsb2cgd29uJ3QgYnVpbGRcbiAgY29uc3QgZGVtYW5kR1cgPSByZXNwb25zaXZlRGVtYW5kR1cgIT09IHVuZGVmaW5lZCBcbiAgICA/IHJlc3BvbnNpdmVEZW1hbmRHVyAqIHB1ZSAvLyBDb252ZXJ0IElUIGxvYWQgdG8gZmFjaWxpdHkgbG9hZFxuICAgIDogY2FsY3VsYXRlRGVtYW5kR1coeWVhciwgcGFyYW1zLCBwdWUpO1xuICBcbiAgLy8gRk9SQ0UgbWluaW11bSBkZW1hbmQgZ3Jvd3RoIHRvIGVuc3VyZSBiYWNrbG9nIGJ1aWxkcyB1cCAoZm9yIFMtY3VydmUpXG4gIC8vIEV2ZW4gd2l0aCBwcmljZSBlbGFzdGljaXR5LCBkZW1hbmQgc2hvdWxkIGdyb3cgYXQgbGVhc3QgNSUgcGVyIHllYXIgaW4gZWFybHkgeWVhcnNcbiAgaWYgKHByZXZTdGF0ZT8uZGVtYW5kR1cgJiYgeWVhciA8PSAyMDQwKSB7XG4gICAgY29uc3QgbWluRGVtYW5kR3Jvd3RoID0gMC4wNTsgLy8gNSUgbWluaW11bSBncm93dGhcbiAgICBjb25zdCBtaW5EZW1hbmRHVyA9IHByZXZTdGF0ZS5kZW1hbmRHVyAqICgxICsgbWluRGVtYW5kR3Jvd3RoKTtcbiAgICBjb25zdCBkZW1hbmRHVyA9IE1hdGgubWF4KGRlbWFuZEdXLCBtaW5EZW1hbmRHVyk7IC8vIEVuc3VyZSBkZW1hbmQgZG9lc24ndCBzaHJpbmsgdG9vIG11Y2hcbiAgfVxuICBcbiAgLy8gRml4IDI6IENhbGN1bGF0ZSBkZW1hbmRHV1ByZXYgY29ycmVjdGx5IChkb24ndCB1c2Ugc2FtZSByZXNwb25zaXZlRGVtYW5kR1cgZm9yIGJvdGggeWVhcnMpXG4gIGxldCBkZW1hbmRHV1ByZXY6IG51bWJlcjtcbiAgaWYgKHByZXZTdGF0ZT8uZGVtYW5kR1cgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlbWFuZEdXUHJldiA9IHByZXZTdGF0ZS5kZW1hbmRHVztcbiAgfSBlbHNlIGlmIChyZXNwb25zaXZlRGVtYW5kR1cgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIEZvciBmaXJzdCB5ZWFyLCBlc3RpbWF0ZSBwcmV2aW91cyB5ZWFyJ3MgZGVtYW5kIHVzaW5nIGhhcmRjb2RlZCBjYWxjdWxhdGlvblxuICAgIC8vIERvbid0IHVzZSBzYW1lIHJlc3BvbnNpdmVEZW1hbmRHVyBmb3IgYm90aCBjdXJyZW50IGFuZCBwcmV2aW91cyB5ZWFyXG4gICAgZGVtYW5kR1dQcmV2ID0gY2FsY3VsYXRlRGVtYW5kR1coeWVhciAtIDEsIHBhcmFtcywgcHVlKTtcbiAgfSBlbHNlIHtcbiAgICBkZW1hbmRHV1ByZXYgPSBjYWxjdWxhdGVEZW1hbmRHVyh5ZWFyIC0gMSwgcGFyYW1zLCBwdWUpO1xuICB9XG4gIGNvbnN0IGRlbWFuZE5ld0dXID0gTWF0aC5tYXgoMCwgZGVtYW5kR1cgLSBkZW1hbmRHV1ByZXYpO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGJ1aWxkIHJhdGUgY2FuZGlkYXRlIChmcm9tIGFuY2hvcnMpXG4gIGxldCBidWlsZFJhdGVDYW5kaWRhdGUgPSBjYWxjdWxhdGVCdWlsZFJhdGVHV3lyKHllYXIsIHBhcmFtcyk7XG4gIFxuICAvLyBORVc6IElmIGdyb3VuZCBkZW1hbmQgaXMgZmFsbGluZyAoZHVlIHRvIG9yYml0YWwgc3Vic3RpdHV0aW9uIG9yIHByaWNlIGVsYXN0aWNpdHkpLFxuICAvLyBidWlsZG91dCBzaG91bGQgc2xvdyBkb3duIChubyBvbmUgYnVpbGRzIGNhcGFjaXR5IGZvciBkZWNsaW5pbmcgbWFya2V0KVxuICBjb25zdCBkZW1hbmRHcm93dGhSYXRlQWN0dWFsID0gcHJldlN0YXRlPy5kZW1hbmRHVyA/IChkZW1hbmRHVyAtIHByZXZTdGF0ZS5kZW1hbmRHVykgLyBNYXRoLm1heChwcmV2U3RhdGUuZGVtYW5kR1csIDEpIDogMDtcbiAgaWYgKGRlbWFuZEdyb3d0aFJhdGVBY3R1YWwgPCAwKSB7XG4gICAgLy8gRGVtYW5kIGlzIHNocmlua2luZyAtIHJlZHVjZSBidWlsZG91dFxuICAgIGNvbnN0IGNvbnRyYWN0aW9uRmFjdG9yID0gTWF0aC5tYXgoMC41LCAxICsgZGVtYW5kR3Jvd3RoUmF0ZUFjdHVhbCAqIDIpOyAvLyBBdCBtb3N0IDUwJSByZWR1Y3Rpb25cbiAgICBidWlsZFJhdGVDYW5kaWRhdGUgPSBidWlsZFJhdGVDYW5kaWRhdGUgKiBjb250cmFjdGlvbkZhY3RvcjsgLy8gUmVhc3NpZ24gdG8gbGV0IHZhcmlhYmxlXG4gIH1cbiAgXG4gIC8vIEFwcGx5IGJvdHRsZW5lY2sgY29uc3RyYWludHMgaWYgZW5hYmxlZFxuICBjb25zdCBib3R0bGVuZWNrTW9kZSA9IHBhcmFtcy5ib3R0bGVuZWNrTW9kZSA/PyAnbWluX29mX2JvdHRsZW5lY2tzJztcbiAgbGV0IGJ1aWxkUmF0ZUdXeXIgPSBidWlsZFJhdGVDYW5kaWRhdGU7XG4gIGxldCBib3R0bGVuZWNrUmF0ZUdXeXI6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgbGV0IGxpbWl0aW5nQm90dGxlbmVjazogJ3RyYW5zZm9ybWVycycgfCAnc3Vic3RhdGlvbnMnIHwgJ3R4JyB8ICdnZW5lcmF0aW9uJyB8ICdjYW5kaWRhdGUnIHwgJ25vbmUnID0gJ2NhbmRpZGF0ZSc7XG4gIFxuICBpZiAoYm90dGxlbmVja01vZGUgPT09ICdtaW5fb2ZfYm90dGxlbmVja3MnICYmIHBhcmFtcy5ib3R0bGVuZWNrQW5jaG9yc0dXeXIpIHtcbiAgICBjb25zdCB7IHRyYW5zZm9ybWVycywgc3Vic3RhdGlvbnMsIHR4LCBnZW5lcmF0aW9uIH0gPSBwYXJhbXMuYm90dGxlbmVja0FuY2hvcnNHV3lyO1xuICAgIFxuICAgIGNvbnN0IHRyYW5zZm9ybWVyc1JhdGUgPSBjYWxjdWxhdGVCb3R0bGVuZWNrUmF0ZUdXeXIoeWVhciwgdHJhbnNmb3JtZXJzKTtcbiAgICBjb25zdCBzdWJzdGF0aW9uc1JhdGUgPSBjYWxjdWxhdGVCb3R0bGVuZWNrUmF0ZUdXeXIoeWVhciwgc3Vic3RhdGlvbnMpO1xuICAgIGNvbnN0IHR4UmF0ZSA9IGNhbGN1bGF0ZUJvdHRsZW5lY2tSYXRlR1d5cih5ZWFyLCB0eCk7XG4gICAgY29uc3QgZ2VuZXJhdGlvblJhdGUgPSBjYWxjdWxhdGVCb3R0bGVuZWNrUmF0ZUdXeXIoeWVhciwgZ2VuZXJhdGlvbik7XG4gICAgXG4gICAgLy8gRmluZCBtaW5pbXVtIGJvdHRsZW5lY2tcbiAgICBib3R0bGVuZWNrUmF0ZUdXeXIgPSBNYXRoLm1pbih0cmFuc2Zvcm1lcnNSYXRlLCBzdWJzdGF0aW9uc1JhdGUsIHR4UmF0ZSwgZ2VuZXJhdGlvblJhdGUpO1xuICAgIFxuICAgIC8vIERldGVybWluZSB3aGljaCBib3R0bGVuZWNrIGlzIGxpbWl0aW5nXG4gICAgaWYgKGJvdHRsZW5lY2tSYXRlR1d5ciA9PT0gdHJhbnNmb3JtZXJzUmF0ZSkge1xuICAgICAgbGltaXRpbmdCb3R0bGVuZWNrID0gJ3RyYW5zZm9ybWVycyc7XG4gICAgfSBlbHNlIGlmIChib3R0bGVuZWNrUmF0ZUdXeXIgPT09IHN1YnN0YXRpb25zUmF0ZSkge1xuICAgICAgbGltaXRpbmdCb3R0bGVuZWNrID0gJ3N1YnN0YXRpb25zJztcbiAgICB9IGVsc2UgaWYgKGJvdHRsZW5lY2tSYXRlR1d5ciA9PT0gdHhSYXRlKSB7XG4gICAgICBsaW1pdGluZ0JvdHRsZW5lY2sgPSAndHgnO1xuICAgIH0gZWxzZSBpZiAoYm90dGxlbmVja1JhdGVHV3lyID09PSBnZW5lcmF0aW9uUmF0ZSkge1xuICAgICAgbGltaXRpbmdCb3R0bGVuZWNrID0gJ2dlbmVyYXRpb24nO1xuICAgIH1cbiAgICBcbiAgICAvLyBFZmZlY3RpdmUgYnVpbGQgcmF0ZSBpcyBtaW5pbXVtIG9mIGNhbmRpZGF0ZSBhbmQgYm90dGxlbmVja1xuICAgIGJ1aWxkUmF0ZUdXeXIgPSBNYXRoLm1pbihidWlsZFJhdGVDYW5kaWRhdGUsIGJvdHRsZW5lY2tSYXRlR1d5cik7XG4gIH0gZWxzZSB7XG4gICAgbGltaXRpbmdCb3R0bGVuZWNrID0gJ25vbmUnO1xuICB9XG4gIFxuICAvLyBBcHBseSByYW1wIGxpbWl0ZXIgKHByZXZlbnQgc3VkZGVuIGp1bXBzKVxuICBjb25zdCByYW1wTGltaXRGcmFjID0gcGFyYW1zLnJhbXBMaW1pdEZyYWNQZXJZZWFyID8/IDAuMjU7XG4gIGlmIChwcmV2U3RhdGU/LmJ1aWxkUmF0ZUdXeXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHByZXZSYXRlID0gcHJldlN0YXRlLmJ1aWxkUmF0ZUdXeXI7XG4gICAgY29uc3QgbWluUmF0ZSA9IHByZXZSYXRlICogKDEgLSByYW1wTGltaXRGcmFjKTtcbiAgICBjb25zdCBtYXhSYXRlID0gcHJldlJhdGUgKiAoMSArIHJhbXBMaW1pdEZyYWMpO1xuICAgIGJ1aWxkUmF0ZUdXeXIgPSBNYXRoLm1heChtaW5SYXRlLCBNYXRoLm1pbihtYXhSYXRlLCBidWlsZFJhdGVHV3lyKSk7XG4gIH1cbiAgXG4gIC8vIENhbGN1bGF0ZSBjYXBhY2l0eSBldm9sdXRpb25cbiAgLy8gY2FwYWNpdHlHdyh0KSA9IGNhcGFjaXR5R3codC0xKSArIGJ1aWxkUmF0ZUd3WWVhcih0KSAtIHJldGlyZW1lbnRzR3codClcbiAgY29uc3QgY2FwYWNpdHlHV1ByZXYgPSBwcmV2U3RhdGU/LmNhcGFjaXR5R1cgPz8gMDtcbiAgY29uc3QgY2FwYWNpdHlHVyA9IGNhcGFjaXR5R1dQcmV2ICsgYnVpbGRSYXRlR1d5ciAtIHJldGlyZW1lbnRzR1c7XG4gIFxuICAvLyBDYWxjdWxhdGUgcGlwZWxpbmVcbiAgLy8gcGlwZWxpbmVHdyh0KSA9IGJ1aWxkUmF0ZUd3WWVhcih0KSAqIHBpcGVsaW5lTGVhZFRpbWVZZWFycyAqIHBpcGVsaW5lRmlsbEZyYWNcbiAgY29uc3QgcGlwZWxpbmVHVyA9IGJ1aWxkUmF0ZUdXeXIgKiBwYXJhbXMucGlwZWxpbmVMZWFkVGltZVllYXJzICogcGFyYW1zLnBpcGVsaW5lRmlsbEZyYWM7XG4gIFxuICAvLyBDYWxjdWxhdGUgYmFja2xvZ1xuICAvLyBiYWNrbG9nR3codCkgPSBtYXgoMCwgYmFja2xvZ0d3KHQtMSkgKyBkZW1hbmROZXdHdyh0KSAtIGJ1aWxkYWJsZUd3KHQpIC0gaW1wbGljaXRCYWNrbG9nRHJhaW4pXG4gIC8vIE5FVzogQmFja2xvZyBjYW4gYWxzbyBiZSBzYXRpc2ZpZWQgYnkgZGVtYW5kIHNoaWZ0aW5nIHRvIG9yYml0YWxcbiAgLy8gV2hlbiBkZW1hbmQgc2hpZnRzIHRvIG9yYml0YWwsIFwiaW1wbGljaXQgYmFja2xvZyBkcmFpblwiIG9jY3Vyc1xuICAvLyBiZWNhdXNlIGN1c3RvbWVycyB3aG8gd2VyZSB3YWl0aW5nIGZvciBncm91bmQgbm93IHVzZSBvcmJpdGFsIGluc3RlYWRcbiAgLy8gRml4IDE6IEluaXRpYWxpemUgd2l0aCBiYXNlbGluZSBiYWNrbG9nIGlmIG5vIHByZXZpb3VzIHN0YXRlXG4gIC8vIEhJR0hFUiBpbml0aWFsIGJhY2tsb2cgdG8gY3JlYXRlIGVhcmx5IHNjYXJjaXR5IHByZXNzdXJlXG4gIGNvbnN0IElOSVRJQUxfQkFDS0xPR19HVyA9IDgwOyAvLyBJbmNyZWFzZWQgZnJvbSA1MCB0byBjcmVhdGUgbW9yZSBlYXJseSBzY2FyY2l0eVxuICBjb25zdCBiYWNrbG9nR1dQcmV2ID0gcHJldlN0YXRlPy5iYWNrbG9nR1cgPz8gSU5JVElBTF9CQUNLTE9HX0dXO1xuICBjb25zdCBidWlsZGFibGVHVyA9IGJ1aWxkUmF0ZUdXeXI7XG4gIGNvbnN0IGltcGxpY2l0QmFja2xvZ0RyYWluID0gKG9yYml0YWxTdWJzdGl0dXRpb25HVyA/PyAwKSAqIDAuNTsgLy8gNTAlIG9mIHNoaWZ0ZWQgZGVtYW5kIHdhcyBpbiBiYWNrbG9nXG4gIFxuICAvLyBORVc6IEJhY2tsb2cgY2FuIGRyYWluIHdoZW4gZGVtYW5kIGZhbGxzIGJlbG93IGJ1aWxkb3V0XG4gIGNvbnN0IG5ldERlbWFuZENoYW5nZSA9IGRlbWFuZE5ld0dXIC0gYnVpbGRhYmxlR1c7XG4gIFxuICAvLyBJZiBvcmJpdGFsIHN1YnN0aXR1dGlvbiBjYXVzZWQgZGVtYW5kIHRvIGRyb3AsIGJhY2tsb2cgZHJhaW5zIGZhc3RlclxuICBjb25zdCBkZW1hbmREcm9wRnJvbVByZXYgPSBNYXRoLm1heCgwLCAocHJldlN0YXRlPy5kZW1hbmRHVyA/PyBkZW1hbmRHVykgLSBkZW1hbmRHVyk7XG4gIGNvbnN0IHN1YnN0aXR1dGlvbkRyYWluID0gZGVtYW5kRHJvcEZyb21QcmV2ICogMC4zOyAvLyAzMCUgb2YgZGVtYW5kIGRyb3Agd2FzIGZyb20gYmFja2xvZ1xuICBcbiAgLy8gRml4IDM6IEVuc3VyZSBiYWNrbG9nIHJlZmxlY3RzIGRlbWFuZC1jYXBhY2l0eSBnYXBcbiAgLy8gSWYgZGVtYW5kID4+IGNhcGFjaXR5LCBiYWNrbG9nIG11c3QgYmUgYXQgbGVhc3QgKGRlbWFuZCAtIGNhcGFjaXR5KVxuICBjb25zdCB1bnNlcnZlZEdXID0gTWF0aC5tYXgoMCwgZGVtYW5kR1cgLSBjYXBhY2l0eUdXKTtcbiAgY29uc3QgYmFja2xvZ0Zsb29yID0gdW5zZXJ2ZWRHVyAqIDAuNTsgLy8gQXQgbGVhc3QgNTAlIG9mIHVuc2VydmVkIGlzIGluIGJhY2tsb2dcbiAgY29uc3QgYmFja2xvZ0dXID0gTWF0aC5tYXgoYmFja2xvZ0Zsb29yLCBNYXRoLm1heCgwLCBiYWNrbG9nR1dQcmV2ICsgbmV0RGVtYW5kQ2hhbmdlIC0gc3Vic3RpdHV0aW9uRHJhaW4gLSBpbXBsaWNpdEJhY2tsb2dEcmFpbikpO1xuICBcbiAgLy8gSGFyZCBhc3NlcnQ6IElmIGRlbWFuZE5ld0d3KHQpID4gYnVpbGRSYXRlR3dZZWFyKHQpLCBiYWNrbG9nR3cgbXVzdCBpbmNyZWFzZVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBpZiAoZGVtYW5kTmV3R1cgPiBidWlsZFJhdGVHV3lyICYmIGJhY2tsb2dHVyA8PSBiYWNrbG9nR1dQcmV2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBbQlVJTERPVVQgSU5WQVJJQU5UXSBZZWFyICR7eWVhcn06IGRlbWFuZE5ld0dXPSR7ZGVtYW5kTmV3R1cudG9GaXhlZCgyKX0gPiBgICtcbiAgICAgICAgYGJ1aWxkUmF0ZUdXeXI9JHtidWlsZFJhdGVHV3lyLnRvRml4ZWQoMil9LCBidXQgYmFja2xvZ0dXPSR7YmFja2xvZ0dXLnRvRml4ZWQoMil9IGAgK1xuICAgICAgICBgPD0gcHJldkJhY2tsb2dHVz0ke2JhY2tsb2dHV1ByZXYudG9GaXhlZCgyKX0uIEJhY2tsb2cgbXVzdCBpbmNyZWFzZS5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2Ugd2FpdCB0aW1lXG4gIC8vIGF2Z1dhaXRZZWFycyh0KSA9IGJhY2tsb2dHdyh0KSAvIG1heChidWlsZFJhdGVHd1llYXIodCksIDFlLTkpXG4gIC8vIEZpeCA0OiBBZGQgc2FuaXR5IGNoZWNrIC0gaWYgYmFja2xvZyA+IDAsIHdhaXQgbXVzdCBiZSA+IDBcbiAgY29uc3QgRVBTID0gMWUtOTtcbiAgY29uc3QgYXZnV2FpdFllYXJzUmF3ID0gYmFja2xvZ0dXIC8gTWF0aC5tYXgoYnVpbGRSYXRlR1d5ciwgRVBTKTtcbiAgLy8gSWYgYmFja2xvZyA+IDAsIHdhaXQgbXVzdCBiZSA+IDBcbiAgY29uc3QgYXZnV2FpdFllYXJzID0gYmFja2xvZ0dXID4gMC4xID8gTWF0aC5tYXgoMC4xLCBhdmdXYWl0WWVhcnNSYXcpIDogYXZnV2FpdFllYXJzUmF3O1xuICBcbiAgLy8gQ2FsY3VsYXRlIGdyb3d0aCByYXRlIChmb3IgZGVidWcpXG4gIGxldCBkZW1hbmRHcm93dGhSYXRlOiBudW1iZXI7XG4gIGlmICh5ZWFyIDw9IDIwNDApIHtcbiAgICBkZW1hbmRHcm93dGhSYXRlID0gTWF0aC5sb2cocGFyYW1zLmRlbWFuZEFuY2hvcnNHV1syMDQwXSAvIHBhcmFtcy5kZW1hbmRBbmNob3JzR1dbMjAyNV0pIC8gMTU7XG4gIH0gZWxzZSB7XG4gICAgZGVtYW5kR3Jvd3RoUmF0ZSA9IE1hdGgubG9nKHBhcmFtcy5kZW1hbmRBbmNob3JzR1dbMjA2MF0gLyBwYXJhbXMuZGVtYW5kQW5jaG9yc0dXWzIwNDBdKSAvIDIwO1xuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIHllYXIsXG4gICAgZGVtYW5kR1csXG4gICAgZGVtYW5kTmV3R1csXG4gICAgYnVpbGRSYXRlR1d5cixcbiAgICBjYXBhY2l0eUdXLFxuICAgIHBpcGVsaW5lR1csXG4gICAgYmFja2xvZ0dXLFxuICAgIGF2Z1dhaXRZZWFycyxcbiAgICBkZW1hbmRHcm93dGhSYXRlLFxuICAgIGJ1aWxkb3V0U21vb3RoRmFjdG9yOiBwYXJhbXMuYnVpbGRvdXRTbW9vdGhpbmdZZWFycyxcbiAgICBib3R0bGVuZWNrUmF0ZUdXeXIsXG4gICAgbGltaXRpbmdCb3R0bGVuZWNrLFxuICAgIGJ1aWxkUmF0ZUNhbmRpZGF0ZSxcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWZhdWx0IG1vYmlsaXphdGlvbiBzY2VuYXJpbyBwYXJhbWV0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX01PQklMSVpBVElPTl9QQVJBTVM6IE1vYmlsaXphdGlvblNjZW5hcmlvUGFyYW1zID0ge1xuICBkZW1hbmRBbmNob3JzR1c6IHtcbiAgICAyMDI1OiAxMjAsIC8vIEZhY2lsaXR5IGxvYWQgYmFzZWxpbmUgKElUIGxvYWQgKiBQVUUpXG4gICAgMjA0MDogNDUwLCAvLyBUYXJnZXRcbiAgICAyMDYwOiAzMDAwLCAvLyBNdWx0aS1UVyB0YXJnZXRcbiAgfSxcbiAgZGVtYW5kQ3VydmU6ICdwaWVjZXdpc2VfZXhwb25lbnRpYWwnLFxuICBkZW1hbmRJc0ZhY2lsaXR5TG9hZDogdHJ1ZSwgLy8gRGVtYW5kIGlzIGZhY2lsaXR5IGxvYWQgKGluY2x1ZGVzIFBVRSlcbiAgYnVpbGRvdXRBbmNob3JzR1d5cjoge1xuICAgIDIwMjU6IDE1LCAvLyBMT1dFUiBpbml0aWFsIGJ1aWxkIHJhdGUgdG8gZm9yY2UgYmFja2xvZyBidWlsZHVwICh3YXMgMjUpXG4gICAgMjAzMDogNTAsIC8vIFNsb3dlciByYW1wIHRvIGFsbG93IGJhY2tsb2cgdG8gYnVpbGQgKHdhcyA2MClcbiAgICAyMDQwOiAxNDAsXG4gICAgMjA2MDogMjIwLFxuICB9LFxuICBidWlsZG91dFNtb290aGluZ1llYXJzOiAzLFxuICBwaXBlbGluZUxlYWRUaW1lWWVhcnM6IDMsXG4gIHBpcGVsaW5lRmlsbEZyYWM6IDEuNSxcbiAgYm90dGxlbmVja01vZGU6ICdtaW5fb2ZfYm90dGxlbmVja3MnLFxuICBib3R0bGVuZWNrQW5jaG9yc0dXeXI6IHtcbiAgICB0cmFuc2Zvcm1lcnM6IHsgMjAyNTogMzAsIDIwMzA6IDUwLCAyMDQwOiAxMDAsIDIwNjA6IDE4MCB9LFxuICAgIHN1YnN0YXRpb25zOiB7IDIwMjU6IDM1LCAyMDMwOiA1NSwgMjA0MDogMTEwLCAyMDYwOiAyMDAgfSxcbiAgICB0eDogeyAyMDI1OiA0MCwgMjAzMDogNjUsIDIwNDA6IDEzMCwgMjA2MDogMjUwIH0sXG4gICAgZ2VuZXJhdGlvbjogeyAyMDI1OiA1MCwgMjAzMDogODAsIDIwNDA6IDE2MCwgMjA2MDogMzAwIH0sXG4gIH0sXG4gIHJhbXBMaW1pdEZyYWNQZXJZZWFyOiAwLjI1LCAvLyAyNSUgbWF4IGNoYW5nZSBwZXIgeWVhclxufTtcblxuIl0sIm5hbWVzIjpbImNhbGN1bGF0ZVByaWNlUmVzcG9uc2l2ZURlbWFuZEdXIiwieWVhciIsImdyb3VuZFByaWNlUGVyR3B1SG91ciIsIm9yYml0YWxQcmljZVBlckdwdUhvdXIiLCJhdmdXYWl0WWVhcnMiLCJwYXJhbXMiLCJwdWUiLCJ5ZWFyc0Zyb20yMDI1IiwiZ3Jvd3RoVGFwZXIiLCJNYXRoIiwidGFuaCIsImJhc2VEZW1hbmQiLCJiYXNlRGVtYW5kMjAyNUdXIiwicG93Iiwib3JnYW5pY0dyb3d0aFJhdGUiLCJiYXNlbGluZVByaWNlIiwicHJpY2VSYXRpbyIsInByaWNlRmFjdG9yIiwicHJpY2VFbGFzdGljaXR5Iiwid2FpdEZhY3RvciIsImV4cCIsIndhaXRFbGFzdGljaXR5Iiwib3JiaXRhbEFkdmFudGFnZSIsIm1heCIsInN1YnN0aXR1dGlvbkZhY3RvciIsIm9yYml0YWxTdWJzdGl0dXRpb25UaHJlc2hvbGQiLCJkZW1hbmRHVyIsImNhbGN1bGF0ZURlbWFuZEdXIiwiZGVtYW5kQW5jaG9yc0dXIiwiZGVtYW5kSXNGYWNpbGl0eUxvYWQiLCJkZW1hbmRDdXJ2ZSIsImRlbWFuZDIwMjUiLCJkZW1hbmQyMDQwIiwiZGVtYW5kMjA2MCIsIkVycm9yIiwicjEiLCJsb2ciLCJyMiIsInllYXJzRnJvbTIwNDAiLCJwcm9jZXNzIiwiYWN0dWFsMjA0MCIsImVycm9yMjA0MCIsImFicyIsInRvRml4ZWQiLCJjYWxjdWxhdGVQcmljZVJlc3BvbnNpdmVCdWlsZFJhdGVHV3lyIiwicHJldkJ1aWxkUmF0ZSIsImdyb3VuZE1hcmdpbiIsImJhY2tsb2dHVyIsImJhc2VHcm93dGgiLCJiYXNlQnVpbGRSYXRlIiwiYmFzZUJ1aWxkUmF0ZTIwMjVHV3lyIiwiYmFzZWxpbmVNYXJnaW4iLCJtYXJnaW5SYXRpbyIsImludmVzdG1lbnRNdWx0aXBsaWVyIiwiaW52ZXN0bWVudEVsYXN0aWNpdHkiLCJiYWNrbG9nTXVsdGlwbGllciIsImJhY2tsb2dSZXNwb25zZUsiLCJtaW4iLCJ0YXJnZXRSYXRlIiwibWF4QnVpbGRSYXRlR1d5ciIsIm1heFJhdGUiLCJyYW1wTGltaXRQZXJZZWFyIiwibWluUmF0ZSIsImNhbGN1bGF0ZUJ1aWxkUmF0ZUdXeXIiLCJidWlsZG91dEFuY2hvcnNHV3lyIiwiYnVpbGRvdXRTbW9vdGhpbmdZZWFycyIsImFuY2hvcnMiLCJhbmNob3JZZWFycyIsIk9iamVjdCIsImtleXMiLCJtYXAiLCJOdW1iZXIiLCJzb3J0IiwiYSIsImIiLCJsZW5ndGgiLCJsb3dlclllYXIiLCJ1cHBlclllYXIiLCJpIiwibG93ZXJSYXRlIiwidXBwZXJSYXRlIiwidCIsImJ1aWxkUmF0ZSIsInNtb290aGluZ1dpbmRvdyIsInNtb290aGVkU3VtIiwiY291bnQiLCJnZXRVbnNtb290aGVkUmF0ZSIsInkiLCJsb3dlciIsInVwcGVyIiwib2Zmc2V0IiwiZmxvb3IiLCJwcmV2WWVhciIsIm5leHRZZWFyIiwicHJldlJhdGUiLCJuZXh0UmF0ZSIsImNhbGN1bGF0ZUJvdHRsZW5lY2tSYXRlR1d5ciIsInN0ZXBNb2JpbGl6YXRpb25TdGF0ZSIsInByZXZTdGF0ZSIsInJldGlyZW1lbnRzR1ciLCJvcmJpdGFsU3Vic3RpdHV0aW9uR1ciLCJyZXNwb25zaXZlRGVtYW5kR1ciLCJ1bmRlZmluZWQiLCJtaW5EZW1hbmRHcm93dGgiLCJtaW5EZW1hbmRHVyIsImRlbWFuZEdXUHJldiIsImRlbWFuZE5ld0dXIiwiYnVpbGRSYXRlQ2FuZGlkYXRlIiwiZGVtYW5kR3Jvd3RoUmF0ZUFjdHVhbCIsImNvbnRyYWN0aW9uRmFjdG9yIiwiYm90dGxlbmVja01vZGUiLCJidWlsZFJhdGVHV3lyIiwiYm90dGxlbmVja1JhdGVHV3lyIiwibGltaXRpbmdCb3R0bGVuZWNrIiwiYm90dGxlbmVja0FuY2hvcnNHV3lyIiwidHJhbnNmb3JtZXJzIiwic3Vic3RhdGlvbnMiLCJ0eCIsImdlbmVyYXRpb24iLCJ0cmFuc2Zvcm1lcnNSYXRlIiwic3Vic3RhdGlvbnNSYXRlIiwidHhSYXRlIiwiZ2VuZXJhdGlvblJhdGUiLCJyYW1wTGltaXRGcmFjIiwicmFtcExpbWl0RnJhY1BlclllYXIiLCJjYXBhY2l0eUdXUHJldiIsImNhcGFjaXR5R1ciLCJwaXBlbGluZUdXIiwicGlwZWxpbmVMZWFkVGltZVllYXJzIiwicGlwZWxpbmVGaWxsRnJhYyIsIklOSVRJQUxfQkFDS0xPR19HVyIsImJhY2tsb2dHV1ByZXYiLCJidWlsZGFibGVHVyIsImltcGxpY2l0QmFja2xvZ0RyYWluIiwibmV0RGVtYW5kQ2hhbmdlIiwiZGVtYW5kRHJvcEZyb21QcmV2Iiwic3Vic3RpdHV0aW9uRHJhaW4iLCJ1bnNlcnZlZEdXIiwiYmFja2xvZ0Zsb29yIiwiRVBTIiwiYXZnV2FpdFllYXJzUmF3IiwiZGVtYW5kR3Jvd3RoUmF0ZSIsImJ1aWxkb3V0U21vb3RoRmFjdG9yIiwiREVGQVVMVF9NT0JJTElaQVRJT05fUEFSQU1TIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/ground_ramping_mobilization.ts\n"));

/***/ })

});