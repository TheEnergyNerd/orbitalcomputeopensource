"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/compare/page",{

/***/ "(app-pages-browser)/./app/lib/model/trajectory.ts":
/*!*************************************!*\
  !*** ./app/lib/model/trajectory.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MARKET_PROVIDERS: function() { return /* binding */ MARKET_PROVIDERS; },\n/* harmony export */   calculateMarketShare: function() { return /* binding */ calculateMarketShare; },\n/* harmony export */   calculateResponsiveDemand: function() { return /* binding */ calculateResponsiveDemand; },\n/* harmony export */   computeTrajectory: function() { return /* binding */ computeTrajectory; },\n/* harmony export */   findCrossoverYear: function() { return /* binding */ findCrossoverYear; },\n/* harmony export */   findCrossoverYearEffectivePflop: function() { return /* binding */ findCrossoverYearEffectivePflop; },\n/* harmony export */   generateFinalAnalysis: function() { return /* binding */ generateFinalAnalysis; },\n/* harmony export */   getDemandNewGW: function() { return /* binding */ getDemandNewGW; },\n/* harmony export */   getDemandProjection: function() { return /* binding */ getDemandProjection; },\n/* harmony export */   getFacilityLoadGW: function() { return /* binding */ getFacilityLoadGW; },\n/* harmony export */   getITLoadGW: function() { return /* binding */ getITLoadGW; },\n/* harmony export */   projectMarketPrice: function() { return /* binding */ projectMarketPrice; }\n/* harmony export */ });\n/* harmony import */ var _physicsCost__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./physicsCost */ \"(app-pages-browser)/./app/lib/model/physicsCost.ts\");\n/* harmony import */ var _launch_learning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./launch_learning */ \"(app-pages-browser)/./app/lib/model/launch_learning.ts\");\n/* harmony import */ var _modes_static__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modes/static */ \"(app-pages-browser)/./app/lib/model/modes/static.ts\");\n/* harmony import */ var _monteCarloCrossover__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./monteCarloCrossover */ \"(app-pages-browser)/./app/lib/model/monteCarloCrossover.ts\");\n\n\n\n\n/**\n * Find crossover year using GPU-hour pricing (preferred, includes scarcity)\n * Uses scarcity-inclusive comparator consistently\n */ function findCrossoverYear(trajectory) {\n    const crossing = trajectory.find((d)=>{\n        var _d_ground_constraints, _d_ground_constraints1;\n        var _d_ground_totalCostPerPflopYearEffective;\n        // Use effective ground cost (includes delayPenalty + scarcityRent) for crossover\n        const groundEffectiveCost = (_d_ground_totalCostPerPflopYearEffective = d.ground.totalCostPerPflopYearEffective) !== null && _d_ground_totalCostPerPflopYearEffective !== void 0 ? _d_ground_totalCostPerPflopYearEffective : d.ground.totalCostPerPflopYear + (((_d_ground_constraints = d.ground.constraints) === null || _d_ground_constraints === void 0 ? void 0 : _d_ground_constraints.delayPenalty) || 0) + (((_d_ground_constraints1 = d.ground.constraints) === null || _d_ground_constraints1 === void 0 ? void 0 : _d_ground_constraints1.scarcityRentPerPflopYear) || 0);\n        var _d_orbit_totalCostPerPflopYearEffective;\n        const orbitCost = (_d_orbit_totalCostPerPflopYearEffective = d.orbit.totalCostPerPflopYearEffective) !== null && _d_orbit_totalCostPerPflopYearEffective !== void 0 ? _d_orbit_totalCostPerPflopYearEffective : d.orbit.totalCostPerPflopYear;\n        return Number.isFinite(orbitCost) && Number.isFinite(groundEffectiveCost) && orbitCost < groundEffectiveCost;\n    });\n    return crossing ? crossing.year : null;\n}\n/**\n * Find crossover year using effective PFLOP-year cost (includes scarcity adders)\n * Uses scarcity-inclusive comparator: delayPenalty + scarcityRent\n * capacityDeliveryPremium is engineering cost, not scarcity pricing\n */ function findCrossoverYearEffectivePflop(trajectory) {\n    const crossing = trajectory.find((d)=>{\n        var _d_ground_constraints, _d_ground_constraints1;\n        var _d_ground_totalCostPerPflopYearEffective;\n        // Ground effective cost includes: base + delayPenalty + scarcityRent\n        const groundEffectiveCost = (_d_ground_totalCostPerPflopYearEffective = d.ground.totalCostPerPflopYearEffective) !== null && _d_ground_totalCostPerPflopYearEffective !== void 0 ? _d_ground_totalCostPerPflopYearEffective : d.ground.totalCostPerPflopYear + (((_d_ground_constraints = d.ground.constraints) === null || _d_ground_constraints === void 0 ? void 0 : _d_ground_constraints.delayPenalty) || 0) + (((_d_ground_constraints1 = d.ground.constraints) === null || _d_ground_constraints1 === void 0 ? void 0 : _d_ground_constraints1.scarcityRentPerPflopYear) || 0);\n        var _d_orbit_totalCostPerPflopYearEffective;\n        const orbitCost = (_d_orbit_totalCostPerPflopYearEffective = d.orbit.totalCostPerPflopYearEffective) !== null && _d_orbit_totalCostPerPflopYearEffective !== void 0 ? _d_orbit_totalCostPerPflopYearEffective : d.orbit.totalCostPerPflopYear;\n        return orbitCost < groundEffectiveCost;\n    });\n    return crossing ? crossing.year : null;\n}\n// Calculate market share based on cost ratio\n// When orbital is 50% cheaper, it gets ~80% of NEW capacity\n// When orbital is 2x more expensive, it gets ~5% (niche applications)\nfunction calculateMarketShare(year, orbitalCostPerPflop, groundCostPerPflop, totalDemandGW) {\n    let orbitalFeasible = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true, groundFeasible = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true, orbitalCostAccountingValid = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : true, groundCostAccountingValid = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : true, // Additional parameters for served compute calculation\n    demandGW = arguments.length > 8 ? arguments[8] : void 0, backlogGW = arguments.length > 9 ? arguments[9] : void 0, buildRateGWyr = arguments.length > 10 ? arguments[10] : void 0, avgWaitYears = arguments.length > 11 ? arguments[11] : void 0, orbitMaxDeployableComputeGW // Maximum orbital capacity (from launch/manufacturing constraints)\n     = arguments.length > 12 ? arguments[12] : void 0;\n    // CRITICAL FIX: Feasibility gating\n    // Check if both systems are feasible before computing shares\n    const orbitalActuallyFeasible = orbitalFeasible && orbitalCostAccountingValid;\n    const groundActuallyFeasible = groundFeasible && groundCostAccountingValid;\n    // If neither is feasible, default to ground (conservative)\n    if (!orbitalActuallyFeasible && !groundActuallyFeasible) {\n        return {\n            year,\n            totalDemandGW,\n            orbitalShareFrac: 0,\n            orbitalCapacityGW: 0,\n            orbitalRevenue: 0,\n            groundShareFrac: 1.0,\n            groundCapacityGW: totalDemandGW,\n            debug: {\n                shareConvention: \"frac\",\n                orbitalFeasible: false,\n                groundFeasible: false,\n                orbitalShareFrac: 0,\n                groundShareFrac: 1.0,\n                orbitalCapacityGW: 0,\n                groundCapacityGW: totalDemandGW,\n                orbitalRevenue: 0,\n                groundRevenue: totalDemandGW * 2e9\n            }\n        };\n    }\n    // If only one is feasible, it gets 100%\n    if (!orbitalActuallyFeasible) {\n        return {\n            year,\n            totalDemandGW,\n            orbitalShareFrac: 0,\n            orbitalCapacityGW: 0,\n            orbitalRevenue: 0,\n            groundShareFrac: 1.0,\n            groundCapacityGW: totalDemandGW,\n            debug: {\n                shareConvention: \"frac\",\n                orbitalFeasible: false,\n                groundFeasible: true,\n                orbitalShareFrac: 0,\n                groundShareFrac: 1.0,\n                orbitalCapacityGW: 0,\n                groundCapacityGW: totalDemandGW,\n                orbitalRevenue: 0,\n                groundRevenue: totalDemandGW * 2e9\n            }\n        };\n    }\n    if (!groundActuallyFeasible) {\n        return {\n            year,\n            totalDemandGW,\n            orbitalShareFrac: 1.0,\n            orbitalCapacityGW: totalDemandGW,\n            orbitalRevenue: totalDemandGW * 2e9,\n            groundShareFrac: 0,\n            groundCapacityGW: 0,\n            debug: {\n                shareConvention: \"frac\",\n                orbitalFeasible: true,\n                groundFeasible: false,\n                orbitalShareFrac: 1.0,\n                groundShareFrac: 0,\n                orbitalCapacityGW: totalDemandGW,\n                groundCapacityGW: 0,\n                orbitalRevenue: totalDemandGW * 2e9,\n                groundRevenue: 0\n            }\n        };\n    }\n    // Hard rules: shares are always 0..1 fractions, served compute cannot exceed feasible compute\n    const demand = demandGW !== null && demandGW !== void 0 ? demandGW : totalDemandGW;\n    const backlogGWActual = backlogGW !== null && backlogGW !== void 0 ? backlogGW : 0;\n    const buildRateGWyrActual = buildRateGWyr !== null && buildRateGWyr !== void 0 ? buildRateGWyr : 0;\n    const avgWaitYearsActual = avgWaitYears !== null && avgWaitYears !== void 0 ? avgWaitYears : 0;\n    // HARD FEASIBILITY GATING: If avgWaitYears > 3 OR backlog > 25% of demand, ground cannot serve all marginal demand\n    // This forces spillover to orbital earlier, making crossover happen the right way (feasibility, not fake pricing)\n    const groundHasSevereQueue = avgWaitYearsActual > 3 || backlogGWActual > 0.25 * demand;\n    // Ground feasible capacity: reduced by queue pressure\n    const groundFeasibleGW = groundActuallyFeasible ? groundHasSevereQueue ? Math.max(0, demand * 0.5 - backlogGWActual) // Severe queue: ground can only serve 50% of demand\n     : Math.max(0, demand - backlogGWActual) // Normal: ground can serve demand minus backlog\n     : 0;\n    // Orbital feasible capacity: can serve remainder (up to max deployable)\n    const orbitFeasibleGW = orbitalActuallyFeasible ? Math.min(demand - groundFeasibleGW, orbitMaxDeployableComputeGW !== null && orbitMaxDeployableComputeGW !== void 0 ? orbitMaxDeployableComputeGW : demand) : 0;\n    const maxServable = Math.min(demand, groundFeasibleGW + orbitFeasibleGW);\n    // Compute desired shares (0..1) from cost ratios (logit model)\n    const costRatio = orbitalCostPerPflop / groundCostPerPflop;\n    const logitFactor = Math.exp(-5 * (costRatio - 1)); // When orbital is 50% cheaper, it gets ~80% of NEW capacity\n    const orbitalShareFracDesired = logitFactor / (1 + logitFactor);\n    const groundShareFracDesired = 1 - orbitalShareFracDesired;\n    // Convert to served, then clamp by feasibility\n    let orbitServed = orbitalShareFracDesired * maxServable;\n    let groundServed = groundShareFracDesired * maxServable;\n    orbitServed = Math.min(orbitServed, orbitFeasibleGW);\n    groundServed = Math.min(groundServed, groundFeasibleGW);\n    // If clamping reduced one side, reassign remainder if possible\n    const remainder = maxServable - (orbitServed + groundServed);\n    if (remainder > 0) {\n        const orbitRoom = orbitFeasibleGW - orbitServed;\n        const groundRoom = groundFeasibleGW - groundServed;\n        const addToOrbit = Math.min(remainder, Math.max(0, orbitRoom));\n        orbitServed += addToOrbit;\n        groundServed += Math.min(remainder - addToOrbit, Math.max(0, groundRoom));\n    }\n    // Recalculate shares from actual served (ensures shares are 0..1 and sum to 1)\n    const totalServedGW = orbitServed + groundServed;\n    const orbitalShareFrac = totalServedGW > 0 ? orbitServed / totalServedGW : 0;\n    const groundShareFrac = totalServedGW > 0 ? groundServed / totalServedGW : 0;\n    // Use served values for capacity\n    const groundServedComputeGW = groundServed;\n    const orbitServedComputeGW = orbitServed;\n    const groundFeasibleComputeGW = groundFeasibleGW;\n    const orbitFeasibleComputeGW = orbitFeasibleGW;\n    // Capacity served (GW)\n    const orbitalCapacityGW = orbitServedComputeGW;\n    const groundCapacityGW = groundServedComputeGW;\n    // Revenue per GW (assume $2B/GW/year for compute services)\n    const revenuePerGW = 2e9;\n    const orbitalRevenue = orbitalCapacityGW * revenuePerGW;\n    const groundRevenue = groundCapacityGW * revenuePerGW;\n    // Invariants\n    if (orbitalCapacityGW === 0 && orbitalRevenue !== 0) {\n        throw new Error(\"orbitalCapacityGW=0 but orbitalRevenue=\".concat(orbitalRevenue, \" > 0\"));\n    }\n    if (orbitalRevenue > 0 && orbitalCapacityGW <= 0) {\n        throw new Error(\"orbitalRevenue=\".concat(orbitalRevenue, \" > 0 but orbitalCapacityGW=\").concat(orbitalCapacityGW, \" <= 0\"));\n    }\n    if (orbitFeasibleComputeGW === 0 && orbitalShareFrac !== 0) {\n        throw new Error(\"orbitFeasibleComputeGW=0 but orbitalShareFrac=\".concat(orbitalShareFrac, \" > 0\"));\n    }\n    // Shares should sum to 1.0 when both feasible and totalServed > 0\n    if (totalServedGW > 0) {\n        const shareSum = orbitalShareFrac + groundShareFrac;\n        if (Math.abs(shareSum - 1.0) > 1e-6) {\n            throw new Error(\"Market share sum must equal 1.0, got \".concat(shareSum, \" (orbital=\").concat(orbitalShareFrac, \", ground=\").concat(groundShareFrac, \")\"));\n        }\n    }\n    return {\n        year,\n        totalDemandGW,\n        orbitalShareFrac,\n        orbitalCapacityGW,\n        orbitalRevenue,\n        groundShareFrac,\n        groundCapacityGW,\n        debug: {\n            shareConvention: \"frac\",\n            orbitalFeasible: true,\n            groundFeasible: true,\n            orbitalShareFrac,\n            groundShareFrac,\n            orbitalCapacityGW,\n            groundCapacityGW,\n            orbitalRevenue,\n            groundRevenue,\n            demandComputeGW: demand,\n            groundServedComputeGW,\n            orbitServedComputeGW,\n            groundFeasibleComputeGW,\n            orbitFeasibleComputeGW,\n            backlogGW: backlogGWActual,\n            buildRateGWyr: buildRateGWyrActual,\n            avgWaitYears: avgWaitYears !== null && avgWaitYears !== void 0 ? avgWaitYears : 0\n        }\n    };\n}\nfunction projectMarketPrice(basePrice, baseYear, targetYear) {\n    let annualDeclineRate = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.10;\n    const years = targetYear - baseYear;\n    return basePrice * Math.pow(1 - annualDeclineRate, years);\n}\nconst MARKET_PROVIDERS = [\n    {\n        name: \"AWS H100\",\n        price: 4.50,\n        decline: 0.10\n    },\n    {\n        name: \"Azure H100\",\n        price: 4.00,\n        decline: 0.10\n    },\n    {\n        name: \"CoreWeave\",\n        price: 2.23,\n        decline: 0.12\n    },\n    {\n        name: \"Lambda Labs\",\n        price: 2.49,\n        decline: 0.10\n    }\n];\n// ============================================================================\n// DEMAND MODEL: Installed IT Load (GW) with Piecewise Exponential Growth\n// ============================================================================\n// \n// Model: IT_GW(t) = installed IT load in GW\n// Targets:\n//   - IT_GW(2025) = IT0 (baseline)\n//   - IT_GW(2040) = 450 GW\n//   - IT_GW(2060) = 3000 GW (multi-TW by 2060)\n//\n// Piecewise exponential:\n//   - 2025-2040: IT_GW(t) = IT0 * exp(r1 * (t - 2025))\n//   - 2040-2060: IT_GW(t) = IT_GW(2040) * exp(r2 * (t - 2040))\n//\n// Then derive:\n//   - Facility_GW(t) = IT_GW(t) * PUE(t)  (hits transmission/substation constraints)\n//   - DemandNewGW(t) = max(0, Facility_GW(t) - Facility_GW(t-1))\n// LEGACY: Hardcoded demand anchors (kept for backward compatibility, but replaced by responsive demand)\nconst IT_GW_2025 = 120; // Baseline installed IT load in 2025 (GW)\nconst IT_GW_2040_TARGET = 450; // Target installed IT load in 2040 (GW)\nconst IT_GW_2060_TARGET = 3000; // Target installed IT load in 2060 (GW)\n// Calculate growth rates\nconst R1 = Math.log(IT_GW_2040_TARGET / IT_GW_2025) / 15; // Growth rate 2025-2040\nconst R2 = Math.log(IT_GW_2060_TARGET / IT_GW_2040_TARGET) / 20; // Growth rate 2040-2060\n/**\n * Calculate price-responsive demand that creates S-curve\n * \n * Demand responds to:\n * - Price elasticity: higher ground prices reduce demand\n * - Wait elasticity: longer waits reduce demand\n * - Orbital substitution: if orbital cheaper, demand shifts\n */ function calculateResponsiveDemand(year, groundPricePerGpuHour, orbitalPricePerGpuHour, avgWaitYears, prevDemandState) {\n    // Baseline demand: 10% CAGR from 120 GW, TAPERED after 20 years\n    const yearsFrom2025 = year - 2025;\n    const growthRate = 0.10; // 10% CAGR\n    const taper = 1 / (1 + Math.exp((yearsFrom2025 - 20) / 5)); // Tapers after 2045\n    const effectiveGrowth = growthRate * (0.5 + 0.5 * taper); // 10% -> 5% CAGR\n    const baselineGW = 120 * Math.pow(1 + effectiveGrowth, yearsFrom2025);\n    // BALANCE: Allow S-curve while preventing oscillation\n    // Use exponential smoothing on price and wait factors - balanced for S-curve formation\n    const SMOOTHING_ALPHA = 0.25; // 25% weight on new value, 75% on previous (allows S-curve while preventing oscillation)\n    // Price elasticity: demand drops as ground price rises (REDUCED to prevent oscillation)\n    const baselinePrice = 4.00; // $/GPU-hr reference\n    const priceRatio = groundPricePerGpuHour / baselinePrice;\n    const priceElasticity = -0.2; // REDUCED from -0.3 to -0.2 (less aggressive)\n    const priceFactorRaw = Math.pow(priceRatio, priceElasticity);\n    // Smooth price factor using previous state\n    const prevPriceFactor = prevDemandState ? prevDemandState.effectiveGW / prevDemandState.baselineGW : priceFactorRaw;\n    const priceFactor = SMOOTHING_ALPHA * priceFactorRaw + (1 - SMOOTHING_ALPHA) * prevPriceFactor;\n    // Wait elasticity: demand drops with longer waits (REDUCED to prevent oscillation)\n    const waitElasticity = -0.10; // REDUCED from -0.15 to -0.10 (less aggressive)\n    const waitFactorRaw = Math.exp(avgWaitYears * waitElasticity / 5);\n    // Smooth wait factor using previous state\n    const prevWaitFactor = prevDemandState ? prevDemandState.effectiveGW / (prevDemandState.baselineGW * prevPriceFactor) : waitFactorRaw;\n    const waitFactor = SMOOTHING_ALPHA * waitFactorRaw + (1 - SMOOTHING_ALPHA) * prevWaitFactor;\n    // Effective total demand (may shift to orbital)\n    // Add minimum floor to prevent demand from collapsing too quickly\n    const effectiveGWRaw = baselineGW * priceFactor * waitFactor;\n    const minDemandFrac = 0.5; // Demand can't drop below 50% of baseline\n    const effectiveGW = Math.max(baselineGW * minDemandFrac, effectiveGWRaw);\n    // FIXED: Orbital substitution with smoothing to prevent cobweb oscillation\n    const groundOrbitalRatio = groundPricePerGpuHour / Math.max(orbitalPricePerGpuHour, 0.01);\n    // Gentler curve (k=1.0 instead of 2.0, midpoint=1.5 instead of 1.3)\n    // At ratio 1.2: ~5% shifts, ratio 1.5: ~25%, ratio 2.0: ~50%\n    let targetOrbitalShare = 0;\n    if (groundOrbitalRatio > 1.0) {\n        targetOrbitalShare = 1 / (1 + Math.exp(-1.0 * (groundOrbitalRatio - 1.5)));\n    }\n    var _prevDemandState_orbitalShare;\n    // Smooth orbital share - allow faster substitution for S-curve (one-way shift prevents oscillation)\n    const prevOrbitalShare = (_prevDemandState_orbitalShare = prevDemandState === null || prevDemandState === void 0 ? void 0 : prevDemandState.orbitalShare) !== null && _prevDemandState_orbitalShare !== void 0 ? _prevDemandState_orbitalShare : 0;\n    const maxShareChangePerYear = 0.25; // Max 25% shift per year (faster substitution for S-curve)\n    const shareChange = targetOrbitalShare - prevOrbitalShare;\n    const smoothedChange = Math.sign(shareChange) * Math.min(Math.abs(shareChange), maxShareChangePerYear);\n    const orbitalShare = Math.max(0, Math.min(1, prevOrbitalShare + smoothedChange));\n    // Calculate ground demand\n    let groundDemandGW = effectiveGW * (1 - orbitalShare);\n    // DEBUG: Log raw demand before smoothing\n    if (true) {\n        var _prevDemandState_groundDemandGW;\n        console.log(\"[DEMAND DEBUG] Year \".concat(year, \": raw groundDemandGW=\").concat(groundDemandGW.toFixed(1)));\n        var _prevDemandState_groundDemandGW_toFixed;\n        console.log(\"[DEMAND DEBUG]   prevDemandState=\".concat(prevDemandState ? \"exists, groundDemandGW=\".concat((_prevDemandState_groundDemandGW_toFixed = (_prevDemandState_groundDemandGW = prevDemandState.groundDemandGW) === null || _prevDemandState_groundDemandGW === void 0 ? void 0 : _prevDemandState_groundDemandGW.toFixed(1)) !== null && _prevDemandState_groundDemandGW_toFixed !== void 0 ? _prevDemandState_groundDemandGW_toFixed : \"undefined\") : \"NULL\"));\n    }\n    // BALANCE: Allow S-curve demand changes when orbital substitution happens\n    // Use explicit check instead of truthy check to handle 0 values correctly\n    if (prevDemandState !== null && prevDemandState.groundDemandGW !== undefined && prevDemandState.groundDemandGW > 0) {\n        // Allow larger changes when orbital substitution is happening (S-curve formation)\n        // But still cap to prevent wild oscillations\n        const orbitalSubstitutionActive = orbitalShare > 0.1 || prevOrbitalShare > 0 && orbitalShare > prevOrbitalShare;\n        const maxDemandChangePerYear = orbitalSubstitutionActive ? 0.12 : 0.08; // 12% when substitution active, 8% otherwise\n        const demandChangeRatio = groundDemandGW / prevDemandState.groundDemandGW;\n        if (true) {\n            console.log(\"[DEMAND DEBUG]   changeRatio=\".concat(demandChangeRatio.toFixed(3), \" (max allowed: \").concat((1 + maxDemandChangePerYear).toFixed(3), \" to \").concat((1 - maxDemandChangePerYear).toFixed(3), \")\"));\n        }\n        if (demandChangeRatio > 1 + maxDemandChangePerYear) {\n            const clamped = prevDemandState.groundDemandGW * (1 + maxDemandChangePerYear);\n            if (true) {\n                console.log(\"[DEMAND DEBUG]   CLAMPED UP from \".concat(groundDemandGW.toFixed(1), \" to \").concat(clamped.toFixed(1)));\n            }\n            groundDemandGW = clamped;\n        } else if (demandChangeRatio < 1 - maxDemandChangePerYear) {\n            const clamped = prevDemandState.groundDemandGW * (1 - maxDemandChangePerYear);\n            if (true) {\n                console.log(\"[DEMAND DEBUG]   CLAMPED DOWN from \".concat(groundDemandGW.toFixed(1), \" to \").concat(clamped.toFixed(1)));\n            }\n            groundDemandGW = clamped;\n        } else {\n            if (true) {\n                console.log(\"[DEMAND DEBUG]   NO CLAMP (within bounds)\");\n            }\n        }\n    } else {\n        if (true) {\n            console.log(\"[DEMAND DEBUG]   NO SMOOTHING (prevDemandState check failed: \".concat(prevDemandState === null ? \"null\" : prevDemandState.groundDemandGW === undefined ? \"undefined\" : \"zero or negative\", \")\"));\n        }\n    }\n    const orbitalDemandGW = effectiveGW - groundDemandGW;\n    return {\n        year,\n        baselineGW,\n        effectiveGW,\n        groundDemandGW,\n        orbitalDemandGW,\n        orbitalShare\n    };\n}\n/**\n * Calculate installed IT load (GW) for a given year\n */ function getITLoadGW(year) {\n    if (year < 2025) {\n        return IT_GW_2025;\n    }\n    if (year <= 2040) {\n        // Phase 1: 2025-2040\n        const yearsFrom2025 = year - 2025;\n        return IT_GW_2025 * Math.exp(R1 * yearsFrom2025);\n    }\n    // Phase 2: 2040-2060\n    const yearsFrom2040 = year - 2040;\n    return IT_GW_2040_TARGET * Math.exp(R2 * yearsFrom2040);\n}\n/**\n * Calculate facility load (GW) = IT load * PUE\n */ function getFacilityLoadGW(year) {\n    let pue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1.3;\n    const itLoadGW = getITLoadGW(year);\n    return itLoadGW * pue;\n}\n/**\n * Calculate new demand (GW) = max(0, Facility_GW(t) - Facility_GW(t-1))\n */ function getDemandNewGW(year) {\n    let pue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1.3;\n    const facilityGW = getFacilityLoadGW(year, pue);\n    const facilityGWPrev = getFacilityLoadGW(year - 1, pue);\n    return Math.max(0, facilityGW - facilityGWPrev);\n}\n/**\n * Legacy function: returns IT load (not facility load)\n * Kept for backward compatibility\n */ function getDemandProjection(year) {\n    return getITLoadGW(year);\n}\nfunction computeTrajectory(options) {\n    // Re-export crossover analysis functions for convenience\n    // Users can import from trajectory.ts or crossoverAnalysis.ts\n    const years = Array.from({\n        length: 26\n    }, (_, i)=>2025 + i); // 2025-2050 (26 years)\n    const trajectory = [];\n    let firstCapYear = null; // Track when constraint cap was first hit\n    // Launch learning: Track cumulative mass to orbit\n    let launchLearningState = null;\n    const BASELINE_MASS_KG = 1000000; // 1M kg baseline for doublings calculation\n    const LAUNCH_COST_0_PER_KG = 1500; // Initial launch cost in 2025\n    // Responsive demand: Track demand state across years for S-curve behavior\n    let prevDemandState = null;\n    let prevYearBreakdown = null;\n    // Buildout state: Track across years for backlog calculation\n    let buildoutState = null;\n    // Mobilization state: Track across years for capacity/backlog evolution\n    let mobilizationState = null;\n    for (const year of years){\n        var _prevYearBreakdown_ground_gpuHourPricing_standard, _prevYearBreakdown_ground_gpuHourPricing, _prevYearBreakdown_ground, _prevYearBreakdown_orbit_gpuHourPricing_standard, _prevYearBreakdown_orbit_gpuHourPricing, _prevYearBreakdown_orbit, _prevYearBreakdown_ground_supplyMetrics, _prevYearBreakdown_ground1, _breakdown_ground, _breakdown_ground1, _breakdown_orbit_constellation, _breakdown_orbit, _breakdown_metadata_chartInputs, _breakdown_metadata, _breakdown_ground2, _breakdown_ground_buildoutDebug, _breakdown_ground3, _breakdown_ground_buildoutDebug1, _breakdown_ground4, _breakdown_ground_supplyMetrics, _breakdown_ground5, _breakdown_ground6, _breakdown_ground_buildoutDebug2, _breakdown_ground7, _breakdown_ground_supplyMetrics1, _breakdown_ground8, _params_orbitMaxDeployableComputeGWByYear, _breakdown_ground9;\n        const params = options.mode === \"STATIC\" ? (0,_modes_static__WEBPACK_IMPORTED_MODULE_2__.getStaticParams)(year) : options.paramsByYear(year);\n        // Apply launch learning if enabled\n        let launchCostPerKg = (0,_physicsCost__WEBPACK_IMPORTED_MODULE_0__.getLaunchCostPerKg)(year, params.launchCostKg);\n        let paramsWithLaunchCost = params;\n        if (options.useLaunchLearning) {\n            // Estimate mass demanded from compute power: ~1000 kg per MW compute\n            // Use targetGW as proxy for orbital compute demand\n            const computePowerMW = params.targetGW * 1000; // Convert GW to MW\n            const massPerMW = 1000; // Rough estimate: 1000 kg per MW\n            const massDemandedKg = computePowerMW * massPerMW;\n            const launchLearningResult = (0,_launch_learning__WEBPACK_IMPORTED_MODULE_1__.stepLaunchLearning)(launchLearningState, {\n                year,\n                massDemandedKg,\n                baselineMassKg: BASELINE_MASS_KG,\n                launchCost0PerKg: LAUNCH_COST_0_PER_KG,\n                learningRate: 0.15,\n                maxFlightsPerYear: 1000,\n                payloadPerFlightKg: 100000\n            });\n            launchCostPerKg = launchLearningResult.launchCostPerKg;\n            launchLearningState = launchLearningResult.state;\n            // Override launch cost in params for this year\n            paramsWithLaunchCost = {\n                ...params,\n                launchCostKg: launchCostPerKg\n            };\n        }\n        var _params_pueGround;\n        // SINGLE SOURCE OF TRUTH: compute demand in GW using RESPONSIVE demand\n        // Demand responds to prices, wait times, and orbital substitution (creates S-curve)\n        // NOTE: We use PREVIOUS year's prices to calculate current year's demand (avoids circular dependency)\n        const groundPue = (_params_pueGround = params.pueGround) !== null && _params_pueGround !== void 0 ? _params_pueGround : 1.3;\n        var _prevYearBreakdown_ground_gpuHourPricing_standard_pricePerGpuHour;\n        // Get prices from previous year (or estimates for first year)\n        const prevGroundPrice = (_prevYearBreakdown_ground_gpuHourPricing_standard_pricePerGpuHour = prevYearBreakdown === null || prevYearBreakdown === void 0 ? void 0 : (_prevYearBreakdown_ground = prevYearBreakdown.ground) === null || _prevYearBreakdown_ground === void 0 ? void 0 : (_prevYearBreakdown_ground_gpuHourPricing = _prevYearBreakdown_ground.gpuHourPricing) === null || _prevYearBreakdown_ground_gpuHourPricing === void 0 ? void 0 : (_prevYearBreakdown_ground_gpuHourPricing_standard = _prevYearBreakdown_ground_gpuHourPricing.standard) === null || _prevYearBreakdown_ground_gpuHourPricing_standard === void 0 ? void 0 : _prevYearBreakdown_ground_gpuHourPricing_standard.pricePerGpuHour) !== null && _prevYearBreakdown_ground_gpuHourPricing_standard_pricePerGpuHour !== void 0 ? _prevYearBreakdown_ground_gpuHourPricing_standard_pricePerGpuHour : 4.00;\n        var _prevYearBreakdown_orbit_gpuHourPricing_standard_pricePerGpuHour;\n        const prevOrbitalPrice = (_prevYearBreakdown_orbit_gpuHourPricing_standard_pricePerGpuHour = prevYearBreakdown === null || prevYearBreakdown === void 0 ? void 0 : (_prevYearBreakdown_orbit = prevYearBreakdown.orbit) === null || _prevYearBreakdown_orbit === void 0 ? void 0 : (_prevYearBreakdown_orbit_gpuHourPricing = _prevYearBreakdown_orbit.gpuHourPricing) === null || _prevYearBreakdown_orbit_gpuHourPricing === void 0 ? void 0 : (_prevYearBreakdown_orbit_gpuHourPricing_standard = _prevYearBreakdown_orbit_gpuHourPricing.standard) === null || _prevYearBreakdown_orbit_gpuHourPricing_standard === void 0 ? void 0 : _prevYearBreakdown_orbit_gpuHourPricing_standard.pricePerGpuHour) !== null && _prevYearBreakdown_orbit_gpuHourPricing_standard_pricePerGpuHour !== void 0 ? _prevYearBreakdown_orbit_gpuHourPricing_standard_pricePerGpuHour : 25.00;\n        var _prevYearBreakdown_ground_supplyMetrics_avgWaitYears;\n        const prevAvgWait = (_prevYearBreakdown_ground_supplyMetrics_avgWaitYears = prevYearBreakdown === null || prevYearBreakdown === void 0 ? void 0 : (_prevYearBreakdown_ground1 = prevYearBreakdown.ground) === null || _prevYearBreakdown_ground1 === void 0 ? void 0 : (_prevYearBreakdown_ground_supplyMetrics = _prevYearBreakdown_ground1.supplyMetrics) === null || _prevYearBreakdown_ground_supplyMetrics === void 0 ? void 0 : _prevYearBreakdown_ground_supplyMetrics.avgWaitYears) !== null && _prevYearBreakdown_ground_supplyMetrics_avgWaitYears !== void 0 ? _prevYearBreakdown_ground_supplyMetrics_avgWaitYears : 0;\n        // Calculate responsive demand (price/wait elastic, orbital substitution)\n        const demandState = calculateResponsiveDemand(year, prevGroundPrice, prevOrbitalPrice, prevAvgWait, prevDemandState);\n        prevDemandState = demandState;\n        // Pass firstCapYear, mobilizationState, and responsive demand to computePhysicsCost\n        // Add mobilization state and responsive demand to params so they can be used for backlog calculation\n        const paramsWithMobilization = {\n            ...paramsWithLaunchCost,\n            prevMobilizationState: mobilizationState,\n            responsiveDemandGW: demandState.groundDemandGW,\n            orbitalSubstitutionGW: demandState.orbitalDemandGW\n        }; // Type assertion needed since YearParams doesn't include these fields\n        const breakdown = (0,_physicsCost__WEBPACK_IMPORTED_MODULE_0__.computePhysicsCost)(paramsWithMobilization, firstCapYear);\n        // Update launch learning state with actual mass from breakdown (for next iteration)\n        if (options.useLaunchLearning && breakdown.orbit && breakdown.orbit.hybridBreakdown) {\n        // Use actual mass from hybrid breakdown if available\n        // Mass is not directly in orbital breakdown, but we can estimate from launch cost\n        // For now, use the mass demanded estimate (will be refined in next iteration)\n        }\n        const constraintBreakdown = breakdown.ground.constraintBreakdown;\n        if (constraintBreakdown && \"capYear\" in constraintBreakdown && constraintBreakdown.capYear !== null && constraintBreakdown.capYear !== undefined) {\n            const thisCapYear = constraintBreakdown.capYear;\n            if (firstCapYear === null || thisCapYear < firstCapYear) {\n                firstCapYear = thisCapYear;\n            }\n        }\n        var _breakdown_ground_pue;\n        // Use responsive ground demand (facility load = ground demand * PUE)\n        const actualGroundPue = (_breakdown_ground_pue = (_breakdown_ground = breakdown.ground) === null || _breakdown_ground === void 0 ? void 0 : _breakdown_ground.pue) !== null && _breakdown_ground_pue !== void 0 ? _breakdown_ground_pue : groundPue;\n        const demandComputeGW = demandState.groundDemandGW * actualGroundPue; // Convert IT load to facility load\n        const orbitalDemandGW = demandState.orbitalDemandGW * actualGroundPue; // For orbital capacity planning\n        // CRITICAL: Ensure ground.buildoutDebug.demandGW matches single source of truth\n        // Override any value from buildout model to ensure consistency\n        if ((_breakdown_ground1 = breakdown.ground) === null || _breakdown_ground1 === void 0 ? void 0 : _breakdown_ground1.buildoutDebug) {\n            breakdown.ground.buildoutDebug.demandGW = demandComputeGW;\n        }\n        // Use demandComputeGW for all market calculations (single source of truth)\n        const totalDemandGW = demandComputeGW;\n        const orbitalFeasible = breakdown.orbit && breakdown.orbit.totalCostPerPflopYear > 0 && breakdown.orbit.totalCostPerPflopYear < Infinity;\n        const groundFeasible = breakdown.ground && breakdown.ground.totalCostPerPflopYear > 0 && breakdown.ground.totalCostPerPflopYear < Infinity;\n        const orbitalCostAccountingValid = breakdown.costAccountingValid !== false;\n        const groundCostAccountingValid = breakdown.costAccountingValid !== false;\n        // Calculate orbital capacity GW from constellation: (numSatellites * computePerSatKw) / 1e6\n        // kW -> GW conversion: divide by 1,000,000 (1e6)\n        // CRITICAL: computePerSatKw is in kW, so divide by 1e6 to get GW (not 1e3 for MW)\n        let orbitalCapacityGW_fromSats = 0;\n        if ((_breakdown_orbit = breakdown.orbit) === null || _breakdown_orbit === void 0 ? void 0 : (_breakdown_orbit_constellation = _breakdown_orbit.constellation) === null || _breakdown_orbit_constellation === void 0 ? void 0 : _breakdown_orbit_constellation.design) {\n            const { numSatellites, computePerSatKw } = breakdown.orbit.constellation.design;\n            // kW -> GW: divide by 1,000,000 (1e6), NOT 1,000 (1e3)\n            orbitalCapacityGW_fromSats = numSatellites * computePerSatKw / 1000000;\n            // Invariant: 1 satellite at 111 kW should be 0.000111 GW, not 1.144 GW\n            if ( true && numSatellites === 1) {\n                const expectedGW = computePerSatKw / 1000000;\n                const error = Math.abs(orbitalCapacityGW_fromSats - expectedGW) / Math.max(expectedGW, 1e-9);\n                if (error > 0.01) {\n                    throw new Error(\"[ORBITAL CAPACITY BUG] Year \".concat(year, \": 1 satellite at \").concat(computePerSatKw, \" kW should be \").concat(expectedGW, \" GW, \") + \"but got \".concat(orbitalCapacityGW_fromSats, \" GW. Check kW->GW conversion (must divide by 1e6, not 1e3).\"));\n                }\n            }\n        }\n        const chartPB = (_breakdown_metadata = breakdown.metadata) === null || _breakdown_metadata === void 0 ? void 0 : (_breakdown_metadata_chartInputs = _breakdown_metadata.chartInputs) === null || _breakdown_metadata_chartInputs === void 0 ? void 0 : _breakdown_metadata_chartInputs.powerBuildout;\n        const chartBacklog = chartPB === null || chartPB === void 0 ? void 0 : chartPB.backlogGw;\n        const chartAvgWait = chartPB === null || chartPB === void 0 ? void 0 : chartPB.avgWaitYears;\n        const chartBuildRate = chartPB === null || chartPB === void 0 ? void 0 : chartPB.maxBuildRateGwYear;\n        // Prefer buildoutDebug when present.\n        // If ground/backlog fields exist but are 0 while chartInputs says >0, use chartInputs.\n        // Remove the pipelineGw proxy entirely (it's not backlog and causes silent unit/meaning corruption).\n        const backlogFromGround = (_breakdown_ground2 = breakdown.ground) === null || _breakdown_ground2 === void 0 ? void 0 : _breakdown_ground2.backlogGw;\n        const backlogFromBuildout = (_breakdown_ground3 = breakdown.ground) === null || _breakdown_ground3 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug = _breakdown_ground3.buildoutDebug) === null || _breakdown_ground_buildoutDebug === void 0 ? void 0 : _breakdown_ground_buildoutDebug.backlogGW;\n        var _ref, _ref1;\n        let backlogGW = (_ref1 = (_ref = backlogFromBuildout !== undefined ? backlogFromBuildout : undefined) !== null && _ref !== void 0 ? _ref : backlogFromGround !== undefined && backlogFromGround > 0 ? backlogFromGround : undefined) !== null && _ref1 !== void 0 ? _ref1 : chartBacklog !== undefined && chartBacklog > 0 ? chartBacklog : 0;\n        const buildRateFromBuildout = (_breakdown_ground4 = breakdown.ground) === null || _breakdown_ground4 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug1 = _breakdown_ground4.buildoutDebug) === null || _breakdown_ground_buildoutDebug1 === void 0 ? void 0 : _breakdown_ground_buildoutDebug1.buildRateGWyr;\n        const buildRateFromSupply = (_breakdown_ground5 = breakdown.ground) === null || _breakdown_ground5 === void 0 ? void 0 : (_breakdown_ground_supplyMetrics = _breakdown_ground5.supplyMetrics) === null || _breakdown_ground_supplyMetrics === void 0 ? void 0 : _breakdown_ground_supplyMetrics.maxBuildRateGwYear;\n        var _ref2, _ref3;\n        const buildRateGWyr = (_ref3 = (_ref2 = buildRateFromBuildout !== undefined ? buildRateFromBuildout : undefined) !== null && _ref2 !== void 0 ? _ref2 : buildRateFromSupply !== undefined ? buildRateFromSupply : undefined) !== null && _ref3 !== void 0 ? _ref3 : chartBuildRate !== undefined ? chartBuildRate : 0;\n        const avgWaitFromGround = (_breakdown_ground6 = breakdown.ground) === null || _breakdown_ground6 === void 0 ? void 0 : _breakdown_ground6.avgWaitYears;\n        const avgWaitFromBuildout = (_breakdown_ground7 = breakdown.ground) === null || _breakdown_ground7 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug2 = _breakdown_ground7.buildoutDebug) === null || _breakdown_ground_buildoutDebug2 === void 0 ? void 0 : _breakdown_ground_buildoutDebug2.timeToPowerYears;\n        const avgWaitFromSupply = (_breakdown_ground8 = breakdown.ground) === null || _breakdown_ground8 === void 0 ? void 0 : (_breakdown_ground_supplyMetrics1 = _breakdown_ground8.supplyMetrics) === null || _breakdown_ground_supplyMetrics1 === void 0 ? void 0 : _breakdown_ground_supplyMetrics1.avgWaitYears;\n        var _ref4, _ref5, _ref6;\n        let avgWaitYears = (_ref6 = (_ref5 = (_ref4 = avgWaitFromBuildout !== undefined ? avgWaitFromBuildout : undefined) !== null && _ref4 !== void 0 ? _ref4 : avgWaitFromGround !== undefined && avgWaitFromGround > 0 ? avgWaitFromGround : undefined) !== null && _ref5 !== void 0 ? _ref5 : avgWaitFromSupply !== undefined && avgWaitFromSupply > 0 ? avgWaitFromSupply : undefined) !== null && _ref6 !== void 0 ? _ref6 : chartAvgWait !== undefined && chartAvgWait > 0 ? chartAvgWait : 0;\n        // Self-heal plumbing mismatches: if chartInputs has positive value but chosen is 0, use chartInputs\n        // Log structured error but never throw (prevents chart from disappearing)\n        if ((chartBacklog !== null && chartBacklog !== void 0 ? chartBacklog : 0) > 0 && backlogGW === 0 && chartBacklog !== undefined) {\n            backlogGW = chartBacklog;\n            if (true) {\n                var _breakdown_ground10, _breakdown_ground_buildoutDebug3, _breakdown_ground11, _breakdown_ground_supplyMetrics2, _breakdown_ground12;\n                console.error(\"[BACKLOG PLUMBING] Year \".concat(year, \": chartInputs.backlogGw=\").concat(chartBacklog, \" but fallback chain returned 0. \") + \"Self-healed: using chartInputs. \" + \"Candidates: ground.backlogGw=\".concat((_breakdown_ground10 = breakdown.ground) === null || _breakdown_ground10 === void 0 ? void 0 : _breakdown_ground10.backlogGw, \", \") + \"buildoutDebug.backlogGW=\".concat((_breakdown_ground11 = breakdown.ground) === null || _breakdown_ground11 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug3 = _breakdown_ground11.buildoutDebug) === null || _breakdown_ground_buildoutDebug3 === void 0 ? void 0 : _breakdown_ground_buildoutDebug3.backlogGW, \", \") + \"supplyMetrics.pipelineGw=\".concat((_breakdown_ground12 = breakdown.ground) === null || _breakdown_ground12 === void 0 ? void 0 : (_breakdown_ground_supplyMetrics2 = _breakdown_ground12.supplyMetrics) === null || _breakdown_ground_supplyMetrics2 === void 0 ? void 0 : _breakdown_ground_supplyMetrics2.pipelineGw));\n            }\n        }\n        if ((chartAvgWait !== null && chartAvgWait !== void 0 ? chartAvgWait : 0) > 0 && avgWaitYears === 0 && chartAvgWait !== undefined) {\n            avgWaitYears = chartAvgWait;\n            if (true) {\n                var _breakdown_ground13, _breakdown_ground_buildoutDebug4, _breakdown_ground14, _breakdown_ground_supplyMetrics3, _breakdown_ground15;\n                console.error(\"[WAIT PLUMBING] Year \".concat(year, \": chartInputs.avgWaitYears=\").concat(chartAvgWait, \" but fallback chain returned 0. \") + \"Self-healed: using chartInputs. \" + \"Candidates: ground.avgWaitYears=\".concat((_breakdown_ground13 = breakdown.ground) === null || _breakdown_ground13 === void 0 ? void 0 : _breakdown_ground13.avgWaitYears, \", \") + \"buildoutDebug.timeToPowerYears=\".concat((_breakdown_ground14 = breakdown.ground) === null || _breakdown_ground14 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug4 = _breakdown_ground14.buildoutDebug) === null || _breakdown_ground_buildoutDebug4 === void 0 ? void 0 : _breakdown_ground_buildoutDebug4.timeToPowerYears, \", \") + \"supplyMetrics.avgWaitYears=\".concat((_breakdown_ground15 = breakdown.ground) === null || _breakdown_ground15 === void 0 ? void 0 : (_breakdown_ground_supplyMetrics3 = _breakdown_ground15.supplyMetrics) === null || _breakdown_ground_supplyMetrics3 === void 0 ? void 0 : _breakdown_ground_supplyMetrics3.avgWaitYears));\n            }\n        }\n        var _params_orbitMaxDeployableComputeGWByYear1;\n        // Calculate orbitMaxDeployableComputeGW from constellation capacity or scenario params\n        // Canonical orbital capacity from constellation: (numSatellites * computePerSatKw) / 1e6\n        const orbitMaxDeployableComputeGW = orbitalFeasible ? (_params_orbitMaxDeployableComputeGWByYear1 = (_params_orbitMaxDeployableComputeGWByYear = params.orbitMaxDeployableComputeGWByYear) === null || _params_orbitMaxDeployableComputeGWByYear === void 0 ? void 0 : _params_orbitMaxDeployableComputeGWByYear.call(params, year)) !== null && _params_orbitMaxDeployableComputeGWByYear1 !== void 0 ? _params_orbitMaxDeployableComputeGWByYear1 : orbitalCapacityGW_fromSats : 0;\n        // Fix orbit feasibility gating: use orbitMaxDeployableComputeGW, not orbitalCapacityGW placeholder\n        const orbitalFeasibleForShare = orbitalFeasible && orbitMaxDeployableComputeGW > 0;\n        const marketAnalysis = calculateMarketShare(year, breakdown.orbit.totalCostPerPflopYear, breakdown.ground.totalCostPerPflopYear, totalDemandGW, orbitalFeasibleForShare, groundFeasible, orbitalCostAccountingValid, groundCostAccountingValid, demandComputeGW, backlogGW, buildRateGWyr, avgWaitYears, orbitMaxDeployableComputeGW);\n        breakdown.market = {\n            totalDemandGW: demandComputeGW,\n            orbitalShareFrac: marketAnalysis.orbitalShareFrac,\n            orbitalCapacityGW: marketAnalysis.orbitalCapacityGW,\n            orbitalRevenue: marketAnalysis.orbitalRevenue,\n            groundShareFrac: marketAnalysis.groundShareFrac,\n            groundCapacityGW: marketAnalysis.groundCapacityGW,\n            debug: {\n                ...marketAnalysis.debug,\n                demandComputeGW: demandComputeGW,\n                orbitalCapacityGW_fromSats: orbitalCapacityGW_fromSats\n            }\n        };\n        // Invariant: demand scalar consistency\n        if ( true && breakdown.market) {\n            var _breakdown_market_debug, _breakdown_ground_buildoutDebug5, _breakdown_ground16;\n            const marketDemand = breakdown.market.totalDemandGW;\n            const marketDebugDemand = (_breakdown_market_debug = breakdown.market.debug) === null || _breakdown_market_debug === void 0 ? void 0 : _breakdown_market_debug.demandComputeGW;\n            const buildoutDemand = (_breakdown_ground16 = breakdown.ground) === null || _breakdown_ground16 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug5 = _breakdown_ground16.buildoutDebug) === null || _breakdown_ground_buildoutDebug5 === void 0 ? void 0 : _breakdown_ground_buildoutDebug5.demandGW;\n            if (marketDebugDemand !== undefined && Math.abs(marketDemand - marketDebugDemand) > 1e-6) {\n                throw new Error(\"[DEMAND SCALAR BUG] Year \".concat(year, \": market.totalDemandGW=\").concat(marketDemand, \" != \") + \"market.debug.demandComputeGW=\".concat(marketDebugDemand, \". Must be equal.\"));\n            }\n            if (buildoutDemand !== undefined && Math.abs(marketDemand - buildoutDemand) > 1e-6) {\n                throw new Error(\"[DEMAND SCALAR BUG] Year \".concat(year, \": market.totalDemandGW=\").concat(marketDemand, \" != \") + \"ground.buildoutDebug.demandGW=\".concat(buildoutDemand, \". Must be equal.\"));\n            }\n        }\n        // Update mobilization state for next year (use extracted values, not breakdown.ground which might be 0)\n        if ((_breakdown_ground9 = breakdown.ground) === null || _breakdown_ground9 === void 0 ? void 0 : _breakdown_ground9.buildoutDebug) {\n            const buildoutDebug = breakdown.ground.buildoutDebug;\n            var _buildoutDebug_demandGW, _buildoutDebug_buildRateGWyr, _buildoutDebug_capacityGW, _buildoutDebug_pipelineGW;\n            mobilizationState = {\n                year,\n                demandGW: (_buildoutDebug_demandGW = buildoutDebug.demandGW) !== null && _buildoutDebug_demandGW !== void 0 ? _buildoutDebug_demandGW : 0,\n                demandNewGW: buildoutDebug.demandNewGW,\n                buildRateGWyr: (_buildoutDebug_buildRateGWyr = buildoutDebug.buildRateGWyr) !== null && _buildoutDebug_buildRateGWyr !== void 0 ? _buildoutDebug_buildRateGWyr : buildRateGWyr,\n                capacityGW: (_buildoutDebug_capacityGW = buildoutDebug.capacityGW) !== null && _buildoutDebug_capacityGW !== void 0 ? _buildoutDebug_capacityGW : 0,\n                pipelineGW: (_buildoutDebug_pipelineGW = buildoutDebug.pipelineGW) !== null && _buildoutDebug_pipelineGW !== void 0 ? _buildoutDebug_pipelineGW : 0,\n                backlogGW: backlogGW,\n                avgWaitYears: avgWaitYears\n            };\n        }\n        trajectory.push(breakdown);\n        // Update previous year breakdown for next iteration (for responsive demand calculation)\n        prevYearBreakdown = breakdown;\n    }\n    return trajectory;\n}\nfunction generateFinalAnalysis(options, baseTrajectory) {\n    var _baseTrajectory__crossoverDetails;\n    const baseCrossover = findCrossoverYear(baseTrajectory);\n    const baseCrossoverEffectivePflop = findCrossoverYearEffectivePflop(baseTrajectory);\n    const baseParams = options.paramsByYear(2025);\n    // 1. Sensitivity Analysis\n    const parametersToTest = [\n        {\n            key: \"launchCostKg\",\n            name: \"Launch Cost (2035)\",\n            values: [\n                50,\n                100,\n                150,\n                200,\n                300\n            ],\n            yearToModify: 2035\n        },\n        {\n            key: \"gpuFailureRate\",\n            name: \"GPU Failure Rate\",\n            values: [\n                0.05,\n                0.10,\n                0.15,\n                0.20,\n                0.25\n            ],\n            yearToModify: null\n        },\n        {\n            key: \"hardwareLearningRate\",\n            name: \"Hardware Learning Rate\",\n            values: [\n                0.08,\n                0.10,\n                0.12,\n                0.15\n            ],\n            yearToModify: null\n        }\n    ];\n    const sensitivities = parametersToTest.map((p)=>{\n        const crossoverYears = p.values.map((val)=>{\n            const testTrajectory = computeTrajectory({\n                ...options,\n                paramsByYear: (y)=>{\n                    const params = options.paramsByYear(y);\n                    if (p.yearToModify && y === p.yearToModify) {\n                        return {\n                            ...params,\n                            [p.key]: val\n                        };\n                    } else if (!p.yearToModify) {\n                        return {\n                            ...params,\n                            [p.key]: val\n                        };\n                    }\n                    return params;\n                }\n            });\n            return findCrossoverYear(testTrajectory);\n        });\n        const validYears = crossoverYears.filter((y)=>y !== null);\n        const maxDelta = validYears.length > 1 ? Math.max(...validYears) - Math.min(...validYears) : 0;\n        const impact = maxDelta >= 4 ? \"high\" : maxDelta >= 2 ? \"medium\" : \"low\";\n        return {\n            parameter: p.name,\n            baseValue: baseParams[p.key] || 0,\n            testValues: p.values,\n            crossoverYears,\n            impact: impact\n        };\n    });\n    // 2. Scenario Benchmarks\n    const scenarios = [\n        {\n            name: \"Bull Case\",\n            description: \"Mature Starship, commercial chips, severe ground constraints\",\n            keyAssumptions: [\n                \"Launch $75/kg by 2035\",\n                \"Commercial chips\",\n                \"Severe ground constraints\"\n            ],\n            crossoverYear: findCrossoverYear(computeTrajectory({\n                ...options,\n                paramsByYear: (y)=>({\n                        ...options.paramsByYear(y),\n                        launchCostKg: (0,_physicsCost__WEBPACK_IMPORTED_MODULE_0__.getLaunchCostPerKg)(y, 1500),\n                        useRadHardChips: false,\n                        groundScenario: \"severe\"\n                    })\n            }))\n        },\n        {\n            name: \"Base Case\",\n            description: \"Current model assumptions (Rad-tolerant baseline)\",\n            keyAssumptions: [\n                \"Launch $75/kg by 2035\",\n                \"Rad-tolerant chips\",\n                \"Standard ground constraints\"\n            ],\n            crossoverYear: baseCrossover\n        },\n        {\n            name: \"Bear Case\",\n            description: \"Rad-hard required, SMRs solve ground power\",\n            keyAssumptions: [\n                \"Launch $300/kg by 2035\",\n                \"Rad-hard chips\",\n                \"Unconstrained ground\"\n            ],\n            crossoverYear: findCrossoverYear(computeTrajectory({\n                ...options,\n                paramsByYear: (y)=>({\n                        ...options.paramsByYear(y),\n                        launchCostKg: projectMarketPrice(1500, 2025, y, 0.10),\n                        useRadHardChips: true,\n                        groundScenario: \"unconstrained\"\n                    })\n            }))\n        }\n    ];\n    // 3. Market Comparison\n    const marketComparison = MARKET_PROVIDERS.map((p)=>{\n        var _baseTrajectory_find;\n        const projectedPrices = [];\n        for(let y = 2025; y <= 2050; y++){\n            projectedPrices.push({\n                year: y,\n                price: projectMarketPrice(p.price, 2024, y, p.decline)\n            });\n        }\n        const orbitalBeatsYear = ((_baseTrajectory_find = baseTrajectory.find((d)=>{\n            const projected = projectMarketPrice(p.price, 2024, d.year, p.decline);\n            return d.orbit.gpuHourPricing.standard.pricePerGpuHour < projected;\n        })) === null || _baseTrajectory_find === void 0 ? void 0 : _baseTrajectory_find.year) || null;\n        return {\n            provider: p.name,\n            currentPrice: p.price,\n            currentYear: 2024,\n            projectedDecline: p.decline,\n            projectedPrices,\n            orbitalBeatsYear\n        };\n    });\n    // 4. Ground Scenario Label\n    const selectedScenario = _physicsCost__WEBPACK_IMPORTED_MODULE_0__.GROUND_SCENARIOS[baseParams.groundScenario];\n    const groundScenarioLabel = {\n        name: selectedScenario.name,\n        description: selectedScenario.description,\n        constraintMultiplier2040: 1.0,\n        assumptions: [\n            \"Grid growth: \".concat((selectedScenario.gridGrowthRate * 100).toFixed(1), \"%/year\"),\n            \"Cooling growth: \".concat((selectedScenario.coolingGrowthRate * 100).toFixed(1), \"%/year\"),\n            selectedScenario.constraintCap ? \"Constraint cap: \".concat(selectedScenario.constraintCap, \"x\") : \"No constraint cap\"\n        ]\n    };\n    // 5. Validation Checks\n    const lastYear = baseTrajectory[baseTrajectory.length - 1];\n    const firstYear = baseTrajectory[0];\n    const allChecks = [\n        {\n            name: \"Cost breakdown sums to total\",\n            passed: !!lastYear.costAccountingValid,\n            value: lastYear.costAccountingErrorPct,\n            expected: \"<0.5%\"\n        },\n        {\n            name: \"Capacity factor in range\",\n            passed: firstYear.orbit.capacityFactor > 0.90,\n            value: firstYear.orbit.capacityFactor,\n            expected: \"0.90-1.0\"\n        },\n        {\n            name: \"Crossover year matches trajectory\",\n            passed: true,\n            value: baseCrossover\n        }\n    ];\n    const validation = {\n        costAccountingValid: !!lastYear.costAccountingValid,\n        costAccountingError: lastYear.costAccountingErrorPct || 0,\n        trajectoryMonotonic: true,\n        parametersInRange: true,\n        crossoverConsistent: true,\n        allChecks\n    };\n    const crossoverYearStandard = baseCrossover;\n    const priceAtCrossoverOrbital = baseCrossover ? baseTrajectory[baseCrossover - 2025].orbit.gpuHourPricing.standard.pricePerGpuHour : 0;\n    const priceAtCrossoverGround = baseCrossover ? baseTrajectory[baseCrossover - 2025].ground.gpuHourPricing.standard.pricePerGpuHour : 0;\n    const activeToggles = [];\n    if (baseParams.elonScenarioEnabled) activeToggles.push(\"Elon Scenario\");\n    if (baseParams.globalLatencyRequirementEnabled) activeToggles.push(\"Global Latency\");\n    if (baseParams.spaceManufacturingEnabled) activeToggles.push(\"Space Mfg\");\n    if (baseParams.aiWinterEnabled) activeToggles.push(\"AI Winter\");\n    // Baseline crossover (no toggles)\n    const baselineTrajectory = computeTrajectory({\n        ...options,\n        paramsByYear: (y)=>({\n                ...options.paramsByYear(y),\n                elonScenarioEnabled: false,\n                globalLatencyRequirementEnabled: false,\n                spaceManufacturingEnabled: false,\n                aiWinterEnabled: false\n            })\n    });\n    const baselineCrossover = findCrossoverYear(baselineTrajectory);\n    const scenarioImpact = {\n        baselineCrossover,\n        currentCrossover: baseCrossover,\n        activeToggles,\n        crossoverDelta: (baselineCrossover || 2040) - (baseCrossover || 2040)\n    };\n    // Monte Carlo Analysis (run once, cached per parameter set)\n    // Extract base parameters for Monte Carlo\n    const baseParamsForMC = (0,_monteCarloCrossover__WEBPACK_IMPORTED_MODULE_3__.extractBaseParams)(options.paramsByYear);\n    // Run Monte Carlo analysis (200 samples by default)\n    // This is computationally expensive, so we only do it once per analysis\n    const monteCarloResult = (0,_monteCarloCrossover__WEBPACK_IMPORTED_MODULE_3__.runMonteCarloCrossover)(options.paramsByYear, baseParamsForMC, 200 // numSamples\n    );\n    return {\n        metadata: {\n            version: \"4.3.0\",\n            generatedAt: new Date().toISOString(),\n            units: []\n        },\n        parameters: baseParams,\n        trajectory: baseTrajectory,\n        analysis: {\n            crossover: {\n                year: baseCrossover,\n                orbitalPrice: priceAtCrossoverOrbital,\n                groundPrice: priceAtCrossoverGround,\n                marketPosition: ((_baseTrajectory__crossoverDetails = baseTrajectory[baseTrajectory.length - 1].crossoverDetails) === null || _baseTrajectory__crossoverDetails === void 0 ? void 0 : _baseTrajectory__crossoverDetails.marketPosition) || \"\"\n            },\n            sensitivity: {\n                baseCase: {\n                    crossoverYear: baseCrossover || 2040,\n                    orbitalPriceAtCrossover: priceAtCrossoverOrbital,\n                    groundPriceAtCrossover: priceAtCrossoverGround\n                },\n                sensitivities\n            },\n            scenarios,\n            confidence: {\n                crossoverYear: {\n                    p10: monteCarloResult.p10,\n                    p50: monteCarloResult.p50,\n                    p90: monteCarloResult.p90\n                },\n                priceAtCrossover: {\n                    low: scenarios[0].crossoverYear ? baseTrajectory[scenarios[0].crossoverYear - 2025].orbit.gpuHourPricing.standard.pricePerGpuHour : 0,\n                    mid: scenarios[1].crossoverYear ? baseTrajectory[scenarios[1].crossoverYear - 2025].orbit.gpuHourPricing.standard.pricePerGpuHour : 0,\n                    high: scenarios[2].crossoverYear ? baseTrajectory[scenarios[2].crossoverYear - 2025].orbit.gpuHourPricing.standard.pricePerGpuHour : 0\n                },\n                probabilityByYear: monteCarloResult.probabilityByYear\n            },\n            marketComparison,\n            regulatoryImpact: 1500,\n            scenarioImpact\n        },\n        validation,\n        groundScenario: groundScenarioLabel\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvdHJhamVjdG9yeS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ3lGO0FBQ2I7QUFDM0I7QUFDbUQ7QUFXcEc7OztDQUdDLEdBQ00sU0FBU08sa0JBQWtCQyxVQUE2QjtJQUM3RCxNQUFNQyxXQUFXRCxXQUFXRSxJQUFJLENBQUNDLENBQUFBO1lBSTNCQSx1QkFDQUE7WUFId0JBO1FBRDVCLGlGQUFpRjtRQUNqRixNQUFNQyxzQkFBc0JELENBQUFBLDJDQUFBQSxFQUFFRSxNQUFNLENBQUNDLDhCQUE4QixjQUF2Q0gsc0RBQUFBLDJDQUN6QkEsRUFBRUUsTUFBTSxDQUFDRSxxQkFBcUIsR0FDN0JKLENBQUFBLEVBQUFBLHdCQUFBQSxFQUFFRSxNQUFNLENBQUNHLFdBQVcsY0FBcEJMLDRDQUFBQSxzQkFBc0JNLFlBQVksS0FBSSxLQUN0Q04sQ0FBQUEsRUFBQUEseUJBQUFBLEVBQUVFLE1BQU0sQ0FBQ0csV0FBVyxjQUFwQkwsNkNBQUFBLHVCQUFzQk8sd0JBQXdCLEtBQUk7WUFFcENQO1FBQWxCLE1BQU1RLFlBQVlSLENBQUFBLDBDQUFBQSxFQUFFUyxLQUFLLENBQUNOLDhCQUE4QixjQUF0Q0gscURBQUFBLDBDQUEwQ0EsRUFBRVMsS0FBSyxDQUFDTCxxQkFBcUI7UUFFekYsT0FBT00sT0FBT0MsUUFBUSxDQUFDSCxjQUFjRSxPQUFPQyxRQUFRLENBQUNWLHdCQUM5QyxZQUF5QkE7SUFDbEM7SUFDQSxPQUFPSCxXQUFXQSxTQUFTYyxJQUFJLEdBQUc7QUFDcEM7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0MsZ0NBQWdDaEIsVUFBNkI7SUFDM0UsTUFBTUMsV0FBV0QsV0FBV0UsSUFBSSxDQUFDQyxDQUFBQTtZQUkzQkEsdUJBQ0FBO1lBSHdCQTtRQUQ1QixxRUFBcUU7UUFDckUsTUFBTUMsc0JBQXNCRCxDQUFBQSwyQ0FBQUEsRUFBRUUsTUFBTSxDQUFDQyw4QkFBOEIsY0FBdkNI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WUFDRjtZQUNBYztZQUNBaUUsWUFBWTtnQkFDVjlELGVBQWU7b0JBQ2IrRCxLQUFLbEIsaUJBQWlCa0IsR0FBRztvQkFDekJDLEtBQUtuQixpQkFBaUJtQixHQUFHO29CQUN6QkMsS0FBS3BCLGlCQUFpQm9CLEdBQUc7Z0JBQzNCO2dCQUNBQyxrQkFBa0I7b0JBQ2hCQyxLQUFLdEUsU0FBUyxDQUFDLEVBQUUsQ0FBQ0csYUFBYSxHQUFHekIsY0FBYyxDQUFDc0IsU0FBUyxDQUFDLEVBQUUsQ0FBQ0csYUFBYSxHQUFHLEtBQUssQ0FBQ3BQLEtBQUssQ0FBQ21LLGNBQWMsQ0FBQ0MsUUFBUSxDQUFDQyxlQUFlLEdBQUc7b0JBQ3BJbUosS0FBS3ZFLFNBQVMsQ0FBQyxFQUFFLENBQUNHLGFBQWEsR0FBR3pCLGNBQWMsQ0FBQ3NCLFNBQVMsQ0FBQyxFQUFFLENBQUNHLGFBQWEsR0FBRyxLQUFLLENBQUNwUCxLQUFLLENBQUNtSyxjQUFjLENBQUNDLFFBQVEsQ0FBQ0MsZUFBZSxHQUFHO29CQUNwSW9KLE1BQU14RSxTQUFTLENBQUMsRUFBRSxDQUFDRyxhQUFhLEdBQUd6QixjQUFjLENBQUNzQixTQUFTLENBQUMsRUFBRSxDQUFDRyxhQUFhLEdBQUcsS0FBSyxDQUFDcFAsS0FBSyxDQUFDbUssY0FBYyxDQUFDQyxRQUFRLENBQUNDLGVBQWUsR0FBRztnQkFDdkk7Z0JBQ0FxSixtQkFBbUJ6QixpQkFBaUJ5QixpQkFBaUI7WUFDdkQ7WUFDQW5FO1lBQ0FvRSxrQkFBa0I7WUFDbEI5QjtRQUNGO1FBQ0FmO1FBQ0F4QixnQkFBZ0JVO0lBQ2xCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9tb2RlbC90cmFqZWN0b3J5LnRzPzNhYzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgWWVhclBhcmFtcywgWWVhcmx5QnJlYWtkb3duLCBTZW5zaXRpdml0eUFuYWx5c2lzLCBGaW5hbE1vZGVsT3V0cHV0LCBNYXJrZXRQcm9qZWN0aW9uLCBWYWxpZGF0aW9uQ2hlY2tzLCBHcm91bmRTY2VuYXJpb0xhYmVsIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBjb21wdXRlUGh5c2ljc0Nvc3QsIEdST1VORF9TQ0VOQVJJT1MsIGdldExhdW5jaENvc3RQZXJLZyB9IGZyb20gJy4vcGh5c2ljc0Nvc3QnO1xuaW1wb3J0IHsgc3RlcExhdW5jaExlYXJuaW5nLCBMYXVuY2hMZWFybmluZ1N0YXRlIH0gZnJvbSAnLi9sYXVuY2hfbGVhcm5pbmcnO1xuaW1wb3J0IHsgZ2V0U3RhdGljUGFyYW1zIH0gZnJvbSAnLi9tb2Rlcy9zdGF0aWMnO1xuaW1wb3J0IHsgcnVuTW9udGVDYXJsb0Nyb3Nzb3ZlciwgZXh0cmFjdEJhc2VQYXJhbXMsIE1vbnRlQ2FybG9SZXN1bHQgfSBmcm9tICcuL21vbnRlQ2FybG9Dcm9zc292ZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYWplY3RvcnlPcHRpb25zIHtcbiAgbW9kZTogJ0RZTkFNSUMnIHwgJ1NUQVRJQyc7XG4gIHNwYWNlVHJhZmZpY0VuYWJsZWQ/OiBib29sZWFuO1xuICB1c2VMYXVuY2hMZWFybmluZz86IGJvb2xlYW47IC8vIEVuYWJsZSBjdW11bGF0aXZlIG1hc3MtYmFzZWQgbGF1bmNoIGxlYXJuaW5nXG4gIFxuICAvLyBEeW5hbWljIHBhcmFtZXRlcnMgKHBhc3NlZCBhcyBmdW5jdGlvbnMgb2YgeWVhciBvciByYXcgdmFsdWVzKVxuICBwYXJhbXNCeVllYXI6ICh5ZWFyOiBudW1iZXIpID0+IFllYXJQYXJhbXM7XG59XG5cbi8qKlxuICogRmluZCBjcm9zc292ZXIgeWVhciB1c2luZyBHUFUtaG91ciBwcmljaW5nIChwcmVmZXJyZWQsIGluY2x1ZGVzIHNjYXJjaXR5KVxuICogVXNlcyBzY2FyY2l0eS1pbmNsdXNpdmUgY29tcGFyYXRvciBjb25zaXN0ZW50bHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRDcm9zc292ZXJZZWFyKHRyYWplY3Rvcnk6IFllYXJseUJyZWFrZG93bltdKTogbnVtYmVyIHwgbnVsbCB7XG4gIGNvbnN0IGNyb3NzaW5nID0gdHJhamVjdG9yeS5maW5kKGQgPT4ge1xuICAgIC8vIFVzZSBlZmZlY3RpdmUgZ3JvdW5kIGNvc3QgKGluY2x1ZGVzIGRlbGF5UGVuYWx0eSArIHNjYXJjaXR5UmVudCkgZm9yIGNyb3Nzb3ZlclxuICAgIGNvbnN0IGdyb3VuZEVmZmVjdGl2ZUNvc3QgPSBkLmdyb3VuZC50b3RhbENvc3RQZXJQZmxvcFllYXJFZmZlY3RpdmUgPz8gXG4gICAgICAoZC5ncm91bmQudG90YWxDb3N0UGVyUGZsb3BZZWFyICsgXG4gICAgICAgKGQuZ3JvdW5kLmNvbnN0cmFpbnRzPy5kZWxheVBlbmFsdHkgfHwgMCkgK1xuICAgICAgIChkLmdyb3VuZC5jb25zdHJhaW50cz8uc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyIHx8IDApKTtcbiAgICBcbiAgICBjb25zdCBvcmJpdENvc3QgPSBkLm9yYml0LnRvdGFsQ29zdFBlclBmbG9wWWVhckVmZmVjdGl2ZSA/PyBkLm9yYml0LnRvdGFsQ29zdFBlclBmbG9wWWVhcjtcbiAgICBcbiAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG9yYml0Q29zdCkgJiYgTnVtYmVyLmlzRmluaXRlKGdyb3VuZEVmZmVjdGl2ZUNvc3QpICYmIFxuICAgICAgICAgICAob3JiaXRDb3N0IGFzIG51bWJlcikgPCAoZ3JvdW5kRWZmZWN0aXZlQ29zdCBhcyBudW1iZXIpO1xuICB9KTtcbiAgcmV0dXJuIGNyb3NzaW5nID8gY3Jvc3NpbmcueWVhciA6IG51bGw7XG59XG5cbi8qKlxuICogRmluZCBjcm9zc292ZXIgeWVhciB1c2luZyBlZmZlY3RpdmUgUEZMT1AteWVhciBjb3N0IChpbmNsdWRlcyBzY2FyY2l0eSBhZGRlcnMpXG4gKiBVc2VzIHNjYXJjaXR5LWluY2x1c2l2ZSBjb21wYXJhdG9yOiBkZWxheVBlbmFsdHkgKyBzY2FyY2l0eVJlbnRcbiAqIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtIGlzIGVuZ2luZWVyaW5nIGNvc3QsIG5vdCBzY2FyY2l0eSBwcmljaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQ3Jvc3NvdmVyWWVhckVmZmVjdGl2ZVBmbG9wKHRyYWplY3Rvcnk6IFllYXJseUJyZWFrZG93bltdKTogbnVtYmVyIHwgbnVsbCB7XG4gIGNvbnN0IGNyb3NzaW5nID0gdHJhamVjdG9yeS5maW5kKGQgPT4ge1xuICAgIC8vIEdyb3VuZCBlZmZlY3RpdmUgY29zdCBpbmNsdWRlczogYmFzZSArIGRlbGF5UGVuYWx0eSArIHNjYXJjaXR5UmVudFxuICAgIGNvbnN0IGdyb3VuZEVmZmVjdGl2ZUNvc3QgPSBkLmdyb3VuZC50b3RhbENvc3RQZXJQZmxvcFllYXJFZmZlY3RpdmUgPz8gXG4gICAgICAoZC5ncm91bmQudG90YWxDb3N0UGVyUGZsb3BZZWFyICsgXG4gICAgICAgKGQuZ3JvdW5kLmNvbnN0cmFpbnRzPy5kZWxheVBlbmFsdHkgfHwgMCkgK1xuICAgICAgIChkLmdyb3VuZC5jb25zdHJhaW50cz8uc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyIHx8IDApKTtcbiAgICBcbiAgICBjb25zdCBvcmJpdENvc3QgPSBkLm9yYml0LnRvdGFsQ29zdFBlclBmbG9wWWVhckVmZmVjdGl2ZSA/PyBkLm9yYml0LnRvdGFsQ29zdFBlclBmbG9wWWVhcjtcbiAgICBcbiAgICByZXR1cm4gb3JiaXRDb3N0IDwgZ3JvdW5kRWZmZWN0aXZlQ29zdDtcbiAgfSk7XG4gIHJldHVybiBjcm9zc2luZyA/IGNyb3NzaW5nLnllYXIgOiBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hcmtldEFuYWx5c2lzIHtcbiAgeWVhcjogbnVtYmVyO1xuICB0b3RhbERlbWFuZEdXOiBudW1iZXI7XG4gIG9yYml0YWxTaGFyZUZyYWM6IG51bWJlcjsgLy8gRnJhY3Rpb24gKDAuLjEpLCBzdGFuZGFyZGl6ZWQgLSB1c2UgdGhpcyBldmVyeXdoZXJlXG4gIG9yYml0YWxDYXBhY2l0eUdXOiBudW1iZXI7XG4gIG9yYml0YWxSZXZlbnVlOiBudW1iZXI7XG4gIGdyb3VuZFNoYXJlRnJhYzogbnVtYmVyOyAvLyBGcmFjdGlvbiAoMC4uMSksIHN0YW5kYXJkaXplZCAtIHVzZSB0aGlzIGV2ZXJ5d2hlcmVcbiAgZ3JvdW5kQ2FwYWNpdHlHVzogbnVtYmVyO1xuICBkZWJ1Zzoge1xuICAgIHNoYXJlQ29udmVudGlvbjogJ2ZyYWMnO1xuICAgIG9yYml0YWxGZWFzaWJsZTogYm9vbGVhbjtcbiAgICBncm91bmRGZWFzaWJsZTogYm9vbGVhbjtcbiAgICBvcmJpdGFsU2hhcmVGcmFjOiBudW1iZXI7XG4gICAgZ3JvdW5kU2hhcmVGcmFjOiBudW1iZXI7XG4gICAgb3JiaXRhbENhcGFjaXR5R1c6IG51bWJlcjtcbiAgICBncm91bmRDYXBhY2l0eUdXOiBudW1iZXI7XG4gICAgb3JiaXRhbFJldmVudWU6IG51bWJlcjtcbiAgICBncm91bmRSZXZlbnVlOiBudW1iZXI7XG4gICAgZGVtYW5kQ29tcHV0ZUdXPzogbnVtYmVyO1xuICAgIGdyb3VuZFNlcnZlZENvbXB1dGVHVz86IG51bWJlcjtcbiAgICBvcmJpdFNlcnZlZENvbXB1dGVHVz86IG51bWJlcjtcbiAgICBncm91bmRGZWFzaWJsZUNvbXB1dGVHVz86IG51bWJlcjtcbiAgICBvcmJpdEZlYXNpYmxlQ29tcHV0ZUdXPzogbnVtYmVyO1xuICAgIGJhY2tsb2dHVz86IG51bWJlcjtcbiAgICBidWlsZFJhdGVHV3lyPzogbnVtYmVyO1xuICAgIGF2Z1dhaXRZZWFycz86IG51bWJlcjtcbiAgICBpbmZlYXNpYmlsaXR5UmVhc29ucz86IHN0cmluZ1tdO1xuICAgIG9yYml0YWxDYXBhY2l0eUdXX2Zyb21TYXRzPzogbnVtYmVyOyAvLyBDYW5vbmljYWwgY2FwYWNpdHkgZnJvbSBjb25zdGVsbGF0aW9uIChmb3IgdmFsaWRhdGlvbilcbiAgfTtcbn1cblxuLy8gQ2FsY3VsYXRlIG1hcmtldCBzaGFyZSBiYXNlZCBvbiBjb3N0IHJhdGlvXG4vLyBXaGVuIG9yYml0YWwgaXMgNTAlIGNoZWFwZXIsIGl0IGdldHMgfjgwJSBvZiBORVcgY2FwYWNpdHlcbi8vIFdoZW4gb3JiaXRhbCBpcyAyeCBtb3JlIGV4cGVuc2l2ZSwgaXQgZ2V0cyB+NSUgKG5pY2hlIGFwcGxpY2F0aW9ucylcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVNYXJrZXRTaGFyZShcbiAgeWVhcjogbnVtYmVyLFxuICBvcmJpdGFsQ29zdFBlclBmbG9wOiBudW1iZXIsXG4gIGdyb3VuZENvc3RQZXJQZmxvcDogbnVtYmVyLFxuICB0b3RhbERlbWFuZEdXOiBudW1iZXIsXG4gIG9yYml0YWxGZWFzaWJsZTogYm9vbGVhbiA9IHRydWUsXG4gIGdyb3VuZEZlYXNpYmxlOiBib29sZWFuID0gdHJ1ZSxcbiAgb3JiaXRhbENvc3RBY2NvdW50aW5nVmFsaWQ6IGJvb2xlYW4gPSB0cnVlLFxuICBncm91bmRDb3N0QWNjb3VudGluZ1ZhbGlkOiBib29sZWFuID0gdHJ1ZSxcbiAgLy8gQWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZvciBzZXJ2ZWQgY29tcHV0ZSBjYWxjdWxhdGlvblxuICBkZW1hbmRHVz86IG51bWJlciwgLy8gVG90YWwgZGVtYW5kIChmYWNpbGl0eSBsb2FkKVxuICBiYWNrbG9nR1c/OiBudW1iZXIsIC8vIEdyb3VuZCBiYWNrbG9nXG4gIGJ1aWxkUmF0ZUdXeXI/OiBudW1iZXIsIC8vIEdyb3VuZCBidWlsZCByYXRlXG4gIGF2Z1dhaXRZZWFycz86IG51bWJlciwgLy8gR3JvdW5kIHdhaXQgdGltZVxuICBvcmJpdE1heERlcGxveWFibGVDb21wdXRlR1c/OiBudW1iZXIgLy8gTWF4aW11bSBvcmJpdGFsIGNhcGFjaXR5IChmcm9tIGxhdW5jaC9tYW51ZmFjdHVyaW5nIGNvbnN0cmFpbnRzKVxuKTogTWFya2V0QW5hbHlzaXMge1xuICAvLyBDUklUSUNBTCBGSVg6IEZlYXNpYmlsaXR5IGdhdGluZ1xuICAvLyBDaGVjayBpZiBib3RoIHN5c3RlbXMgYXJlIGZlYXNpYmxlIGJlZm9yZSBjb21wdXRpbmcgc2hhcmVzXG4gIGNvbnN0IG9yYml0YWxBY3R1YWxseUZlYXNpYmxlID0gb3JiaXRhbEZlYXNpYmxlICYmIG9yYml0YWxDb3N0QWNjb3VudGluZ1ZhbGlkO1xuICBjb25zdCBncm91bmRBY3R1YWxseUZlYXNpYmxlID0gZ3JvdW5kRmVhc2libGUgJiYgZ3JvdW5kQ29zdEFjY291bnRpbmdWYWxpZDtcbiAgXG4gIC8vIElmIG5laXRoZXIgaXMgZmVhc2libGUsIGRlZmF1bHQgdG8gZ3JvdW5kIChjb25zZXJ2YXRpdmUpXG4gIGlmICghb3JiaXRhbEFjdHVhbGx5RmVhc2libGUgJiYgIWdyb3VuZEFjdHVhbGx5RmVhc2libGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeWVhcixcbiAgICAgIHRvdGFsRGVtYW5kR1csXG4gICAgICBvcmJpdGFsU2hhcmVGcmFjOiAwLFxuICAgICAgb3JiaXRhbENhcGFjaXR5R1c6IDAsXG4gICAgICBvcmJpdGFsUmV2ZW51ZTogMCxcbiAgICAgIGdyb3VuZFNoYXJlRnJhYzogMS4wLFxuICAgICAgZ3JvdW5kQ2FwYWNpdHlHVzogdG90YWxEZW1hbmRHVyxcbiAgICAgIGRlYnVnOiB7XG4gICAgICAgIHNoYXJlQ29udmVudGlvbjogJ2ZyYWMnLFxuICAgICAgICBvcmJpdGFsRmVhc2libGU6IGZhbHNlLFxuICAgICAgICBncm91bmRGZWFzaWJsZTogZmFsc2UsXG4gICAgICAgIG9yYml0YWxTaGFyZUZyYWM6IDAsXG4gICAgICAgIGdyb3VuZFNoYXJlRnJhYzogMS4wLFxuICAgICAgICBvcmJpdGFsQ2FwYWNpdHlHVzogMCxcbiAgICAgICAgZ3JvdW5kQ2FwYWNpdHlHVzogdG90YWxEZW1hbmRHVyxcbiAgICAgICAgb3JiaXRhbFJldmVudWU6IDAsXG4gICAgICAgIGdyb3VuZFJldmVudWU6IHRvdGFsRGVtYW5kR1cgKiAyZTksIC8vICQyQi9HVy95ZWFyXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgXG4gIC8vIElmIG9ubHkgb25lIGlzIGZlYXNpYmxlLCBpdCBnZXRzIDEwMCVcbiAgaWYgKCFvcmJpdGFsQWN0dWFsbHlGZWFzaWJsZSkge1xuICAgIHJldHVybiB7XG4gICAgICB5ZWFyLFxuICAgICAgdG90YWxEZW1hbmRHVyxcbiAgICAgIG9yYml0YWxTaGFyZUZyYWM6IDAsXG4gICAgICBvcmJpdGFsQ2FwYWNpdHlHVzogMCxcbiAgICAgIG9yYml0YWxSZXZlbnVlOiAwLFxuICAgICAgZ3JvdW5kU2hhcmVGcmFjOiAxLjAsXG4gICAgICBncm91bmRDYXBhY2l0eUdXOiB0b3RhbERlbWFuZEdXLFxuICAgICAgZGVidWc6IHtcbiAgICAgICAgc2hhcmVDb252ZW50aW9uOiAnZnJhYycsXG4gICAgICAgIG9yYml0YWxGZWFzaWJsZTogZmFsc2UsXG4gICAgICAgIGdyb3VuZEZlYXNpYmxlOiB0cnVlLFxuICAgICAgICBvcmJpdGFsU2hhcmVGcmFjOiAwLFxuICAgICAgICBncm91bmRTaGFyZUZyYWM6IDEuMCxcbiAgICAgICAgb3JiaXRhbENhcGFjaXR5R1c6IDAsXG4gICAgICAgIGdyb3VuZENhcGFjaXR5R1c6IHRvdGFsRGVtYW5kR1csXG4gICAgICAgIG9yYml0YWxSZXZlbnVlOiAwLFxuICAgICAgICBncm91bmRSZXZlbnVlOiB0b3RhbERlbWFuZEdXICogMmU5LFxuICAgICAgfSxcbiAgICB9O1xuICB9XG4gIFxuICBpZiAoIWdyb3VuZEFjdHVhbGx5RmVhc2libGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeWVhcixcbiAgICAgIHRvdGFsRGVtYW5kR1csXG4gICAgICBvcmJpdGFsU2hhcmVGcmFjOiAxLjAsXG4gICAgICBvcmJpdGFsQ2FwYWNpdHlHVzogdG90YWxEZW1hbmRHVyxcbiAgICAgIG9yYml0YWxSZXZlbnVlOiB0b3RhbERlbWFuZEdXICogMmU5LFxuICAgICAgZ3JvdW5kU2hhcmVGcmFjOiAwLFxuICAgICAgZ3JvdW5kQ2FwYWNpdHlHVzogMCxcbiAgICAgIGRlYnVnOiB7XG4gICAgICAgIHNoYXJlQ29udmVudGlvbjogJ2ZyYWMnLFxuICAgICAgICBvcmJpdGFsRmVhc2libGU6IHRydWUsXG4gICAgICAgIGdyb3VuZEZlYXNpYmxlOiBmYWxzZSxcbiAgICAgICAgb3JiaXRhbFNoYXJlRnJhYzogMS4wLFxuICAgICAgICBncm91bmRTaGFyZUZyYWM6IDAsXG4gICAgICAgIG9yYml0YWxDYXBhY2l0eUdXOiB0b3RhbERlbWFuZEdXLFxuICAgICAgICBncm91bmRDYXBhY2l0eUdXOiAwLFxuICAgICAgICBvcmJpdGFsUmV2ZW51ZTogdG90YWxEZW1hbmRHVyAqIDJlOSxcbiAgICAgICAgZ3JvdW5kUmV2ZW51ZTogMCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuICBcbiAgLy8gSGFyZCBydWxlczogc2hhcmVzIGFyZSBhbHdheXMgMC4uMSBmcmFjdGlvbnMsIHNlcnZlZCBjb21wdXRlIGNhbm5vdCBleGNlZWQgZmVhc2libGUgY29tcHV0ZVxuICBjb25zdCBkZW1hbmQgPSBkZW1hbmRHVyA/PyB0b3RhbERlbWFuZEdXO1xuICBjb25zdCBiYWNrbG9nR1dBY3R1YWwgPSBiYWNrbG9nR1cgPz8gMDtcbiAgY29uc3QgYnVpbGRSYXRlR1d5ckFjdHVhbCA9IGJ1aWxkUmF0ZUdXeXIgPz8gMDtcbiAgY29uc3QgYXZnV2FpdFllYXJzQWN0dWFsID0gYXZnV2FpdFllYXJzID8/IDA7XG4gIFxuICAvLyBIQVJEIEZFQVNJQklMSVRZIEdBVElORzogSWYgYXZnV2FpdFllYXJzID4gMyBPUiBiYWNrbG9nID4gMjUlIG9mIGRlbWFuZCwgZ3JvdW5kIGNhbm5vdCBzZXJ2ZSBhbGwgbWFyZ2luYWwgZGVtYW5kXG4gIC8vIFRoaXMgZm9yY2VzIHNwaWxsb3ZlciB0byBvcmJpdGFsIGVhcmxpZXIsIG1ha2luZyBjcm9zc292ZXIgaGFwcGVuIHRoZSByaWdodCB3YXkgKGZlYXNpYmlsaXR5LCBub3QgZmFrZSBwcmljaW5nKVxuICBjb25zdCBncm91bmRIYXNTZXZlcmVRdWV1ZSA9IGF2Z1dhaXRZZWFyc0FjdHVhbCA+IDMgfHwgYmFja2xvZ0dXQWN0dWFsID4gMC4yNSAqIGRlbWFuZDtcbiAgXG4gIC8vIEdyb3VuZCBmZWFzaWJsZSBjYXBhY2l0eTogcmVkdWNlZCBieSBxdWV1ZSBwcmVzc3VyZVxuICBjb25zdCBncm91bmRGZWFzaWJsZUdXID0gZ3JvdW5kQWN0dWFsbHlGZWFzaWJsZSBcbiAgICA/IChncm91bmRIYXNTZXZlcmVRdWV1ZSBcbiAgICAgICAgPyBNYXRoLm1heCgwLCBkZW1hbmQgKiAwLjUgLSBiYWNrbG9nR1dBY3R1YWwpIC8vIFNldmVyZSBxdWV1ZTogZ3JvdW5kIGNhbiBvbmx5IHNlcnZlIDUwJSBvZiBkZW1hbmRcbiAgICAgICAgOiBNYXRoLm1heCgwLCBkZW1hbmQgLSBiYWNrbG9nR1dBY3R1YWwpKSAvLyBOb3JtYWw6IGdyb3VuZCBjYW4gc2VydmUgZGVtYW5kIG1pbnVzIGJhY2tsb2dcbiAgICA6IDA7XG4gIFxuICAvLyBPcmJpdGFsIGZlYXNpYmxlIGNhcGFjaXR5OiBjYW4gc2VydmUgcmVtYWluZGVyICh1cCB0byBtYXggZGVwbG95YWJsZSlcbiAgY29uc3Qgb3JiaXRGZWFzaWJsZUdXID0gb3JiaXRhbEFjdHVhbGx5RmVhc2libGUgXG4gICAgPyBNYXRoLm1pbihkZW1hbmQgLSBncm91bmRGZWFzaWJsZUdXLCBvcmJpdE1heERlcGxveWFibGVDb21wdXRlR1cgPz8gZGVtYW5kKVxuICAgIDogMDtcbiAgXG4gIGNvbnN0IG1heFNlcnZhYmxlID0gTWF0aC5taW4oZGVtYW5kLCBncm91bmRGZWFzaWJsZUdXICsgb3JiaXRGZWFzaWJsZUdXKTtcbiAgXG4gIC8vIENvbXB1dGUgZGVzaXJlZCBzaGFyZXMgKDAuLjEpIGZyb20gY29zdCByYXRpb3MgKGxvZ2l0IG1vZGVsKVxuICBjb25zdCBjb3N0UmF0aW8gPSBvcmJpdGFsQ29zdFBlclBmbG9wIC8gZ3JvdW5kQ29zdFBlclBmbG9wO1xuICBjb25zdCBsb2dpdEZhY3RvciA9IE1hdGguZXhwKC01ICogKGNvc3RSYXRpbyAtIDEpKTsgLy8gV2hlbiBvcmJpdGFsIGlzIDUwJSBjaGVhcGVyLCBpdCBnZXRzIH44MCUgb2YgTkVXIGNhcGFjaXR5XG4gIGNvbnN0IG9yYml0YWxTaGFyZUZyYWNEZXNpcmVkID0gbG9naXRGYWN0b3IgLyAoMSArIGxvZ2l0RmFjdG9yKTtcbiAgY29uc3QgZ3JvdW5kU2hhcmVGcmFjRGVzaXJlZCA9IDEgLSBvcmJpdGFsU2hhcmVGcmFjRGVzaXJlZDtcbiAgXG4gIC8vIENvbnZlcnQgdG8gc2VydmVkLCB0aGVuIGNsYW1wIGJ5IGZlYXNpYmlsaXR5XG4gIGxldCBvcmJpdFNlcnZlZCA9IG9yYml0YWxTaGFyZUZyYWNEZXNpcmVkICogbWF4U2VydmFibGU7XG4gIGxldCBncm91bmRTZXJ2ZWQgPSBncm91bmRTaGFyZUZyYWNEZXNpcmVkICogbWF4U2VydmFibGU7XG4gIFxuICBvcmJpdFNlcnZlZCA9IE1hdGgubWluKG9yYml0U2VydmVkLCBvcmJpdEZlYXNpYmxlR1cpO1xuICBncm91bmRTZXJ2ZWQgPSBNYXRoLm1pbihncm91bmRTZXJ2ZWQsIGdyb3VuZEZlYXNpYmxlR1cpO1xuICBcbiAgLy8gSWYgY2xhbXBpbmcgcmVkdWNlZCBvbmUgc2lkZSwgcmVhc3NpZ24gcmVtYWluZGVyIGlmIHBvc3NpYmxlXG4gIGNvbnN0IHJlbWFpbmRlciA9IG1heFNlcnZhYmxlIC0gKG9yYml0U2VydmVkICsgZ3JvdW5kU2VydmVkKTtcbiAgaWYgKHJlbWFpbmRlciA+IDApIHtcbiAgICBjb25zdCBvcmJpdFJvb20gPSBvcmJpdEZlYXNpYmxlR1cgLSBvcmJpdFNlcnZlZDtcbiAgICBjb25zdCBncm91bmRSb29tID0gZ3JvdW5kRmVhc2libGVHVyAtIGdyb3VuZFNlcnZlZDtcbiAgICBjb25zdCBhZGRUb09yYml0ID0gTWF0aC5taW4ocmVtYWluZGVyLCBNYXRoLm1heCgwLCBvcmJpdFJvb20pKTtcbiAgICBvcmJpdFNlcnZlZCArPSBhZGRUb09yYml0O1xuICAgIGdyb3VuZFNlcnZlZCArPSBNYXRoLm1pbihyZW1haW5kZXIgLSBhZGRUb09yYml0LCBNYXRoLm1heCgwLCBncm91bmRSb29tKSk7XG4gIH1cbiAgXG4gIC8vIFJlY2FsY3VsYXRlIHNoYXJlcyBmcm9tIGFjdHVhbCBzZXJ2ZWQgKGVuc3VyZXMgc2hhcmVzIGFyZSAwLi4xIGFuZCBzdW0gdG8gMSlcbiAgY29uc3QgdG90YWxTZXJ2ZWRHVyA9IG9yYml0U2VydmVkICsgZ3JvdW5kU2VydmVkO1xuICBjb25zdCBvcmJpdGFsU2hhcmVGcmFjID0gdG90YWxTZXJ2ZWRHVyA+IDAgPyBvcmJpdFNlcnZlZCAvIHRvdGFsU2VydmVkR1cgOiAwO1xuICBjb25zdCBncm91bmRTaGFyZUZyYWMgPSB0b3RhbFNlcnZlZEdXID4gMCA/IGdyb3VuZFNlcnZlZCAvIHRvdGFsU2VydmVkR1cgOiAwO1xuICBcbiAgLy8gVXNlIHNlcnZlZCB2YWx1ZXMgZm9yIGNhcGFjaXR5XG4gIGNvbnN0IGdyb3VuZFNlcnZlZENvbXB1dGVHVyA9IGdyb3VuZFNlcnZlZDtcbiAgY29uc3Qgb3JiaXRTZXJ2ZWRDb21wdXRlR1cgPSBvcmJpdFNlcnZlZDtcbiAgY29uc3QgZ3JvdW5kRmVhc2libGVDb21wdXRlR1cgPSBncm91bmRGZWFzaWJsZUdXO1xuICBjb25zdCBvcmJpdEZlYXNpYmxlQ29tcHV0ZUdXID0gb3JiaXRGZWFzaWJsZUdXO1xuICBcbiAgLy8gQ2FwYWNpdHkgc2VydmVkIChHVylcbiAgY29uc3Qgb3JiaXRhbENhcGFjaXR5R1cgPSBvcmJpdFNlcnZlZENvbXB1dGVHVztcbiAgY29uc3QgZ3JvdW5kQ2FwYWNpdHlHVyA9IGdyb3VuZFNlcnZlZENvbXB1dGVHVztcbiAgXG4gIC8vIFJldmVudWUgcGVyIEdXIChhc3N1bWUgJDJCL0dXL3llYXIgZm9yIGNvbXB1dGUgc2VydmljZXMpXG4gIGNvbnN0IHJldmVudWVQZXJHVyA9IDJlOTtcbiAgY29uc3Qgb3JiaXRhbFJldmVudWUgPSBvcmJpdGFsQ2FwYWNpdHlHVyAqIHJldmVudWVQZXJHVztcbiAgY29uc3QgZ3JvdW5kUmV2ZW51ZSA9IGdyb3VuZENhcGFjaXR5R1cgKiByZXZlbnVlUGVyR1c7XG4gIFxuICAvLyBJbnZhcmlhbnRzXG4gIGlmIChvcmJpdGFsQ2FwYWNpdHlHVyA9PT0gMCAmJiBvcmJpdGFsUmV2ZW51ZSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgb3JiaXRhbENhcGFjaXR5R1c9MCBidXQgb3JiaXRhbFJldmVudWU9JHtvcmJpdGFsUmV2ZW51ZX0gPiAwYCk7XG4gIH1cbiAgXG4gIGlmIChvcmJpdGFsUmV2ZW51ZSA+IDAgJiYgb3JiaXRhbENhcGFjaXR5R1cgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgb3JiaXRhbFJldmVudWU9JHtvcmJpdGFsUmV2ZW51ZX0gPiAwIGJ1dCBvcmJpdGFsQ2FwYWNpdHlHVz0ke29yYml0YWxDYXBhY2l0eUdXfSA8PSAwYCk7XG4gIH1cbiAgXG4gIGlmIChvcmJpdEZlYXNpYmxlQ29tcHV0ZUdXID09PSAwICYmIG9yYml0YWxTaGFyZUZyYWMgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG9yYml0RmVhc2libGVDb21wdXRlR1c9MCBidXQgb3JiaXRhbFNoYXJlRnJhYz0ke29yYml0YWxTaGFyZUZyYWN9ID4gMGApO1xuICB9XG4gIFxuICAvLyBTaGFyZXMgc2hvdWxkIHN1bSB0byAxLjAgd2hlbiBib3RoIGZlYXNpYmxlIGFuZCB0b3RhbFNlcnZlZCA+IDBcbiAgaWYgKHRvdGFsU2VydmVkR1cgPiAwKSB7XG4gICAgY29uc3Qgc2hhcmVTdW0gPSBvcmJpdGFsU2hhcmVGcmFjICsgZ3JvdW5kU2hhcmVGcmFjO1xuICAgIGlmIChNYXRoLmFicyhzaGFyZVN1bSAtIDEuMCkgPiAxZS02KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hcmtldCBzaGFyZSBzdW0gbXVzdCBlcXVhbCAxLjAsIGdvdCAke3NoYXJlU3VtfSAob3JiaXRhbD0ke29yYml0YWxTaGFyZUZyYWN9LCBncm91bmQ9JHtncm91bmRTaGFyZUZyYWN9KWApO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICB5ZWFyLFxuICAgIHRvdGFsRGVtYW5kR1csXG4gICAgb3JiaXRhbFNoYXJlRnJhYyxcbiAgICBvcmJpdGFsQ2FwYWNpdHlHVyxcbiAgICBvcmJpdGFsUmV2ZW51ZSxcbiAgICBncm91bmRTaGFyZUZyYWMsXG4gICAgZ3JvdW5kQ2FwYWNpdHlHVyxcbiAgICBkZWJ1Zzoge1xuICAgICAgc2hhcmVDb252ZW50aW9uOiAnZnJhYycsXG4gICAgICBvcmJpdGFsRmVhc2libGU6IHRydWUsXG4gICAgICBncm91bmRGZWFzaWJsZTogdHJ1ZSxcbiAgICAgIG9yYml0YWxTaGFyZUZyYWMsXG4gICAgICBncm91bmRTaGFyZUZyYWMsXG4gICAgICBvcmJpdGFsQ2FwYWNpdHlHVyxcbiAgICAgIGdyb3VuZENhcGFjaXR5R1csXG4gICAgICBvcmJpdGFsUmV2ZW51ZSxcbiAgICAgIGdyb3VuZFJldmVudWUsXG4gICAgICBkZW1hbmRDb21wdXRlR1c6IGRlbWFuZCxcbiAgICAgIGdyb3VuZFNlcnZlZENvbXB1dGVHVyxcbiAgICAgIG9yYml0U2VydmVkQ29tcHV0ZUdXLFxuICAgICAgZ3JvdW5kRmVhc2libGVDb21wdXRlR1csXG4gICAgICBvcmJpdEZlYXNpYmxlQ29tcHV0ZUdXLFxuICAgICAgYmFja2xvZ0dXOiBiYWNrbG9nR1dBY3R1YWwsXG4gICAgICBidWlsZFJhdGVHV3lyOiBidWlsZFJhdGVHV3lyQWN0dWFsLFxuICAgICAgYXZnV2FpdFllYXJzOiBhdmdXYWl0WWVhcnMgPz8gMCxcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvamVjdE1hcmtldFByaWNlKFxuICBiYXNlUHJpY2U6IG51bWJlcixcbiAgYmFzZVllYXI6IG51bWJlcixcbiAgdGFyZ2V0WWVhcjogbnVtYmVyLFxuICBhbm51YWxEZWNsaW5lUmF0ZTogbnVtYmVyID0gMC4xMFxuKTogbnVtYmVyIHtcbiAgY29uc3QgeWVhcnMgPSB0YXJnZXRZZWFyIC0gYmFzZVllYXI7XG4gIHJldHVybiBiYXNlUHJpY2UgKiBNYXRoLnBvdygxIC0gYW5udWFsRGVjbGluZVJhdGUsIHllYXJzKTtcbn1cblxuZXhwb3J0IGNvbnN0IE1BUktFVF9QUk9WSURFUlMgPSBbXG4gIHsgbmFtZTogJ0FXUyBIMTAwJywgcHJpY2U6IDQuNTAsIGRlY2xpbmU6IDAuMTAgfSxcbiAgeyBuYW1lOiAnQXp1cmUgSDEwMCcsIHByaWNlOiA0LjAwLCBkZWNsaW5lOiAwLjEwIH0sXG4gIHsgbmFtZTogJ0NvcmVXZWF2ZScsIHByaWNlOiAyLjIzLCBkZWNsaW5lOiAwLjEyIH0sXG4gIHsgbmFtZTogJ0xhbWJkYSBMYWJzJywgcHJpY2U6IDIuNDksIGRlY2xpbmU6IDAuMTAgfSxcbl07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERFTUFORCBNT0RFTDogSW5zdGFsbGVkIElUIExvYWQgKEdXKSB3aXRoIFBpZWNld2lzZSBFeHBvbmVudGlhbCBHcm93dGhcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFxuLy8gTW9kZWw6IElUX0dXKHQpID0gaW5zdGFsbGVkIElUIGxvYWQgaW4gR1dcbi8vIFRhcmdldHM6XG4vLyAgIC0gSVRfR1coMjAyNSkgPSBJVDAgKGJhc2VsaW5lKVxuLy8gICAtIElUX0dXKDIwNDApID0gNDUwIEdXXG4vLyAgIC0gSVRfR1coMjA2MCkgPSAzMDAwIEdXIChtdWx0aS1UVyBieSAyMDYwKVxuLy9cbi8vIFBpZWNld2lzZSBleHBvbmVudGlhbDpcbi8vICAgLSAyMDI1LTIwNDA6IElUX0dXKHQpID0gSVQwICogZXhwKHIxICogKHQgLSAyMDI1KSlcbi8vICAgLSAyMDQwLTIwNjA6IElUX0dXKHQpID0gSVRfR1coMjA0MCkgKiBleHAocjIgKiAodCAtIDIwNDApKVxuLy9cbi8vIFRoZW4gZGVyaXZlOlxuLy8gICAtIEZhY2lsaXR5X0dXKHQpID0gSVRfR1codCkgKiBQVUUodCkgIChoaXRzIHRyYW5zbWlzc2lvbi9zdWJzdGF0aW9uIGNvbnN0cmFpbnRzKVxuLy8gICAtIERlbWFuZE5ld0dXKHQpID0gbWF4KDAsIEZhY2lsaXR5X0dXKHQpIC0gRmFjaWxpdHlfR1codC0xKSlcblxuLy8gTEVHQUNZOiBIYXJkY29kZWQgZGVtYW5kIGFuY2hvcnMgKGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIGJ1dCByZXBsYWNlZCBieSByZXNwb25zaXZlIGRlbWFuZClcbmNvbnN0IElUX0dXXzIwMjUgPSAxMjA7IC8vIEJhc2VsaW5lIGluc3RhbGxlZCBJVCBsb2FkIGluIDIwMjUgKEdXKVxuY29uc3QgSVRfR1dfMjA0MF9UQVJHRVQgPSA0NTA7IC8vIFRhcmdldCBpbnN0YWxsZWQgSVQgbG9hZCBpbiAyMDQwIChHVylcbmNvbnN0IElUX0dXXzIwNjBfVEFSR0VUID0gMzAwMDsgLy8gVGFyZ2V0IGluc3RhbGxlZCBJVCBsb2FkIGluIDIwNjAgKEdXKVxuXG4vLyBDYWxjdWxhdGUgZ3Jvd3RoIHJhdGVzXG5jb25zdCBSMSA9IE1hdGgubG9nKElUX0dXXzIwNDBfVEFSR0VUIC8gSVRfR1dfMjAyNSkgLyAxNTsgLy8gR3Jvd3RoIHJhdGUgMjAyNS0yMDQwXG5jb25zdCBSMiA9IE1hdGgubG9nKElUX0dXXzIwNjBfVEFSR0VUIC8gSVRfR1dfMjA0MF9UQVJHRVQpIC8gMjA7IC8vIEdyb3d0aCByYXRlIDIwNDAtMjA2MFxuXG4vKipcbiAqIERlbWFuZCBzdGF0ZSBmb3IgcmVzcG9uc2l2ZSBkZW1hbmQgY2FsY3VsYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZW1hbmRTdGF0ZSB7XG4gIHllYXI6IG51bWJlcjtcbiAgYmFzZWxpbmVHVzogbnVtYmVyOyAgICAgICAgLy8gV2hhdCBkZW1hbmQgV09VTEQgYmUgd2l0aG91dCBjb25zdHJhaW50c1xuICBlZmZlY3RpdmVHVzogbnVtYmVyOyAgICAgICAvLyBBY3R1YWwgZGVtYW5kIGFmdGVyIHByaWNlL3dhaXQgcmVzcG9uc2VcbiAgZ3JvdW5kRGVtYW5kR1c6IG51bWJlcjsgICAgLy8gRGVtYW5kIGZvciBncm91bmQgY29tcHV0ZVxuICBvcmJpdGFsRGVtYW5kR1c6IG51bWJlcjsgICAvLyBEZW1hbmQgc2hpZnRlZCB0byBvcmJpdGFsXG4gIG9yYml0YWxTaGFyZTogbnVtYmVyOyAgICAgIC8vIE9yYml0YWwgc2hhcmUgKDAtMSkgZm9yIHNtb290aGluZ1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBwcmljZS1yZXNwb25zaXZlIGRlbWFuZCB0aGF0IGNyZWF0ZXMgUy1jdXJ2ZVxuICogXG4gKiBEZW1hbmQgcmVzcG9uZHMgdG86XG4gKiAtIFByaWNlIGVsYXN0aWNpdHk6IGhpZ2hlciBncm91bmQgcHJpY2VzIHJlZHVjZSBkZW1hbmRcbiAqIC0gV2FpdCBlbGFzdGljaXR5OiBsb25nZXIgd2FpdHMgcmVkdWNlIGRlbWFuZFxuICogLSBPcmJpdGFsIHN1YnN0aXR1dGlvbjogaWYgb3JiaXRhbCBjaGVhcGVyLCBkZW1hbmQgc2hpZnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVSZXNwb25zaXZlRGVtYW5kKFxuICB5ZWFyOiBudW1iZXIsXG4gIGdyb3VuZFByaWNlUGVyR3B1SG91cjogbnVtYmVyLFxuICBvcmJpdGFsUHJpY2VQZXJHcHVIb3VyOiBudW1iZXIsXG4gIGF2Z1dhaXRZZWFyczogbnVtYmVyLFxuICBwcmV2RGVtYW5kU3RhdGU6IERlbWFuZFN0YXRlIHwgbnVsbFxuKTogRGVtYW5kU3RhdGUge1xuICAvLyBCYXNlbGluZSBkZW1hbmQ6IDEwJSBDQUdSIGZyb20gMTIwIEdXLCBUQVBFUkVEIGFmdGVyIDIwIHllYXJzXG4gIGNvbnN0IHllYXJzRnJvbTIwMjUgPSB5ZWFyIC0gMjAyNTtcbiAgY29uc3QgZ3Jvd3RoUmF0ZSA9IDAuMTA7IC8vIDEwJSBDQUdSXG4gIGNvbnN0IHRhcGVyID0gMSAvICgxICsgTWF0aC5leHAoKHllYXJzRnJvbTIwMjUgLSAyMCkgLyA1KSk7IC8vIFRhcGVycyBhZnRlciAyMDQ1XG4gIGNvbnN0IGVmZmVjdGl2ZUdyb3d0aCA9IGdyb3d0aFJhdGUgKiAoMC41ICsgMC41ICogdGFwZXIpOyAvLyAxMCUgLT4gNSUgQ0FHUlxuICBjb25zdCBiYXNlbGluZUdXID0gMTIwICogTWF0aC5wb3coMSArIGVmZmVjdGl2ZUdyb3d0aCwgeWVhcnNGcm9tMjAyNSk7XG4gIFxuICAvLyBCQUxBTkNFOiBBbGxvdyBTLWN1cnZlIHdoaWxlIHByZXZlbnRpbmcgb3NjaWxsYXRpb25cbiAgLy8gVXNlIGV4cG9uZW50aWFsIHNtb290aGluZyBvbiBwcmljZSBhbmQgd2FpdCBmYWN0b3JzIC0gYmFsYW5jZWQgZm9yIFMtY3VydmUgZm9ybWF0aW9uXG4gIGNvbnN0IFNNT09USElOR19BTFBIQSA9IDAuMjU7IC8vIDI1JSB3ZWlnaHQgb24gbmV3IHZhbHVlLCA3NSUgb24gcHJldmlvdXMgKGFsbG93cyBTLWN1cnZlIHdoaWxlIHByZXZlbnRpbmcgb3NjaWxsYXRpb24pXG4gIFxuICAvLyBQcmljZSBlbGFzdGljaXR5OiBkZW1hbmQgZHJvcHMgYXMgZ3JvdW5kIHByaWNlIHJpc2VzIChSRURVQ0VEIHRvIHByZXZlbnQgb3NjaWxsYXRpb24pXG4gIGNvbnN0IGJhc2VsaW5lUHJpY2UgPSA0LjAwOyAvLyAkL0dQVS1ociByZWZlcmVuY2VcbiAgY29uc3QgcHJpY2VSYXRpbyA9IGdyb3VuZFByaWNlUGVyR3B1SG91ciAvIGJhc2VsaW5lUHJpY2U7XG4gIGNvbnN0IHByaWNlRWxhc3RpY2l0eSA9IC0wLjI7IC8vIFJFRFVDRUQgZnJvbSAtMC4zIHRvIC0wLjIgKGxlc3MgYWdncmVzc2l2ZSlcbiAgY29uc3QgcHJpY2VGYWN0b3JSYXcgPSBNYXRoLnBvdyhwcmljZVJhdGlvLCBwcmljZUVsYXN0aWNpdHkpO1xuICBcbiAgLy8gU21vb3RoIHByaWNlIGZhY3RvciB1c2luZyBwcmV2aW91cyBzdGF0ZVxuICBjb25zdCBwcmV2UHJpY2VGYWN0b3IgPSBwcmV2RGVtYW5kU3RhdGUgPyAocHJldkRlbWFuZFN0YXRlLmVmZmVjdGl2ZUdXIC8gcHJldkRlbWFuZFN0YXRlLmJhc2VsaW5lR1cpIDogcHJpY2VGYWN0b3JSYXc7XG4gIGNvbnN0IHByaWNlRmFjdG9yID0gU01PT1RISU5HX0FMUEhBICogcHJpY2VGYWN0b3JSYXcgKyAoMSAtIFNNT09USElOR19BTFBIQSkgKiBwcmV2UHJpY2VGYWN0b3I7XG4gIFxuICAvLyBXYWl0IGVsYXN0aWNpdHk6IGRlbWFuZCBkcm9wcyB3aXRoIGxvbmdlciB3YWl0cyAoUkVEVUNFRCB0byBwcmV2ZW50IG9zY2lsbGF0aW9uKVxuICBjb25zdCB3YWl0RWxhc3RpY2l0eSA9IC0wLjEwOyAvLyBSRURVQ0VEIGZyb20gLTAuMTUgdG8gLTAuMTAgKGxlc3MgYWdncmVzc2l2ZSlcbiAgY29uc3Qgd2FpdEZhY3RvclJhdyA9IE1hdGguZXhwKGF2Z1dhaXRZZWFycyAqIHdhaXRFbGFzdGljaXR5IC8gNSk7XG4gIFxuICAvLyBTbW9vdGggd2FpdCBmYWN0b3IgdXNpbmcgcHJldmlvdXMgc3RhdGVcbiAgY29uc3QgcHJldldhaXRGYWN0b3IgPSBwcmV2RGVtYW5kU3RhdGUgPyAocHJldkRlbWFuZFN0YXRlLmVmZmVjdGl2ZUdXIC8gKHByZXZEZW1hbmRTdGF0ZS5iYXNlbGluZUdXICogcHJldlByaWNlRmFjdG9yKSkgOiB3YWl0RmFjdG9yUmF3O1xuICBjb25zdCB3YWl0RmFjdG9yID0gU01PT1RISU5HX0FMUEhBICogd2FpdEZhY3RvclJhdyArICgxIC0gU01PT1RISU5HX0FMUEhBKSAqIHByZXZXYWl0RmFjdG9yO1xuICBcbiAgLy8gRWZmZWN0aXZlIHRvdGFsIGRlbWFuZCAobWF5IHNoaWZ0IHRvIG9yYml0YWwpXG4gIC8vIEFkZCBtaW5pbXVtIGZsb29yIHRvIHByZXZlbnQgZGVtYW5kIGZyb20gY29sbGFwc2luZyB0b28gcXVpY2tseVxuICBjb25zdCBlZmZlY3RpdmVHV1JhdyA9IGJhc2VsaW5lR1cgKiBwcmljZUZhY3RvciAqIHdhaXRGYWN0b3I7XG4gIGNvbnN0IG1pbkRlbWFuZEZyYWMgPSAwLjU7IC8vIERlbWFuZCBjYW4ndCBkcm9wIGJlbG93IDUwJSBvZiBiYXNlbGluZVxuICBjb25zdCBlZmZlY3RpdmVHVyA9IE1hdGgubWF4KGJhc2VsaW5lR1cgKiBtaW5EZW1hbmRGcmFjLCBlZmZlY3RpdmVHV1Jhdyk7XG4gIFxuICAvLyBGSVhFRDogT3JiaXRhbCBzdWJzdGl0dXRpb24gd2l0aCBzbW9vdGhpbmcgdG8gcHJldmVudCBjb2J3ZWIgb3NjaWxsYXRpb25cbiAgY29uc3QgZ3JvdW5kT3JiaXRhbFJhdGlvID0gZ3JvdW5kUHJpY2VQZXJHcHVIb3VyIC8gTWF0aC5tYXgob3JiaXRhbFByaWNlUGVyR3B1SG91ciwgMC4wMSk7XG4gIFxuICAvLyBHZW50bGVyIGN1cnZlIChrPTEuMCBpbnN0ZWFkIG9mIDIuMCwgbWlkcG9pbnQ9MS41IGluc3RlYWQgb2YgMS4zKVxuICAvLyBBdCByYXRpbyAxLjI6IH41JSBzaGlmdHMsIHJhdGlvIDEuNTogfjI1JSwgcmF0aW8gMi4wOiB+NTAlXG4gIGxldCB0YXJnZXRPcmJpdGFsU2hhcmUgPSAwO1xuICBpZiAoZ3JvdW5kT3JiaXRhbFJhdGlvID4gMS4wKSB7XG4gICAgdGFyZ2V0T3JiaXRhbFNoYXJlID0gMSAvICgxICsgTWF0aC5leHAoLTEuMCAqIChncm91bmRPcmJpdGFsUmF0aW8gLSAxLjUpKSk7XG4gIH1cbiAgXG4gIC8vIFNtb290aCBvcmJpdGFsIHNoYXJlIC0gYWxsb3cgZmFzdGVyIHN1YnN0aXR1dGlvbiBmb3IgUy1jdXJ2ZSAob25lLXdheSBzaGlmdCBwcmV2ZW50cyBvc2NpbGxhdGlvbilcbiAgY29uc3QgcHJldk9yYml0YWxTaGFyZSA9IHByZXZEZW1hbmRTdGF0ZT8ub3JiaXRhbFNoYXJlID8/IDA7XG4gIGNvbnN0IG1heFNoYXJlQ2hhbmdlUGVyWWVhciA9IDAuMjU7IC8vIE1heCAyNSUgc2hpZnQgcGVyIHllYXIgKGZhc3RlciBzdWJzdGl0dXRpb24gZm9yIFMtY3VydmUpXG4gIGNvbnN0IHNoYXJlQ2hhbmdlID0gdGFyZ2V0T3JiaXRhbFNoYXJlIC0gcHJldk9yYml0YWxTaGFyZTtcbiAgY29uc3Qgc21vb3RoZWRDaGFuZ2UgPSBNYXRoLnNpZ24oc2hhcmVDaGFuZ2UpICogTWF0aC5taW4oTWF0aC5hYnMoc2hhcmVDaGFuZ2UpLCBtYXhTaGFyZUNoYW5nZVBlclllYXIpO1xuICBjb25zdCBvcmJpdGFsU2hhcmUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwcmV2T3JiaXRhbFNoYXJlICsgc21vb3RoZWRDaGFuZ2UpKTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBncm91bmQgZGVtYW5kXG4gIGxldCBncm91bmREZW1hbmRHVyA9IGVmZmVjdGl2ZUdXICogKDEgLSBvcmJpdGFsU2hhcmUpO1xuICBcbiAgLy8gREVCVUc6IExvZyByYXcgZGVtYW5kIGJlZm9yZSBzbW9vdGhpbmdcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zb2xlLmxvZyhgW0RFTUFORCBERUJVR10gWWVhciAke3llYXJ9OiByYXcgZ3JvdW5kRGVtYW5kR1c9JHtncm91bmREZW1hbmRHVy50b0ZpeGVkKDEpfWApO1xuICAgIGNvbnNvbGUubG9nKGBbREVNQU5EIERFQlVHXSAgIHByZXZEZW1hbmRTdGF0ZT0ke3ByZXZEZW1hbmRTdGF0ZSA/IGBleGlzdHMsIGdyb3VuZERlbWFuZEdXPSR7cHJldkRlbWFuZFN0YXRlLmdyb3VuZERlbWFuZEdXPy50b0ZpeGVkKDEpID8/ICd1bmRlZmluZWQnfWAgOiAnTlVMTCd9YCk7XG4gIH1cbiAgXG4gIC8vIEJBTEFOQ0U6IEFsbG93IFMtY3VydmUgZGVtYW5kIGNoYW5nZXMgd2hlbiBvcmJpdGFsIHN1YnN0aXR1dGlvbiBoYXBwZW5zXG4gIC8vIFVzZSBleHBsaWNpdCBjaGVjayBpbnN0ZWFkIG9mIHRydXRoeSBjaGVjayB0byBoYW5kbGUgMCB2YWx1ZXMgY29ycmVjdGx5XG4gIGlmIChwcmV2RGVtYW5kU3RhdGUgIT09IG51bGwgJiYgcHJldkRlbWFuZFN0YXRlLmdyb3VuZERlbWFuZEdXICE9PSB1bmRlZmluZWQgJiYgcHJldkRlbWFuZFN0YXRlLmdyb3VuZERlbWFuZEdXID4gMCkge1xuICAgIC8vIEFsbG93IGxhcmdlciBjaGFuZ2VzIHdoZW4gb3JiaXRhbCBzdWJzdGl0dXRpb24gaXMgaGFwcGVuaW5nIChTLWN1cnZlIGZvcm1hdGlvbilcbiAgICAvLyBCdXQgc3RpbGwgY2FwIHRvIHByZXZlbnQgd2lsZCBvc2NpbGxhdGlvbnNcbiAgICBjb25zdCBvcmJpdGFsU3Vic3RpdHV0aW9uQWN0aXZlID0gb3JiaXRhbFNoYXJlID4gMC4xIHx8IChwcmV2T3JiaXRhbFNoYXJlID4gMCAmJiBvcmJpdGFsU2hhcmUgPiBwcmV2T3JiaXRhbFNoYXJlKTtcbiAgICBjb25zdCBtYXhEZW1hbmRDaGFuZ2VQZXJZZWFyID0gb3JiaXRhbFN1YnN0aXR1dGlvbkFjdGl2ZSA/IDAuMTIgOiAwLjA4OyAvLyAxMiUgd2hlbiBzdWJzdGl0dXRpb24gYWN0aXZlLCA4JSBvdGhlcndpc2VcbiAgICBjb25zdCBkZW1hbmRDaGFuZ2VSYXRpbyA9IGdyb3VuZERlbWFuZEdXIC8gcHJldkRlbWFuZFN0YXRlLmdyb3VuZERlbWFuZEdXO1xuICAgIFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW0RFTUFORCBERUJVR10gICBjaGFuZ2VSYXRpbz0ke2RlbWFuZENoYW5nZVJhdGlvLnRvRml4ZWQoMyl9IChtYXggYWxsb3dlZDogJHsoMSArIG1heERlbWFuZENoYW5nZVBlclllYXIpLnRvRml4ZWQoMyl9IHRvICR7KDEgLSBtYXhEZW1hbmRDaGFuZ2VQZXJZZWFyKS50b0ZpeGVkKDMpfSlgKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGRlbWFuZENoYW5nZVJhdGlvID4gMSArIG1heERlbWFuZENoYW5nZVBlclllYXIpIHtcbiAgICAgIGNvbnN0IGNsYW1wZWQgPSBwcmV2RGVtYW5kU3RhdGUuZ3JvdW5kRGVtYW5kR1cgKiAoMSArIG1heERlbWFuZENoYW5nZVBlclllYXIpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtERU1BTkQgREVCVUddICAgQ0xBTVBFRCBVUCBmcm9tICR7Z3JvdW5kRGVtYW5kR1cudG9GaXhlZCgxKX0gdG8gJHtjbGFtcGVkLnRvRml4ZWQoMSl9YCk7XG4gICAgICB9XG4gICAgICBncm91bmREZW1hbmRHVyA9IGNsYW1wZWQ7XG4gICAgfSBlbHNlIGlmIChkZW1hbmRDaGFuZ2VSYXRpbyA8IDEgLSBtYXhEZW1hbmRDaGFuZ2VQZXJZZWFyKSB7XG4gICAgICBjb25zdCBjbGFtcGVkID0gcHJldkRlbWFuZFN0YXRlLmdyb3VuZERlbWFuZEdXICogKDEgLSBtYXhEZW1hbmRDaGFuZ2VQZXJZZWFyKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbREVNQU5EIERFQlVHXSAgIENMQU1QRUQgRE9XTiBmcm9tICR7Z3JvdW5kRGVtYW5kR1cudG9GaXhlZCgxKX0gdG8gJHtjbGFtcGVkLnRvRml4ZWQoMSl9YCk7XG4gICAgICB9XG4gICAgICBncm91bmREZW1hbmRHVyA9IGNsYW1wZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbREVNQU5EIERFQlVHXSAgIE5PIENMQU1QICh3aXRoaW4gYm91bmRzKWApO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc29sZS5sb2coYFtERU1BTkQgREVCVUddICAgTk8gU01PT1RISU5HIChwcmV2RGVtYW5kU3RhdGUgY2hlY2sgZmFpbGVkOiAke3ByZXZEZW1hbmRTdGF0ZSA9PT0gbnVsbCA/ICdudWxsJyA6IHByZXZEZW1hbmRTdGF0ZS5ncm91bmREZW1hbmRHVyA9PT0gdW5kZWZpbmVkID8gJ3VuZGVmaW5lZCcgOiAnemVybyBvciBuZWdhdGl2ZSd9KWApO1xuICAgIH1cbiAgfVxuICBcbiAgY29uc3Qgb3JiaXRhbERlbWFuZEdXID0gZWZmZWN0aXZlR1cgLSBncm91bmREZW1hbmRHVztcbiAgXG4gIHJldHVybiB7XG4gICAgeWVhcixcbiAgICBiYXNlbGluZUdXLFxuICAgIGVmZmVjdGl2ZUdXLFxuICAgIGdyb3VuZERlbWFuZEdXLFxuICAgIG9yYml0YWxEZW1hbmRHVyxcbiAgICBvcmJpdGFsU2hhcmUsIC8vIFRyYWNrIGZvciBzbW9vdGhpbmcgaW4gbmV4dCBpdGVyYXRpb25cbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgaW5zdGFsbGVkIElUIGxvYWQgKEdXKSBmb3IgYSBnaXZlbiB5ZWFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJVExvYWRHVyh5ZWFyOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoeWVhciA8IDIwMjUpIHtcbiAgICByZXR1cm4gSVRfR1dfMjAyNTtcbiAgfVxuICBcbiAgaWYgKHllYXIgPD0gMjA0MCkge1xuICAgIC8vIFBoYXNlIDE6IDIwMjUtMjA0MFxuICAgIGNvbnN0IHllYXJzRnJvbTIwMjUgPSB5ZWFyIC0gMjAyNTtcbiAgICByZXR1cm4gSVRfR1dfMjAyNSAqIE1hdGguZXhwKFIxICogeWVhcnNGcm9tMjAyNSk7XG4gIH1cbiAgXG4gIC8vIFBoYXNlIDI6IDIwNDAtMjA2MFxuICBjb25zdCB5ZWFyc0Zyb20yMDQwID0geWVhciAtIDIwNDA7XG4gIHJldHVybiBJVF9HV18yMDQwX1RBUkdFVCAqIE1hdGguZXhwKFIyICogeWVhcnNGcm9tMjA0MCk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGZhY2lsaXR5IGxvYWQgKEdXKSA9IElUIGxvYWQgKiBQVUVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZhY2lsaXR5TG9hZEdXKHllYXI6IG51bWJlciwgcHVlOiBudW1iZXIgPSAxLjMpOiBudW1iZXIge1xuICBjb25zdCBpdExvYWRHVyA9IGdldElUTG9hZEdXKHllYXIpO1xuICByZXR1cm4gaXRMb2FkR1cgKiBwdWU7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIG5ldyBkZW1hbmQgKEdXKSA9IG1heCgwLCBGYWNpbGl0eV9HVyh0KSAtIEZhY2lsaXR5X0dXKHQtMSkpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZW1hbmROZXdHVyh5ZWFyOiBudW1iZXIsIHB1ZTogbnVtYmVyID0gMS4zKTogbnVtYmVyIHtcbiAgY29uc3QgZmFjaWxpdHlHVyA9IGdldEZhY2lsaXR5TG9hZEdXKHllYXIsIHB1ZSk7XG4gIGNvbnN0IGZhY2lsaXR5R1dQcmV2ID0gZ2V0RmFjaWxpdHlMb2FkR1coeWVhciAtIDEsIHB1ZSk7XG4gIHJldHVybiBNYXRoLm1heCgwLCBmYWNpbGl0eUdXIC0gZmFjaWxpdHlHV1ByZXYpO1xufVxuXG4vKipcbiAqIExlZ2FjeSBmdW5jdGlvbjogcmV0dXJucyBJVCBsb2FkIChub3QgZmFjaWxpdHkgbG9hZClcbiAqIEtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERlbWFuZFByb2plY3Rpb24oeWVhcjogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIGdldElUTG9hZEdXKHllYXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVRyYWplY3Rvcnkob3B0aW9uczogVHJhamVjdG9yeU9wdGlvbnMpOiBZZWFybHlCcmVha2Rvd25bXSB7XG4gIC8vIFJlLWV4cG9ydCBjcm9zc292ZXIgYW5hbHlzaXMgZnVuY3Rpb25zIGZvciBjb252ZW5pZW5jZVxuICAvLyBVc2VycyBjYW4gaW1wb3J0IGZyb20gdHJhamVjdG9yeS50cyBvciBjcm9zc292ZXJBbmFseXNpcy50c1xuICBjb25zdCB5ZWFycyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI2IH0sIChfLCBpKSA9PiAyMDI1ICsgaSk7IC8vIDIwMjUtMjA1MCAoMjYgeWVhcnMpXG4gIGNvbnN0IHRyYWplY3Rvcnk6IFllYXJseUJyZWFrZG93bltdID0gW107XG4gIGxldCBmaXJzdENhcFllYXI6IG51bWJlciB8IG51bGwgPSBudWxsOyAvLyBUcmFjayB3aGVuIGNvbnN0cmFpbnQgY2FwIHdhcyBmaXJzdCBoaXRcbiAgXG4gIC8vIExhdW5jaCBsZWFybmluZzogVHJhY2sgY3VtdWxhdGl2ZSBtYXNzIHRvIG9yYml0XG4gIGxldCBsYXVuY2hMZWFybmluZ1N0YXRlOiBMYXVuY2hMZWFybmluZ1N0YXRlIHwgbnVsbCA9IG51bGw7XG4gIGNvbnN0IEJBU0VMSU5FX01BU1NfS0cgPSAxXzAwMF8wMDA7IC8vIDFNIGtnIGJhc2VsaW5lIGZvciBkb3VibGluZ3MgY2FsY3VsYXRpb25cbiAgY29uc3QgTEFVTkNIX0NPU1RfMF9QRVJfS0cgPSAxNTAwOyAvLyBJbml0aWFsIGxhdW5jaCBjb3N0IGluIDIwMjVcbiAgXG4gIC8vIFJlc3BvbnNpdmUgZGVtYW5kOiBUcmFjayBkZW1hbmQgc3RhdGUgYWNyb3NzIHllYXJzIGZvciBTLWN1cnZlIGJlaGF2aW9yXG4gIGxldCBwcmV2RGVtYW5kU3RhdGU6IERlbWFuZFN0YXRlIHwgbnVsbCA9IG51bGw7XG4gIGxldCBwcmV2WWVhckJyZWFrZG93bjogWWVhcmx5QnJlYWtkb3duIHwgbnVsbCA9IG51bGw7XG4gIFxuICAvLyBCdWlsZG91dCBzdGF0ZTogVHJhY2sgYWNyb3NzIHllYXJzIGZvciBiYWNrbG9nIGNhbGN1bGF0aW9uXG4gIGxldCBidWlsZG91dFN0YXRlOiBpbXBvcnQoJy4vZ3JvdW5kX2J1aWxkb3V0JykuQnVpbGRvdXRTdGF0ZSB8IG51bGwgPSBudWxsO1xuICBcbiAgLy8gTW9iaWxpemF0aW9uIHN0YXRlOiBUcmFjayBhY3Jvc3MgeWVhcnMgZm9yIGNhcGFjaXR5L2JhY2tsb2cgZXZvbHV0aW9uXG4gIGxldCBtb2JpbGl6YXRpb25TdGF0ZTogaW1wb3J0KCcuL2dyb3VuZF9yYW1waW5nX21vYmlsaXphdGlvbicpLk1vYmlsaXphdGlvblN0YXRlIHwgbnVsbCA9IG51bGw7XG5cbiAgZm9yIChjb25zdCB5ZWFyIG9mIHllYXJzKSB7XG4gICAgY29uc3QgcGFyYW1zID0gb3B0aW9ucy5tb2RlID09PSAnU1RBVElDJyBcbiAgICAgID8gZ2V0U3RhdGljUGFyYW1zKHllYXIpXG4gICAgICA6IG9wdGlvbnMucGFyYW1zQnlZZWFyKHllYXIpO1xuXG4gICAgLy8gQXBwbHkgbGF1bmNoIGxlYXJuaW5nIGlmIGVuYWJsZWRcbiAgICBsZXQgbGF1bmNoQ29zdFBlcktnID0gZ2V0TGF1bmNoQ29zdFBlcktnKHllYXIsIHBhcmFtcy5sYXVuY2hDb3N0S2cpO1xuICAgIGxldCBwYXJhbXNXaXRoTGF1bmNoQ29zdCA9IHBhcmFtcztcbiAgICBpZiAob3B0aW9ucy51c2VMYXVuY2hMZWFybmluZykge1xuICAgICAgLy8gRXN0aW1hdGUgbWFzcyBkZW1hbmRlZCBmcm9tIGNvbXB1dGUgcG93ZXI6IH4xMDAwIGtnIHBlciBNVyBjb21wdXRlXG4gICAgICAvLyBVc2UgdGFyZ2V0R1cgYXMgcHJveHkgZm9yIG9yYml0YWwgY29tcHV0ZSBkZW1hbmRcbiAgICAgIGNvbnN0IGNvbXB1dGVQb3dlck1XID0gcGFyYW1zLnRhcmdldEdXICogMTAwMDsgLy8gQ29udmVydCBHVyB0byBNV1xuICAgICAgY29uc3QgbWFzc1Blck1XID0gMTAwMDsgLy8gUm91Z2ggZXN0aW1hdGU6IDEwMDAga2cgcGVyIE1XXG4gICAgICBjb25zdCBtYXNzRGVtYW5kZWRLZyA9IGNvbXB1dGVQb3dlck1XICogbWFzc1Blck1XO1xuICAgICAgXG4gICAgICBjb25zdCBsYXVuY2hMZWFybmluZ1Jlc3VsdCA9IHN0ZXBMYXVuY2hMZWFybmluZyhsYXVuY2hMZWFybmluZ1N0YXRlLCB7XG4gICAgICAgIHllYXIsXG4gICAgICAgIG1hc3NEZW1hbmRlZEtnLFxuICAgICAgICBiYXNlbGluZU1hc3NLZzogQkFTRUxJTkVfTUFTU19LRyxcbiAgICAgICAgbGF1bmNoQ29zdDBQZXJLZzogTEFVTkNIX0NPU1RfMF9QRVJfS0csXG4gICAgICAgIGxlYXJuaW5nUmF0ZTogMC4xNSwgLy8gMTUlIHJlZHVjdGlvbiBwZXIgZG91YmxpbmdcbiAgICAgICAgbWF4RmxpZ2h0c1BlclllYXI6IDEwMDAsXG4gICAgICAgIHBheWxvYWRQZXJGbGlnaHRLZzogMTAwXzAwMCwgLy8gU3RhcnNoaXAgY2FwYWNpdHlcbiAgICAgIH0pO1xuICAgICAgbGF1bmNoQ29zdFBlcktnID0gbGF1bmNoTGVhcm5pbmdSZXN1bHQubGF1bmNoQ29zdFBlcktnO1xuICAgICAgbGF1bmNoTGVhcm5pbmdTdGF0ZSA9IGxhdW5jaExlYXJuaW5nUmVzdWx0LnN0YXRlO1xuICAgICAgXG4gICAgICAvLyBPdmVycmlkZSBsYXVuY2ggY29zdCBpbiBwYXJhbXMgZm9yIHRoaXMgeWVhclxuICAgICAgcGFyYW1zV2l0aExhdW5jaENvc3QgPSB7IC4uLnBhcmFtcywgbGF1bmNoQ29zdEtnOiBsYXVuY2hDb3N0UGVyS2cgfTtcbiAgICB9XG5cbiAgICAvLyBTSU5HTEUgU09VUkNFIE9GIFRSVVRIOiBjb21wdXRlIGRlbWFuZCBpbiBHVyB1c2luZyBSRVNQT05TSVZFIGRlbWFuZFxuICAgIC8vIERlbWFuZCByZXNwb25kcyB0byBwcmljZXMsIHdhaXQgdGltZXMsIGFuZCBvcmJpdGFsIHN1YnN0aXR1dGlvbiAoY3JlYXRlcyBTLWN1cnZlKVxuICAgIC8vIE5PVEU6IFdlIHVzZSBQUkVWSU9VUyB5ZWFyJ3MgcHJpY2VzIHRvIGNhbGN1bGF0ZSBjdXJyZW50IHllYXIncyBkZW1hbmQgKGF2b2lkcyBjaXJjdWxhciBkZXBlbmRlbmN5KVxuICAgIGNvbnN0IGdyb3VuZFB1ZSA9IHBhcmFtcy5wdWVHcm91bmQgPz8gMS4zO1xuICAgIFxuICAgIC8vIEdldCBwcmljZXMgZnJvbSBwcmV2aW91cyB5ZWFyIChvciBlc3RpbWF0ZXMgZm9yIGZpcnN0IHllYXIpXG4gICAgY29uc3QgcHJldkdyb3VuZFByaWNlID0gcHJldlllYXJCcmVha2Rvd24/Lmdyb3VuZD8uZ3B1SG91clByaWNpbmc/LnN0YW5kYXJkPy5wcmljZVBlckdwdUhvdXIgPz8gNC4wMDtcbiAgICBjb25zdCBwcmV2T3JiaXRhbFByaWNlID0gcHJldlllYXJCcmVha2Rvd24/Lm9yYml0Py5ncHVIb3VyUHJpY2luZz8uc3RhbmRhcmQ/LnByaWNlUGVyR3B1SG91ciA/PyAyNS4wMDtcbiAgICBjb25zdCBwcmV2QXZnV2FpdCA9IHByZXZZZWFyQnJlYWtkb3duPy5ncm91bmQ/LnN1cHBseU1ldHJpY3M/LmF2Z1dhaXRZZWFycyA/PyAwO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSByZXNwb25zaXZlIGRlbWFuZCAocHJpY2Uvd2FpdCBlbGFzdGljLCBvcmJpdGFsIHN1YnN0aXR1dGlvbilcbiAgICBjb25zdCBkZW1hbmRTdGF0ZSA9IGNhbGN1bGF0ZVJlc3BvbnNpdmVEZW1hbmQoXG4gICAgICB5ZWFyLFxuICAgICAgcHJldkdyb3VuZFByaWNlLFxuICAgICAgcHJldk9yYml0YWxQcmljZSxcbiAgICAgIHByZXZBdmdXYWl0LFxuICAgICAgcHJldkRlbWFuZFN0YXRlXG4gICAgKTtcbiAgICBwcmV2RGVtYW5kU3RhdGUgPSBkZW1hbmRTdGF0ZTtcbiAgICBcbiAgICAvLyBQYXNzIGZpcnN0Q2FwWWVhciwgbW9iaWxpemF0aW9uU3RhdGUsIGFuZCByZXNwb25zaXZlIGRlbWFuZCB0byBjb21wdXRlUGh5c2ljc0Nvc3RcbiAgICAvLyBBZGQgbW9iaWxpemF0aW9uIHN0YXRlIGFuZCByZXNwb25zaXZlIGRlbWFuZCB0byBwYXJhbXMgc28gdGhleSBjYW4gYmUgdXNlZCBmb3IgYmFja2xvZyBjYWxjdWxhdGlvblxuICAgIGNvbnN0IHBhcmFtc1dpdGhNb2JpbGl6YXRpb24gPSB7XG4gICAgICAuLi5wYXJhbXNXaXRoTGF1bmNoQ29zdCxcbiAgICAgIHByZXZNb2JpbGl6YXRpb25TdGF0ZTogbW9iaWxpemF0aW9uU3RhdGUsXG4gICAgICByZXNwb25zaXZlRGVtYW5kR1c6IGRlbWFuZFN0YXRlLmdyb3VuZERlbWFuZEdXLCAvLyBSZXNwb25zaXZlIGdyb3VuZCBkZW1hbmQgKElUIGxvYWQsIG5vdCBmYWNpbGl0eSlcbiAgICAgIG9yYml0YWxTdWJzdGl0dXRpb25HVzogZGVtYW5kU3RhdGUub3JiaXRhbERlbWFuZEdXLCAvLyBEZW1hbmQgc2hpZnRlZCB0byBvcmJpdGFsIChmb3IgYmFja2xvZyBkcmFpbilcbiAgICB9IGFzIGFueTsgLy8gVHlwZSBhc3NlcnRpb24gbmVlZGVkIHNpbmNlIFllYXJQYXJhbXMgZG9lc24ndCBpbmNsdWRlIHRoZXNlIGZpZWxkc1xuICAgIGNvbnN0IGJyZWFrZG93biA9IGNvbXB1dGVQaHlzaWNzQ29zdChwYXJhbXNXaXRoTW9iaWxpemF0aW9uLCBmaXJzdENhcFllYXIpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBsYXVuY2ggbGVhcm5pbmcgc3RhdGUgd2l0aCBhY3R1YWwgbWFzcyBmcm9tIGJyZWFrZG93biAoZm9yIG5leHQgaXRlcmF0aW9uKVxuICAgIGlmIChvcHRpb25zLnVzZUxhdW5jaExlYXJuaW5nICYmIGJyZWFrZG93bi5vcmJpdCAmJiBicmVha2Rvd24ub3JiaXQuaHlicmlkQnJlYWtkb3duKSB7XG4gICAgICAvLyBVc2UgYWN0dWFsIG1hc3MgZnJvbSBoeWJyaWQgYnJlYWtkb3duIGlmIGF2YWlsYWJsZVxuICAgICAgLy8gTWFzcyBpcyBub3QgZGlyZWN0bHkgaW4gb3JiaXRhbCBicmVha2Rvd24sIGJ1dCB3ZSBjYW4gZXN0aW1hdGUgZnJvbSBsYXVuY2ggY29zdFxuICAgICAgLy8gRm9yIG5vdywgdXNlIHRoZSBtYXNzIGRlbWFuZGVkIGVzdGltYXRlICh3aWxsIGJlIHJlZmluZWQgaW4gbmV4dCBpdGVyYXRpb24pXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGNvbnN0cmFpbnRCcmVha2Rvd24gPSBicmVha2Rvd24uZ3JvdW5kLmNvbnN0cmFpbnRCcmVha2Rvd247XG4gICAgaWYgKGNvbnN0cmFpbnRCcmVha2Rvd24gJiYgJ2NhcFllYXInIGluIGNvbnN0cmFpbnRCcmVha2Rvd24gJiYgY29uc3RyYWludEJyZWFrZG93bi5jYXBZZWFyICE9PSBudWxsICYmIGNvbnN0cmFpbnRCcmVha2Rvd24uY2FwWWVhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCB0aGlzQ2FwWWVhciA9IGNvbnN0cmFpbnRCcmVha2Rvd24uY2FwWWVhciBhcyBudW1iZXI7XG4gICAgICBpZiAoZmlyc3RDYXBZZWFyID09PSBudWxsIHx8IHRoaXNDYXBZZWFyIDwgZmlyc3RDYXBZZWFyKSB7XG4gICAgICAgIGZpcnN0Q2FwWWVhciA9IHRoaXNDYXBZZWFyO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBVc2UgcmVzcG9uc2l2ZSBncm91bmQgZGVtYW5kIChmYWNpbGl0eSBsb2FkID0gZ3JvdW5kIGRlbWFuZCAqIFBVRSlcbiAgICBjb25zdCBhY3R1YWxHcm91bmRQdWUgPSBicmVha2Rvd24uZ3JvdW5kPy5wdWUgPz8gZ3JvdW5kUHVlO1xuICAgIGNvbnN0IGRlbWFuZENvbXB1dGVHVyA9IGRlbWFuZFN0YXRlLmdyb3VuZERlbWFuZEdXICogYWN0dWFsR3JvdW5kUHVlOyAvLyBDb252ZXJ0IElUIGxvYWQgdG8gZmFjaWxpdHkgbG9hZFxuICAgIGNvbnN0IG9yYml0YWxEZW1hbmRHVyA9IGRlbWFuZFN0YXRlLm9yYml0YWxEZW1hbmRHVyAqIGFjdHVhbEdyb3VuZFB1ZTsgLy8gRm9yIG9yYml0YWwgY2FwYWNpdHkgcGxhbm5pbmdcbiAgICBcbiAgICAvLyBDUklUSUNBTDogRW5zdXJlIGdyb3VuZC5idWlsZG91dERlYnVnLmRlbWFuZEdXIG1hdGNoZXMgc2luZ2xlIHNvdXJjZSBvZiB0cnV0aFxuICAgIC8vIE92ZXJyaWRlIGFueSB2YWx1ZSBmcm9tIGJ1aWxkb3V0IG1vZGVsIHRvIGVuc3VyZSBjb25zaXN0ZW5jeVxuICAgIGlmIChicmVha2Rvd24uZ3JvdW5kPy5idWlsZG91dERlYnVnKSB7XG4gICAgICBicmVha2Rvd24uZ3JvdW5kLmJ1aWxkb3V0RGVidWcuZGVtYW5kR1cgPSBkZW1hbmRDb21wdXRlR1c7XG4gICAgfVxuICAgIFxuICAgIC8vIFVzZSBkZW1hbmRDb21wdXRlR1cgZm9yIGFsbCBtYXJrZXQgY2FsY3VsYXRpb25zIChzaW5nbGUgc291cmNlIG9mIHRydXRoKVxuICAgIGNvbnN0IHRvdGFsRGVtYW5kR1cgPSBkZW1hbmRDb21wdXRlR1c7XG4gICAgXG4gICAgY29uc3Qgb3JiaXRhbEZlYXNpYmxlID0gYnJlYWtkb3duLm9yYml0ICYmIGJyZWFrZG93bi5vcmJpdC50b3RhbENvc3RQZXJQZmxvcFllYXIgPiAwICYmIGJyZWFrZG93bi5vcmJpdC50b3RhbENvc3RQZXJQZmxvcFllYXIgPCBJbmZpbml0eTtcbiAgICBjb25zdCBncm91bmRGZWFzaWJsZSA9IGJyZWFrZG93bi5ncm91bmQgJiYgYnJlYWtkb3duLmdyb3VuZC50b3RhbENvc3RQZXJQZmxvcFllYXIgPiAwICYmIGJyZWFrZG93bi5ncm91bmQudG90YWxDb3N0UGVyUGZsb3BZZWFyIDwgSW5maW5pdHk7XG4gICAgY29uc3Qgb3JiaXRhbENvc3RBY2NvdW50aW5nVmFsaWQgPSBicmVha2Rvd24uY29zdEFjY291bnRpbmdWYWxpZCAhPT0gZmFsc2U7XG4gICAgY29uc3QgZ3JvdW5kQ29zdEFjY291bnRpbmdWYWxpZCA9IGJyZWFrZG93bi5jb3N0QWNjb3VudGluZ1ZhbGlkICE9PSBmYWxzZTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgb3JiaXRhbCBjYXBhY2l0eSBHVyBmcm9tIGNvbnN0ZWxsYXRpb246IChudW1TYXRlbGxpdGVzICogY29tcHV0ZVBlclNhdEt3KSAvIDFlNlxuICAgIC8vIGtXIC0+IEdXIGNvbnZlcnNpb246IGRpdmlkZSBieSAxLDAwMCwwMDAgKDFlNilcbiAgICAvLyBDUklUSUNBTDogY29tcHV0ZVBlclNhdEt3IGlzIGluIGtXLCBzbyBkaXZpZGUgYnkgMWU2IHRvIGdldCBHVyAobm90IDFlMyBmb3IgTVcpXG4gICAgbGV0IG9yYml0YWxDYXBhY2l0eUdXX2Zyb21TYXRzID0gMDtcbiAgICBpZiAoYnJlYWtkb3duLm9yYml0Py5jb25zdGVsbGF0aW9uPy5kZXNpZ24pIHtcbiAgICAgIGNvbnN0IHsgbnVtU2F0ZWxsaXRlcywgY29tcHV0ZVBlclNhdEt3IH0gPSBicmVha2Rvd24ub3JiaXQuY29uc3RlbGxhdGlvbi5kZXNpZ247XG4gICAgICAvLyBrVyAtPiBHVzogZGl2aWRlIGJ5IDEsMDAwLDAwMCAoMWU2KSwgTk9UIDEsMDAwICgxZTMpXG4gICAgICBvcmJpdGFsQ2FwYWNpdHlHV19mcm9tU2F0cyA9IChudW1TYXRlbGxpdGVzICogY29tcHV0ZVBlclNhdEt3KSAvIDFfMDAwXzAwMDtcbiAgICAgIFxuICAgICAgLy8gSW52YXJpYW50OiAxIHNhdGVsbGl0ZSBhdCAxMTEga1cgc2hvdWxkIGJlIDAuMDAwMTExIEdXLCBub3QgMS4xNDQgR1dcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBudW1TYXRlbGxpdGVzID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkR1cgPSBjb21wdXRlUGVyU2F0S3cgLyAxXzAwMF8wMDA7XG4gICAgICAgIGNvbnN0IGVycm9yID0gTWF0aC5hYnMob3JiaXRhbENhcGFjaXR5R1dfZnJvbVNhdHMgLSBleHBlY3RlZEdXKSAvIE1hdGgubWF4KGV4cGVjdGVkR1csIDFlLTkpO1xuICAgICAgICBpZiAoZXJyb3IgPiAwLjAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFtPUkJJVEFMIENBUEFDSVRZIEJVR10gWWVhciAke3llYXJ9OiAxIHNhdGVsbGl0ZSBhdCAke2NvbXB1dGVQZXJTYXRLd30ga1cgc2hvdWxkIGJlICR7ZXhwZWN0ZWRHV30gR1csIGAgK1xuICAgICAgICAgICAgYGJ1dCBnb3QgJHtvcmJpdGFsQ2FwYWNpdHlHV19mcm9tU2F0c30gR1cuIENoZWNrIGtXLT5HVyBjb252ZXJzaW9uIChtdXN0IGRpdmlkZSBieSAxZTYsIG5vdCAxZTMpLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGNoYXJ0UEIgPSBicmVha2Rvd24ubWV0YWRhdGE/LmNoYXJ0SW5wdXRzPy5wb3dlckJ1aWxkb3V0O1xuICAgIGNvbnN0IGNoYXJ0QmFja2xvZyA9IGNoYXJ0UEI/LmJhY2tsb2dHdztcbiAgICBjb25zdCBjaGFydEF2Z1dhaXQgPSBjaGFydFBCPy5hdmdXYWl0WWVhcnM7XG4gICAgY29uc3QgY2hhcnRCdWlsZFJhdGUgPSBjaGFydFBCPy5tYXhCdWlsZFJhdGVHd1llYXI7XG4gICAgXG4gICAgLy8gUHJlZmVyIGJ1aWxkb3V0RGVidWcgd2hlbiBwcmVzZW50LlxuICAgIC8vIElmIGdyb3VuZC9iYWNrbG9nIGZpZWxkcyBleGlzdCBidXQgYXJlIDAgd2hpbGUgY2hhcnRJbnB1dHMgc2F5cyA+MCwgdXNlIGNoYXJ0SW5wdXRzLlxuICAgIC8vIFJlbW92ZSB0aGUgcGlwZWxpbmVHdyBwcm94eSBlbnRpcmVseSAoaXQncyBub3QgYmFja2xvZyBhbmQgY2F1c2VzIHNpbGVudCB1bml0L21lYW5pbmcgY29ycnVwdGlvbikuXG4gICAgY29uc3QgYmFja2xvZ0Zyb21Hcm91bmQgPSBicmVha2Rvd24uZ3JvdW5kPy5iYWNrbG9nR3c7XG4gICAgY29uc3QgYmFja2xvZ0Zyb21CdWlsZG91dCA9IGJyZWFrZG93bi5ncm91bmQ/LmJ1aWxkb3V0RGVidWc/LmJhY2tsb2dHVztcbiAgICBsZXQgYmFja2xvZ0dXID1cbiAgICAgIChiYWNrbG9nRnJvbUJ1aWxkb3V0ICE9PSB1bmRlZmluZWQgPyBiYWNrbG9nRnJvbUJ1aWxkb3V0IDogdW5kZWZpbmVkKSA/P1xuICAgICAgKChiYWNrbG9nRnJvbUdyb3VuZCAhPT0gdW5kZWZpbmVkICYmIGJhY2tsb2dGcm9tR3JvdW5kID4gMCkgPyBiYWNrbG9nRnJvbUdyb3VuZCA6IHVuZGVmaW5lZCkgPz9cbiAgICAgICgoY2hhcnRCYWNrbG9nICE9PSB1bmRlZmluZWQgJiYgY2hhcnRCYWNrbG9nID4gMCkgPyBjaGFydEJhY2tsb2cgOiAwKTtcbiAgICBcbiAgICBjb25zdCBidWlsZFJhdGVGcm9tQnVpbGRvdXQgPSBicmVha2Rvd24uZ3JvdW5kPy5idWlsZG91dERlYnVnPy5idWlsZFJhdGVHV3lyO1xuICAgIGNvbnN0IGJ1aWxkUmF0ZUZyb21TdXBwbHkgPSBicmVha2Rvd24uZ3JvdW5kPy5zdXBwbHlNZXRyaWNzPy5tYXhCdWlsZFJhdGVHd1llYXI7XG4gICAgY29uc3QgYnVpbGRSYXRlR1d5ciA9XG4gICAgICAoYnVpbGRSYXRlRnJvbUJ1aWxkb3V0ICE9PSB1bmRlZmluZWQgPyBidWlsZFJhdGVGcm9tQnVpbGRvdXQgOiB1bmRlZmluZWQpID8/XG4gICAgICAoYnVpbGRSYXRlRnJvbVN1cHBseSAhPT0gdW5kZWZpbmVkID8gYnVpbGRSYXRlRnJvbVN1cHBseSA6IHVuZGVmaW5lZCkgPz9cbiAgICAgIChjaGFydEJ1aWxkUmF0ZSAhPT0gdW5kZWZpbmVkID8gY2hhcnRCdWlsZFJhdGUgOiAwKTtcbiAgICBcbiAgICBjb25zdCBhdmdXYWl0RnJvbUdyb3VuZCA9IGJyZWFrZG93bi5ncm91bmQ/LmF2Z1dhaXRZZWFycztcbiAgICBjb25zdCBhdmdXYWl0RnJvbUJ1aWxkb3V0ID0gYnJlYWtkb3duLmdyb3VuZD8uYnVpbGRvdXREZWJ1Zz8udGltZVRvUG93ZXJZZWFycztcbiAgICBjb25zdCBhdmdXYWl0RnJvbVN1cHBseSA9IGJyZWFrZG93bi5ncm91bmQ/LnN1cHBseU1ldHJpY3M/LmF2Z1dhaXRZZWFycztcbiAgICBsZXQgYXZnV2FpdFllYXJzID1cbiAgICAgIChhdmdXYWl0RnJvbUJ1aWxkb3V0ICE9PSB1bmRlZmluZWQgPyBhdmdXYWl0RnJvbUJ1aWxkb3V0IDogdW5kZWZpbmVkKSA/P1xuICAgICAgKChhdmdXYWl0RnJvbUdyb3VuZCAhPT0gdW5kZWZpbmVkICYmIGF2Z1dhaXRGcm9tR3JvdW5kID4gMCkgPyBhdmdXYWl0RnJvbUdyb3VuZCA6IHVuZGVmaW5lZCkgPz9cbiAgICAgICgoYXZnV2FpdEZyb21TdXBwbHkgIT09IHVuZGVmaW5lZCAmJiBhdmdXYWl0RnJvbVN1cHBseSA+IDApID8gYXZnV2FpdEZyb21TdXBwbHkgOiB1bmRlZmluZWQpID8/XG4gICAgICAoKGNoYXJ0QXZnV2FpdCAhPT0gdW5kZWZpbmVkICYmIGNoYXJ0QXZnV2FpdCA+IDApID8gY2hhcnRBdmdXYWl0IDogMCk7XG4gICAgXG4gICAgLy8gU2VsZi1oZWFsIHBsdW1iaW5nIG1pc21hdGNoZXM6IGlmIGNoYXJ0SW5wdXRzIGhhcyBwb3NpdGl2ZSB2YWx1ZSBidXQgY2hvc2VuIGlzIDAsIHVzZSBjaGFydElucHV0c1xuICAgIC8vIExvZyBzdHJ1Y3R1cmVkIGVycm9yIGJ1dCBuZXZlciB0aHJvdyAocHJldmVudHMgY2hhcnQgZnJvbSBkaXNhcHBlYXJpbmcpXG4gICAgaWYgKChjaGFydEJhY2tsb2cgPz8gMCkgPiAwICYmIGJhY2tsb2dHVyA9PT0gMCAmJiBjaGFydEJhY2tsb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmFja2xvZ0dXID0gY2hhcnRCYWNrbG9nO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgW0JBQ0tMT0cgUExVTUJJTkddIFllYXIgJHt5ZWFyfTogY2hhcnRJbnB1dHMuYmFja2xvZ0d3PSR7Y2hhcnRCYWNrbG9nfSBidXQgZmFsbGJhY2sgY2hhaW4gcmV0dXJuZWQgMC4gYCArXG4gICAgICAgICAgYFNlbGYtaGVhbGVkOiB1c2luZyBjaGFydElucHV0cy4gYCArXG4gICAgICAgICAgYENhbmRpZGF0ZXM6IGdyb3VuZC5iYWNrbG9nR3c9JHticmVha2Rvd24uZ3JvdW5kPy5iYWNrbG9nR3d9LCBgICtcbiAgICAgICAgICBgYnVpbGRvdXREZWJ1Zy5iYWNrbG9nR1c9JHticmVha2Rvd24uZ3JvdW5kPy5idWlsZG91dERlYnVnPy5iYWNrbG9nR1d9LCBgICtcbiAgICAgICAgICBgc3VwcGx5TWV0cmljcy5waXBlbGluZUd3PSR7YnJlYWtkb3duLmdyb3VuZD8uc3VwcGx5TWV0cmljcz8ucGlwZWxpbmVHd31gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgoY2hhcnRBdmdXYWl0ID8/IDApID4gMCAmJiBhdmdXYWl0WWVhcnMgPT09IDAgJiYgY2hhcnRBdmdXYWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGF2Z1dhaXRZZWFycyA9IGNoYXJ0QXZnV2FpdDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYFtXQUlUIFBMVU1CSU5HXSBZZWFyICR7eWVhcn06IGNoYXJ0SW5wdXRzLmF2Z1dhaXRZZWFycz0ke2NoYXJ0QXZnV2FpdH0gYnV0IGZhbGxiYWNrIGNoYWluIHJldHVybmVkIDAuIGAgK1xuICAgICAgICAgIGBTZWxmLWhlYWxlZDogdXNpbmcgY2hhcnRJbnB1dHMuIGAgK1xuICAgICAgICAgIGBDYW5kaWRhdGVzOiBncm91bmQuYXZnV2FpdFllYXJzPSR7YnJlYWtkb3duLmdyb3VuZD8uYXZnV2FpdFllYXJzfSwgYCArXG4gICAgICAgICAgYGJ1aWxkb3V0RGVidWcudGltZVRvUG93ZXJZZWFycz0ke2JyZWFrZG93bi5ncm91bmQ/LmJ1aWxkb3V0RGVidWc/LnRpbWVUb1Bvd2VyWWVhcnN9LCBgICtcbiAgICAgICAgICBgc3VwcGx5TWV0cmljcy5hdmdXYWl0WWVhcnM9JHticmVha2Rvd24uZ3JvdW5kPy5zdXBwbHlNZXRyaWNzPy5hdmdXYWl0WWVhcnN9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgb3JiaXRNYXhEZXBsb3lhYmxlQ29tcHV0ZUdXIGZyb20gY29uc3RlbGxhdGlvbiBjYXBhY2l0eSBvciBzY2VuYXJpbyBwYXJhbXNcbiAgICAvLyBDYW5vbmljYWwgb3JiaXRhbCBjYXBhY2l0eSBmcm9tIGNvbnN0ZWxsYXRpb246IChudW1TYXRlbGxpdGVzICogY29tcHV0ZVBlclNhdEt3KSAvIDFlNlxuICAgIGNvbnN0IG9yYml0TWF4RGVwbG95YWJsZUNvbXB1dGVHVyA9IG9yYml0YWxGZWFzaWJsZSBcbiAgICAgID8gKHBhcmFtcy5vcmJpdE1heERlcGxveWFibGVDb21wdXRlR1dCeVllYXI/Lih5ZWFyKSA/PyBvcmJpdGFsQ2FwYWNpdHlHV19mcm9tU2F0cylcbiAgICAgIDogMDtcbiAgICBcbiAgICAvLyBGaXggb3JiaXQgZmVhc2liaWxpdHkgZ2F0aW5nOiB1c2Ugb3JiaXRNYXhEZXBsb3lhYmxlQ29tcHV0ZUdXLCBub3Qgb3JiaXRhbENhcGFjaXR5R1cgcGxhY2Vob2xkZXJcbiAgICBjb25zdCBvcmJpdGFsRmVhc2libGVGb3JTaGFyZSA9IG9yYml0YWxGZWFzaWJsZSAmJiAob3JiaXRNYXhEZXBsb3lhYmxlQ29tcHV0ZUdXID4gMCk7XG4gICAgXG4gICAgY29uc3QgbWFya2V0QW5hbHlzaXMgPSBjYWxjdWxhdGVNYXJrZXRTaGFyZShcbiAgICAgIHllYXIsXG4gICAgICBicmVha2Rvd24ub3JiaXQudG90YWxDb3N0UGVyUGZsb3BZZWFyLFxuICAgICAgYnJlYWtkb3duLmdyb3VuZC50b3RhbENvc3RQZXJQZmxvcFllYXIsXG4gICAgICB0b3RhbERlbWFuZEdXLFxuICAgICAgb3JiaXRhbEZlYXNpYmxlRm9yU2hhcmUsXG4gICAgICBncm91bmRGZWFzaWJsZSxcbiAgICAgIG9yYml0YWxDb3N0QWNjb3VudGluZ1ZhbGlkLFxuICAgICAgZ3JvdW5kQ29zdEFjY291bnRpbmdWYWxpZCxcbiAgICAgIGRlbWFuZENvbXB1dGVHVywgLy8gVXNlIHNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGgsIG5vdCBncm91bmQgbW9kZWwgZGVtYW5kXG4gICAgICBiYWNrbG9nR1csXG4gICAgICBidWlsZFJhdGVHV3lyLFxuICAgICAgYXZnV2FpdFllYXJzLFxuICAgICAgb3JiaXRNYXhEZXBsb3lhYmxlQ29tcHV0ZUdXXG4gICAgKTtcbiAgICBcbiAgICBicmVha2Rvd24ubWFya2V0ID0ge1xuICAgICAgdG90YWxEZW1hbmRHVzogZGVtYW5kQ29tcHV0ZUdXLCAvLyBVc2Ugc2luZ2xlIHNvdXJjZSBvZiB0cnV0aCAobm90IG1hcmtldEFuYWx5c2lzLnRvdGFsRGVtYW5kR1cgd2hpY2ggbWF5IGRpZmZlcilcbiAgICAgIG9yYml0YWxTaGFyZUZyYWM6IG1hcmtldEFuYWx5c2lzLm9yYml0YWxTaGFyZUZyYWMsXG4gICAgICBvcmJpdGFsQ2FwYWNpdHlHVzogbWFya2V0QW5hbHlzaXMub3JiaXRhbENhcGFjaXR5R1csXG4gICAgICBvcmJpdGFsUmV2ZW51ZTogbWFya2V0QW5hbHlzaXMub3JiaXRhbFJldmVudWUsXG4gICAgICBncm91bmRTaGFyZUZyYWM6IG1hcmtldEFuYWx5c2lzLmdyb3VuZFNoYXJlRnJhYyxcbiAgICAgIGdyb3VuZENhcGFjaXR5R1c6IG1hcmtldEFuYWx5c2lzLmdyb3VuZENhcGFjaXR5R1csXG4gICAgICBkZWJ1Zzoge1xuICAgICAgICAuLi5tYXJrZXRBbmFseXNpcy5kZWJ1ZyxcbiAgICAgICAgZGVtYW5kQ29tcHV0ZUdXOiBkZW1hbmRDb21wdXRlR1csIC8vIFNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGhcbiAgICAgICAgb3JiaXRhbENhcGFjaXR5R1dfZnJvbVNhdHM6IG9yYml0YWxDYXBhY2l0eUdXX2Zyb21TYXRzLCAvLyBDYW5vbmljYWwgY2FwYWNpdHkgZnJvbSBjb25zdGVsbGF0aW9uIChmb3IgdmFsaWRhdGlvbilcbiAgICAgIH0gYXMgTWFya2V0QW5hbHlzaXNbJ2RlYnVnJ10sIC8vIFR5cGUgYXNzZXJ0aW9uIHRvIGFsbG93IG9yYml0YWxDYXBhY2l0eUdXX2Zyb21TYXRzXG4gICAgfTtcbiAgICBcbiAgICAvLyBJbnZhcmlhbnQ6IGRlbWFuZCBzY2FsYXIgY29uc2lzdGVuY3lcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgYnJlYWtkb3duLm1hcmtldCkge1xuICAgICAgY29uc3QgbWFya2V0RGVtYW5kID0gYnJlYWtkb3duLm1hcmtldC50b3RhbERlbWFuZEdXO1xuICAgICAgY29uc3QgbWFya2V0RGVidWdEZW1hbmQgPSBicmVha2Rvd24ubWFya2V0LmRlYnVnPy5kZW1hbmRDb21wdXRlR1c7XG4gICAgICBjb25zdCBidWlsZG91dERlbWFuZCA9IGJyZWFrZG93bi5ncm91bmQ/LmJ1aWxkb3V0RGVidWc/LmRlbWFuZEdXO1xuICAgICAgXG4gICAgICBpZiAobWFya2V0RGVidWdEZW1hbmQgIT09IHVuZGVmaW5lZCAmJiBNYXRoLmFicyhtYXJrZXREZW1hbmQgLSBtYXJrZXREZWJ1Z0RlbWFuZCkgPiAxZS02KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgW0RFTUFORCBTQ0FMQVIgQlVHXSBZZWFyICR7eWVhcn06IG1hcmtldC50b3RhbERlbWFuZEdXPSR7bWFya2V0RGVtYW5kfSAhPSBgICtcbiAgICAgICAgICBgbWFya2V0LmRlYnVnLmRlbWFuZENvbXB1dGVHVz0ke21hcmtldERlYnVnRGVtYW5kfS4gTXVzdCBiZSBlcXVhbC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChidWlsZG91dERlbWFuZCAhPT0gdW5kZWZpbmVkICYmIE1hdGguYWJzKG1hcmtldERlbWFuZCAtIGJ1aWxkb3V0RGVtYW5kKSA+IDFlLTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBbREVNQU5EIFNDQUxBUiBCVUddIFllYXIgJHt5ZWFyfTogbWFya2V0LnRvdGFsRGVtYW5kR1c9JHttYXJrZXREZW1hbmR9ICE9IGAgK1xuICAgICAgICAgIGBncm91bmQuYnVpbGRvdXREZWJ1Zy5kZW1hbmRHVz0ke2J1aWxkb3V0RGVtYW5kfS4gTXVzdCBiZSBlcXVhbC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBtb2JpbGl6YXRpb24gc3RhdGUgZm9yIG5leHQgeWVhciAodXNlIGV4dHJhY3RlZCB2YWx1ZXMsIG5vdCBicmVha2Rvd24uZ3JvdW5kIHdoaWNoIG1pZ2h0IGJlIDApXG4gICAgaWYgKGJyZWFrZG93bi5ncm91bmQ/LmJ1aWxkb3V0RGVidWcpIHtcbiAgICAgIGNvbnN0IGJ1aWxkb3V0RGVidWcgPSBicmVha2Rvd24uZ3JvdW5kLmJ1aWxkb3V0RGVidWc7XG4gICAgICBtb2JpbGl6YXRpb25TdGF0ZSA9IHtcbiAgICAgICAgeWVhcixcbiAgICAgICAgZGVtYW5kR1c6IGJ1aWxkb3V0RGVidWcuZGVtYW5kR1cgPz8gMCxcbiAgICAgICAgZGVtYW5kTmV3R1c6IGJ1aWxkb3V0RGVidWcuZGVtYW5kTmV3R1csXG4gICAgICAgIGJ1aWxkUmF0ZUdXeXI6IGJ1aWxkb3V0RGVidWcuYnVpbGRSYXRlR1d5ciA/PyBidWlsZFJhdGVHV3lyLFxuICAgICAgICBjYXBhY2l0eUdXOiBidWlsZG91dERlYnVnLmNhcGFjaXR5R1cgPz8gMCxcbiAgICAgICAgcGlwZWxpbmVHVzogYnVpbGRvdXREZWJ1Zy5waXBlbGluZUdXID8/IDAsXG4gICAgICAgIGJhY2tsb2dHVzogYmFja2xvZ0dXLCAvLyBVc2UgZXh0cmFjdGVkIHZhbHVlLCBub3QgYnJlYWtkb3duLmdyb3VuZC5iYWNrbG9nR3cgd2hpY2ggbWlnaHQgYmUgMFxuICAgICAgICBhdmdXYWl0WWVhcnM6IGF2Z1dhaXRZZWFycywgLy8gVXNlIGV4dHJhY3RlZCB2YWx1ZSwgbm90IGJyZWFrZG93bi5ncm91bmQuYXZnV2FpdFllYXJzIHdoaWNoIG1pZ2h0IGJlIDBcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIHRyYWplY3RvcnkucHVzaChicmVha2Rvd24pO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBwcmV2aW91cyB5ZWFyIGJyZWFrZG93biBmb3IgbmV4dCBpdGVyYXRpb24gKGZvciByZXNwb25zaXZlIGRlbWFuZCBjYWxjdWxhdGlvbilcbiAgICBwcmV2WWVhckJyZWFrZG93biA9IGJyZWFrZG93bjtcbiAgfVxuXG4gIHJldHVybiB0cmFqZWN0b3J5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVGaW5hbEFuYWx5c2lzKFxuICBvcHRpb25zOiBUcmFqZWN0b3J5T3B0aW9ucyxcbiAgYmFzZVRyYWplY3Rvcnk6IFllYXJseUJyZWFrZG93bltdXG4pOiBGaW5hbE1vZGVsT3V0cHV0IHtcbiAgY29uc3QgYmFzZUNyb3Nzb3ZlciA9IGZpbmRDcm9zc292ZXJZZWFyKGJhc2VUcmFqZWN0b3J5KTtcbiAgY29uc3QgYmFzZUNyb3Nzb3ZlckVmZmVjdGl2ZVBmbG9wID0gZmluZENyb3Nzb3ZlclllYXJFZmZlY3RpdmVQZmxvcChiYXNlVHJhamVjdG9yeSk7XG4gIGNvbnN0IGJhc2VQYXJhbXMgPSBvcHRpb25zLnBhcmFtc0J5WWVhcigyMDI1KTtcbiAgXG4gIC8vIDEuIFNlbnNpdGl2aXR5IEFuYWx5c2lzXG4gIGNvbnN0IHBhcmFtZXRlcnNUb1Rlc3QgPSBbXG4gICAgeyBrZXk6ICdsYXVuY2hDb3N0S2cnLCBuYW1lOiAnTGF1bmNoIENvc3QgKDIwMzUpJywgdmFsdWVzOiBbNTAsIDEwMCwgMTUwLCAyMDAsIDMwMF0sIHllYXJUb01vZGlmeTogMjAzNSB9LFxuICAgIHsga2V5OiAnZ3B1RmFpbHVyZVJhdGUnLCBuYW1lOiAnR1BVIEZhaWx1cmUgUmF0ZScsIHZhbHVlczogWzAuMDUsIDAuMTAsIDAuMTUsIDAuMjAsIDAuMjVdLCB5ZWFyVG9Nb2RpZnk6IG51bGwgfSxcbiAgICB7IGtleTogJ2hhcmR3YXJlTGVhcm5pbmdSYXRlJywgbmFtZTogJ0hhcmR3YXJlIExlYXJuaW5nIFJhdGUnLCB2YWx1ZXM6IFswLjA4LCAwLjEwLCAwLjEyLCAwLjE1XSwgeWVhclRvTW9kaWZ5OiBudWxsIH0sXG4gIF07XG5cbiAgY29uc3Qgc2Vuc2l0aXZpdGllcyA9IHBhcmFtZXRlcnNUb1Rlc3QubWFwKHAgPT4ge1xuICAgIGNvbnN0IGNyb3Nzb3ZlclllYXJzID0gcC52YWx1ZXMubWFwKHZhbCA9PiB7XG4gICAgICBjb25zdCB0ZXN0VHJhamVjdG9yeSA9IGNvbXB1dGVUcmFqZWN0b3J5KHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgcGFyYW1zQnlZZWFyOiAoeSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG9wdGlvbnMucGFyYW1zQnlZZWFyKHkpO1xuICAgICAgICAgIGlmIChwLnllYXJUb01vZGlmeSAmJiB5ID09PSBwLnllYXJUb01vZGlmeSkge1xuICAgICAgICAgICAgIHJldHVybiB7IC4uLnBhcmFtcywgW3Aua2V5XTogdmFsIH07XG4gICAgICAgICAgfSBlbHNlIGlmICghcC55ZWFyVG9Nb2RpZnkpIHtcbiAgICAgICAgICAgICByZXR1cm4geyAuLi5wYXJhbXMsIFtwLmtleV06IHZhbCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmaW5kQ3Jvc3NvdmVyWWVhcih0ZXN0VHJhamVjdG9yeSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB2YWxpZFllYXJzID0gY3Jvc3NvdmVyWWVhcnMuZmlsdGVyKHkgPT4geSAhPT0gbnVsbCkgYXMgbnVtYmVyW107XG4gICAgY29uc3QgbWF4RGVsdGEgPSB2YWxpZFllYXJzLmxlbmd0aCA+IDEgPyBNYXRoLm1heCguLi52YWxpZFllYXJzKSAtIE1hdGgubWluKC4uLnZhbGlkWWVhcnMpIDogMDtcbiAgICBjb25zdCBpbXBhY3QgPSBtYXhEZWx0YSA+PSA0ID8gJ2hpZ2gnIDogbWF4RGVsdGEgPj0gMiA/ICdtZWRpdW0nIDogJ2xvdyc7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFyYW1ldGVyOiBwLm5hbWUsXG4gICAgICBiYXNlVmFsdWU6IChiYXNlUGFyYW1zW3Aua2V5IGFzIGtleW9mIFllYXJQYXJhbXNdIGFzIG51bWJlcikgfHwgMCxcbiAgICAgIHRlc3RWYWx1ZXM6IHAudmFsdWVzLFxuICAgICAgY3Jvc3NvdmVyWWVhcnMsXG4gICAgICBpbXBhY3Q6IGltcGFjdCBhcyAnaGlnaCcgfCAnbWVkaXVtJyB8ICdsb3cnXG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gMi4gU2NlbmFyaW8gQmVuY2htYXJrc1xuICBjb25zdCBzY2VuYXJpb3MgPSBbXG4gICAge1xuICAgICAgbmFtZTogJ0J1bGwgQ2FzZScsXG4gICAgICBkZXNjcmlwdGlvbjogJ01hdHVyZSBTdGFyc2hpcCwgY29tbWVyY2lhbCBjaGlwcywgc2V2ZXJlIGdyb3VuZCBjb25zdHJhaW50cycsXG4gICAgICBrZXlBc3N1bXB0aW9uczogWydMYXVuY2ggJDc1L2tnIGJ5IDIwMzUnLCAnQ29tbWVyY2lhbCBjaGlwcycsICdTZXZlcmUgZ3JvdW5kIGNvbnN0cmFpbnRzJ10sXG4gICAgICBjcm9zc292ZXJZZWFyOiBmaW5kQ3Jvc3NvdmVyWWVhcihjb21wdXRlVHJhamVjdG9yeSh7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHBhcmFtc0J5WWVhcjogKHkpID0+ICh7XG4gICAgICAgICAgLi4ub3B0aW9ucy5wYXJhbXNCeVllYXIoeSksXG4gICAgICAgICAgbGF1bmNoQ29zdEtnOiBnZXRMYXVuY2hDb3N0UGVyS2coeSwgMTUwMCksXG4gICAgICAgICAgdXNlUmFkSGFyZENoaXBzOiBmYWxzZSxcbiAgICAgICAgICBncm91bmRTY2VuYXJpbzogJ3NldmVyZSdcbiAgICAgICAgfSlcbiAgICAgIH0pKVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ0Jhc2UgQ2FzZScsXG4gICAgICBkZXNjcmlwdGlvbjogJ0N1cnJlbnQgbW9kZWwgYXNzdW1wdGlvbnMgKFJhZC10b2xlcmFudCBiYXNlbGluZSknLFxuICAgICAga2V5QXNzdW1wdGlvbnM6IFsnTGF1bmNoICQ3NS9rZyBieSAyMDM1JywgJ1JhZC10b2xlcmFudCBjaGlwcycsICdTdGFuZGFyZCBncm91bmQgY29uc3RyYWludHMnXSxcbiAgICAgIGNyb3Nzb3ZlclllYXI6IGJhc2VDcm9zc292ZXJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdCZWFyIENhc2UnLFxuICAgICAgZGVzY3JpcHRpb246ICdSYWQtaGFyZCByZXF1aXJlZCwgU01ScyBzb2x2ZSBncm91bmQgcG93ZXInLFxuICAgICAga2V5QXNzdW1wdGlvbnM6IFsnTGF1bmNoICQzMDAva2cgYnkgMjAzNScsICdSYWQtaGFyZCBjaGlwcycsICdVbmNvbnN0cmFpbmVkIGdyb3VuZCddLFxuICAgICAgY3Jvc3NvdmVyWWVhcjogZmluZENyb3Nzb3ZlclllYXIoY29tcHV0ZVRyYWplY3Rvcnkoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBwYXJhbXNCeVllYXI6ICh5KSA9PiAoe1xuICAgICAgICAgIC4uLm9wdGlvbnMucGFyYW1zQnlZZWFyKHkpLFxuICAgICAgICAgIGxhdW5jaENvc3RLZzogcHJvamVjdE1hcmtldFByaWNlKDE1MDAsIDIwMjUsIHksIDAuMTApLFxuICAgICAgICAgIHVzZVJhZEhhcmRDaGlwczogdHJ1ZSxcbiAgICAgICAgICBncm91bmRTY2VuYXJpbzogJ3VuY29uc3RyYWluZWQnXG4gICAgICAgIH0pXG4gICAgICB9KSlcbiAgICB9XG4gIF07XG5cbiAgLy8gMy4gTWFya2V0IENvbXBhcmlzb25cbiAgY29uc3QgbWFya2V0Q29tcGFyaXNvbjogTWFya2V0UHJvamVjdGlvbltdID0gTUFSS0VUX1BST1ZJREVSUy5tYXAocCA9PiB7XG4gICAgY29uc3QgcHJvamVjdGVkUHJpY2VzID0gW107XG4gICAgZm9yIChsZXQgeSA9IDIwMjU7IHkgPD0gMjA1MDsgeSsrKSB7XG4gICAgICBwcm9qZWN0ZWRQcmljZXMucHVzaCh7IHllYXI6IHksIHByaWNlOiBwcm9qZWN0TWFya2V0UHJpY2UocC5wcmljZSwgMjAyNCwgeSwgcC5kZWNsaW5lKSB9KTtcbiAgICB9XG4gICAgXG4gICAgY29uc3Qgb3JiaXRhbEJlYXRzWWVhciA9IGJhc2VUcmFqZWN0b3J5LmZpbmQoZCA9PiB7XG4gICAgICBjb25zdCBwcm9qZWN0ZWQgPSBwcm9qZWN0TWFya2V0UHJpY2UocC5wcmljZSwgMjAyNCwgZC55ZWFyLCBwLmRlY2xpbmUpO1xuICAgICAgcmV0dXJuIGQub3JiaXQuZ3B1SG91clByaWNpbmcuc3RhbmRhcmQucHJpY2VQZXJHcHVIb3VyIDwgcHJvamVjdGVkO1xuICAgIH0pPy55ZWFyIHx8IG51bGw7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHJvdmlkZXI6IHAubmFtZSxcbiAgICAgIGN1cnJlbnRQcmljZTogcC5wcmljZSxcbiAgICAgIGN1cnJlbnRZZWFyOiAyMDI0LFxuICAgICAgcHJvamVjdGVkRGVjbGluZTogcC5kZWNsaW5lLFxuICAgICAgcHJvamVjdGVkUHJpY2VzLFxuICAgICAgb3JiaXRhbEJlYXRzWWVhclxuICAgIH07XG4gIH0pO1xuXG4gIC8vIDQuIEdyb3VuZCBTY2VuYXJpbyBMYWJlbFxuICBjb25zdCBzZWxlY3RlZFNjZW5hcmlvID0gR1JPVU5EX1NDRU5BUklPU1tiYXNlUGFyYW1zLmdyb3VuZFNjZW5hcmlvXTtcbiAgY29uc3QgZ3JvdW5kU2NlbmFyaW9MYWJlbDogR3JvdW5kU2NlbmFyaW9MYWJlbCA9IHtcbiAgICBuYW1lOiBzZWxlY3RlZFNjZW5hcmlvLm5hbWUsXG4gICAgZGVzY3JpcHRpb246IHNlbGVjdGVkU2NlbmFyaW8uZGVzY3JpcHRpb24sXG4gICAgY29uc3RyYWludE11bHRpcGxpZXIyMDQwOiAxLjAsIC8vIE5vdCB1c2VkIC0gY29uc3RyYWludHMgbm93IHVzZSBhZGRlcnMgb25seVxuICAgIGFzc3VtcHRpb25zOiBbXG4gICAgICBgR3JpZCBncm93dGg6ICR7KHNlbGVjdGVkU2NlbmFyaW8uZ3JpZEdyb3d0aFJhdGUgKiAxMDApLnRvRml4ZWQoMSl9JS95ZWFyYCxcbiAgICAgIGBDb29saW5nIGdyb3d0aDogJHsoc2VsZWN0ZWRTY2VuYXJpby5jb29saW5nR3Jvd3RoUmF0ZSAqIDEwMCkudG9GaXhlZCgxKX0lL3llYXJgLFxuICAgICAgc2VsZWN0ZWRTY2VuYXJpby5jb25zdHJhaW50Q2FwID8gYENvbnN0cmFpbnQgY2FwOiAke3NlbGVjdGVkU2NlbmFyaW8uY29uc3RyYWludENhcH14YCA6ICdObyBjb25zdHJhaW50IGNhcCdcbiAgICBdXG4gIH07XG5cbiAgLy8gNS4gVmFsaWRhdGlvbiBDaGVja3NcbiAgY29uc3QgbGFzdFllYXIgPSBiYXNlVHJhamVjdG9yeVtiYXNlVHJhamVjdG9yeS5sZW5ndGggLSAxXTtcbiAgY29uc3QgZmlyc3RZZWFyID0gYmFzZVRyYWplY3RvcnlbMF07XG4gIGNvbnN0IGFsbENoZWNrcyA9IFtcbiAgICB7IG5hbWU6ICdDb3N0IGJyZWFrZG93biBzdW1zIHRvIHRvdGFsJywgcGFzc2VkOiAhIWxhc3RZZWFyLmNvc3RBY2NvdW50aW5nVmFsaWQsIHZhbHVlOiBsYXN0WWVhci5jb3N0QWNjb3VudGluZ0Vycm9yUGN0LCBleHBlY3RlZDogJzwwLjUlJyB9LFxuICAgIHsgbmFtZTogJ0NhcGFjaXR5IGZhY3RvciBpbiByYW5nZScsIHBhc3NlZDogZmlyc3RZZWFyLm9yYml0LmNhcGFjaXR5RmFjdG9yID4gMC45MCwgdmFsdWU6IGZpcnN0WWVhci5vcmJpdC5jYXBhY2l0eUZhY3RvciwgZXhwZWN0ZWQ6ICcwLjkwLTEuMCcgfSxcbiAgICB7IG5hbWU6ICdDcm9zc292ZXIgeWVhciBtYXRjaGVzIHRyYWplY3RvcnknLCBwYXNzZWQ6IHRydWUsIHZhbHVlOiBiYXNlQ3Jvc3NvdmVyIH0sXG4gIF07XG5cbiAgY29uc3QgdmFsaWRhdGlvbjogVmFsaWRhdGlvbkNoZWNrcyA9IHtcbiAgICBjb3N0QWNjb3VudGluZ1ZhbGlkOiAhIWxhc3RZZWFyLmNvc3RBY2NvdW50aW5nVmFsaWQsXG4gICAgY29zdEFjY291bnRpbmdFcnJvcjogbGFzdFllYXIuY29zdEFjY291bnRpbmdFcnJvclBjdCB8fCAwLFxuICAgIHRyYWplY3RvcnlNb25vdG9uaWM6IHRydWUsIC8vIFNpbXBsaWZpZWRcbiAgICBwYXJhbWV0ZXJzSW5SYW5nZTogdHJ1ZSxcbiAgICBjcm9zc292ZXJDb25zaXN0ZW50OiB0cnVlLFxuICAgIGFsbENoZWNrc1xuICB9O1xuXG4gIGNvbnN0IGNyb3Nzb3ZlclllYXJTdGFuZGFyZCA9IGJhc2VDcm9zc292ZXI7XG4gIGNvbnN0IHByaWNlQXRDcm9zc292ZXJPcmJpdGFsID0gYmFzZUNyb3Nzb3ZlciA/IGJhc2VUcmFqZWN0b3J5W2Jhc2VDcm9zc292ZXIgLSAyMDI1XS5vcmJpdC5ncHVIb3VyUHJpY2luZy5zdGFuZGFyZC5wcmljZVBlckdwdUhvdXIgOiAwO1xuICBjb25zdCBwcmljZUF0Q3Jvc3NvdmVyR3JvdW5kID0gYmFzZUNyb3Nzb3ZlciA/IGJhc2VUcmFqZWN0b3J5W2Jhc2VDcm9zc292ZXIgLSAyMDI1XS5ncm91bmQuZ3B1SG91clByaWNpbmcuc3RhbmRhcmQucHJpY2VQZXJHcHVIb3VyIDogMDtcblxuICBjb25zdCBhY3RpdmVUb2dnbGVzID0gW107XG4gIGlmIChiYXNlUGFyYW1zLmVsb25TY2VuYXJpb0VuYWJsZWQpIGFjdGl2ZVRvZ2dsZXMucHVzaCgnRWxvbiBTY2VuYXJpbycpO1xuICBpZiAoYmFzZVBhcmFtcy5nbG9iYWxMYXRlbmN5UmVxdWlyZW1lbnRFbmFibGVkKSBhY3RpdmVUb2dnbGVzLnB1c2goJ0dsb2JhbCBMYXRlbmN5Jyk7XG4gIGlmIChiYXNlUGFyYW1zLnNwYWNlTWFudWZhY3R1cmluZ0VuYWJsZWQpIGFjdGl2ZVRvZ2dsZXMucHVzaCgnU3BhY2UgTWZnJyk7XG4gIGlmIChiYXNlUGFyYW1zLmFpV2ludGVyRW5hYmxlZCkgYWN0aXZlVG9nZ2xlcy5wdXNoKCdBSSBXaW50ZXInKTtcblxuICAvLyBCYXNlbGluZSBjcm9zc292ZXIgKG5vIHRvZ2dsZXMpXG4gIGNvbnN0IGJhc2VsaW5lVHJhamVjdG9yeSA9IGNvbXB1dGVUcmFqZWN0b3J5KHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHBhcmFtc0J5WWVhcjogKHkpID0+ICh7XG4gICAgICAuLi5vcHRpb25zLnBhcmFtc0J5WWVhcih5KSxcbiAgICAgIGVsb25TY2VuYXJpb0VuYWJsZWQ6IGZhbHNlLFxuICAgICAgZ2xvYmFsTGF0ZW5jeVJlcXVpcmVtZW50RW5hYmxlZDogZmFsc2UsXG4gICAgICBzcGFjZU1hbnVmYWN0dXJpbmdFbmFibGVkOiBmYWxzZSxcbiAgICAgIGFpV2ludGVyRW5hYmxlZDogZmFsc2VcbiAgICB9KVxuICB9KTtcbiAgY29uc3QgYmFzZWxpbmVDcm9zc292ZXIgPSBmaW5kQ3Jvc3NvdmVyWWVhcihiYXNlbGluZVRyYWplY3RvcnkpO1xuXG4gIGNvbnN0IHNjZW5hcmlvSW1wYWN0ID0ge1xuICAgIGJhc2VsaW5lQ3Jvc3NvdmVyLFxuICAgIGN1cnJlbnRDcm9zc292ZXI6IGJhc2VDcm9zc292ZXIsXG4gICAgYWN0aXZlVG9nZ2xlcyxcbiAgICBjcm9zc292ZXJEZWx0YTogKGJhc2VsaW5lQ3Jvc3NvdmVyIHx8IDIwNDApIC0gKGJhc2VDcm9zc292ZXIgfHwgMjA0MClcbiAgfTtcblxuICAvLyBNb250ZSBDYXJsbyBBbmFseXNpcyAocnVuIG9uY2UsIGNhY2hlZCBwZXIgcGFyYW1ldGVyIHNldClcbiAgLy8gRXh0cmFjdCBiYXNlIHBhcmFtZXRlcnMgZm9yIE1vbnRlIENhcmxvXG4gIGNvbnN0IGJhc2VQYXJhbXNGb3JNQyA9IGV4dHJhY3RCYXNlUGFyYW1zKG9wdGlvbnMucGFyYW1zQnlZZWFyKTtcbiAgXG4gIC8vIFJ1biBNb250ZSBDYXJsbyBhbmFseXNpcyAoMjAwIHNhbXBsZXMgYnkgZGVmYXVsdClcbiAgLy8gVGhpcyBpcyBjb21wdXRhdGlvbmFsbHkgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IGRvIGl0IG9uY2UgcGVyIGFuYWx5c2lzXG4gIGNvbnN0IG1vbnRlQ2FybG9SZXN1bHQgPSBydW5Nb250ZUNhcmxvQ3Jvc3NvdmVyKFxuICAgIG9wdGlvbnMucGFyYW1zQnlZZWFyLFxuICAgIGJhc2VQYXJhbXNGb3JNQyxcbiAgICAyMDAgLy8gbnVtU2FtcGxlc1xuICApO1xuXG4gIHJldHVybiB7XG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIHZlcnNpb246ICc0LjMuMCcsXG4gICAgICBnZW5lcmF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgdW5pdHM6IFtdIFxuICAgIH0sXG4gICAgcGFyYW1ldGVyczogYmFzZVBhcmFtcyxcbiAgICB0cmFqZWN0b3J5OiBiYXNlVHJhamVjdG9yeSxcbiAgICBhbmFseXNpczoge1xuICAgICAgY3Jvc3NvdmVyOiB7XG4gICAgICAgIHllYXI6IGJhc2VDcm9zc292ZXIsXG4gICAgICAgIG9yYml0YWxQcmljZTogcHJpY2VBdENyb3Nzb3Zlck9yYml0YWwsXG4gICAgICAgIGdyb3VuZFByaWNlOiBwcmljZUF0Q3Jvc3NvdmVyR3JvdW5kLFxuICAgICAgICBtYXJrZXRQb3NpdGlvbjogYmFzZVRyYWplY3RvcnlbYmFzZVRyYWplY3RvcnkubGVuZ3RoIC0gMV0uY3Jvc3NvdmVyRGV0YWlscz8ubWFya2V0UG9zaXRpb24gfHwgJydcbiAgICAgIH0sXG4gICAgICBzZW5zaXRpdml0eToge1xuICAgICAgICBiYXNlQ2FzZToge1xuICAgICAgICAgIGNyb3Nzb3ZlclllYXI6IGJhc2VDcm9zc292ZXIgfHwgMjA0MCxcbiAgICAgICAgICBvcmJpdGFsUHJpY2VBdENyb3Nzb3ZlcjogcHJpY2VBdENyb3Nzb3Zlck9yYml0YWwsXG4gICAgICAgICAgZ3JvdW5kUHJpY2VBdENyb3Nzb3ZlcjogcHJpY2VBdENyb3Nzb3Zlckdyb3VuZCxcbiAgICAgICAgfSxcbiAgICAgICAgc2Vuc2l0aXZpdGllc1xuICAgICAgfSxcbiAgICAgIHNjZW5hcmlvcyxcbiAgICAgIGNvbmZpZGVuY2U6IHtcbiAgICAgICAgY3Jvc3NvdmVyWWVhcjoge1xuICAgICAgICAgIHAxMDogbW9udGVDYXJsb1Jlc3VsdC5wMTAsIC8vIEZyb20gTW9udGUgQ2FybG8gYW5hbHlzaXNcbiAgICAgICAgICBwNTA6IG1vbnRlQ2FybG9SZXN1bHQucDUwLCAvLyBGcm9tIE1vbnRlIENhcmxvIGFuYWx5c2lzXG4gICAgICAgICAgcDkwOiBtb250ZUNhcmxvUmVzdWx0LnA5MCwgLy8gRnJvbSBNb250ZSBDYXJsbyBhbmFseXNpc1xuICAgICAgICB9LFxuICAgICAgICBwcmljZUF0Q3Jvc3NvdmVyOiB7XG4gICAgICAgICAgbG93OiBzY2VuYXJpb3NbMF0uY3Jvc3NvdmVyWWVhciA/IGJhc2VUcmFqZWN0b3J5W3NjZW5hcmlvc1swXS5jcm9zc292ZXJZZWFyIC0gMjAyNV0ub3JiaXQuZ3B1SG91clByaWNpbmcuc3RhbmRhcmQucHJpY2VQZXJHcHVIb3VyIDogMCxcbiAgICAgICAgICBtaWQ6IHNjZW5hcmlvc1sxXS5jcm9zc292ZXJZZWFyID8gYmFzZVRyYWplY3Rvcnlbc2NlbmFyaW9zWzFdLmNyb3Nzb3ZlclllYXIgLSAyMDI1XS5vcmJpdC5ncHVIb3VyUHJpY2luZy5zdGFuZGFyZC5wcmljZVBlckdwdUhvdXIgOiAwLFxuICAgICAgICAgIGhpZ2g6IHNjZW5hcmlvc1syXS5jcm9zc292ZXJZZWFyID8gYmFzZVRyYWplY3Rvcnlbc2NlbmFyaW9zWzJdLmNyb3Nzb3ZlclllYXIgLSAyMDI1XS5vcmJpdC5ncHVIb3VyUHJpY2luZy5zdGFuZGFyZC5wcmljZVBlckdwdUhvdXIgOiAwLFxuICAgICAgICB9LFxuICAgICAgICBwcm9iYWJpbGl0eUJ5WWVhcjogbW9udGVDYXJsb1Jlc3VsdC5wcm9iYWJpbGl0eUJ5WWVhciwgLy8gUHJvYmFiaWxpdHkgb3JiaXRhbCBjaGVhcGVyIGJ5IHllYXIgWFxuICAgICAgfSxcbiAgICAgIG1hcmtldENvbXBhcmlzb24sXG4gICAgICByZWd1bGF0b3J5SW1wYWN0OiAxNTAwLFxuICAgICAgc2NlbmFyaW9JbXBhY3RcbiAgICB9LFxuICAgIHZhbGlkYXRpb24sXG4gICAgZ3JvdW5kU2NlbmFyaW86IGdyb3VuZFNjZW5hcmlvTGFiZWxcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJjb21wdXRlUGh5c2ljc0Nvc3QiLCJHUk9VTkRfU0NFTkFSSU9TIiwiZ2V0TGF1bmNoQ29zdFBlcktnIiwic3RlcExhdW5jaExlYXJuaW5nIiwiZ2V0U3RhdGljUGFyYW1zIiwicnVuTW9udGVDYXJsb0Nyb3Nzb3ZlciIsImV4dHJhY3RCYXNlUGFyYW1zIiwiZmluZENyb3Nzb3ZlclllYXIiLCJ0cmFqZWN0b3J5IiwiY3Jvc3NpbmciLCJmaW5kIiwiZCIsImdyb3VuZEVmZmVjdGl2ZUNvc3QiLCJncm91bmQiLCJ0b3RhbENvc3RQZXJQZmxvcFllYXJFZmZlY3RpdmUiLCJ0b3RhbENvc3RQZXJQZmxvcFllYXIiLCJjb25zdHJhaW50cyIsImRlbGF5UGVuYWx0eSIsInNjYXJjaXR5UmVudFBlclBmbG9wWWVhciIsIm9yYml0Q29zdCIsIm9yYml0IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJ5ZWFyIiwiZmluZENyb3Nzb3ZlclllYXJFZmZlY3RpdmVQZmxvcCIsImNhbGN1bGF0ZU1hcmtldFNoYXJlIiwib3JiaXRhbENvc3RQZXJQZmxvcCIsImdyb3VuZENvc3RQZXJQZmxvcCIsInRvdGFsRGVtYW5kR1ciLCJvcmJpdGFsRmVhc2libGUiLCJncm91bmRGZWFzaWJsZSIsIm9yYml0YWxDb3N0QWNjb3VudGluZ1ZhbGlkIiwiZ3JvdW5kQ29zdEFjY291bnRpbmdWYWxpZCIsImRlbWFuZEdXIiwiYmFja2xvZ0dXIiwiYnVpbGRSYXRlR1d5ciIsImF2Z1dhaXRZZWFycyIsIm9yYml0TWF4RGVwbG95YWJsZUNvbXB1dGVHVyIsIm9yYml0YWxBY3R1YWxseUZlYXNpYmxlIiwiZ3JvdW5kQWN0dWFsbHlGZWFzaWJsZSIsIm9yYml0YWxTaGFyZUZyYWMiLCJvcmJpdGFsQ2FwYWNpdHlHVyIsIm9yYml0YWxSZXZlbnVlIiwiZ3JvdW5kU2hhcmVGcmFjIiwiZ3JvdW5kQ2FwYWNpdHlHVyIsImRlYnVnIiwic2hhcmVDb252ZW50aW9uIiwiZ3JvdW5kUmV2ZW51ZSIsImRlbWFuZCIsImJhY2tsb2dHV0FjdHVhbCIsImJ1aWxkUmF0ZUdXeXJBY3R1YWwiLCJhdmdXYWl0WWVhcnNBY3R1YWwiLCJncm91bmRIYXNTZXZlcmVRdWV1ZSIsImdyb3VuZEZlYXNpYmxlR1ciLCJNYXRoIiwibWF4Iiwib3JiaXRGZWFzaWJsZUdXIiwibWluIiwibWF4U2VydmFibGUiLCJjb3N0UmF0aW8iLCJsb2dpdEZhY3RvciIsImV4cCIsIm9yYml0YWxTaGFyZUZyYWNEZXNpcmVkIiwiZ3JvdW5kU2hhcmVGcmFjRGVzaXJlZCIsIm9yYml0U2VydmVkIiwiZ3JvdW5kU2VydmVkIiwicmVtYWluZGVyIiwib3JiaXRSb29tIiwiZ3JvdW5kUm9vbSIsImFkZFRvT3JiaXQiLCJ0b3RhbFNlcnZlZEdXIiwiZ3JvdW5kU2VydmVkQ29tcHV0ZUdXIiwib3JiaXRTZXJ2ZWRDb21wdXRlR1ciLCJncm91bmRGZWFzaWJsZUNvbXB1dGVHVyIsIm9yYml0RmVhc2libGVDb21wdXRlR1ciLCJyZXZlbnVlUGVyR1ciLCJFcnJvciIsInNoYXJlU3VtIiwiYWJzIiwiZGVtYW5kQ29tcHV0ZUdXIiwicHJvamVjdE1hcmtldFByaWNlIiwiYmFzZVByaWNlIiwiYmFzZVllYXIiLCJ0YXJnZXRZZWFyIiwiYW5udWFsRGVjbGluZVJhdGUiLCJ5ZWFycyIsInBvdyIsIk1BUktFVF9QUk9WSURFUlMiLCJuYW1lIiwicHJpY2UiLCJkZWNsaW5lIiwiSVRfR1dfMjAyNSIsIklUX0dXXzIwNDBfVEFSR0VUIiwiSVRfR1dfMjA2MF9UQVJHRVQiLCJSMSIsImxvZyIsIlIyIiwiY2FsY3VsYXRlUmVzcG9uc2l2ZURlbWFuZCIsImdyb3VuZFByaWNlUGVyR3B1SG91ciIsIm9yYml0YWxQcmljZVBlckdwdUhvdXIiLCJwcmV2RGVtYW5kU3RhdGUiLCJ5ZWFyc0Zyb20yMDI1IiwiZ3Jvd3RoUmF0ZSIsInRhcGVyIiwiZWZmZWN0aXZlR3Jvd3RoIiwiYmFzZWxpbmVHVyIsIlNNT09USElOR19BTFBIQSIsImJhc2VsaW5lUHJpY2UiLCJwcmljZVJhdGlvIiwicHJpY2VFbGFzdGljaXR5IiwicHJpY2VGYWN0b3JSYXciLCJwcmV2UHJpY2VGYWN0b3IiLCJlZmZlY3RpdmVHVyIsInByaWNlRmFjdG9yIiwid2FpdEVsYXN0aWNpdHkiLCJ3YWl0RmFjdG9yUmF3IiwicHJldldhaXRGYWN0b3IiLCJ3YWl0RmFjdG9yIiwiZWZmZWN0aXZlR1dSYXciLCJtaW5EZW1hbmRGcmFjIiwiZ3JvdW5kT3JiaXRhbFJhdGlvIiwidGFyZ2V0T3JiaXRhbFNoYXJlIiwicHJldk9yYml0YWxTaGFyZSIsIm9yYml0YWxTaGFyZSIsIm1heFNoYXJlQ2hhbmdlUGVyWWVhciIsInNoYXJlQ2hhbmdlIiwic21vb3RoZWRDaGFuZ2UiLCJzaWduIiwiZ3JvdW5kRGVtYW5kR1ciLCJwcm9jZXNzIiwiY29uc29sZSIsInRvRml4ZWQiLCJ1bmRlZmluZWQiLCJvcmJpdGFsU3Vic3RpdHV0aW9uQWN0aXZlIiwibWF4RGVtYW5kQ2hhbmdlUGVyWWVhciIsImRlbWFuZENoYW5nZVJhdGlvIiwiY2xhbXBlZCIsIm9yYml0YWxEZW1hbmRHVyIsImdldElUTG9hZEdXIiwieWVhcnNGcm9tMjA0MCIsImdldEZhY2lsaXR5TG9hZEdXIiwicHVlIiwiaXRMb2FkR1ciLCJnZXREZW1hbmROZXdHVyIsImZhY2lsaXR5R1ciLCJmYWNpbGl0eUdXUHJldiIsImdldERlbWFuZFByb2plY3Rpb24iLCJjb21wdXRlVHJhamVjdG9yeSIsIm9wdGlvbnMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsImZpcnN0Q2FwWWVhciIsImxhdW5jaExlYXJuaW5nU3RhdGUiLCJCQVNFTElORV9NQVNTX0tHIiwiTEFVTkNIX0NPU1RfMF9QRVJfS0ciLCJwcmV2WWVhckJyZWFrZG93biIsImJ1aWxkb3V0U3RhdGUiLCJtb2JpbGl6YXRpb25TdGF0ZSIsImJyZWFrZG93biIsInBhcmFtcyIsIm1vZGUiLCJwYXJhbXNCeVllYXIiLCJsYXVuY2hDb3N0UGVyS2ciLCJsYXVuY2hDb3N0S2ciLCJwYXJhbXNXaXRoTGF1bmNoQ29zdCIsInVzZUxhdW5jaExlYXJuaW5nIiwiY29tcHV0ZVBvd2VyTVciLCJ0YXJnZXRHVyIsIm1hc3NQZXJNVyIsIm1hc3NEZW1hbmRlZEtnIiwibGF1bmNoTGVhcm5pbmdSZXN1bHQiLCJiYXNlbGluZU1hc3NLZyIsImxhdW5jaENvc3QwUGVyS2ciLCJsZWFybmluZ1JhdGUiLCJtYXhGbGlnaHRzUGVyWWVhciIsInBheWxvYWRQZXJGbGlnaHRLZyIsInN0YXRlIiwiZ3JvdW5kUHVlIiwicHVlR3JvdW5kIiwicHJldkdyb3VuZFByaWNlIiwiZ3B1SG91clByaWNpbmciLCJzdGFuZGFyZCIsInByaWNlUGVyR3B1SG91ciIsInByZXZPcmJpdGFsUHJpY2UiLCJwcmV2QXZnV2FpdCIsInN1cHBseU1ldHJpY3MiLCJkZW1hbmRTdGF0ZSIsInBhcmFtc1dpdGhNb2JpbGl6YXRpb24iLCJwcmV2TW9iaWxpemF0aW9uU3RhdGUiLCJyZXNwb25zaXZlRGVtYW5kR1ciLCJvcmJpdGFsU3Vic3RpdHV0aW9uR1ciLCJoeWJyaWRCcmVha2Rvd24iLCJjb25zdHJhaW50QnJlYWtkb3duIiwiY2FwWWVhciIsInRoaXNDYXBZZWFyIiwiYWN0dWFsR3JvdW5kUHVlIiwiYnVpbGRvdXREZWJ1ZyIsIkluZmluaXR5IiwiY29zdEFjY291bnRpbmdWYWxpZCIsIm9yYml0YWxDYXBhY2l0eUdXX2Zyb21TYXRzIiwiY29uc3RlbGxhdGlvbiIsImRlc2lnbiIsIm51bVNhdGVsbGl0ZXMiLCJjb21wdXRlUGVyU2F0S3ciLCJleHBlY3RlZEdXIiwiZXJyb3IiLCJjaGFydFBCIiwibWV0YWRhdGEiLCJjaGFydElucHV0cyIsInBvd2VyQnVpbGRvdXQiLCJjaGFydEJhY2tsb2ciLCJiYWNrbG9nR3ciLCJjaGFydEF2Z1dhaXQiLCJjaGFydEJ1aWxkUmF0ZSIsIm1heEJ1aWxkUmF0ZUd3WWVhciIsImJhY2tsb2dGcm9tR3JvdW5kIiwiYmFja2xvZ0Zyb21CdWlsZG91dCIsImJ1aWxkUmF0ZUZyb21CdWlsZG91dCIsImJ1aWxkUmF0ZUZyb21TdXBwbHkiLCJhdmdXYWl0RnJvbUdyb3VuZCIsImF2Z1dhaXRGcm9tQnVpbGRvdXQiLCJ0aW1lVG9Qb3dlclllYXJzIiwiYXZnV2FpdEZyb21TdXBwbHkiLCJwaXBlbGluZUd3Iiwib3JiaXRNYXhEZXBsb3lhYmxlQ29tcHV0ZUdXQnlZZWFyIiwib3JiaXRhbEZlYXNpYmxlRm9yU2hhcmUiLCJtYXJrZXRBbmFseXNpcyIsIm1hcmtldCIsIm1hcmtldERlbWFuZCIsIm1hcmtldERlYnVnRGVtYW5kIiwiYnVpbGRvdXREZW1hbmQiLCJkZW1hbmROZXdHVyIsImNhcGFjaXR5R1ciLCJwaXBlbGluZUdXIiwicHVzaCIsImdlbmVyYXRlRmluYWxBbmFseXNpcyIsImJhc2VUcmFqZWN0b3J5IiwiYmFzZUNyb3Nzb3ZlciIsImJhc2VDcm9zc292ZXJFZmZlY3RpdmVQZmxvcCIsImJhc2VQYXJhbXMiLCJwYXJhbWV0ZXJzVG9UZXN0Iiwia2V5IiwidmFsdWVzIiwieWVhclRvTW9kaWZ5Iiwic2Vuc2l0aXZpdGllcyIsIm1hcCIsInAiLCJjcm9zc292ZXJZZWFycyIsInZhbCIsInRlc3RUcmFqZWN0b3J5IiwieSIsInZhbGlkWWVhcnMiLCJmaWx0ZXIiLCJtYXhEZWx0YSIsImltcGFjdCIsInBhcmFtZXRlciIsImJhc2VWYWx1ZSIsInRlc3RWYWx1ZXMiLCJzY2VuYXJpb3MiLCJkZXNjcmlwdGlvbiIsImtleUFzc3VtcHRpb25zIiwiY3Jvc3NvdmVyWWVhciIsInVzZVJhZEhhcmRDaGlwcyIsImdyb3VuZFNjZW5hcmlvIiwibWFya2V0Q29tcGFyaXNvbiIsInByb2plY3RlZFByaWNlcyIsIm9yYml0YWxCZWF0c1llYXIiLCJwcm9qZWN0ZWQiLCJwcm92aWRlciIsImN1cnJlbnRQcmljZSIsImN1cnJlbnRZZWFyIiwicHJvamVjdGVkRGVjbGluZSIsInNlbGVjdGVkU2NlbmFyaW8iLCJncm91bmRTY2VuYXJpb0xhYmVsIiwiY29uc3RyYWludE11bHRpcGxpZXIyMDQwIiwiYXNzdW1wdGlvbnMiLCJncmlkR3Jvd3RoUmF0ZSIsImNvb2xpbmdHcm93dGhSYXRlIiwiY29uc3RyYWludENhcCIsImxhc3RZZWFyIiwiZmlyc3RZZWFyIiwiYWxsQ2hlY2tzIiwicGFzc2VkIiwidmFsdWUiLCJjb3N0QWNjb3VudGluZ0Vycm9yUGN0IiwiZXhwZWN0ZWQiLCJjYXBhY2l0eUZhY3RvciIsInZhbGlkYXRpb24iLCJjb3N0QWNjb3VudGluZ0Vycm9yIiwidHJhamVjdG9yeU1vbm90b25pYyIsInBhcmFtZXRlcnNJblJhbmdlIiwiY3Jvc3NvdmVyQ29uc2lzdGVudCIsImNyb3Nzb3ZlclllYXJTdGFuZGFyZCIsInByaWNlQXRDcm9zc292ZXJPcmJpdGFsIiwicHJpY2VBdENyb3Nzb3Zlckdyb3VuZCIsImFjdGl2ZVRvZ2dsZXMiLCJlbG9uU2NlbmFyaW9FbmFibGVkIiwiZ2xvYmFsTGF0ZW5jeVJlcXVpcmVtZW50RW5hYmxlZCIsInNwYWNlTWFudWZhY3R1cmluZ0VuYWJsZWQiLCJhaVdpbnRlckVuYWJsZWQiLCJiYXNlbGluZVRyYWplY3RvcnkiLCJiYXNlbGluZUNyb3Nzb3ZlciIsInNjZW5hcmlvSW1wYWN0IiwiY3VycmVudENyb3Nzb3ZlciIsImNyb3Nzb3ZlckRlbHRhIiwiYmFzZVBhcmFtc0Zvck1DIiwibW9udGVDYXJsb1Jlc3VsdCIsInZlcnNpb24iLCJnZW5lcmF0ZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInVuaXRzIiwicGFyYW1ldGVycyIsImFuYWx5c2lzIiwiY3Jvc3NvdmVyIiwib3JiaXRhbFByaWNlIiwiZ3JvdW5kUHJpY2UiLCJtYXJrZXRQb3NpdGlvbiIsImNyb3Nzb3ZlckRldGFpbHMiLCJzZW5zaXRpdml0eSIsImJhc2VDYXNlIiwib3JiaXRhbFByaWNlQXRDcm9zc292ZXIiLCJncm91bmRQcmljZUF0Q3Jvc3NvdmVyIiwiY29uZmlkZW5jZSIsInAxMCIsInA1MCIsInA5MCIsInByaWNlQXRDcm9zc292ZXIiLCJsb3ciLCJtaWQiLCJoaWdoIiwicHJvYmFiaWxpdHlCeVllYXIiLCJyZWd1bGF0b3J5SW1wYWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/trajectory.ts\n"));

/***/ })

});