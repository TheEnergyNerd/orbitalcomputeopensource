"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/compare/page",{

/***/ "(app-pages-browser)/./app/lib/model/physicsCost.ts":
/*!**************************************!*\
  !*** ./app/lib/model/physicsCost.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_SMR_PARAMS: function() { return /* binding */ DEFAULT_SMR_PARAMS; },\n/* harmony export */   GROUND_SCENARIOS: function() { return /* binding */ GROUND_SCENARIOS; },\n/* harmony export */   MODEL_UNITS: function() { return /* binding */ MODEL_UNITS; },\n/* harmony export */   computePhysicsCost: function() { return /* binding */ computePhysicsCost; },\n/* harmony export */   getLaunchCostPerKg: function() { return /* binding */ getLaunchCostPerKg; }\n/* harmony export */ });\n/* harmony import */ var _congestion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./congestion */ \"(app-pages-browser)/./app/lib/model/congestion.ts\");\n/* harmony import */ var _edgeInference__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./edgeInference */ \"(app-pages-browser)/./app/lib/model/edgeInference.ts\");\n/* harmony import */ var _orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./orbitalPhysics */ \"(app-pages-browser)/./app/lib/model/orbitalPhysics.ts\");\n/* harmony import */ var _ground_supply_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ground_supply_model */ \"(app-pages-browser)/./app/lib/model/ground_supply_model.ts\");\n/* harmony import */ var _ground_queue_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ground_queue_model */ \"(app-pages-browser)/./app/lib/model/ground_queue_model.ts\");\n/* harmony import */ var _ground_constraint_penalties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ground_constraint_penalties */ \"(app-pages-browser)/./app/lib/model/ground_constraint_penalties.ts\");\n/* harmony import */ var _ground_buildout__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ground_buildout */ \"(app-pages-browser)/./app/lib/model/ground_buildout.ts\");\n/* harmony import */ var _ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ground_ramping_mobilization */ \"(app-pages-browser)/./app/lib/model/ground_ramping_mobilization.ts\");\n/* harmony import */ var _compute_efficiency__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./compute_efficiency */ \"(app-pages-browser)/./app/lib/model/compute_efficiency.ts\");\n/* harmony import */ var _cost_accounting__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./cost_accounting */ \"(app-pages-browser)/./app/lib/model/cost_accounting.ts\");\n/* harmony import */ var _units__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./units */ \"(app-pages-browser)/./app/lib/model/units.ts\");\n/* harmony import */ var _constellation_sizing__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./constellation_sizing */ \"(app-pages-browser)/./app/lib/model/constellation_sizing.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst CONSTANTS = {\n    HOURS_PER_YEAR: 8760,\n    GROUND_HARDWARE_COST_PFLOP_2025: 15000,\n    GROUND_HARDWARE_LIFETIME: 3,\n    MIN_DELIVERED_GFLOPS_PER_W: 20\n};\nconst DEFAULT_SMR_PARAMS = {\n    enabled: false,\n    smrDeploymentStartYear: 2030,\n    smrRampUpYears: 5,\n    electricityCostWithSMR: 50,\n    gridConstraintRelief: 0.90,\n    coolingConstraintRelief: 0.50,\n    waterConstraintRelief: 0.30,\n    landConstraintRelief: 0.60,\n    smrCapexPremium: 1.15\n};\nconst GROUND_SCENARIOS = {\n    unconstrained: {\n        name: \"Unconstrained\",\n        description: \"SMRs + geographic arbitrage solve power/water constraints\",\n        constraintCap: 1.5,\n        gridGrowthRate: 0.02,\n        coolingGrowthRate: 0.01,\n        waterGrowthRate: 0.01,\n        landGrowthRate: 0.01\n    },\n    moderate: {\n        name: \"Moderate\",\n        description: \"Partial adaptation, some persistent friction\",\n        constraintCap: 3.0,\n        gridGrowthRate: 0.03,\n        coolingGrowthRate: 0.02,\n        waterGrowthRate: 0.015,\n        landGrowthRate: 0.015\n    },\n    constrained: {\n        name: \"Constrained (Aggressive Baseline)\",\n        description: \"Accelerated AI demand pressure on infrastructure\",\n        constraintCap: null,\n        gridGrowthRate: 0.07,\n        coolingGrowthRate: 0.04,\n        waterGrowthRate: 0.03,\n        landGrowthRate: 0.03\n    },\n    severe: {\n        name: \"Severe\",\n        description: \"Constrained + carbon tax + water scarcity crisis\",\n        constraintCap: null,\n        gridGrowthRate: 0.09,\n        coolingGrowthRate: 0.06,\n        waterGrowthRate: 0.05,\n        landGrowthRate: 0.04\n    }\n};\nfunction calculateGroundConstraint(year, scenarioKey, enabled) {\n    if (!enabled) return {\n        multiplier: 1.0,\n        breakdown: {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0\n        }\n    };\n    const scenario = GROUND_SCENARIOS[scenarioKey];\n    const yearsFromBase = Math.max(0, year - 2025);\n    const grid = Math.pow(1 + scenario.gridGrowthRate, yearsFromBase);\n    const cooling = Math.pow(1 + scenario.coolingGrowthRate, yearsFromBase);\n    const water = Math.pow(1 + scenario.waterGrowthRate, yearsFromBase);\n    const land = Math.pow(1 + scenario.landGrowthRate, yearsFromBase);\n    let multiplier = grid * cooling * water * land;\n    if (scenario.constraintCap !== null) {\n        multiplier = Math.min(multiplier, scenario.constraintCap);\n    }\n    return {\n        multiplier,\n        breakdown: {\n            grid,\n            cooling,\n            water,\n            land\n        }\n    };\n}\nfunction validateComputeEfficiency(gflopsPerWatt) {\n    let level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"system\";\n    const ranges = {\n        chip: {\n            min: 100,\n            max: 10000\n        },\n        system: {\n            min: 30,\n            max: 5000\n        },\n        datacenter: {\n            min: 10,\n            max: 1000\n        }\n    };\n    const range = ranges[level];\n    if (gflopsPerWatt < range.min || gflopsPerWatt > range.max) {\n        return {\n            valid: false,\n            warning: \"gflopsPerWatt=\".concat(gflopsPerWatt.toFixed(0), \" outside expected range for \").concat(level, \" level (\").concat(range.min, \"-\").concat(range.max, \")\")\n        };\n    }\n    return {\n        valid: true\n    };\n}\nconst SLA_TIERS = {\n    \"basic\": {\n        availabilityTarget: 0.99,\n        maxLatencyToGroundMs: 100,\n        minBandwidthGbps: 1,\n        maxRecoveryTimeMinutes: 60,\n        creditPerViolationPct: 10\n    },\n    \"standard\": {\n        availabilityTarget: 0.999,\n        maxLatencyToGroundMs: 50,\n        minBandwidthGbps: 10,\n        maxRecoveryTimeMinutes: 15,\n        creditPerViolationPct: 25\n    },\n    \"premium\": {\n        availabilityTarget: 0.9999,\n        maxLatencyToGroundMs: 20,\n        minBandwidthGbps: 100,\n        maxRecoveryTimeMinutes: 5,\n        creditPerViolationPct: 50\n    }\n};\nfunction applyStaticFreeze(params) {\n    if (!params.isStaticMode) return params;\n    return {\n        ...params,\n        launchCostKg: 1500,\n        specificPowerWKg: 36.5,\n        groundEffectiveGflopsPerW_2025: 30,\n        orbitEffectiveGflopsPerW_2025: 25,\n        groundConstraintsEnabled: true,\n        powerGridMultiplier: 1.0,\n        coolingMultiplier: 1.0,\n        waterScarcityEnabled: false,\n        landScarcityEnabled: false,\n        deployableArea2025M2: 75,\n        deployableArea2040M2: 75\n    };\n}\n// Cache for monotonicity check\nlet prevLaunchCostCache = new Map();\nfunction getLaunchCostPerKg(year, base2025) {\n    if (year <= 2025) {\n        prevLaunchCostCache.set(year, base2025);\n        return base2025;\n    }\n    const COMMERCIAL_MARKUP = 2.5;\n    const INSURANCE_PCT = 0.05;\n    const INTEGRATION_COST_PER_LAUNCH = 500000; // $500k per launch\n    const ASSUMED_PAYLOAD_KG = 100000; // 100t payload for integration cost amortization\n    // Internal SpaceX cost trajectory (marginal cost)\n    // Normalize base2025 to internal cost scale\n    const internalBase2025 = base2025 / (COMMERCIAL_MARKUP * (1 + INSURANCE_PCT)) - INTEGRATION_COST_PER_LAUNCH / ASSUMED_PAYLOAD_KG;\n    const normalizedBase = Math.max(internalBase2025, 600); // Ensure reasonable internal cost\n    const internalWaypoints = [\n        [\n            2025,\n            normalizedBase\n        ],\n        [\n            2026,\n            800\n        ],\n        [\n            2027,\n            400\n        ],\n        [\n            2028,\n            200\n        ],\n        [\n            2030,\n            75\n        ],\n        [\n            2035,\n            30\n        ],\n        [\n            2040,\n            20\n        ],\n        [\n            2045,\n            15\n        ],\n        [\n            2050,\n            10\n        ] // Internal cost floor\n    ];\n    // Find internal cost\n    let internalCostPerKg = normalizedBase;\n    for(let i = 0; i < internalWaypoints.length - 1; i++){\n        const [y1, c1] = internalWaypoints[i];\n        const [y2, c2] = internalWaypoints[i + 1];\n        if (year >= y1 && year <= y2) {\n            const t = (year - y1) / (y2 - y1);\n            internalCostPerKg = c1 * Math.pow(c2 / c1, t);\n            break;\n        }\n    }\n    if (year > internalWaypoints[internalWaypoints.length - 1][0]) {\n        internalCostPerKg = internalWaypoints[internalWaypoints.length - 1][1];\n    }\n    // Apply commercial markup\n    const withMarkup = internalCostPerKg * COMMERCIAL_MARKUP;\n    const withInsurance = withMarkup * (1 + INSURANCE_PCT);\n    const integrationPerKg = INTEGRATION_COST_PER_LAUNCH / ASSUMED_PAYLOAD_KG;\n    const commercialCostPerKg = withInsurance + integrationPerKg;\n    // Floor: commercial cost never below $30/kg (realistic minimum)\n    let result = Math.max(commercialCostPerKg, 30);\n    // Enforce monotonicity: never increase from previous year\n    const prevYear = year - 1;\n    const prevCost = prevLaunchCostCache.get(prevYear);\n    if (prevCost !== undefined && result > prevCost) {\n        result = prevCost; // Clamp to previous year's cost\n    }\n    prevLaunchCostCache.set(year, result);\n    return result;\n}\nfunction calculateTokenPricing(costPerPflopYear, modelConfig) {\n    const baseFLOPS = modelConfig.params * 2;\n    const precisionMultiplier = {\n        \"fp16\": 1.0,\n        \"fp8\": 0.5,\n        \"int8\": 0.5\n    }[modelConfig.precision];\n    const flopsPerToken = baseFLOPS * precisionMultiplier;\n    const secondsPerYear = 8760 * 3600;\n    const flopsPerPflopYear = 1e15 * secondsPerYear;\n    const tokensPerPflopYear = flopsPerPflopYear / flopsPerToken;\n    const costPerToken = costPerPflopYear / tokensPerPflopYear;\n    return {\n        modelParams: modelConfig.params,\n        precision: modelConfig.precision,\n        flopsPerToken,\n        tokensPerPflopYear,\n        costPerToken,\n        costPer1kTokens: costPerToken * 1000,\n        costPer1mTokens: costPerToken * 1e6\n    };\n}\nfunction calculateGpuHourPricing(costPerPflopYear, params, costBreakdown) {\n    const hoursPerYear = 8760;\n    const costPerGpuYear = costPerPflopYear * params.pflopsPerGpu;\n    const effectiveHours = hoursPerYear * params.utilizationTarget;\n    const basePerHour = costPerGpuYear / effectiveHours;\n    // DEFENSIVE CHECK: GPU-hour price should be in reasonable range ($0.01 to $100)\n    // If costPerPflopYear is insane (e.g., billions), this will catch it\n    if ( true && basePerHour > 1000) {\n        console.error(\"[GPU-HOUR PRICING] Year calculation: basePerHour=\".concat(basePerHour, \" > 1000. \") + \"costPerPflopYear=\".concat(costPerPflopYear, \", pflopsPerGpu=\").concat(params.pflopsPerGpu, \", \") + \"effectiveHours=\".concat(effectiveHours));\n        // Clamp to prevent chart explosion\n        const clampedCostPerPflopYear = Math.min(costPerPflopYear, 10000); // Cap at $10k/PFLOP-year\n        const clampedCostPerGpuYear = clampedCostPerPflopYear * params.pflopsPerGpu;\n        const clampedBasePerHour = clampedCostPerGpuYear / effectiveHours;\n        if (clampedBasePerHour > 100) {\n            throw new Error(\"[GPU-HOUR PRICING] Even after clamping, basePerHour=\".concat(clampedBasePerHour, \" > 100. \") + \"This indicates a unit error or calculation bug. Check costPerPflopYear input.\");\n        }\n    }\n    // Derive breakdown from cost components if provided\n    let powerPerHour = 0;\n    let coolingPerHour = 0;\n    let interconnectPerHour = 0;\n    let opsPerHour = 0;\n    let computePerHour = basePerHour;\n    if (costBreakdown) {\n        const totalBase = (costBreakdown.power || 0) + (costBreakdown.thermal || 0) + (costBreakdown.interconnect || 0) + (costBreakdown.ops || 0) + (costBreakdown.compute || 0);\n        if (totalBase > 0) {\n            // Scale breakdown components to GPU-hour\n            const scale = costPerGpuYear / (totalBase * params.pflopsPerGpu) / effectiveHours;\n            powerPerHour = (costBreakdown.power || 0) * params.pflopsPerGpu * scale;\n            coolingPerHour = (costBreakdown.thermal || 0) * params.pflopsPerGpu * scale;\n            interconnectPerHour = (costBreakdown.interconnect || 0) * params.pflopsPerGpu * scale;\n            opsPerHour = (costBreakdown.ops || 0) * params.pflopsPerGpu * scale;\n            computePerHour = (costBreakdown.compute || 0) * params.pflopsPerGpu * scale;\n        }\n    } else {\n        // Fallback: estimate ops as 5% of base\n        opsPerHour = basePerHour * 0.05;\n    }\n    const nines = -Math.log10(1 - params.sla.availabilityTarget);\n    const sparesRatio = 1 + 0.05 * nines;\n    const sparesPerHour = computePerHour * (sparesRatio - 1);\n    const violationProb = 1 - params.sla.availabilityTarget;\n    const expectedCreditPerHour = violationProb * params.sla.creditPerViolationPct / 100;\n    const slaRiskBuffer = basePerHour * expectedCreditPerHour * 2;\n    const totalCostPerHour = computePerHour + powerPerHour + coolingPerHour + interconnectPerHour + opsPerHour + sparesPerHour + slaRiskBuffer;\n    const margin = totalCostPerHour * params.operatorMarginPct;\n    let pricePerGpuHour = totalCostPerHour + margin;\n    // FINAL CLAMP: GPU-hour price must be in reasonable range ($0.01 to $100)\n    // This prevents chart explosion from unit errors or calculation bugs\n    const MAX_REASONABLE_GPU_HOUR_PRICE = 100;\n    const MIN_REASONABLE_GPU_HOUR_PRICE = 0.01;\n    if (pricePerGpuHour > MAX_REASONABLE_GPU_HOUR_PRICE) {\n        if (true) {\n            console.error(\"[GPU-HOUR PRICING] pricePerGpuHour=\".concat(pricePerGpuHour, \" > \").concat(MAX_REASONABLE_GPU_HOUR_PRICE, \". \") + \"Clamping to \".concat(MAX_REASONABLE_GPU_HOUR_PRICE, \". \") + \"costPerPflopYear=\".concat(costPerPflopYear, \", basePerHour=\").concat(basePerHour, \", totalCostPerHour=\").concat(totalCostPerHour));\n        }\n        pricePerGpuHour = MAX_REASONABLE_GPU_HOUR_PRICE;\n    }\n    if (pricePerGpuHour < MIN_REASONABLE_GPU_HOUR_PRICE && pricePerGpuHour > 0) {\n        pricePerGpuHour = MIN_REASONABLE_GPU_HOUR_PRICE;\n    }\n    return {\n        gpuType: \"H100-equivalent\",\n        location: params.location,\n        sla: params.sla,\n        pricePerGpuHour,\n        costBreakdown: {\n            hardwareAmortization: computePerHour,\n            power: powerPerHour,\n            cooling: coolingPerHour,\n            interconnect: interconnectPerHour,\n            operations: opsPerHour,\n            spares: sparesPerHour,\n            slaRiskBuffer,\n            margin\n        },\n        effectiveUtilization: params.utilizationTarget,\n        sparesRatio\n    };\n}\nconst MODEL_UNITS = {\n    pflopDefinition: \"fp16\",\n    sustainedVsPeak: \"sustained\",\n    gflopsPerWattLevel: \"system\",\n    includesNetworkingOverhead: false\n};\nfunction assertComputePowerConsistency(gflopsPerWatt, computePowerKw, effectivePflops) {\n    let units = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : MODEL_UNITS;\n    // 1 PFLOP = 1e6 GFLOPS\n    // Power (W) = GFLOPS / (GFLOPS/W) = (effectivePflops * 1e6) / gflopsPerWatt\n    // Power (kW) = Power (W) / 1000\n    // gflopsPerWatt is at system level (includes power conversion, cooling)\n    const expectedKw = effectivePflops * 1e6 / gflopsPerWatt / 1000;\n    const discrepancy = computePowerKw / expectedKw;\n    return {\n        valid: discrepancy > 0.5 && discrepancy < 2.0,\n        ratio: discrepancy,\n        expectedKw,\n        discrepancy\n    };\n}\nconst BASE_SITE_2025 = 1500; // Base site cost in 2025 ($/PFLOP-year)\nfunction calculateGroundTotal(year, params, energyCostBase, hardwareCostBase, isStaticMode, effectiveScenario) {\n    let latencyPenalty = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1.0, smrParams = arguments.length > 7 ? arguments[7] : void 0, firstCapYear = arguments.length > 8 ? arguments[8] : void 0, actualEnergyCostPerPflopYear = arguments.length > 9 ? arguments[9] : void 0, actualElectricityPricePerMwh = arguments.length > 10 ? arguments[10] : void 0;\n    const yearsFromBase = Math.max(0, year - 2025);\n    let siteCostBase = BASE_SITE_2025;\n    const enabled = params.groundConstraintsEnabled && !params.isStaticMode;\n    // SMR Toggle logic\n    const smrEnabled = (smrParams === null || smrParams === void 0 ? void 0 : smrParams.enabled) && year >= (smrParams.smrDeploymentStartYear || 2030);\n    let smrRampFactor = 0;\n    let constraintRelief = {\n        grid: 0,\n        cooling: 0,\n        water: 0,\n        land: 0\n    };\n    if (smrEnabled && smrParams) {\n        const yearsActive = year - smrParams.smrDeploymentStartYear;\n        smrRampFactor = Math.min(1, yearsActive / smrParams.smrRampUpYears);\n        // Apply constraint relief\n        constraintRelief = {\n            grid: smrParams.gridConstraintRelief * smrRampFactor,\n            cooling: smrParams.coolingConstraintRelief * smrRampFactor,\n            water: smrParams.waterConstraintRelief * smrRampFactor,\n            land: smrParams.landConstraintRelief * smrRampFactor\n        };\n        siteCostBase = BASE_SITE_2025 * (1 + (smrParams.smrCapexPremium - 1) * smrRampFactor);\n    }\n    // REFACTORED: Split energy (no multiplier) vs capacity/delivery premium (with multiplier)\n    // \n    // Energy cost: Raw electricity price * kWh (NO constraint multiplier)\n    // - Represents actual market electricity price\n    // - Grows with electricity price trajectory, not infrastructure scarcity\n    const energyCost = actualEnergyCostPerPflopYear !== null && actualEnergyCostPerPflopYear !== void 0 ? actualEnergyCostPerPflopYear : energyCostBase;\n    const effectiveElectricityPrice = actualElectricityPricePerMwh !== null && actualElectricityPricePerMwh !== void 0 ? actualElectricityPricePerMwh : 120;\n    if (!enabled) {\n        // No constraints: all costs at base, no premium\n        const total = (energyCost + siteCostBase + hardwareCostBase) * latencyPenalty;\n        return {\n            energyCost: energyCost * latencyPenalty,\n            siteCost: siteCostBase * latencyPenalty,\n            hardwareCost: hardwareCostBase * latencyPenalty,\n            capacityDeliveryPremium: 0,\n            timeToEnergizePenalty: 0,\n            totalCostPerPflopYear: total,\n            constraintMultiplier: 1.0,\n            breakdown: {\n                grid: 1.0,\n                cooling: 1.0,\n                water: 1.0,\n                land: 1.0,\n                energyMultiplier: 1.0,\n                siteMultiplier: 1.0,\n                capacityDeliveryMultiplier: 1.0\n            },\n            smrEnabled,\n            smrRampFactor,\n            effectiveElectricityCost: effectiveElectricityPrice,\n            constraintRelief\n        };\n    }\n    // CRITICAL FIX: Use queue-derived constraints, NOT time-based exponential\n    // This function is only used when NOT using buildout/queue models (legacy path)\n    // For consistency, use minimal constraints here (base costs only)\n    // Real constraint pricing should come from buildout/queue models\n    // GROUND COST ACCOUNTING: Explicit separation of components (ADDITIVE ONLY)\n    // \n    // 1. siteCapexAmortPerPflopYear: Pure amortized capex\n    //    - Buildings + power delivery inside site + cooling plant\n    //    - Base cost, NOT affected by constraint\n    const siteCapexAmortPerPflopYear = siteCostBase;\n    // 2. capacityDeliveryPremiumPerPflopYear: Scarcity price for firm MW at right place/time\n    //    - Set to zero in legacy path (constraints should come from buildout/queue models)\n    //    - This path is only for backward compatibility\n    const capacityDeliveryPremiumPerPflopYear = 0;\n    // 3. timeToEnergizePenaltyPerPflopYear: Financing cost of waiting (WACC + delay years)\n    //    - Set to zero in legacy path (delay penalties should come from buildout/queue models)\n    //    - This path is only for backward compatibility\n    const timeToEnergizePenaltyPerPflopYear = 0;\n    // CRITICAL: Remove double counting\n    // Do NOT include timeToEnergizePenalty in headline cost used for crossover\n    // (capacity gating in market share already accounts for backlog)\n    // Compute both base and effective costs:\n    const siteCostPerPflopYear_base = siteCapexAmortPerPflopYear + capacityDeliveryPremiumPerPflopYear;\n    const siteCostPerPflopYear_effective = siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + capacityDeliveryPremiumPerPflopYear;\n    // Validation: siteCost_effective must equal sum of components\n    const siteCostCheck = Math.abs(siteCostPerPflopYear_effective - (siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + capacityDeliveryPremiumPerPflopYear));\n    if (siteCostCheck > 0.01) {\n        throw new Error(\"Site cost accounting error: siteCost_effective=\".concat(siteCostPerPflopYear_effective, \" != sum(components)=\").concat(siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + capacityDeliveryPremiumPerPflopYear, \", diff=\").concat(siteCostCheck));\n    }\n    const hardware = hardwareCostBase;\n    // Headline cost for crossover: base only (excludes delay penalty, which is handled via capacity gating)\n    const total = (energyCost + siteCostPerPflopYear_base + hardware) * latencyPenalty;\n    // Effective/all-in cost: includes delay penalty (for reference/debug)\n    const totalEffective = (energyCost + siteCostPerPflopYear_effective + hardware) * latencyPenalty;\n    return {\n        energyCost: energyCost * latencyPenalty,\n        siteCost: siteCostPerPflopYear_base * latencyPenalty,\n        hardwareCost: hardware * latencyPenalty,\n        siteCapexAmortPerPflopYear: siteCapexAmortPerPflopYear * latencyPenalty,\n        capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear * latencyPenalty,\n        timeToEnergizePenalty: timeToEnergizePenaltyPerPflopYear * latencyPenalty,\n        totalCostPerPflopYear: total,\n        totalCostPerPflopYearEffective: totalEffective,\n        constraintMultiplier: 1.0,\n        breakdown: {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        },\n        constraints: {\n            method: \"adders\",\n            capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear * latencyPenalty,\n            delayPenalty: timeToEnergizePenaltyPerPflopYear * latencyPenalty,\n            appliedMultipliers: {\n                constraintMultiplierUsed: false,\n                energyMultiplierUsed: false,\n                siteMultiplierUsed: false\n            },\n            debug: {\n                doubleCountCheck: {\n                    mode: \"adders\",\n                    multiplierApplied: false,\n                    addersApplied: capacityDeliveryPremiumPerPflopYear > 0 || timeToEnergizePenaltyPerPflopYear > 0,\n                    invariantOk: true,\n                    notes: \"calculateGroundTotal uses adders only (capacityDeliveryPremium + timeToEnergizePenalty)\"\n                }\n            }\n        },\n        smrEnabled,\n        smrRampFactor,\n        effectiveElectricityCost: effectiveElectricityPrice,\n        constraintRelief\n    };\n}\nfunction computePhysicsCost(rawParams) {\n    let firstCapYear = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n    var _hybridResult_regulatory, _groundResult_constraints, _groundResult_constraints1, _params_edgeInference, _hybridResult_specificPowerMultipliers, _hybridResult_computePayload, _hybridResult_specificPowerMultipliers1, _groundResult_buildoutDebug, _groundResult_supplyMetrics, _groundResult_supplyMetrics1, _groundResult_supplyMetrics2, _groundResult_buildoutDebug1, _groundResult_supplyMetrics3, _groundResult_buildoutDebug2, _groundResult_buildoutDebug3;\n    const params = applyStaticFreeze(rawParams);\n    const { year, isStaticMode, launchCostKg: baseLaunchCost, specificPowerWKg: trajSpecificPower, groundEffectiveGflopsPerW_2025: rawGroundEffectiveGflopsPerW_2025, orbitEffectiveGflopsPerW_2025: rawOrbitEffectiveGflopsPerW_2025, pueGround, pueOrbital, capacityFactorGround, targetGW, satellitePowerKW, groundConstraintsEnabled, powerGridMultiplier, coolingMultiplier, waterScarcityEnabled, landScarcityEnabled, spaceTrafficEnabled, orbitalAltitude, useRadHardChips, sunFraction, groundScenario, smrMitigationEnabled, workloadType, elonScenarioEnabled, globalLatencyRequirementEnabled, spaceManufacturingEnabled, aiWinterEnabled } = params;\n    var _ref;\n    // CRITICAL FIX: Handle parameter name migration\n    // Old names: flopsPerWattGround, flopsPerWattOrbital (DEPRECATED - delete conversion logic)\n    // New names: groundEffectiveGflopsPerW_2025, orbitEffectiveGflopsPerW_2025\n    // Parameters are ALREADY in GFLOPS/W (not FLOPS/W) - no conversion needed\n    const actualGroundInput = (_ref = rawGroundEffectiveGflopsPerW_2025 !== null && rawGroundEffectiveGflopsPerW_2025 !== void 0 ? rawGroundEffectiveGflopsPerW_2025 : params.gflopsPerWattGround2025) !== null && _ref !== void 0 ? _ref : params.flopsPerWattGround;\n    var _ref1;\n    const actualOrbitInput = (_ref1 = rawOrbitEffectiveGflopsPerW_2025 !== null && rawOrbitEffectiveGflopsPerW_2025 !== void 0 ? rawOrbitEffectiveGflopsPerW_2025 : params.gflopsPerWattOrbital2025) !== null && _ref1 !== void 0 ? _ref1 : params.flopsPerWattOrbital;\n    // CANONICAL COMPUTE EFFICIENCY: Single source of truth for GFLOPS/W\n    // Parameter is interpreted as GFLOPS/W (not FLOPS/W) - no 1e9/1e12 conversions\n    let groundEfficiencyResult;\n    let orbitalEfficiencyResult;\n    // Ground: Use canonical ComputeEfficiency function\n    // CRITICAL FIX: Parameter is ALREADY in GFLOPS/W (not FLOPS/W)\n    // No unit conversion - treat input as effective GFLOPS/W directly\n    if (!actualGroundInput || !isFinite(actualGroundInput) || actualGroundInput <= 0) {\n        // Invalid input - use default\n        groundEfficiencyResult = (0,_compute_efficiency__WEBPACK_IMPORTED_MODULE_8__.getDefaultComputeEfficiency)(\"NVIDIA H100 SXM\", year, \"FP16\");\n    } else {\n        // Input is effective GFLOPS/W - derive chip peak assuming standard factors\n        // effective = chipPeak * utilization / systemOverhead\n        // So: chipPeak = effective * systemOverhead / utilization\n        const systemOverheadFactor = 1.18; // PUE 1.18 equivalent\n        const utilizationFactor = 0.70;\n        const chipPeakGflopsPerW = actualGroundInput * systemOverheadFactor / utilizationFactor;\n        // FAIL-FAST INVARIANT: Chip peak must be in realistic range [1, 20000] GFLOPS/W\n        if (chipPeakGflopsPerW < 1 || chipPeakGflopsPerW > 20000) {\n            throw new Error(\"GROUND COMPUTE EFFICIENCY UNIT MISMATCH: \" + \"chipPeakGflopsPerW=\".concat(chipPeakGflopsPerW.toFixed(2), \" is outside valid range [1, 20000] GFLOPS/W. \") + \"Input: actualGroundInput=\".concat(actualGroundInput, \", \") + \"This suggests a units error. Expected range: 30-5000 GFLOPS/W for system-level efficiency.\");\n        }\n        groundEfficiencyResult = (0,_compute_efficiency__WEBPACK_IMPORTED_MODULE_8__.ComputeEfficiency)({\n            chipPeakGflopsPerW,\n            utilizationFactor,\n            systemOverheadFactor\n        });\n        // FAIL-FAST INVARIANT: Effective GFLOPS/W must be in realistic range [1, 5000] GFLOPS/W\n        if (groundEfficiencyResult.effectiveGflopsPerW < 1 || groundEfficiencyResult.effectiveGflopsPerW > 5000) {\n            throw new Error(\"GROUND COMPUTE EFFICIENCY OUT OF RANGE: \" + \"effectiveGflopsPerW=\".concat(groundEfficiencyResult.effectiveGflopsPerW.toFixed(2), \" is outside valid range [1, 5000] GFLOPS/W. \") + \"Input: actualGroundInput=\".concat(actualGroundInput, \", \") + \"chipPeakGflopsPerW=\".concat(chipPeakGflopsPerW.toFixed(2), \". \") + \"This suggests a units error or invalid input.\");\n        }\n    }\n    // Orbital: Same logic - parameter is ALREADY in GFLOPS/W (not FLOPS/W)\n    // No unit conversion - treat input as effective GFLOPS/W directly\n    if (!actualOrbitInput || !isFinite(actualOrbitInput) || actualOrbitInput <= 0) {\n        // Invalid input - use default\n        orbitalEfficiencyResult = (0,_compute_efficiency__WEBPACK_IMPORTED_MODULE_8__.getDefaultComputeEfficiency)(\"H100-equivalent (rad-tolerant)\", year, \"FP16\");\n    } else {\n        // Input is effective GFLOPS/W - derive chip peak\n        const systemOverheadFactor = 1.18;\n        const utilizationFactor = 0.65;\n        const chipPeakGflopsPerW = actualOrbitInput * systemOverheadFactor / utilizationFactor;\n        // FAIL-FAST INVARIANT: Chip peak must be in realistic range [1, 20000] GFLOPS/W\n        if (chipPeakGflopsPerW < 1 || chipPeakGflopsPerW > 20000) {\n            throw new Error(\"ORBITAL COMPUTE EFFICIENCY UNIT MISMATCH: \" + \"chipPeakGflopsPerW=\".concat(chipPeakGflopsPerW.toFixed(2), \" is outside valid range [1, 20000] GFLOPS/W. \") + \"Input: actualOrbitInput=\".concat(actualOrbitInput, \", \") + \"This suggests a units error. Expected range: 25-4000 GFLOPS/W for system-level efficiency.\");\n        }\n        orbitalEfficiencyResult = (0,_compute_efficiency__WEBPACK_IMPORTED_MODULE_8__.ComputeEfficiency)({\n            chipPeakGflopsPerW,\n            utilizationFactor,\n            systemOverheadFactor\n        });\n        // FAIL-FAST INVARIANT: Effective GFLOPS/W must be in realistic range [1, 5000] GFLOPS/W\n        if (orbitalEfficiencyResult.effectiveGflopsPerW < 1 || orbitalEfficiencyResult.effectiveGflopsPerW > 5000) {\n            throw new Error(\"ORBITAL COMPUTE EFFICIENCY OUT OF RANGE: \" + \"effectiveGflopsPerW=\".concat(orbitalEfficiencyResult.effectiveGflopsPerW.toFixed(2), \" is outside valid range [1, 5000] GFLOPS/W. \") + \"Input: actualOrbitInput=\".concat(actualOrbitInput, \", \") + \"chipPeakGflopsPerW=\".concat(chipPeakGflopsPerW.toFixed(2), \". \") + \"This suggests a units error or invalid input.\");\n        }\n    }\n    // HARD ASSERT: Ground efficiency must always be populated and finite\n    if (!groundEfficiencyResult || !isFinite(groundEfficiencyResult.effectiveGflopsPerW) || groundEfficiencyResult.effectiveGflopsPerW <= 0) {\n        throw new Error(\"CRITICAL: Ground compute efficiency is invalid. \" + \"actualGroundInput=\".concat(actualGroundInput, \", \") + \"rawGroundEffectiveGflopsPerW_2025=\".concat(rawGroundEffectiveGflopsPerW_2025, \", \") + \"gflopsPerWattGround2025=\".concat(params.gflopsPerWattGround2025, \", \") + \"groundEfficiencyResult=\".concat(JSON.stringify(groundEfficiencyResult)));\n    }\n    // CRITICAL FIX: Standardize compute-efficiency level definitions\n    // Standard definitions:\n    // - peakGflopsPerWatt: chip peak (no utilization, no overhead, no derates)\n    // - systemEffectiveGflopsPerWatt: peak * utilization / systemOverheadFactor (SYSTEM-LEVEL EFFECTIVE)\n    // - deliveredGflopsPerWatt: systemEffective * thermalCapFactor * radiationDerate * availability\n    // Ground: systemEffective only (no delivery derates)\n    const groundEffectiveGflopsPerW = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(groundEfficiencyResult.effectiveGflopsPerW, \"ground efficiency calculation\");\n    // Orbital: Track all three levels\n    const orbitPeakGflopsPerWatt = orbitalEfficiencyResult.debug.chipPeakGflopsPerW;\n    const orbitSystemEffectiveGflopsPerWatt = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(orbitalEfficiencyResult.effectiveGflopsPerW, \"orbital systemEffective efficiency calculation\");\n    // NOTE: deliveredGflopsPerWatt will be calculated after thermal system is computed\n    // It will be: systemEffective * thermalCapFactor * radiationDerate * availability\n    // AI Winter: Constraints grow 50% slower\n    const effectiveGroundScenario = aiWinterEnabled && year >= 2028 ? {\n        ...GROUND_SCENARIOS[groundScenario],\n        gridGrowthRate: GROUND_SCENARIOS[groundScenario].gridGrowthRate * 0.5,\n        coolingGrowthRate: GROUND_SCENARIOS[groundScenario].coolingGrowthRate * 0.5,\n        waterGrowthRate: GROUND_SCENARIOS[groundScenario].waterGrowthRate * 0.5,\n        landGrowthRate: GROUND_SCENARIOS[groundScenario].landGrowthRate * 0.5\n    } : GROUND_SCENARIOS[groundScenario];\n    // Elon Scenario: Discounts\n    const launchDiscount = elonScenarioEnabled ? 0.50 : 1.0;\n    const powerDiscount = elonScenarioEnabled ? 0.70 : 1.0;\n    const networkingDiscount = elonScenarioEnabled ? 0.10 : 1.0;\n    const operatorMargin = elonScenarioEnabled ? 0.05 : 0.20;\n    // Global Latency: 3x ground overprovisioning penalty\n    const groundLatencyPenalty = globalLatencyRequirementEnabled && year >= 2028 ? 3.0 : 1.0;\n    // Space Manufacturing: Mass reduction\n    let massMultiplier = 1.0;\n    if (spaceManufacturingEnabled && year >= 2032) {\n        const yearsSinceStart = year - 2032;\n        const ramp = Math.min(1.0, yearsSinceStart / 5);\n        massMultiplier = 1.0 - 0.60 * ramp;\n    }\n    // EMERGENCY FIX: Use simple fixed 2025 base values\n    // These are the known-correct values from the emergency fix\n    // Don't try to calculate from flopsPerWatt - just use these constants\n    const BASE_ENERGY_2025 = 581; // $/PFLOP-year (fixed 2025 base)\n    const BASE_SITE_2025 = 1500; // $/PFLOP-year (fixed 2025 base)\n    const ENERGY_COST_BASE_2025 = BASE_ENERGY_2025; // Use fixed base, not calculated\n    // For reference/display (not used in constraint calculation)\n    const BASE_ELECTRICITY_PRICE_2025 = 120; // $/MWh (2025 baseline)\n    let groundElectricityPricePerMwh = BASE_ELECTRICITY_PRICE_2025;\n    if (!params.isStaticMode) {\n        groundElectricityPricePerMwh *= Math.pow(1.02, year - 2025);\n    }\n    const effectivePueGround = pueGround + (year - 2025) * 0.01;\n    // Convert GFLOPS/W to power: 1 PFLOP = 1e6 GFLOPS, so power (W) = (1e6 GFLOPS) / (GFLOPS/W)\n    const groundEnergyMWhPerPflopYear = 8760 * 1e6 / groundEffectiveGflopsPerW * effectivePueGround / 1e6;\n    const groundEnergyCostPerPflopYear = groundEnergyMWhPerPflopYear * groundElectricityPricePerMwh * capacityFactorGround;\n    const computeGroundHardwareCost = (y, baseCost)=>{\n        const yearIndex = y - 2025;\n        let cost = baseCost;\n        for(let i = 0; i < yearIndex; i++){\n            let annualDecline;\n            if (i < 3) annualDecline = 0.10;\n            else if (i < 6) annualDecline = 0.05;\n            else if (i < 10) annualDecline = 0.02;\n            else annualDecline = 0.005;\n            cost *= 1 - annualDecline;\n        }\n        return cost;\n    };\n    var _params_groundHardwareLifetimeYears;\n    const groundLifetime = (_params_groundHardwareLifetimeYears = params.groundHardwareLifetimeYears) !== null && _params_groundHardwareLifetimeYears !== void 0 ? _params_groundHardwareLifetimeYears : CONSTANTS.GROUND_HARDWARE_LIFETIME;\n    const groundHardwareCapexPerPflopYear = computeGroundHardwareCost(year, CONSTANTS.GROUND_HARDWARE_COST_PFLOP_2025) / groundLifetime;\n    const smrParams = params.smrToggleEnabled ? params.smrToggleParams || DEFAULT_SMR_PARAMS : undefined;\n    let groundResult;\n    let groundTotalCost;\n    let groundComparatorCostPerPflopYear; // Comparator cost for crossover (uses effective when queue exists)\n    let groundHasQueue = false; // Track if ground has queue/backlog (for debug and comparator cost)\n    let energyConstraintMultiplier;\n    let constraintBreakdown;\n    const useRegionalModel = params.useRegionalGroundModel === true && params.groundConstraintsEnabled && !params.isStaticMode;\n    // FIX: Make buildout model the default (it correctly uses responsive demand)\n    // Queue model requires full demand trajectory to work correctly, so it's opt-in only\n    // Only use queue model if explicitly enabled (useQueueBasedConstraint === true)\n    const useQueueModel = params.useQueueBasedConstraint === true && params.groundConstraintsEnabled && !params.isStaticMode && !useRegionalModel;\n    // Buildout model is the default (defaults to true unless explicitly disabled)\n    const useBuildoutModel = params.useBuildoutModel !== false && params.groundConstraintsEnabled && !params.isStaticMode && !useRegionalModel && !useQueueModel;\n    if (useQueueModel) {\n        // Pass responsive demand and orbital substitution to queue model (if available from trajectory.ts)\n        const responsiveDemandGW = params.responsiveDemandGW;\n        const orbitalSubstitutionGW = params.orbitalSubstitutionGW;\n        // Build demand map if responsive demand is provided\n        const demandByYear = responsiveDemandGW !== undefined ? new Map([\n            [\n                year,\n                responsiveDemandGW\n            ]\n        ]) : undefined;\n        const orbitalSubstitutionByYear = orbitalSubstitutionGW !== undefined ? new Map([\n            [\n                year,\n                orbitalSubstitutionGW\n            ]\n        ]) : undefined;\n        const supplyTrajectory = (0,_ground_queue_model__WEBPACK_IMPORTED_MODULE_4__.generateGroundSupplyTrajectory)(2025, year, demandByYear, orbitalSubstitutionByYear);\n        const currentSupplyState = supplyTrajectory[supplyTrajectory.length - 1];\n        // Debug: Log if responsive demand is being ignored\n        if ( true && responsiveDemandGW !== undefined) {\n            const hardcodedDemand = (0,_ground_queue_model__WEBPACK_IMPORTED_MODULE_4__.getGlobalDemandGw)(year);\n            if (Math.abs(currentSupplyState.demandGw - hardcodedDemand) < 1e-6) {\n                console.warn(\"[QUEUE MODEL DEBUG] Year \".concat(year, \": Responsive demand (\").concat(responsiveDemandGW.toFixed(2), \" GW) may be ignored. \") + \"Queue model using: \".concat(currentSupplyState.demandGw.toFixed(2), \" GW (hardcoded: \").concat(hardcodedDemand.toFixed(2), \" GW)\"));\n            } else {\n                console.log(\"[QUEUE MODEL DEBUG] Year \".concat(year, \": Using responsive demand \").concat(responsiveDemandGW.toFixed(2), \" GW \") + \"(queue model: \".concat(currentSupplyState.demandGw.toFixed(2), \" GW)\"));\n            }\n        }\n        var _params_wacc, _params_waccBacklogK, _params_waccBacklogExponent, _params_criticalBacklogGW;\n        // Calculate WACC-based penalties and multipliers\n        // Pass WACC parameters for capital rationing (WACC rises with backlog)\n        const waccParams = {\n            baseWacc: (_params_wacc = params.wacc) !== null && _params_wacc !== void 0 ? _params_wacc : 0.10,\n            waccBacklogK: (_params_waccBacklogK = params.waccBacklogK) !== null && _params_waccBacklogK !== void 0 ? _params_waccBacklogK : 0.5,\n            waccBacklogExponent: (_params_waccBacklogExponent = params.waccBacklogExponent) !== null && _params_waccBacklogExponent !== void 0 ? _params_waccBacklogExponent : 1.2,\n            criticalBacklogGW: (_params_criticalBacklogGW = params.criticalBacklogGW) !== null && _params_criticalBacklogGW !== void 0 ? _params_criticalBacklogGW : 50\n        };\n        const penalties = (0,_ground_constraint_penalties__WEBPACK_IMPORTED_MODULE_5__.calculateGroundConstraintPenalties)(currentSupplyState, groundEffectiveGflopsPerW, effectivePueGround, capacityFactorGround, waccParams);\n        const BASE_SITE_2025 = 1500;\n        // Energy cost: Use actual calculated value (NOT multiplied by constraint)\n        // CRITICAL FIX: Do NOT apply PUE multiplier - energy cost is base only\n        // PUE stress should be reflected in capacityDeliveryPremium, not energy multiplier\n        const energyCostBase = groundEnergyCostPerPflopYear;\n        const energyCost = energyCostBase; // Base energy cost only - no multiplier\n        // GROUND COST ACCOUNTING: Explicit separation of components (queue model)\n        const siteCostBase = BASE_SITE_2025;\n        // 1. siteCapexAmortPerPflopYear: Pure amortized capex (NOT affected by constraint)\n        const siteCapexAmortPerPflopYear = siteCostBase;\n        // CHOICE: Use delayPenalty + scarcityRent (Hill-based), NOT capacityDeliveryPremium\n        // Set capacityDeliveryPremium to 0 to avoid triple-charging\n        const capacityDeliveryPremiumPerPflopYear = 0; // NOT USED - using delayPenalty + scarcityRent instead\n        // 1. timeToEnergizePenaltyPerPflopYear: Bounded linear WACC carry (NOT exponential)\n        const timeToEnergizePenaltyPerPflopYear = penalties.timeToEnergizePenaltyPerPflopYear;\n        // 2. scarcityRentPerPflopYear: Hill function of avgWaitYears (w50=2.0, n=2.0, rentMax=0.65)\n        // Base cost for scarcity rent = hardware + site (no capacityDeliveryPremium)\n        const capexAnnualBasePerPflopYear = groundHardwareCapexPerPflopYear + siteCapexAmortPerPflopYear;\n        // Calculate scarcity multiplier using LOG-BASED function (never fully saturates)\n        // Returns multiplier (1.0 = no scarcity, 2.0 = 2x price) - MULTIPLICATIVE, not additive\n        const scarcityRentResult = (0,_ground_constraint_penalties__WEBPACK_IMPORTED_MODULE_5__.calculateScarcityRent)(currentSupplyState.avgWaitYears, currentSupplyState.utilizationPct, {\n            waitThresholdYears: 1.0,\n            rentMaxMultiplier: 2.0,\n            utilizationThreshold: 0.85\n        });\n        const scarcityMultiplier = scarcityRentResult.scarcityMultiplier;\n        // For backward compatibility: scarcityRentPerPflopYear = 0 (scarcity is now multiplicative)\n        const scarcityRentPerPflopYear = 0;\n        // Debug: verify queue model consistency\n        if (true) {\n            var _currentSupplyState_unservedGw;\n            const unservedGw = (_currentSupplyState_unservedGw = currentSupplyState.unservedGw) !== null && _currentSupplyState_unservedGw !== void 0 ? _currentSupplyState_unservedGw : currentSupplyState.demandGw - currentSupplyState.capacityGw;\n            if (currentSupplyState.demandGw < currentSupplyState.capacityGw && currentSupplyState.backlogGw > 50) {\n                console.warn(\"[QUEUE MODEL] Year \".concat(year, \": demandGw=\").concat(currentSupplyState.demandGw.toFixed(1), \" < capacityGw=\").concat(currentSupplyState.capacityGw.toFixed(1), \" \") + \"but backlogGw=\".concat(currentSupplyState.backlogGw.toFixed(1), \" > 50. This may indicate queue model issue.\"));\n            }\n        }\n        // CRITICAL: Remove double counting\n        // Do NOT include timeToEnergizePenalty + scarcityRent in headline cost used for crossover\n        // (capacity gating in market share already accounts for backlog)\n        // Compute both base and effective costs:\n        const siteCostPerPflopYear_base = siteCapexAmortPerPflopYear; // No capacityDeliveryPremium\n        const siteCostPerPflopYear_effective = siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + scarcityRentPerPflopYear;\n        // Validation\n        const expectedEffective = siteCapexAmortPerPflopYear + capacityDeliveryPremiumPerPflopYear + timeToEnergizePenaltyPerPflopYear + scarcityRentPerPflopYear;\n        const siteCostCheck = Math.abs(siteCostPerPflopYear_effective - expectedEffective);\n        if (siteCostCheck > 0.01) {\n            throw new Error(\"Site cost accounting error (queue model): siteCost_effective=\".concat(siteCostPerPflopYear_effective, \" != sum(components)=\").concat(expectedEffective, \" (siteCapex=\").concat(siteCapexAmortPerPflopYear, \", premium=\").concat(capacityDeliveryPremiumPerPflopYear, \", delay=\").concat(timeToEnergizePenaltyPerPflopYear, \", scarcity=\").concat(scarcityRentPerPflopYear, \"), diff=\").concat(siteCostCheck));\n        }\n        const hardwareCost = groundHardwareCapexPerPflopYear;\n        // UNIFIED SCARCITY ACCOUNTING: Keep totalCostPerPflopYear physical-only\n        // Scarcity (delayPenalty + scarcityRent) is treated purely in GPU-hour pricing, not in PFLOP-year cost\n        groundTotalCost = (energyCost + siteCostPerPflopYear_base + hardwareCost) * groundLatencyPenalty;\n        // For crossover: use base cost (scarcity is already reflected in GPU-hour pricing)\n        // This ensures we don't double-count scarcity\n        groundHasQueue = timeToEnergizePenaltyPerPflopYear > 0.01;\n        groundComparatorCostPerPflopYear = groundTotalCost; // Base cost only (scarcity in GPU-hour)\n        // CRITICAL FIX: Remove all multipliers - use additive terms only\n        // Multipliers are NOT applied to any dollar amounts\n        // All constraint effects are captured in capacityDeliveryPremium and timeToEnergizePenalty\n        energyConstraintMultiplier = 1.0; // Never applied - for backward compat only\n        // Constraint breakdown: all multipliers set to 1.0 (not applied)\n        // These are kept for debug/decomposition but never multiplied into costs\n        constraintBreakdown = {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        };\n        var _currentSupplyState_avgWaitYearsRaw, _currentSupplyState_unservedGw1, _currentSupplyState_deliveredFromBacklogGw, _currentSupplyState_unservedGw2, _currentSupplyState_deliveredFromBacklogGw1, _currentSupplyState_avgWaitYearsRaw1;\n        groundResult = {\n            energyCost: energyCost * groundLatencyPenalty,\n            siteCost: siteCostPerPflopYear_base * groundLatencyPenalty,\n            hardwareCost: hardwareCost * groundLatencyPenalty,\n            siteCapexAmortPerPflopYear: siteCapexAmortPerPflopYear * groundLatencyPenalty,\n            capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear * groundLatencyPenalty,\n            timeToEnergizePenalty: timeToEnergizePenaltyPerPflopYear * groundLatencyPenalty,\n            totalCostPerPflopYear: groundTotalCost,\n            totalCostPerPflopYearEffective: groundTotalCost,\n            totalCostPerPflopYearAllIn: groundTotalCost,\n            constraintMultiplier: 1.0,\n            breakdown: constraintBreakdown,\n            constraints: {\n                method: \"adders\",\n                capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear * groundLatencyPenalty,\n                delayPenalty: timeToEnergizePenaltyPerPflopYear * groundLatencyPenalty,\n                scarcityRentPerPflopYear: scarcityRentPerPflopYear * groundLatencyPenalty,\n                scarcityMultiplier: scarcityMultiplier,\n                appliedMultipliers: {\n                    constraintMultiplierUsed: false,\n                    energyMultiplierUsed: false,\n                    siteMultiplierUsed: false\n                },\n                // Debug fields for Hill-based scarcity rent (wait-time based)\n                scarcityHill: scarcityRentResult.scarcityHill,\n                avgWaitYearsRaw: (_currentSupplyState_avgWaitYearsRaw = currentSupplyState.avgWaitYearsRaw) !== null && _currentSupplyState_avgWaitYearsRaw !== void 0 ? _currentSupplyState_avgWaitYearsRaw : currentSupplyState.avgWaitYears,\n                avgWaitYearsClamped: scarcityRentResult.avgWaitYearsClamped,\n                rentFrac: scarcityRentResult.rentFrac,\n                // Additional debug fields for verification\n                backlogGw: currentSupplyState.backlogGw,\n                unservedGw: (_currentSupplyState_unservedGw1 = currentSupplyState.unservedGw) !== null && _currentSupplyState_unservedGw1 !== void 0 ? _currentSupplyState_unservedGw1 : 0,\n                deliveredFromBacklogGw: (_currentSupplyState_deliveredFromBacklogGw = currentSupplyState.deliveredFromBacklogGw) !== null && _currentSupplyState_deliveredFromBacklogGw !== void 0 ? _currentSupplyState_deliveredFromBacklogGw : 0,\n                baseCostPerPflopYear: capexAnnualBasePerPflopYear * groundLatencyPenalty,\n                totalCostPerPflopYear: groundTotalCost\n            },\n            supplyMetrics: {\n                demandGw: currentSupplyState.demandGw,\n                capacityGw: currentSupplyState.capacityGw,\n                pipelineGw: currentSupplyState.pipelineGw,\n                maxBuildRateGwYear: currentSupplyState.maxBuildRateGwYear,\n                avgWaitYears: currentSupplyState.avgWaitYears,\n                utilizationPct: currentSupplyState.utilizationPct,\n                // Debug fields for queue model verification\n                backlogGw: currentSupplyState.backlogGw,\n                unservedGw: (_currentSupplyState_unservedGw2 = currentSupplyState.unservedGw) !== null && _currentSupplyState_unservedGw2 !== void 0 ? _currentSupplyState_unservedGw2 : 0,\n                deliveredFromBacklogGw: (_currentSupplyState_deliveredFromBacklogGw1 = currentSupplyState.deliveredFromBacklogGw) !== null && _currentSupplyState_deliveredFromBacklogGw1 !== void 0 ? _currentSupplyState_deliveredFromBacklogGw1 : 0,\n                avgWaitYearsRaw: (_currentSupplyState_avgWaitYearsRaw1 = currentSupplyState.avgWaitYearsRaw) !== null && _currentSupplyState_avgWaitYearsRaw1 !== void 0 ? _currentSupplyState_avgWaitYearsRaw1 : currentSupplyState.avgWaitYears\n            },\n            constraintComponents: {\n                queuePressure: currentSupplyState.avgWaitYears > 0 ? 1 + currentSupplyState.avgWaitYears / 2 : 1,\n                utilizationPressure: currentSupplyState.utilizationPct > 0.85 ? 1 + (currentSupplyState.utilizationPct - 0.85) * 5 : 1,\n                scarcityPremium: penalties.siteMultiplier\n            },\n            // Debug fields for WACC penalties\n            backlogGw: penalties.backlogGw,\n            avgWaitYears: penalties.avgWaitYears,\n            capexAtRiskPerMW: penalties.capexAtRiskPerMW,\n            carryCostPerMW: penalties.carryCostPerMW,\n            lostMarginPerMW: penalties.lostMarginPerMW,\n            timeToEnergizePenaltyPerPflopYear: penalties.timeToEnergizePenaltyPerPflopYear,\n            pueMultiplier: penalties.pueMultiplier,\n            smrEnabled: false,\n            smrRampFactor: 0,\n            effectiveElectricityCost: groundElectricityPricePerMwh,\n            constraintRelief: {\n                grid: 0,\n                cooling: 0,\n                water: 0,\n                land: 0\n            }\n        };\n    } else if (useBuildoutModel) {\n        var _groundResult_buildoutDebug4;\n        // NEW: Ramping Mobilization Model\n        // Replaces constraint multiplier with explicit buildout capex premium and delay penalties\n        // Uses ramping buildout capacity with smooth interpolation\n        // Get mobilization parameters (use defaults if not provided)\n        const mobilizationParams = params.mobilizationParams ? {\n            ..._ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_MOBILIZATION_PARAMS,\n            ...params.mobilizationParams,\n            demandCurve: params.mobilizationParams.demandCurve || _ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_MOBILIZATION_PARAMS.demandCurve\n        } : _ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_MOBILIZATION_PARAMS;\n        var _params_prevMobilizationState;\n        // Get previous mobilization state from params (passed from trajectory)\n        // If not provided, calculate from previous year's demand\n        const prevMobilizationState = (_params_prevMobilizationState = params.prevMobilizationState) !== null && _params_prevMobilizationState !== void 0 ? _params_prevMobilizationState : null;\n        // Step mobilization state forward\n        // Pass responsive demand and orbital substitution if available (from trajectory.ts)\n        const responsiveDemandGW = params.responsiveDemandGW;\n        const orbitalSubstitutionGW = params.orbitalSubstitutionGW;\n        const mobilizationResult = (0,_ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__.stepMobilizationState)(prevMobilizationState, mobilizationParams, year, effectivePueGround, 0, orbitalSubstitutionGW, responsiveDemandGW // Pass responsive demand (overrides hardcoded)\n        );\n        // Extract values from mobilization model\n        const demandNewGW = mobilizationResult.demandNewGW;\n        const buildRateGWyr = mobilizationResult.buildRateGWyr;\n        const buildableGW = buildRateGWyr; // buildable = build rate\n        const capacityGW = mobilizationResult.capacityGW;\n        const pipelineGW = mobilizationResult.pipelineGW;\n        const backlogGW = mobilizationResult.backlogGW;\n        const avgWaitYears = mobilizationResult.avgWaitYears;\n        var _params_wacc1;\n        // Default buildout parameters\n        const baseWacc = (_params_wacc1 = params.wacc) !== null && _params_wacc1 !== void 0 ? _params_wacc1 : 0.10; // 10% base WACC\n        const PROJECT_LIFETIME = 20; // 20 years\n        const BUILDOUT_CAPEX_BASE = 2000; // $2k/kW base buildout capex (reduced from 3k)\n        const DEFAULT_SCARCITY_CURVE = {\n            k: 2.0,\n            exponent: 1.7,\n            thresholdUtil: 0.0\n        };\n        const PANIC_EXPONENT = 1.3; // Exponent for delay penalty panic regime\n        var _params_waccBacklogK1;\n        // Compute effective WACC (rises with backlog - capital rationing)\n        const waccBacklogK = (_params_waccBacklogK1 = params.waccBacklogK) !== null && _params_waccBacklogK1 !== void 0 ? _params_waccBacklogK1 : 0.5;\n        var _params_waccBacklogExponent1;\n        const waccBacklogExponent = (_params_waccBacklogExponent1 = params.waccBacklogExponent) !== null && _params_waccBacklogExponent1 !== void 0 ? _params_waccBacklogExponent1 : 1.2;\n        var _params_criticalBacklogGW1;\n        const criticalBacklogGW = (_params_criticalBacklogGW1 = params.criticalBacklogGW) !== null && _params_criticalBacklogGW1 !== void 0 ? _params_criticalBacklogGW1 : 50;\n        const backlogRatio = Math.max(0, backlogGW / criticalBacklogGW);\n        const waccMultiplier = 1 + waccBacklogK * Math.pow(backlogRatio, waccBacklogExponent);\n        const waccEffective = baseWacc * waccMultiplier;\n        var _params_buildoutProjectLifetimeYears, _params_valueOfTimeMode, _params_buildoutCapexBase_$PerkW, _params_buildoutCapexScarcityCurve, _params_buildoutPanicExponent, _params_buildoutHybridWeights;\n        // Calculate buildout constraints\n        const buildoutParams = {\n            demandNewGWByYear: demandNewGW,\n            buildableGWByYear: buildableGW,\n            backlogGW: backlogGW,\n            avgWaitYears: avgWaitYears,\n            baseEnergyPricePerMwhByYear: groundElectricityPricePerMwh,\n            pueGroundByYear: effectivePueGround,\n            wacc: waccEffective,\n            projectLifetimeYears: (_params_buildoutProjectLifetimeYears = params.buildoutProjectLifetimeYears) !== null && _params_buildoutProjectLifetimeYears !== void 0 ? _params_buildoutProjectLifetimeYears : PROJECT_LIFETIME,\n            valueOfTimeMode: (_params_valueOfTimeMode = params.valueOfTimeMode) !== null && _params_valueOfTimeMode !== void 0 ? _params_valueOfTimeMode : \"wacc_on_capex\",\n            buildoutCapexBase_$PerkW: (_params_buildoutCapexBase_$PerkW = params.buildoutCapexBase_$PerkW) !== null && _params_buildoutCapexBase_$PerkW !== void 0 ? _params_buildoutCapexBase_$PerkW : BUILDOUT_CAPEX_BASE,\n            buildoutCapexScarcityCurve: (_params_buildoutCapexScarcityCurve = params.buildoutCapexScarcityCurve) !== null && _params_buildoutCapexScarcityCurve !== void 0 ? _params_buildoutCapexScarcityCurve : DEFAULT_SCARCITY_CURVE,\n            panicExponent: (_params_buildoutPanicExponent = params.buildoutPanicExponent) !== null && _params_buildoutPanicExponent !== void 0 ? _params_buildoutPanicExponent : PANIC_EXPONENT,\n            hardwareCapexPerPflopYear: groundHardwareCapexPerPflopYear,\n            siteCapexAmortPerPflopYear: BASE_SITE_2025,\n            // Legacy fields (kept for backward compat, but not used in new calculation)\n            computeHardwareCapex: groundHardwareCapexPerPflopYear * (groundEffectiveGflopsPerW * capacityFactorGround / effectivePueGround / 1e6),\n            siteCapex: BASE_SITE_2025 * (groundEffectiveGflopsPerW * capacityFactorGround / effectivePueGround / 1e6),\n            marginPerGpuHour: 0.5,\n            annualGpuHoursDelivered: 8760 * capacityFactorGround,\n            hybridWeights: (_params_buildoutHybridWeights = params.buildoutHybridWeights) !== null && _params_buildoutHybridWeights !== void 0 ? _params_buildoutHybridWeights : {\n                waccWeight: 0.5,\n                marginWeight: 0.5\n            }\n        };\n        const buildoutResult = (0,_ground_buildout__WEBPACK_IMPORTED_MODULE_6__.calculateBuildoutConstraints)(null, buildoutParams, year, groundEffectiveGflopsPerW, effectivePueGround, capacityFactorGround);\n        // Energy cost: base energy only (NOT affected by buildout constraints)\n        const energyCost = groundEnergyCostPerPflopYear;\n        // Site cost: base capex + buildout premium (engineering cost only, not scarcity pricing)\n        const siteCapexAmortPerPflopYear = BASE_SITE_2025;\n        const buildoutPremiumPerPflopYear = buildoutResult.buildoutPremiumPerPflopYear; // Base engineering cost only\n        const delayPenaltyPerPflopYear = buildoutResult.delayPenaltyPerPflopYear; // Linear: WACC * capex * waitYears\n        // CRITICAL: Wait-time-based scarcity rent (EARLY, SATURATING)\n        // Define annualized capex base for scarcity rent calculation\n        const capexAnnualBasePerPflopYear = groundHardwareCapexPerPflopYear + siteCapexAmortPerPflopYear + buildoutPremiumPerPflopYear; // Include buildout premium as true engineering capex\n        // Calculate scarcity multiplier using LOG-BASED function (never fully saturates)\n        // Returns multiplier (1.0 = no scarcity, 2.0 = 2x price) - MULTIPLICATIVE, not additive\n        const utilizationPct = capacityGW > 0 ? Math.min(1.0, demandNewGW / capacityGW) : 1.0;\n        var _params_scarcityRentWaitThresholdYears, _params_scarcityRentMaxMultiplier;\n        const scarcityRentResult = (0,_ground_constraint_penalties__WEBPACK_IMPORTED_MODULE_5__.calculateScarcityRent)(avgWaitYears, utilizationPct, {\n            waitThresholdYears: (_params_scarcityRentWaitThresholdYears = params.scarcityRentWaitThresholdYears) !== null && _params_scarcityRentWaitThresholdYears !== void 0 ? _params_scarcityRentWaitThresholdYears : 1.0,\n            rentMaxMultiplier: (_params_scarcityRentMaxMultiplier = params.scarcityRentMaxMultiplier) !== null && _params_scarcityRentMaxMultiplier !== void 0 ? _params_scarcityRentMaxMultiplier : 2.0,\n            utilizationThreshold: 0.85\n        });\n        const scarcityMultiplier = scarcityRentResult.scarcityMultiplier;\n        // For backward compatibility: scarcityRentPerPflopYear = 0 (scarcity is now multiplicative)\n        const scarcityRentPerPflopYear = 0;\n        // Define three totals:\n        // 1. base: energy + siteCapexAmort + buildoutPremium + hardware (no scarcity pricing)\n        // 2. effective: includes delayPenalty + scarcityRent (used for crossover)\n        // 3. headline: same as base (for backward compatibility)\n        const siteCostPerPflopYear_base = siteCapexAmortPerPflopYear + buildoutPremiumPerPflopYear;\n        const siteCostPerPflopYear_effective = siteCapexAmortPerPflopYear + buildoutPremiumPerPflopYear + delayPenaltyPerPflopYear + scarcityRentPerPflopYear;\n        // Validation: ensure no double counting\n        if (params.useQueueBasedConstraint !== false) {\n            console.warn(\"[BUILDOUT] useQueueBasedConstraint should be false when useBuildoutModel is true to avoid double counting\");\n        }\n        // Double counting guardrails: ensure constraintMultiplier is 1.0 when useBuildoutModel is true\n        if (true) {\n            if ((groundResult === null || groundResult === void 0 ? void 0 : groundResult.constraintMultiplier) !== undefined && groundResult.constraintMultiplier !== 1.0) {\n                throw new Error(\"[DOUBLE COUNTING] useBuildoutModel=true but constraintMultiplier=\".concat(groundResult.constraintMultiplier, \" != 1.0 (year=\").concat(year, \")\"));\n            }\n        }\n        const hardwareCost = groundHardwareCapexPerPflopYear;\n        // Add replacement/ops costs to hardware cost\n        const hardwareCostWithReplacement = hardwareCost + replacementCostPerPflopYear + sparesCarryCostPerPflopYear + groundOpsCostPerPflopYear;\n        // Compute totals (include replacement/ops in all)\n        const groundTotalCost_base = (energyCost + siteCostPerPflopYear_base + hardwareCostWithReplacement) * groundLatencyPenalty;\n        const groundTotalCost_effective = (energyCost + siteCostPerPflopYear_effective + hardwareCostWithReplacement) * groundLatencyPenalty; // Includes delayPenalty + scarcityRent\n        // UNIFIED SCARCITY ACCOUNTING: Keep totalCostPerPflopYear physical-only\n        // Scarcity (delayPenalty + scarcityRent) is treated purely in GPU-hour pricing, not in PFLOP-year cost\n        groundTotalCost = groundTotalCost_base; // Physical costs only (scarcity in GPU-hour)\n        var _groundResult_buildoutDebug_backlogGW;\n        // Detect if ground has queue/backlog (constraints are active) - for diagnostics only\n        groundHasQueue = avgWaitYears > 0.05 || backlogGW > 0.05 || ((_groundResult_buildoutDebug_backlogGW = groundResult === null || groundResult === void 0 ? void 0 : (_groundResult_buildoutDebug4 = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug4 === void 0 ? void 0 : _groundResult_buildoutDebug4.backlogGW) !== null && _groundResult_buildoutDebug_backlogGW !== void 0 ? _groundResult_buildoutDebug_backlogGW : 0) > 0.05;\n        // For crossover: use base cost (scarcity is already reflected in GPU-hour pricing)\n        // This ensures we don't double-count scarcity\n        groundComparatorCostPerPflopYear = groundTotalCost; // Base cost only (scarcity in GPU-hour)\n        energyConstraintMultiplier = 1.0; // Energy NOT affected by buildout constraints\n        // Constraint breakdown: all 1.0 (no multipliers, use buildout terms instead)\n        constraintBreakdown = {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        };\n        groundResult = {\n            energyCost: energyCost * groundLatencyPenalty,\n            siteCost: siteCostPerPflopYear_base * groundLatencyPenalty,\n            hardwareCost: hardwareCostWithReplacement * groundLatencyPenalty,\n            // Replacement/ops breakdown\n            replacementCost: replacementCostPerPflopYear * groundLatencyPenalty,\n            sparesCarryCost: sparesCarryCostPerPflopYear * groundLatencyPenalty,\n            opsCost: groundOpsCostPerPflopYear * groundLatencyPenalty,\n            siteCapexAmortPerPflopYear: siteCapexAmortPerPflopYear * groundLatencyPenalty,\n            capacityDeliveryPremium: buildoutPremiumPerPflopYear * groundLatencyPenalty,\n            timeToEnergizePenalty: delayPenaltyPerPflopYear * groundLatencyPenalty,\n            totalCostPerPflopYear: groundTotalCost,\n            totalCostPerPflopYearBase: groundTotalCost_base,\n            totalCostPerPflopYearEffective: groundTotalCost,\n            totalCostPerPflopYearAllIn: groundTotalCost,\n            // Debug: show pricing components\n            pricingComponents: {\n                delayPenaltyWeighted: delayPenaltyWeighted * groundLatencyPenalty,\n                scarcityRentPerPflopYear: scarcityRentPerPflopYear * groundLatencyPenalty,\n                pricingMode,\n                delayPenaltyWeight,\n                rentFrac: scarcityRentResult.rentFrac,\n                waitEffYears: scarcityRentResult.waitEffYears,\n                // Debug fields for scarcity rent calculation\n                scarcityHill: scarcityRentResult.scarcityHill,\n                avgWaitYearsRaw: scarcityRentResult.avgWaitYearsRaw,\n                avgWaitYearsClamped: scarcityRentResult.avgWaitYearsClamped\n            },\n            constraintMultiplier: 1.0,\n            breakdown: constraintBreakdown,\n            supplyMetrics: {\n                demandGw: mobilizationResult.demandGW,\n                capacityGw: capacityGW,\n                pipelineGw: pipelineGW,\n                maxBuildRateGwYear: buildRateGWyr,\n                avgWaitYears: avgWaitYears,\n                utilizationPct: capacityGW > 0 ? mobilizationResult.demandGW / capacityGW : 0\n            },\n            // Buildout debug fields (from ramping mobilization model)\n            backlogGw: backlogGW,\n            avgWaitYears: avgWaitYears,\n            buildoutDebug: {\n                demandNewGW: demandNewGW,\n                buildableGW: buildableGW,\n                buildRateGWyr: buildRateGWyr,\n                capacityGW: capacityGW,\n                pipelineGW: pipelineGW,\n                scarcityIndex: buildoutResult.factors.scarcityIndex,\n                buildoutCapex_$PerkW: buildoutResult.factors.buildoutCapex_$PerkW,\n                annualizedBuildoutPremium_$PerkWyr: buildoutResult.factors.annualizedBuildoutPremium_$PerkWyr,\n                timeToPowerYears: avgWaitYears,\n                valueOfTime_$PerYear: buildoutResult.factors.valueOfTime_$PerYear,\n                delayPenalty_$PerYear: buildoutResult.factors.delayPenalty_$PerYear,\n                buildoutPremiumPerPflopYear: buildoutPremiumPerPflopYear,\n                delayPenaltyPerPflopYear: delayPenaltyPerPflopYear,\n                // Additional mobilization debug fields\n                demandGW: mobilizationResult.demandGW,\n                demandGrowthRate: mobilizationResult.demandGrowthRate,\n                backlogGW: mobilizationResult.backlogGW,\n                avgWaitYears: mobilizationResult.avgWaitYears\n            },\n            smrEnabled: false,\n            smrRampFactor: 0,\n            effectiveElectricityCost: groundElectricityPricePerMwh,\n            constraintRelief: {\n                grid: 0,\n                cooling: 0,\n                water: 0,\n                land: 0\n            },\n            constraints: {\n                method: \"adders\",\n                capacityDeliveryPremium: buildoutPremiumPerPflopYear * groundLatencyPenalty,\n                delayPenalty: delayPenaltyPerPflopYear * groundLatencyPenalty,\n                scarcityRentPerPflopYear: scarcityRentPerPflopYear * groundLatencyPenalty,\n                scarcityMultiplier: scarcityMultiplier,\n                appliedMultipliers: {\n                    constraintMultiplierUsed: false,\n                    energyMultiplierUsed: false,\n                    siteMultiplierUsed: false\n                },\n                waccBase: baseWacc,\n                waccEffective: waccEffective,\n                rentFrac: scarcityRentResult.rentFrac,\n                waitYearsUsed: scarcityRentResult.waitEffYears,\n                waitEffYears: scarcityRentResult.waitEffYears,\n                // Debug fields for scarcity rent calculation\n                scarcityHill: scarcityRentResult.scarcityHill,\n                avgWaitYearsRaw: scarcityRentResult.avgWaitYearsRaw,\n                avgWaitYearsClamped: scarcityRentResult.avgWaitYearsClamped,\n                debug: {\n                    doubleCountCheck: {\n                        mode: \"adders\",\n                        multiplierApplied: false,\n                        addersApplied: true,\n                        invariantOk: true,\n                        notes: \"Buildout model uses adders only (capacityDeliveryPremium + delayPenalty + scarcityRent)\"\n                    }\n                }\n            }\n        };\n        // Invariant: If using adders, multipliers must not be applied\n        if (true) {\n            const hasMultiplier = groundResult.constraintMultiplier !== 1.0;\n            const hasAdder = groundResult.capacityDeliveryPremium > 0 || groundResult.timeToEnergizePenalty > 0;\n            if (hasMultiplier && hasAdder) {\n                throw new Error(\"[DOUBLE COUNTING DETECTED] Year \".concat(year, \": constraintMultiplier=\").concat(groundResult.constraintMultiplier, \" != 1.0 \") + \"AND adders > 0 (capacityDeliveryPremium=\".concat(groundResult.capacityDeliveryPremium, \", \") + \"delayPenalty=\".concat(groundResult.timeToEnergizePenalty, \"). Both cannot be applied simultaneously.\"));\n            }\n        }\n    } else if (useRegionalModel) {\n        var _regionalResult_supplyMetrics, _regionalResult_supplyMetrics1;\n        const demandPflops = (0,_ground_supply_model__WEBPACK_IMPORTED_MODULE_3__.getGlobalDemandPflops)(year, groundEffectiveGflopsPerW);\n        const regionalResult = (0,_ground_supply_model__WEBPACK_IMPORTED_MODULE_3__.calculateRegionalGroundCost)(year, demandPflops, groundEffectiveGflopsPerW, effectivePueGround, capacityFactorGround, groundHardwareCapexPerPflopYear, undefined // Use default regions\n        );\n        // REFACTORED: Regional model - energy cost should NOT have constraint multiplier\n        // Regional model already separates energy (raw) from site (with constraint)\n        const energyCost = regionalResult.energyCostPerPflopYear; // Raw electricity (NO constraint multiplier)\n        const siteCost = regionalResult.siteCostPerPflopYear; // Site costs WITH constraint multiplier\n        // GROUND COST ACCOUNTING: Explicit separation for regional model\n        const siteCostBase = BASE_SITE_2025;\n        // 1. siteCapexAmortPerPflopYear: Base site capex (NOT affected by constraint)\n        const siteCapexAmortPerPflopYear = siteCostBase;\n        // 2. capacityDeliveryPremiumPerPflopYear: Premium above base (from constraint multiplier)\n        const capacityDeliveryPremiumPerPflopYear = Math.max(0, siteCost - siteCostBase);\n        // 3. timeToEnergizePenaltyPerPflopYear: Regional model doesn't model queue delay separately (0 for now)\n        const timeToEnergizePenaltyPerPflopYear = 0;\n        // INVARIANT: siteCostPerPflopYear = siteCapexAmort + timeToEnergizePenalty + capacityDeliveryPremium\n        const siteCostPerPflopYear = siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + capacityDeliveryPremiumPerPflopYear;\n        // Validation (allow small tolerance for regional model approximation)\n        const siteCostCheck = Math.abs(siteCost - siteCostPerPflopYear);\n        if (siteCostCheck > 1.0) {\n            throw new Error(\"Site cost accounting error (regional model): siteCost=\".concat(siteCost, \" != sum(components)=\").concat(siteCostPerPflopYear, \", diff=\").concat(siteCostCheck));\n        }\n        // CRITICAL FIX: Regional model already separates energy (no multiplier) from site (with premium)\n        // Do NOT apply constraintMultiplier - it's already reflected in siteCostPerPflopYear\n        const constraintMultiplier = 1.0; // Not applied - kept for backward compat only\n        groundTotalCost = regionalResult.totalCostPerPflopYear;\n        groundHasQueue = false; // Regional model doesn't model queue delay separately\n        groundComparatorCostPerPflopYear = groundTotalCost; // Use base cost for regional model\n        energyConstraintMultiplier = 1.0; // Never applied\n        constraintBreakdown = {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        };\n        var _regionalResult_supplyMetrics_pipelineGw, _regionalResult_supplyMetrics_avgWaitYears, _regionalResult_supplyMetrics2;\n        groundResult = {\n            energyCost: energyCost,\n            siteCost: siteCostPerPflopYear,\n            siteCapexAmortPerPflopYear: siteCapexAmortPerPflopYear,\n            capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear,\n            timeToEnergizePenalty: timeToEnergizePenaltyPerPflopYear,\n            hardwareCost: regionalResult.hardwareCapexPerPflopYear,\n            totalCostPerPflopYear: groundTotalCost,\n            constraintMultiplier: 1.0,\n            constraints: {\n                method: \"adders\",\n                capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear,\n                delayPenalty: 0,\n                appliedMultipliers: {\n                    constraintMultiplierUsed: false,\n                    energyMultiplierUsed: false,\n                    siteMultiplierUsed: false\n                },\n                debug: {\n                    doubleCountCheck: {\n                        mode: \"adders\",\n                        multiplierApplied: false,\n                        addersApplied: capacityDeliveryPremiumPerPflopYear > 0,\n                        invariantOk: true,\n                        notes: \"Regional model uses adders only (capacityDeliveryPremium from siteCost - siteCostBase)\"\n                    }\n                }\n            },\n            breakdown: constraintBreakdown,\n            smrEnabled: false,\n            smrRampFactor: 0,\n            effectiveElectricityCost: regionalResult.averageEnergyCostMwh,\n            constraintRelief: {\n                grid: 0,\n                cooling: 0,\n                water: 0,\n                land: 0\n            },\n            // Ensure backlogGw and avgWaitYears are always set (use supplyMetrics as fallback)\n            backlogGw: (_regionalResult_supplyMetrics_pipelineGw = (_regionalResult_supplyMetrics = regionalResult.supplyMetrics) === null || _regionalResult_supplyMetrics === void 0 ? void 0 : _regionalResult_supplyMetrics.pipelineGw) !== null && _regionalResult_supplyMetrics_pipelineGw !== void 0 ? _regionalResult_supplyMetrics_pipelineGw : 0,\n            avgWaitYears: (_regionalResult_supplyMetrics_avgWaitYears = (_regionalResult_supplyMetrics1 = regionalResult.supplyMetrics) === null || _regionalResult_supplyMetrics1 === void 0 ? void 0 : _regionalResult_supplyMetrics1.avgWaitYears) !== null && _regionalResult_supplyMetrics_avgWaitYears !== void 0 ? _regionalResult_supplyMetrics_avgWaitYears : 0,\n            supplyMetrics: (_regionalResult_supplyMetrics2 = regionalResult.supplyMetrics) !== null && _regionalResult_supplyMetrics2 !== void 0 ? _regionalResult_supplyMetrics2 : {\n                demandGw: 0,\n                capacityGw: 0,\n                pipelineGw: 0,\n                maxBuildRateGwYear: 0,\n                avgWaitYears: 0,\n                utilizationPct: 0\n            }\n        };\n    } else {\n        groundResult = calculateGroundTotal(year, params, ENERGY_COST_BASE_2025, groundHardwareCapexPerPflopYear, params.isStaticMode, effectiveGroundScenario, groundLatencyPenalty, smrParams, firstCapYear !== null && firstCapYear !== void 0 ? firstCapYear : null, groundEnergyCostPerPflopYear, groundElectricityPricePerMwh);\n        // CRITICAL FIX: Ensure backlogGw and avgWaitYears are always set (even if calculateGroundTotal doesn't provide them)\n        // Use supplyMetrics as fallback if available, otherwise 0\n        // Type assertion needed because calculateGroundTotal may not include these fields\n        const groundResultWithBacklog = groundResult;\n        if (!(\"backlogGw\" in groundResultWithBacklog) || groundResultWithBacklog.backlogGw === undefined) {\n            var _groundResultWithBacklog_supplyMetrics;\n            var _groundResultWithBacklog_supplyMetrics_pipelineGw;\n            groundResultWithBacklog.backlogGw = (_groundResultWithBacklog_supplyMetrics_pipelineGw = (_groundResultWithBacklog_supplyMetrics = groundResultWithBacklog.supplyMetrics) === null || _groundResultWithBacklog_supplyMetrics === void 0 ? void 0 : _groundResultWithBacklog_supplyMetrics.pipelineGw) !== null && _groundResultWithBacklog_supplyMetrics_pipelineGw !== void 0 ? _groundResultWithBacklog_supplyMetrics_pipelineGw : 0; // TEMP proxy\n        }\n        if (!(\"avgWaitYears\" in groundResultWithBacklog) || groundResultWithBacklog.avgWaitYears === undefined) {\n            var _groundResultWithBacklog_supplyMetrics1;\n            var _groundResultWithBacklog_supplyMetrics_avgWaitYears;\n            groundResultWithBacklog.avgWaitYears = (_groundResultWithBacklog_supplyMetrics_avgWaitYears = (_groundResultWithBacklog_supplyMetrics1 = groundResultWithBacklog.supplyMetrics) === null || _groundResultWithBacklog_supplyMetrics1 === void 0 ? void 0 : _groundResultWithBacklog_supplyMetrics1.avgWaitYears) !== null && _groundResultWithBacklog_supplyMetrics_avgWaitYears !== void 0 ? _groundResultWithBacklog_supplyMetrics_avgWaitYears : 0;\n        }\n        // Ensure supplyMetrics exists\n        if (!groundResultWithBacklog.supplyMetrics) {\n            var _groundResultWithBacklog_backlogGw, _groundResultWithBacklog_avgWaitYears;\n            groundResultWithBacklog.supplyMetrics = {\n                demandGw: 0,\n                capacityGw: 0,\n                pipelineGw: (_groundResultWithBacklog_backlogGw = groundResultWithBacklog.backlogGw) !== null && _groundResultWithBacklog_backlogGw !== void 0 ? _groundResultWithBacklog_backlogGw : 0,\n                maxBuildRateGwYear: 0,\n                avgWaitYears: (_groundResultWithBacklog_avgWaitYears = groundResultWithBacklog.avgWaitYears) !== null && _groundResultWithBacklog_avgWaitYears !== void 0 ? _groundResultWithBacklog_avgWaitYears : 0,\n                utilizationPct: 0\n            };\n        }\n        groundResult = groundResultWithBacklog;\n        groundTotalCost = groundResult.totalCostPerPflopYear;\n        var _groundResult_timeToEnergizePenalty;\n        groundHasQueue = ((_groundResult_timeToEnergizePenalty = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty !== void 0 ? _groundResult_timeToEnergizePenalty : 0) > 0.01; // Check if delay penalty exists\n        var _groundResult_totalCostPerPflopYearEffective;\n        groundComparatorCostPerPflopYear = groundHasQueue ? (_groundResult_totalCostPerPflopYearEffective = groundResult.totalCostPerPflopYearEffective) !== null && _groundResult_totalCostPerPflopYearEffective !== void 0 ? _groundResult_totalCostPerPflopYearEffective : groundResult.totalCostPerPflopYear : groundTotalCost;\n        // CRITICAL FIX: Never apply multipliers - all set to 1.0\n        energyConstraintMultiplier = 1.0; // Never applied\n        // Invariant: If using adders, multipliers must not be applied\n        if ( true && groundResult.constraints) {\n            const hasMultiplier = groundResult.constraintMultiplier !== 1.0;\n            const hasAdder = groundResult.constraints.capacityDeliveryPremium > 0 || groundResult.constraints.delayPenalty > 0;\n            if (hasMultiplier && hasAdder) {\n                throw new Error(\"[DOUBLE COUNTING DETECTED] Year \".concat(year, \": constraintMultiplier=\").concat(groundResult.constraintMultiplier, \" != 1.0 \") + \"AND adders > 0 (capacityDeliveryPremium=\".concat(groundResult.constraints.capacityDeliveryPremium, \", \") + \"delayPenalty=\".concat(groundResult.constraints.delayPenalty, \"). Both cannot be applied simultaneously.\"));\n            }\n        }\n        constraintBreakdown = {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        };\n        // Invariant: Check for double counting\n        if (true) {\n            const hasMultiplier = groundResult.constraintMultiplier !== 1.0 || groundResult.breakdown.energyMultiplier !== 1.0 || groundResult.breakdown.siteMultiplier !== 1.0;\n            const hasPremium = (groundResult.capacityDeliveryPremium || 0) > 0 || (groundResult.timeToEnergizePenalty || 0) > 0;\n            if (hasMultiplier && hasPremium) {\n                console.warn(\"[DOUBLE COUNTING DETECTED] Year \".concat(year, \": \") + \"Multipliers (constraint=\".concat(groundResult.constraintMultiplier, \", \") + \"energy=\".concat(groundResult.breakdown.energyMultiplier, \", \") + \"site=\".concat(groundResult.breakdown.siteMultiplier, \") AND \") + \"premiums (capacity=\".concat(groundResult.capacityDeliveryPremium, \", \") + \"delay=\".concat(groundResult.timeToEnergizePenalty, \") are both present. \") + \"This indicates double counting.\");\n            }\n        }\n    }\n    const launchCostPerKg = getLaunchCostPerKg(year, baseLaunchCost) * launchDiscount;\n    const lifetimeYears = 6;\n    // Fusion toggle params\n    const fusionParams = params.fusionToggleEnabled ? params.fusionToggleParams || {\n        ..._orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_FUSION_PARAMS,\n        enabled: true\n    } : undefined;\n    // CONSTELLATION SIZING: Design constellation to meet compute requirements\n    // Convert target compute (GW) to power (kW) for constellation sizing\n    const targetComputeKw = satellitePowerKW;\n    let constellation = (0,_constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.designConstellation)(targetComputeKw, _constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.SATELLITE_CONSTRAINTS, 100000, trajSpecificPower);\n    // Use per-satellite compute power for cost calculation\n    let computePowerPerSatKw = constellation.computePerSatKw;\n    let hybridResult = (0,_orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.computeSatelliteHybridCost)(year, launchCostPerKg, {\n        ..._orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_CONFIG,\n        computePowerKw: computePowerPerSatKw,\n        altitudeKm: orbitalAltitude,\n        lifetimeYears: lifetimeYears,\n        specificPowerWKg: trajSpecificPower,\n        useRadHardChips: useRadHardChips,\n        sunFraction: sunFraction,\n        workloadType: workloadType || \"inference\"\n    }, fusionParams, params.useCorrectedSpecificPower, params.useCorrectedThermal);\n    // CRITICAL FIX: Calculate delivered efficiency with ALL delivery derates\n    // delivered = systemEffective * thermalCapFactor * radiationDerate * availability\n    // Single source of truth for all three factors:\n    const thermalCapFactor = hybridResult.thermalSystem.thermalCapFactor;\n    const radiationDerate = hybridResult.degradationFactor || 1.0; // Hardware degradation from radiation (chip failures, ECC overhead)\n    const availability = hybridResult.capacityFactor || 1.0; // Capacity factor is uptime-inclusive (includes eclipse, degradation, radiation downtime, uptime)\n    // Calculate delivered efficiency (all derates applied multiplicatively)\n    // This is the true \"delivered\" efficiency that accounts for all operational constraints\n    let orbitDeliveredGflopsPerWatt = orbitSystemEffectiveGflopsPerWatt * thermalCapFactor * radiationDerate * availability;\n    // CRITICAL: If thermal constraint causes delivered efficiency to drop below minimum (20 GFLOPS/W),\n    // this indicates a severe thermal constraint that should be handled by expanding radiator or reducing compute\n    // For now, we clamp to minimum to prevent validation errors, but log a warning (only once per year)\n    if (orbitDeliveredGflopsPerWatt < CONSTANTS.MIN_DELIVERED_GFLOPS_PER_W) {\n        const originalDelivered = orbitDeliveredGflopsPerWatt;\n        orbitDeliveredGflopsPerWatt = CONSTANTS.MIN_DELIVERED_GFLOPS_PER_W;\n    // Log warning about severe thermal constraint (only in dev, and only once per year to reduce spam)\n    // The actual clamped value is available in orbit.computeEfficiency.validation metadata\n    // Thermal constraint warnings removed for cleaner console output\n    }\n    // Use delivered efficiency for all cost calculations\n    let orbitEffectiveGflopsPerW = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(orbitDeliveredGflopsPerWatt, \"orbital delivered efficiency calculation\");\n    // Power scaling calculation\n    const powerScalingParams = params.powerScalingParams || _orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_POWER_SCALING;\n    const scalingResult = (0,_orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.calculateScaledMass)(computePowerPerSatKw, powerScalingParams);\n    // CONSTELLATION SCALING: Apply constellation multiplier to mass and costs\n    // Per-satellite mass (already calculated for one satellite)\n    let massPerSatKg = hybridResult.totalMassKg * massMultiplier;\n    // CRITICAL FIX: Check if actual mass exceeds limit and re-split constellation if needed\n    // The simplified mass model in designConstellation may underestimate actual mass\n    // If actual mass exceeds limit, we need to split into smaller satellites\n    const MAX_SATELLITE_MASS_KG = _constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.SATELLITE_CONSTRAINTS.maxMassKg; // 10,000 kg from constraints\n    if (massPerSatKg > MAX_SATELLITE_MASS_KG) {\n        // Calculate required compute per satellite to stay under mass limit\n        // Mass scales roughly with compute power, so: massPerSatKg / computePowerPerSatKw = massPerKw\n        const massPerKw = massPerSatKg / computePowerPerSatKw;\n        const maxComputePerSatKw = MAX_SATELLITE_MASS_KG / massPerKw;\n        // Recalculate constellation with smaller satellites\n        const adjustedConstellation = (0,_constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.designConstellation)(targetComputeKw, {\n            ..._constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.SATELLITE_CONSTRAINTS,\n            maxComputeKw: maxComputePerSatKw * 0.9\n        }, 100000, trajSpecificPower);\n        // Recalculate hybrid cost with adjusted compute per satellite\n        const adjustedHybridResult = (0,_orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.computeSatelliteHybridCost)(year, launchCostPerKg, {\n            ..._orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_CONFIG,\n            computePowerKw: adjustedConstellation.computePerSatKw,\n            altitudeKm: orbitalAltitude,\n            lifetimeYears: lifetimeYears,\n            specificPowerWKg: trajSpecificPower,\n            useRadHardChips: useRadHardChips,\n            sunFraction: sunFraction,\n            workloadType: workloadType || \"inference\"\n        }, fusionParams, params.useCorrectedSpecificPower, params.useCorrectedThermal);\n        // Update with adjusted values\n        const adjustedMassPerSatKg = adjustedHybridResult.totalMassKg * massMultiplier;\n        if (adjustedMassPerSatKg > MAX_SATELLITE_MASS_KG) {\n            // Still too heavy - this shouldn't happen, but log a warning\n            console.warn(\"Satellite mass \".concat(adjustedMassPerSatKg.toFixed(0), \"kg still exceeds limit \").concat(MAX_SATELLITE_MASS_KG, \"kg \") + \"even after splitting to \".concat(adjustedConstellation.computePerSatKw.toFixed(1), \"kW per satellite. \") + \"Consider further reducing compute per satellite or improving specific power.\");\n        }\n        // Use adjusted constellation and hybrid result\n        constellation = adjustedConstellation;\n        hybridResult = adjustedHybridResult;\n        computePowerPerSatKw = adjustedConstellation.computePerSatKw;\n        massPerSatKg = adjustedMassPerSatKg;\n        // Recalculate delivered efficiency with adjusted thermal cap (all derates applied)\n        const adjustedThermalCapFactor = hybridResult.thermalSystem.thermalCapFactor;\n        const adjustedRadiationDerate = hybridResult.degradationFactor || 1.0;\n        const adjustedAvailability = hybridResult.capacityFactor || 1.0;\n        let adjustedDeliveredGflopsPerWatt = orbitSystemEffectiveGflopsPerWatt * adjustedThermalCapFactor * adjustedRadiationDerate * adjustedAvailability;\n        // Clamp to minimum if thermal constraint is too severe\n        if (adjustedDeliveredGflopsPerWatt < CONSTANTS.MIN_DELIVERED_GFLOPS_PER_W) {\n            adjustedDeliveredGflopsPerWatt = CONSTANTS.MIN_DELIVERED_GFLOPS_PER_W;\n        }\n        orbitEffectiveGflopsPerW = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(adjustedDeliveredGflopsPerWatt, \"orbital delivered efficiency (after constellation split)\");\n    }\n    // Scale costs by number of satellites and apply constellation overhead\n    // Calculate AFTER mass check so we use the adjusted constellation if it was split\n    const constellationMultiplier = constellation.numSatellites;\n    const constellationOverheadMultiplier = constellation.constellationOverhead;\n    // Total constellation mass\n    const effectiveTotalMassKg = massPerSatKg * constellation.numSatellites;\n    const effectiveTotalLaunchCost = effectiveTotalMassKg * launchCostPerKg;\n    // Apply Elon Scenario: Discounts\n    const effectivePowerFabCost = hybridResult.powerSystem.fabCostUsd * powerDiscount;\n    const effectiveNetworkingFabCost = hybridResult.networking.fabCostUsd * networkingDiscount;\n    const effectiveNetworkingOpEx = (hybridResult.networking.annualOpExUsd || 0) * networkingDiscount;\n    // Effective PFLOPs: per-satellite PFLOPs  number of satellites\n    const effectivePflopsPerSat = hybridResult.effectivePflops;\n    const totalEffectivePflops = effectivePflopsPerSat * constellation.numSatellites;\n    // Launch cost: total constellation launch cost / total PFLOPs\n    const launchCostPerPflopYear = effectiveTotalLaunchCost / totalEffectivePflops / lifetimeYears;\n    // CRITICAL FIX 1: Cost Accounting - ensure breakdown sums to total\n    // Calculate each component explicitly, scaled by constellation\n    // Per-satellite costs  number of satellites  constellation overhead\n    const constellationCostMultiplier = constellation.numSatellites * constellationOverheadMultiplier;\n    const powerCost = effectivePowerFabCost * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const computeCost = (hybridResult.computePayload.chipCostUsd + hybridResult.computePayload.qualificationCostUsd) * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const thermalCost = hybridResult.thermalSystem.fabCostUsd * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const radiationCost = hybridResult.radiationProtection.fabCostUsd * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const busCost = hybridResult.bus.fabCostUsd * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const networkingCost = effectiveNetworkingFabCost * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const interconnectCost = hybridResult.interconnect.totalAnnualCost * constellationCostMultiplier / totalEffectivePflops;\n    const regulatoryCost = (((_hybridResult_regulatory = hybridResult.regulatory) === null || _hybridResult_regulatory === void 0 ? void 0 : _hybridResult_regulatory.annualCostUsd) || 0) * constellationCostMultiplier / totalEffectivePflops;\n    // Ops cost scales with constellation overhead (more satellites = more ops complexity)\n    const baseOpsCostPerSat = hybridResult.opsPerPflopYear * effectivePflopsPerSat; // Total ops cost per satellite\n    const networkingOpsCostPerSat = (hybridResult.networking.annualOpExUsd || 0) - effectiveNetworkingOpEx; // Already per-sat\n    const adjustedNetworkingOpsCostPerSat = effectiveNetworkingOpEx; // Already per-sat\n    const opsCostPerSat = baseOpsCostPerSat - networkingOpsCostPerSat + adjustedNetworkingOpsCostPerSat;\n    // Scale ops cost by constellation (with overhead for coordination)\n    const opsCostMultiplier = constellation.numSatellites * (1 + 0.1 * Math.log10(constellation.numSatellites));\n    const opsCost = opsCostPerSat * opsCostMultiplier / totalEffectivePflops;\n    const orbitalBreakdown = {\n        power: powerCost,\n        compute: computeCost,\n        thermal: thermalCost,\n        radiation: radiationCost,\n        bus: busCost,\n        ops: opsCost,\n        congestion: 0,\n        networking: networkingCost,\n        interconnect: interconnectCost,\n        regulatory: regulatoryCost,\n        launch: launchCostPerPflopYear\n    };\n    const totalSatelliteCost = hybridResult.totalSatelliteCost * constellationCostMultiplier;\n    const satelliteCount = constellation.numSatellites; // Use actual constellation size\n    const congestion = (0,_congestion__WEBPACK_IMPORTED_MODULE_0__.calculateCongestion)(satelliteCount, totalSatelliteCost, year, 10000 + satelliteCount, spaceTrafficEnabled);\n    // Total fleet PFLOPS: use constellation total PFLOPs\n    // Already calculated as totalEffectivePflops above\n    orbitalBreakdown.congestion = spaceTrafficEnabled ? congestion.congestionCostPerPflopYear / totalEffectivePflops : 0;\n    // PATCH G: Cost Accounting Invariants\n    // Use assertCostAccounting to ensure breakdown sums to total exactly\n    const orbitalComponents = [\n        {\n            name: \"power\",\n            value: orbitalBreakdown.power\n        },\n        {\n            name: \"compute\",\n            value: orbitalBreakdown.compute\n        },\n        {\n            name: \"thermal\",\n            value: orbitalBreakdown.thermal\n        },\n        {\n            name: \"radiation\",\n            value: orbitalBreakdown.radiation\n        },\n        {\n            name: \"bus\",\n            value: orbitalBreakdown.bus\n        },\n        {\n            name: \"ops\",\n            value: orbitalBreakdown.ops\n        },\n        {\n            name: \"networking\",\n            value: orbitalBreakdown.networking\n        },\n        {\n            name: \"interconnect\",\n            value: orbitalBreakdown.interconnect\n        },\n        {\n            name: \"regulatory\",\n            value: orbitalBreakdown.regulatory\n        },\n        {\n            name: \"launch\",\n            value: orbitalBreakdown.launch\n        },\n        {\n            name: \"congestion\",\n            value: orbitalBreakdown.congestion\n        }\n    ];\n    const breakdownSum = Object.values(orbitalBreakdown).reduce((a, b)=>a + b, 0);\n    const realisticCostPerPflop = breakdownSum;\n    // Track applied multipliers for debugging\n    const appliedMultipliers = [\n        {\n            name: \"launchDiscount\",\n            value: launchDiscount,\n            appliedTo: \"launch cost\"\n        },\n        {\n            name: \"powerDiscount\",\n            value: powerDiscount,\n            appliedTo: \"power fab cost\"\n        },\n        {\n            name: \"networkingDiscount\",\n            value: networkingDiscount,\n            appliedTo: \"networking cost\"\n        },\n        {\n            name: \"massMultiplier\",\n            value: massMultiplier,\n            appliedTo: \"total mass\"\n        }\n    ];\n    // Assert cost accounting (throws if invalid)\n    const orbitalAccounting = (0,_cost_accounting__WEBPACK_IMPORTED_MODULE_9__.assertCostAccounting)(realisticCostPerPflop, orbitalComponents, appliedMultipliers);\n    const costAccountingValid = orbitalAccounting.valid;\n    const costAccountingErrorPct = orbitalAccounting.errorPct;\n    // FIX 5: GPU-hour breakdown must derive from annual cost breakdown\n    // GPU-hour pricing: Apply scarcity as MULTIPLICATIVE multiplier (not additive)\n    // delayPenalty remains additive (WACC carry cost), but scarcity rent is now multiplicative\n    const delayPenaltyPerPflopYear = ((_groundResult_constraints = groundResult.constraints) === null || _groundResult_constraints === void 0 ? void 0 : _groundResult_constraints.delayPenalty) || 0;\n    var _groundResult_constraints_scarcityMultiplier;\n    const scarcityMultiplier = (_groundResult_constraints_scarcityMultiplier = (_groundResult_constraints1 = groundResult.constraints) === null || _groundResult_constraints1 === void 0 ? void 0 : _groundResult_constraints1.scarcityMultiplier) !== null && _groundResult_constraints_scarcityMultiplier !== void 0 ? _groundResult_constraints_scarcityMultiplier : 1.0; // Multiplier from log-based function\n    // Convert delayPenalty to $/GPU-hour (still additive)\n    const pflopsPerGpu = 2.0;\n    const utilizationTarget = 0.85;\n    const hoursPerYear = 8760;\n    const annualGpuHoursPerPFLOP = hoursPerYear * utilizationTarget / pflopsPerGpu;\n    const delayPenaltyAdderPerGpuHour = delayPenaltyPerPflopYear / annualGpuHoursPerPFLOP;\n    // Note: Scarcity is now MULTIPLICATIVE (not additive), so no conversion check needed\n    // Scarcity multiplier is applied directly to base cost in GPU-hour pricing\n    // Use BASE cost (without scarcity) for GPU-hour pricing, then apply scarcity as multiplier\n    // This prevents double-counting: scarcity is multiplicative in GPU-hour pricing, not additive\n    // We want: baseCost (no scarcity) * scarcityMultiplier = total with scarcity\n    // Use groundResult.totalCostPerPflopYearBase if available (from buildout model), otherwise construct from components\n    const groundCostBaseForPricing = useBuildoutModel && (groundResult === null || groundResult === void 0 ? void 0 : groundResult.totalCostPerPflopYearBase) !== undefined ? groundResult.totalCostPerPflopYearBase : (groundResult.energyCost + groundResult.siteCost + groundResult.hardwareCost) * groundLatencyPenalty;\n    const groundGpuHour = (sla)=>{\n        const basePricing = calculateGpuHourPricing(groundCostBaseForPricing, {\n            pflopsPerGpu,\n            utilizationTarget,\n            operatorMarginPct: operatorMargin,\n            sla,\n            location: \"ground\"\n        }, {\n            compute: groundResult.hardwareCost,\n            power: groundResult.energyCost,\n            site: useBuildoutModel ? groundResult.siteCapexAmortPerPflopYear : groundResult.siteCost\n        });\n        // UNIFIED SCARCITY ACCOUNTING: Scarcity is MULTIPLICATIVE (not additive)\n        // CRITICAL FIX: Apply scarcity as premium on FIXED reference base, not declining base\n        // This prevents Moore's Law from eroding scarcity dollar amounts\n        // Extract base cost before margin (this declines with Moore's Law)\n        const preMarginBase = basePricing.pricePerGpuHour - (basePricing.costBreakdown.margin || 0);\n        // Scarcity premium based on FIXED reference, not declining base\n        // This ensures scarcity doesn't get eroded by Moore's Law\n        const SCARCITY_REFERENCE_BASE = 3.50; // Fixed 2025 market reference ($/GPU-hr)\n        const scarcityPremium = (scarcityMultiplier - 1) * SCARCITY_REFERENCE_BASE;\n        // Total cost = base (declining with Moore's Law) + scarcity (fixed) + delay\n        const costWithScarcity = preMarginBase + scarcityPremium;\n        const costWithScarcityAndDelay = costWithScarcity + delayPenaltyAdderPerGpuHour;\n        // Then add margin\n        const margin = costWithScarcityAndDelay * operatorMargin;\n        const pricePerGpuHour = costWithScarcityAndDelay + margin;\n        return {\n            ...basePricing,\n            pricePerGpuHour,\n            costBreakdown: {\n                ...basePricing.costBreakdown,\n                scarcity: scarcityPremium,\n                delayPenalty: delayPenaltyAdderPerGpuHour,\n                margin\n            }\n        };\n    };\n    const orbitalGpuHour = (sla)=>calculateGpuHourPricing(realisticCostPerPflop, {\n            pflopsPerGpu: 2.0,\n            utilizationTarget: 0.85,\n            operatorMarginPct: operatorMargin,\n            sla,\n            location: \"orbital\"\n        }, orbitalBreakdown); // Use full orbital breakdown\n    const groundTokens = {\n        llama70B: calculateTokenPricing(groundTotalCost, {\n            params: 70e9,\n            precision: \"fp16\"\n        }),\n        llama405B: calculateTokenPricing(groundTotalCost, {\n            params: 405e9,\n            precision: \"fp16\"\n        })\n    };\n    const orbitalTokens = {\n        llama70B: calculateTokenPricing(realisticCostPerPflop, {\n            params: 70e9,\n            precision: \"fp16\"\n        }),\n        llama405B: calculateTokenPricing(realisticCostPerPflop, {\n            params: 405e9,\n            precision: \"fp16\"\n        })\n    };\n    const edgeInference = ((_params_edgeInference = params.edgeInference) === null || _params_edgeInference === void 0 ? void 0 : _params_edgeInference.enabled) ? (0,_edgeInference__WEBPACK_IMPORTED_MODULE_1__.computeEdgeInferenceCosts)(year, params.edgeInference, launchCostPerKg, totalEffectivePflops / effectiveTotalMassKg) : undefined;\n    const gpuHourCrossover = orbitalGpuHour(SLA_TIERS.standard).pricePerGpuHour < groundGpuHour(SLA_TIERS.standard).pricePerGpuHour;\n    // ============================================================================\n    // DEBUG INVARIANTS (development mode only)\n    // ============================================================================\n    if (true) {\n        var _groundResult_supplyMetrics4, _groundResult_constraints2, _groundResult_constraints3;\n        var _groundResult_supplyMetrics_avgWaitYears;\n        // Invariant 1: If avgWaitYears > 0 then scarcity multiplier should be > 1.0 (scarcity is multiplicative in GPU-hour pricing)\n        const avgWaitYears = (_groundResult_supplyMetrics_avgWaitYears = (_groundResult_supplyMetrics4 = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics4 === void 0 ? void 0 : _groundResult_supplyMetrics4.avgWaitYears) !== null && _groundResult_supplyMetrics_avgWaitYears !== void 0 ? _groundResult_supplyMetrics_avgWaitYears : 0;\n        var _groundResult_constraints_scarcityMultiplier1;\n        const scarcityMultiplier = (_groundResult_constraints_scarcityMultiplier1 = (_groundResult_constraints2 = groundResult.constraints) === null || _groundResult_constraints2 === void 0 ? void 0 : _groundResult_constraints2.scarcityMultiplier) !== null && _groundResult_constraints_scarcityMultiplier1 !== void 0 ? _groundResult_constraints_scarcityMultiplier1 : 1.0;\n        if (avgWaitYears > 1.0 && scarcityMultiplier <= 1.0) {\n            console.warn(\"[INVARIANT VIOLATION] Year \".concat(year, \": avgWaitYears=\").concat(avgWaitYears, \" > 1.0 but scarcityMultiplier=\").concat(scarcityMultiplier, \" <= 1.0. \") + \"Scarcity multiplier should be > 1.0 when wait time exists (scarcity is multiplicative in GPU-hour pricing).\");\n        }\n        var _groundResult_totalCostPerPflopYearEffective1;\n        // Invariant 2: supplyMetrics.capacityGw is the effective capacity (bottleneck)\n        // Queue model uses coherent backlog based on unmet demand\n        // Invariant 3: GPU-hour chart yMax guard (prevented by explicit series extraction in chart component)\n        // This is handled in the chart component with explicit series extraction\n        // Invariant 4: Crossover uses effective ground cost\n        const groundEffective = (_groundResult_totalCostPerPflopYearEffective1 = groundResult.totalCostPerPflopYearEffective) !== null && _groundResult_totalCostPerPflopYearEffective1 !== void 0 ? _groundResult_totalCostPerPflopYearEffective1 : groundResult.totalCostPerPflopYear;\n        const groundHeadline = groundResult.totalCostPerPflopYear;\n        var _groundResult_constraints_delayPenalty;\n        const delayPenalty = (_groundResult_constraints_delayPenalty = (_groundResult_constraints3 = groundResult.constraints) === null || _groundResult_constraints3 === void 0 ? void 0 : _groundResult_constraints3.delayPenalty) !== null && _groundResult_constraints_delayPenalty !== void 0 ? _groundResult_constraints_delayPenalty : 0;\n        // Scarcity is now multiplicative (not additive), so don't add it to effective cost\n        const expectedEffective = groundHeadline + delayPenalty; // Scarcity applied in GPU-hour pricing, not PFLOP-year\n        const effectiveError = Math.abs(groundEffective - expectedEffective);\n        // Reuse scarcityMultiplier from Invariant 1 above\n        if (effectiveError > 0.01 && (delayPenalty > 0 || scarcityMultiplier > 1.0)) {\n            console.warn(\"[INVARIANT VIOLATION] Year \".concat(year, \": groundEffective=\").concat(groundEffective, \" != expected=\").concat(expectedEffective, \" \") + \"(headline=\".concat(groundHeadline, \", delayPenalty=\").concat(delayPenalty, \", scarcityMultiplier=\").concat(scarcityMultiplier, \"). \") + \"Crossover should use effective cost. Note: scarcity is multiplicative in GPU-hour pricing, not additive in PFLOP-year.\");\n        }\n    }\n    // CRITICAL FIX: Validate delivered efficiency by comparing like-for-like only\n    // expectedDelivered = systemEffectiveGflopsPerWatt * thermalCapFactor * radiationDerate * availability\n    // ratio = deliveredGflopsPerWatt / expectedDelivered\n    // If ratio is finite and |1 - ratio| <= tolerance (0.02), then valid=true, warning=null\n    // Else valid=false, warning describes the mismatch\n    // Remove any other comparisons (e.g., delivered vs systemEffective, delivered vs peak*utilization without overhead, etc.)\n    const expectedDelivered = orbitSystemEffectiveGflopsPerWatt * thermalCapFactor * radiationDerate * availability;\n    const ratio = orbitDeliveredGflopsPerWatt / Math.max(expectedDelivered, 1e-6);\n    const TOLERANCE = 0.02; // 2% tolerance\n    const ratioError = Math.abs(1 - ratio);\n    // CRITICAL: Fix validator logic - if ratio is finite and |1 - ratio| <= tolerance, then valid=true\n    const isRatioValid = isFinite(ratio) && ratioError <= TOLERANCE;\n    // Escalate: if mismatch > 5%, mark as invalid (don't just warn)\n    const ESCALATE_THRESHOLD = 0.05; // 5%\n    const isInvalid = !isRatioValid && ratioError > ESCALATE_THRESHOLD;\n    // Debug invariants: assert delivered <= systemEffective + eps\n    const deliveredVsSystemError = orbitDeliveredGflopsPerWatt - orbitSystemEffectiveGflopsPerWatt;\n    if (deliveredVsSystemError > 1e-6) {\n        console.warn(\"[INVARIANT VIOLATION] Delivered efficiency (\".concat(orbitDeliveredGflopsPerWatt.toFixed(2), \") > systemEffective (\").concat(orbitSystemEffectiveGflopsPerWatt.toFixed(2), \"). \") + \"Delivered must be <= systemEffective.\");\n    }\n    // Efficiency debug logging removed for cleaner console output\n    // Validation results are available in orbit.computeEfficiency.validation metadata\n    // CRITICAL: Validate delivered efficiency - compare delivered vs expectedDelivered only\n    // Make validator debug explicit with all factors\n    // If mismatch > 5%, mark run invalid and stop chart rendering (escalate, don't silently warn)\n    const deliveredValidation = {\n        valid: isRatioValid,\n        warning: isRatioValid ? undefined // Empty/null when valid\n         : \"Power/Efficiency mismatch: \".concat(ratio.toFixed(2), \"x discrepancy (expected=\").concat(expectedDelivered.toFixed(2), \", delivered=\").concat(orbitDeliveredGflopsPerWatt.toFixed(2), \")\"),\n        expectedDelivered,\n        delivered: orbitDeliveredGflopsPerWatt,\n        ratio,\n        factorsUsed: {\n            thermalCapFactor,\n            radiationDerate,\n            availability,\n            utilization: orbitalEfficiencyResult.debug.utilizationFactor,\n            systemOverheadFactor: orbitalEfficiencyResult.debug.systemOverheadFactor\n        },\n        // Escalate: if ratio is way off (> 5%), mark as invalid\n        invalid: !isRatioValid && Math.abs(1 - ratio) > 0.05\n    };\n    const efficiencyValidation = validateComputeEfficiency(orbitEffectiveGflopsPerW, params.efficiencyLevel);\n    const consistencyCheck = assertComputePowerConsistency(orbitEffectiveGflopsPerW, targetComputeKw, totalEffectivePflops, MODEL_UNITS);\n    var _groundResult_capacityDeliveryPremium, _groundResult_timeToEnergizePenalty1, _groundResult_siteCapexAmortPerPflopYear, _groundResult_timeToEnergizePenalty2, _groundResult_capacityDeliveryPremium1, _hybridResult_specificPowerMultipliers_massMultiplier, _hybridResult_thermalSystem_wasteHeatW, _hybridResult_thermalSystem_qPerM2_W, _hybridResult_thermalSystem_areaAvailableM2;\n    // SANITY PANEL: Comprehensive debug block per year\n    const sanityPanel = {\n        ground: {\n            effectiveGflopsPerW: groundEffectiveGflopsPerW,\n            energyCostPerPflopYear: groundResult.energyCost,\n            siteCapexAmort: (_groundResult_siteCapexAmortPerPflopYear = groundResult.siteCapexAmortPerPflopYear) !== null && _groundResult_siteCapexAmortPerPflopYear !== void 0 ? _groundResult_siteCapexAmortPerPflopYear : groundResult.siteCost - ((_groundResult_capacityDeliveryPremium = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium !== void 0 ? _groundResult_capacityDeliveryPremium : 0) - ((_groundResult_timeToEnergizePenalty1 = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty1 !== void 0 ? _groundResult_timeToEnergizePenalty1 : 0),\n            delayPenalty: (_groundResult_timeToEnergizePenalty2 = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty2 !== void 0 ? _groundResult_timeToEnergizePenalty2 : 0,\n            capacityPremium: (_groundResult_capacityDeliveryPremium1 = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium1 !== void 0 ? _groundResult_capacityDeliveryPremium1 : 0,\n            constraintMultiplier: groundResult.constraintMultiplier,\n            total: groundTotalCost\n        },\n        orbit: {\n            // REMOVED: effectiveSpecificPower (duplicate of specificPower_effective_WPerKg)\n            // Use specificPower_effective_WPerKg instead (canonical field)\n            massMultiplier: (_hybridResult_specificPowerMultipliers_massMultiplier = (_hybridResult_specificPowerMultipliers = hybridResult.specificPowerMultipliers) === null || _hybridResult_specificPowerMultipliers === void 0 ? void 0 : _hybridResult_specificPowerMultipliers.massMultiplier) !== null && _hybridResult_specificPowerMultipliers_massMultiplier !== void 0 ? _hybridResult_specificPowerMultipliers_massMultiplier : 1.0,\n            requiredAreaM2: hybridResult.thermalSystem.qPerM2_W ? ((_hybridResult_thermalSystem_wasteHeatW = hybridResult.thermalSystem.wasteHeatW) !== null && _hybridResult_thermalSystem_wasteHeatW !== void 0 ? _hybridResult_thermalSystem_wasteHeatW : hybridResult.thermalSystem.wasteHeatKw * 1000) / ((_hybridResult_thermalSystem_qPerM2_W = hybridResult.thermalSystem.qPerM2_W) !== null && _hybridResult_thermalSystem_qPerM2_W !== void 0 ? _hybridResult_thermalSystem_qPerM2_W : 1) : hybridResult.thermalSystem.physicalAreaM2,\n            areaAvailableM2: (_hybridResult_thermalSystem_areaAvailableM2 = hybridResult.thermalSystem.areaAvailableM2) !== null && _hybridResult_thermalSystem_areaAvailableM2 !== void 0 ? _hybridResult_thermalSystem_areaAvailableM2 : hybridResult.thermalSystem.physicalAreaM2,\n            thermalCapFactor: hybridResult.thermalSystem.thermalCapFactor,\n            total: realisticCostPerPflop\n        },\n        allInvariantsPassed: (()=>{\n            var _groundResult_siteCapexAmortPerPflopYear, _groundResult_timeToEnergizePenalty, _groundResult_capacityDeliveryPremium;\n            // Check key invariants\n            const siteCostCheck = Math.abs(groundResult.siteCost - (((_groundResult_siteCapexAmortPerPflopYear = groundResult.siteCapexAmortPerPflopYear) !== null && _groundResult_siteCapexAmortPerPflopYear !== void 0 ? _groundResult_siteCapexAmortPerPflopYear : 0) + ((_groundResult_timeToEnergizePenalty = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty !== void 0 ? _groundResult_timeToEnergizePenalty : 0) + ((_groundResult_capacityDeliveryPremium = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium !== void 0 ? _groundResult_capacityDeliveryPremium : 0))) < 0.01;\n            const thermalAreaCheck = hybridResult.thermalSystem.areaAvailableM2 ? Math.abs(hybridResult.thermalSystem.areaAvailableM2 - hybridResult.thermalSystem.physicalAreaM2) / hybridResult.thermalSystem.physicalAreaM2 < 0.01 : true;\n            const specificPowerCheck = hybridResult.specificPowerMultipliers ? hybridResult.specificPowerMultipliers.effective <= hybridResult.specificPowerMultipliers.baseSpecificPower * 1.01 : true;\n            const thermalCapCheck = hybridResult.thermalSystem.thermalCapFactor >= 0 && hybridResult.thermalSystem.thermalCapFactor <= 1;\n            return siteCostCheck && thermalAreaCheck && specificPowerCheck && thermalCapCheck;\n        })()\n    };\n    var _groundResult_capacityDeliveryPremium2, _groundResult_timeToEnergizePenalty3, _groundResult_siteCapexAmortPerPflopYear1, _groundResult_capacityDeliveryPremium3, _groundResult_timeToEnergizePenalty4, _hybridResult_specificPowerMultipliers_effective, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _ref10, _ref11;\n    return {\n        year,\n        mode: params.isStaticMode ? \"STATIC\" : \"DYNAMIC\",\n        sanityPanel,\n        ground: {\n            electricityPricePerMwh: groundElectricityPricePerMwh,\n            pue: effectivePueGround,\n            capacityFactor: capacityFactorGround,\n            // HARD ASSERT: All ground efficiency fields must be populated and finite\n            gflopsPerWatt: (()=>{\n                const value = groundEffectiveGflopsPerW;\n                if (!isFinite(value) || value <= 0) {\n                    throw new Error(\"ground.gflopsPerWatt is invalid: \".concat(value, \". actualGroundInput=\").concat(actualGroundInput));\n                }\n                return value;\n            })(),\n            computeDefinition: (()=>{\n                // CRITICAL FIX: Validate all computeDefinition fields to catch unit corruption\n                const peak = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(groundEfficiencyResult.debug.chipPeakGflopsPerW, \"ground.computeDefinition.peakGflopsPerWatt\");\n                const effective = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(groundEfficiencyResult.debug.effectiveGflopsPerW, \"ground.computeDefinition.effectiveGflopsPerWatt\");\n                const utilization = groundEfficiencyResult.debug.utilizationFactor;\n                if (!isFinite(utilization) || utilization <= 0 || utilization > 1) {\n                    throw new Error(\"ground.computeDefinition.utilizationFactor is invalid: \".concat(utilization));\n                }\n                return {\n                    chipName: \"NVIDIA H100 SXM\",\n                    precision: \"FP16\",\n                    peakGflopsPerWatt: peak,\n                    utilizationFactor: utilization,\n                    effectiveGflopsPerWatt: effective,\n                    notes: \"Datacenter deployment, system-level efficiency\"\n                };\n            })(),\n            energyCostPerPflopYear: (()=>{\n                const value = groundResult.energyCost;\n                if (!isFinite(value) || value < 0) {\n                    throw new Error(\"ground.energyCostPerPflopYear is invalid: \".concat(value, \". \") + \"Check: groundEffectiveGflopsPerW=\".concat(groundEffectiveGflopsPerW, \", \") + \"groundElectricityPricePerMwh=\".concat(groundElectricityPricePerMwh, \", \") + \"effectivePueGround=\".concat(effectivePueGround));\n                }\n                return value;\n            })(),\n            siteCostPerPflopYear: (()=>{\n                const value = groundResult.siteCost;\n                if (!isFinite(value) || value < 0) {\n                    throw new Error(\"ground.siteCostPerPflopYear is invalid: \".concat(value));\n                }\n                return value;\n            })(),\n            siteCapexAmortPerPflopYear: (_groundResult_siteCapexAmortPerPflopYear1 = groundResult.siteCapexAmortPerPflopYear) !== null && _groundResult_siteCapexAmortPerPflopYear1 !== void 0 ? _groundResult_siteCapexAmortPerPflopYear1 : groundResult.siteCost - ((_groundResult_capacityDeliveryPremium2 = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium2 !== void 0 ? _groundResult_capacityDeliveryPremium2 : 0) - ((_groundResult_timeToEnergizePenalty3 = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty3 !== void 0 ? _groundResult_timeToEnergizePenalty3 : 0),\n            capacityDeliveryPremium: (_groundResult_capacityDeliveryPremium3 = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium3 !== void 0 ? _groundResult_capacityDeliveryPremium3 : 0,\n            timeToEnergizePenalty: (_groundResult_timeToEnergizePenalty4 = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty4 !== void 0 ? _groundResult_timeToEnergizePenalty4 : 0,\n            hardwareCapexPerPflopYear: groundResult.hardwareCost,\n            constraintMultiplier: 1.0,\n            constraintBreakdown: {\n                ...constraintBreakdown,\n                capacityDeliveryMultiplier: 1.0\n            },\n            constraints: groundResult.constraints ? {\n                ...groundResult.constraints,\n                method: \"adders\"\n            } : {\n                method: \"adders\",\n                capacityDeliveryPremium: groundResult.capacityDeliveryPremium || 0,\n                delayPenalty: groundResult.timeToEnergizePenalty || 0,\n                appliedMultipliers: {\n                    constraintMultiplierUsed: false,\n                    energyMultiplierUsed: false,\n                    siteMultiplierUsed: false\n                }\n            },\n            supplyMetrics: groundResult.supplyMetrics,\n            constraintComponents: groundResult.constraintComponents,\n            totalCostPerPflopYear: (()=>{\n                const value = groundTotalCost;\n                if (!isFinite(value) || value <= 0) {\n                    throw new Error(\"ground.totalCostPerPflopYear is invalid: \".concat(value, \". \") + \"Components: energy=\".concat(groundResult.energyCost, \", site=\").concat(groundResult.siteCost, \", hardware=\").concat(groundResult.hardwareCost, \", \") + \"groundEffectiveGflopsPerW=\".concat(groundEffectiveGflopsPerW, \", actualGroundInput=\").concat(actualGroundInput));\n                }\n                return value;\n            })(),\n            gpuHourPricing: {\n                basic: groundGpuHour(SLA_TIERS.basic),\n                standard: groundGpuHour(SLA_TIERS.standard),\n                premium: groundGpuHour(SLA_TIERS.premium)\n            },\n            tokenPricing: groundTokens,\n            smrEnabled: groundResult.smrEnabled,\n            smrRampFactor: groundResult.smrRampFactor,\n            effectiveElectricityCost: groundResult.effectiveElectricityCost,\n            constraintRelief: groundResult.constraintRelief\n        },\n        orbit: {\n            lcoePerMwh: hybridResult.powerSystem.totalCostUsd / (satellitePowerKW * _orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.PHYSICS_CONSTANTS.HOURS_PER_YEAR * lifetimeYears * hybridResult.capacityFactor / 1000),\n            pue: pueOrbital,\n            capacityFactor: hybridResult.capacityFactor,\n            capacityFactorProvenance: (_hybridResult_computePayload = hybridResult.computePayload) === null || _hybridResult_computePayload === void 0 ? void 0 : _hybridResult_computePayload.capacityFactorProvenance,\n            gflopsPerWatt: orbitEffectiveGflopsPerW,\n            computeDefinition: {\n                chipName: \"H100-equivalent (rad-tolerant)\",\n                precision: \"FP16\",\n                peakGflopsPerWatt: (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(orbitPeakGflopsPerWatt, \"orbit.computeDefinition.peakGflopsPerWatt\"),\n                utilizationFactor: orbitalEfficiencyResult.debug.utilizationFactor,\n                effectiveGflopsPerWatt: orbitSystemEffectiveGflopsPerWatt,\n                // deliveredGflopsPerWatt is stored in orbit.computeEfficiency.gflopsPerWatt, not here\n                notes: \"Commercial rad-tolerant variant. peakGflopsPerWatt = chip peak. effectiveGflopsPerWatt = peak * utilization / systemOverheadFactor (system-level effective). deliveredGflopsPerWatt = systemEffective \\xd7 thermalCapFactor \\xd7 radiationDerate \\xd7 availability\"\n            },\n            computeEfficiencyProvenance: {\n                peakGflopsPerWatt: orbitalEfficiencyResult.debug.chipPeakGflopsPerW,\n                utilizationFactor: orbitalEfficiencyResult.debug.utilizationFactor,\n                systemOverheadFactor: orbitalEfficiencyResult.debug.systemOverheadFactor,\n                effectiveGflopsPerWatt: orbitalEfficiencyResult.debug.effectiveGflopsPerW\n            },\n            launchCostPerKg: launchCostPerKg,\n            specificPowerWPerKg: hybridResult.specificPowerWPerKg,\n            specificPower_subsystem_WPerKg: hybridResult.specificPowerWPerKg,\n            specificPower_effective_WPerKg: (_hybridResult_specificPowerMultipliers_effective = (_hybridResult_specificPowerMultipliers1 = hybridResult.specificPowerMultipliers) === null || _hybridResult_specificPowerMultipliers1 === void 0 ? void 0 : _hybridResult_specificPowerMultipliers1.effective) !== null && _hybridResult_specificPowerMultipliers_effective !== void 0 ? _hybridResult_specificPowerMultipliers_effective : scalingResult.effectiveSpecificPower,\n            // Use specificPowerMultipliers from hybridResult (calculated in orbitalPhysics.ts with correct mass fraction accounting)\n            specificPowerMultipliers: hybridResult.specificPowerMultipliers,\n            energyCostPerPflopYear: orbitalBreakdown.power,\n            hardwareCostPerPflopYear: orbitalBreakdown.compute,\n            launchCostPerPflopYear: orbitalBreakdown.launch,\n            radiationMultiplier: 1.0,\n            thermalCapFactor: hybridResult.thermalSystem.thermalCapFactor,\n            congestionCostPerPflopYear: orbitalBreakdown.congestion,\n            totalCostPerPflopYear: realisticCostPerPflop,\n            thermalCapped: hybridResult.thermalSystem.thermalCapped,\n            computePowerKw: targetComputeKw,\n            maxRejectableKw: hybridResult.thermalSystem.maxRejectableKw || hybridResult.thermalSystem.wasteHeatKw * 1.25,\n            collisionRisk: congestion.collisionRisk,\n            bodyMountedAreaM2: 0,\n            deployableAreaM2: hybridResult.thermalSystem.physicalAreaM2,\n            totalRadiatorAreaM2: hybridResult.thermalSystem.physicalAreaM2,\n            radiatorCostPerPflopYear: hybridResult.thermalSystem.totalCostUsd * constellationCostMultiplier / totalEffectivePflops / lifetimeYears,\n            radiatorMassKg: hybridResult.thermalSystem.totalMassKg,\n            optimisticCostPerPflop: orbitalBreakdown.power + orbitalBreakdown.compute + orbitalBreakdown.bus,\n            radiationShieldingCost: orbitalBreakdown.radiation,\n            thermalSystemCost: orbitalBreakdown.thermal,\n            replacementRateCost: orbitalBreakdown.ops,\n            eccOverheadCost: 0,\n            redundancyCost: 0,\n            realisticCostPerPflop,\n            hybridBreakdown: orbitalBreakdown,\n            gpuHourPricing: {\n                basic: orbitalGpuHour(SLA_TIERS.basic),\n                standard: orbitalGpuHour(SLA_TIERS.standard),\n                premium: orbitalGpuHour(SLA_TIERS.premium)\n            },\n            tokenPricing: orbitalTokens,\n            radiationDegradation: {\n                annualFailureRate: useRadHardChips ? 0.09 : 0.15,\n                effectiveComputePercent: hybridResult.degradationFactor,\n                eccOverheadPct: 0.05,\n                applied: true\n            },\n            powerSystemType: hybridResult.powerSystemType,\n            scalingPenalty: scalingResult.scalingPenalty,\n            // REMOVED: effectiveSpecificPower (duplicate of specificPower_effective_WPerKg)\n            // Use specificPower_effective_WPerKg instead (canonical field)\n            fusionDetails: hybridResult.fusionDetails,\n            // Constellation sizing\n            constellation: {\n                design: {\n                    numSatellites: constellation.numSatellites,\n                    computePerSatKw: constellation.computePerSatKw,\n                    massPerSatKg: massPerSatKg,\n                    radiatorAreaPerSatM2: constellation.radiatorAreaPerSatM2\n                },\n                launch: {\n                    satsPerLaunch: constellation.satsPerLaunch,\n                    launchesRequired: constellation.launchesRequired,\n                    totalMassKg: effectiveTotalMassKg\n                },\n                scaling: {\n                    constellationOverhead: constellation.constellationOverhead,\n                    scalingEfficiency: constellation.scalingEfficiency\n                },\n                warnings: constellation.warnings\n            },\n            // Debug blocks for analysis - explicitly track all efficiency levels\n            // Single source of truth: define orbit.computeEfficiencyLevels each year\n            // Note: computeEfficiencyLevels is stored in metadata, not directly on orbit\n            effectiveComputeMultipliers: {\n                thermalCapFactor: hybridResult.thermalSystem.thermalCapFactor,\n                radiationDerate: hybridResult.degradationFactor || 1.0,\n                availability: hybridResult.capacityFactor || 1.0,\n                utilization: orbitalEfficiencyResult.debug.utilizationFactor\n            },\n            costShares: (()=>{\n                const total = realisticCostPerPflop;\n                return {\n                    launch: orbitalBreakdown.launch / total * 100,\n                    power: orbitalBreakdown.power / total * 100,\n                    compute: orbitalBreakdown.compute / total * 100,\n                    thermal: orbitalBreakdown.thermal / total * 100,\n                    bus: orbitalBreakdown.bus / total * 100,\n                    ops: orbitalBreakdown.ops / total * 100,\n                    networking: orbitalBreakdown.networking / total * 100,\n                    groundSegment: orbitalBreakdown.regulatory / total * 100\n                };\n            })(),\n            localSensitivity: (()=>{\n                // Calculate local sensitivity: dCost/dParameter (approximate derivatives)\n                // dCost_dLaunch: launch cost scales linearly with launchCostPerKg\n                const dCost_dLaunch = orbitalBreakdown.launch / launchCostPerKg;\n                // dCost_dSpecificPower: power cost scales inversely with specific power (negative)\n                const dCost_dSpecificPower = -(orbitalBreakdown.power / trajSpecificPower);\n                // dCost_dGflopsPerW: power cost scales inversely with GFLOPS/W (negative)\n                const dCost_dGflopsPerW = -(orbitalBreakdown.power / orbitEffectiveGflopsPerW);\n                // dCost_dFailureRate: ops cost scales with failure rate\n                const baseFailureRate = useRadHardChips ? 0.09 : 0.15;\n                const dCost_dFailureRate = orbitalBreakdown.ops / baseFailureRate;\n                // dCost_dPue: power cost scales linearly with PUE\n                const dCost_dPue = orbitalBreakdown.power / pueOrbital;\n                return {\n                    dCost_dLaunch,\n                    dCost_dSpecificPower,\n                    dCost_dGflopsPerW,\n                    dCost_dFailureRate,\n                    dCost_dPue\n                };\n            })()\n        },\n        edgeInference,\n        crossover: realisticCostPerPflop < groundComparatorCostPerPflopYear,\n        crossoverDetails: {\n            gpuHourCrossover,\n            tokenCrossover: orbitalTokens.llama70B.costPer1kTokens < groundTokens.llama70B.costPer1kTokens,\n            marketPosition: gpuHourCrossover ? \"Orbital \".concat(((1 - orbitalGpuHour(SLA_TIERS.standard).pricePerGpuHour / groundGpuHour(SLA_TIERS.standard).pricePerGpuHour) * 100).toFixed(1), \"% cheaper\") : \"Ground \".concat(((1 - groundGpuHour(SLA_TIERS.standard).pricePerGpuHour / orbitalGpuHour(SLA_TIERS.standard).pricePerGpuHour) * 100).toFixed(1), \"% cheaper\")\n        },\n        costAccountingValid,\n        costAccountingErrorPct,\n        metadata: {\n            groundUnits: [\n                {\n                    metric: \"gflopsPerWatt\",\n                    unit: \"GFLOPS/W\",\n                    level: \"system\",\n                    notes: \"Ground system-level efficiency including memory, network, power delivery overhead\"\n                }\n            ],\n            orbitUnits: [\n                {\n                    metric: \"gflopsPerWatt\",\n                    unit: \"GFLOPS/W\",\n                    level: \"delivered\",\n                    notes: \"Orbital delivered efficiency: systemEffective \\xd7 thermalCapFactor \\xd7 radiationDerate \\xd7 availability\"\n                }\n            ],\n            units: [\n                {\n                    metric: \"gflopsPerWatt\",\n                    unit: \"GFLOPS/W\",\n                    level: \"system\",\n                    notes: \"System-level efficiency including memory, network, power delivery overhead\"\n                },\n                {\n                    metric: \"costPerPflopYear\",\n                    unit: \"USD/PFLOP-year\",\n                    level: \"infrastructure\",\n                    notes: \"Total cost to operate 1 PFLOP of sustained compute for one year\"\n                },\n                {\n                    metric: \"pricePerGpuHour\",\n                    unit: \"USD/GPU-hour\",\n                    level: \"market\",\n                    notes: \"Market price with SLA, including margin and risk buffer\"\n                },\n                {\n                    metric: \"costPer1kTokens\",\n                    unit: \"USD/1K tokens\",\n                    level: \"application\",\n                    notes: \"Inference cost for specified model size (70B or 405B)\"\n                }\n            ],\n            debug: {\n                groundLifetime: groundLifetime,\n                gpuFailureRateAnnual: params.gpuFailureRateAnnual,\n                totalCostExcludesDelayPenalty: true,\n                totalCostEffectiveIncludesDelayPenalty: groundResult.totalCostPerPflopYearEffective !== undefined,\n                groundHasQueue,\n                groundComparatorCostPerPflopYear\n            },\n            computeEfficiency: {\n                gflopsPerWatt: orbitEffectiveGflopsPerW,\n                efficiencyLevel: \"delivered\",\n                validation: {\n                    // CRITICAL: Use deliveredValidation as primary - it compares like-for-like\n                    // Only fail if deliveredValidation fails (ratio mismatch) OR efficiencyValidation fails (range check)\n                    // consistencyCheck is for power/compute consistency, not efficiency validation\n                    valid: efficiencyValidation.valid && deliveredValidation.valid,\n                    warning: efficiencyValidation.warning || deliveredValidation.warning || undefined,\n                    expectedDelivered: deliveredValidation.expectedDelivered,\n                    delivered: deliveredValidation.delivered,\n                    ratio: deliveredValidation.ratio,\n                    factorsUsed: deliveredValidation.factorsUsed\n                }\n            },\n            // Chart inputs for power buildout constraints (replaces energyCostComparison)\n            chartInputs: {\n                powerBuildout: {\n                    demandGw: (_ref3 = (_ref2 = \"buildoutDebug\" in groundResult ? (_groundResult_buildoutDebug = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug === void 0 ? void 0 : _groundResult_buildoutDebug.demandGW : undefined) !== null && _ref2 !== void 0 ? _ref2 : \"supplyMetrics\" in groundResult ? (_groundResult_supplyMetrics = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics === void 0 ? void 0 : _groundResult_supplyMetrics.demandGw : undefined) !== null && _ref3 !== void 0 ? _ref3 : 0,\n                    supplyGw: (_ref4 = \"supplyMetrics\" in groundResult ? (_groundResult_supplyMetrics1 = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics1 === void 0 ? void 0 : _groundResult_supplyMetrics1.capacityGw : undefined) !== null && _ref4 !== void 0 ? _ref4 : 0,\n                    maxBuildRateGwYear: (_ref6 = (_ref5 = \"supplyMetrics\" in groundResult ? (_groundResult_supplyMetrics2 = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics2 === void 0 ? void 0 : _groundResult_supplyMetrics2.maxBuildRateGwYear : undefined) !== null && _ref5 !== void 0 ? _ref5 : \"buildoutDebug\" in groundResult ? (_groundResult_buildoutDebug1 = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug1 === void 0 ? void 0 : _groundResult_buildoutDebug1.buildRateGWyr : undefined) !== null && _ref6 !== void 0 ? _ref6 : 0,\n                    pipelineGw: (_ref7 = \"supplyMetrics\" in groundResult ? (_groundResult_supplyMetrics3 = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics3 === void 0 ? void 0 : _groundResult_supplyMetrics3.pipelineGw : undefined) !== null && _ref7 !== void 0 ? _ref7 : 0,\n                    backlogGw: (_ref9 = (_ref8 = \"backlogGw\" in groundResult ? groundResult.backlogGw : undefined) !== null && _ref8 !== void 0 ? _ref8 : \"buildoutDebug\" in groundResult ? (_groundResult_buildoutDebug2 = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug2 === void 0 ? void 0 : _groundResult_buildoutDebug2.backlogGW : undefined) !== null && _ref9 !== void 0 ? _ref9 : 0,\n                    avgWaitYears: (_ref11 = (_ref10 = \"avgWaitYears\" in groundResult ? groundResult.avgWaitYears : undefined) !== null && _ref10 !== void 0 ? _ref10 : \"buildoutDebug\" in groundResult ? (_groundResult_buildoutDebug3 = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug3 === void 0 ? void 0 : _groundResult_buildoutDebug3.timeToPowerYears : undefined) !== null && _ref11 !== void 0 ? _ref11 : 0\n                }\n            }\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvcGh5c2ljc0Nvc3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXbUQ7QUFDUztBQVlsQztBQUNtRjtBQUNzRTtBQUN6RTtBQUNWO0FBQ2tEO0FBQzVEO0FBQ0s7QUFDNUI7QUFNcUI7QUFJcEYsTUFBTXVCLFlBQVk7SUFDaEJDLGdCQUFnQjtJQUNoQkMsaUNBQWlDO0lBQ2pDQywwQkFBMEI7SUFDMUJDLDRCQUE0QjtBQUM5QjtBQUVPLE1BQU1DLHFCQUFzQztJQUNqREMsU0FBUztJQUNUQyx3QkFBd0I7SUFDeEJDLGdCQUFnQjtJQUNoQkMsd0JBQXdCO0lBQ3hCQyxzQkFBc0I7SUFDdEJDLHlCQUF5QjtJQUN6QkMsdUJBQXVCO0lBQ3ZCQyxzQkFBc0I7SUFDdEJDLGlCQUFpQjtBQUNuQixFQUFFO0FBRUssTUFBTUMsbUJBQWlFO0lBQzVFQyxlQUFlO1FBQ2JDLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGdCQUFnQjtJQUNsQjtJQUNBQyxVQUFVO1FBQ1JQLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGdCQUFnQjtJQUNsQjtJQUNBRSxhQUFhO1FBQ1hSLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGdCQUFnQjtJQUNsQjtJQUNBRyxRQUFRO1FBQ05ULE1BQU07UUFDTkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGdCQUFnQjtJQUNsQjtBQUNGLEVBQUU7QUFFRixTQUFTSSwwQkFDUEMsSUFBWSxFQUNaQyxXQUEyQixFQUMzQnZCLE9B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dUJBRDNFLDJCQUN5RjtvQkFDcEdnTyxjQUFjLFdBQUMsMkJBQWtCL0YsZUFBZUEsYUFBYStGLFlBQVksR0FBR2hPLHVCQUE3RCw2QkFDQSxtQkFBbUJpSSxnQkFBZUEsK0JBQUFBLGFBQWFnTCxhQUFhLGNBQTFCaEwsbURBQUFBLDZCQUE0QitMLGdCQUFnQixHQUFHaFUsdUJBRGxGLDZCQUNnRztnQkFDaEg7WUFDRjtRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvbGliL21vZGVsL3BoeXNpY3NDb3N0LnRzPzNmZGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgXG4gIFllYXJQYXJhbXMsIFxuICBZZWFybHlCcmVha2Rvd24sIFxuICBTTEFDb25maWcsIFxuICBHcHVIb3VyUHJpY2luZywgXG4gIFRva2VuUHJpY2luZywgXG4gIFdvcmtsb2FkVHlwZSxcbiAgR3JvdW5kU2NlbmFyaW8sXG4gIEdyb3VuZFNjZW5hcmlvQ29uZmlnLFxuICBTTVJUb2dnbGVQYXJhbXNcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBjYWxjdWxhdGVDb25nZXN0aW9uIH0gZnJvbSAnLi9jb25nZXN0aW9uJztcbmltcG9ydCB7IGNvbXB1dGVFZGdlSW5mZXJlbmNlQ29zdHMgfSBmcm9tICcuL2VkZ2VJbmZlcmVuY2UnO1xuaW1wb3J0IHsgXG4gIGNvbXB1dGVTYXRlbGxpdGVIeWJyaWRDb3N0LFxuICBERUZBVUxUX0NPTkZJRyxcbiAgUEhZU0lDU19DT05TVEFOVFMsXG4gIFNUQVJMSU5LX0VNUElSSUNBTCxcbiAgV09SS0xPQURfUFJPRklMRVMsXG4gIERFRkFVTFRfSU5URVJDT05ORUNULFxuICBERUZBVUxUX0ZVU0lPTl9QQVJBTVMsXG4gIERFRkFVTFRfUE9XRVJfU0NBTElORyxcbiAgY2FsY3VsYXRlU2NhbGVkTWFzcyxcbiAgU3BhY2VGdXNpb25QYXJhbXNcbn0gZnJvbSAnLi9vcmJpdGFsUGh5c2ljcyc7XG5pbXBvcnQgeyBjYWxjdWxhdGVSZWdpb25hbEdyb3VuZENvc3QsIEdyb3VuZENvc3RSZXN1bHQsIGdldEdsb2JhbERlbWFuZFBmbG9wcyB9IGZyb20gJy4vZ3JvdW5kX3N1cHBseV9tb2RlbCc7XG5pbXBvcnQgeyBnZW5lcmF0ZUdyb3VuZFN1cHBseVRyYWplY3RvcnksIGNhbGN1bGF0ZUNvbnN0cmFpbnRGcm9tU3VwcGx5LCBzdGVwR3JvdW5kU3VwcGx5LCBJTklUSUFMX1NVUFBMWV9TVEFURSwgR3JvdW5kU3VwcGx5U3RhdGUsIGdldEdsb2JhbERlbWFuZEd3IH0gZnJvbSAnLi9ncm91bmRfcXVldWVfbW9kZWwnO1xuaW1wb3J0IHsgY2FsY3VsYXRlR3JvdW5kQ29uc3RyYWludFBlbmFsdGllcywgY2FsY3VsYXRlU2NhcmNpdHlSZW50IH0gZnJvbSAnLi9ncm91bmRfY29uc3RyYWludF9wZW5hbHRpZXMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlQnVpbGRvdXRDb25zdHJhaW50cywgQnVpbGRvdXRTdGF0ZSwgQnVpbGRvdXRSZXN1bHQgfSBmcm9tICcuL2dyb3VuZF9idWlsZG91dCc7XG5pbXBvcnQgeyBzdGVwTW9iaWxpemF0aW9uU3RhdGUsIERFRkFVTFRfTU9CSUxJWkFUSU9OX1BBUkFNUywgTW9iaWxpemF0aW9uU2NlbmFyaW9QYXJhbXMsIE1vYmlsaXphdGlvblN0YXRlIH0gZnJvbSAnLi9ncm91bmRfcmFtcGluZ19tb2JpbGl6YXRpb24nO1xuaW1wb3J0IHsgQ29tcHV0ZUVmZmljaWVuY3ksIGdldERlZmF1bHRDb21wdXRlRWZmaWNpZW5jeSB9IGZyb20gJy4vY29tcHV0ZV9lZmZpY2llbmN5JztcbmltcG9ydCB7IGFzc2VydENvc3RBY2NvdW50aW5nLCB2YWxpZGF0ZVRyYWplY3RvcnlDb3N0QWNjb3VudGluZyB9IGZyb20gJy4vY29zdF9hY2NvdW50aW5nJztcbmltcG9ydCB7IHZhbGlkYXRlR2Zsb3BzUGVyV2F0dCwgQ09NUFVURV9VTklUUyB9IGZyb20gJy4vdW5pdHMnO1xuaW1wb3J0IHsgc2FuaXRpemVGaW5pdGUsIHNhbml0aXplU2VyaWVzIH0gZnJvbSAnLi4vdXRpbHMvc2FuaXRpemUnO1xuaW1wb3J0IHsgY2FsY3VsYXRlTmV0d29ya2luZ1NjYWxpbmcgfSBmcm9tICcuL25ldHdvcmtpbmdfc2NhbGluZyc7XG5pbXBvcnQgeyBzdGVwTGF1bmNoTGVhcm5pbmcsIExhdW5jaExlYXJuaW5nU3RhdGUgfSBmcm9tICcuL2xhdW5jaF9sZWFybmluZyc7XG5pbXBvcnQgeyBjYWxjdWxhdGVTeXN0ZW1TcGVjaWZpY1Bvd2VyIH0gZnJvbSAnLi9zcGVjaWZpY19wb3dlcic7XG5pbXBvcnQgeyBjYWxjdWxhdGVUaGVybWFsU3lzdGVtLCBERUZBVUxUX1RIRVJNQUxfUEFSQU1TIH0gZnJvbSAnLi90aGVybWFsX3BoeXNpY3MnO1xuaW1wb3J0IHsgZGVzaWduQ29uc3RlbGxhdGlvbiwgU0FURUxMSVRFX0NPTlNUUkFJTlRTIH0gZnJvbSAnLi9jb25zdGVsbGF0aW9uX3NpemluZyc7XG5pbXBvcnQgeyBnZXRTdGF0aWNQYXJhbXMgfSBmcm9tICcuL21vZGVzL3N0YXRpYyc7XG5pbXBvcnQgeyBnZXREZW1hbmRQcm9qZWN0aW9uLCBnZXRGYWNpbGl0eUxvYWRHVywgZ2V0RGVtYW5kTmV3R1csIGdldElUTG9hZEdXIH0gZnJvbSAnLi90cmFqZWN0b3J5JztcblxuY29uc3QgQ09OU1RBTlRTID0ge1xuICBIT1VSU19QRVJfWUVBUjogODc2MCxcbiAgR1JPVU5EX0hBUkRXQVJFX0NPU1RfUEZMT1BfMjAyNTogMTUwMDAsIFxuICBHUk9VTkRfSEFSRFdBUkVfTElGRVRJTUU6IDMsXG4gIE1JTl9ERUxJVkVSRURfR0ZMT1BTX1BFUl9XOiAyMCwgLy8gTWluaW11bSBkZWxpdmVyZWQgZWZmaWNpZW5jeSB0byBwcmV2ZW50IHZhbGlkYXRpb24gZXJyb3JzIGZyb20gc2V2ZXJlIHRoZXJtYWwgY29uc3RyYWludHNcbn07XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NNUl9QQVJBTVM6IFNNUlRvZ2dsZVBhcmFtcyA9IHtcbiAgZW5hYmxlZDogZmFsc2UsXG4gIHNtckRlcGxveW1lbnRTdGFydFllYXI6IDIwMzAsXG4gIHNtclJhbXBVcFllYXJzOiA1LFxuICBlbGVjdHJpY2l0eUNvc3RXaXRoU01SOiA1MCxcbiAgZ3JpZENvbnN0cmFpbnRSZWxpZWY6IDAuOTAsXG4gIGNvb2xpbmdDb25zdHJhaW50UmVsaWVmOiAwLjUwLFxuICB3YXRlckNvbnN0cmFpbnRSZWxpZWY6IDAuMzAsXG4gIGxhbmRDb25zdHJhaW50UmVsaWVmOiAwLjYwLFxuICBzbXJDYXBleFByZW1pdW06IDEuMTUsXG59O1xuXG5leHBvcnQgY29uc3QgR1JPVU5EX1NDRU5BUklPUzogUmVjb3JkPEdyb3VuZFNjZW5hcmlvLCBHcm91bmRTY2VuYXJpb0NvbmZpZz4gPSB7XG4gIHVuY29uc3RyYWluZWQ6IHtcbiAgICBuYW1lOiAnVW5jb25zdHJhaW5lZCcsXG4gICAgZGVzY3JpcHRpb246ICdTTVJzICsgZ2VvZ3JhcGhpYyBhcmJpdHJhZ2Ugc29sdmUgcG93ZXIvd2F0ZXIgY29uc3RyYWludHMnLFxuICAgIGNvbnN0cmFpbnRDYXA6IDEuNSxcbiAgICBncmlkR3Jvd3RoUmF0ZTogMC4wMixcbiAgICBjb29saW5nR3Jvd3RoUmF0ZTogMC4wMSxcbiAgICB3YXRlckdyb3d0aFJhdGU6IDAuMDEsXG4gICAgbGFuZEdyb3d0aFJhdGU6IDAuMDEsXG4gIH0sXG4gIG1vZGVyYXRlOiB7XG4gICAgbmFtZTogJ01vZGVyYXRlJyxcbiAgICBkZXNjcmlwdGlvbjogJ1BhcnRpYWwgYWRhcHRhdGlvbiwgc29tZSBwZXJzaXN0ZW50IGZyaWN0aW9uJyxcbiAgICBjb25zdHJhaW50Q2FwOiAzLjAsXG4gICAgZ3JpZEdyb3d0aFJhdGU6IDAuMDMsXG4gICAgY29vbGluZ0dyb3d0aFJhdGU6IDAuMDIsXG4gICAgd2F0ZXJHcm93dGhSYXRlOiAwLjAxNSxcbiAgICBsYW5kR3Jvd3RoUmF0ZTogMC4wMTUsXG4gIH0sXG4gIGNvbnN0cmFpbmVkOiB7XG4gICAgbmFtZTogJ0NvbnN0cmFpbmVkIChBZ2dyZXNzaXZlIEJhc2VsaW5lKScsXG4gICAgZGVzY3JpcHRpb246ICdBY2NlbGVyYXRlZCBBSSBkZW1hbmQgcHJlc3N1cmUgb24gaW5mcmFzdHJ1Y3R1cmUnLFxuICAgIGNvbnN0cmFpbnRDYXA6IG51bGwsXG4gICAgZ3JpZEdyb3d0aFJhdGU6IDAuMDcsICAgICAgLy8gNyUveWVhciAod2FzIDUlKVxuICAgIGNvb2xpbmdHcm93dGhSYXRlOiAwLjA0LCAgIC8vIDQlL3llYXIgKHdhcyAzJSlcbiAgICB3YXRlckdyb3d0aFJhdGU6IDAuMDMsICAgICAvLyAzJS95ZWFyICh3YXMgMiUpXG4gICAgbGFuZEdyb3d0aFJhdGU6IDAuMDMsICAgICAgLy8gMyUveWVhciAod2FzIDIlKVxuICB9LFxuICBzZXZlcmU6IHtcbiAgICBuYW1lOiAnU2V2ZXJlJyxcbiAgICBkZXNjcmlwdGlvbjogJ0NvbnN0cmFpbmVkICsgY2FyYm9uIHRheCArIHdhdGVyIHNjYXJjaXR5IGNyaXNpcycsXG4gICAgY29uc3RyYWludENhcDogbnVsbCxcbiAgICBncmlkR3Jvd3RoUmF0ZTogMC4wOSwgICAgICAvLyA5JS95ZWFyICh3YXMgNyUpXG4gICAgY29vbGluZ0dyb3d0aFJhdGU6IDAuMDYsICAgLy8gNiUveWVhciAod2FzIDUlKVxuICAgIHdhdGVyR3Jvd3RoUmF0ZTogMC4wNSwgICAgIC8vIDUlL3llYXIgKHdhcyA0JSlcbiAgICBsYW5kR3Jvd3RoUmF0ZTogMC4wNCwgICAgICAvLyA0JS95ZWFyICh3YXMgMyUpXG4gIH0sXG59O1xuXG5mdW5jdGlvbiBjYWxjdWxhdGVHcm91bmRDb25zdHJhaW50KFxuICB5ZWFyOiBudW1iZXIsXG4gIHNjZW5hcmlvS2V5OiBHcm91bmRTY2VuYXJpbyxcbiAgZW5hYmxlZDogYm9vbGVhblxuKTogeyBtdWx0aXBsaWVyOiBudW1iZXIsIGJyZWFrZG93bjogeyBncmlkOiBudW1iZXIsIGNvb2xpbmc6IG51bWJlciwgd2F0ZXI6IG51bWJlciwgbGFuZDogbnVtYmVyIH0gfSB7XG4gIGlmICghZW5hYmxlZCkgcmV0dXJuIHsgbXVsdGlwbGllcjogMS4wLCBicmVha2Rvd246IHsgZ3JpZDogMS4wLCBjb29saW5nOiAxLjAsIHdhdGVyOiAxLjAsIGxhbmQ6IDEuMCB9IH07XG4gIFxuICBjb25zdCBzY2VuYXJpbyA9IEdST1VORF9TQ0VOQVJJT1Nbc2NlbmFyaW9LZXldO1xuICBjb25zdCB5ZWFyc0Zyb21CYXNlID0gTWF0aC5tYXgoMCwgeWVhciAtIDIwMjUpO1xuICBcbiAgY29uc3QgZ3JpZCA9IE1hdGgucG93KDEgKyBzY2VuYXJpby5ncmlkR3Jvd3RoUmF0ZSwgeWVhcnNGcm9tQmFzZSk7XG4gIGNvbnN0IGNvb2xpbmcgPSBNYXRoLnBvdygxICsgc2NlbmFyaW8uY29vbGluZ0dyb3d0aFJhdGUsIHllYXJzRnJvbUJhc2UpO1xuICBjb25zdCB3YXRlciA9IE1hdGgucG93KDEgKyBzY2VuYXJpby53YXRlckdyb3d0aFJhdGUsIHllYXJzRnJvbUJhc2UpO1xuICBjb25zdCBsYW5kID0gTWF0aC5wb3coMSArIHNjZW5hcmlvLmxhbmRHcm93dGhSYXRlLCB5ZWFyc0Zyb21CYXNlKTtcbiAgXG4gIGxldCBtdWx0aXBsaWVyID0gZ3JpZCAqIGNvb2xpbmcgKiB3YXRlciAqIGxhbmQ7XG4gIGlmIChzY2VuYXJpby5jb25zdHJhaW50Q2FwICE9PSBudWxsKSB7XG4gICAgbXVsdGlwbGllciA9IE1hdGgubWluKG11bHRpcGxpZXIsIHNjZW5hcmlvLmNvbnN0cmFpbnRDYXApO1xuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIG11bHRpcGxpZXIsXG4gICAgYnJlYWtkb3duOiB7IGdyaWQsIGNvb2xpbmcsIHdhdGVyLCBsYW5kIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wdXRlRWZmaWNpZW5jeShcbiAgZ2Zsb3BzUGVyV2F0dDogbnVtYmVyLFxuICBsZXZlbDogJ2NoaXAnIHwgJ3N5c3RlbScgfCAnZGF0YWNlbnRlcicgPSAnc3lzdGVtJ1xuKTogeyB2YWxpZDogYm9vbGVhbjsgd2FybmluZz86IHN0cmluZyB9IHtcbiAgY29uc3QgcmFuZ2VzID0ge1xuICAgIGNoaXA6IHsgbWluOiAxMDAsIG1heDogMTAwMDAgfSwgICAgICAgLy8gQ2hpcC1sZXZlbCAodXAgdG8gMTBrIGZvciBmdXR1cmUgRlA4KVxuICAgIHN5c3RlbTogeyBtaW46IDMwLCBtYXg6IDUwMDAgfSwgICAgICAgLy8gU3lzdGVtLWxldmVsICBcbiAgICBkYXRhY2VudGVyOiB7IG1pbjogMTAsIG1heDogMTAwMCB9LCAgIC8vIEZ1bGwgZGF0YWNlbnRlclxuICB9O1xuICBcbiAgY29uc3QgcmFuZ2UgPSByYW5nZXNbbGV2ZWxdO1xuICBpZiAoZ2Zsb3BzUGVyV2F0dCA8IHJhbmdlLm1pbiB8fCBnZmxvcHNQZXJXYXR0ID4gcmFuZ2UubWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgIHdhcm5pbmc6IGBnZmxvcHNQZXJXYXR0PSR7Z2Zsb3BzUGVyV2F0dC50b0ZpeGVkKDApfSBvdXRzaWRlIGV4cGVjdGVkIHJhbmdlIGZvciAke2xldmVsfSBsZXZlbCAoJHtyYW5nZS5taW59LSR7cmFuZ2UubWF4fSlgLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfTtcbn1cblxuY29uc3QgU0xBX1RJRVJTOiBSZWNvcmQ8c3RyaW5nLCBTTEFDb25maWc+ID0ge1xuICAnYmFzaWMnOiB7XG4gICAgYXZhaWxhYmlsaXR5VGFyZ2V0OiAwLjk5LFxuICAgIG1heExhdGVuY3lUb0dyb3VuZE1zOiAxMDAsXG4gICAgbWluQmFuZHdpZHRoR2JwczogMSxcbiAgICBtYXhSZWNvdmVyeVRpbWVNaW51dGVzOiA2MCxcbiAgICBjcmVkaXRQZXJWaW9sYXRpb25QY3Q6IDEwLFxuICB9LFxuICAnc3RhbmRhcmQnOiB7XG4gICAgYXZhaWxhYmlsaXR5VGFyZ2V0OiAwLjk5OSxcbiAgICBtYXhMYXRlbmN5VG9Hcm91bmRNczogNTAsXG4gICAgbWluQmFuZHdpZHRoR2JwczogMTAsXG4gICAgbWF4UmVjb3ZlcnlUaW1lTWludXRlczogMTUsXG4gICAgY3JlZGl0UGVyVmlvbGF0aW9uUGN0OiAyNSxcbiAgfSxcbiAgJ3ByZW1pdW0nOiB7XG4gICAgYXZhaWxhYmlsaXR5VGFyZ2V0OiAwLjk5OTksXG4gICAgbWF4TGF0ZW5jeVRvR3JvdW5kTXM6IDIwLFxuICAgIG1pbkJhbmR3aWR0aEdicHM6IDEwMCxcbiAgICBtYXhSZWNvdmVyeVRpbWVNaW51dGVzOiA1LFxuICAgIGNyZWRpdFBlclZpb2xhdGlvblBjdDogNTAsXG4gIH0sXG59O1xuXG5mdW5jdGlvbiBhcHBseVN0YXRpY0ZyZWV6ZShwYXJhbXM6IFllYXJQYXJhbXMpOiBZZWFyUGFyYW1zIHtcbiAgaWYgKCFwYXJhbXMuaXNTdGF0aWNNb2RlKSByZXR1cm4gcGFyYW1zO1xuICBcbiAgcmV0dXJuIHtcbiAgICAuLi5wYXJhbXMsXG4gICAgbGF1bmNoQ29zdEtnOiAxNTAwLFxuICAgIHNwZWNpZmljUG93ZXJXS2c6IDM2LjUsXG4gICAgZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1OiAzMCwgXG4gICAgb3JiaXRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjU6IDI1LCBcbiAgICBncm91bmRDb25zdHJhaW50c0VuYWJsZWQ6IHRydWUsXG4gICAgcG93ZXJHcmlkTXVsdGlwbGllcjogMS4wLFxuICAgIGNvb2xpbmdNdWx0aXBsaWVyOiAxLjAsXG4gICAgd2F0ZXJTY2FyY2l0eUVuYWJsZWQ6IGZhbHNlLFxuICAgIGxhbmRTY2FyY2l0eUVuYWJsZWQ6IGZhbHNlLFxuICAgIGRlcGxveWFibGVBcmVhMjAyNU0yOiA3NSxcbiAgICBkZXBsb3lhYmxlQXJlYTIwNDBNMjogNzUsXG4gIH07XG59XG5cbi8vIENhY2hlIGZvciBtb25vdG9uaWNpdHkgY2hlY2tcbmxldCBwcmV2TGF1bmNoQ29zdENhY2hlOiBNYXA8bnVtYmVyLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGF1bmNoQ29zdFBlcktnKHllYXI6IG51bWJlciwgYmFzZTIwMjU6IG51bWJlcik6IG51bWJlciB7XG4gIGlmICh5ZWFyIDw9IDIwMjUpIHtcbiAgICBwcmV2TGF1bmNoQ29zdENhY2hlLnNldCh5ZWFyLCBiYXNlMjAyNSk7XG4gICAgcmV0dXJuIGJhc2UyMDI1O1xuICB9XG4gIFxuICBjb25zdCBDT01NRVJDSUFMX01BUktVUCA9IDIuNTtcbiAgY29uc3QgSU5TVVJBTkNFX1BDVCA9IDAuMDU7XG4gIGNvbnN0IElOVEVHUkFUSU9OX0NPU1RfUEVSX0xBVU5DSCA9IDUwMDAwMDsgLy8gJDUwMGsgcGVyIGxhdW5jaFxuICBjb25zdCBBU1NVTUVEX1BBWUxPQURfS0cgPSAxMDAwMDA7IC8vIDEwMHQgcGF5bG9hZCBmb3IgaW50ZWdyYXRpb24gY29zdCBhbW9ydGl6YXRpb25cbiAgXG4gIC8vIEludGVybmFsIFNwYWNlWCBjb3N0IHRyYWplY3RvcnkgKG1hcmdpbmFsIGNvc3QpXG4gIC8vIE5vcm1hbGl6ZSBiYXNlMjAyNSB0byBpbnRlcm5hbCBjb3N0IHNjYWxlXG4gIGNvbnN0IGludGVybmFsQmFzZTIwMjUgPSBiYXNlMjAyNSAvIChDT01NRVJDSUFMX01BUktVUCAqICgxICsgSU5TVVJBTkNFX1BDVCkpIC0gKElOVEVHUkFUSU9OX0NPU1RfUEVSX0xBVU5DSCAvIEFTU1VNRURfUEFZTE9BRF9LRyk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRCYXNlID0gTWF0aC5tYXgoaW50ZXJuYWxCYXNlMjAyNSwgNjAwKTsgLy8gRW5zdXJlIHJlYXNvbmFibGUgaW50ZXJuYWwgY29zdFxuICBcbiAgY29uc3QgaW50ZXJuYWxXYXlwb2ludHM6IFtudW1iZXIsIG51bWJlcl1bXSA9IFtcbiAgICBbMjAyNSwgbm9ybWFsaXplZEJhc2VdLFxuICAgIFsyMDI2LCA4MDBdLFxuICAgIFsyMDI3LCA0MDBdLFxuICAgIFsyMDI4LCAyMDBdLFxuICAgIFsyMDMwLCA3NV0sXG4gICAgWzIwMzUsIDMwXSxcbiAgICBbMjA0MCwgMjBdLFxuICAgIFsyMDQ1LCAxNV0sXG4gICAgWzIwNTAsIDEwXSAgIC8vIEludGVybmFsIGNvc3QgZmxvb3JcbiAgXTtcbiAgXG4gIC8vIEZpbmQgaW50ZXJuYWwgY29zdFxuICBsZXQgaW50ZXJuYWxDb3N0UGVyS2cgPSBub3JtYWxpemVkQmFzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnRlcm5hbFdheXBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCBbeTEsIGMxXSA9IGludGVybmFsV2F5cG9pbnRzW2ldO1xuICAgIGNvbnN0IFt5MiwgYzJdID0gaW50ZXJuYWxXYXlwb2ludHNbaSArIDFdO1xuICAgIGlmICh5ZWFyID49IHkxICYmIHllYXIgPD0geTIpIHtcbiAgICAgIGNvbnN0IHQgPSAoeWVhciAtIHkxKSAvICh5MiAtIHkxKTtcbiAgICAgIGludGVybmFsQ29zdFBlcktnID0gYzEgKiBNYXRoLnBvdyhjMiAvIGMxLCB0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoeWVhciA+IGludGVybmFsV2F5cG9pbnRzW2ludGVybmFsV2F5cG9pbnRzLmxlbmd0aCAtIDFdWzBdKSB7XG4gICAgaW50ZXJuYWxDb3N0UGVyS2cgPSBpbnRlcm5hbFdheXBvaW50c1tpbnRlcm5hbFdheXBvaW50cy5sZW5ndGggLSAxXVsxXTtcbiAgfVxuICBcbiAgLy8gQXBwbHkgY29tbWVyY2lhbCBtYXJrdXBcbiAgY29uc3Qgd2l0aE1hcmt1cCA9IGludGVybmFsQ29zdFBlcktnICogQ09NTUVSQ0lBTF9NQVJLVVA7XG4gIGNvbnN0IHdpdGhJbnN1cmFuY2UgPSB3aXRoTWFya3VwICogKDEgKyBJTlNVUkFOQ0VfUENUKTtcbiAgY29uc3QgaW50ZWdyYXRpb25QZXJLZyA9IElOVEVHUkFUSU9OX0NPU1RfUEVSX0xBVU5DSCAvIEFTU1VNRURfUEFZTE9BRF9LRztcbiAgY29uc3QgY29tbWVyY2lhbENvc3RQZXJLZyA9IHdpdGhJbnN1cmFuY2UgKyBpbnRlZ3JhdGlvblBlcktnO1xuICBcbiAgLy8gRmxvb3I6IGNvbW1lcmNpYWwgY29zdCBuZXZlciBiZWxvdyAkMzAva2cgKHJlYWxpc3RpYyBtaW5pbXVtKVxuICBsZXQgcmVzdWx0ID0gTWF0aC5tYXgoY29tbWVyY2lhbENvc3RQZXJLZywgMzApO1xuICBcbiAgLy8gRW5mb3JjZSBtb25vdG9uaWNpdHk6IG5ldmVyIGluY3JlYXNlIGZyb20gcHJldmlvdXMgeWVhclxuICBjb25zdCBwcmV2WWVhciA9IHllYXIgLSAxO1xuICBjb25zdCBwcmV2Q29zdCA9IHByZXZMYXVuY2hDb3N0Q2FjaGUuZ2V0KHByZXZZZWFyKTtcbiAgaWYgKHByZXZDb3N0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0ID4gcHJldkNvc3QpIHtcbiAgICByZXN1bHQgPSBwcmV2Q29zdDsgLy8gQ2xhbXAgdG8gcHJldmlvdXMgeWVhcidzIGNvc3RcbiAgfVxuICBcbiAgcHJldkxhdW5jaENvc3RDYWNoZS5zZXQoeWVhciwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlVG9rZW5QcmljaW5nKFxuICBjb3N0UGVyUGZsb3BZZWFyOiBudW1iZXIsXG4gIG1vZGVsQ29uZmlnOiB7XG4gICAgcGFyYW1zOiBudW1iZXI7XG4gICAgcHJlY2lzaW9uOiAnZnAxNicgfCAnZnA4JyB8ICdpbnQ4JztcbiAgfVxuKTogVG9rZW5QcmljaW5nIHtcbiAgY29uc3QgYmFzZUZMT1BTID0gbW9kZWxDb25maWcucGFyYW1zICogMjtcbiAgY29uc3QgcHJlY2lzaW9uTXVsdGlwbGllciA9IHtcbiAgICAnZnAxNic6IDEuMCxcbiAgICAnZnA4JzogMC41LFxuICAgICdpbnQ4JzogMC41LFxuICB9W21vZGVsQ29uZmlnLnByZWNpc2lvbl07XG4gIGNvbnN0IGZsb3BzUGVyVG9rZW4gPSBiYXNlRkxPUFMgKiBwcmVjaXNpb25NdWx0aXBsaWVyO1xuICBjb25zdCBzZWNvbmRzUGVyWWVhciA9IDg3NjAgKiAzNjAwO1xuICBjb25zdCBmbG9wc1BlclBmbG9wWWVhciA9IDFlMTUgKiBzZWNvbmRzUGVyWWVhcjtcbiAgY29uc3QgdG9rZW5zUGVyUGZsb3BZZWFyID0gZmxvcHNQZXJQZmxvcFllYXIgLyBmbG9wc1BlclRva2VuO1xuICBjb25zdCBjb3N0UGVyVG9rZW4gPSBjb3N0UGVyUGZsb3BZZWFyIC8gdG9rZW5zUGVyUGZsb3BZZWFyO1xuICBcbiAgcmV0dXJuIHtcbiAgICBtb2RlbFBhcmFtczogbW9kZWxDb25maWcucGFyYW1zLFxuICAgIHByZWNpc2lvbjogbW9kZWxDb25maWcucHJlY2lzaW9uLFxuICAgIGZsb3BzUGVyVG9rZW4sXG4gICAgdG9rZW5zUGVyUGZsb3BZZWFyLFxuICAgIGNvc3RQZXJUb2tlbixcbiAgICBjb3N0UGVyMWtUb2tlbnM6IGNvc3RQZXJUb2tlbiAqIDEwMDAsXG4gICAgY29zdFBlcjFtVG9rZW5zOiBjb3N0UGVyVG9rZW4gKiAxZTYsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUdwdUhvdXJQcmljaW5nKFxuICBjb3N0UGVyUGZsb3BZZWFyOiBudW1iZXIsXG4gIHBhcmFtczoge1xuICAgIHBmbG9wc1BlckdwdTogbnVtYmVyO1xuICAgIHV0aWxpemF0aW9uVGFyZ2V0OiBudW1iZXI7XG4gICAgb3BlcmF0b3JNYXJnaW5QY3Q6IG51bWJlcjtcbiAgICBzbGE6IFNMQUNvbmZpZztcbiAgICBsb2NhdGlvbjogJ29yYml0YWwnIHwgJ2dyb3VuZCc7XG4gIH0sXG4gIGNvc3RCcmVha2Rvd24/OiB7ICAvLyBPcHRpb25hbCBicmVha2Rvd24gdG8gZGVyaXZlIHBvd2VyL2Nvb2xpbmcvaW50ZXJjb25uZWN0XG4gICAgcG93ZXI/OiBudW1iZXI7XG4gICAgdGhlcm1hbD86IG51bWJlcjtcbiAgICBpbnRlcmNvbm5lY3Q/OiBudW1iZXI7XG4gICAgb3BzPzogbnVtYmVyO1xuICAgIGNvbXB1dGU/OiBudW1iZXI7XG4gICAgc2l0ZT86IG51bWJlcjtcbiAgICBba2V5OiBzdHJpbmddOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIH1cbik6IEdwdUhvdXJQcmljaW5nIHtcbiAgY29uc3QgaG91cnNQZXJZZWFyID0gODc2MDtcbiAgY29uc3QgY29zdFBlckdwdVllYXIgPSBjb3N0UGVyUGZsb3BZZWFyICogcGFyYW1zLnBmbG9wc1BlckdwdTtcbiAgY29uc3QgZWZmZWN0aXZlSG91cnMgPSBob3Vyc1BlclllYXIgKiBwYXJhbXMudXRpbGl6YXRpb25UYXJnZXQ7XG4gIGNvbnN0IGJhc2VQZXJIb3VyID0gY29zdFBlckdwdVllYXIgLyBlZmZlY3RpdmVIb3VycztcbiAgXG4gIC8vIERFRkVOU0lWRSBDSEVDSzogR1BVLWhvdXIgcHJpY2Ugc2hvdWxkIGJlIGluIHJlYXNvbmFibGUgcmFuZ2UgKCQwLjAxIHRvICQxMDApXG4gIC8vIElmIGNvc3RQZXJQZmxvcFllYXIgaXMgaW5zYW5lIChlLmcuLCBiaWxsaW9ucyksIHRoaXMgd2lsbCBjYXRjaCBpdFxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgYmFzZVBlckhvdXIgPiAxMDAwKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGBbR1BVLUhPVVIgUFJJQ0lOR10gWWVhciBjYWxjdWxhdGlvbjogYmFzZVBlckhvdXI9JHtiYXNlUGVySG91cn0gPiAxMDAwLiBgICtcbiAgICAgIGBjb3N0UGVyUGZsb3BZZWFyPSR7Y29zdFBlclBmbG9wWWVhcn0sIHBmbG9wc1BlckdwdT0ke3BhcmFtcy5wZmxvcHNQZXJHcHV9LCBgICtcbiAgICAgIGBlZmZlY3RpdmVIb3Vycz0ke2VmZmVjdGl2ZUhvdXJzfWBcbiAgICApO1xuICAgIC8vIENsYW1wIHRvIHByZXZlbnQgY2hhcnQgZXhwbG9zaW9uXG4gICAgY29uc3QgY2xhbXBlZENvc3RQZXJQZmxvcFllYXIgPSBNYXRoLm1pbihjb3N0UGVyUGZsb3BZZWFyLCAxMDAwMCk7IC8vIENhcCBhdCAkMTBrL1BGTE9QLXllYXJcbiAgICBjb25zdCBjbGFtcGVkQ29zdFBlckdwdVllYXIgPSBjbGFtcGVkQ29zdFBlclBmbG9wWWVhciAqIHBhcmFtcy5wZmxvcHNQZXJHcHU7XG4gICAgY29uc3QgY2xhbXBlZEJhc2VQZXJIb3VyID0gY2xhbXBlZENvc3RQZXJHcHVZZWFyIC8gZWZmZWN0aXZlSG91cnM7XG4gICAgaWYgKGNsYW1wZWRCYXNlUGVySG91ciA+IDEwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgW0dQVS1IT1VSIFBSSUNJTkddIEV2ZW4gYWZ0ZXIgY2xhbXBpbmcsIGJhc2VQZXJIb3VyPSR7Y2xhbXBlZEJhc2VQZXJIb3VyfSA+IDEwMC4gYCArXG4gICAgICAgIGBUaGlzIGluZGljYXRlcyBhIHVuaXQgZXJyb3Igb3IgY2FsY3VsYXRpb24gYnVnLiBDaGVjayBjb3N0UGVyUGZsb3BZZWFyIGlucHV0LmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBEZXJpdmUgYnJlYWtkb3duIGZyb20gY29zdCBjb21wb25lbnRzIGlmIHByb3ZpZGVkXG4gIGxldCBwb3dlclBlckhvdXIgPSAwO1xuICBsZXQgY29vbGluZ1BlckhvdXIgPSAwO1xuICBsZXQgaW50ZXJjb25uZWN0UGVySG91ciA9IDA7XG4gIGxldCBvcHNQZXJIb3VyID0gMDtcbiAgbGV0IGNvbXB1dGVQZXJIb3VyID0gYmFzZVBlckhvdXI7XG4gIFxuICBpZiAoY29zdEJyZWFrZG93bikge1xuICAgIGNvbnN0IHRvdGFsQmFzZSA9IChjb3N0QnJlYWtkb3duLnBvd2VyIHx8IDApICsgKGNvc3RCcmVha2Rvd24udGhlcm1hbCB8fCAwKSArIFxuICAgICAgICAgICAgICAgICAgICAgIChjb3N0QnJlYWtkb3duLmludGVyY29ubmVjdCB8fCAwKSArIChjb3N0QnJlYWtkb3duLm9wcyB8fCAwKSArIFxuICAgICAgICAgICAgICAgICAgICAgIChjb3N0QnJlYWtkb3duLmNvbXB1dGUgfHwgMCk7XG4gICAgaWYgKHRvdGFsQmFzZSA+IDApIHtcbiAgICAgIC8vIFNjYWxlIGJyZWFrZG93biBjb21wb25lbnRzIHRvIEdQVS1ob3VyXG4gICAgICBjb25zdCBzY2FsZSA9IGNvc3RQZXJHcHVZZWFyIC8gKHRvdGFsQmFzZSAqIHBhcmFtcy5wZmxvcHNQZXJHcHUpIC8gZWZmZWN0aXZlSG91cnM7XG4gICAgICBwb3dlclBlckhvdXIgPSAoY29zdEJyZWFrZG93bi5wb3dlciB8fCAwKSAqIHBhcmFtcy5wZmxvcHNQZXJHcHUgKiBzY2FsZTtcbiAgICAgIGNvb2xpbmdQZXJIb3VyID0gKGNvc3RCcmVha2Rvd24udGhlcm1hbCB8fCAwKSAqIHBhcmFtcy5wZmxvcHNQZXJHcHUgKiBzY2FsZTtcbiAgICAgIGludGVyY29ubmVjdFBlckhvdXIgPSAoY29zdEJyZWFrZG93bi5pbnRlcmNvbm5lY3QgfHwgMCkgKiBwYXJhbXMucGZsb3BzUGVyR3B1ICogc2NhbGU7XG4gICAgICBvcHNQZXJIb3VyID0gKGNvc3RCcmVha2Rvd24ub3BzIHx8IDApICogcGFyYW1zLnBmbG9wc1BlckdwdSAqIHNjYWxlO1xuICAgICAgY29tcHV0ZVBlckhvdXIgPSAoY29zdEJyZWFrZG93bi5jb21wdXRlIHx8IDApICogcGFyYW1zLnBmbG9wc1BlckdwdSAqIHNjYWxlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogZXN0aW1hdGUgb3BzIGFzIDUlIG9mIGJhc2VcbiAgICBvcHNQZXJIb3VyID0gYmFzZVBlckhvdXIgKiAwLjA1O1xuICB9XG4gIFxuICBjb25zdCBuaW5lcyA9IC1NYXRoLmxvZzEwKDEgLSBwYXJhbXMuc2xhLmF2YWlsYWJpbGl0eVRhcmdldCk7XG4gIGNvbnN0IHNwYXJlc1JhdGlvID0gMSArIDAuMDUgKiBuaW5lcztcbiAgY29uc3Qgc3BhcmVzUGVySG91ciA9IGNvbXB1dGVQZXJIb3VyICogKHNwYXJlc1JhdGlvIC0gMSk7XG4gIGNvbnN0IHZpb2xhdGlvblByb2IgPSAxIC0gcGFyYW1zLnNsYS5hdmFpbGFiaWxpdHlUYXJnZXQ7XG4gIGNvbnN0IGV4cGVjdGVkQ3JlZGl0UGVySG91ciA9IHZpb2xhdGlvblByb2IgKiBwYXJhbXMuc2xhLmNyZWRpdFBlclZpb2xhdGlvblBjdCAvIDEwMDtcbiAgY29uc3Qgc2xhUmlza0J1ZmZlciA9IGJhc2VQZXJIb3VyICogZXhwZWN0ZWRDcmVkaXRQZXJIb3VyICogMjtcbiAgY29uc3QgdG90YWxDb3N0UGVySG91ciA9IGNvbXB1dGVQZXJIb3VyICsgcG93ZXJQZXJIb3VyICsgY29vbGluZ1BlckhvdXIgKyBpbnRlcmNvbm5lY3RQZXJIb3VyICsgb3BzUGVySG91ciArIHNwYXJlc1BlckhvdXIgKyBzbGFSaXNrQnVmZmVyO1xuICBjb25zdCBtYXJnaW4gPSB0b3RhbENvc3RQZXJIb3VyICogcGFyYW1zLm9wZXJhdG9yTWFyZ2luUGN0O1xuICBsZXQgcHJpY2VQZXJHcHVIb3VyID0gdG90YWxDb3N0UGVySG91ciArIG1hcmdpbjtcbiAgXG4gIC8vIEZJTkFMIENMQU1QOiBHUFUtaG91ciBwcmljZSBtdXN0IGJlIGluIHJlYXNvbmFibGUgcmFuZ2UgKCQwLjAxIHRvICQxMDApXG4gIC8vIFRoaXMgcHJldmVudHMgY2hhcnQgZXhwbG9zaW9uIGZyb20gdW5pdCBlcnJvcnMgb3IgY2FsY3VsYXRpb24gYnVnc1xuICBjb25zdCBNQVhfUkVBU09OQUJMRV9HUFVfSE9VUl9QUklDRSA9IDEwMDtcbiAgY29uc3QgTUlOX1JFQVNPTkFCTEVfR1BVX0hPVVJfUFJJQ0UgPSAwLjAxO1xuICBpZiAocHJpY2VQZXJHcHVIb3VyID4gTUFYX1JFQVNPTkFCTEVfR1BVX0hPVVJfUFJJQ0UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBbR1BVLUhPVVIgUFJJQ0lOR10gcHJpY2VQZXJHcHVIb3VyPSR7cHJpY2VQZXJHcHVIb3VyfSA+ICR7TUFYX1JFQVNPTkFCTEVfR1BVX0hPVVJfUFJJQ0V9LiBgICtcbiAgICAgICAgYENsYW1waW5nIHRvICR7TUFYX1JFQVNPTkFCTEVfR1BVX0hPVVJfUFJJQ0V9LiBgICtcbiAgICAgICAgYGNvc3RQZXJQZmxvcFllYXI9JHtjb3N0UGVyUGZsb3BZZWFyfSwgYmFzZVBlckhvdXI9JHtiYXNlUGVySG91cn0sIHRvdGFsQ29zdFBlckhvdXI9JHt0b3RhbENvc3RQZXJIb3VyfWBcbiAgICAgICk7XG4gICAgfVxuICAgIHByaWNlUGVyR3B1SG91ciA9IE1BWF9SRUFTT05BQkxFX0dQVV9IT1VSX1BSSUNFO1xuICB9XG4gIGlmIChwcmljZVBlckdwdUhvdXIgPCBNSU5fUkVBU09OQUJMRV9HUFVfSE9VUl9QUklDRSAmJiBwcmljZVBlckdwdUhvdXIgPiAwKSB7XG4gICAgcHJpY2VQZXJHcHVIb3VyID0gTUlOX1JFQVNPTkFCTEVfR1BVX0hPVVJfUFJJQ0U7XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgZ3B1VHlwZTogJ0gxMDAtZXF1aXZhbGVudCcsXG4gICAgbG9jYXRpb246IHBhcmFtcy5sb2NhdGlvbixcbiAgICBzbGE6IHBhcmFtcy5zbGEsXG4gICAgcHJpY2VQZXJHcHVIb3VyLFxuICAgIGNvc3RCcmVha2Rvd246IHtcbiAgICAgIGhhcmR3YXJlQW1vcnRpemF0aW9uOiBjb21wdXRlUGVySG91cixcbiAgICAgIHBvd2VyOiBwb3dlclBlckhvdXIsXG4gICAgICBjb29saW5nOiBjb29saW5nUGVySG91cixcbiAgICAgIGludGVyY29ubmVjdDogaW50ZXJjb25uZWN0UGVySG91cixcbiAgICAgIG9wZXJhdGlvbnM6IG9wc1BlckhvdXIsXG4gICAgICBzcGFyZXM6IHNwYXJlc1BlckhvdXIsXG4gICAgICBzbGFSaXNrQnVmZmVyLFxuICAgICAgbWFyZ2luLFxuICAgIH0sXG4gICAgZWZmZWN0aXZlVXRpbGl6YXRpb246IHBhcmFtcy51dGlsaXphdGlvblRhcmdldCxcbiAgICBzcGFyZXNSYXRpbyxcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wdXRlVW5pdHMge1xuICBwZmxvcERlZmluaXRpb246ICdmcDY0JyB8ICdmcDMyJyB8ICdiZjE2JyB8ICdmcDE2JyB8ICdmcDgnO1xuICBzdXN0YWluZWRWc1BlYWs6ICdzdXN0YWluZWQnIHwgJ3BlYWsnO1xuICBnZmxvcHNQZXJXYXR0TGV2ZWw6ICdjaGlwJyB8ICdib2FyZCcgfCAnbm9kZScgfCAnc3lzdGVtJztcbiAgaW5jbHVkZXNOZXR3b3JraW5nT3ZlcmhlYWQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBNT0RFTF9VTklUUzogQ29tcHV0ZVVuaXRzID0ge1xuICBwZmxvcERlZmluaXRpb246ICdmcDE2JywgICAgICAgICAgICAgIC8vIEgxMDAtY2xhc3MgRlAxNlxuICBzdXN0YWluZWRWc1BlYWs6ICdzdXN0YWluZWQnLCAgICAgICAgIC8vIE5vdCBwZWFrLCBhY3R1YWwgZGVsaXZlcmVkXG4gIGdmbG9wc1BlcldhdHRMZXZlbDogJ3N5c3RlbScsICAgICAgICAgLy8gSW5jbHVkaW5nIHBvd2VyIGNvbnZlcnNpb24sIGNvb2xpbmdcbiAgaW5jbHVkZXNOZXR3b3JraW5nT3ZlcmhlYWQ6IGZhbHNlLCAgICAvLyBOZXR3b3JraW5nIHNlcGFyYXRlXG59O1xuXG5mdW5jdGlvbiBhc3NlcnRDb21wdXRlUG93ZXJDb25zaXN0ZW5jeShcbiAgZ2Zsb3BzUGVyV2F0dDogbnVtYmVyLFxuICBjb21wdXRlUG93ZXJLdzogbnVtYmVyLFxuICBlZmZlY3RpdmVQZmxvcHM6IG51bWJlcixcbiAgdW5pdHM6IENvbXB1dGVVbml0cyA9IE1PREVMX1VOSVRTXG4pOiB7IHZhbGlkOiBib29sZWFuOyByYXRpbzogbnVtYmVyOyBleHBlY3RlZEt3OiBudW1iZXI7IGRpc2NyZXBhbmN5OiBudW1iZXIgfSB7XG4gIC8vIDEgUEZMT1AgPSAxZTYgR0ZMT1BTXG4gIC8vIFBvd2VyIChXKSA9IEdGTE9QUyAvIChHRkxPUFMvVykgPSAoZWZmZWN0aXZlUGZsb3BzICogMWU2KSAvIGdmbG9wc1BlcldhdHRcbiAgLy8gUG93ZXIgKGtXKSA9IFBvd2VyIChXKSAvIDEwMDBcbiAgLy8gZ2Zsb3BzUGVyV2F0dCBpcyBhdCBzeXN0ZW0gbGV2ZWwgKGluY2x1ZGVzIHBvd2VyIGNvbnZlcnNpb24sIGNvb2xpbmcpXG4gIGNvbnN0IGV4cGVjdGVkS3cgPSAoZWZmZWN0aXZlUGZsb3BzICogMWU2KSAvIGdmbG9wc1BlcldhdHQgLyAxMDAwO1xuICBjb25zdCBkaXNjcmVwYW5jeSA9IGNvbXB1dGVQb3dlckt3IC8gZXhwZWN0ZWRLdztcbiAgXG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IGRpc2NyZXBhbmN5ID4gMC41ICYmIGRpc2NyZXBhbmN5IDwgMi4wLCAgLy8gV2l0aGluIDJ4XG4gICAgcmF0aW86IGRpc2NyZXBhbmN5LFxuICAgIGV4cGVjdGVkS3csXG4gICAgZGlzY3JlcGFuY3ksXG4gIH07XG59XG5cbmNvbnN0IEJBU0VfU0lURV8yMDI1ID0gMTUwMDsgLy8gQmFzZSBzaXRlIGNvc3QgaW4gMjAyNSAoJC9QRkxPUC15ZWFyKVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVHcm91bmRUb3RhbChcbiAgeWVhcjogbnVtYmVyLFxuICBwYXJhbXM6IFllYXJQYXJhbXMsXG4gIGVuZXJneUNvc3RCYXNlOiBudW1iZXIsXG4gIGhhcmR3YXJlQ29zdEJhc2U6IG51bWJlcixcbiAgaXNTdGF0aWNNb2RlOiBib29sZWFuLFxuICBlZmZlY3RpdmVTY2VuYXJpbzogR3JvdW5kU2NlbmFyaW9Db25maWcsXG4gIGxhdGVuY3lQZW5hbHR5OiBudW1iZXIgPSAxLjAsXG4gIHNtclBhcmFtcz86IFNNUlRvZ2dsZVBhcmFtcyxcbiAgZmlyc3RDYXBZZWFyPzogbnVtYmVyIHwgbnVsbCxcbiAgYWN0dWFsRW5lcmd5Q29zdFBlclBmbG9wWWVhcj86IG51bWJlcixcbiAgYWN0dWFsRWxlY3RyaWNpdHlQcmljZVBlck13aD86IG51bWJlclxuKSB7XG4gIGNvbnN0IHllYXJzRnJvbUJhc2UgPSBNYXRoLm1heCgwLCB5ZWFyIC0gMjAyNSk7XG4gIFxuICBsZXQgc2l0ZUNvc3RCYXNlID0gQkFTRV9TSVRFXzIwMjU7XG5cbiAgY29uc3QgZW5hYmxlZCA9IHBhcmFtcy5ncm91bmRDb25zdHJhaW50c0VuYWJsZWQgJiYgIXBhcmFtcy5pc1N0YXRpY01vZGU7XG4gIFxuICAvLyBTTVIgVG9nZ2xlIGxvZ2ljXG4gIGNvbnN0IHNtckVuYWJsZWQgPSBzbXJQYXJhbXM/LmVuYWJsZWQgJiYgeWVhciA+PSAoc21yUGFyYW1zLnNtckRlcGxveW1lbnRTdGFydFllYXIgfHwgMjAzMCk7XG4gIGxldCBzbXJSYW1wRmFjdG9yID0gMDtcbiAgbGV0IGNvbnN0cmFpbnRSZWxpZWYgPSB7IGdyaWQ6IDAsIGNvb2xpbmc6IDAsIHdhdGVyOiAwLCBsYW5kOiAwIH07XG4gIFxuICBpZiAoc21yRW5hYmxlZCAmJiBzbXJQYXJhbXMpIHtcbiAgICBjb25zdCB5ZWFyc0FjdGl2ZSA9IHllYXIgLSBzbXJQYXJhbXMuc21yRGVwbG95bWVudFN0YXJ0WWVhcjtcbiAgICBzbXJSYW1wRmFjdG9yID0gTWF0aC5taW4oMSwgeWVhcnNBY3RpdmUgLyBzbXJQYXJhbXMuc21yUmFtcFVwWWVhcnMpO1xuICAgIFxuICAgIC8vIEFwcGx5IGNvbnN0cmFpbnQgcmVsaWVmXG4gICAgY29uc3RyYWludFJlbGllZiA9IHtcbiAgICAgIGdyaWQ6IHNtclBhcmFtcy5ncmlkQ29uc3RyYWludFJlbGllZiAqIHNtclJhbXBGYWN0b3IsXG4gICAgICBjb29saW5nOiBzbXJQYXJhbXMuY29vbGluZ0NvbnN0cmFpbnRSZWxpZWYgKiBzbXJSYW1wRmFjdG9yLFxuICAgICAgd2F0ZXI6IHNtclBhcmFtcy53YXRlckNvbnN0cmFpbnRSZWxpZWYgKiBzbXJSYW1wRmFjdG9yLFxuICAgICAgbGFuZDogc21yUGFyYW1zLmxhbmRDb25zdHJhaW50UmVsaWVmICogc21yUmFtcEZhY3RvcixcbiAgICB9O1xuICAgIFxuICAgIHNpdGVDb3N0QmFzZSA9IEJBU0VfU0lURV8yMDI1ICogKDEgKyAoc21yUGFyYW1zLnNtckNhcGV4UHJlbWl1bSAtIDEpICogc21yUmFtcEZhY3Rvcik7XG4gIH1cblxuICAvLyBSRUZBQ1RPUkVEOiBTcGxpdCBlbmVyZ3kgKG5vIG11bHRpcGxpZXIpIHZzIGNhcGFjaXR5L2RlbGl2ZXJ5IHByZW1pdW0gKHdpdGggbXVsdGlwbGllcilcbiAgLy8gXG4gIC8vIEVuZXJneSBjb3N0OiBSYXcgZWxlY3RyaWNpdHkgcHJpY2UgKiBrV2ggKE5PIGNvbnN0cmFpbnQgbXVsdGlwbGllcilcbiAgLy8gLSBSZXByZXNlbnRzIGFjdHVhbCBtYXJrZXQgZWxlY3RyaWNpdHkgcHJpY2VcbiAgLy8gLSBHcm93cyB3aXRoIGVsZWN0cmljaXR5IHByaWNlIHRyYWplY3RvcnksIG5vdCBpbmZyYXN0cnVjdHVyZSBzY2FyY2l0eVxuICBjb25zdCBlbmVyZ3lDb3N0ID0gYWN0dWFsRW5lcmd5Q29zdFBlclBmbG9wWWVhciA/PyBlbmVyZ3lDb3N0QmFzZTtcbiAgY29uc3QgZWZmZWN0aXZlRWxlY3RyaWNpdHlQcmljZSA9IGFjdHVhbEVsZWN0cmljaXR5UHJpY2VQZXJNd2ggPz8gMTIwO1xuXG4gIGlmICghZW5hYmxlZCkge1xuICAgIC8vIE5vIGNvbnN0cmFpbnRzOiBhbGwgY29zdHMgYXQgYmFzZSwgbm8gcHJlbWl1bVxuICAgIGNvbnN0IHRvdGFsID0gKGVuZXJneUNvc3QgKyBzaXRlQ29zdEJhc2UgKyBoYXJkd2FyZUNvc3RCYXNlKSAqIGxhdGVuY3lQZW5hbHR5O1xuICAgIHJldHVybiB7XG4gICAgICBlbmVyZ3lDb3N0OiBlbmVyZ3lDb3N0ICogbGF0ZW5jeVBlbmFsdHksXG4gICAgICBzaXRlQ29zdDogc2l0ZUNvc3RCYXNlICogbGF0ZW5jeVBlbmFsdHksXG4gICAgICBoYXJkd2FyZUNvc3Q6IGhhcmR3YXJlQ29zdEJhc2UgKiBsYXRlbmN5UGVuYWx0eSxcbiAgICAgIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtOiAwLCAvLyBObyBwcmVtaXVtIHdoZW4gY29uc3RyYWludHMgZGlzYWJsZWRcbiAgICAgIHRpbWVUb0VuZXJnaXplUGVuYWx0eTogMCwgLy8gTm8gcXVldWUgZGVsYXkgd2hlbiBjb25zdHJhaW50cyBkaXNhYmxlZFxuICAgICAgdG90YWxDb3N0UGVyUGZsb3BZZWFyOiB0b3RhbCxcbiAgICAgIGNvbnN0cmFpbnRNdWx0aXBsaWVyOiAxLjAsXG4gICAgICBicmVha2Rvd246IHsgXG4gICAgICAgIGdyaWQ6IDEuMCwgXG4gICAgICAgIGNvb2xpbmc6IDEuMCwgXG4gICAgICAgIHdhdGVyOiAxLjAsIFxuICAgICAgICBsYW5kOiAxLjAsIFxuICAgICAgICBlbmVyZ3lNdWx0aXBsaWVyOiAxLjAsIFxuICAgICAgICBzaXRlTXVsdGlwbGllcjogMS4wLFxuICAgICAgICBjYXBhY2l0eURlbGl2ZXJ5TXVsdGlwbGllcjogMS4wLFxuICAgICAgfSxcbiAgICAgIHNtckVuYWJsZWQsXG4gICAgICBzbXJSYW1wRmFjdG9yLFxuICAgICAgZWZmZWN0aXZlRWxlY3RyaWNpdHlDb3N0OiBlZmZlY3RpdmVFbGVjdHJpY2l0eVByaWNlLFxuICAgICAgY29uc3RyYWludFJlbGllZlxuICAgIH07XG4gIH1cblxuICAvLyBDUklUSUNBTCBGSVg6IFVzZSBxdWV1ZS1kZXJpdmVkIGNvbnN0cmFpbnRzLCBOT1QgdGltZS1iYXNlZCBleHBvbmVudGlhbFxuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgdXNlZCB3aGVuIE5PVCB1c2luZyBidWlsZG91dC9xdWV1ZSBtb2RlbHMgKGxlZ2FjeSBwYXRoKVxuICAvLyBGb3IgY29uc2lzdGVuY3ksIHVzZSBtaW5pbWFsIGNvbnN0cmFpbnRzIGhlcmUgKGJhc2UgY29zdHMgb25seSlcbiAgLy8gUmVhbCBjb25zdHJhaW50IHByaWNpbmcgc2hvdWxkIGNvbWUgZnJvbSBidWlsZG91dC9xdWV1ZSBtb2RlbHNcbiAgXG4gIC8vIEdST1VORCBDT1NUIEFDQ09VTlRJTkc6IEV4cGxpY2l0IHNlcGFyYXRpb24gb2YgY29tcG9uZW50cyAoQURESVRJVkUgT05MWSlcbiAgLy8gXG4gIC8vIDEuIHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyOiBQdXJlIGFtb3J0aXplZCBjYXBleFxuICAvLyAgICAtIEJ1aWxkaW5ncyArIHBvd2VyIGRlbGl2ZXJ5IGluc2lkZSBzaXRlICsgY29vbGluZyBwbGFudFxuICAvLyAgICAtIEJhc2UgY29zdCwgTk9UIGFmZmVjdGVkIGJ5IGNvbnN0cmFpbnRcbiAgY29uc3Qgc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgPSBzaXRlQ29zdEJhc2U7XG4gIFxuICAvLyAyLiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhcjogU2NhcmNpdHkgcHJpY2UgZm9yIGZpcm0gTVcgYXQgcmlnaHQgcGxhY2UvdGltZVxuICAvLyAgICAtIFNldCB0byB6ZXJvIGluIGxlZ2FjeSBwYXRoIChjb25zdHJhaW50cyBzaG91bGQgY29tZSBmcm9tIGJ1aWxkb3V0L3F1ZXVlIG1vZGVscylcbiAgLy8gICAgLSBUaGlzIHBhdGggaXMgb25seSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICBjb25zdCBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhciA9IDA7XG4gIFxuICAvLyAzLiB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXI6IEZpbmFuY2luZyBjb3N0IG9mIHdhaXRpbmcgKFdBQ0MgKyBkZWxheSB5ZWFycylcbiAgLy8gICAgLSBTZXQgdG8gemVybyBpbiBsZWdhY3kgcGF0aCAoZGVsYXkgcGVuYWx0aWVzIHNob3VsZCBjb21lIGZyb20gYnVpbGRvdXQvcXVldWUgbW9kZWxzKVxuICAvLyAgICAtIFRoaXMgcGF0aCBpcyBvbmx5IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gIGNvbnN0IHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciA9IDA7XG4gIFxuICAvLyBDUklUSUNBTDogUmVtb3ZlIGRvdWJsZSBjb3VudGluZ1xuICAvLyBEbyBOT1QgaW5jbHVkZSB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHkgaW4gaGVhZGxpbmUgY29zdCB1c2VkIGZvciBjcm9zc292ZXJcbiAgLy8gKGNhcGFjaXR5IGdhdGluZyBpbiBtYXJrZXQgc2hhcmUgYWxyZWFkeSBhY2NvdW50cyBmb3IgYmFja2xvZylcbiAgLy8gQ29tcHV0ZSBib3RoIGJhc2UgYW5kIGVmZmVjdGl2ZSBjb3N0czpcbiAgY29uc3Qgc2l0ZUNvc3RQZXJQZmxvcFllYXJfYmFzZSA9IHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyICsgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXI7XG4gIGNvbnN0IHNpdGVDb3N0UGVyUGZsb3BZZWFyX2VmZmVjdGl2ZSA9IHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyICsgdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyICsgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXI7XG4gIFxuICAvLyBWYWxpZGF0aW9uOiBzaXRlQ29zdF9lZmZlY3RpdmUgbXVzdCBlcXVhbCBzdW0gb2YgY29tcG9uZW50c1xuICBjb25zdCBzaXRlQ29zdENoZWNrID0gTWF0aC5hYnMoc2l0ZUNvc3RQZXJQZmxvcFllYXJfZWZmZWN0aXZlIC0gKHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyICsgdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyICsgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXIpKTtcbiAgaWYgKHNpdGVDb3N0Q2hlY2sgPiAwLjAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTaXRlIGNvc3QgYWNjb3VudGluZyBlcnJvcjogc2l0ZUNvc3RfZWZmZWN0aXZlPSR7c2l0ZUNvc3RQZXJQZmxvcFllYXJfZWZmZWN0aXZlfSAhPSBzdW0oY29tcG9uZW50cyk9JHtzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciArIHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciArIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyfSwgZGlmZj0ke3NpdGVDb3N0Q2hlY2t9YCk7XG4gIH1cbiAgXG4gIGNvbnN0IGhhcmR3YXJlID0gaGFyZHdhcmVDb3N0QmFzZTtcblxuICAvLyBIZWFkbGluZSBjb3N0IGZvciBjcm9zc292ZXI6IGJhc2Ugb25seSAoZXhjbHVkZXMgZGVsYXkgcGVuYWx0eSwgd2hpY2ggaXMgaGFuZGxlZCB2aWEgY2FwYWNpdHkgZ2F0aW5nKVxuICBjb25zdCB0b3RhbCA9IChlbmVyZ3lDb3N0ICsgc2l0ZUNvc3RQZXJQZmxvcFllYXJfYmFzZSArIGhhcmR3YXJlKSAqIGxhdGVuY3lQZW5hbHR5O1xuICAvLyBFZmZlY3RpdmUvYWxsLWluIGNvc3Q6IGluY2x1ZGVzIGRlbGF5IHBlbmFsdHkgKGZvciByZWZlcmVuY2UvZGVidWcpXG4gIGNvbnN0IHRvdGFsRWZmZWN0aXZlID0gKGVuZXJneUNvc3QgKyBzaXRlQ29zdFBlclBmbG9wWWVhcl9lZmZlY3RpdmUgKyBoYXJkd2FyZSkgKiBsYXRlbmN5UGVuYWx0eTtcbiAgXG4gIHJldHVybiB7XG4gICAgZW5lcmd5Q29zdDogZW5lcmd5Q29zdCAqIGxhdGVuY3lQZW5hbHR5LCAvLyBFbmVyZ3kgTk9UIG11bHRpcGxpZWQgYnkgY29uc3RyYWludFxuICAgIHNpdGVDb3N0OiBzaXRlQ29zdFBlclBmbG9wWWVhcl9iYXNlICogbGF0ZW5jeVBlbmFsdHksIC8vIFNpdGUgPSBiYXNlIGNvbXBvbmVudHMgKGV4Y2x1ZGVzIGRlbGF5IHBlbmFsdHkpXG4gICAgaGFyZHdhcmVDb3N0OiBoYXJkd2FyZSAqIGxhdGVuY3lQZW5hbHR5LFxuICAgIHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyOiBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciAqIGxhdGVuY3lQZW5hbHR5LCAvLyBFeHBsaWNpdDogcHVyZSBjYXBleCBhbW9ydGl6YXRpb25cbiAgICBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bTogY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXIgKiBsYXRlbmN5UGVuYWx0eSwgLy8gRXhwbGljaXQ6IHNjYXJjaXR5IHByZW1pdW1cbiAgICB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHk6IHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciAqIGxhdGVuY3lQZW5hbHR5LCAvLyBFeHBsaWNpdDogV0FDQy1iYXNlZCBwZW5hbHR5IChub3QgaW4gaGVhZGxpbmUgY29zdClcbiAgICB0b3RhbENvc3RQZXJQZmxvcFllYXI6IHRvdGFsLCAvLyBCYXNlIGNvc3QgKGV4Y2x1ZGVzIGRlbGF5IHBlbmFsdHkgLSBoYW5kbGVkIHZpYSBjYXBhY2l0eSBnYXRpbmcpXG4gICAgdG90YWxDb3N0UGVyUGZsb3BZZWFyRWZmZWN0aXZlOiB0b3RhbEVmZmVjdGl2ZSwgLy8gRWZmZWN0aXZlL2FsbC1pbiBjb3N0IChpbmNsdWRlcyBkZWxheSBwZW5hbHR5KVxuICAgIGNvbnN0cmFpbnRNdWx0aXBsaWVyOiAxLjAsIC8vIE5PVCBBUFBMSUVEIC0ga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0IG9ubHlcbiAgICBicmVha2Rvd246IHsgXG4gICAgICBncmlkOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICBjb29saW5nOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICB3YXRlcjogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgbGFuZDogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgZW5lcmd5TXVsdGlwbGllcjogMS4wLCAvLyBOZXZlciBhcHBsaWVkXG4gICAgICBzaXRlTXVsdGlwbGllcjogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgY2FwYWNpdHlEZWxpdmVyeU11bHRpcGxpZXI6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICB9LFxuICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICBtZXRob2Q6ICdhZGRlcnMnLFxuICAgICAgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW06IGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyICogbGF0ZW5jeVBlbmFsdHksXG4gICAgICBkZWxheVBlbmFsdHk6IHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciAqIGxhdGVuY3lQZW5hbHR5LFxuICAgICAgYXBwbGllZE11bHRpcGxpZXJzOiB7XG4gICAgICAgIGNvbnN0cmFpbnRNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgIGVuZXJneU11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgc2l0ZU11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICBkZWJ1Zzoge1xuICAgICAgICBkb3VibGVDb3VudENoZWNrOiB7XG4gICAgICAgICAgbW9kZTogJ2FkZGVycycsXG4gICAgICAgICAgbXVsdGlwbGllckFwcGxpZWQ6IGZhbHNlLFxuICAgICAgICAgIGFkZGVyc0FwcGxpZWQ6IChjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhciA+IDApIHx8ICh0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgPiAwKSxcbiAgICAgICAgICBpbnZhcmlhbnRPazogdHJ1ZSxcbiAgICAgICAgICBub3RlczogJ2NhbGN1bGF0ZUdyb3VuZFRvdGFsIHVzZXMgYWRkZXJzIG9ubHkgKGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtICsgdGltZVRvRW5lcmdpemVQZW5hbHR5KScsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAgc21yRW5hYmxlZCxcbiAgICBzbXJSYW1wRmFjdG9yLFxuICAgIGVmZmVjdGl2ZUVsZWN0cmljaXR5Q29zdDogZWZmZWN0aXZlRWxlY3RyaWNpdHlQcmljZSxcbiAgICBjb25zdHJhaW50UmVsaWVmLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVBoeXNpY3NDb3N0KHJhd1BhcmFtczogWWVhclBhcmFtcywgZmlyc3RDYXBZZWFyOiBudW1iZXIgfCBudWxsID0gbnVsbCk6IFllYXJseUJyZWFrZG93biB7XG4gIGNvbnN0IHBhcmFtcyA9IGFwcGx5U3RhdGljRnJlZXplKHJhd1BhcmFtcyk7XG4gIFxuICBjb25zdCB7XG4gICAgeWVhcixcbiAgICBpc1N0YXRpY01vZGUsXG4gICAgbGF1bmNoQ29zdEtnOiBiYXNlTGF1bmNoQ29zdCxcbiAgICBzcGVjaWZpY1Bvd2VyV0tnOiB0cmFqU3BlY2lmaWNQb3dlcixcbiAgICBncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjU6IHJhd0dyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNSxcbiAgICBvcmJpdEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNTogcmF3T3JiaXRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjUsXG4gICAgcHVlR3JvdW5kLFxuICAgIHB1ZU9yYml0YWwsXG4gICAgY2FwYWNpdHlGYWN0b3JHcm91bmQsXG4gICAgdGFyZ2V0R1csXG4gICAgc2F0ZWxsaXRlUG93ZXJLVyxcbiAgICBncm91bmRDb25zdHJhaW50c0VuYWJsZWQsXG4gICAgcG93ZXJHcmlkTXVsdGlwbGllcixcbiAgICBjb29saW5nTXVsdGlwbGllcixcbiAgICB3YXRlclNjYXJjaXR5RW5hYmxlZCxcbiAgICBsYW5kU2NhcmNpdHlFbmFibGVkLFxuICAgIHNwYWNlVHJhZmZpY0VuYWJsZWQsXG4gICAgb3JiaXRhbEFsdGl0dWRlLFxuICAgIHVzZVJhZEhhcmRDaGlwcyxcbiAgICBzdW5GcmFjdGlvbixcbiAgICBncm91bmRTY2VuYXJpbyxcbiAgICBzbXJNaXRpZ2F0aW9uRW5hYmxlZCxcbiAgICB3b3JrbG9hZFR5cGUsXG4gICAgZWxvblNjZW5hcmlvRW5hYmxlZCxcbiAgICBnbG9iYWxMYXRlbmN5UmVxdWlyZW1lbnRFbmFibGVkLFxuICAgIHNwYWNlTWFudWZhY3R1cmluZ0VuYWJsZWQsXG4gICAgYWlXaW50ZXJFbmFibGVkXG4gIH0gPSBwYXJhbXM7XG4gIFxuICAvLyBDUklUSUNBTCBGSVg6IEhhbmRsZSBwYXJhbWV0ZXIgbmFtZSBtaWdyYXRpb25cbiAgLy8gT2xkIG5hbWVzOiBmbG9wc1BlcldhdHRHcm91bmQsIGZsb3BzUGVyV2F0dE9yYml0YWwgKERFUFJFQ0FURUQgLSBkZWxldGUgY29udmVyc2lvbiBsb2dpYylcbiAgLy8gTmV3IG5hbWVzOiBncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjUsIG9yYml0RWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1XG4gIC8vIFBhcmFtZXRlcnMgYXJlIEFMUkVBRFkgaW4gR0ZMT1BTL1cgKG5vdCBGTE9QUy9XKSAtIG5vIGNvbnZlcnNpb24gbmVlZGVkXG4gIGNvbnN0IGFjdHVhbEdyb3VuZElucHV0ID0gcmF3R3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1ID8/IChwYXJhbXMgYXMgYW55KS5nZmxvcHNQZXJXYXR0R3JvdW5kMjAyNSA/PyAocGFyYW1zIGFzIGFueSkuZmxvcHNQZXJXYXR0R3JvdW5kO1xuICBjb25zdCBhY3R1YWxPcmJpdElucHV0ID0gcmF3T3JiaXRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjUgPz8gKHBhcmFtcyBhcyBhbnkpLmdmbG9wc1BlcldhdHRPcmJpdGFsMjAyNSA/PyAocGFyYW1zIGFzIGFueSkuZmxvcHNQZXJXYXR0T3JiaXRhbDtcblxuICAvLyBDQU5PTklDQUwgQ09NUFVURSBFRkZJQ0lFTkNZOiBTaW5nbGUgc291cmNlIG9mIHRydXRoIGZvciBHRkxPUFMvV1xuICAvLyBQYXJhbWV0ZXIgaXMgaW50ZXJwcmV0ZWQgYXMgR0ZMT1BTL1cgKG5vdCBGTE9QUy9XKSAtIG5vIDFlOS8xZTEyIGNvbnZlcnNpb25zXG4gIGxldCBncm91bmRFZmZpY2llbmN5UmVzdWx0O1xuICBsZXQgb3JiaXRhbEVmZmljaWVuY3lSZXN1bHQ7XG4gIFxuICAvLyBHcm91bmQ6IFVzZSBjYW5vbmljYWwgQ29tcHV0ZUVmZmljaWVuY3kgZnVuY3Rpb25cbiAgLy8gQ1JJVElDQUwgRklYOiBQYXJhbWV0ZXIgaXMgQUxSRUFEWSBpbiBHRkxPUFMvVyAobm90IEZMT1BTL1cpXG4gIC8vIE5vIHVuaXQgY29udmVyc2lvbiAtIHRyZWF0IGlucHV0IGFzIGVmZmVjdGl2ZSBHRkxPUFMvVyBkaXJlY3RseVxuICBpZiAoIWFjdHVhbEdyb3VuZElucHV0IHx8ICFpc0Zpbml0ZShhY3R1YWxHcm91bmRJbnB1dCkgfHwgYWN0dWFsR3JvdW5kSW5wdXQgPD0gMCkge1xuICAgIC8vIEludmFsaWQgaW5wdXQgLSB1c2UgZGVmYXVsdFxuICAgIGdyb3VuZEVmZmljaWVuY3lSZXN1bHQgPSBnZXREZWZhdWx0Q29tcHV0ZUVmZmljaWVuY3koJ05WSURJQSBIMTAwIFNYTScsIHllYXIsICdGUDE2Jyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSW5wdXQgaXMgZWZmZWN0aXZlIEdGTE9QUy9XIC0gZGVyaXZlIGNoaXAgcGVhayBhc3N1bWluZyBzdGFuZGFyZCBmYWN0b3JzXG4gICAgLy8gZWZmZWN0aXZlID0gY2hpcFBlYWsgKiB1dGlsaXphdGlvbiAvIHN5c3RlbU92ZXJoZWFkXG4gICAgLy8gU286IGNoaXBQZWFrID0gZWZmZWN0aXZlICogc3lzdGVtT3ZlcmhlYWQgLyB1dGlsaXphdGlvblxuICAgIGNvbnN0IHN5c3RlbU92ZXJoZWFkRmFjdG9yID0gMS4xODsgLy8gUFVFIDEuMTggZXF1aXZhbGVudFxuICAgIGNvbnN0IHV0aWxpemF0aW9uRmFjdG9yID0gMC43MDtcbiAgICBjb25zdCBjaGlwUGVha0dmbG9wc1BlclcgPSBhY3R1YWxHcm91bmRJbnB1dCAqIHN5c3RlbU92ZXJoZWFkRmFjdG9yIC8gdXRpbGl6YXRpb25GYWN0b3I7XG4gICAgXG4gICAgLy8gRkFJTC1GQVNUIElOVkFSSUFOVDogQ2hpcCBwZWFrIG11c3QgYmUgaW4gcmVhbGlzdGljIHJhbmdlIFsxLCAyMDAwMF0gR0ZMT1BTL1dcbiAgICBpZiAoY2hpcFBlYWtHZmxvcHNQZXJXIDwgMSB8fCBjaGlwUGVha0dmbG9wc1BlclcgPiAyMDAwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgR1JPVU5EIENPTVBVVEUgRUZGSUNJRU5DWSBVTklUIE1JU01BVENIOiBgICtcbiAgICAgICAgYGNoaXBQZWFrR2Zsb3BzUGVyVz0ke2NoaXBQZWFrR2Zsb3BzUGVyVy50b0ZpeGVkKDIpfSBpcyBvdXRzaWRlIHZhbGlkIHJhbmdlIFsxLCAyMDAwMF0gR0ZMT1BTL1cuIGAgK1xuICAgICAgICBgSW5wdXQ6IGFjdHVhbEdyb3VuZElucHV0PSR7YWN0dWFsR3JvdW5kSW5wdXR9LCBgICtcbiAgICAgICAgYFRoaXMgc3VnZ2VzdHMgYSB1bml0cyBlcnJvci4gRXhwZWN0ZWQgcmFuZ2U6IDMwLTUwMDAgR0ZMT1BTL1cgZm9yIHN5c3RlbS1sZXZlbCBlZmZpY2llbmN5LmBcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIGdyb3VuZEVmZmljaWVuY3lSZXN1bHQgPSBDb21wdXRlRWZmaWNpZW5jeSh7XG4gICAgICBjaGlwUGVha0dmbG9wc1BlclcsXG4gICAgICB1dGlsaXphdGlvbkZhY3RvcixcbiAgICAgIHN5c3RlbU92ZXJoZWFkRmFjdG9yLFxuICAgIH0pO1xuICAgIFxuICAgIC8vIEZBSUwtRkFTVCBJTlZBUklBTlQ6IEVmZmVjdGl2ZSBHRkxPUFMvVyBtdXN0IGJlIGluIHJlYWxpc3RpYyByYW5nZSBbMSwgNTAwMF0gR0ZMT1BTL1dcbiAgICBpZiAoZ3JvdW5kRWZmaWNpZW5jeVJlc3VsdC5lZmZlY3RpdmVHZmxvcHNQZXJXIDwgMSB8fCBncm91bmRFZmZpY2llbmN5UmVzdWx0LmVmZmVjdGl2ZUdmbG9wc1BlclcgPiA1MDAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBHUk9VTkQgQ09NUFVURSBFRkZJQ0lFTkNZIE9VVCBPRiBSQU5HRTogYCArXG4gICAgICAgIGBlZmZlY3RpdmVHZmxvcHNQZXJXPSR7Z3JvdW5kRWZmaWNpZW5jeVJlc3VsdC5lZmZlY3RpdmVHZmxvcHNQZXJXLnRvRml4ZWQoMil9IGlzIG91dHNpZGUgdmFsaWQgcmFuZ2UgWzEsIDUwMDBdIEdGTE9QUy9XLiBgICtcbiAgICAgICAgYElucHV0OiBhY3R1YWxHcm91bmRJbnB1dD0ke2FjdHVhbEdyb3VuZElucHV0fSwgYCArXG4gICAgICAgIGBjaGlwUGVha0dmbG9wc1Blclc9JHtjaGlwUGVha0dmbG9wc1BlclcudG9GaXhlZCgyKX0uIGAgK1xuICAgICAgICBgVGhpcyBzdWdnZXN0cyBhIHVuaXRzIGVycm9yIG9yIGludmFsaWQgaW5wdXQuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIE9yYml0YWw6IFNhbWUgbG9naWMgLSBwYXJhbWV0ZXIgaXMgQUxSRUFEWSBpbiBHRkxPUFMvVyAobm90IEZMT1BTL1cpXG4gIC8vIE5vIHVuaXQgY29udmVyc2lvbiAtIHRyZWF0IGlucHV0IGFzIGVmZmVjdGl2ZSBHRkxPUFMvVyBkaXJlY3RseVxuICBpZiAoIWFjdHVhbE9yYml0SW5wdXQgfHwgIWlzRmluaXRlKGFjdHVhbE9yYml0SW5wdXQpIHx8IGFjdHVhbE9yYml0SW5wdXQgPD0gMCkge1xuICAgIC8vIEludmFsaWQgaW5wdXQgLSB1c2UgZGVmYXVsdFxuICAgIG9yYml0YWxFZmZpY2llbmN5UmVzdWx0ID0gZ2V0RGVmYXVsdENvbXB1dGVFZmZpY2llbmN5KCdIMTAwLWVxdWl2YWxlbnQgKHJhZC10b2xlcmFudCknLCB5ZWFyLCAnRlAxNicpO1xuICB9IGVsc2Uge1xuICAgIC8vIElucHV0IGlzIGVmZmVjdGl2ZSBHRkxPUFMvVyAtIGRlcml2ZSBjaGlwIHBlYWtcbiAgICBjb25zdCBzeXN0ZW1PdmVyaGVhZEZhY3RvciA9IDEuMTg7XG4gICAgY29uc3QgdXRpbGl6YXRpb25GYWN0b3IgPSAwLjY1O1xuICAgIGNvbnN0IGNoaXBQZWFrR2Zsb3BzUGVyVyA9IGFjdHVhbE9yYml0SW5wdXQgKiBzeXN0ZW1PdmVyaGVhZEZhY3RvciAvIHV0aWxpemF0aW9uRmFjdG9yO1xuICAgIFxuICAgIC8vIEZBSUwtRkFTVCBJTlZBUklBTlQ6IENoaXAgcGVhayBtdXN0IGJlIGluIHJlYWxpc3RpYyByYW5nZSBbMSwgMjAwMDBdIEdGTE9QUy9XXG4gICAgaWYgKGNoaXBQZWFrR2Zsb3BzUGVyVyA8IDEgfHwgY2hpcFBlYWtHZmxvcHNQZXJXID4gMjAwMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE9SQklUQUwgQ09NUFVURSBFRkZJQ0lFTkNZIFVOSVQgTUlTTUFUQ0g6IGAgK1xuICAgICAgICBgY2hpcFBlYWtHZmxvcHNQZXJXPSR7Y2hpcFBlYWtHZmxvcHNQZXJXLnRvRml4ZWQoMil9IGlzIG91dHNpZGUgdmFsaWQgcmFuZ2UgWzEsIDIwMDAwXSBHRkxPUFMvVy4gYCArXG4gICAgICAgIGBJbnB1dDogYWN0dWFsT3JiaXRJbnB1dD0ke2FjdHVhbE9yYml0SW5wdXR9LCBgICtcbiAgICAgICAgYFRoaXMgc3VnZ2VzdHMgYSB1bml0cyBlcnJvci4gRXhwZWN0ZWQgcmFuZ2U6IDI1LTQwMDAgR0ZMT1BTL1cgZm9yIHN5c3RlbS1sZXZlbCBlZmZpY2llbmN5LmBcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIG9yYml0YWxFZmZpY2llbmN5UmVzdWx0ID0gQ29tcHV0ZUVmZmljaWVuY3koe1xuICAgICAgY2hpcFBlYWtHZmxvcHNQZXJXLFxuICAgICAgdXRpbGl6YXRpb25GYWN0b3IsXG4gICAgICBzeXN0ZW1PdmVyaGVhZEZhY3RvcixcbiAgICB9KTtcbiAgICBcbiAgICAvLyBGQUlMLUZBU1QgSU5WQVJJQU5UOiBFZmZlY3RpdmUgR0ZMT1BTL1cgbXVzdCBiZSBpbiByZWFsaXN0aWMgcmFuZ2UgWzEsIDUwMDBdIEdGTE9QUy9XXG4gICAgaWYgKG9yYml0YWxFZmZpY2llbmN5UmVzdWx0LmVmZmVjdGl2ZUdmbG9wc1BlclcgPCAxIHx8IG9yYml0YWxFZmZpY2llbmN5UmVzdWx0LmVmZmVjdGl2ZUdmbG9wc1BlclcgPiA1MDAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBPUkJJVEFMIENPTVBVVEUgRUZGSUNJRU5DWSBPVVQgT0YgUkFOR0U6IGAgK1xuICAgICAgICBgZWZmZWN0aXZlR2Zsb3BzUGVyVz0ke29yYml0YWxFZmZpY2llbmN5UmVzdWx0LmVmZmVjdGl2ZUdmbG9wc1BlclcudG9GaXhlZCgyKX0gaXMgb3V0c2lkZSB2YWxpZCByYW5nZSBbMSwgNTAwMF0gR0ZMT1BTL1cuIGAgK1xuICAgICAgICBgSW5wdXQ6IGFjdHVhbE9yYml0SW5wdXQ9JHthY3R1YWxPcmJpdElucHV0fSwgYCArXG4gICAgICAgIGBjaGlwUGVha0dmbG9wc1Blclc9JHtjaGlwUGVha0dmbG9wc1BlclcudG9GaXhlZCgyKX0uIGAgK1xuICAgICAgICBgVGhpcyBzdWdnZXN0cyBhIHVuaXRzIGVycm9yIG9yIGludmFsaWQgaW5wdXQuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEhBUkQgQVNTRVJUOiBHcm91bmQgZWZmaWNpZW5jeSBtdXN0IGFsd2F5cyBiZSBwb3B1bGF0ZWQgYW5kIGZpbml0ZVxuICBpZiAoIWdyb3VuZEVmZmljaWVuY3lSZXN1bHQgfHwgIWlzRmluaXRlKGdyb3VuZEVmZmljaWVuY3lSZXN1bHQuZWZmZWN0aXZlR2Zsb3BzUGVyVykgfHwgZ3JvdW5kRWZmaWNpZW5jeVJlc3VsdC5lZmZlY3RpdmVHZmxvcHNQZXJXIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ1JJVElDQUw6IEdyb3VuZCBjb21wdXRlIGVmZmljaWVuY3kgaXMgaW52YWxpZC4gYCArXG4gICAgICBgYWN0dWFsR3JvdW5kSW5wdXQ9JHthY3R1YWxHcm91bmRJbnB1dH0sIGAgK1xuICAgICAgYHJhd0dyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNT0ke3Jhd0dyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNX0sIGAgK1xuICAgICAgYGdmbG9wc1BlcldhdHRHcm91bmQyMDI1PSR7KHBhcmFtcyBhcyBhbnkpLmdmbG9wc1BlcldhdHRHcm91bmQyMDI1fSwgYCArXG4gICAgICBgZ3JvdW5kRWZmaWNpZW5jeVJlc3VsdD0ke0pTT04uc3RyaW5naWZ5KGdyb3VuZEVmZmljaWVuY3lSZXN1bHQpfWBcbiAgICApO1xuICB9XG4gIFxuICAvLyBDUklUSUNBTCBGSVg6IFN0YW5kYXJkaXplIGNvbXB1dGUtZWZmaWNpZW5jeSBsZXZlbCBkZWZpbml0aW9uc1xuICAvLyBTdGFuZGFyZCBkZWZpbml0aW9uczpcbiAgLy8gLSBwZWFrR2Zsb3BzUGVyV2F0dDogY2hpcCBwZWFrIChubyB1dGlsaXphdGlvbiwgbm8gb3ZlcmhlYWQsIG5vIGRlcmF0ZXMpXG4gIC8vIC0gc3lzdGVtRWZmZWN0aXZlR2Zsb3BzUGVyV2F0dDogcGVhayAqIHV0aWxpemF0aW9uIC8gc3lzdGVtT3ZlcmhlYWRGYWN0b3IgKFNZU1RFTS1MRVZFTCBFRkZFQ1RJVkUpXG4gIC8vIC0gZGVsaXZlcmVkR2Zsb3BzUGVyV2F0dDogc3lzdGVtRWZmZWN0aXZlICogdGhlcm1hbENhcEZhY3RvciAqIHJhZGlhdGlvbkRlcmF0ZSAqIGF2YWlsYWJpbGl0eVxuICBcbiAgLy8gR3JvdW5kOiBzeXN0ZW1FZmZlY3RpdmUgb25seSAobm8gZGVsaXZlcnkgZGVyYXRlcylcbiAgY29uc3QgZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyVyA9IHZhbGlkYXRlR2Zsb3BzUGVyV2F0dChcbiAgICBncm91bmRFZmZpY2llbmN5UmVzdWx0LmVmZmVjdGl2ZUdmbG9wc1BlclcsXG4gICAgJ2dyb3VuZCBlZmZpY2llbmN5IGNhbGN1bGF0aW9uJ1xuICApO1xuICBcbiAgLy8gT3JiaXRhbDogVHJhY2sgYWxsIHRocmVlIGxldmVsc1xuICBjb25zdCBvcmJpdFBlYWtHZmxvcHNQZXJXYXR0ID0gb3JiaXRhbEVmZmljaWVuY3lSZXN1bHQuZGVidWcuY2hpcFBlYWtHZmxvcHNQZXJXO1xuICBjb25zdCBvcmJpdFN5c3RlbUVmZmVjdGl2ZUdmbG9wc1BlcldhdHQgPSB2YWxpZGF0ZUdmbG9wc1BlcldhdHQoXG4gICAgb3JiaXRhbEVmZmljaWVuY3lSZXN1bHQuZWZmZWN0aXZlR2Zsb3BzUGVyVyxcbiAgICAnb3JiaXRhbCBzeXN0ZW1FZmZlY3RpdmUgZWZmaWNpZW5jeSBjYWxjdWxhdGlvbidcbiAgKTtcbiAgXG4gIC8vIE5PVEU6IGRlbGl2ZXJlZEdmbG9wc1BlcldhdHQgd2lsbCBiZSBjYWxjdWxhdGVkIGFmdGVyIHRoZXJtYWwgc3lzdGVtIGlzIGNvbXB1dGVkXG4gIC8vIEl0IHdpbGwgYmU6IHN5c3RlbUVmZmVjdGl2ZSAqIHRoZXJtYWxDYXBGYWN0b3IgKiByYWRpYXRpb25EZXJhdGUgKiBhdmFpbGFiaWxpdHlcblxuICAvLyBBSSBXaW50ZXI6IENvbnN0cmFpbnRzIGdyb3cgNTAlIHNsb3dlclxuICBjb25zdCBlZmZlY3RpdmVHcm91bmRTY2VuYXJpbyA9IGFpV2ludGVyRW5hYmxlZCAmJiB5ZWFyID49IDIwMjggPyB7XG4gICAgLi4uR1JPVU5EX1NDRU5BUklPU1tncm91bmRTY2VuYXJpb10sXG4gICAgZ3JpZEdyb3d0aFJhdGU6IEdST1VORF9TQ0VOQVJJT1NbZ3JvdW5kU2NlbmFyaW9dLmdyaWRHcm93dGhSYXRlICogMC41LFxuICAgIGNvb2xpbmdHcm93dGhSYXRlOiBHUk9VTkRfU0NFTkFSSU9TW2dyb3VuZFNjZW5hcmlvXS5jb29saW5nR3Jvd3RoUmF0ZSAqIDAuNSxcbiAgICB3YXRlckdyb3d0aFJhdGU6IEdST1VORF9TQ0VOQVJJT1NbZ3JvdW5kU2NlbmFyaW9dLndhdGVyR3Jvd3RoUmF0ZSAqIDAuNSxcbiAgICBsYW5kR3Jvd3RoUmF0ZTogR1JPVU5EX1NDRU5BUklPU1tncm91bmRTY2VuYXJpb10ubGFuZEdyb3d0aFJhdGUgKiAwLjUsXG4gIH0gOiBHUk9VTkRfU0NFTkFSSU9TW2dyb3VuZFNjZW5hcmlvXTtcblxuICAvLyBFbG9uIFNjZW5hcmlvOiBEaXNjb3VudHNcbiAgY29uc3QgbGF1bmNoRGlzY291bnQgPSBlbG9uU2NlbmFyaW9FbmFibGVkID8gMC41MCA6IDEuMDtcbiAgY29uc3QgcG93ZXJEaXNjb3VudCA9IGVsb25TY2VuYXJpb0VuYWJsZWQgPyAwLjcwIDogMS4wO1xuICBjb25zdCBuZXR3b3JraW5nRGlzY291bnQgPSBlbG9uU2NlbmFyaW9FbmFibGVkID8gMC4xMCA6IDEuMDtcbiAgY29uc3Qgb3BlcmF0b3JNYXJnaW4gPSBlbG9uU2NlbmFyaW9FbmFibGVkID8gMC4wNSA6IDAuMjA7XG5cbiAgLy8gR2xvYmFsIExhdGVuY3k6IDN4IGdyb3VuZCBvdmVycHJvdmlzaW9uaW5nIHBlbmFsdHlcbiAgY29uc3QgZ3JvdW5kTGF0ZW5jeVBlbmFsdHkgPSAoZ2xvYmFsTGF0ZW5jeVJlcXVpcmVtZW50RW5hYmxlZCAmJiB5ZWFyID49IDIwMjgpID8gMy4wIDogMS4wO1xuXG4gIC8vIFNwYWNlIE1hbnVmYWN0dXJpbmc6IE1hc3MgcmVkdWN0aW9uXG4gIGxldCBtYXNzTXVsdGlwbGllciA9IDEuMDtcbiAgaWYgKHNwYWNlTWFudWZhY3R1cmluZ0VuYWJsZWQgJiYgeWVhciA+PSAyMDMyKSB7XG4gICAgY29uc3QgeWVhcnNTaW5jZVN0YXJ0ID0geWVhciAtIDIwMzI7XG4gICAgY29uc3QgcmFtcCA9IE1hdGgubWluKDEuMCwgeWVhcnNTaW5jZVN0YXJ0IC8gNSk7XG4gICAgbWFzc011bHRpcGxpZXIgPSAxLjAgLSAoMC42MCAqIHJhbXApO1xuICB9XG5cbiAgLy8gRU1FUkdFTkNZIEZJWDogVXNlIHNpbXBsZSBmaXhlZCAyMDI1IGJhc2UgdmFsdWVzXG4gIC8vIFRoZXNlIGFyZSB0aGUga25vd24tY29ycmVjdCB2YWx1ZXMgZnJvbSB0aGUgZW1lcmdlbmN5IGZpeFxuICAvLyBEb24ndCB0cnkgdG8gY2FsY3VsYXRlIGZyb20gZmxvcHNQZXJXYXR0IC0ganVzdCB1c2UgdGhlc2UgY29uc3RhbnRzXG4gIGNvbnN0IEJBU0VfRU5FUkdZXzIwMjUgPSA1ODE7ICAgICAgLy8gJC9QRkxPUC15ZWFyIChmaXhlZCAyMDI1IGJhc2UpXG4gIGNvbnN0IEJBU0VfU0lURV8yMDI1ID0gMTUwMDsgICAgICAvLyAkL1BGTE9QLXllYXIgKGZpeGVkIDIwMjUgYmFzZSlcbiAgY29uc3QgRU5FUkdZX0NPU1RfQkFTRV8yMDI1ID0gQkFTRV9FTkVSR1lfMjAyNTsgLy8gVXNlIGZpeGVkIGJhc2UsIG5vdCBjYWxjdWxhdGVkXG4gIFxuICAvLyBGb3IgcmVmZXJlbmNlL2Rpc3BsYXkgKG5vdCB1c2VkIGluIGNvbnN0cmFpbnQgY2FsY3VsYXRpb24pXG4gIGNvbnN0IEJBU0VfRUxFQ1RSSUNJVFlfUFJJQ0VfMjAyNSA9IDEyMDsgLy8gJC9NV2ggKDIwMjUgYmFzZWxpbmUpXG4gIGxldCBncm91bmRFbGVjdHJpY2l0eVByaWNlUGVyTXdoID0gQkFTRV9FTEVDVFJJQ0lUWV9QUklDRV8yMDI1OyBcbiAgaWYgKCFwYXJhbXMuaXNTdGF0aWNNb2RlKSB7XG4gICAgZ3JvdW5kRWxlY3RyaWNpdHlQcmljZVBlck13aCAqPSBNYXRoLnBvdygxLjAyLCB5ZWFyIC0gMjAyNSk7XG4gIH1cbiAgXG4gIGNvbnN0IGVmZmVjdGl2ZVB1ZUdyb3VuZCA9IHB1ZUdyb3VuZCArICgoeWVhciAtIDIwMjUpICogMC4wMSk7XG4gIC8vIENvbnZlcnQgR0ZMT1BTL1cgdG8gcG93ZXI6IDEgUEZMT1AgPSAxZTYgR0ZMT1BTLCBzbyBwb3dlciAoVykgPSAoMWU2IEdGTE9QUykgLyAoR0ZMT1BTL1cpXG4gIGNvbnN0IGdyb3VuZEVuZXJneU1XaFBlclBmbG9wWWVhciA9ICg4NzYwICogMWU2IC8gZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyVykgKiBlZmZlY3RpdmVQdWVHcm91bmQgLyAxZTY7XG4gIGNvbnN0IGdyb3VuZEVuZXJneUNvc3RQZXJQZmxvcFllYXIgPSBncm91bmRFbmVyZ3lNV2hQZXJQZmxvcFllYXIgKiAoZ3JvdW5kRWxlY3RyaWNpdHlQcmljZVBlck13aCkgKiBjYXBhY2l0eUZhY3Rvckdyb3VuZDtcblxuICBjb25zdCBjb21wdXRlR3JvdW5kSGFyZHdhcmVDb3N0ID0gKHk6IG51bWJlciwgYmFzZUNvc3Q6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHllYXJJbmRleCA9IHkgLSAyMDI1O1xuICAgIGxldCBjb3N0ID0gYmFzZUNvc3Q7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB5ZWFySW5kZXg7IGkrKykge1xuICAgICAgbGV0IGFubnVhbERlY2xpbmU7XG4gICAgICBpZiAoaSA8IDMpIGFubnVhbERlY2xpbmUgPSAwLjEwO1xuICAgICAgZWxzZSBpZiAoaSA8IDYpIGFubnVhbERlY2xpbmUgPSAwLjA1O1xuICAgICAgZWxzZSBpZiAoaSA8IDEwKSBhbm51YWxEZWNsaW5lID0gMC4wMjtcbiAgICAgIGVsc2UgYW5udWFsRGVjbGluZSA9IDAuMDA1O1xuICAgICAgY29zdCAqPSAoMSAtIGFubnVhbERlY2xpbmUpO1xuICAgIH1cbiAgICByZXR1cm4gY29zdDtcbiAgfTtcbiAgY29uc3QgZ3JvdW5kTGlmZXRpbWUgPSBwYXJhbXMuZ3JvdW5kSGFyZHdhcmVMaWZldGltZVllYXJzID8/IENPTlNUQU5UUy5HUk9VTkRfSEFSRFdBUkVfTElGRVRJTUU7XG4gIGNvbnN0IGdyb3VuZEhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXIgPSBjb21wdXRlR3JvdW5kSGFyZHdhcmVDb3N0KHllYXIsIENPTlNUQU5UUy5HUk9VTkRfSEFSRFdBUkVfQ09TVF9QRkxPUF8yMDI1KSAvIGdyb3VuZExpZmV0aW1lO1xuXG4gIGNvbnN0IHNtclBhcmFtcyA9IHBhcmFtcy5zbXJUb2dnbGVFbmFibGVkID8gKHBhcmFtcy5zbXJUb2dnbGVQYXJhbXMgfHwgREVGQVVMVF9TTVJfUEFSQU1TKSA6IHVuZGVmaW5lZDtcbiAgXG4gIGxldCBncm91bmRSZXN1bHQ7XG4gIGxldCBncm91bmRUb3RhbENvc3Q6IG51bWJlcjtcbiAgbGV0IGdyb3VuZENvbXBhcmF0b3JDb3N0UGVyUGZsb3BZZWFyOiBudW1iZXI7IC8vIENvbXBhcmF0b3IgY29zdCBmb3IgY3Jvc3NvdmVyICh1c2VzIGVmZmVjdGl2ZSB3aGVuIHF1ZXVlIGV4aXN0cylcbiAgbGV0IGdyb3VuZEhhc1F1ZXVlOiBib29sZWFuID0gZmFsc2U7IC8vIFRyYWNrIGlmIGdyb3VuZCBoYXMgcXVldWUvYmFja2xvZyAoZm9yIGRlYnVnIGFuZCBjb21wYXJhdG9yIGNvc3QpXG4gIGxldCBlbmVyZ3lDb25zdHJhaW50TXVsdGlwbGllcjogbnVtYmVyO1xuICBsZXQgY29uc3RyYWludEJyZWFrZG93bjoge1xuICAgIGdyaWQ6IG51bWJlcjtcbiAgICBjb29saW5nOiBudW1iZXI7XG4gICAgd2F0ZXI6IG51bWJlcjtcbiAgICBsYW5kOiBudW1iZXI7XG4gICAgZW5lcmd5TXVsdGlwbGllcjogbnVtYmVyO1xuICAgIHNpdGVNdWx0aXBsaWVyOiBudW1iZXI7XG4gICAgY2FwYWNpdHlEZWxpdmVyeU11bHRpcGxpZXI/OiBudW1iZXI7XG4gIH07XG4gIFxuICBjb25zdCB1c2VSZWdpb25hbE1vZGVsID0gcGFyYW1zLnVzZVJlZ2lvbmFsR3JvdW5kTW9kZWwgPT09IHRydWUgJiYgcGFyYW1zLmdyb3VuZENvbnN0cmFpbnRzRW5hYmxlZCAmJiAhcGFyYW1zLmlzU3RhdGljTW9kZTtcbiAgXG4gIC8vIEZJWDogTWFrZSBidWlsZG91dCBtb2RlbCB0aGUgZGVmYXVsdCAoaXQgY29ycmVjdGx5IHVzZXMgcmVzcG9uc2l2ZSBkZW1hbmQpXG4gIC8vIFF1ZXVlIG1vZGVsIHJlcXVpcmVzIGZ1bGwgZGVtYW5kIHRyYWplY3RvcnkgdG8gd29yayBjb3JyZWN0bHksIHNvIGl0J3Mgb3B0LWluIG9ubHlcbiAgLy8gT25seSB1c2UgcXVldWUgbW9kZWwgaWYgZXhwbGljaXRseSBlbmFibGVkICh1c2VRdWV1ZUJhc2VkQ29uc3RyYWludCA9PT0gdHJ1ZSlcbiAgY29uc3QgdXNlUXVldWVNb2RlbCA9IHBhcmFtcy51c2VRdWV1ZUJhc2VkQ29uc3RyYWludCA9PT0gdHJ1ZSAmJiBwYXJhbXMuZ3JvdW5kQ29uc3RyYWludHNFbmFibGVkICYmICFwYXJhbXMuaXNTdGF0aWNNb2RlICYmICF1c2VSZWdpb25hbE1vZGVsO1xuICAvLyBCdWlsZG91dCBtb2RlbCBpcyB0aGUgZGVmYXVsdCAoZGVmYXVsdHMgdG8gdHJ1ZSB1bmxlc3MgZXhwbGljaXRseSBkaXNhYmxlZClcbiAgY29uc3QgdXNlQnVpbGRvdXRNb2RlbCA9IChwYXJhbXMudXNlQnVpbGRvdXRNb2RlbCAhPT0gZmFsc2UpICYmIHBhcmFtcy5ncm91bmRDb25zdHJhaW50c0VuYWJsZWQgJiYgIXBhcmFtcy5pc1N0YXRpY01vZGUgJiYgIXVzZVJlZ2lvbmFsTW9kZWwgJiYgIXVzZVF1ZXVlTW9kZWw7XG4gIFxuICBpZiAodXNlUXVldWVNb2RlbCkge1xuICAgIC8vIFBhc3MgcmVzcG9uc2l2ZSBkZW1hbmQgYW5kIG9yYml0YWwgc3Vic3RpdHV0aW9uIHRvIHF1ZXVlIG1vZGVsIChpZiBhdmFpbGFibGUgZnJvbSB0cmFqZWN0b3J5LnRzKVxuICAgIGNvbnN0IHJlc3BvbnNpdmVEZW1hbmRHVyA9IChwYXJhbXMgYXMgYW55KS5yZXNwb25zaXZlRGVtYW5kR1cgYXMgbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9yYml0YWxTdWJzdGl0dXRpb25HVyA9IChwYXJhbXMgYXMgYW55KS5vcmJpdGFsU3Vic3RpdHV0aW9uR1cgYXMgbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIFxuICAgIC8vIEJ1aWxkIGRlbWFuZCBtYXAgaWYgcmVzcG9uc2l2ZSBkZW1hbmQgaXMgcHJvdmlkZWRcbiAgICBjb25zdCBkZW1hbmRCeVllYXIgPSByZXNwb25zaXZlRGVtYW5kR1cgIT09IHVuZGVmaW5lZCBcbiAgICAgID8gbmV3IE1hcChbW3llYXIsIHJlc3BvbnNpdmVEZW1hbmRHV11dKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb3JiaXRhbFN1YnN0aXR1dGlvbkJ5WWVhciA9IG9yYml0YWxTdWJzdGl0dXRpb25HVyAhPT0gdW5kZWZpbmVkXG4gICAgICA/IG5ldyBNYXAoW1t5ZWFyLCBvcmJpdGFsU3Vic3RpdHV0aW9uR1ddXSlcbiAgICAgIDogdW5kZWZpbmVkO1xuICAgIFxuICAgIGNvbnN0IHN1cHBseVRyYWplY3RvcnkgPSBnZW5lcmF0ZUdyb3VuZFN1cHBseVRyYWplY3RvcnkoMjAyNSwgeWVhciwgZGVtYW5kQnlZZWFyLCBvcmJpdGFsU3Vic3RpdHV0aW9uQnlZZWFyKTtcbiAgICBjb25zdCBjdXJyZW50U3VwcGx5U3RhdGUgPSBzdXBwbHlUcmFqZWN0b3J5W3N1cHBseVRyYWplY3RvcnkubGVuZ3RoIC0gMV07XG4gICAgXG4gICAgLy8gRGVidWc6IExvZyBpZiByZXNwb25zaXZlIGRlbWFuZCBpcyBiZWluZyBpZ25vcmVkXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIHJlc3BvbnNpdmVEZW1hbmRHVyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBoYXJkY29kZWREZW1hbmQgPSBnZXRHbG9iYWxEZW1hbmRHdyh5ZWFyKTtcbiAgICAgIGlmIChNYXRoLmFicyhjdXJyZW50U3VwcGx5U3RhdGUuZGVtYW5kR3cgLSBoYXJkY29kZWREZW1hbmQpIDwgMWUtNikge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFtRVUVVRSBNT0RFTCBERUJVR10gWWVhciAke3llYXJ9OiBSZXNwb25zaXZlIGRlbWFuZCAoJHtyZXNwb25zaXZlRGVtYW5kR1cudG9GaXhlZCgyKX0gR1cpIG1heSBiZSBpZ25vcmVkLiBgICtcbiAgICAgICAgICBgUXVldWUgbW9kZWwgdXNpbmc6ICR7Y3VycmVudFN1cHBseVN0YXRlLmRlbWFuZEd3LnRvRml4ZWQoMil9IEdXIChoYXJkY29kZWQ6ICR7aGFyZGNvZGVkRGVtYW5kLnRvRml4ZWQoMil9IEdXKWBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGBbUVVFVUUgTU9ERUwgREVCVUddIFllYXIgJHt5ZWFyfTogVXNpbmcgcmVzcG9uc2l2ZSBkZW1hbmQgJHtyZXNwb25zaXZlRGVtYW5kR1cudG9GaXhlZCgyKX0gR1cgYCArXG4gICAgICAgICAgYChxdWV1ZSBtb2RlbDogJHtjdXJyZW50U3VwcGx5U3RhdGUuZGVtYW5kR3cudG9GaXhlZCgyKX0gR1cpYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgV0FDQy1iYXNlZCBwZW5hbHRpZXMgYW5kIG11bHRpcGxpZXJzXG4gICAgLy8gUGFzcyBXQUNDIHBhcmFtZXRlcnMgZm9yIGNhcGl0YWwgcmF0aW9uaW5nIChXQUNDIHJpc2VzIHdpdGggYmFja2xvZylcbiAgICBjb25zdCB3YWNjUGFyYW1zID0ge1xuICAgICAgYmFzZVdhY2M6IHBhcmFtcy53YWNjID8/IDAuMTAsXG4gICAgICB3YWNjQmFja2xvZ0s6IHBhcmFtcy53YWNjQmFja2xvZ0sgPz8gMC41LFxuICAgICAgd2FjY0JhY2tsb2dFeHBvbmVudDogcGFyYW1zLndhY2NCYWNrbG9nRXhwb25lbnQgPz8gMS4yLFxuICAgICAgY3JpdGljYWxCYWNrbG9nR1c6IHBhcmFtcy5jcml0aWNhbEJhY2tsb2dHVyA/PyA1MCxcbiAgICB9O1xuICAgIGNvbnN0IHBlbmFsdGllcyA9IGNhbGN1bGF0ZUdyb3VuZENvbnN0cmFpbnRQZW5hbHRpZXMoXG4gICAgICBjdXJyZW50U3VwcGx5U3RhdGUsXG4gICAgICBncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXLFxuICAgICAgZWZmZWN0aXZlUHVlR3JvdW5kLFxuICAgICAgY2FwYWNpdHlGYWN0b3JHcm91bmQsXG4gICAgICB3YWNjUGFyYW1zXG4gICAgKTtcbiAgICBcbiAgICBjb25zdCBCQVNFX1NJVEVfMjAyNSA9IDE1MDA7XG4gICAgXG4gICAgLy8gRW5lcmd5IGNvc3Q6IFVzZSBhY3R1YWwgY2FsY3VsYXRlZCB2YWx1ZSAoTk9UIG11bHRpcGxpZWQgYnkgY29uc3RyYWludClcbiAgICAvLyBDUklUSUNBTCBGSVg6IERvIE5PVCBhcHBseSBQVUUgbXVsdGlwbGllciAtIGVuZXJneSBjb3N0IGlzIGJhc2Ugb25seVxuICAgIC8vIFBVRSBzdHJlc3Mgc2hvdWxkIGJlIHJlZmxlY3RlZCBpbiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSwgbm90IGVuZXJneSBtdWx0aXBsaWVyXG4gICAgY29uc3QgZW5lcmd5Q29zdEJhc2UgPSBncm91bmRFbmVyZ3lDb3N0UGVyUGZsb3BZZWFyO1xuICAgIGNvbnN0IGVuZXJneUNvc3QgPSBlbmVyZ3lDb3N0QmFzZTsgLy8gQmFzZSBlbmVyZ3kgY29zdCBvbmx5IC0gbm8gbXVsdGlwbGllclxuICAgIFxuICAgIC8vIEdST1VORCBDT1NUIEFDQ09VTlRJTkc6IEV4cGxpY2l0IHNlcGFyYXRpb24gb2YgY29tcG9uZW50cyAocXVldWUgbW9kZWwpXG4gICAgY29uc3Qgc2l0ZUNvc3RCYXNlID0gQkFTRV9TSVRFXzIwMjU7XG4gICAgXG4gICAgLy8gMS4gc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXI6IFB1cmUgYW1vcnRpemVkIGNhcGV4IChOT1QgYWZmZWN0ZWQgYnkgY29uc3RyYWludClcbiAgICBjb25zdCBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciA9IHNpdGVDb3N0QmFzZTtcbiAgICBcbiAgICAvLyBDSE9JQ0U6IFVzZSBkZWxheVBlbmFsdHkgKyBzY2FyY2l0eVJlbnQgKEhpbGwtYmFzZWQpLCBOT1QgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1cbiAgICAvLyBTZXQgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gdG8gMCB0byBhdm9pZCB0cmlwbGUtY2hhcmdpbmdcbiAgICBjb25zdCBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhciA9IDA7IC8vIE5PVCBVU0VEIC0gdXNpbmcgZGVsYXlQZW5hbHR5ICsgc2NhcmNpdHlSZW50IGluc3RlYWRcbiAgICBcbiAgICAvLyAxLiB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXI6IEJvdW5kZWQgbGluZWFyIFdBQ0MgY2FycnkgKE5PVCBleHBvbmVudGlhbClcbiAgICBjb25zdCB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgPSBwZW5hbHRpZXMudGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyO1xuICAgIFxuICAgIC8vIDIuIHNjYXJjaXR5UmVudFBlclBmbG9wWWVhcjogSGlsbCBmdW5jdGlvbiBvZiBhdmdXYWl0WWVhcnMgKHc1MD0yLjAsIG49Mi4wLCByZW50TWF4PTAuNjUpXG4gICAgLy8gQmFzZSBjb3N0IGZvciBzY2FyY2l0eSByZW50ID0gaGFyZHdhcmUgKyBzaXRlIChubyBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSlcbiAgICBjb25zdCBjYXBleEFubnVhbEJhc2VQZXJQZmxvcFllYXIgPSBcbiAgICAgIGdyb3VuZEhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXIgK1xuICAgICAgc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXI7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHNjYXJjaXR5IG11bHRpcGxpZXIgdXNpbmcgTE9HLUJBU0VEIGZ1bmN0aW9uIChuZXZlciBmdWxseSBzYXR1cmF0ZXMpXG4gICAgLy8gUmV0dXJucyBtdWx0aXBsaWVyICgxLjAgPSBubyBzY2FyY2l0eSwgMi4wID0gMnggcHJpY2UpIC0gTVVMVElQTElDQVRJVkUsIG5vdCBhZGRpdGl2ZVxuICAgIGNvbnN0IHNjYXJjaXR5UmVudFJlc3VsdCA9IGNhbGN1bGF0ZVNjYXJjaXR5UmVudChcbiAgICAgIGN1cnJlbnRTdXBwbHlTdGF0ZS5hdmdXYWl0WWVhcnMsXG4gICAgICBjdXJyZW50U3VwcGx5U3RhdGUudXRpbGl6YXRpb25QY3QsIC8vIFBhc3MgdXRpbGl6YXRpb24gZm9yIHRocmVzaG9sZCBnYXRlXG4gICAgICB7XG4gICAgICAgIHdhaXRUaHJlc2hvbGRZZWFyczogMS4wLCAvLyBNaW5pbXVtIHdhaXQgYmVmb3JlIHNjYXJjaXR5IGFjdGl2YXRlc1xuICAgICAgICByZW50TWF4TXVsdGlwbGllcjogMi4wLCAvLyBNYXhpbXVtIHByaWNlIG11bHRpcGxpZXIgKDJ4ID0gMTAwJSBpbmNyZWFzZSlcbiAgICAgICAgdXRpbGl6YXRpb25UaHJlc2hvbGQ6IDAuODUsIC8vIFV0aWxpemF0aW9uIHRocmVzaG9sZFxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3Qgc2NhcmNpdHlNdWx0aXBsaWVyID0gc2NhcmNpdHlSZW50UmVzdWx0LnNjYXJjaXR5TXVsdGlwbGllcjtcbiAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eTogc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyID0gMCAoc2NhcmNpdHkgaXMgbm93IG11bHRpcGxpY2F0aXZlKVxuICAgIGNvbnN0IHNjYXJjaXR5UmVudFBlclBmbG9wWWVhciA9IDA7XG4gICAgXG4gICAgLy8gRGVidWc6IHZlcmlmeSBxdWV1ZSBtb2RlbCBjb25zaXN0ZW5jeVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgY29uc3QgdW5zZXJ2ZWRHdyA9IGN1cnJlbnRTdXBwbHlTdGF0ZS51bnNlcnZlZEd3ID8/IChjdXJyZW50U3VwcGx5U3RhdGUuZGVtYW5kR3cgLSBjdXJyZW50U3VwcGx5U3RhdGUuY2FwYWNpdHlHdyk7XG4gICAgICBpZiAoY3VycmVudFN1cHBseVN0YXRlLmRlbWFuZEd3IDwgY3VycmVudFN1cHBseVN0YXRlLmNhcGFjaXR5R3cgJiYgY3VycmVudFN1cHBseVN0YXRlLmJhY2tsb2dHdyA+IDUwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgW1FVRVVFIE1PREVMXSBZZWFyICR7eWVhcn06IGRlbWFuZEd3PSR7Y3VycmVudFN1cHBseVN0YXRlLmRlbWFuZEd3LnRvRml4ZWQoMSl9IDwgY2FwYWNpdHlHdz0ke2N1cnJlbnRTdXBwbHlTdGF0ZS5jYXBhY2l0eUd3LnRvRml4ZWQoMSl9IGAgK1xuICAgICAgICAgIGBidXQgYmFja2xvZ0d3PSR7Y3VycmVudFN1cHBseVN0YXRlLmJhY2tsb2dHdy50b0ZpeGVkKDEpfSA+IDUwLiBUaGlzIG1heSBpbmRpY2F0ZSBxdWV1ZSBtb2RlbCBpc3N1ZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENSSVRJQ0FMOiBSZW1vdmUgZG91YmxlIGNvdW50aW5nXG4gICAgLy8gRG8gTk9UIGluY2x1ZGUgdGltZVRvRW5lcmdpemVQZW5hbHR5ICsgc2NhcmNpdHlSZW50IGluIGhlYWRsaW5lIGNvc3QgdXNlZCBmb3IgY3Jvc3NvdmVyXG4gICAgLy8gKGNhcGFjaXR5IGdhdGluZyBpbiBtYXJrZXQgc2hhcmUgYWxyZWFkeSBhY2NvdW50cyBmb3IgYmFja2xvZylcbiAgICAvLyBDb21wdXRlIGJvdGggYmFzZSBhbmQgZWZmZWN0aXZlIGNvc3RzOlxuICAgIGNvbnN0IHNpdGVDb3N0UGVyUGZsb3BZZWFyX2Jhc2UgPSBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhcjsgLy8gTm8gY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1cbiAgICBjb25zdCBzaXRlQ29zdFBlclBmbG9wWWVhcl9lZmZlY3RpdmUgPSBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciArIHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciArIHNjYXJjaXR5UmVudFBlclBmbG9wWWVhcjtcbiAgICBcbiAgICAvLyBWYWxpZGF0aW9uXG4gICAgY29uc3QgZXhwZWN0ZWRFZmZlY3RpdmUgPSBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciArIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyICsgdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyICsgc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyO1xuICAgIGNvbnN0IHNpdGVDb3N0Q2hlY2sgPSBNYXRoLmFicyhzaXRlQ29zdFBlclBmbG9wWWVhcl9lZmZlY3RpdmUgLSBleHBlY3RlZEVmZmVjdGl2ZSk7XG4gICAgaWYgKHNpdGVDb3N0Q2hlY2sgPiAwLjAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpdGUgY29zdCBhY2NvdW50aW5nIGVycm9yIChxdWV1ZSBtb2RlbCk6IHNpdGVDb3N0X2VmZmVjdGl2ZT0ke3NpdGVDb3N0UGVyUGZsb3BZZWFyX2VmZmVjdGl2ZX0gIT0gc3VtKGNvbXBvbmVudHMpPSR7ZXhwZWN0ZWRFZmZlY3RpdmV9IChzaXRlQ2FwZXg9JHtzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhcn0sIHByZW1pdW09JHtjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhcn0sIGRlbGF5PSR7dGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyfSwgc2NhcmNpdHk9JHtzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXJ9KSwgZGlmZj0ke3NpdGVDb3N0Q2hlY2t9YCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGhhcmR3YXJlQ29zdCA9IGdyb3VuZEhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXI7XG4gICAgXG4gICAgLy8gVU5JRklFRCBTQ0FSQ0lUWSBBQ0NPVU5USU5HOiBLZWVwIHRvdGFsQ29zdFBlclBmbG9wWWVhciBwaHlzaWNhbC1vbmx5XG4gICAgLy8gU2NhcmNpdHkgKGRlbGF5UGVuYWx0eSArIHNjYXJjaXR5UmVudCkgaXMgdHJlYXRlZCBwdXJlbHkgaW4gR1BVLWhvdXIgcHJpY2luZywgbm90IGluIFBGTE9QLXllYXIgY29zdFxuICAgIGdyb3VuZFRvdGFsQ29zdCA9IChlbmVyZ3lDb3N0ICsgc2l0ZUNvc3RQZXJQZmxvcFllYXJfYmFzZSArIGhhcmR3YXJlQ29zdCkgKiBncm91bmRMYXRlbmN5UGVuYWx0eTtcbiAgICBcbiAgICAvLyBGb3IgY3Jvc3NvdmVyOiB1c2UgYmFzZSBjb3N0IChzY2FyY2l0eSBpcyBhbHJlYWR5IHJlZmxlY3RlZCBpbiBHUFUtaG91ciBwcmljaW5nKVxuICAgIC8vIFRoaXMgZW5zdXJlcyB3ZSBkb24ndCBkb3VibGUtY291bnQgc2NhcmNpdHlcbiAgICBncm91bmRIYXNRdWV1ZSA9IHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciA+IDAuMDE7XG4gICAgZ3JvdW5kQ29tcGFyYXRvckNvc3RQZXJQZmxvcFllYXIgPSBncm91bmRUb3RhbENvc3Q7IC8vIEJhc2UgY29zdCBvbmx5IChzY2FyY2l0eSBpbiBHUFUtaG91cilcbiAgICBcbiAgICAvLyBDUklUSUNBTCBGSVg6IFJlbW92ZSBhbGwgbXVsdGlwbGllcnMgLSB1c2UgYWRkaXRpdmUgdGVybXMgb25seVxuICAgIC8vIE11bHRpcGxpZXJzIGFyZSBOT1QgYXBwbGllZCB0byBhbnkgZG9sbGFyIGFtb3VudHNcbiAgICAvLyBBbGwgY29uc3RyYWludCBlZmZlY3RzIGFyZSBjYXB0dXJlZCBpbiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSBhbmQgdGltZVRvRW5lcmdpemVQZW5hbHR5XG4gICAgZW5lcmd5Q29uc3RyYWludE11bHRpcGxpZXIgPSAxLjA7IC8vIE5ldmVyIGFwcGxpZWQgLSBmb3IgYmFja3dhcmQgY29tcGF0IG9ubHlcbiAgICBcbiAgICAvLyBDb25zdHJhaW50IGJyZWFrZG93bjogYWxsIG11bHRpcGxpZXJzIHNldCB0byAxLjAgKG5vdCBhcHBsaWVkKVxuICAgIC8vIFRoZXNlIGFyZSBrZXB0IGZvciBkZWJ1Zy9kZWNvbXBvc2l0aW9uIGJ1dCBuZXZlciBtdWx0aXBsaWVkIGludG8gY29zdHNcbiAgICBjb25zdHJhaW50QnJlYWtkb3duID0ge1xuICAgICAgZ3JpZDogMS4wLCAvLyBOb3QgYXBwbGllZCAtIGNvbnN0cmFpbnQgZWZmZWN0cyBpbiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVxuICAgICAgY29vbGluZzogMS4wLCAvLyBOb3QgYXBwbGllZCAtIGNvbnN0cmFpbnQgZWZmZWN0cyBpbiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVxuICAgICAgd2F0ZXI6IDEuMCwgLy8gTm90IGFwcGxpZWQgLSBjb25zdHJhaW50IGVmZmVjdHMgaW4gY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1cbiAgICAgIGxhbmQ6IDEuMCwgLy8gTm90IGFwcGxpZWQgLSBjb25zdHJhaW50IGVmZmVjdHMgaW4gY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1cbiAgICAgIGVuZXJneU11bHRpcGxpZXI6IDEuMCwgLy8gTmV2ZXIgYXBwbGllZCAtIGVuZXJneSBjb3N0IGlzIGJhc2Ugb25seVxuICAgICAgc2l0ZU11bHRpcGxpZXI6IDEuMCwgLy8gTm90IGFwcGxpZWQgLSBjb25zdHJhaW50IGVmZmVjdHMgaW4gY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1cbiAgICAgIGNhcGFjaXR5RGVsaXZlcnlNdWx0aXBsaWVyOiAxLjAsIC8vIE5vdCBhcHBsaWVkIC0gY29uc3RyYWludCBlZmZlY3RzIGluIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtXG4gICAgfTtcbiAgICBcbiAgICBncm91bmRSZXN1bHQgPSB7XG4gICAgICBlbmVyZ3lDb3N0OiBlbmVyZ3lDb3N0ICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksIC8vIEVuZXJneSB3aXRoIFBVRSBtdWx0aXBsaWVyXG4gICAgICBzaXRlQ29zdDogc2l0ZUNvc3RQZXJQZmxvcFllYXJfYmFzZSAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LCAvLyBTaXRlID0gYmFzZSBjb21wb25lbnRzIChleGNsdWRlcyBkZWxheSBwZW5hbHR5KVxuICAgICAgaGFyZHdhcmVDb3N0OiBoYXJkd2FyZUNvc3QgKiBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgIHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyOiBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LCAvLyBFeHBsaWNpdDogcHVyZSBjYXBleFxuICAgICAgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW06IGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksIC8vIEV4cGxpY2l0OiBzY2FyY2l0eSBwcmVtaXVtXG4gICAgICB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHk6IHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LCAvLyBFeHBsaWNpdDogV0FDQy1iYXNlZCBwZW5hbHR5IChub3QgaW4gaGVhZGxpbmUgY29zdClcbiAgICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhcjogZ3JvdW5kVG90YWxDb3N0LCAvLyBQaHlzaWNhbCBjb3N0cyBvbmx5IChzY2FyY2l0eSB0cmVhdGVkIGluIEdQVS1ob3VyIHByaWNpbmcpXG4gICAgICB0b3RhbENvc3RQZXJQZmxvcFllYXJFZmZlY3RpdmU6IGdyb3VuZFRvdGFsQ29zdCwgLy8gU2FtZSBhcyBiYXNlIChzY2FyY2l0eSBpbiBHUFUtaG91ciwgbm90IFBGTE9QLXllYXIpXG4gICAgICB0b3RhbENvc3RQZXJQZmxvcFllYXJBbGxJbjogZ3JvdW5kVG90YWxDb3N0LCAvLyBTYW1lIGFzIGJhc2UgKHNjYXJjaXR5IGluIEdQVS1ob3VyLCBub3QgUEZMT1AteWVhcilcbiAgICAgIGNvbnN0cmFpbnRNdWx0aXBsaWVyOiAxLjAsIC8vIE5PVCBBUFBMSUVEIC0ga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0IG9ubHlcbiAgICAgIGJyZWFrZG93bjogY29uc3RyYWludEJyZWFrZG93bixcbiAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgIG1ldGhvZDogJ2FkZGVycycsXG4gICAgICAgIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtOiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LCAvLyBTZXQgdG8gMCAobm90IHVzZWQpXG4gICAgICAgIGRlbGF5UGVuYWx0eTogdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksIC8vIEJvdW5kZWQgbGluZWFyIFdBQ0MgY2FycnlcbiAgICAgICAgc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyOiBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSwgLy8gQmFja3dhcmQgY29tcGF0IChub3cgMCwgc2NhcmNpdHkgaXMgbXVsdGlwbGljYXRpdmUpXG4gICAgICAgIHNjYXJjaXR5TXVsdGlwbGllcjogc2NhcmNpdHlNdWx0aXBsaWVyLCAvLyBNdWx0aXBsaWNhdGl2ZSBzY2FyY2l0eSAoMS4wID0gbm8gc2NhcmNpdHksIDIuMCA9IDJ4IHByaWNlKVxuICAgICAgICBhcHBsaWVkTXVsdGlwbGllcnM6IHtcbiAgICAgICAgICBjb25zdHJhaW50TXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgICAgIGVuZXJneU11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgICBzaXRlTXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICAvLyBEZWJ1ZyBmaWVsZHMgZm9yIEhpbGwtYmFzZWQgc2NhcmNpdHkgcmVudCAod2FpdC10aW1lIGJhc2VkKVxuICAgICAgICBzY2FyY2l0eUhpbGw6IHNjYXJjaXR5UmVudFJlc3VsdC5zY2FyY2l0eUhpbGwsXG4gICAgICAgIGF2Z1dhaXRZZWFyc1JhdzogY3VycmVudFN1cHBseVN0YXRlLmF2Z1dhaXRZZWFyc1JhdyA/PyBjdXJyZW50U3VwcGx5U3RhdGUuYXZnV2FpdFllYXJzLFxuICAgICAgICBhdmdXYWl0WWVhcnNDbGFtcGVkOiBzY2FyY2l0eVJlbnRSZXN1bHQuYXZnV2FpdFllYXJzQ2xhbXBlZCxcbiAgICAgICAgcmVudEZyYWM6IHNjYXJjaXR5UmVudFJlc3VsdC5yZW50RnJhYyxcbiAgICAgICAgLy8gQWRkaXRpb25hbCBkZWJ1ZyBmaWVsZHMgZm9yIHZlcmlmaWNhdGlvblxuICAgICAgICBiYWNrbG9nR3c6IGN1cnJlbnRTdXBwbHlTdGF0ZS5iYWNrbG9nR3csXG4gICAgICAgIHVuc2VydmVkR3c6IGN1cnJlbnRTdXBwbHlTdGF0ZS51bnNlcnZlZEd3ID8/IDAsXG4gICAgICAgIGRlbGl2ZXJlZEZyb21CYWNrbG9nR3c6IGN1cnJlbnRTdXBwbHlTdGF0ZS5kZWxpdmVyZWRGcm9tQmFja2xvZ0d3ID8/IDAsXG4gICAgICAgIGJhc2VDb3N0UGVyUGZsb3BZZWFyOiBjYXBleEFubnVhbEJhc2VQZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgICAgdG90YWxDb3N0UGVyUGZsb3BZZWFyOiBncm91bmRUb3RhbENvc3QsXG4gICAgICB9LFxuICAgICAgc3VwcGx5TWV0cmljczoge1xuICAgICAgICBkZW1hbmRHdzogY3VycmVudFN1cHBseVN0YXRlLmRlbWFuZEd3LFxuICAgICAgICBjYXBhY2l0eUd3OiBjdXJyZW50U3VwcGx5U3RhdGUuY2FwYWNpdHlHdyxcbiAgICAgICAgcGlwZWxpbmVHdzogY3VycmVudFN1cHBseVN0YXRlLnBpcGVsaW5lR3csXG4gICAgICAgIG1heEJ1aWxkUmF0ZUd3WWVhcjogY3VycmVudFN1cHBseVN0YXRlLm1heEJ1aWxkUmF0ZUd3WWVhcixcbiAgICAgICAgYXZnV2FpdFllYXJzOiBjdXJyZW50U3VwcGx5U3RhdGUuYXZnV2FpdFllYXJzLFxuICAgICAgICB1dGlsaXphdGlvblBjdDogY3VycmVudFN1cHBseVN0YXRlLnV0aWxpemF0aW9uUGN0LFxuICAgICAgICAvLyBEZWJ1ZyBmaWVsZHMgZm9yIHF1ZXVlIG1vZGVsIHZlcmlmaWNhdGlvblxuICAgICAgICBiYWNrbG9nR3c6IGN1cnJlbnRTdXBwbHlTdGF0ZS5iYWNrbG9nR3csXG4gICAgICAgIHVuc2VydmVkR3c6IGN1cnJlbnRTdXBwbHlTdGF0ZS51bnNlcnZlZEd3ID8/IDAsXG4gICAgICAgIGRlbGl2ZXJlZEZyb21CYWNrbG9nR3c6IGN1cnJlbnRTdXBwbHlTdGF0ZS5kZWxpdmVyZWRGcm9tQmFja2xvZ0d3ID8/IDAsXG4gICAgICAgIGF2Z1dhaXRZZWFyc1JhdzogY3VycmVudFN1cHBseVN0YXRlLmF2Z1dhaXRZZWFyc1JhdyA/PyBjdXJyZW50U3VwcGx5U3RhdGUuYXZnV2FpdFllYXJzLFxuICAgICAgfSxcbiAgICAgIGNvbnN0cmFpbnRDb21wb25lbnRzOiB7XG4gICAgICAgIHF1ZXVlUHJlc3N1cmU6IGN1cnJlbnRTdXBwbHlTdGF0ZS5hdmdXYWl0WWVhcnMgPiAwID8gMSArIGN1cnJlbnRTdXBwbHlTdGF0ZS5hdmdXYWl0WWVhcnMgLyAyIDogMSxcbiAgICAgICAgdXRpbGl6YXRpb25QcmVzc3VyZTogY3VycmVudFN1cHBseVN0YXRlLnV0aWxpemF0aW9uUGN0ID4gMC44NSA/IDEgKyAoY3VycmVudFN1cHBseVN0YXRlLnV0aWxpemF0aW9uUGN0IC0gMC44NSkgKiA1IDogMSxcbiAgICAgICAgc2NhcmNpdHlQcmVtaXVtOiBwZW5hbHRpZXMuc2l0ZU11bHRpcGxpZXIsXG4gICAgICB9LFxuICAgICAgLy8gRGVidWcgZmllbGRzIGZvciBXQUNDIHBlbmFsdGllc1xuICAgICAgYmFja2xvZ0d3OiBwZW5hbHRpZXMuYmFja2xvZ0d3LFxuICAgICAgYXZnV2FpdFllYXJzOiBwZW5hbHRpZXMuYXZnV2FpdFllYXJzLFxuICAgICAgY2FwZXhBdFJpc2tQZXJNVzogcGVuYWx0aWVzLmNhcGV4QXRSaXNrUGVyTVcsXG4gICAgICBjYXJyeUNvc3RQZXJNVzogcGVuYWx0aWVzLmNhcnJ5Q29zdFBlck1XLFxuICAgICAgbG9zdE1hcmdpblBlck1XOiBwZW5hbHRpZXMubG9zdE1hcmdpblBlck1XLFxuICAgICAgdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyOiBwZW5hbHRpZXMudGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyLFxuICAgICAgcHVlTXVsdGlwbGllcjogcGVuYWx0aWVzLnB1ZU11bHRpcGxpZXIsXG4gICAgICBzbXJFbmFibGVkOiBmYWxzZSxcbiAgICAgIHNtclJhbXBGYWN0b3I6IDAsXG4gICAgICBlZmZlY3RpdmVFbGVjdHJpY2l0eUNvc3Q6IGdyb3VuZEVsZWN0cmljaXR5UHJpY2VQZXJNd2gsXG4gICAgICBjb25zdHJhaW50UmVsaWVmOiB7IGdyaWQ6IDAsIGNvb2xpbmc6IDAsIHdhdGVyOiAwLCBsYW5kOiAwIH0sXG4gICAgfTtcbiAgfSBlbHNlIGlmICh1c2VCdWlsZG91dE1vZGVsKSB7XG4gICAgLy8gTkVXOiBSYW1waW5nIE1vYmlsaXphdGlvbiBNb2RlbFxuICAgIC8vIFJlcGxhY2VzIGNvbnN0cmFpbnQgbXVsdGlwbGllciB3aXRoIGV4cGxpY2l0IGJ1aWxkb3V0IGNhcGV4IHByZW1pdW0gYW5kIGRlbGF5IHBlbmFsdGllc1xuICAgIC8vIFVzZXMgcmFtcGluZyBidWlsZG91dCBjYXBhY2l0eSB3aXRoIHNtb290aCBpbnRlcnBvbGF0aW9uXG4gICAgXG4gICAgLy8gR2V0IG1vYmlsaXphdGlvbiBwYXJhbWV0ZXJzICh1c2UgZGVmYXVsdHMgaWYgbm90IHByb3ZpZGVkKVxuICAgIGNvbnN0IG1vYmlsaXphdGlvblBhcmFtczogTW9iaWxpemF0aW9uU2NlbmFyaW9QYXJhbXMgPSBwYXJhbXMubW9iaWxpemF0aW9uUGFyYW1zID8ge1xuICAgICAgLi4uREVGQVVMVF9NT0JJTElaQVRJT05fUEFSQU1TLFxuICAgICAgLi4ucGFyYW1zLm1vYmlsaXphdGlvblBhcmFtcyxcbiAgICAgIGRlbWFuZEN1cnZlOiAocGFyYW1zLm1vYmlsaXphdGlvblBhcmFtcy5kZW1hbmRDdXJ2ZSB8fCBERUZBVUxUX01PQklMSVpBVElPTl9QQVJBTVMuZGVtYW5kQ3VydmUpIGFzICdwaWVjZXdpc2VfZXhwb25lbnRpYWwnLFxuICAgIH0gOiBERUZBVUxUX01PQklMSVpBVElPTl9QQVJBTVM7XG4gICAgXG4gICAgLy8gR2V0IHByZXZpb3VzIG1vYmlsaXphdGlvbiBzdGF0ZSBmcm9tIHBhcmFtcyAocGFzc2VkIGZyb20gdHJhamVjdG9yeSlcbiAgICAvLyBJZiBub3QgcHJvdmlkZWQsIGNhbGN1bGF0ZSBmcm9tIHByZXZpb3VzIHllYXIncyBkZW1hbmRcbiAgICBjb25zdCBwcmV2TW9iaWxpemF0aW9uU3RhdGU6IE1vYmlsaXphdGlvblN0YXRlIHwgbnVsbCA9IChwYXJhbXMgYXMgYW55KS5wcmV2TW9iaWxpemF0aW9uU3RhdGUgPz8gbnVsbDtcbiAgICBcbiAgICAvLyBTdGVwIG1vYmlsaXphdGlvbiBzdGF0ZSBmb3J3YXJkXG4gICAgLy8gUGFzcyByZXNwb25zaXZlIGRlbWFuZCBhbmQgb3JiaXRhbCBzdWJzdGl0dXRpb24gaWYgYXZhaWxhYmxlIChmcm9tIHRyYWplY3RvcnkudHMpXG4gICAgY29uc3QgcmVzcG9uc2l2ZURlbWFuZEdXID0gKHBhcmFtcyBhcyBhbnkpLnJlc3BvbnNpdmVEZW1hbmRHVyBhcyBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb3JiaXRhbFN1YnN0aXR1dGlvbkdXID0gKHBhcmFtcyBhcyBhbnkpLm9yYml0YWxTdWJzdGl0dXRpb25HVyBhcyBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY29uc3QgbW9iaWxpemF0aW9uUmVzdWx0ID0gc3RlcE1vYmlsaXphdGlvblN0YXRlKFxuICAgICAgcHJldk1vYmlsaXphdGlvblN0YXRlLFxuICAgICAgbW9iaWxpemF0aW9uUGFyYW1zLFxuICAgICAgeWVhcixcbiAgICAgIGVmZmVjdGl2ZVB1ZUdyb3VuZCxcbiAgICAgIDAsIC8vIHJldGlyZW1lbnRzR1cgPSAwIGZvciBub3dcbiAgICAgIG9yYml0YWxTdWJzdGl0dXRpb25HVywgLy8gUGFzcyBvcmJpdGFsIHN1YnN0aXR1dGlvbiBmb3IgYmFja2xvZyBkcmFpblxuICAgICAgcmVzcG9uc2l2ZURlbWFuZEdXIC8vIFBhc3MgcmVzcG9uc2l2ZSBkZW1hbmQgKG92ZXJyaWRlcyBoYXJkY29kZWQpXG4gICAgKTtcbiAgICBcbiAgICAvLyBFeHRyYWN0IHZhbHVlcyBmcm9tIG1vYmlsaXphdGlvbiBtb2RlbFxuICAgIGNvbnN0IGRlbWFuZE5ld0dXID0gbW9iaWxpemF0aW9uUmVzdWx0LmRlbWFuZE5ld0dXO1xuICAgIGNvbnN0IGJ1aWxkUmF0ZUdXeXIgPSBtb2JpbGl6YXRpb25SZXN1bHQuYnVpbGRSYXRlR1d5cjtcbiAgICBjb25zdCBidWlsZGFibGVHVyA9IGJ1aWxkUmF0ZUdXeXI7IC8vIGJ1aWxkYWJsZSA9IGJ1aWxkIHJhdGVcbiAgICBjb25zdCBjYXBhY2l0eUdXID0gbW9iaWxpemF0aW9uUmVzdWx0LmNhcGFjaXR5R1c7XG4gICAgY29uc3QgcGlwZWxpbmVHVyA9IG1vYmlsaXphdGlvblJlc3VsdC5waXBlbGluZUdXO1xuICAgIGNvbnN0IGJhY2tsb2dHVyA9IG1vYmlsaXphdGlvblJlc3VsdC5iYWNrbG9nR1c7XG4gICAgY29uc3QgYXZnV2FpdFllYXJzID0gbW9iaWxpemF0aW9uUmVzdWx0LmF2Z1dhaXRZZWFycztcbiAgICBcbiAgICAvLyBEZWZhdWx0IGJ1aWxkb3V0IHBhcmFtZXRlcnNcbiAgICBjb25zdCBiYXNlV2FjYyA9IHBhcmFtcy53YWNjID8/IDAuMTA7IC8vIDEwJSBiYXNlIFdBQ0NcbiAgICBjb25zdCBQUk9KRUNUX0xJRkVUSU1FID0gMjA7IC8vIDIwIHllYXJzXG4gICAgY29uc3QgQlVJTERPVVRfQ0FQRVhfQkFTRSA9IDIwMDA7IC8vICQyay9rVyBiYXNlIGJ1aWxkb3V0IGNhcGV4IChyZWR1Y2VkIGZyb20gM2spXG4gICAgY29uc3QgREVGQVVMVF9TQ0FSQ0lUWV9DVVJWRSA9IHtcbiAgICAgIGs6IDIuMCwgLy8gYnVpbGRvdXRLIChpbmNyZWFzZWQgZnJvbSAwLjUgZm9yIHNoYXJwZXIgc2NhbGluZylcbiAgICAgIGV4cG9uZW50OiAxLjcsIC8vIGJ1aWxkb3V0RXhwb25lbnQgKGluY3JlYXNlZCBmcm9tIDEuNSBmb3Igc2hhcnBlciBzY2FsaW5nKVxuICAgICAgdGhyZXNob2xkVXRpbDogMC4wLCAvLyBQcmVtaXVtIGtpY2tzIGluIGltbWVkaWF0ZWx5XG4gICAgfTtcbiAgICBjb25zdCBQQU5JQ19FWFBPTkVOVCA9IDEuMzsgLy8gRXhwb25lbnQgZm9yIGRlbGF5IHBlbmFsdHkgcGFuaWMgcmVnaW1lXG4gICAgXG4gICAgLy8gQ29tcHV0ZSBlZmZlY3RpdmUgV0FDQyAocmlzZXMgd2l0aCBiYWNrbG9nIC0gY2FwaXRhbCByYXRpb25pbmcpXG4gICAgY29uc3Qgd2FjY0JhY2tsb2dLID0gcGFyYW1zLndhY2NCYWNrbG9nSyA/PyAwLjU7XG4gICAgY29uc3Qgd2FjY0JhY2tsb2dFeHBvbmVudCA9IHBhcmFtcy53YWNjQmFja2xvZ0V4cG9uZW50ID8/IDEuMjtcbiAgICBjb25zdCBjcml0aWNhbEJhY2tsb2dHVyA9IHBhcmFtcy5jcml0aWNhbEJhY2tsb2dHVyA/PyA1MDtcbiAgICBjb25zdCBiYWNrbG9nUmF0aW8gPSBNYXRoLm1heCgwLCBiYWNrbG9nR1cgLyBjcml0aWNhbEJhY2tsb2dHVyk7XG4gICAgY29uc3Qgd2FjY011bHRpcGxpZXIgPSAxICsgd2FjY0JhY2tsb2dLICogTWF0aC5wb3coYmFja2xvZ1JhdGlvLCB3YWNjQmFja2xvZ0V4cG9uZW50KTtcbiAgICBjb25zdCB3YWNjRWZmZWN0aXZlID0gYmFzZVdhY2MgKiB3YWNjTXVsdGlwbGllcjtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgYnVpbGRvdXQgY29uc3RyYWludHNcbiAgICBjb25zdCBidWlsZG91dFBhcmFtcyA9IHtcbiAgICAgIGRlbWFuZE5ld0dXQnlZZWFyOiBkZW1hbmROZXdHVyxcbiAgICAgIGJ1aWxkYWJsZUdXQnlZZWFyOiBidWlsZGFibGVHVyxcbiAgICAgIGJhY2tsb2dHVzogYmFja2xvZ0dXLCAvLyBQYXNzIGZyb20gbW9iaWxpemF0aW9uIG1vZGVsXG4gICAgICBhdmdXYWl0WWVhcnM6IGF2Z1dhaXRZZWFycywgLy8gUGFzcyBmcm9tIG1vYmlsaXphdGlvbiBtb2RlbFxuICAgICAgYmFzZUVuZXJneVByaWNlUGVyTXdoQnlZZWFyOiBncm91bmRFbGVjdHJpY2l0eVByaWNlUGVyTXdoLFxuICAgICAgcHVlR3JvdW5kQnlZZWFyOiBlZmZlY3RpdmVQdWVHcm91bmQsXG4gICAgICB3YWNjOiB3YWNjRWZmZWN0aXZlLCAvLyBVc2UgZWZmZWN0aXZlIFdBQ0MgKHJpc2VzIHdpdGggYmFja2xvZylcbiAgICAgIHByb2plY3RMaWZldGltZVllYXJzOiBwYXJhbXMuYnVpbGRvdXRQcm9qZWN0TGlmZXRpbWVZZWFycyA/PyBQUk9KRUNUX0xJRkVUSU1FLFxuICAgICAgdmFsdWVPZlRpbWVNb2RlOiBwYXJhbXMudmFsdWVPZlRpbWVNb2RlID8/ICd3YWNjX29uX2NhcGV4JywgLy8gRGVmYXVsdCB0byB3YWNjX29uX2NhcGV4XG4gICAgICBidWlsZG91dENhcGV4QmFzZV8kUGVya1c6IHBhcmFtcy5idWlsZG91dENhcGV4QmFzZV8kUGVya1cgPz8gQlVJTERPVVRfQ0FQRVhfQkFTRSxcbiAgICAgIGJ1aWxkb3V0Q2FwZXhTY2FyY2l0eUN1cnZlOiBwYXJhbXMuYnVpbGRvdXRDYXBleFNjYXJjaXR5Q3VydmUgPz8gREVGQVVMVF9TQ0FSQ0lUWV9DVVJWRSxcbiAgICAgIHBhbmljRXhwb25lbnQ6IHBhcmFtcy5idWlsZG91dFBhbmljRXhwb25lbnQgPz8gUEFOSUNfRVhQT05FTlQsXG4gICAgICBoYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyOiBncm91bmRIYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyLCAvLyBQYXNzIGRpcmVjdGx5IChub3QgY29udmVydGVkIHRvIGtXKVxuICAgICAgc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXI6IEJBU0VfU0lURV8yMDI1LCAvLyBQYXNzIGRpcmVjdGx5IChub3QgY29udmVydGVkIHRvIGtXKVxuICAgICAgLy8gTGVnYWN5IGZpZWxkcyAoa2VwdCBmb3IgYmFja3dhcmQgY29tcGF0LCBidXQgbm90IHVzZWQgaW4gbmV3IGNhbGN1bGF0aW9uKVxuICAgICAgY29tcHV0ZUhhcmR3YXJlQ2FwZXg6IGdyb3VuZEhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXIgKiAoZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyVyAqIGNhcGFjaXR5RmFjdG9yR3JvdW5kIC8gZWZmZWN0aXZlUHVlR3JvdW5kIC8gMWU2KSxcbiAgICAgIHNpdGVDYXBleDogQkFTRV9TSVRFXzIwMjUgKiAoZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyVyAqIGNhcGFjaXR5RmFjdG9yR3JvdW5kIC8gZWZmZWN0aXZlUHVlR3JvdW5kIC8gMWU2KSxcbiAgICAgIG1hcmdpblBlckdwdUhvdXI6IDAuNSxcbiAgICAgIGFubnVhbEdwdUhvdXJzRGVsaXZlcmVkOiA4NzYwICogY2FwYWNpdHlGYWN0b3JHcm91bmQsXG4gICAgICBoeWJyaWRXZWlnaHRzOiBwYXJhbXMuYnVpbGRvdXRIeWJyaWRXZWlnaHRzID8/IHsgd2FjY1dlaWdodDogMC41LCBtYXJnaW5XZWlnaHQ6IDAuNSB9LFxuICAgIH07XG4gICAgXG4gICAgY29uc3QgYnVpbGRvdXRSZXN1bHQgPSBjYWxjdWxhdGVCdWlsZG91dENvbnN0cmFpbnRzKFxuICAgICAgbnVsbCwgLy8gU3RhdGUgaXMgbm93IG1hbmFnZWQgYnkgbW9iaWxpemF0aW9uIG1vZGVsXG4gICAgICBidWlsZG91dFBhcmFtcyxcbiAgICAgIHllYXIsXG4gICAgICBncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXLFxuICAgICAgZWZmZWN0aXZlUHVlR3JvdW5kLFxuICAgICAgY2FwYWNpdHlGYWN0b3JHcm91bmRcbiAgICApO1xuICAgIFxuICAgIC8vIEVuZXJneSBjb3N0OiBiYXNlIGVuZXJneSBvbmx5IChOT1QgYWZmZWN0ZWQgYnkgYnVpbGRvdXQgY29uc3RyYWludHMpXG4gICAgY29uc3QgZW5lcmd5Q29zdCA9IGdyb3VuZEVuZXJneUNvc3RQZXJQZmxvcFllYXI7XG4gICAgXG4gICAgLy8gU2l0ZSBjb3N0OiBiYXNlIGNhcGV4ICsgYnVpbGRvdXQgcHJlbWl1bSAoZW5naW5lZXJpbmcgY29zdCBvbmx5LCBub3Qgc2NhcmNpdHkgcHJpY2luZylcbiAgICBjb25zdCBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciA9IEJBU0VfU0lURV8yMDI1O1xuICAgIGNvbnN0IGJ1aWxkb3V0UHJlbWl1bVBlclBmbG9wWWVhciA9IGJ1aWxkb3V0UmVzdWx0LmJ1aWxkb3V0UHJlbWl1bVBlclBmbG9wWWVhcjsgLy8gQmFzZSBlbmdpbmVlcmluZyBjb3N0IG9ubHlcbiAgICBjb25zdCBkZWxheVBlbmFsdHlQZXJQZmxvcFllYXIgPSBidWlsZG91dFJlc3VsdC5kZWxheVBlbmFsdHlQZXJQZmxvcFllYXI7IC8vIExpbmVhcjogV0FDQyAqIGNhcGV4ICogd2FpdFllYXJzXG4gICAgXG4gICAgLy8gQ1JJVElDQUw6IFdhaXQtdGltZS1iYXNlZCBzY2FyY2l0eSByZW50IChFQVJMWSwgU0FUVVJBVElORylcbiAgICAvLyBEZWZpbmUgYW5udWFsaXplZCBjYXBleCBiYXNlIGZvciBzY2FyY2l0eSByZW50IGNhbGN1bGF0aW9uXG4gICAgY29uc3QgY2FwZXhBbm51YWxCYXNlUGVyUGZsb3BZZWFyID0gXG4gICAgICBncm91bmRIYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyICtcbiAgICAgIHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyICtcbiAgICAgIGJ1aWxkb3V0UHJlbWl1bVBlclBmbG9wWWVhcjsgLy8gSW5jbHVkZSBidWlsZG91dCBwcmVtaXVtIGFzIHRydWUgZW5naW5lZXJpbmcgY2FwZXhcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgc2NhcmNpdHkgbXVsdGlwbGllciB1c2luZyBMT0ctQkFTRUQgZnVuY3Rpb24gKG5ldmVyIGZ1bGx5IHNhdHVyYXRlcylcbiAgICAvLyBSZXR1cm5zIG11bHRpcGxpZXIgKDEuMCA9IG5vIHNjYXJjaXR5LCAyLjAgPSAyeCBwcmljZSkgLSBNVUxUSVBMSUNBVElWRSwgbm90IGFkZGl0aXZlXG4gICAgY29uc3QgdXRpbGl6YXRpb25QY3QgPSBjYXBhY2l0eUdXID4gMCA/IE1hdGgubWluKDEuMCwgZGVtYW5kTmV3R1cgLyBjYXBhY2l0eUdXKSA6IDEuMDtcbiAgICBjb25zdCBzY2FyY2l0eVJlbnRSZXN1bHQgPSBjYWxjdWxhdGVTY2FyY2l0eVJlbnQoXG4gICAgICBhdmdXYWl0WWVhcnMsXG4gICAgICB1dGlsaXphdGlvblBjdCwgLy8gUGFzcyB1dGlsaXphdGlvbiBmb3IgdGhyZXNob2xkIGdhdGVcbiAgICAgIHtcbiAgICAgICAgd2FpdFRocmVzaG9sZFllYXJzOiBwYXJhbXMuc2NhcmNpdHlSZW50V2FpdFRocmVzaG9sZFllYXJzID8/IDEuMCwgLy8gTWluaW11bSB3YWl0IGJlZm9yZSBzY2FyY2l0eSBhY3RpdmF0ZXNcbiAgICAgICAgcmVudE1heE11bHRpcGxpZXI6IHBhcmFtcy5zY2FyY2l0eVJlbnRNYXhNdWx0aXBsaWVyID8/IDIuMCwgLy8gTWF4aW11bSBwcmljZSBtdWx0aXBsaWVyICgyeCA9IDEwMCUgaW5jcmVhc2UpXG4gICAgICAgIHV0aWxpemF0aW9uVGhyZXNob2xkOiAwLjg1LCAvLyBVdGlsaXphdGlvbiB0aHJlc2hvbGRcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IHNjYXJjaXR5TXVsdGlwbGllciA9IHNjYXJjaXR5UmVudFJlc3VsdC5zY2FyY2l0eU11bHRpcGxpZXI7XG4gICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IHNjYXJjaXR5UmVudFBlclBmbG9wWWVhciA9IDAgKHNjYXJjaXR5IGlzIG5vdyBtdWx0aXBsaWNhdGl2ZSlcbiAgICBjb25zdCBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXIgPSAwO1xuICAgIFxuICAgIC8vIERlZmluZSB0aHJlZSB0b3RhbHM6XG4gICAgLy8gMS4gYmFzZTogZW5lcmd5ICsgc2l0ZUNhcGV4QW1vcnQgKyBidWlsZG91dFByZW1pdW0gKyBoYXJkd2FyZSAobm8gc2NhcmNpdHkgcHJpY2luZylcbiAgICAvLyAyLiBlZmZlY3RpdmU6IGluY2x1ZGVzIGRlbGF5UGVuYWx0eSArIHNjYXJjaXR5UmVudCAodXNlZCBmb3IgY3Jvc3NvdmVyKVxuICAgIC8vIDMuIGhlYWRsaW5lOiBzYW1lIGFzIGJhc2UgKGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuICAgIGNvbnN0IHNpdGVDb3N0UGVyUGZsb3BZZWFyX2Jhc2UgPSBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciArIGJ1aWxkb3V0UHJlbWl1bVBlclBmbG9wWWVhcjtcbiAgICBjb25zdCBzaXRlQ29zdFBlclBmbG9wWWVhcl9lZmZlY3RpdmUgPSBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciArIGJ1aWxkb3V0UHJlbWl1bVBlclBmbG9wWWVhciArIGRlbGF5UGVuYWx0eVBlclBmbG9wWWVhciArIHNjYXJjaXR5UmVudFBlclBmbG9wWWVhcjtcbiAgICBcbiAgICAvLyBWYWxpZGF0aW9uOiBlbnN1cmUgbm8gZG91YmxlIGNvdW50aW5nXG4gICAgaWYgKHBhcmFtcy51c2VRdWV1ZUJhc2VkQ29uc3RyYWludCAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnNvbGUud2FybihgW0JVSUxET1VUXSB1c2VRdWV1ZUJhc2VkQ29uc3RyYWludCBzaG91bGQgYmUgZmFsc2Ugd2hlbiB1c2VCdWlsZG91dE1vZGVsIGlzIHRydWUgdG8gYXZvaWQgZG91YmxlIGNvdW50aW5nYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIERvdWJsZSBjb3VudGluZyBndWFyZHJhaWxzOiBlbnN1cmUgY29uc3RyYWludE11bHRpcGxpZXIgaXMgMS4wIHdoZW4gdXNlQnVpbGRvdXRNb2RlbCBpcyB0cnVlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBpZiAoZ3JvdW5kUmVzdWx0Py5jb25zdHJhaW50TXVsdGlwbGllciAhPT0gdW5kZWZpbmVkICYmIGdyb3VuZFJlc3VsdC5jb25zdHJhaW50TXVsdGlwbGllciAhPT0gMS4wKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW0RPVUJMRSBDT1VOVElOR10gdXNlQnVpbGRvdXRNb2RlbD10cnVlIGJ1dCBjb25zdHJhaW50TXVsdGlwbGllcj0ke2dyb3VuZFJlc3VsdC5jb25zdHJhaW50TXVsdGlwbGllcn0gIT0gMS4wICh5ZWFyPSR7eWVhcn0pYCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGhhcmR3YXJlQ29zdCA9IGdyb3VuZEhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXI7XG4gICAgXG4gICAgLy8gQWRkIHJlcGxhY2VtZW50L29wcyBjb3N0cyB0byBoYXJkd2FyZSBjb3N0XG4gICAgY29uc3QgaGFyZHdhcmVDb3N0V2l0aFJlcGxhY2VtZW50ID0gaGFyZHdhcmVDb3N0ICsgcmVwbGFjZW1lbnRDb3N0UGVyUGZsb3BZZWFyICsgc3BhcmVzQ2FycnlDb3N0UGVyUGZsb3BZZWFyICsgZ3JvdW5kT3BzQ29zdFBlclBmbG9wWWVhcjtcbiAgICBcbiAgICAvLyBDb21wdXRlIHRvdGFscyAoaW5jbHVkZSByZXBsYWNlbWVudC9vcHMgaW4gYWxsKVxuICAgIGNvbnN0IGdyb3VuZFRvdGFsQ29zdF9iYXNlID0gKGVuZXJneUNvc3QgKyBzaXRlQ29zdFBlclBmbG9wWWVhcl9iYXNlICsgaGFyZHdhcmVDb3N0V2l0aFJlcGxhY2VtZW50KSAqIGdyb3VuZExhdGVuY3lQZW5hbHR5O1xuICAgIGNvbnN0IGdyb3VuZFRvdGFsQ29zdF9lZmZlY3RpdmUgPSAoZW5lcmd5Q29zdCArIHNpdGVDb3N0UGVyUGZsb3BZZWFyX2VmZmVjdGl2ZSArIGhhcmR3YXJlQ29zdFdpdGhSZXBsYWNlbWVudCkgKiBncm91bmRMYXRlbmN5UGVuYWx0eTsgLy8gSW5jbHVkZXMgZGVsYXlQZW5hbHR5ICsgc2NhcmNpdHlSZW50XG4gICAgXG4gICAgLy8gVU5JRklFRCBTQ0FSQ0lUWSBBQ0NPVU5USU5HOiBLZWVwIHRvdGFsQ29zdFBlclBmbG9wWWVhciBwaHlzaWNhbC1vbmx5XG4gICAgLy8gU2NhcmNpdHkgKGRlbGF5UGVuYWx0eSArIHNjYXJjaXR5UmVudCkgaXMgdHJlYXRlZCBwdXJlbHkgaW4gR1BVLWhvdXIgcHJpY2luZywgbm90IGluIFBGTE9QLXllYXIgY29zdFxuICAgIGdyb3VuZFRvdGFsQ29zdCA9IGdyb3VuZFRvdGFsQ29zdF9iYXNlOyAvLyBQaHlzaWNhbCBjb3N0cyBvbmx5IChzY2FyY2l0eSBpbiBHUFUtaG91cilcbiAgICBcbiAgICAvLyBEZXRlY3QgaWYgZ3JvdW5kIGhhcyBxdWV1ZS9iYWNrbG9nIChjb25zdHJhaW50cyBhcmUgYWN0aXZlKSAtIGZvciBkaWFnbm9zdGljcyBvbmx5XG4gICAgZ3JvdW5kSGFzUXVldWUgPVxuICAgICAgKGF2Z1dhaXRZZWFycyA+IDAuMDUpIHx8XG4gICAgICAoYmFja2xvZ0dXID4gMC4wNSkgfHxcbiAgICAgICgoZ3JvdW5kUmVzdWx0IGFzIGFueSk/LmJ1aWxkb3V0RGVidWc/LmJhY2tsb2dHVyA/PyAwKSA+IDAuMDU7XG4gICAgXG4gICAgLy8gRm9yIGNyb3Nzb3ZlcjogdXNlIGJhc2UgY29zdCAoc2NhcmNpdHkgaXMgYWxyZWFkeSByZWZsZWN0ZWQgaW4gR1BVLWhvdXIgcHJpY2luZylcbiAgICAvLyBUaGlzIGVuc3VyZXMgd2UgZG9uJ3QgZG91YmxlLWNvdW50IHNjYXJjaXR5XG4gICAgZ3JvdW5kQ29tcGFyYXRvckNvc3RQZXJQZmxvcFllYXIgPSBncm91bmRUb3RhbENvc3Q7IC8vIEJhc2UgY29zdCBvbmx5IChzY2FyY2l0eSBpbiBHUFUtaG91cilcbiAgICBcbiAgICBlbmVyZ3lDb25zdHJhaW50TXVsdGlwbGllciA9IDEuMDsgLy8gRW5lcmd5IE5PVCBhZmZlY3RlZCBieSBidWlsZG91dCBjb25zdHJhaW50c1xuICAgIFxuICAgIC8vIENvbnN0cmFpbnQgYnJlYWtkb3duOiBhbGwgMS4wIChubyBtdWx0aXBsaWVycywgdXNlIGJ1aWxkb3V0IHRlcm1zIGluc3RlYWQpXG4gICAgY29uc3RyYWludEJyZWFrZG93biA9IHtcbiAgICAgIGdyaWQ6IDEuMCxcbiAgICAgIGNvb2xpbmc6IDEuMCxcbiAgICAgIHdhdGVyOiAxLjAsXG4gICAgICBsYW5kOiAxLjAsXG4gICAgICBlbmVyZ3lNdWx0aXBsaWVyOiAxLjAsIC8vIEVuZXJneSBOT1QgYWZmZWN0ZWRcbiAgICAgIHNpdGVNdWx0aXBsaWVyOiAxLjAsIC8vIE5vIG11bHRpcGxpZXIsIHVzZSBidWlsZG91dCBwcmVtaXVtXG4gICAgICBjYXBhY2l0eURlbGl2ZXJ5TXVsdGlwbGllcjogMS4wLCAvLyBObyBtdWx0aXBsaWVyLCB1c2UgYnVpbGRvdXQgcHJlbWl1bVxuICAgIH07XG4gICAgXG4gICAgZ3JvdW5kUmVzdWx0ID0ge1xuICAgICAgZW5lcmd5Q29zdDogZW5lcmd5Q29zdCAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LFxuICAgICAgc2l0ZUNvc3Q6IHNpdGVDb3N0UGVyUGZsb3BZZWFyX2Jhc2UgKiBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgIGhhcmR3YXJlQ29zdDogaGFyZHdhcmVDb3N0V2l0aFJlcGxhY2VtZW50ICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICAvLyBSZXBsYWNlbWVudC9vcHMgYnJlYWtkb3duXG4gICAgICByZXBsYWNlbWVudENvc3Q6IHJlcGxhY2VtZW50Q29zdFBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LFxuICAgICAgc3BhcmVzQ2FycnlDb3N0OiBzcGFyZXNDYXJyeUNvc3RQZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgIG9wc0Nvc3Q6IGdyb3VuZE9wc0Nvc3RQZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgIHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyOiBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LFxuICAgICAgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW06IGJ1aWxkb3V0UHJlbWl1bVBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LCAvLyBCdWlsZG91dCBwcmVtaXVtIHJlcGxhY2VzIG9sZCBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVxuICAgICAgdGltZVRvRW5lcmdpemVQZW5hbHR5OiBkZWxheVBlbmFsdHlQZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSwgLy8gRGVsYXkgcGVuYWx0eSAobGluZWFyOiBXQUNDICogY2FwZXggKiB3YWl0WWVhcnMpXG4gICAgICB0b3RhbENvc3RQZXJQZmxvcFllYXI6IGdyb3VuZFRvdGFsQ29zdCwgLy8gUGh5c2ljYWwgY29zdHMgb25seSAoc2NhcmNpdHkgdHJlYXRlZCBpbiBHUFUtaG91ciBwcmljaW5nKVxuICAgICAgdG90YWxDb3N0UGVyUGZsb3BZZWFyQmFzZTogZ3JvdW5kVG90YWxDb3N0X2Jhc2UsIC8vIEJhc2UgY29zdCAobm8gc2NhcmNpdHkgcHJpY2luZylcbiAgICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhckVmZmVjdGl2ZTogZ3JvdW5kVG90YWxDb3N0LCAvLyBTYW1lIGFzIGJhc2UgKHNjYXJjaXR5IGluIEdQVS1ob3VyLCBub3QgUEZMT1AteWVhcilcbiAgICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhckFsbEluOiBncm91bmRUb3RhbENvc3QsIC8vIFNhbWUgYXMgYmFzZSAoc2NhcmNpdHkgaW4gR1BVLWhvdXIsIG5vdCBQRkxPUC15ZWFyKVxuICAgICAgLy8gRGVidWc6IHNob3cgcHJpY2luZyBjb21wb25lbnRzXG4gICAgICBwcmljaW5nQ29tcG9uZW50czoge1xuICAgICAgICBkZWxheVBlbmFsdHlXZWlnaHRlZDogZGVsYXlQZW5hbHR5V2VpZ2h0ZWQgKiBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgICAgc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyOiBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgICAgcHJpY2luZ01vZGUsXG4gICAgICAgIGRlbGF5UGVuYWx0eVdlaWdodCxcbiAgICAgICAgcmVudEZyYWM6IHNjYXJjaXR5UmVudFJlc3VsdC5yZW50RnJhYyxcbiAgICAgICAgd2FpdEVmZlllYXJzOiBzY2FyY2l0eVJlbnRSZXN1bHQud2FpdEVmZlllYXJzLFxuICAgICAgICAvLyBEZWJ1ZyBmaWVsZHMgZm9yIHNjYXJjaXR5IHJlbnQgY2FsY3VsYXRpb25cbiAgICAgICAgc2NhcmNpdHlIaWxsOiBzY2FyY2l0eVJlbnRSZXN1bHQuc2NhcmNpdHlIaWxsLFxuICAgICAgICBhdmdXYWl0WWVhcnNSYXc6IHNjYXJjaXR5UmVudFJlc3VsdC5hdmdXYWl0WWVhcnNSYXcsXG4gICAgICAgIGF2Z1dhaXRZZWFyc0NsYW1wZWQ6IHNjYXJjaXR5UmVudFJlc3VsdC5hdmdXYWl0WWVhcnNDbGFtcGVkLFxuICAgICAgfSxcbiAgICAgIGNvbnN0cmFpbnRNdWx0aXBsaWVyOiAxLjAsIC8vIE5vIGNvbnN0cmFpbnQgbXVsdGlwbGllciAtIHVzZSBidWlsZG91dCB0ZXJtc1xuICAgICAgYnJlYWtkb3duOiBjb25zdHJhaW50QnJlYWtkb3duLFxuICAgICAgc3VwcGx5TWV0cmljczoge1xuICAgICAgICBkZW1hbmRHdzogbW9iaWxpemF0aW9uUmVzdWx0LmRlbWFuZEdXLFxuICAgICAgICBjYXBhY2l0eUd3OiBjYXBhY2l0eUdXLFxuICAgICAgICBwaXBlbGluZUd3OiBwaXBlbGluZUdXLFxuICAgICAgICBtYXhCdWlsZFJhdGVHd1llYXI6IGJ1aWxkUmF0ZUdXeXIsXG4gICAgICAgIGF2Z1dhaXRZZWFyczogYXZnV2FpdFllYXJzLFxuICAgICAgICB1dGlsaXphdGlvblBjdDogY2FwYWNpdHlHVyA+IDAgPyBtb2JpbGl6YXRpb25SZXN1bHQuZGVtYW5kR1cgLyBjYXBhY2l0eUdXIDogMCxcbiAgICAgIH0sXG4gICAgICAvLyBCdWlsZG91dCBkZWJ1ZyBmaWVsZHMgKGZyb20gcmFtcGluZyBtb2JpbGl6YXRpb24gbW9kZWwpXG4gICAgICBiYWNrbG9nR3c6IGJhY2tsb2dHVyxcbiAgICAgIGF2Z1dhaXRZZWFyczogYXZnV2FpdFllYXJzLFxuICAgICAgYnVpbGRvdXREZWJ1Zzoge1xuICAgICAgICBkZW1hbmROZXdHVzogZGVtYW5kTmV3R1csXG4gICAgICAgIGJ1aWxkYWJsZUdXOiBidWlsZGFibGVHVyxcbiAgICAgICAgYnVpbGRSYXRlR1d5cjogYnVpbGRSYXRlR1d5cixcbiAgICAgICAgY2FwYWNpdHlHVzogY2FwYWNpdHlHVyxcbiAgICAgICAgcGlwZWxpbmVHVzogcGlwZWxpbmVHVyxcbiAgICAgICAgc2NhcmNpdHlJbmRleDogYnVpbGRvdXRSZXN1bHQuZmFjdG9ycy5zY2FyY2l0eUluZGV4LFxuICAgICAgICBidWlsZG91dENhcGV4XyRQZXJrVzogYnVpbGRvdXRSZXN1bHQuZmFjdG9ycy5idWlsZG91dENhcGV4XyRQZXJrVyxcbiAgICAgICAgYW5udWFsaXplZEJ1aWxkb3V0UHJlbWl1bV8kUGVya1d5cjogYnVpbGRvdXRSZXN1bHQuZmFjdG9ycy5hbm51YWxpemVkQnVpbGRvdXRQcmVtaXVtXyRQZXJrV3lyLFxuICAgICAgICB0aW1lVG9Qb3dlclllYXJzOiBhdmdXYWl0WWVhcnMsXG4gICAgICAgIHZhbHVlT2ZUaW1lXyRQZXJZZWFyOiBidWlsZG91dFJlc3VsdC5mYWN0b3JzLnZhbHVlT2ZUaW1lXyRQZXJZZWFyLFxuICAgICAgICBkZWxheVBlbmFsdHlfJFBlclllYXI6IGJ1aWxkb3V0UmVzdWx0LmZhY3RvcnMuZGVsYXlQZW5hbHR5XyRQZXJZZWFyLFxuICAgICAgICBidWlsZG91dFByZW1pdW1QZXJQZmxvcFllYXI6IGJ1aWxkb3V0UHJlbWl1bVBlclBmbG9wWWVhcixcbiAgICAgICAgZGVsYXlQZW5hbHR5UGVyUGZsb3BZZWFyOiBkZWxheVBlbmFsdHlQZXJQZmxvcFllYXIsXG4gICAgICAgIC8vIEFkZGl0aW9uYWwgbW9iaWxpemF0aW9uIGRlYnVnIGZpZWxkc1xuICAgICAgICBkZW1hbmRHVzogbW9iaWxpemF0aW9uUmVzdWx0LmRlbWFuZEdXLFxuICAgICAgICBkZW1hbmRHcm93dGhSYXRlOiBtb2JpbGl6YXRpb25SZXN1bHQuZGVtYW5kR3Jvd3RoUmF0ZSxcbiAgICAgICAgYmFja2xvZ0dXOiBtb2JpbGl6YXRpb25SZXN1bHQuYmFja2xvZ0dXLFxuICAgICAgICBhdmdXYWl0WWVhcnM6IG1vYmlsaXphdGlvblJlc3VsdC5hdmdXYWl0WWVhcnMsXG4gICAgICB9LFxuICAgICAgc21yRW5hYmxlZDogZmFsc2UsXG4gICAgICBzbXJSYW1wRmFjdG9yOiAwLFxuICAgICAgZWZmZWN0aXZlRWxlY3RyaWNpdHlDb3N0OiBncm91bmRFbGVjdHJpY2l0eVByaWNlUGVyTXdoLFxuICAgICAgY29uc3RyYWludFJlbGllZjogeyBncmlkOiAwLCBjb29saW5nOiAwLCB3YXRlcjogMCwgbGFuZDogMCB9LFxuICAgICAgY29uc3RyYWludHM6IHtcbiAgICAgICAgbWV0aG9kOiAnYWRkZXJzJyxcbiAgICAgICAgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW06IGJ1aWxkb3V0UHJlbWl1bVBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LFxuICAgICAgICBkZWxheVBlbmFsdHk6IGRlbGF5UGVuYWx0eVBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LFxuICAgICAgICBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXI6IHNjYXJjaXR5UmVudFBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LCAvLyBCYWNrd2FyZCBjb21wYXQgKG5vdyAwLCBzY2FyY2l0eSBpcyBtdWx0aXBsaWNhdGl2ZSlcbiAgICAgICAgc2NhcmNpdHlNdWx0aXBsaWVyOiBzY2FyY2l0eU11bHRpcGxpZXIsIC8vIE11bHRpcGxpY2F0aXZlIHNjYXJjaXR5ICgxLjAgPSBubyBzY2FyY2l0eSwgMi4wID0gMnggcHJpY2UpXG4gICAgICAgIGFwcGxpZWRNdWx0aXBsaWVyczoge1xuICAgICAgICAgIGNvbnN0cmFpbnRNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgICAgZW5lcmd5TXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgICAgIHNpdGVNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIHdhY2NCYXNlOiBiYXNlV2FjYyxcbiAgICAgICAgd2FjY0VmZmVjdGl2ZTogd2FjY0VmZmVjdGl2ZSxcbiAgICAgICAgcmVudEZyYWM6IHNjYXJjaXR5UmVudFJlc3VsdC5yZW50RnJhYyxcbiAgICAgICAgd2FpdFllYXJzVXNlZDogc2NhcmNpdHlSZW50UmVzdWx0LndhaXRFZmZZZWFycywgLy8gV2FpdCB0aW1lIHVzZWQgZm9yIHNjYXJjaXR5IHJlbnQgY2FsY3VsYXRpb25cbiAgICAgICAgd2FpdEVmZlllYXJzOiBzY2FyY2l0eVJlbnRSZXN1bHQud2FpdEVmZlllYXJzLCAvLyBBbGlhcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICAvLyBEZWJ1ZyBmaWVsZHMgZm9yIHNjYXJjaXR5IHJlbnQgY2FsY3VsYXRpb25cbiAgICAgICAgc2NhcmNpdHlIaWxsOiBzY2FyY2l0eVJlbnRSZXN1bHQuc2NhcmNpdHlIaWxsLFxuICAgICAgICBhdmdXYWl0WWVhcnNSYXc6IHNjYXJjaXR5UmVudFJlc3VsdC5hdmdXYWl0WWVhcnNSYXcsXG4gICAgICAgIGF2Z1dhaXRZZWFyc0NsYW1wZWQ6IHNjYXJjaXR5UmVudFJlc3VsdC5hdmdXYWl0WWVhcnNDbGFtcGVkLFxuICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgIGRvdWJsZUNvdW50Q2hlY2s6IHtcbiAgICAgICAgICAgIG1vZGU6ICdhZGRlcnMnLFxuICAgICAgICAgICAgbXVsdGlwbGllckFwcGxpZWQ6IGZhbHNlLFxuICAgICAgICAgICAgYWRkZXJzQXBwbGllZDogdHJ1ZSxcbiAgICAgICAgICAgIGludmFyaWFudE9rOiB0cnVlLFxuICAgICAgICAgICAgbm90ZXM6ICdCdWlsZG91dCBtb2RlbCB1c2VzIGFkZGVycyBvbmx5IChjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSArIGRlbGF5UGVuYWx0eSArIHNjYXJjaXR5UmVudCknLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG4gICAgXG4gICAgLy8gSW52YXJpYW50OiBJZiB1c2luZyBhZGRlcnMsIG11bHRpcGxpZXJzIG11c3Qgbm90IGJlIGFwcGxpZWRcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGNvbnN0IGhhc011bHRpcGxpZXIgPSBncm91bmRSZXN1bHQuY29uc3RyYWludE11bHRpcGxpZXIgIT09IDEuMDtcbiAgICAgIGNvbnN0IGhhc0FkZGVyID0gKGdyb3VuZFJlc3VsdC5jYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSA+IDApIHx8IChncm91bmRSZXN1bHQudGltZVRvRW5lcmdpemVQZW5hbHR5ID4gMCk7XG4gICAgICBpZiAoaGFzTXVsdGlwbGllciAmJiBoYXNBZGRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFtET1VCTEUgQ09VTlRJTkcgREVURUNURURdIFllYXIgJHt5ZWFyfTogY29uc3RyYWludE11bHRpcGxpZXI9JHtncm91bmRSZXN1bHQuY29uc3RyYWludE11bHRpcGxpZXJ9ICE9IDEuMCBgICtcbiAgICAgICAgICBgQU5EIGFkZGVycyA+IDAgKGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtPSR7Z3JvdW5kUmVzdWx0LmNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtfSwgYCArXG4gICAgICAgICAgYGRlbGF5UGVuYWx0eT0ke2dyb3VuZFJlc3VsdC50aW1lVG9FbmVyZ2l6ZVBlbmFsdHl9KS4gQm90aCBjYW5ub3QgYmUgYXBwbGllZCBzaW11bHRhbmVvdXNseS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHVzZVJlZ2lvbmFsTW9kZWwpIHtcbiAgICBjb25zdCBkZW1hbmRQZmxvcHMgPSBnZXRHbG9iYWxEZW1hbmRQZmxvcHMoeWVhciwgZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyVyk7XG4gICAgY29uc3QgcmVnaW9uYWxSZXN1bHQgPSBjYWxjdWxhdGVSZWdpb25hbEdyb3VuZENvc3QoXG4gICAgICB5ZWFyLFxuICAgICAgZGVtYW5kUGZsb3BzLFxuICAgICAgZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyVyxcbiAgICAgIGVmZmVjdGl2ZVB1ZUdyb3VuZCxcbiAgICAgIGNhcGFjaXR5RmFjdG9yR3JvdW5kLFxuICAgICAgZ3JvdW5kSGFyZHdhcmVDYXBleFBlclBmbG9wWWVhcixcbiAgICAgIHVuZGVmaW5lZCAvLyBVc2UgZGVmYXVsdCByZWdpb25zXG4gICAgKTtcbiAgICBcbiAgICAvLyBSRUZBQ1RPUkVEOiBSZWdpb25hbCBtb2RlbCAtIGVuZXJneSBjb3N0IHNob3VsZCBOT1QgaGF2ZSBjb25zdHJhaW50IG11bHRpcGxpZXJcbiAgICAvLyBSZWdpb25hbCBtb2RlbCBhbHJlYWR5IHNlcGFyYXRlcyBlbmVyZ3kgKHJhdykgZnJvbSBzaXRlICh3aXRoIGNvbnN0cmFpbnQpXG4gICAgY29uc3QgZW5lcmd5Q29zdCA9IHJlZ2lvbmFsUmVzdWx0LmVuZXJneUNvc3RQZXJQZmxvcFllYXI7IC8vIFJhdyBlbGVjdHJpY2l0eSAoTk8gY29uc3RyYWludCBtdWx0aXBsaWVyKVxuICAgIGNvbnN0IHNpdGVDb3N0ID0gcmVnaW9uYWxSZXN1bHQuc2l0ZUNvc3RQZXJQZmxvcFllYXI7IC8vIFNpdGUgY29zdHMgV0lUSCBjb25zdHJhaW50IG11bHRpcGxpZXJcbiAgICBcbiAgICAvLyBHUk9VTkQgQ09TVCBBQ0NPVU5USU5HOiBFeHBsaWNpdCBzZXBhcmF0aW9uIGZvciByZWdpb25hbCBtb2RlbFxuICAgIGNvbnN0IHNpdGVDb3N0QmFzZSA9IEJBU0VfU0lURV8yMDI1O1xuICAgIFxuICAgIC8vIDEuIHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyOiBCYXNlIHNpdGUgY2FwZXggKE5PVCBhZmZlY3RlZCBieSBjb25zdHJhaW50KVxuICAgIGNvbnN0IHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyID0gc2l0ZUNvc3RCYXNlO1xuICAgIFxuICAgIC8vIDIuIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyOiBQcmVtaXVtIGFib3ZlIGJhc2UgKGZyb20gY29uc3RyYWludCBtdWx0aXBsaWVyKVxuICAgIGNvbnN0IGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyID0gTWF0aC5tYXgoMCwgc2l0ZUNvc3QgLSBzaXRlQ29zdEJhc2UpO1xuICAgIFxuICAgIC8vIDMuIHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhcjogUmVnaW9uYWwgbW9kZWwgZG9lc24ndCBtb2RlbCBxdWV1ZSBkZWxheSBzZXBhcmF0ZWx5ICgwIGZvciBub3cpXG4gICAgY29uc3QgdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyID0gMDtcbiAgICBcbiAgICAvLyBJTlZBUklBTlQ6IHNpdGVDb3N0UGVyUGZsb3BZZWFyID0gc2l0ZUNhcGV4QW1vcnQgKyB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHkgKyBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVxuICAgIGNvbnN0IHNpdGVDb3N0UGVyUGZsb3BZZWFyID0gc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgKyB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgKyBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhcjtcbiAgICBcbiAgICAvLyBWYWxpZGF0aW9uIChhbGxvdyBzbWFsbCB0b2xlcmFuY2UgZm9yIHJlZ2lvbmFsIG1vZGVsIGFwcHJveGltYXRpb24pXG4gICAgY29uc3Qgc2l0ZUNvc3RDaGVjayA9IE1hdGguYWJzKHNpdGVDb3N0IC0gc2l0ZUNvc3RQZXJQZmxvcFllYXIpO1xuICAgIGlmIChzaXRlQ29zdENoZWNrID4gMS4wKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpdGUgY29zdCBhY2NvdW50aW5nIGVycm9yIChyZWdpb25hbCBtb2RlbCk6IHNpdGVDb3N0PSR7c2l0ZUNvc3R9ICE9IHN1bShjb21wb25lbnRzKT0ke3NpdGVDb3N0UGVyUGZsb3BZZWFyfSwgZGlmZj0ke3NpdGVDb3N0Q2hlY2t9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIENSSVRJQ0FMIEZJWDogUmVnaW9uYWwgbW9kZWwgYWxyZWFkeSBzZXBhcmF0ZXMgZW5lcmd5IChubyBtdWx0aXBsaWVyKSBmcm9tIHNpdGUgKHdpdGggcHJlbWl1bSlcbiAgICAvLyBEbyBOT1QgYXBwbHkgY29uc3RyYWludE11bHRpcGxpZXIgLSBpdCdzIGFscmVhZHkgcmVmbGVjdGVkIGluIHNpdGVDb3N0UGVyUGZsb3BZZWFyXG4gICAgY29uc3QgY29uc3RyYWludE11bHRpcGxpZXIgPSAxLjA7IC8vIE5vdCBhcHBsaWVkIC0ga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0IG9ubHlcbiAgICBcbiAgICBncm91bmRUb3RhbENvc3QgPSByZWdpb25hbFJlc3VsdC50b3RhbENvc3RQZXJQZmxvcFllYXI7XG4gICAgZ3JvdW5kSGFzUXVldWUgPSBmYWxzZTsgLy8gUmVnaW9uYWwgbW9kZWwgZG9lc24ndCBtb2RlbCBxdWV1ZSBkZWxheSBzZXBhcmF0ZWx5XG4gICAgZ3JvdW5kQ29tcGFyYXRvckNvc3RQZXJQZmxvcFllYXIgPSBncm91bmRUb3RhbENvc3Q7IC8vIFVzZSBiYXNlIGNvc3QgZm9yIHJlZ2lvbmFsIG1vZGVsXG4gICAgZW5lcmd5Q29uc3RyYWludE11bHRpcGxpZXIgPSAxLjA7IC8vIE5ldmVyIGFwcGxpZWRcbiAgICBjb25zdHJhaW50QnJlYWtkb3duID0ge1xuICAgICAgZ3JpZDogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgY29vbGluZzogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgd2F0ZXI6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIGxhbmQ6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIGVuZXJneU11bHRpcGxpZXI6IDEuMCwgLy8gTmV2ZXIgYXBwbGllZFxuICAgICAgc2l0ZU11bHRpcGxpZXI6IDEuMCwgLy8gTm90IGFwcGxpZWQgLSBjb25zdHJhaW50IGVmZmVjdHMgYWxyZWFkeSBpbiBzaXRlQ29zdFxuICAgICAgY2FwYWNpdHlEZWxpdmVyeU11bHRpcGxpZXI6IDEuMCwgLy8gTm90IGFwcGxpZWQgLSBjb25zdHJhaW50IGVmZmVjdHMgYWxyZWFkeSBpbiBzaXRlQ29zdFxuICAgIH07XG4gICAgXG4gICAgZ3JvdW5kUmVzdWx0ID0ge1xuICAgICAgZW5lcmd5Q29zdDogZW5lcmd5Q29zdCwgLy8gUmF3IGVsZWN0cmljaXR5IGNvc3QgKE5PIGNvbnN0cmFpbnQgbXVsdGlwbGllcilcbiAgICAgIHNpdGVDb3N0OiBzaXRlQ29zdFBlclBmbG9wWWVhciwgLy8gU2l0ZSA9IHN1bSBvZiBjb21wb25lbnRzIChJTlZBUklBTlQpXG4gICAgICBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhcjogc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIsIC8vIEV4cGxpY2l0OiBwdXJlIGNhcGV4XG4gICAgICBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bTogY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXIsIC8vIEV4cGxpY2l0OiBzY2FyY2l0eSBwcmVtaXVtXG4gICAgICB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHk6IHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciwgLy8gUmVnaW9uYWwgbW9kZWw6IDAgKG5vdCBtb2RlbGVkIHNlcGFyYXRlbHkpXG4gICAgICBoYXJkd2FyZUNvc3Q6IHJlZ2lvbmFsUmVzdWx0LmhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXIsXG4gICAgICB0b3RhbENvc3RQZXJQZmxvcFllYXI6IGdyb3VuZFRvdGFsQ29zdCxcbiAgICAgIGNvbnN0cmFpbnRNdWx0aXBsaWVyOiAxLjAsIC8vIE5PVCBBUFBMSUVEIC0ga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0IG9ubHlcbiAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgIG1ldGhvZDogJ2FkZGVycycsXG4gICAgICAgIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtOiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhciwgLy8gRnJvbSByZWdpb25hbCBtb2RlbCBzaXRlQ29zdCAtIHNpdGVDb3N0QmFzZVxuICAgICAgICBkZWxheVBlbmFsdHk6IDAsIC8vIFJlZ2lvbmFsIG1vZGVsIGRvZXNuJ3QgbW9kZWwgZGVsYXkgc2VwYXJhdGVseVxuICAgICAgICBhcHBsaWVkTXVsdGlwbGllcnM6IHtcbiAgICAgICAgICBjb25zdHJhaW50TXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgICAgIGVuZXJneU11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgICBzaXRlTXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgIGRvdWJsZUNvdW50Q2hlY2s6IHtcbiAgICAgICAgICAgIG1vZGU6ICdhZGRlcnMnLFxuICAgICAgICAgICAgbXVsdGlwbGllckFwcGxpZWQ6IGZhbHNlLFxuICAgICAgICAgICAgYWRkZXJzQXBwbGllZDogY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXIgPiAwLFxuICAgICAgICAgICAgaW52YXJpYW50T2s6IHRydWUsXG4gICAgICAgICAgICBub3RlczogJ1JlZ2lvbmFsIG1vZGVsIHVzZXMgYWRkZXJzIG9ubHkgKGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtIGZyb20gc2l0ZUNvc3QgLSBzaXRlQ29zdEJhc2UpJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGJyZWFrZG93bjogY29uc3RyYWludEJyZWFrZG93bixcbiAgICAgIHNtckVuYWJsZWQ6IGZhbHNlLFxuICAgICAgc21yUmFtcEZhY3RvcjogMCxcbiAgICAgIGVmZmVjdGl2ZUVsZWN0cmljaXR5Q29zdDogcmVnaW9uYWxSZXN1bHQuYXZlcmFnZUVuZXJneUNvc3RNd2gsXG4gICAgICBjb25zdHJhaW50UmVsaWVmOiB7IGdyaWQ6IDAsIGNvb2xpbmc6IDAsIHdhdGVyOiAwLCBsYW5kOiAwIH0sXG4gICAgICAvLyBFbnN1cmUgYmFja2xvZ0d3IGFuZCBhdmdXYWl0WWVhcnMgYXJlIGFsd2F5cyBzZXQgKHVzZSBzdXBwbHlNZXRyaWNzIGFzIGZhbGxiYWNrKVxuICAgICAgYmFja2xvZ0d3OiByZWdpb25hbFJlc3VsdC5zdXBwbHlNZXRyaWNzPy5waXBlbGluZUd3ID8/IDAsIC8vIFRFTVAgcHJveHk6IHVzZSBwaXBlbGluZSBhcyBwbGFjZWhvbGRlclxuICAgICAgYXZnV2FpdFllYXJzOiByZWdpb25hbFJlc3VsdC5zdXBwbHlNZXRyaWNzPy5hdmdXYWl0WWVhcnMgPz8gMCxcbiAgICAgIHN1cHBseU1ldHJpY3M6IHJlZ2lvbmFsUmVzdWx0LnN1cHBseU1ldHJpY3MgPz8ge1xuICAgICAgICBkZW1hbmRHdzogMCxcbiAgICAgICAgY2FwYWNpdHlHdzogMCxcbiAgICAgICAgcGlwZWxpbmVHdzogMCxcbiAgICAgICAgbWF4QnVpbGRSYXRlR3dZZWFyOiAwLFxuICAgICAgICBhdmdXYWl0WWVhcnM6IDAsXG4gICAgICAgIHV0aWxpemF0aW9uUGN0OiAwLFxuICAgICAgfSxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGdyb3VuZFJlc3VsdCA9IGNhbGN1bGF0ZUdyb3VuZFRvdGFsKFxuICAgICAgeWVhcixcbiAgICAgIHBhcmFtcyxcbiAgICAgIEVORVJHWV9DT1NUX0JBU0VfMjAyNSxcbiAgICAgIGdyb3VuZEhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXIsXG4gICAgICBwYXJhbXMuaXNTdGF0aWNNb2RlLFxuICAgICAgZWZmZWN0aXZlR3JvdW5kU2NlbmFyaW8sXG4gICAgICBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgIHNtclBhcmFtcyxcbiAgICAgIGZpcnN0Q2FwWWVhciA/PyBudWxsLFxuICAgICAgZ3JvdW5kRW5lcmd5Q29zdFBlclBmbG9wWWVhcixcbiAgICAgIGdyb3VuZEVsZWN0cmljaXR5UHJpY2VQZXJNd2hcbiAgICApO1xuXG4gICAgLy8gQ1JJVElDQUwgRklYOiBFbnN1cmUgYmFja2xvZ0d3IGFuZCBhdmdXYWl0WWVhcnMgYXJlIGFsd2F5cyBzZXQgKGV2ZW4gaWYgY2FsY3VsYXRlR3JvdW5kVG90YWwgZG9lc24ndCBwcm92aWRlIHRoZW0pXG4gICAgLy8gVXNlIHN1cHBseU1ldHJpY3MgYXMgZmFsbGJhY2sgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgMFxuICAgIC8vIFR5cGUgYXNzZXJ0aW9uIG5lZWRlZCBiZWNhdXNlIGNhbGN1bGF0ZUdyb3VuZFRvdGFsIG1heSBub3QgaW5jbHVkZSB0aGVzZSBmaWVsZHNcbiAgICBjb25zdCBncm91bmRSZXN1bHRXaXRoQmFja2xvZyA9IGdyb3VuZFJlc3VsdCBhcyBhbnk7XG4gICAgaWYgKCEoJ2JhY2tsb2dHdycgaW4gZ3JvdW5kUmVzdWx0V2l0aEJhY2tsb2cpIHx8IGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nLmJhY2tsb2dHdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBncm91bmRSZXN1bHRXaXRoQmFja2xvZy5iYWNrbG9nR3cgPSBncm91bmRSZXN1bHRXaXRoQmFja2xvZy5zdXBwbHlNZXRyaWNzPy5waXBlbGluZUd3ID8/IDA7IC8vIFRFTVAgcHJveHlcbiAgICB9XG4gICAgaWYgKCEoJ2F2Z1dhaXRZZWFycycgaW4gZ3JvdW5kUmVzdWx0V2l0aEJhY2tsb2cpIHx8IGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nLmF2Z1dhaXRZZWFycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBncm91bmRSZXN1bHRXaXRoQmFja2xvZy5hdmdXYWl0WWVhcnMgPSBncm91bmRSZXN1bHRXaXRoQmFja2xvZy5zdXBwbHlNZXRyaWNzPy5hdmdXYWl0WWVhcnMgPz8gMDtcbiAgICB9XG4gICAgLy8gRW5zdXJlIHN1cHBseU1ldHJpY3MgZXhpc3RzXG4gICAgaWYgKCFncm91bmRSZXN1bHRXaXRoQmFja2xvZy5zdXBwbHlNZXRyaWNzKSB7XG4gICAgICBncm91bmRSZXN1bHRXaXRoQmFja2xvZy5zdXBwbHlNZXRyaWNzID0ge1xuICAgICAgICBkZW1hbmRHdzogMCxcbiAgICAgICAgY2FwYWNpdHlHdzogMCxcbiAgICAgICAgcGlwZWxpbmVHdzogZ3JvdW5kUmVzdWx0V2l0aEJhY2tsb2cuYmFja2xvZ0d3ID8/IDAsXG4gICAgICAgIG1heEJ1aWxkUmF0ZUd3WWVhcjogMCxcbiAgICAgICAgYXZnV2FpdFllYXJzOiBncm91bmRSZXN1bHRXaXRoQmFja2xvZy5hdmdXYWl0WWVhcnMgPz8gMCxcbiAgICAgICAgdXRpbGl6YXRpb25QY3Q6IDAsXG4gICAgICB9O1xuICAgIH1cbiAgICBncm91bmRSZXN1bHQgPSBncm91bmRSZXN1bHRXaXRoQmFja2xvZztcblxuICAgIGdyb3VuZFRvdGFsQ29zdCA9IGdyb3VuZFJlc3VsdC50b3RhbENvc3RQZXJQZmxvcFllYXI7XG4gICAgZ3JvdW5kSGFzUXVldWUgPSAoZ3JvdW5kUmVzdWx0LnRpbWVUb0VuZXJnaXplUGVuYWx0eSA/PyAwKSA+IDAuMDE7IC8vIENoZWNrIGlmIGRlbGF5IHBlbmFsdHkgZXhpc3RzXG4gICAgZ3JvdW5kQ29tcGFyYXRvckNvc3RQZXJQZmxvcFllYXIgPSBncm91bmRIYXNRdWV1ZVxuICAgICAgPyAoZ3JvdW5kUmVzdWx0LnRvdGFsQ29zdFBlclBmbG9wWWVhckVmZmVjdGl2ZSA/PyBncm91bmRSZXN1bHQudG90YWxDb3N0UGVyUGZsb3BZZWFyKVxuICAgICAgOiBncm91bmRUb3RhbENvc3Q7XG4gICAgLy8gQ1JJVElDQUwgRklYOiBOZXZlciBhcHBseSBtdWx0aXBsaWVycyAtIGFsbCBzZXQgdG8gMS4wXG4gICAgZW5lcmd5Q29uc3RyYWludE11bHRpcGxpZXIgPSAxLjA7IC8vIE5ldmVyIGFwcGxpZWRcbiAgICBcbiAgICAvLyBJbnZhcmlhbnQ6IElmIHVzaW5nIGFkZGVycywgbXVsdGlwbGllcnMgbXVzdCBub3QgYmUgYXBwbGllZFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBncm91bmRSZXN1bHQuY29uc3RyYWludHMpIHtcbiAgICAgIGNvbnN0IGhhc011bHRpcGxpZXIgPSBncm91bmRSZXN1bHQuY29uc3RyYWludE11bHRpcGxpZXIgIT09IDEuMDtcbiAgICAgIGNvbnN0IGhhc0FkZGVyID0gKGdyb3VuZFJlc3VsdC5jb25zdHJhaW50cy5jYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSA+IDApIHx8IChncm91bmRSZXN1bHQuY29uc3RyYWludHMuZGVsYXlQZW5hbHR5ID4gMCk7XG4gICAgICBpZiAoaGFzTXVsdGlwbGllciAmJiBoYXNBZGRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFtET1VCTEUgQ09VTlRJTkcgREVURUNURURdIFllYXIgJHt5ZWFyfTogY29uc3RyYWludE11bHRpcGxpZXI9JHtncm91bmRSZXN1bHQuY29uc3RyYWludE11bHRpcGxpZXJ9ICE9IDEuMCBgICtcbiAgICAgICAgICBgQU5EIGFkZGVycyA+IDAgKGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtPSR7Z3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRzLmNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtfSwgYCArXG4gICAgICAgICAgYGRlbGF5UGVuYWx0eT0ke2dyb3VuZFJlc3VsdC5jb25zdHJhaW50cy5kZWxheVBlbmFsdHl9KS4gQm90aCBjYW5ub3QgYmUgYXBwbGllZCBzaW11bHRhbmVvdXNseS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0cmFpbnRCcmVha2Rvd24gPSB7XG4gICAgICBncmlkOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICBjb29saW5nOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICB3YXRlcjogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgbGFuZDogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgZW5lcmd5TXVsdGlwbGllcjogMS4wLCAvLyBOZXZlciBhcHBsaWVkXG4gICAgICBzaXRlTXVsdGlwbGllcjogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgY2FwYWNpdHlEZWxpdmVyeU11bHRpcGxpZXI6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICB9O1xuICAgIFxuICAgIC8vIEludmFyaWFudDogQ2hlY2sgZm9yIGRvdWJsZSBjb3VudGluZ1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgY29uc3QgaGFzTXVsdGlwbGllciA9IChncm91bmRSZXN1bHQuY29uc3RyYWludE11bHRpcGxpZXIgIT09IDEuMCkgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoZ3JvdW5kUmVzdWx0LmJyZWFrZG93bi5lbmVyZ3lNdWx0aXBsaWVyICE9PSAxLjApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoZ3JvdW5kUmVzdWx0LmJyZWFrZG93bi5zaXRlTXVsdGlwbGllciAhPT0gMS4wKTtcbiAgICAgIGNvbnN0IGhhc1ByZW1pdW0gPSAoZ3JvdW5kUmVzdWx0LmNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtIHx8IDApID4gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGdyb3VuZFJlc3VsdC50aW1lVG9FbmVyZ2l6ZVBlbmFsdHkgfHwgMCkgPiAwO1xuICAgICAgaWYgKGhhc011bHRpcGxpZXIgJiYgaGFzUHJlbWl1bSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFtET1VCTEUgQ09VTlRJTkcgREVURUNURURdIFllYXIgJHt5ZWFyfTogYCArXG4gICAgICAgICAgYE11bHRpcGxpZXJzIChjb25zdHJhaW50PSR7Z3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRNdWx0aXBsaWVyfSwgYCArXG4gICAgICAgICAgYGVuZXJneT0ke2dyb3VuZFJlc3VsdC5icmVha2Rvd24uZW5lcmd5TXVsdGlwbGllcn0sIGAgK1xuICAgICAgICAgIGBzaXRlPSR7Z3JvdW5kUmVzdWx0LmJyZWFrZG93bi5zaXRlTXVsdGlwbGllcn0pIEFORCBgICtcbiAgICAgICAgICBgcHJlbWl1bXMgKGNhcGFjaXR5PSR7Z3JvdW5kUmVzdWx0LmNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtfSwgYCArXG4gICAgICAgICAgYGRlbGF5PSR7Z3JvdW5kUmVzdWx0LnRpbWVUb0VuZXJnaXplUGVuYWx0eX0pIGFyZSBib3RoIHByZXNlbnQuIGAgK1xuICAgICAgICAgIGBUaGlzIGluZGljYXRlcyBkb3VibGUgY291bnRpbmcuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGxhdW5jaENvc3RQZXJLZyA9IGdldExhdW5jaENvc3RQZXJLZyh5ZWFyLCBiYXNlTGF1bmNoQ29zdCkgKiBsYXVuY2hEaXNjb3VudDtcbiAgY29uc3QgbGlmZXRpbWVZZWFycyA9IDY7XG4gIFxuICAvLyBGdXNpb24gdG9nZ2xlIHBhcmFtc1xuICBjb25zdCBmdXNpb25QYXJhbXMgPSBwYXJhbXMuZnVzaW9uVG9nZ2xlRW5hYmxlZCBcbiAgICA/IChwYXJhbXMuZnVzaW9uVG9nZ2xlUGFyYW1zIHx8IHsgLi4uREVGQVVMVF9GVVNJT05fUEFSQU1TLCBlbmFibGVkOiB0cnVlIH0pXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgLy8gQ09OU1RFTExBVElPTiBTSVpJTkc6IERlc2lnbiBjb25zdGVsbGF0aW9uIHRvIG1lZXQgY29tcHV0ZSByZXF1aXJlbWVudHNcbiAgLy8gQ29udmVydCB0YXJnZXQgY29tcHV0ZSAoR1cpIHRvIHBvd2VyIChrVykgZm9yIGNvbnN0ZWxsYXRpb24gc2l6aW5nXG4gIGNvbnN0IHRhcmdldENvbXB1dGVLdyA9IHNhdGVsbGl0ZVBvd2VyS1c7XG4gIGxldCBjb25zdGVsbGF0aW9uID0gZGVzaWduQ29uc3RlbGxhdGlvbihcbiAgICB0YXJnZXRDb21wdXRlS3csXG4gICAgU0FURUxMSVRFX0NPTlNUUkFJTlRTLFxuICAgIDEwMDAwMCwgLy8gU3RhcnNoaXA6IDEwMHQgdG8gTEVPXG4gICAgdHJhalNwZWNpZmljUG93ZXJcbiAgKTtcbiAgXG4gIC8vIFVzZSBwZXItc2F0ZWxsaXRlIGNvbXB1dGUgcG93ZXIgZm9yIGNvc3QgY2FsY3VsYXRpb25cbiAgbGV0IGNvbXB1dGVQb3dlclBlclNhdEt3ID0gY29uc3RlbGxhdGlvbi5jb21wdXRlUGVyU2F0S3c7XG5cbiAgbGV0IGh5YnJpZFJlc3VsdCA9IGNvbXB1dGVTYXRlbGxpdGVIeWJyaWRDb3N0KFxuICAgIHllYXIsIFxuICAgIGxhdW5jaENvc3RQZXJLZywgXG4gICAge1xuICAgICAgLi4uREVGQVVMVF9DT05GSUcsXG4gICAgICBjb21wdXRlUG93ZXJLdzogY29tcHV0ZVBvd2VyUGVyU2F0S3csIC8vIFVzZSBwZXItc2F0ZWxsaXRlIHBvd2VyXG4gICAgICBhbHRpdHVkZUttOiBvcmJpdGFsQWx0aXR1ZGUsXG4gICAgICBsaWZldGltZVllYXJzOiBsaWZldGltZVllYXJzLFxuICAgICAgc3BlY2lmaWNQb3dlcldLZzogdHJhalNwZWNpZmljUG93ZXIsXG4gICAgICB1c2VSYWRIYXJkQ2hpcHM6IHVzZVJhZEhhcmRDaGlwcyxcbiAgICAgIHN1bkZyYWN0aW9uOiBzdW5GcmFjdGlvbixcbiAgICAgIHdvcmtsb2FkVHlwZTogd29ya2xvYWRUeXBlIHx8ICdpbmZlcmVuY2UnXG4gICAgfSwgXG4gICAgZnVzaW9uUGFyYW1zLFxuICAgIHBhcmFtcy51c2VDb3JyZWN0ZWRTcGVjaWZpY1Bvd2VyLFxuICAgIHBhcmFtcy51c2VDb3JyZWN0ZWRUaGVybWFsXG4gICk7XG4gIFxuICAvLyBDUklUSUNBTCBGSVg6IENhbGN1bGF0ZSBkZWxpdmVyZWQgZWZmaWNpZW5jeSB3aXRoIEFMTCBkZWxpdmVyeSBkZXJhdGVzXG4gIC8vIGRlbGl2ZXJlZCA9IHN5c3RlbUVmZmVjdGl2ZSAqIHRoZXJtYWxDYXBGYWN0b3IgKiByYWRpYXRpb25EZXJhdGUgKiBhdmFpbGFiaWxpdHlcbiAgLy8gU2luZ2xlIHNvdXJjZSBvZiB0cnV0aCBmb3IgYWxsIHRocmVlIGZhY3RvcnM6XG4gIGNvbnN0IHRoZXJtYWxDYXBGYWN0b3IgPSBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS50aGVybWFsQ2FwRmFjdG9yO1xuICBjb25zdCByYWRpYXRpb25EZXJhdGUgPSBoeWJyaWRSZXN1bHQuZGVncmFkYXRpb25GYWN0b3IgfHwgMS4wOyAvLyBIYXJkd2FyZSBkZWdyYWRhdGlvbiBmcm9tIHJhZGlhdGlvbiAoY2hpcCBmYWlsdXJlcywgRUNDIG92ZXJoZWFkKVxuICBjb25zdCBhdmFpbGFiaWxpdHkgPSBoeWJyaWRSZXN1bHQuY2FwYWNpdHlGYWN0b3IgfHwgMS4wOyAvLyBDYXBhY2l0eSBmYWN0b3IgaXMgdXB0aW1lLWluY2x1c2l2ZSAoaW5jbHVkZXMgZWNsaXBzZSwgZGVncmFkYXRpb24sIHJhZGlhdGlvbiBkb3dudGltZSwgdXB0aW1lKVxuICBcbiAgLy8gQ2FsY3VsYXRlIGRlbGl2ZXJlZCBlZmZpY2llbmN5IChhbGwgZGVyYXRlcyBhcHBsaWVkIG11bHRpcGxpY2F0aXZlbHkpXG4gIC8vIFRoaXMgaXMgdGhlIHRydWUgXCJkZWxpdmVyZWRcIiBlZmZpY2llbmN5IHRoYXQgYWNjb3VudHMgZm9yIGFsbCBvcGVyYXRpb25hbCBjb25zdHJhaW50c1xuICBsZXQgb3JiaXREZWxpdmVyZWRHZmxvcHNQZXJXYXR0ID0gb3JiaXRTeXN0ZW1FZmZlY3RpdmVHZmxvcHNQZXJXYXR0ICogdGhlcm1hbENhcEZhY3RvciAqIHJhZGlhdGlvbkRlcmF0ZSAqIGF2YWlsYWJpbGl0eTtcbiAgXG4gIC8vIENSSVRJQ0FMOiBJZiB0aGVybWFsIGNvbnN0cmFpbnQgY2F1c2VzIGRlbGl2ZXJlZCBlZmZpY2llbmN5IHRvIGRyb3AgYmVsb3cgbWluaW11bSAoMjAgR0ZMT1BTL1cpLFxuICAvLyB0aGlzIGluZGljYXRlcyBhIHNldmVyZSB0aGVybWFsIGNvbnN0cmFpbnQgdGhhdCBzaG91bGQgYmUgaGFuZGxlZCBieSBleHBhbmRpbmcgcmFkaWF0b3Igb3IgcmVkdWNpbmcgY29tcHV0ZVxuICAvLyBGb3Igbm93LCB3ZSBjbGFtcCB0byBtaW5pbXVtIHRvIHByZXZlbnQgdmFsaWRhdGlvbiBlcnJvcnMsIGJ1dCBsb2cgYSB3YXJuaW5nIChvbmx5IG9uY2UgcGVyIHllYXIpXG4gIGlmIChvcmJpdERlbGl2ZXJlZEdmbG9wc1BlcldhdHQgPCBDT05TVEFOVFMuTUlOX0RFTElWRVJFRF9HRkxPUFNfUEVSX1cpIHtcbiAgICBjb25zdCBvcmlnaW5hbERlbGl2ZXJlZCA9IG9yYml0RGVsaXZlcmVkR2Zsb3BzUGVyV2F0dDtcbiAgICBvcmJpdERlbGl2ZXJlZEdmbG9wc1BlcldhdHQgPSBDT05TVEFOVFMuTUlOX0RFTElWRVJFRF9HRkxPUFNfUEVSX1c7XG4gICAgXG4gICAgLy8gTG9nIHdhcm5pbmcgYWJvdXQgc2V2ZXJlIHRoZXJtYWwgY29uc3RyYWludCAob25seSBpbiBkZXYsIGFuZCBvbmx5IG9uY2UgcGVyIHllYXIgdG8gcmVkdWNlIHNwYW0pXG4gICAgLy8gVGhlIGFjdHVhbCBjbGFtcGVkIHZhbHVlIGlzIGF2YWlsYWJsZSBpbiBvcmJpdC5jb21wdXRlRWZmaWNpZW5jeS52YWxpZGF0aW9uIG1ldGFkYXRhXG4gICAgLy8gVGhlcm1hbCBjb25zdHJhaW50IHdhcm5pbmdzIHJlbW92ZWQgZm9yIGNsZWFuZXIgY29uc29sZSBvdXRwdXRcbiAgfVxuICBcbiAgLy8gVXNlIGRlbGl2ZXJlZCBlZmZpY2llbmN5IGZvciBhbGwgY29zdCBjYWxjdWxhdGlvbnNcbiAgbGV0IG9yYml0RWZmZWN0aXZlR2Zsb3BzUGVyVyA9IHZhbGlkYXRlR2Zsb3BzUGVyV2F0dChcbiAgICBvcmJpdERlbGl2ZXJlZEdmbG9wc1BlcldhdHQsXG4gICAgJ29yYml0YWwgZGVsaXZlcmVkIGVmZmljaWVuY3kgY2FsY3VsYXRpb24nXG4gICk7XG4gIFxuICAvLyBQb3dlciBzY2FsaW5nIGNhbGN1bGF0aW9uXG4gIGNvbnN0IHBvd2VyU2NhbGluZ1BhcmFtcyA9IHBhcmFtcy5wb3dlclNjYWxpbmdQYXJhbXMgfHwgREVGQVVMVF9QT1dFUl9TQ0FMSU5HO1xuICBjb25zdCBzY2FsaW5nUmVzdWx0ID0gY2FsY3VsYXRlU2NhbGVkTWFzcyhjb21wdXRlUG93ZXJQZXJTYXRLdywgcG93ZXJTY2FsaW5nUGFyYW1zKTtcblxuICAvLyBDT05TVEVMTEFUSU9OIFNDQUxJTkc6IEFwcGx5IGNvbnN0ZWxsYXRpb24gbXVsdGlwbGllciB0byBtYXNzIGFuZCBjb3N0c1xuICAvLyBQZXItc2F0ZWxsaXRlIG1hc3MgKGFscmVhZHkgY2FsY3VsYXRlZCBmb3Igb25lIHNhdGVsbGl0ZSlcbiAgbGV0IG1hc3NQZXJTYXRLZyA9IGh5YnJpZFJlc3VsdC50b3RhbE1hc3NLZyAqIG1hc3NNdWx0aXBsaWVyO1xuICBcbiAgLy8gQ1JJVElDQUwgRklYOiBDaGVjayBpZiBhY3R1YWwgbWFzcyBleGNlZWRzIGxpbWl0IGFuZCByZS1zcGxpdCBjb25zdGVsbGF0aW9uIGlmIG5lZWRlZFxuICAvLyBUaGUgc2ltcGxpZmllZCBtYXNzIG1vZGVsIGluIGRlc2lnbkNvbnN0ZWxsYXRpb24gbWF5IHVuZGVyZXN0aW1hdGUgYWN0dWFsIG1hc3NcbiAgLy8gSWYgYWN0dWFsIG1hc3MgZXhjZWVkcyBsaW1pdCwgd2UgbmVlZCB0byBzcGxpdCBpbnRvIHNtYWxsZXIgc2F0ZWxsaXRlc1xuICBjb25zdCBNQVhfU0FURUxMSVRFX01BU1NfS0cgPSBTQVRFTExJVEVfQ09OU1RSQUlOVFMubWF4TWFzc0tnOyAvLyAxMCwwMDAga2cgZnJvbSBjb25zdHJhaW50c1xuICBpZiAobWFzc1BlclNhdEtnID4gTUFYX1NBVEVMTElURV9NQVNTX0tHKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHJlcXVpcmVkIGNvbXB1dGUgcGVyIHNhdGVsbGl0ZSB0byBzdGF5IHVuZGVyIG1hc3MgbGltaXRcbiAgICAvLyBNYXNzIHNjYWxlcyByb3VnaGx5IHdpdGggY29tcHV0ZSBwb3dlciwgc286IG1hc3NQZXJTYXRLZyAvIGNvbXB1dGVQb3dlclBlclNhdEt3ID0gbWFzc1Blckt3XG4gICAgY29uc3QgbWFzc1Blckt3ID0gbWFzc1BlclNhdEtnIC8gY29tcHV0ZVBvd2VyUGVyU2F0S3c7XG4gICAgY29uc3QgbWF4Q29tcHV0ZVBlclNhdEt3ID0gTUFYX1NBVEVMTElURV9NQVNTX0tHIC8gbWFzc1Blckt3O1xuICAgIFxuICAgIC8vIFJlY2FsY3VsYXRlIGNvbnN0ZWxsYXRpb24gd2l0aCBzbWFsbGVyIHNhdGVsbGl0ZXNcbiAgICBjb25zdCBhZGp1c3RlZENvbnN0ZWxsYXRpb24gPSBkZXNpZ25Db25zdGVsbGF0aW9uKFxuICAgICAgdGFyZ2V0Q29tcHV0ZUt3LFxuICAgICAge1xuICAgICAgICAuLi5TQVRFTExJVEVfQ09OU1RSQUlOVFMsXG4gICAgICAgIG1heENvbXB1dGVLdzogbWF4Q29tcHV0ZVBlclNhdEt3ICogMC45LCAvLyBVc2UgOTAlIG9mIG1heCB0byBsZWF2ZSBtYXJnaW5cbiAgICAgIH0sXG4gICAgICAxMDAwMDAsIC8vIFN0YXJzaGlwOiAxMDB0IHRvIExFT1xuICAgICAgdHJhalNwZWNpZmljUG93ZXJcbiAgICApO1xuICAgIFxuICAgIC8vIFJlY2FsY3VsYXRlIGh5YnJpZCBjb3N0IHdpdGggYWRqdXN0ZWQgY29tcHV0ZSBwZXIgc2F0ZWxsaXRlXG4gICAgY29uc3QgYWRqdXN0ZWRIeWJyaWRSZXN1bHQgPSBjb21wdXRlU2F0ZWxsaXRlSHlicmlkQ29zdChcbiAgICAgIHllYXIsIFxuICAgICAgbGF1bmNoQ29zdFBlcktnLCBcbiAgICAgIHtcbiAgICAgICAgLi4uREVGQVVMVF9DT05GSUcsXG4gICAgICAgIGNvbXB1dGVQb3dlckt3OiBhZGp1c3RlZENvbnN0ZWxsYXRpb24uY29tcHV0ZVBlclNhdEt3LFxuICAgICAgICBhbHRpdHVkZUttOiBvcmJpdGFsQWx0aXR1ZGUsXG4gICAgICAgIGxpZmV0aW1lWWVhcnM6IGxpZmV0aW1lWWVhcnMsXG4gICAgICAgIHNwZWNpZmljUG93ZXJXS2c6IHRyYWpTcGVjaWZpY1Bvd2VyLFxuICAgICAgICB1c2VSYWRIYXJkQ2hpcHM6IHVzZVJhZEhhcmRDaGlwcyxcbiAgICAgICAgc3VuRnJhY3Rpb246IHN1bkZyYWN0aW9uLFxuICAgICAgICB3b3JrbG9hZFR5cGU6IHdvcmtsb2FkVHlwZSB8fCAnaW5mZXJlbmNlJ1xuICAgICAgfSwgXG4gICAgICBmdXNpb25QYXJhbXMsXG4gICAgICBwYXJhbXMudXNlQ29ycmVjdGVkU3BlY2lmaWNQb3dlcixcbiAgICAgIHBhcmFtcy51c2VDb3JyZWN0ZWRUaGVybWFsXG4gICAgKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgd2l0aCBhZGp1c3RlZCB2YWx1ZXNcbiAgICBjb25zdCBhZGp1c3RlZE1hc3NQZXJTYXRLZyA9IGFkanVzdGVkSHlicmlkUmVzdWx0LnRvdGFsTWFzc0tnICogbWFzc011bHRpcGxpZXI7XG4gICAgaWYgKGFkanVzdGVkTWFzc1BlclNhdEtnID4gTUFYX1NBVEVMTElURV9NQVNTX0tHKSB7XG4gICAgICAvLyBTdGlsbCB0b28gaGVhdnkgLSB0aGlzIHNob3VsZG4ndCBoYXBwZW4sIGJ1dCBsb2cgYSB3YXJuaW5nXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBTYXRlbGxpdGUgbWFzcyAke2FkanVzdGVkTWFzc1BlclNhdEtnLnRvRml4ZWQoMCl9a2cgc3RpbGwgZXhjZWVkcyBsaW1pdCAke01BWF9TQVRFTExJVEVfTUFTU19LR31rZyBgICtcbiAgICAgICAgYGV2ZW4gYWZ0ZXIgc3BsaXR0aW5nIHRvICR7YWRqdXN0ZWRDb25zdGVsbGF0aW9uLmNvbXB1dGVQZXJTYXRLdy50b0ZpeGVkKDEpfWtXIHBlciBzYXRlbGxpdGUuIGAgK1xuICAgICAgICBgQ29uc2lkZXIgZnVydGhlciByZWR1Y2luZyBjb21wdXRlIHBlciBzYXRlbGxpdGUgb3IgaW1wcm92aW5nIHNwZWNpZmljIHBvd2VyLmBcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVzZSBhZGp1c3RlZCBjb25zdGVsbGF0aW9uIGFuZCBoeWJyaWQgcmVzdWx0XG4gICAgY29uc3RlbGxhdGlvbiA9IGFkanVzdGVkQ29uc3RlbGxhdGlvbjtcbiAgICBoeWJyaWRSZXN1bHQgPSBhZGp1c3RlZEh5YnJpZFJlc3VsdDtcbiAgICBjb21wdXRlUG93ZXJQZXJTYXRLdyA9IGFkanVzdGVkQ29uc3RlbGxhdGlvbi5jb21wdXRlUGVyU2F0S3c7XG4gICAgbWFzc1BlclNhdEtnID0gYWRqdXN0ZWRNYXNzUGVyU2F0S2c7XG4gICAgXG4gICAgLy8gUmVjYWxjdWxhdGUgZGVsaXZlcmVkIGVmZmljaWVuY3kgd2l0aCBhZGp1c3RlZCB0aGVybWFsIGNhcCAoYWxsIGRlcmF0ZXMgYXBwbGllZClcbiAgICBjb25zdCBhZGp1c3RlZFRoZXJtYWxDYXBGYWN0b3IgPSBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS50aGVybWFsQ2FwRmFjdG9yO1xuICAgIGNvbnN0IGFkanVzdGVkUmFkaWF0aW9uRGVyYXRlID0gaHlicmlkUmVzdWx0LmRlZ3JhZGF0aW9uRmFjdG9yIHx8IDEuMDtcbiAgICBjb25zdCBhZGp1c3RlZEF2YWlsYWJpbGl0eSA9IGh5YnJpZFJlc3VsdC5jYXBhY2l0eUZhY3RvciB8fCAxLjA7XG4gICAgbGV0IGFkanVzdGVkRGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCA9IG9yYml0U3lzdGVtRWZmZWN0aXZlR2Zsb3BzUGVyV2F0dCAqIGFkanVzdGVkVGhlcm1hbENhcEZhY3RvciAqIGFkanVzdGVkUmFkaWF0aW9uRGVyYXRlICogYWRqdXN0ZWRBdmFpbGFiaWxpdHk7XG4gICAgXG4gICAgLy8gQ2xhbXAgdG8gbWluaW11bSBpZiB0aGVybWFsIGNvbnN0cmFpbnQgaXMgdG9vIHNldmVyZVxuICAgIGlmIChhZGp1c3RlZERlbGl2ZXJlZEdmbG9wc1BlcldhdHQgPCBDT05TVEFOVFMuTUlOX0RFTElWRVJFRF9HRkxPUFNfUEVSX1cpIHtcbiAgICAgIGFkanVzdGVkRGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCA9IENPTlNUQU5UUy5NSU5fREVMSVZFUkVEX0dGTE9QU19QRVJfVztcbiAgICB9XG4gICAgXG4gICAgb3JiaXRFZmZlY3RpdmVHZmxvcHNQZXJXID0gdmFsaWRhdGVHZmxvcHNQZXJXYXR0KFxuICAgICAgYWRqdXN0ZWREZWxpdmVyZWRHZmxvcHNQZXJXYXR0LFxuICAgICAgJ29yYml0YWwgZGVsaXZlcmVkIGVmZmljaWVuY3kgKGFmdGVyIGNvbnN0ZWxsYXRpb24gc3BsaXQpJ1xuICAgICk7XG4gIH1cbiAgXG4gIC8vIFNjYWxlIGNvc3RzIGJ5IG51bWJlciBvZiBzYXRlbGxpdGVzIGFuZCBhcHBseSBjb25zdGVsbGF0aW9uIG92ZXJoZWFkXG4gIC8vIENhbGN1bGF0ZSBBRlRFUiBtYXNzIGNoZWNrIHNvIHdlIHVzZSB0aGUgYWRqdXN0ZWQgY29uc3RlbGxhdGlvbiBpZiBpdCB3YXMgc3BsaXRcbiAgY29uc3QgY29uc3RlbGxhdGlvbk11bHRpcGxpZXIgPSBjb25zdGVsbGF0aW9uLm51bVNhdGVsbGl0ZXM7XG4gIGNvbnN0IGNvbnN0ZWxsYXRpb25PdmVyaGVhZE11bHRpcGxpZXIgPSBjb25zdGVsbGF0aW9uLmNvbnN0ZWxsYXRpb25PdmVyaGVhZDtcbiAgXG4gIC8vIFRvdGFsIGNvbnN0ZWxsYXRpb24gbWFzc1xuICBjb25zdCBlZmZlY3RpdmVUb3RhbE1hc3NLZyA9IG1hc3NQZXJTYXRLZyAqIGNvbnN0ZWxsYXRpb24ubnVtU2F0ZWxsaXRlcztcbiAgY29uc3QgZWZmZWN0aXZlVG90YWxMYXVuY2hDb3N0ID0gZWZmZWN0aXZlVG90YWxNYXNzS2cgKiBsYXVuY2hDb3N0UGVyS2c7XG5cbiAgLy8gQXBwbHkgRWxvbiBTY2VuYXJpbzogRGlzY291bnRzXG4gIGNvbnN0IGVmZmVjdGl2ZVBvd2VyRmFiQ29zdCA9IGh5YnJpZFJlc3VsdC5wb3dlclN5c3RlbS5mYWJDb3N0VXNkICogcG93ZXJEaXNjb3VudDtcbiAgY29uc3QgZWZmZWN0aXZlTmV0d29ya2luZ0ZhYkNvc3QgPSBoeWJyaWRSZXN1bHQubmV0d29ya2luZy5mYWJDb3N0VXNkICogbmV0d29ya2luZ0Rpc2NvdW50O1xuICBjb25zdCBlZmZlY3RpdmVOZXR3b3JraW5nT3BFeCA9IChoeWJyaWRSZXN1bHQubmV0d29ya2luZy5hbm51YWxPcEV4VXNkIHx8IDApICogbmV0d29ya2luZ0Rpc2NvdW50O1xuXG4gIC8vIEVmZmVjdGl2ZSBQRkxPUHM6IHBlci1zYXRlbGxpdGUgUEZMT1BzIMOXIG51bWJlciBvZiBzYXRlbGxpdGVzXG4gIGNvbnN0IGVmZmVjdGl2ZVBmbG9wc1BlclNhdCA9IGh5YnJpZFJlc3VsdC5lZmZlY3RpdmVQZmxvcHM7XG4gIGNvbnN0IHRvdGFsRWZmZWN0aXZlUGZsb3BzID0gZWZmZWN0aXZlUGZsb3BzUGVyU2F0ICogY29uc3RlbGxhdGlvbi5udW1TYXRlbGxpdGVzO1xuICBcbiAgLy8gTGF1bmNoIGNvc3Q6IHRvdGFsIGNvbnN0ZWxsYXRpb24gbGF1bmNoIGNvc3QgLyB0b3RhbCBQRkxPUHNcbiAgY29uc3QgbGF1bmNoQ29zdFBlclBmbG9wWWVhciA9IGVmZmVjdGl2ZVRvdGFsTGF1bmNoQ29zdCAvIHRvdGFsRWZmZWN0aXZlUGZsb3BzIC8gbGlmZXRpbWVZZWFycztcblxuICAvLyBDUklUSUNBTCBGSVggMTogQ29zdCBBY2NvdW50aW5nIC0gZW5zdXJlIGJyZWFrZG93biBzdW1zIHRvIHRvdGFsXG4gIC8vIENhbGN1bGF0ZSBlYWNoIGNvbXBvbmVudCBleHBsaWNpdGx5LCBzY2FsZWQgYnkgY29uc3RlbGxhdGlvblxuICAvLyBQZXItc2F0ZWxsaXRlIGNvc3RzIMOXIG51bWJlciBvZiBzYXRlbGxpdGVzIMOXIGNvbnN0ZWxsYXRpb24gb3ZlcmhlYWRcbiAgY29uc3QgY29uc3RlbGxhdGlvbkNvc3RNdWx0aXBsaWVyID0gY29uc3RlbGxhdGlvbi5udW1TYXRlbGxpdGVzICogY29uc3RlbGxhdGlvbk92ZXJoZWFkTXVsdGlwbGllcjtcbiAgXG4gIGNvbnN0IHBvd2VyQ29zdCA9IChlZmZlY3RpdmVQb3dlckZhYkNvc3QgKiBjb25zdGVsbGF0aW9uQ29zdE11bHRpcGxpZXIpIC8gdG90YWxFZmZlY3RpdmVQZmxvcHMgLyBsaWZldGltZVllYXJzO1xuICBjb25zdCBjb21wdXRlQ29zdCA9ICgoaHlicmlkUmVzdWx0LmNvbXB1dGVQYXlsb2FkLmNoaXBDb3N0VXNkICsgaHlicmlkUmVzdWx0LmNvbXB1dGVQYXlsb2FkLnF1YWxpZmljYXRpb25Db3N0VXNkKSAqIGNvbnN0ZWxsYXRpb25Db3N0TXVsdGlwbGllcikgLyB0b3RhbEVmZmVjdGl2ZVBmbG9wcyAvIGxpZmV0aW1lWWVhcnM7XG4gIGNvbnN0IHRoZXJtYWxDb3N0ID0gKGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLmZhYkNvc3RVc2QgKiBjb25zdGVsbGF0aW9uQ29zdE11bHRpcGxpZXIpIC8gdG90YWxFZmZlY3RpdmVQZmxvcHMgLyBsaWZldGltZVllYXJzO1xuICBjb25zdCByYWRpYXRpb25Db3N0ID0gKGh5YnJpZFJlc3VsdC5yYWRpYXRpb25Qcm90ZWN0aW9uLmZhYkNvc3RVc2QgKiBjb25zdGVsbGF0aW9uQ29zdE11bHRpcGxpZXIpIC8gdG90YWxFZmZlY3RpdmVQZmxvcHMgLyBsaWZldGltZVllYXJzO1xuICBjb25zdCBidXNDb3N0ID0gKGh5YnJpZFJlc3VsdC5idXMuZmFiQ29zdFVzZCAqIGNvbnN0ZWxsYXRpb25Db3N0TXVsdGlwbGllcikgLyB0b3RhbEVmZmVjdGl2ZVBmbG9wcyAvIGxpZmV0aW1lWWVhcnM7XG4gIGNvbnN0IG5ldHdvcmtpbmdDb3N0ID0gKGVmZmVjdGl2ZU5ldHdvcmtpbmdGYWJDb3N0ICogY29uc3RlbGxhdGlvbkNvc3RNdWx0aXBsaWVyKSAvIHRvdGFsRWZmZWN0aXZlUGZsb3BzIC8gbGlmZXRpbWVZZWFycztcbiAgY29uc3QgaW50ZXJjb25uZWN0Q29zdCA9IChoeWJyaWRSZXN1bHQuaW50ZXJjb25uZWN0LnRvdGFsQW5udWFsQ29zdCAqIGNvbnN0ZWxsYXRpb25Db3N0TXVsdGlwbGllcikgLyB0b3RhbEVmZmVjdGl2ZVBmbG9wcztcbiAgY29uc3QgcmVndWxhdG9yeUNvc3QgPSAoKGh5YnJpZFJlc3VsdC5yZWd1bGF0b3J5Py5hbm51YWxDb3N0VXNkIHx8IDApICogY29uc3RlbGxhdGlvbkNvc3RNdWx0aXBsaWVyKSAvIHRvdGFsRWZmZWN0aXZlUGZsb3BzO1xuICBcbiAgLy8gT3BzIGNvc3Qgc2NhbGVzIHdpdGggY29uc3RlbGxhdGlvbiBvdmVyaGVhZCAobW9yZSBzYXRlbGxpdGVzID0gbW9yZSBvcHMgY29tcGxleGl0eSlcbiAgY29uc3QgYmFzZU9wc0Nvc3RQZXJTYXQgPSBoeWJyaWRSZXN1bHQub3BzUGVyUGZsb3BZZWFyICogZWZmZWN0aXZlUGZsb3BzUGVyU2F0OyAvLyBUb3RhbCBvcHMgY29zdCBwZXIgc2F0ZWxsaXRlXG4gIGNvbnN0IG5ldHdvcmtpbmdPcHNDb3N0UGVyU2F0ID0gKGh5YnJpZFJlc3VsdC5uZXR3b3JraW5nLmFubnVhbE9wRXhVc2QgfHwgMCkgLSBlZmZlY3RpdmVOZXR3b3JraW5nT3BFeDsgLy8gQWxyZWFkeSBwZXItc2F0XG4gIGNvbnN0IGFkanVzdGVkTmV0d29ya2luZ09wc0Nvc3RQZXJTYXQgPSBlZmZlY3RpdmVOZXR3b3JraW5nT3BFeDsgLy8gQWxyZWFkeSBwZXItc2F0XG4gIGNvbnN0IG9wc0Nvc3RQZXJTYXQgPSBiYXNlT3BzQ29zdFBlclNhdCAtIG5ldHdvcmtpbmdPcHNDb3N0UGVyU2F0ICsgYWRqdXN0ZWROZXR3b3JraW5nT3BzQ29zdFBlclNhdDtcbiAgXG4gIC8vIFNjYWxlIG9wcyBjb3N0IGJ5IGNvbnN0ZWxsYXRpb24gKHdpdGggb3ZlcmhlYWQgZm9yIGNvb3JkaW5hdGlvbilcbiAgY29uc3Qgb3BzQ29zdE11bHRpcGxpZXIgPSBjb25zdGVsbGF0aW9uLm51bVNhdGVsbGl0ZXMgKiAoMSArIDAuMSAqIE1hdGgubG9nMTAoY29uc3RlbGxhdGlvbi5udW1TYXRlbGxpdGVzKSk7XG4gIGNvbnN0IG9wc0Nvc3QgPSAob3BzQ29zdFBlclNhdCAqIG9wc0Nvc3RNdWx0aXBsaWVyKSAvIHRvdGFsRWZmZWN0aXZlUGZsb3BzO1xuXG4gIGNvbnN0IG9yYml0YWxCcmVha2Rvd24gPSB7XG4gICAgcG93ZXI6IHBvd2VyQ29zdCxcbiAgICBjb21wdXRlOiBjb21wdXRlQ29zdCxcbiAgICB0aGVybWFsOiB0aGVybWFsQ29zdCxcbiAgICByYWRpYXRpb246IHJhZGlhdGlvbkNvc3QsXG4gICAgYnVzOiBidXNDb3N0LFxuICAgIG9wczogb3BzQ29zdCxcbiAgICBjb25nZXN0aW9uOiAwLCAvLyBDYWxjdWxhdGVkIGJlbG93XG4gICAgbmV0d29ya2luZzogbmV0d29ya2luZ0Nvc3QsXG4gICAgaW50ZXJjb25uZWN0OiBpbnRlcmNvbm5lY3RDb3N0LFxuICAgIHJlZ3VsYXRvcnk6IHJlZ3VsYXRvcnlDb3N0LFxuICAgIGxhdW5jaDogbGF1bmNoQ29zdFBlclBmbG9wWWVhclxuICB9O1xuXG4gIGNvbnN0IHRvdGFsU2F0ZWxsaXRlQ29zdCA9IGh5YnJpZFJlc3VsdC50b3RhbFNhdGVsbGl0ZUNvc3QgKiBjb25zdGVsbGF0aW9uQ29zdE11bHRpcGxpZXI7XG4gIGNvbnN0IHNhdGVsbGl0ZUNvdW50ID0gY29uc3RlbGxhdGlvbi5udW1TYXRlbGxpdGVzOyAvLyBVc2UgYWN0dWFsIGNvbnN0ZWxsYXRpb24gc2l6ZVxuICBjb25zdCBjb25nZXN0aW9uID0gY2FsY3VsYXRlQ29uZ2VzdGlvbihzYXRlbGxpdGVDb3VudCwgdG90YWxTYXRlbGxpdGVDb3N0LCB5ZWFyLCAxMDAwMCArIHNhdGVsbGl0ZUNvdW50LCBzcGFjZVRyYWZmaWNFbmFibGVkKTtcbiAgXG4gIC8vIFRvdGFsIGZsZWV0IFBGTE9QUzogdXNlIGNvbnN0ZWxsYXRpb24gdG90YWwgUEZMT1BzXG4gIC8vIEFscmVhZHkgY2FsY3VsYXRlZCBhcyB0b3RhbEVmZmVjdGl2ZVBmbG9wcyBhYm92ZVxuICBvcmJpdGFsQnJlYWtkb3duLmNvbmdlc3Rpb24gPSBzcGFjZVRyYWZmaWNFbmFibGVkID8gKGNvbmdlc3Rpb24uY29uZ2VzdGlvbkNvc3RQZXJQZmxvcFllYXIgLyB0b3RhbEVmZmVjdGl2ZVBmbG9wcykgOiAwO1xuXG4gIC8vIFBBVENIIEc6IENvc3QgQWNjb3VudGluZyBJbnZhcmlhbnRzXG4gIC8vIFVzZSBhc3NlcnRDb3N0QWNjb3VudGluZyB0byBlbnN1cmUgYnJlYWtkb3duIHN1bXMgdG8gdG90YWwgZXhhY3RseVxuICBjb25zdCBvcmJpdGFsQ29tcG9uZW50cyA9IFtcbiAgICB7IG5hbWU6ICdwb3dlcicsIHZhbHVlOiBvcmJpdGFsQnJlYWtkb3duLnBvd2VyIH0sXG4gICAgeyBuYW1lOiAnY29tcHV0ZScsIHZhbHVlOiBvcmJpdGFsQnJlYWtkb3duLmNvbXB1dGUgfSxcbiAgICB7IG5hbWU6ICd0aGVybWFsJywgdmFsdWU6IG9yYml0YWxCcmVha2Rvd24udGhlcm1hbCB9LFxuICAgIHsgbmFtZTogJ3JhZGlhdGlvbicsIHZhbHVlOiBvcmJpdGFsQnJlYWtkb3duLnJhZGlhdGlvbiB9LFxuICAgIHsgbmFtZTogJ2J1cycsIHZhbHVlOiBvcmJpdGFsQnJlYWtkb3duLmJ1cyB9LFxuICAgIHsgbmFtZTogJ29wcycsIHZhbHVlOiBvcmJpdGFsQnJlYWtkb3duLm9wcyB9LFxuICAgIHsgbmFtZTogJ25ldHdvcmtpbmcnLCB2YWx1ZTogb3JiaXRhbEJyZWFrZG93bi5uZXR3b3JraW5nIH0sXG4gICAgeyBuYW1lOiAnaW50ZXJjb25uZWN0JywgdmFsdWU6IG9yYml0YWxCcmVha2Rvd24uaW50ZXJjb25uZWN0IH0sXG4gICAgeyBuYW1lOiAncmVndWxhdG9yeScsIHZhbHVlOiBvcmJpdGFsQnJlYWtkb3duLnJlZ3VsYXRvcnkgfSxcbiAgICB7IG5hbWU6ICdsYXVuY2gnLCB2YWx1ZTogb3JiaXRhbEJyZWFrZG93bi5sYXVuY2ggfSxcbiAgICB7IG5hbWU6ICdjb25nZXN0aW9uJywgdmFsdWU6IG9yYml0YWxCcmVha2Rvd24uY29uZ2VzdGlvbiB9LFxuICBdO1xuICBcbiAgY29uc3QgYnJlYWtkb3duU3VtID0gT2JqZWN0LnZhbHVlcyhvcmJpdGFsQnJlYWtkb3duKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgY29uc3QgcmVhbGlzdGljQ29zdFBlclBmbG9wID0gYnJlYWtkb3duU3VtO1xuICBcbiAgLy8gVHJhY2sgYXBwbGllZCBtdWx0aXBsaWVycyBmb3IgZGVidWdnaW5nXG4gIGNvbnN0IGFwcGxpZWRNdWx0aXBsaWVyczogQXJyYXk8eyBuYW1lOiBzdHJpbmc7IHZhbHVlOiBudW1iZXI7IGFwcGxpZWRUbzogc3RyaW5nIH0+ID0gW1xuICAgIHsgbmFtZTogJ2xhdW5jaERpc2NvdW50JywgdmFsdWU6IGxhdW5jaERpc2NvdW50LCBhcHBsaWVkVG86ICdsYXVuY2ggY29zdCcgfSxcbiAgICB7IG5hbWU6ICdwb3dlckRpc2NvdW50JywgdmFsdWU6IHBvd2VyRGlzY291bnQsIGFwcGxpZWRUbzogJ3Bvd2VyIGZhYiBjb3N0JyB9LFxuICAgIHsgbmFtZTogJ25ldHdvcmtpbmdEaXNjb3VudCcsIHZhbHVlOiBuZXR3b3JraW5nRGlzY291bnQsIGFwcGxpZWRUbzogJ25ldHdvcmtpbmcgY29zdCcgfSxcbiAgICB7IG5hbWU6ICdtYXNzTXVsdGlwbGllcicsIHZhbHVlOiBtYXNzTXVsdGlwbGllciwgYXBwbGllZFRvOiAndG90YWwgbWFzcycgfSxcbiAgXTtcbiAgXG4gIC8vIEFzc2VydCBjb3N0IGFjY291bnRpbmcgKHRocm93cyBpZiBpbnZhbGlkKVxuICBjb25zdCBvcmJpdGFsQWNjb3VudGluZyA9IGFzc2VydENvc3RBY2NvdW50aW5nKHJlYWxpc3RpY0Nvc3RQZXJQZmxvcCwgb3JiaXRhbENvbXBvbmVudHMsIGFwcGxpZWRNdWx0aXBsaWVycyk7XG4gIGNvbnN0IGNvc3RBY2NvdW50aW5nVmFsaWQgPSBvcmJpdGFsQWNjb3VudGluZy52YWxpZDtcbiAgY29uc3QgY29zdEFjY291bnRpbmdFcnJvclBjdCA9IG9yYml0YWxBY2NvdW50aW5nLmVycm9yUGN0O1xuXG4gIC8vIEZJWCA1OiBHUFUtaG91ciBicmVha2Rvd24gbXVzdCBkZXJpdmUgZnJvbSBhbm51YWwgY29zdCBicmVha2Rvd25cbiAgLy8gR1BVLWhvdXIgcHJpY2luZzogQXBwbHkgc2NhcmNpdHkgYXMgTVVMVElQTElDQVRJVkUgbXVsdGlwbGllciAobm90IGFkZGl0aXZlKVxuICAvLyBkZWxheVBlbmFsdHkgcmVtYWlucyBhZGRpdGl2ZSAoV0FDQyBjYXJyeSBjb3N0KSwgYnV0IHNjYXJjaXR5IHJlbnQgaXMgbm93IG11bHRpcGxpY2F0aXZlXG4gIGNvbnN0IGRlbGF5UGVuYWx0eVBlclBmbG9wWWVhciA9IGdyb3VuZFJlc3VsdC5jb25zdHJhaW50cz8uZGVsYXlQZW5hbHR5IHx8IDA7XG4gIGNvbnN0IHNjYXJjaXR5TXVsdGlwbGllciA9IGdyb3VuZFJlc3VsdC5jb25zdHJhaW50cz8uc2NhcmNpdHlNdWx0aXBsaWVyID8/IDEuMDsgLy8gTXVsdGlwbGllciBmcm9tIGxvZy1iYXNlZCBmdW5jdGlvblxuICBcbiAgLy8gQ29udmVydCBkZWxheVBlbmFsdHkgdG8gJC9HUFUtaG91ciAoc3RpbGwgYWRkaXRpdmUpXG4gIGNvbnN0IHBmbG9wc1BlckdwdSA9IDIuMDtcbiAgY29uc3QgdXRpbGl6YXRpb25UYXJnZXQgPSAwLjg1O1xuICBjb25zdCBob3Vyc1BlclllYXIgPSA4NzYwO1xuICBjb25zdCBhbm51YWxHcHVIb3Vyc1BlclBGTE9QID0gaG91cnNQZXJZZWFyICogdXRpbGl6YXRpb25UYXJnZXQgLyBwZmxvcHNQZXJHcHU7XG4gIGNvbnN0IGRlbGF5UGVuYWx0eUFkZGVyUGVyR3B1SG91ciA9IGRlbGF5UGVuYWx0eVBlclBmbG9wWWVhciAvIGFubnVhbEdwdUhvdXJzUGVyUEZMT1A7XG4gIFxuICAvLyBOb3RlOiBTY2FyY2l0eSBpcyBub3cgTVVMVElQTElDQVRJVkUgKG5vdCBhZGRpdGl2ZSksIHNvIG5vIGNvbnZlcnNpb24gY2hlY2sgbmVlZGVkXG4gIC8vIFNjYXJjaXR5IG11bHRpcGxpZXIgaXMgYXBwbGllZCBkaXJlY3RseSB0byBiYXNlIGNvc3QgaW4gR1BVLWhvdXIgcHJpY2luZ1xuICBcbiAgLy8gVXNlIEJBU0UgY29zdCAod2l0aG91dCBzY2FyY2l0eSkgZm9yIEdQVS1ob3VyIHByaWNpbmcsIHRoZW4gYXBwbHkgc2NhcmNpdHkgYXMgbXVsdGlwbGllclxuICAvLyBUaGlzIHByZXZlbnRzIGRvdWJsZS1jb3VudGluZzogc2NhcmNpdHkgaXMgbXVsdGlwbGljYXRpdmUgaW4gR1BVLWhvdXIgcHJpY2luZywgbm90IGFkZGl0aXZlXG4gIC8vIFdlIHdhbnQ6IGJhc2VDb3N0IChubyBzY2FyY2l0eSkgKiBzY2FyY2l0eU11bHRpcGxpZXIgPSB0b3RhbCB3aXRoIHNjYXJjaXR5XG4gIC8vIFVzZSBncm91bmRSZXN1bHQudG90YWxDb3N0UGVyUGZsb3BZZWFyQmFzZSBpZiBhdmFpbGFibGUgKGZyb20gYnVpbGRvdXQgbW9kZWwpLCBvdGhlcndpc2UgY29uc3RydWN0IGZyb20gY29tcG9uZW50c1xuICBjb25zdCBncm91bmRDb3N0QmFzZUZvclByaWNpbmcgPSB1c2VCdWlsZG91dE1vZGVsICYmIGdyb3VuZFJlc3VsdD8udG90YWxDb3N0UGVyUGZsb3BZZWFyQmFzZSAhPT0gdW5kZWZpbmVkXG4gICAgPyBncm91bmRSZXN1bHQudG90YWxDb3N0UGVyUGZsb3BZZWFyQmFzZVxuICAgIDogKGdyb3VuZFJlc3VsdC5lbmVyZ3lDb3N0ICsgZ3JvdW5kUmVzdWx0LnNpdGVDb3N0ICsgZ3JvdW5kUmVzdWx0LmhhcmR3YXJlQ29zdCkgKiBncm91bmRMYXRlbmN5UGVuYWx0eTtcbiAgXG4gIGNvbnN0IGdyb3VuZEdwdUhvdXIgPSAoc2xhOiBTTEFDb25maWcpID0+IHtcbiAgICBjb25zdCBiYXNlUHJpY2luZyA9IGNhbGN1bGF0ZUdwdUhvdXJQcmljaW5nKGdyb3VuZENvc3RCYXNlRm9yUHJpY2luZywge1xuICAgICAgcGZsb3BzUGVyR3B1LFxuICAgICAgdXRpbGl6YXRpb25UYXJnZXQsXG4gICAgICBvcGVyYXRvck1hcmdpblBjdDogb3BlcmF0b3JNYXJnaW4sXG4gICAgICBzbGEsXG4gICAgICBsb2NhdGlvbjogJ2dyb3VuZCdcbiAgICB9LCB7XG4gICAgICBjb21wdXRlOiBncm91bmRSZXN1bHQuaGFyZHdhcmVDb3N0LFxuICAgICAgcG93ZXI6IGdyb3VuZFJlc3VsdC5lbmVyZ3lDb3N0LFxuICAgICAgc2l0ZTogdXNlQnVpbGRvdXRNb2RlbCA/IGdyb3VuZFJlc3VsdC5zaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciA6IGdyb3VuZFJlc3VsdC5zaXRlQ29zdCxcbiAgICAgIC8vIEdyb3VuZCBjb29saW5nIGluY2x1ZGVkIGluIGVuZXJneSwgaW50ZXJjb25uZWN0IG1pbmltYWxcbiAgICB9KTtcbiAgICBcbiAgICAvLyBVTklGSUVEIFNDQVJDSVRZIEFDQ09VTlRJTkc6IFNjYXJjaXR5IGlzIE1VTFRJUExJQ0FUSVZFIChub3QgYWRkaXRpdmUpXG4gICAgLy8gQ1JJVElDQUwgRklYOiBBcHBseSBzY2FyY2l0eSBhcyBwcmVtaXVtIG9uIEZJWEVEIHJlZmVyZW5jZSBiYXNlLCBub3QgZGVjbGluaW5nIGJhc2VcbiAgICAvLyBUaGlzIHByZXZlbnRzIE1vb3JlJ3MgTGF3IGZyb20gZXJvZGluZyBzY2FyY2l0eSBkb2xsYXIgYW1vdW50c1xuICAgIFxuICAgIC8vIEV4dHJhY3QgYmFzZSBjb3N0IGJlZm9yZSBtYXJnaW4gKHRoaXMgZGVjbGluZXMgd2l0aCBNb29yZSdzIExhdylcbiAgICBjb25zdCBwcmVNYXJnaW5CYXNlID0gYmFzZVByaWNpbmcucHJpY2VQZXJHcHVIb3VyIC0gKGJhc2VQcmljaW5nLmNvc3RCcmVha2Rvd24ubWFyZ2luIHx8IDApO1xuICAgIFxuICAgIC8vIFNjYXJjaXR5IHByZW1pdW0gYmFzZWQgb24gRklYRUQgcmVmZXJlbmNlLCBub3QgZGVjbGluaW5nIGJhc2VcbiAgICAvLyBUaGlzIGVuc3VyZXMgc2NhcmNpdHkgZG9lc24ndCBnZXQgZXJvZGVkIGJ5IE1vb3JlJ3MgTGF3XG4gICAgY29uc3QgU0NBUkNJVFlfUkVGRVJFTkNFX0JBU0UgPSAzLjUwOyAvLyBGaXhlZCAyMDI1IG1hcmtldCByZWZlcmVuY2UgKCQvR1BVLWhyKVxuICAgIGNvbnN0IHNjYXJjaXR5UHJlbWl1bSA9IChzY2FyY2l0eU11bHRpcGxpZXIgLSAxKSAqIFNDQVJDSVRZX1JFRkVSRU5DRV9CQVNFO1xuICAgIFxuICAgIC8vIFRvdGFsIGNvc3QgPSBiYXNlIChkZWNsaW5pbmcgd2l0aCBNb29yZSdzIExhdykgKyBzY2FyY2l0eSAoZml4ZWQpICsgZGVsYXlcbiAgICBjb25zdCBjb3N0V2l0aFNjYXJjaXR5ID0gcHJlTWFyZ2luQmFzZSArIHNjYXJjaXR5UHJlbWl1bTtcbiAgICBjb25zdCBjb3N0V2l0aFNjYXJjaXR5QW5kRGVsYXkgPSBjb3N0V2l0aFNjYXJjaXR5ICsgZGVsYXlQZW5hbHR5QWRkZXJQZXJHcHVIb3VyO1xuICAgIFxuICAgIC8vIFRoZW4gYWRkIG1hcmdpblxuICAgIGNvbnN0IG1hcmdpbiA9IGNvc3RXaXRoU2NhcmNpdHlBbmREZWxheSAqIG9wZXJhdG9yTWFyZ2luO1xuICAgIGNvbnN0IHByaWNlUGVyR3B1SG91ciA9IGNvc3RXaXRoU2NhcmNpdHlBbmREZWxheSArIG1hcmdpbjtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgLi4uYmFzZVByaWNpbmcsXG4gICAgICBwcmljZVBlckdwdUhvdXIsXG4gICAgICBjb3N0QnJlYWtkb3duOiB7XG4gICAgICAgIC4uLmJhc2VQcmljaW5nLmNvc3RCcmVha2Rvd24sXG4gICAgICAgIHNjYXJjaXR5OiBzY2FyY2l0eVByZW1pdW0sIC8vIEZpeGVkLWJhc2Ugc2NhcmNpdHkgcHJlbWl1bSAoZG9lc24ndCBkZWNsaW5lIHdpdGggTW9vcmUncyBMYXcpXG4gICAgICAgIGRlbGF5UGVuYWx0eTogZGVsYXlQZW5hbHR5QWRkZXJQZXJHcHVIb3VyLCAvLyBEZWxheSBwZW5hbHR5IChXQUNDIGNhcnJ5KVxuICAgICAgICBtYXJnaW4sIC8vIG92ZXJ3cml0ZSB3aXRoIHJlY29tcHV0ZWQgbWFyZ2luXG4gICAgICB9LFxuICAgIH07XG4gIH07XG5cbiAgY29uc3Qgb3JiaXRhbEdwdUhvdXIgPSAoc2xhOiBTTEFDb25maWcpID0+IGNhbGN1bGF0ZUdwdUhvdXJQcmljaW5nKHJlYWxpc3RpY0Nvc3RQZXJQZmxvcCwge1xuICAgIHBmbG9wc1BlckdwdTogMi4wLFxuICAgIHV0aWxpemF0aW9uVGFyZ2V0OiAwLjg1LFxuICAgIG9wZXJhdG9yTWFyZ2luUGN0OiBvcGVyYXRvck1hcmdpbixcbiAgICBzbGEsXG4gICAgbG9jYXRpb246ICdvcmJpdGFsJ1xuICB9LCBvcmJpdGFsQnJlYWtkb3duKTsgLy8gVXNlIGZ1bGwgb3JiaXRhbCBicmVha2Rvd25cblxuICBjb25zdCBncm91bmRUb2tlbnMgPSB7XG4gICAgbGxhbWE3MEI6IGNhbGN1bGF0ZVRva2VuUHJpY2luZyhncm91bmRUb3RhbENvc3QsIHsgcGFyYW1zOiA3MGU5LCBwcmVjaXNpb246ICdmcDE2JyB9KSxcbiAgICBsbGFtYTQwNUI6IGNhbGN1bGF0ZVRva2VuUHJpY2luZyhncm91bmRUb3RhbENvc3QsIHsgcGFyYW1zOiA0MDVlOSwgcHJlY2lzaW9uOiAnZnAxNicgfSlcbiAgfTtcblxuICBjb25zdCBvcmJpdGFsVG9rZW5zID0ge1xuICAgIGxsYW1hNzBCOiBjYWxjdWxhdGVUb2tlblByaWNpbmcocmVhbGlzdGljQ29zdFBlclBmbG9wLCB7IHBhcmFtczogNzBlOSwgcHJlY2lzaW9uOiAnZnAxNicgfSksXG4gICAgbGxhbWE0MDVCOiBjYWxjdWxhdGVUb2tlblByaWNpbmcocmVhbGlzdGljQ29zdFBlclBmbG9wLCB7IHBhcmFtczogNDA1ZTksIHByZWNpc2lvbjogJ2ZwMTYnIH0pXG4gIH07XG5cbiAgY29uc3QgZWRnZUluZmVyZW5jZSA9IHBhcmFtcy5lZGdlSW5mZXJlbmNlPy5lbmFibGVkIFxuICAgID8gY29tcHV0ZUVkZ2VJbmZlcmVuY2VDb3N0cyh5ZWFyLCBwYXJhbXMuZWRnZUluZmVyZW5jZSwgbGF1bmNoQ29zdFBlcktnLCB0b3RhbEVmZmVjdGl2ZVBmbG9wcyAvIGVmZmVjdGl2ZVRvdGFsTWFzc0tnKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IGdwdUhvdXJDcm9zc292ZXIgPSBvcmJpdGFsR3B1SG91cihTTEFfVElFUlMuc3RhbmRhcmQpLnByaWNlUGVyR3B1SG91ciA8IGdyb3VuZEdwdUhvdXIoU0xBX1RJRVJTLnN0YW5kYXJkKS5wcmljZVBlckdwdUhvdXI7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBERUJVRyBJTlZBUklBTlRTIChkZXZlbG9wbWVudCBtb2RlIG9ubHkpXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgLy8gSW52YXJpYW50IDE6IElmIGF2Z1dhaXRZZWFycyA+IDAgdGhlbiBzY2FyY2l0eSBtdWx0aXBsaWVyIHNob3VsZCBiZSA+IDEuMCAoc2NhcmNpdHkgaXMgbXVsdGlwbGljYXRpdmUgaW4gR1BVLWhvdXIgcHJpY2luZylcbiAgICBjb25zdCBhdmdXYWl0WWVhcnMgPSBncm91bmRSZXN1bHQuc3VwcGx5TWV0cmljcz8uYXZnV2FpdFllYXJzID8/IDA7XG4gICAgY29uc3Qgc2NhcmNpdHlNdWx0aXBsaWVyID0gZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRzPy5zY2FyY2l0eU11bHRpcGxpZXIgPz8gMS4wO1xuICAgIGlmIChhdmdXYWl0WWVhcnMgPiAxLjAgJiYgc2NhcmNpdHlNdWx0aXBsaWVyIDw9IDEuMCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW0lOVkFSSUFOVCBWSU9MQVRJT05dIFllYXIgJHt5ZWFyfTogYXZnV2FpdFllYXJzPSR7YXZnV2FpdFllYXJzfSA+IDEuMCBidXQgc2NhcmNpdHlNdWx0aXBsaWVyPSR7c2NhcmNpdHlNdWx0aXBsaWVyfSA8PSAxLjAuIGAgK1xuICAgICAgICBgU2NhcmNpdHkgbXVsdGlwbGllciBzaG91bGQgYmUgPiAxLjAgd2hlbiB3YWl0IHRpbWUgZXhpc3RzIChzY2FyY2l0eSBpcyBtdWx0aXBsaWNhdGl2ZSBpbiBHUFUtaG91ciBwcmljaW5nKS5gXG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICAvLyBJbnZhcmlhbnQgMjogc3VwcGx5TWV0cmljcy5jYXBhY2l0eUd3IGlzIHRoZSBlZmZlY3RpdmUgY2FwYWNpdHkgKGJvdHRsZW5lY2spXG4gICAgLy8gUXVldWUgbW9kZWwgdXNlcyBjb2hlcmVudCBiYWNrbG9nIGJhc2VkIG9uIHVubWV0IGRlbWFuZFxuICAgIFxuICAgIC8vIEludmFyaWFudCAzOiBHUFUtaG91ciBjaGFydCB5TWF4IGd1YXJkIChwcmV2ZW50ZWQgYnkgZXhwbGljaXQgc2VyaWVzIGV4dHJhY3Rpb24gaW4gY2hhcnQgY29tcG9uZW50KVxuICAgIC8vIFRoaXMgaXMgaGFuZGxlZCBpbiB0aGUgY2hhcnQgY29tcG9uZW50IHdpdGggZXhwbGljaXQgc2VyaWVzIGV4dHJhY3Rpb25cbiAgICBcbiAgICAvLyBJbnZhcmlhbnQgNDogQ3Jvc3NvdmVyIHVzZXMgZWZmZWN0aXZlIGdyb3VuZCBjb3N0XG4gICAgY29uc3QgZ3JvdW5kRWZmZWN0aXZlID0gZ3JvdW5kUmVzdWx0LnRvdGFsQ29zdFBlclBmbG9wWWVhckVmZmVjdGl2ZSA/PyBncm91bmRSZXN1bHQudG90YWxDb3N0UGVyUGZsb3BZZWFyO1xuICAgIGNvbnN0IGdyb3VuZEhlYWRsaW5lID0gZ3JvdW5kUmVzdWx0LnRvdGFsQ29zdFBlclBmbG9wWWVhcjtcbiAgICBjb25zdCBkZWxheVBlbmFsdHkgPSBncm91bmRSZXN1bHQuY29uc3RyYWludHM/LmRlbGF5UGVuYWx0eSA/PyAwO1xuICAgIC8vIFNjYXJjaXR5IGlzIG5vdyBtdWx0aXBsaWNhdGl2ZSAobm90IGFkZGl0aXZlKSwgc28gZG9uJ3QgYWRkIGl0IHRvIGVmZmVjdGl2ZSBjb3N0XG4gICAgY29uc3QgZXhwZWN0ZWRFZmZlY3RpdmUgPSBncm91bmRIZWFkbGluZSArIGRlbGF5UGVuYWx0eTsgLy8gU2NhcmNpdHkgYXBwbGllZCBpbiBHUFUtaG91ciBwcmljaW5nLCBub3QgUEZMT1AteWVhclxuICAgIGNvbnN0IGVmZmVjdGl2ZUVycm9yID0gTWF0aC5hYnMoZ3JvdW5kRWZmZWN0aXZlIC0gZXhwZWN0ZWRFZmZlY3RpdmUpO1xuICAgIC8vIFJldXNlIHNjYXJjaXR5TXVsdGlwbGllciBmcm9tIEludmFyaWFudCAxIGFib3ZlXG4gICAgaWYgKGVmZmVjdGl2ZUVycm9yID4gMC4wMSAmJiAoZGVsYXlQZW5hbHR5ID4gMCB8fCBzY2FyY2l0eU11bHRpcGxpZXIgPiAxLjApKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbSU5WQVJJQU5UIFZJT0xBVElPTl0gWWVhciAke3llYXJ9OiBncm91bmRFZmZlY3RpdmU9JHtncm91bmRFZmZlY3RpdmV9ICE9IGV4cGVjdGVkPSR7ZXhwZWN0ZWRFZmZlY3RpdmV9IGAgK1xuICAgICAgICBgKGhlYWRsaW5lPSR7Z3JvdW5kSGVhZGxpbmV9LCBkZWxheVBlbmFsdHk9JHtkZWxheVBlbmFsdHl9LCBzY2FyY2l0eU11bHRpcGxpZXI9JHtzY2FyY2l0eU11bHRpcGxpZXJ9KS4gYCArXG4gICAgICAgIGBDcm9zc292ZXIgc2hvdWxkIHVzZSBlZmZlY3RpdmUgY29zdC4gTm90ZTogc2NhcmNpdHkgaXMgbXVsdGlwbGljYXRpdmUgaW4gR1BVLWhvdXIgcHJpY2luZywgbm90IGFkZGl0aXZlIGluIFBGTE9QLXllYXIuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyBDUklUSUNBTCBGSVg6IFZhbGlkYXRlIGRlbGl2ZXJlZCBlZmZpY2llbmN5IGJ5IGNvbXBhcmluZyBsaWtlLWZvci1saWtlIG9ubHlcbiAgLy8gZXhwZWN0ZWREZWxpdmVyZWQgPSBzeXN0ZW1FZmZlY3RpdmVHZmxvcHNQZXJXYXR0ICogdGhlcm1hbENhcEZhY3RvciAqIHJhZGlhdGlvbkRlcmF0ZSAqIGF2YWlsYWJpbGl0eVxuICAvLyByYXRpbyA9IGRlbGl2ZXJlZEdmbG9wc1BlcldhdHQgLyBleHBlY3RlZERlbGl2ZXJlZFxuICAvLyBJZiByYXRpbyBpcyBmaW5pdGUgYW5kIHwxIC0gcmF0aW98IDw9IHRvbGVyYW5jZSAoMC4wMiksIHRoZW4gdmFsaWQ9dHJ1ZSwgd2FybmluZz1udWxsXG4gIC8vIEVsc2UgdmFsaWQ9ZmFsc2UsIHdhcm5pbmcgZGVzY3JpYmVzIHRoZSBtaXNtYXRjaFxuICAvLyBSZW1vdmUgYW55IG90aGVyIGNvbXBhcmlzb25zIChlLmcuLCBkZWxpdmVyZWQgdnMgc3lzdGVtRWZmZWN0aXZlLCBkZWxpdmVyZWQgdnMgcGVhayp1dGlsaXphdGlvbiB3aXRob3V0IG92ZXJoZWFkLCBldGMuKVxuICBjb25zdCBleHBlY3RlZERlbGl2ZXJlZCA9IG9yYml0U3lzdGVtRWZmZWN0aXZlR2Zsb3BzUGVyV2F0dCAqIHRoZXJtYWxDYXBGYWN0b3IgKiByYWRpYXRpb25EZXJhdGUgKiBhdmFpbGFiaWxpdHk7XG4gIGNvbnN0IHJhdGlvID0gb3JiaXREZWxpdmVyZWRHZmxvcHNQZXJXYXR0IC8gTWF0aC5tYXgoZXhwZWN0ZWREZWxpdmVyZWQsIDFlLTYpO1xuICBjb25zdCBUT0xFUkFOQ0UgPSAwLjAyOyAvLyAyJSB0b2xlcmFuY2VcbiAgY29uc3QgcmF0aW9FcnJvciA9IE1hdGguYWJzKDEgLSByYXRpbyk7XG4gIFxuICAvLyBDUklUSUNBTDogRml4IHZhbGlkYXRvciBsb2dpYyAtIGlmIHJhdGlvIGlzIGZpbml0ZSBhbmQgfDEgLSByYXRpb3wgPD0gdG9sZXJhbmNlLCB0aGVuIHZhbGlkPXRydWVcbiAgY29uc3QgaXNSYXRpb1ZhbGlkID0gaXNGaW5pdGUocmF0aW8pICYmIHJhdGlvRXJyb3IgPD0gVE9MRVJBTkNFO1xuICBcbiAgLy8gRXNjYWxhdGU6IGlmIG1pc21hdGNoID4gNSUsIG1hcmsgYXMgaW52YWxpZCAoZG9uJ3QganVzdCB3YXJuKVxuICBjb25zdCBFU0NBTEFURV9USFJFU0hPTEQgPSAwLjA1OyAvLyA1JVxuICBjb25zdCBpc0ludmFsaWQgPSAhaXNSYXRpb1ZhbGlkICYmIHJhdGlvRXJyb3IgPiBFU0NBTEFURV9USFJFU0hPTEQ7XG4gIFxuICAvLyBEZWJ1ZyBpbnZhcmlhbnRzOiBhc3NlcnQgZGVsaXZlcmVkIDw9IHN5c3RlbUVmZmVjdGl2ZSArIGVwc1xuICBjb25zdCBkZWxpdmVyZWRWc1N5c3RlbUVycm9yID0gb3JiaXREZWxpdmVyZWRHZmxvcHNQZXJXYXR0IC0gb3JiaXRTeXN0ZW1FZmZlY3RpdmVHZmxvcHNQZXJXYXR0O1xuICBpZiAoZGVsaXZlcmVkVnNTeXN0ZW1FcnJvciA+IDFlLTYpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgW0lOVkFSSUFOVCBWSU9MQVRJT05dIERlbGl2ZXJlZCBlZmZpY2llbmN5ICgke29yYml0RGVsaXZlcmVkR2Zsb3BzUGVyV2F0dC50b0ZpeGVkKDIpfSkgPiBzeXN0ZW1FZmZlY3RpdmUgKCR7b3JiaXRTeXN0ZW1FZmZlY3RpdmVHZmxvcHNQZXJXYXR0LnRvRml4ZWQoMil9KS4gYCArXG4gICAgICBgRGVsaXZlcmVkIG11c3QgYmUgPD0gc3lzdGVtRWZmZWN0aXZlLmBcbiAgICApO1xuICB9XG4gIFxuICAvLyBFZmZpY2llbmN5IGRlYnVnIGxvZ2dpbmcgcmVtb3ZlZCBmb3IgY2xlYW5lciBjb25zb2xlIG91dHB1dFxuICAvLyBWYWxpZGF0aW9uIHJlc3VsdHMgYXJlIGF2YWlsYWJsZSBpbiBvcmJpdC5jb21wdXRlRWZmaWNpZW5jeS52YWxpZGF0aW9uIG1ldGFkYXRhXG4gIFxuICAvLyBDUklUSUNBTDogVmFsaWRhdGUgZGVsaXZlcmVkIGVmZmljaWVuY3kgLSBjb21wYXJlIGRlbGl2ZXJlZCB2cyBleHBlY3RlZERlbGl2ZXJlZCBvbmx5XG4gIC8vIE1ha2UgdmFsaWRhdG9yIGRlYnVnIGV4cGxpY2l0IHdpdGggYWxsIGZhY3RvcnNcbiAgLy8gSWYgbWlzbWF0Y2ggPiA1JSwgbWFyayBydW4gaW52YWxpZCBhbmQgc3RvcCBjaGFydCByZW5kZXJpbmcgKGVzY2FsYXRlLCBkb24ndCBzaWxlbnRseSB3YXJuKVxuICBjb25zdCBkZWxpdmVyZWRWYWxpZGF0aW9uID0ge1xuICAgIHZhbGlkOiBpc1JhdGlvVmFsaWQsXG4gICAgd2FybmluZzogaXNSYXRpb1ZhbGlkIFxuICAgICAgPyB1bmRlZmluZWQgLy8gRW1wdHkvbnVsbCB3aGVuIHZhbGlkXG4gICAgICA6IGBQb3dlci9FZmZpY2llbmN5IG1pc21hdGNoOiAke3JhdGlvLnRvRml4ZWQoMil9eCBkaXNjcmVwYW5jeSAoZXhwZWN0ZWQ9JHtleHBlY3RlZERlbGl2ZXJlZC50b0ZpeGVkKDIpfSwgZGVsaXZlcmVkPSR7b3JiaXREZWxpdmVyZWRHZmxvcHNQZXJXYXR0LnRvRml4ZWQoMil9KWAsXG4gICAgZXhwZWN0ZWREZWxpdmVyZWQsXG4gICAgZGVsaXZlcmVkOiBvcmJpdERlbGl2ZXJlZEdmbG9wc1BlcldhdHQsXG4gICAgcmF0aW8sXG4gICAgZmFjdG9yc1VzZWQ6IHtcbiAgICAgIHRoZXJtYWxDYXBGYWN0b3IsXG4gICAgICByYWRpYXRpb25EZXJhdGUsXG4gICAgICBhdmFpbGFiaWxpdHksXG4gICAgICB1dGlsaXphdGlvbjogb3JiaXRhbEVmZmljaWVuY3lSZXN1bHQuZGVidWcudXRpbGl6YXRpb25GYWN0b3IsXG4gICAgICBzeXN0ZW1PdmVyaGVhZEZhY3Rvcjogb3JiaXRhbEVmZmljaWVuY3lSZXN1bHQuZGVidWcuc3lzdGVtT3ZlcmhlYWRGYWN0b3IsXG4gICAgfSxcbiAgICAvLyBFc2NhbGF0ZTogaWYgcmF0aW8gaXMgd2F5IG9mZiAoPiA1JSksIG1hcmsgYXMgaW52YWxpZFxuICAgIGludmFsaWQ6ICFpc1JhdGlvVmFsaWQgJiYgTWF0aC5hYnMoMSAtIHJhdGlvKSA+IDAuMDUsXG4gIH07XG4gIFxuICBjb25zdCBlZmZpY2llbmN5VmFsaWRhdGlvbiA9IHZhbGlkYXRlQ29tcHV0ZUVmZmljaWVuY3kob3JiaXRFZmZlY3RpdmVHZmxvcHNQZXJXLCBwYXJhbXMuZWZmaWNpZW5jeUxldmVsKTtcbiAgY29uc3QgY29uc2lzdGVuY3lDaGVjayA9IGFzc2VydENvbXB1dGVQb3dlckNvbnNpc3RlbmN5KG9yYml0RWZmZWN0aXZlR2Zsb3BzUGVyVywgdGFyZ2V0Q29tcHV0ZUt3LCB0b3RhbEVmZmVjdGl2ZVBmbG9wcywgTU9ERUxfVU5JVFMpO1xuXG4gIC8vIFNBTklUWSBQQU5FTDogQ29tcHJlaGVuc2l2ZSBkZWJ1ZyBibG9jayBwZXIgeWVhclxuICBjb25zdCBzYW5pdHlQYW5lbCA9IHtcbiAgICBncm91bmQ6IHtcbiAgICAgIGVmZmVjdGl2ZUdmbG9wc1Blclc6IGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlclcsXG4gICAgICBlbmVyZ3lDb3N0UGVyUGZsb3BZZWFyOiBncm91bmRSZXN1bHQuZW5lcmd5Q29zdCxcbiAgICAgIHNpdGVDYXBleEFtb3J0OiBncm91bmRSZXN1bHQuc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgPz8gKGdyb3VuZFJlc3VsdC5zaXRlQ29zdCAtIChncm91bmRSZXN1bHQuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gPz8gMCkgLSAoZ3JvdW5kUmVzdWx0LnRpbWVUb0VuZXJnaXplUGVuYWx0eSA/PyAwKSksXG4gICAgICBkZWxheVBlbmFsdHk6IGdyb3VuZFJlc3VsdC50aW1lVG9FbmVyZ2l6ZVBlbmFsdHkgPz8gMCxcbiAgICAgIGNhcGFjaXR5UHJlbWl1bTogZ3JvdW5kUmVzdWx0LmNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtID8/IDAsXG4gICAgICBjb25zdHJhaW50TXVsdGlwbGllcjogZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRNdWx0aXBsaWVyLFxuICAgICAgdG90YWw6IGdyb3VuZFRvdGFsQ29zdCxcbiAgICB9LFxuICAgIG9yYml0OiB7XG4gICAgICAvLyBSRU1PVkVEOiBlZmZlY3RpdmVTcGVjaWZpY1Bvd2VyIChkdXBsaWNhdGUgb2Ygc3BlY2lmaWNQb3dlcl9lZmZlY3RpdmVfV1BlcktnKVxuICAgICAgLy8gVXNlIHNwZWNpZmljUG93ZXJfZWZmZWN0aXZlX1dQZXJLZyBpbnN0ZWFkIChjYW5vbmljYWwgZmllbGQpXG4gICAgICBtYXNzTXVsdGlwbGllcjogaHlicmlkUmVzdWx0LnNwZWNpZmljUG93ZXJNdWx0aXBsaWVycz8ubWFzc011bHRpcGxpZXIgPz8gMS4wLFxuICAgICAgcmVxdWlyZWRBcmVhTTI6IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnFQZXJNMl9XID8gKGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLndhc3RlSGVhdFcgPz8gaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0ud2FzdGVIZWF0S3cgKiAxMDAwKSAvIChoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS5xUGVyTTJfVyA/PyAxKSA6IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnBoeXNpY2FsQXJlYU0yLFxuICAgICAgYXJlYUF2YWlsYWJsZU0yOiBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS5hcmVhQXZhaWxhYmxlTTIgPz8gaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0ucGh5c2ljYWxBcmVhTTIsXG4gICAgICB0aGVybWFsQ2FwRmFjdG9yOiBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS50aGVybWFsQ2FwRmFjdG9yLFxuICAgICAgdG90YWw6IHJlYWxpc3RpY0Nvc3RQZXJQZmxvcCxcbiAgICB9LFxuICAgIGFsbEludmFyaWFudHNQYXNzZWQ6ICgoKSA9PiB7XG4gICAgICAvLyBDaGVjayBrZXkgaW52YXJpYW50c1xuICAgICAgY29uc3Qgc2l0ZUNvc3RDaGVjayA9IE1hdGguYWJzKGdyb3VuZFJlc3VsdC5zaXRlQ29zdCAtICgoZ3JvdW5kUmVzdWx0LnNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyID8/IDApICsgKGdyb3VuZFJlc3VsdC50aW1lVG9FbmVyZ2l6ZVBlbmFsdHkgPz8gMCkgKyAoZ3JvdW5kUmVzdWx0LmNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtID8/IDApKSkgPCAwLjAxO1xuICAgICAgY29uc3QgdGhlcm1hbEFyZWFDaGVjayA9IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLmFyZWFBdmFpbGFibGVNMiA/IE1hdGguYWJzKGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLmFyZWFBdmFpbGFibGVNMiAtIGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnBoeXNpY2FsQXJlYU0yKSAvIGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnBoeXNpY2FsQXJlYU0yIDwgMC4wMSA6IHRydWU7XG4gICAgICBjb25zdCBzcGVjaWZpY1Bvd2VyQ2hlY2sgPSBoeWJyaWRSZXN1bHQuc3BlY2lmaWNQb3dlck11bHRpcGxpZXJzID8gaHlicmlkUmVzdWx0LnNwZWNpZmljUG93ZXJNdWx0aXBsaWVycy5lZmZlY3RpdmUgPD0gaHlicmlkUmVzdWx0LnNwZWNpZmljUG93ZXJNdWx0aXBsaWVycy5iYXNlU3BlY2lmaWNQb3dlciAqIDEuMDEgOiB0cnVlO1xuICAgICAgY29uc3QgdGhlcm1hbENhcENoZWNrID0gaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0udGhlcm1hbENhcEZhY3RvciA+PSAwICYmIGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnRoZXJtYWxDYXBGYWN0b3IgPD0gMTtcbiAgICAgIHJldHVybiBzaXRlQ29zdENoZWNrICYmIHRoZXJtYWxBcmVhQ2hlY2sgJiYgc3BlY2lmaWNQb3dlckNoZWNrICYmIHRoZXJtYWxDYXBDaGVjaztcbiAgICB9KSgpLFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgeWVhcixcbiAgICBtb2RlOiBwYXJhbXMuaXNTdGF0aWNNb2RlID8gJ1NUQVRJQycgOiAnRFlOQU1JQycsXG4gICAgc2FuaXR5UGFuZWwsXG4gICAgZ3JvdW5kOiB7XG4gICAgICBlbGVjdHJpY2l0eVByaWNlUGVyTXdoOiBncm91bmRFbGVjdHJpY2l0eVByaWNlUGVyTXdoLFxuICAgICAgcHVlOiBlZmZlY3RpdmVQdWVHcm91bmQsXG4gICAgICBjYXBhY2l0eUZhY3RvcjogY2FwYWNpdHlGYWN0b3JHcm91bmQsXG4gICAgICAvLyBIQVJEIEFTU0VSVDogQWxsIGdyb3VuZCBlZmZpY2llbmN5IGZpZWxkcyBtdXN0IGJlIHBvcHVsYXRlZCBhbmQgZmluaXRlXG4gICAgICBnZmxvcHNQZXJXYXR0OiAoKCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1Blclc7XG4gICAgICAgIGlmICghaXNGaW5pdGUodmFsdWUpIHx8IHZhbHVlIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGdyb3VuZC5nZmxvcHNQZXJXYXR0IGlzIGludmFsaWQ6ICR7dmFsdWV9LiBhY3R1YWxHcm91bmRJbnB1dD0ke2FjdHVhbEdyb3VuZElucHV0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pKCksIC8vIEVmZmVjdGl2ZSAoc3lzdGVtKSBHRkxPUFMvV1xuICAgICAgY29tcHV0ZURlZmluaXRpb246ICgoKSA9PiB7XG4gICAgICAgIC8vIENSSVRJQ0FMIEZJWDogVmFsaWRhdGUgYWxsIGNvbXB1dGVEZWZpbml0aW9uIGZpZWxkcyB0byBjYXRjaCB1bml0IGNvcnJ1cHRpb25cbiAgICAgICAgY29uc3QgcGVhayA9IHZhbGlkYXRlR2Zsb3BzUGVyV2F0dChcbiAgICAgICAgICBncm91bmRFZmZpY2llbmN5UmVzdWx0LmRlYnVnLmNoaXBQZWFrR2Zsb3BzUGVyVyxcbiAgICAgICAgICAnZ3JvdW5kLmNvbXB1dGVEZWZpbml0aW9uLnBlYWtHZmxvcHNQZXJXYXR0J1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBlZmZlY3RpdmUgPSB2YWxpZGF0ZUdmbG9wc1BlcldhdHQoXG4gICAgICAgICAgZ3JvdW5kRWZmaWNpZW5jeVJlc3VsdC5kZWJ1Zy5lZmZlY3RpdmVHZmxvcHNQZXJXLFxuICAgICAgICAgICdncm91bmQuY29tcHV0ZURlZmluaXRpb24uZWZmZWN0aXZlR2Zsb3BzUGVyV2F0dCdcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdXRpbGl6YXRpb24gPSBncm91bmRFZmZpY2llbmN5UmVzdWx0LmRlYnVnLnV0aWxpemF0aW9uRmFjdG9yO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFpc0Zpbml0ZSh1dGlsaXphdGlvbikgfHwgdXRpbGl6YXRpb24gPD0gMCB8fCB1dGlsaXphdGlvbiA+IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGdyb3VuZC5jb21wdXRlRGVmaW5pdGlvbi51dGlsaXphdGlvbkZhY3RvciBpcyBpbnZhbGlkOiAke3V0aWxpemF0aW9ufWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoaXBOYW1lOiAnTlZJRElBIEgxMDAgU1hNJyxcbiAgICAgICAgICBwcmVjaXNpb246ICdGUDE2JyxcbiAgICAgICAgICBwZWFrR2Zsb3BzUGVyV2F0dDogcGVhayxcbiAgICAgICAgICB1dGlsaXphdGlvbkZhY3RvcjogdXRpbGl6YXRpb24sXG4gICAgICAgICAgZWZmZWN0aXZlR2Zsb3BzUGVyV2F0dDogZWZmZWN0aXZlLFxuICAgICAgICAgIG5vdGVzOiAnRGF0YWNlbnRlciBkZXBsb3ltZW50LCBzeXN0ZW0tbGV2ZWwgZWZmaWNpZW5jeScsXG4gICAgICAgIH07XG4gICAgICB9KSgpLFxuICAgICAgZW5lcmd5Q29zdFBlclBmbG9wWWVhcjogKCgpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBncm91bmRSZXN1bHQuZW5lcmd5Q29zdDtcbiAgICAgICAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYGdyb3VuZC5lbmVyZ3lDb3N0UGVyUGZsb3BZZWFyIGlzIGludmFsaWQ6ICR7dmFsdWV9LiBgICtcbiAgICAgICAgICAgIGBDaGVjazogZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyVz0ke2dyb3VuZEVmZmVjdGl2ZUdmbG9wc1Blcld9LCBgICtcbiAgICAgICAgICAgIGBncm91bmRFbGVjdHJpY2l0eVByaWNlUGVyTXdoPSR7Z3JvdW5kRWxlY3RyaWNpdHlQcmljZVBlck13aH0sIGAgK1xuICAgICAgICAgICAgYGVmZmVjdGl2ZVB1ZUdyb3VuZD0ke2VmZmVjdGl2ZVB1ZUdyb3VuZH1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KSgpLCAvLyBSYXcgZWxlY3RyaWNpdHkgKE5PIGNvbnN0cmFpbnQgbXVsdGlwbGllcilcbiAgICAgIHNpdGVDb3N0UGVyUGZsb3BZZWFyOiAoKCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdyb3VuZFJlc3VsdC5zaXRlQ29zdDtcbiAgICAgICAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBncm91bmQuc2l0ZUNvc3RQZXJQZmxvcFllYXIgaXMgaW52YWxpZDogJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KSgpLCAvLyBTaXRlIGNvc3RzID0gc3VtIG9mIGNvbXBvbmVudHMgKElOVkFSSUFOVClcbiAgICAgIHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyOiBncm91bmRSZXN1bHQuc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgPz8gKGdyb3VuZFJlc3VsdC5zaXRlQ29zdCAtIChncm91bmRSZXN1bHQuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gPz8gMCkgLSAoZ3JvdW5kUmVzdWx0LnRpbWVUb0VuZXJnaXplUGVuYWx0eSA/PyAwKSksIC8vIFB1cmUgY2FwZXggYW1vcnRpemF0aW9uXG4gICAgICBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bTogZ3JvdW5kUmVzdWx0LmNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtID8/IDAsIC8vIEV4cGxpY2l0IGNhcGFjaXR5L2RlbGl2ZXJ5IHByZW1pdW0gKGluZGVwZW5kZW50KVxuICAgICAgdGltZVRvRW5lcmdpemVQZW5hbHR5OiBncm91bmRSZXN1bHQudGltZVRvRW5lcmdpemVQZW5hbHR5ID8/IDAsIC8vIFF1ZXVlIGRlbGF5IHBlbmFsdHkgKFdBQ0MtYmFzZWQsIGluZGVwZW5kZW50KVxuICAgICAgaGFyZHdhcmVDYXBleFBlclBmbG9wWWVhcjogZ3JvdW5kUmVzdWx0LmhhcmR3YXJlQ29zdCxcbiAgICAgIGNvbnN0cmFpbnRNdWx0aXBsaWVyOiAxLjAsIC8vIE5PVCBBUFBMSUVEIC0ga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0IG9ubHlcbiAgICAgIGNvbnN0cmFpbnRCcmVha2Rvd246IHtcbiAgICAgICAgLi4uY29uc3RyYWludEJyZWFrZG93bixcbiAgICAgICAgY2FwYWNpdHlEZWxpdmVyeU11bHRpcGxpZXI6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIH0sXG4gICAgICBjb25zdHJhaW50czogKGdyb3VuZFJlc3VsdC5jb25zdHJhaW50cyA/IHtcbiAgICAgICAgLi4uZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRzLFxuICAgICAgICBtZXRob2Q6ICdhZGRlcnMnIGFzIGNvbnN0LFxuICAgICAgfSA6IHtcbiAgICAgICAgbWV0aG9kOiAnYWRkZXJzJyBhcyBjb25zdCxcbiAgICAgICAgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW06IChncm91bmRSZXN1bHQuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gfHwgMCksXG4gICAgICAgIGRlbGF5UGVuYWx0eTogKGdyb3VuZFJlc3VsdC50aW1lVG9FbmVyZ2l6ZVBlbmFsdHkgfHwgMCksXG4gICAgICAgIGFwcGxpZWRNdWx0aXBsaWVyczoge1xuICAgICAgICAgIGNvbnN0cmFpbnRNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgICAgZW5lcmd5TXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgICAgIHNpdGVNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICB9KSBhcyB7IG1ldGhvZDogJ2FkZGVycyc7IGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtOiBudW1iZXI7IGRlbGF5UGVuYWx0eTogbnVtYmVyOyBhcHBsaWVkTXVsdGlwbGllcnM6IHsgY29uc3RyYWludE11bHRpcGxpZXJVc2VkOiBib29sZWFuOyBlbmVyZ3lNdWx0aXBsaWVyVXNlZDogYm9vbGVhbjsgc2l0ZU11bHRpcGxpZXJVc2VkOiBib29sZWFuOyB9OyBkZWJ1Zz86IGFueSB9LFxuICAgICAgc3VwcGx5TWV0cmljczogKGdyb3VuZFJlc3VsdCBhcyBhbnkpLnN1cHBseU1ldHJpY3MsXG4gICAgICBjb25zdHJhaW50Q29tcG9uZW50czogKGdyb3VuZFJlc3VsdCBhcyBhbnkpLmNvbnN0cmFpbnRDb21wb25lbnRzLFxuICAgICAgdG90YWxDb3N0UGVyUGZsb3BZZWFyOiAoKCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdyb3VuZFRvdGFsQ29zdDtcbiAgICAgICAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkgfHwgdmFsdWUgPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBncm91bmQudG90YWxDb3N0UGVyUGZsb3BZZWFyIGlzIGludmFsaWQ6ICR7dmFsdWV9LiBgICtcbiAgICAgICAgICAgIGBDb21wb25lbnRzOiBlbmVyZ3k9JHtncm91bmRSZXN1bHQuZW5lcmd5Q29zdH0sIHNpdGU9JHtncm91bmRSZXN1bHQuc2l0ZUNvc3R9LCBoYXJkd2FyZT0ke2dyb3VuZFJlc3VsdC5oYXJkd2FyZUNvc3R9LCBgICtcbiAgICAgICAgICAgIGBncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXPSR7Z3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyV30sIGFjdHVhbEdyb3VuZElucHV0PSR7YWN0dWFsR3JvdW5kSW5wdXR9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSkoKSxcbiAgICAgIGdwdUhvdXJQcmljaW5nOiB7XG4gICAgICAgIGJhc2ljOiBncm91bmRHcHVIb3VyKFNMQV9USUVSUy5iYXNpYyksXG4gICAgICAgIHN0YW5kYXJkOiBncm91bmRHcHVIb3VyKFNMQV9USUVSUy5zdGFuZGFyZCksXG4gICAgICAgIHByZW1pdW06IGdyb3VuZEdwdUhvdXIoU0xBX1RJRVJTLnByZW1pdW0pLFxuICAgICAgfSxcbiAgICAgIHRva2VuUHJpY2luZzogZ3JvdW5kVG9rZW5zLFxuICAgICAgc21yRW5hYmxlZDogZ3JvdW5kUmVzdWx0LnNtckVuYWJsZWQsXG4gICAgICBzbXJSYW1wRmFjdG9yOiBncm91bmRSZXN1bHQuc21yUmFtcEZhY3RvcixcbiAgICAgIGVmZmVjdGl2ZUVsZWN0cmljaXR5Q29zdDogZ3JvdW5kUmVzdWx0LmVmZmVjdGl2ZUVsZWN0cmljaXR5Q29zdCxcbiAgICAgIGNvbnN0cmFpbnRSZWxpZWY6IGdyb3VuZFJlc3VsdC5jb25zdHJhaW50UmVsaWVmXG4gICAgfSxcbiAgICBvcmJpdDoge1xuICAgICAgbGNvZVBlck13aDogKGh5YnJpZFJlc3VsdC5wb3dlclN5c3RlbS50b3RhbENvc3RVc2QpIC8gKHNhdGVsbGl0ZVBvd2VyS1cgKiBQSFlTSUNTX0NPTlNUQU5UUy5IT1VSU19QRVJfWUVBUiAqIGxpZmV0aW1lWWVhcnMgKiBoeWJyaWRSZXN1bHQuY2FwYWNpdHlGYWN0b3IgLyAxMDAwKSxcbiAgICAgIHB1ZTogcHVlT3JiaXRhbCxcbiAgICAgIGNhcGFjaXR5RmFjdG9yOiBoeWJyaWRSZXN1bHQuY2FwYWNpdHlGYWN0b3IsXG4gICAgICBjYXBhY2l0eUZhY3RvclByb3ZlbmFuY2U6IGh5YnJpZFJlc3VsdC5jb21wdXRlUGF5bG9hZD8uY2FwYWNpdHlGYWN0b3JQcm92ZW5hbmNlLCAvLyBEZWJ1ZzogQ0YgYnJlYWtkb3duXG4gICAgICBnZmxvcHNQZXJXYXR0OiBvcmJpdEVmZmVjdGl2ZUdmbG9wc1BlclcsIC8vIERlbGl2ZXJlZCBHRkxPUFMvVyAoc3lzdGVtRWZmZWN0aXZlIMOXIHRoZXJtYWxDYXAgw5cgcmFkaWF0aW9uRGVyYXRlIMOXIGF2YWlsYWJpbGl0eSlcbiAgICAgIGNvbXB1dGVEZWZpbml0aW9uOiB7XG4gICAgICAgIGNoaXBOYW1lOiAnSDEwMC1lcXVpdmFsZW50IChyYWQtdG9sZXJhbnQpJyxcbiAgICAgICAgcHJlY2lzaW9uOiAnRlAxNicsXG4gICAgICAgIHBlYWtHZmxvcHNQZXJXYXR0OiB2YWxpZGF0ZUdmbG9wc1BlcldhdHQoXG4gICAgICAgICAgb3JiaXRQZWFrR2Zsb3BzUGVyV2F0dCxcbiAgICAgICAgICAnb3JiaXQuY29tcHV0ZURlZmluaXRpb24ucGVha0dmbG9wc1BlcldhdHQnXG4gICAgICAgICksXG4gICAgICAgIHV0aWxpemF0aW9uRmFjdG9yOiBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5kZWJ1Zy51dGlsaXphdGlvbkZhY3RvcixcbiAgICAgICAgZWZmZWN0aXZlR2Zsb3BzUGVyV2F0dDogb3JiaXRTeXN0ZW1FZmZlY3RpdmVHZmxvcHNQZXJXYXR0LCAvLyBTeXN0ZW0tZWZmZWN0aXZlID0gcGVhayAqIHV0aWxpemF0aW9uIC8gc3lzdGVtT3ZlcmhlYWRGYWN0b3IgKFNZU1RFTS1MRVZFTCBFRkZFQ1RJVkUpXG4gICAgICAgIC8vIGRlbGl2ZXJlZEdmbG9wc1BlcldhdHQgaXMgc3RvcmVkIGluIG9yYml0LmNvbXB1dGVFZmZpY2llbmN5LmdmbG9wc1BlcldhdHQsIG5vdCBoZXJlXG4gICAgICAgIG5vdGVzOiAnQ29tbWVyY2lhbCByYWQtdG9sZXJhbnQgdmFyaWFudC4gcGVha0dmbG9wc1BlcldhdHQgPSBjaGlwIHBlYWsuIGVmZmVjdGl2ZUdmbG9wc1BlcldhdHQgPSBwZWFrICogdXRpbGl6YXRpb24gLyBzeXN0ZW1PdmVyaGVhZEZhY3RvciAoc3lzdGVtLWxldmVsIGVmZmVjdGl2ZSkuIGRlbGl2ZXJlZEdmbG9wc1BlcldhdHQgPSBzeXN0ZW1FZmZlY3RpdmUgw5cgdGhlcm1hbENhcEZhY3RvciDDlyByYWRpYXRpb25EZXJhdGUgw5cgYXZhaWxhYmlsaXR5JyxcbiAgICAgIH0sXG4gICAgICBjb21wdXRlRWZmaWNpZW5jeVByb3ZlbmFuY2U6IHtcbiAgICAgICAgcGVha0dmbG9wc1BlcldhdHQ6IG9yYml0YWxFZmZpY2llbmN5UmVzdWx0LmRlYnVnLmNoaXBQZWFrR2Zsb3BzUGVyVyxcbiAgICAgICAgdXRpbGl6YXRpb25GYWN0b3I6IG9yYml0YWxFZmZpY2llbmN5UmVzdWx0LmRlYnVnLnV0aWxpemF0aW9uRmFjdG9yLFxuICAgICAgICBzeXN0ZW1PdmVyaGVhZEZhY3Rvcjogb3JiaXRhbEVmZmljaWVuY3lSZXN1bHQuZGVidWcuc3lzdGVtT3ZlcmhlYWRGYWN0b3IsXG4gICAgICAgIGVmZmVjdGl2ZUdmbG9wc1BlcldhdHQ6IG9yYml0YWxFZmZpY2llbmN5UmVzdWx0LmRlYnVnLmVmZmVjdGl2ZUdmbG9wc1BlclcsXG4gICAgICB9LCAvLyBEZWJ1ZzogR0ZMT1BTL1cgYnJlYWtkb3duXG4gICAgICBsYXVuY2hDb3N0UGVyS2c6IGxhdW5jaENvc3RQZXJLZyxcbiAgICAgIHNwZWNpZmljUG93ZXJXUGVyS2c6IGh5YnJpZFJlc3VsdC5zcGVjaWZpY1Bvd2VyV1BlcktnLCAvLyBEZXByZWNhdGVkOiB1c2Ugc3BlY2lmaWNQb3dlcl9zdWJzeXN0ZW1fV1BlcktnXG4gICAgICBzcGVjaWZpY1Bvd2VyX3N1YnN5c3RlbV9XUGVyS2c6IGh5YnJpZFJlc3VsdC5zcGVjaWZpY1Bvd2VyV1BlcktnLCAvLyBTdWJzeXN0ZW0tbGV2ZWwgKHNvbGFyIGFycmF5IG9ubHkpXG4gICAgICBzcGVjaWZpY1Bvd2VyX2VmZmVjdGl2ZV9XUGVyS2c6IGh5YnJpZFJlc3VsdC5zcGVjaWZpY1Bvd2VyTXVsdGlwbGllcnM/LmVmZmVjdGl2ZSA/PyBzY2FsaW5nUmVzdWx0LmVmZmVjdGl2ZVNwZWNpZmljUG93ZXIsIC8vIEVmZmVjdGl2ZSBzcGFjZWNyYWZ0LWxldmVsIChmcm9tIG11bHRpcGxpZXJzIGNhbGN1bGF0aW9uKVxuICAgICAgLy8gVXNlIHNwZWNpZmljUG93ZXJNdWx0aXBsaWVycyBmcm9tIGh5YnJpZFJlc3VsdCAoY2FsY3VsYXRlZCBpbiBvcmJpdGFsUGh5c2ljcy50cyB3aXRoIGNvcnJlY3QgbWFzcyBmcmFjdGlvbiBhY2NvdW50aW5nKVxuICAgICAgc3BlY2lmaWNQb3dlck11bHRpcGxpZXJzOiBoeWJyaWRSZXN1bHQuc3BlY2lmaWNQb3dlck11bHRpcGxpZXJzLFxuICAgICAgZW5lcmd5Q29zdFBlclBmbG9wWWVhcjogb3JiaXRhbEJyZWFrZG93bi5wb3dlcixcbiAgICAgIGhhcmR3YXJlQ29zdFBlclBmbG9wWWVhcjogb3JiaXRhbEJyZWFrZG93bi5jb21wdXRlLFxuICAgICAgbGF1bmNoQ29zdFBlclBmbG9wWWVhcjogb3JiaXRhbEJyZWFrZG93bi5sYXVuY2gsXG4gICAgICByYWRpYXRpb25NdWx0aXBsaWVyOiAxLjAsXG4gICAgICB0aGVybWFsQ2FwRmFjdG9yOiBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS50aGVybWFsQ2FwRmFjdG9yLFxuICAgICAgY29uZ2VzdGlvbkNvc3RQZXJQZmxvcFllYXI6IG9yYml0YWxCcmVha2Rvd24uY29uZ2VzdGlvbixcbiAgICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhcjogcmVhbGlzdGljQ29zdFBlclBmbG9wLCBcbiAgICAgIHRoZXJtYWxDYXBwZWQ6IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnRoZXJtYWxDYXBwZWQsXG4gICAgICBjb21wdXRlUG93ZXJLdzogdGFyZ2V0Q29tcHV0ZUt3LCAvLyBUb3RhbCBjb25zdGVsbGF0aW9uIGNvbXB1dGUgcG93ZXJcbiAgICAgIG1heFJlamVjdGFibGVLdzogaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0ubWF4UmVqZWN0YWJsZUt3IHx8IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLndhc3RlSGVhdEt3ICogMS4yNSxcbiAgICAgIGNvbGxpc2lvblJpc2s6IGNvbmdlc3Rpb24uY29sbGlzaW9uUmlzayxcbiAgICAgIGJvZHlNb3VudGVkQXJlYU0yOiAwLFxuICAgICAgZGVwbG95YWJsZUFyZWFNMjogaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0ucGh5c2ljYWxBcmVhTTIsXG4gICAgICB0b3RhbFJhZGlhdG9yQXJlYU0yOiBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS5waHlzaWNhbEFyZWFNMixcbiAgICAgIHJhZGlhdG9yQ29zdFBlclBmbG9wWWVhcjogKGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnRvdGFsQ29zdFVzZCAqIGNvbnN0ZWxsYXRpb25Db3N0TXVsdGlwbGllcikgLyB0b3RhbEVmZmVjdGl2ZVBmbG9wcyAvIGxpZmV0aW1lWWVhcnMsXG4gICAgICByYWRpYXRvck1hc3NLZzogaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0udG90YWxNYXNzS2csXG4gICAgICBvcHRpbWlzdGljQ29zdFBlclBmbG9wOiBvcmJpdGFsQnJlYWtkb3duLnBvd2VyICsgb3JiaXRhbEJyZWFrZG93bi5jb21wdXRlICsgb3JiaXRhbEJyZWFrZG93bi5idXMsXG4gICAgICByYWRpYXRpb25TaGllbGRpbmdDb3N0OiBvcmJpdGFsQnJlYWtkb3duLnJhZGlhdGlvbixcbiAgICAgIHRoZXJtYWxTeXN0ZW1Db3N0OiBvcmJpdGFsQnJlYWtkb3duLnRoZXJtYWwsXG4gICAgICByZXBsYWNlbWVudFJhdGVDb3N0OiBvcmJpdGFsQnJlYWtkb3duLm9wcyxcbiAgICAgIGVjY092ZXJoZWFkQ29zdDogMCxcbiAgICAgIHJlZHVuZGFuY3lDb3N0OiAwLFxuICAgICAgcmVhbGlzdGljQ29zdFBlclBmbG9wLFxuICAgICAgaHlicmlkQnJlYWtkb3duOiBvcmJpdGFsQnJlYWtkb3duLFxuICAgICAgZ3B1SG91clByaWNpbmc6IHtcbiAgICAgICAgYmFzaWM6IG9yYml0YWxHcHVIb3VyKFNMQV9USUVSUy5iYXNpYyksXG4gICAgICAgIHN0YW5kYXJkOiBvcmJpdGFsR3B1SG91cihTTEFfVElFUlMuc3RhbmRhcmQpLFxuICAgICAgICBwcmVtaXVtOiBvcmJpdGFsR3B1SG91cihTTEFfVElFUlMucHJlbWl1bSksXG4gICAgICB9LFxuICAgICAgdG9rZW5QcmljaW5nOiBvcmJpdGFsVG9rZW5zLFxuICAgICAgcmFkaWF0aW9uRGVncmFkYXRpb246IHtcbiAgICAgICAgYW5udWFsRmFpbHVyZVJhdGU6IHVzZVJhZEhhcmRDaGlwcyA/IDAuMDkgOiAwLjE1LFxuICAgICAgICBlZmZlY3RpdmVDb21wdXRlUGVyY2VudDogaHlicmlkUmVzdWx0LmRlZ3JhZGF0aW9uRmFjdG9yLFxuICAgICAgICBlY2NPdmVyaGVhZFBjdDogMC4wNSxcbiAgICAgICAgYXBwbGllZDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHBvd2VyU3lzdGVtVHlwZTogaHlicmlkUmVzdWx0LnBvd2VyU3lzdGVtVHlwZSxcbiAgICAgIHNjYWxpbmdQZW5hbHR5OiBzY2FsaW5nUmVzdWx0LnNjYWxpbmdQZW5hbHR5LFxuICAgICAgLy8gUkVNT1ZFRDogZWZmZWN0aXZlU3BlY2lmaWNQb3dlciAoZHVwbGljYXRlIG9mIHNwZWNpZmljUG93ZXJfZWZmZWN0aXZlX1dQZXJLZylcbiAgICAgIC8vIFVzZSBzcGVjaWZpY1Bvd2VyX2VmZmVjdGl2ZV9XUGVyS2cgaW5zdGVhZCAoY2Fub25pY2FsIGZpZWxkKVxuICAgICAgZnVzaW9uRGV0YWlsczogaHlicmlkUmVzdWx0LmZ1c2lvbkRldGFpbHMsXG4gICAgICBcbiAgICAgIC8vIENvbnN0ZWxsYXRpb24gc2l6aW5nXG4gICAgICBjb25zdGVsbGF0aW9uOiB7XG4gICAgICAgIGRlc2lnbjoge1xuICAgICAgICAgIG51bVNhdGVsbGl0ZXM6IGNvbnN0ZWxsYXRpb24ubnVtU2F0ZWxsaXRlcyxcbiAgICAgICAgICBjb21wdXRlUGVyU2F0S3c6IGNvbnN0ZWxsYXRpb24uY29tcHV0ZVBlclNhdEt3LFxuICAgICAgICAgIG1hc3NQZXJTYXRLZzogbWFzc1BlclNhdEtnLFxuICAgICAgICAgIHJhZGlhdG9yQXJlYVBlclNhdE0yOiBjb25zdGVsbGF0aW9uLnJhZGlhdG9yQXJlYVBlclNhdE0yLFxuICAgICAgICB9LFxuICAgICAgICBsYXVuY2g6IHtcbiAgICAgICAgICBzYXRzUGVyTGF1bmNoOiBjb25zdGVsbGF0aW9uLnNhdHNQZXJMYXVuY2gsXG4gICAgICAgICAgbGF1bmNoZXNSZXF1aXJlZDogY29uc3RlbGxhdGlvbi5sYXVuY2hlc1JlcXVpcmVkLFxuICAgICAgICAgIHRvdGFsTWFzc0tnOiBlZmZlY3RpdmVUb3RhbE1hc3NLZyxcbiAgICAgICAgfSxcbiAgICAgICAgc2NhbGluZzoge1xuICAgICAgICAgIGNvbnN0ZWxsYXRpb25PdmVyaGVhZDogY29uc3RlbGxhdGlvbi5jb25zdGVsbGF0aW9uT3ZlcmhlYWQsXG4gICAgICAgICAgc2NhbGluZ0VmZmljaWVuY3k6IGNvbnN0ZWxsYXRpb24uc2NhbGluZ0VmZmljaWVuY3ksXG4gICAgICAgIH0sXG4gICAgICAgIHdhcm5pbmdzOiBjb25zdGVsbGF0aW9uLndhcm5pbmdzLFxuICAgICAgfSxcbiAgICAgIFxuICAgICAgLy8gRGVidWcgYmxvY2tzIGZvciBhbmFseXNpcyAtIGV4cGxpY2l0bHkgdHJhY2sgYWxsIGVmZmljaWVuY3kgbGV2ZWxzXG4gICAgICAvLyBTaW5nbGUgc291cmNlIG9mIHRydXRoOiBkZWZpbmUgb3JiaXQuY29tcHV0ZUVmZmljaWVuY3lMZXZlbHMgZWFjaCB5ZWFyXG4gICAgICAvLyBOb3RlOiBjb21wdXRlRWZmaWNpZW5jeUxldmVscyBpcyBzdG9yZWQgaW4gbWV0YWRhdGEsIG5vdCBkaXJlY3RseSBvbiBvcmJpdFxuICAgICAgZWZmZWN0aXZlQ29tcHV0ZU11bHRpcGxpZXJzOiB7XG4gICAgICAgIHRoZXJtYWxDYXBGYWN0b3I6IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnRoZXJtYWxDYXBGYWN0b3IsXG4gICAgICAgIHJhZGlhdGlvbkRlcmF0ZTogaHlicmlkUmVzdWx0LmRlZ3JhZGF0aW9uRmFjdG9yIHx8IDEuMCxcbiAgICAgICAgYXZhaWxhYmlsaXR5OiBoeWJyaWRSZXN1bHQuY2FwYWNpdHlGYWN0b3IgfHwgMS4wLFxuICAgICAgICB1dGlsaXphdGlvbjogb3JiaXRhbEVmZmljaWVuY3lSZXN1bHQuZGVidWcudXRpbGl6YXRpb25GYWN0b3IsXG4gICAgICB9LFxuICAgICAgY29zdFNoYXJlczogKCgpID0+IHtcbiAgICAgICAgY29uc3QgdG90YWwgPSByZWFsaXN0aWNDb3N0UGVyUGZsb3A7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGF1bmNoOiAob3JiaXRhbEJyZWFrZG93bi5sYXVuY2ggLyB0b3RhbCkgKiAxMDAsXG4gICAgICAgICAgcG93ZXI6IChvcmJpdGFsQnJlYWtkb3duLnBvd2VyIC8gdG90YWwpICogMTAwLFxuICAgICAgICAgIGNvbXB1dGU6IChvcmJpdGFsQnJlYWtkb3duLmNvbXB1dGUgLyB0b3RhbCkgKiAxMDAsXG4gICAgICAgICAgdGhlcm1hbDogKG9yYml0YWxCcmVha2Rvd24udGhlcm1hbCAvIHRvdGFsKSAqIDEwMCxcbiAgICAgICAgICBidXM6IChvcmJpdGFsQnJlYWtkb3duLmJ1cyAvIHRvdGFsKSAqIDEwMCxcbiAgICAgICAgICBvcHM6IChvcmJpdGFsQnJlYWtkb3duLm9wcyAvIHRvdGFsKSAqIDEwMCxcbiAgICAgICAgICBuZXR3b3JraW5nOiAob3JiaXRhbEJyZWFrZG93bi5uZXR3b3JraW5nIC8gdG90YWwpICogMTAwLFxuICAgICAgICAgIGdyb3VuZFNlZ21lbnQ6IChvcmJpdGFsQnJlYWtkb3duLnJlZ3VsYXRvcnkgLyB0b3RhbCkgKiAxMDAsIC8vIFJlZ3VsYXRvcnkgaW5jbHVkZXMgZ3JvdW5kIHNlZ21lbnRcbiAgICAgICAgfTtcbiAgICAgIH0pKCksXG4gICAgICBsb2NhbFNlbnNpdGl2aXR5OiAoKCkgPT4ge1xuICAgICAgICAvLyBDYWxjdWxhdGUgbG9jYWwgc2Vuc2l0aXZpdHk6IGRDb3N0L2RQYXJhbWV0ZXIgKGFwcHJveGltYXRlIGRlcml2YXRpdmVzKVxuICAgICAgICBcbiAgICAgICAgLy8gZENvc3RfZExhdW5jaDogbGF1bmNoIGNvc3Qgc2NhbGVzIGxpbmVhcmx5IHdpdGggbGF1bmNoQ29zdFBlcktnXG4gICAgICAgIGNvbnN0IGRDb3N0X2RMYXVuY2ggPSBvcmJpdGFsQnJlYWtkb3duLmxhdW5jaCAvIGxhdW5jaENvc3RQZXJLZztcbiAgICAgICAgXG4gICAgICAgIC8vIGRDb3N0X2RTcGVjaWZpY1Bvd2VyOiBwb3dlciBjb3N0IHNjYWxlcyBpbnZlcnNlbHkgd2l0aCBzcGVjaWZpYyBwb3dlciAobmVnYXRpdmUpXG4gICAgICAgIGNvbnN0IGRDb3N0X2RTcGVjaWZpY1Bvd2VyID0gLShvcmJpdGFsQnJlYWtkb3duLnBvd2VyIC8gdHJhalNwZWNpZmljUG93ZXIpO1xuICAgICAgICBcbiAgICAgICAgLy8gZENvc3RfZEdmbG9wc1Blclc6IHBvd2VyIGNvc3Qgc2NhbGVzIGludmVyc2VseSB3aXRoIEdGTE9QUy9XIChuZWdhdGl2ZSlcbiAgICAgICAgY29uc3QgZENvc3RfZEdmbG9wc1BlclcgPSAtKG9yYml0YWxCcmVha2Rvd24ucG93ZXIgLyBvcmJpdEVmZmVjdGl2ZUdmbG9wc1BlclcpO1xuICAgICAgICBcbiAgICAgICAgLy8gZENvc3RfZEZhaWx1cmVSYXRlOiBvcHMgY29zdCBzY2FsZXMgd2l0aCBmYWlsdXJlIHJhdGVcbiAgICAgICAgY29uc3QgYmFzZUZhaWx1cmVSYXRlID0gdXNlUmFkSGFyZENoaXBzID8gMC4wOSA6IDAuMTU7XG4gICAgICAgIGNvbnN0IGRDb3N0X2RGYWlsdXJlUmF0ZSA9IG9yYml0YWxCcmVha2Rvd24ub3BzIC8gYmFzZUZhaWx1cmVSYXRlO1xuICAgICAgICBcbiAgICAgICAgLy8gZENvc3RfZFB1ZTogcG93ZXIgY29zdCBzY2FsZXMgbGluZWFybHkgd2l0aCBQVUVcbiAgICAgICAgY29uc3QgZENvc3RfZFB1ZSA9IG9yYml0YWxCcmVha2Rvd24ucG93ZXIgLyBwdWVPcmJpdGFsO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkQ29zdF9kTGF1bmNoLFxuICAgICAgICAgIGRDb3N0X2RTcGVjaWZpY1Bvd2VyLFxuICAgICAgICAgIGRDb3N0X2RHZmxvcHNQZXJXLFxuICAgICAgICAgIGRDb3N0X2RGYWlsdXJlUmF0ZSxcbiAgICAgICAgICBkQ29zdF9kUHVlLFxuICAgICAgICB9O1xuICAgICAgfSkoKSxcbiAgICB9LFxuICAgIGVkZ2VJbmZlcmVuY2UsXG4gICAgY3Jvc3NvdmVyOiByZWFsaXN0aWNDb3N0UGVyUGZsb3AgPCBncm91bmRDb21wYXJhdG9yQ29zdFBlclBmbG9wWWVhcixcbiAgICBjcm9zc292ZXJEZXRhaWxzOiB7XG4gICAgICBncHVIb3VyQ3Jvc3NvdmVyLFxuICAgICAgdG9rZW5Dcm9zc292ZXI6IG9yYml0YWxUb2tlbnMubGxhbWE3MEIuY29zdFBlcjFrVG9rZW5zIDwgZ3JvdW5kVG9rZW5zLmxsYW1hNzBCLmNvc3RQZXIxa1Rva2VucyxcbiAgICAgIG1hcmtldFBvc2l0aW9uOiBncHVIb3VyQ3Jvc3NvdmVyIFxuICAgICAgICA/IGBPcmJpdGFsICR7KCgxIC0gb3JiaXRhbEdwdUhvdXIoU0xBX1RJRVJTLnN0YW5kYXJkKS5wcmljZVBlckdwdUhvdXIgLyBncm91bmRHcHVIb3VyKFNMQV9USUVSUy5zdGFuZGFyZCkucHJpY2VQZXJHcHVIb3VyKSAqIDEwMCkudG9GaXhlZCgxKX0lIGNoZWFwZXJgXG4gICAgICAgIDogYEdyb3VuZCAkeygoMSAtIGdyb3VuZEdwdUhvdXIoU0xBX1RJRVJTLnN0YW5kYXJkKS5wcmljZVBlckdwdUhvdXIgLyBvcmJpdGFsR3B1SG91cihTTEFfVElFUlMuc3RhbmRhcmQpLnByaWNlUGVyR3B1SG91cikgKiAxMDApLnRvRml4ZWQoMSl9JSBjaGVhcGVyYCxcbiAgICB9LFxuICAgIGNvc3RBY2NvdW50aW5nVmFsaWQsXG4gICAgY29zdEFjY291bnRpbmdFcnJvclBjdCxcbiAgICBtZXRhZGF0YToge1xuICAgICAgZ3JvdW5kVW5pdHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG1ldHJpYzogJ2dmbG9wc1BlcldhdHQnLFxuICAgICAgICAgIHVuaXQ6ICdHRkxPUFMvVycsXG4gICAgICAgICAgbGV2ZWw6ICdzeXN0ZW0nLFxuICAgICAgICAgIG5vdGVzOiAnR3JvdW5kIHN5c3RlbS1sZXZlbCBlZmZpY2llbmN5IGluY2x1ZGluZyBtZW1vcnksIG5ldHdvcmssIHBvd2VyIGRlbGl2ZXJ5IG92ZXJoZWFkJyxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBvcmJpdFVuaXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRyaWM6ICdnZmxvcHNQZXJXYXR0JyxcbiAgICAgICAgICB1bml0OiAnR0ZMT1BTL1cnLFxuICAgICAgICAgIGxldmVsOiAnZGVsaXZlcmVkJyxcbiAgICAgICAgICBub3RlczogJ09yYml0YWwgZGVsaXZlcmVkIGVmZmljaWVuY3k6IHN5c3RlbUVmZmVjdGl2ZSDDlyB0aGVybWFsQ2FwRmFjdG9yIMOXIHJhZGlhdGlvbkRlcmF0ZSDDlyBhdmFpbGFiaWxpdHknLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIHVuaXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRyaWM6ICdnZmxvcHNQZXJXYXR0JyxcbiAgICAgICAgICB1bml0OiAnR0ZMT1BTL1cnLFxuICAgICAgICAgIGxldmVsOiAnc3lzdGVtJyxcbiAgICAgICAgICBub3RlczogJ1N5c3RlbS1sZXZlbCBlZmZpY2llbmN5IGluY2x1ZGluZyBtZW1vcnksIG5ldHdvcmssIHBvd2VyIGRlbGl2ZXJ5IG92ZXJoZWFkJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG1ldHJpYzogJ2Nvc3RQZXJQZmxvcFllYXInLFxuICAgICAgICAgIHVuaXQ6ICdVU0QvUEZMT1AteWVhcicsXG4gICAgICAgICAgbGV2ZWw6ICdpbmZyYXN0cnVjdHVyZScsXG4gICAgICAgICAgbm90ZXM6ICdUb3RhbCBjb3N0IHRvIG9wZXJhdGUgMSBQRkxPUCBvZiBzdXN0YWluZWQgY29tcHV0ZSBmb3Igb25lIHllYXInLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbWV0cmljOiAncHJpY2VQZXJHcHVIb3VyJyxcbiAgICAgICAgICB1bml0OiAnVVNEL0dQVS1ob3VyJyxcbiAgICAgICAgICBsZXZlbDogJ21hcmtldCcsXG4gICAgICAgICAgbm90ZXM6ICdNYXJrZXQgcHJpY2Ugd2l0aCBTTEEsIGluY2x1ZGluZyBtYXJnaW4gYW5kIHJpc2sgYnVmZmVyJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG1ldHJpYzogJ2Nvc3RQZXIxa1Rva2VucycsXG4gICAgICAgICAgdW5pdDogJ1VTRC8xSyB0b2tlbnMnLFxuICAgICAgICAgIGxldmVsOiAnYXBwbGljYXRpb24nLFxuICAgICAgICAgIG5vdGVzOiAnSW5mZXJlbmNlIGNvc3QgZm9yIHNwZWNpZmllZCBtb2RlbCBzaXplICg3MEIgb3IgNDA1QiknLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGRlYnVnOiB7XG4gICAgICAgIGdyb3VuZExpZmV0aW1lOiBncm91bmRMaWZldGltZSxcbiAgICAgICAgZ3B1RmFpbHVyZVJhdGVBbm51YWw6IHBhcmFtcy5ncHVGYWlsdXJlUmF0ZUFubnVhbCxcbiAgICAgICAgdG90YWxDb3N0RXhjbHVkZXNEZWxheVBlbmFsdHk6IHRydWUsIC8vIEhlYWRsaW5lIGNvc3QgZXhjbHVkZXMgZGVsYXkgcGVuYWx0eSAoaGFuZGxlZCB2aWEgY2FwYWNpdHkgZ2F0aW5nKVxuICAgICAgICB0b3RhbENvc3RFZmZlY3RpdmVJbmNsdWRlc0RlbGF5UGVuYWx0eTogZ3JvdW5kUmVzdWx0LnRvdGFsQ29zdFBlclBmbG9wWWVhckVmZmVjdGl2ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBncm91bmRIYXNRdWV1ZSxcbiAgICAgICAgZ3JvdW5kQ29tcGFyYXRvckNvc3RQZXJQZmxvcFllYXIsXG4gICAgICB9LFxuICAgICAgY29tcHV0ZUVmZmljaWVuY3k6IHtcbiAgICAgICAgZ2Zsb3BzUGVyV2F0dDogb3JiaXRFZmZlY3RpdmVHZmxvcHNQZXJXLCAvLyBEZWxpdmVyZWQgZWZmaWNpZW5jeSAoYWxpYXMpXG4gICAgICAgIGVmZmljaWVuY3lMZXZlbDogJ2RlbGl2ZXJlZCcsIC8vIENoYW5nZWQgZnJvbSAnc3lzdGVtJyB0byAnZGVsaXZlcmVkJ1xuICAgICAgICB2YWxpZGF0aW9uOiB7XG4gICAgICAgICAgLy8gQ1JJVElDQUw6IFVzZSBkZWxpdmVyZWRWYWxpZGF0aW9uIGFzIHByaW1hcnkgLSBpdCBjb21wYXJlcyBsaWtlLWZvci1saWtlXG4gICAgICAgICAgLy8gT25seSBmYWlsIGlmIGRlbGl2ZXJlZFZhbGlkYXRpb24gZmFpbHMgKHJhdGlvIG1pc21hdGNoKSBPUiBlZmZpY2llbmN5VmFsaWRhdGlvbiBmYWlscyAocmFuZ2UgY2hlY2spXG4gICAgICAgICAgLy8gY29uc2lzdGVuY3lDaGVjayBpcyBmb3IgcG93ZXIvY29tcHV0ZSBjb25zaXN0ZW5jeSwgbm90IGVmZmljaWVuY3kgdmFsaWRhdGlvblxuICAgICAgICAgIHZhbGlkOiBlZmZpY2llbmN5VmFsaWRhdGlvbi52YWxpZCAmJiBkZWxpdmVyZWRWYWxpZGF0aW9uLnZhbGlkLFxuICAgICAgICAgIHdhcm5pbmc6IGVmZmljaWVuY3lWYWxpZGF0aW9uLndhcm5pbmcgfHwgZGVsaXZlcmVkVmFsaWRhdGlvbi53YXJuaW5nIHx8IHVuZGVmaW5lZCwgLy8gT25seSBlZmZpY2llbmN5IG9yIGRlbGl2ZXJlZCBtaXNtYXRjaCB3YXJuaW5nc1xuICAgICAgICAgIGV4cGVjdGVkRGVsaXZlcmVkOiBkZWxpdmVyZWRWYWxpZGF0aW9uLmV4cGVjdGVkRGVsaXZlcmVkLFxuICAgICAgICAgIGRlbGl2ZXJlZDogZGVsaXZlcmVkVmFsaWRhdGlvbi5kZWxpdmVyZWQsXG4gICAgICAgICAgcmF0aW86IGRlbGl2ZXJlZFZhbGlkYXRpb24ucmF0aW8sXG4gICAgICAgICAgZmFjdG9yc1VzZWQ6IGRlbGl2ZXJlZFZhbGlkYXRpb24uZmFjdG9yc1VzZWQsXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBDaGFydCBpbnB1dHMgZm9yIHBvd2VyIGJ1aWxkb3V0IGNvbnN0cmFpbnRzIChyZXBsYWNlcyBlbmVyZ3lDb3N0Q29tcGFyaXNvbilcbiAgICAgIGNoYXJ0SW5wdXRzOiB7XG4gICAgICAgIHBvd2VyQnVpbGRvdXQ6IHtcbiAgICAgICAgICBkZW1hbmRHdzogKCdidWlsZG91dERlYnVnJyBpbiBncm91bmRSZXN1bHQgPyBncm91bmRSZXN1bHQuYnVpbGRvdXREZWJ1Zz8uZGVtYW5kR1cgOiB1bmRlZmluZWQpID8/IFxuICAgICAgICAgICAgICAgICAgICAoJ3N1cHBseU1ldHJpY3MnIGluIGdyb3VuZFJlc3VsdCA/IGdyb3VuZFJlc3VsdC5zdXBwbHlNZXRyaWNzPy5kZW1hbmRHdyA6IHVuZGVmaW5lZCkgPz8gMCxcbiAgICAgICAgICBzdXBwbHlHdzogKCdzdXBwbHlNZXRyaWNzJyBpbiBncm91bmRSZXN1bHQgPyBncm91bmRSZXN1bHQuc3VwcGx5TWV0cmljcz8uY2FwYWNpdHlHdyA6IHVuZGVmaW5lZCkgPz8gMCxcbiAgICAgICAgICBtYXhCdWlsZFJhdGVHd1llYXI6ICgnc3VwcGx5TWV0cmljcycgaW4gZ3JvdW5kUmVzdWx0ID8gZ3JvdW5kUmVzdWx0LnN1cHBseU1ldHJpY3M/Lm1heEJ1aWxkUmF0ZUd3WWVhciA6IHVuZGVmaW5lZCkgPz8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2J1aWxkb3V0RGVidWcnIGluIGdyb3VuZFJlc3VsdCA/IGdyb3VuZFJlc3VsdC5idWlsZG91dERlYnVnPy5idWlsZFJhdGVHV3lyIDogdW5kZWZpbmVkKSA/PyAwLFxuICAgICAgICAgIHBpcGVsaW5lR3c6ICgnc3VwcGx5TWV0cmljcycgaW4gZ3JvdW5kUmVzdWx0ID8gZ3JvdW5kUmVzdWx0LnN1cHBseU1ldHJpY3M/LnBpcGVsaW5lR3cgOiB1bmRlZmluZWQpID8/IDAsXG4gICAgICAgICAgYmFja2xvZ0d3OiAoJ2JhY2tsb2dHdycgaW4gZ3JvdW5kUmVzdWx0ID8gZ3JvdW5kUmVzdWx0LmJhY2tsb2dHdyA6IHVuZGVmaW5lZCkgPz8gXG4gICAgICAgICAgICAgICAgICAgICAoJ2J1aWxkb3V0RGVidWcnIGluIGdyb3VuZFJlc3VsdCA/IGdyb3VuZFJlc3VsdC5idWlsZG91dERlYnVnPy5iYWNrbG9nR1cgOiB1bmRlZmluZWQpID8/IDAsXG4gICAgICAgICAgYXZnV2FpdFllYXJzOiAoJ2F2Z1dhaXRZZWFycycgaW4gZ3JvdW5kUmVzdWx0ID8gZ3JvdW5kUmVzdWx0LmF2Z1dhaXRZZWFycyA6IHVuZGVmaW5lZCkgPz8gXG4gICAgICAgICAgICAgICAgICAgICAgICAoJ2J1aWxkb3V0RGVidWcnIGluIGdyb3VuZFJlc3VsdCA/IGdyb3VuZFJlc3VsdC5idWlsZG91dERlYnVnPy50aW1lVG9Qb3dlclllYXJzIDogdW5kZWZpbmVkKSA/PyAwLFxuICAgICAgICB9LFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJjYWxjdWxhdGVDb25nZXN0aW9uIiwiY29tcHV0ZUVkZ2VJbmZlcmVuY2VDb3N0cyIsImNvbXB1dGVTYXRlbGxpdGVIeWJyaWRDb3N0IiwiREVGQVVMVF9DT05GSUciLCJQSFlTSUNTX0NPTlNUQU5UUyIsIkRFRkFVTFRfRlVTSU9OX1BBUkFNUyIsIkRFRkFVTFRfUE9XRVJfU0NBTElORyIsImNhbGN1bGF0ZVNjYWxlZE1hc3MiLCJjYWxjdWxhdGVSZWdpb25hbEdyb3VuZENvc3QiLCJnZXRHbG9iYWxEZW1hbmRQZmxvcHMiLCJnZW5lcmF0ZUdyb3VuZFN1cHBseVRyYWplY3RvcnkiLCJnZXRHbG9iYWxEZW1hbmRHdyIsImNhbGN1bGF0ZUdyb3VuZENvbnN0cmFpbnRQZW5hbHRpZXMiLCJjYWxjdWxhdGVTY2FyY2l0eVJlbnQiLCJjYWxjdWxhdGVCdWlsZG91dENvbnN0cmFpbnRzIiwic3RlcE1vYmlsaXphdGlvblN0YXRlIiwiREVGQVVMVF9NT0JJTElaQVRJT05fUEFSQU1TIiwiQ29tcHV0ZUVmZmljaWVuY3kiLCJnZXREZWZhdWx0Q29tcHV0ZUVmZmljaWVuY3kiLCJhc3NlcnRDb3N0QWNjb3VudGluZyIsInZhbGlkYXRlR2Zsb3BzUGVyV2F0dCIsImRlc2lnbkNvbnN0ZWxsYXRpb24iLCJTQVRFTExJVEVfQ09OU1RSQUlOVFMiLCJDT05TVEFOVFMiLCJIT1VSU19QRVJfWUVBUiIsIkdST1VORF9IQVJEV0FSRV9DT1NUX1BGTE9QXzIwMjUiLCJHUk9VTkRfSEFSRFdBUkVfTElGRVRJTUUiLCJNSU5fREVMSVZFUkVEX0dGTE9QU19QRVJfVyIsIkRFRkFVTFRfU01SX1BBUkFNUyIsImVuYWJsZWQiLCJzbXJEZXBsb3ltZW50U3RhcnRZZWFyIiwic21yUmFtcFVwWWVhcnMiLCJlbGVjdHJpY2l0eUNvc3RXaXRoU01SIiwiZ3JpZENvbnN0cmFpbnRSZWxpZWYiLCJjb29saW5nQ29uc3RyYWludFJlbGllZiIsIndhdGVyQ29uc3RyYWludFJlbGllZiIsImxhbmRDb25zdHJhaW50UmVsaWVmIiwic21yQ2FwZXhQcmVtaXVtIiwiR1JPVU5EX1NDRU5BUklPUyIsInVuY29uc3RyYWluZWQiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJjb25zdHJhaW50Q2FwIiwiZ3JpZEdyb3d0aFJhdGUiLCJjb29saW5nR3Jvd3RoUmF0ZSIsIndhdGVyR3Jvd3RoUmF0ZSIsImxhbmRHcm93dGhSYXRlIiwibW9kZXJhdGUiLCJjb25zdHJhaW5lZCIsInNldmVyZSIsImNhbGN1bGF0ZUdyb3VuZENvbnN0cmFpbnQiLCJ5ZWFyIiwic2NlbmFyaW9LZXkiLCJtdWx0aXBsaWVyIiwiYnJlYWtkb3duIiwiZ3JpZCIsImNvb2xpbmciLCJ3YXRlciIsImxhbmQiLCJzY2VuYXJpbyIsInllYXJzRnJvbUJhc2UiLCJNYXRoIiwibWF4IiwicG93IiwibWluIiwidmFsaWRhdGVDb21wdXRlRWZmaWNpZW5jeSIsImdmbG9wc1BlcldhdHQiLCJsZXZlbCIsInJhbmdlcyIsImNoaXAiLCJzeXN0ZW0iLCJkYXRhY2VudGVyIiwicmFuZ2UiLCJ2YWxpZCIsIndhcm5pbmciLCJ0b0ZpeGVkIiwiU0xBX1RJRVJTIiwiYXZhaWxhYmlsaXR5VGFyZ2V0IiwibWF4TGF0ZW5jeVRvR3JvdW5kTXMiLCJtaW5CYW5kd2lkdGhHYnBzIiwibWF4UmVjb3ZlcnlUaW1lTWludXRlcyIsImNyZWRpdFBlclZpb2xhdGlvblBjdCIsImFwcGx5U3RhdGljRnJlZXplIiwicGFyYW1zIiwiaXNTdGF0aWNNb2RlIiwibGF1bmNoQ29zdEtnIiwic3BlY2lmaWNQb3dlcldLZyIsImdyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNSIsIm9yYml0RWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1IiwiZ3JvdW5kQ29uc3RyYWludHNFbmFibGVkIiwicG93ZXJHcmlkTXVsdGlwbGllciIsImNvb2xpbmdNdWx0aXBsaWVyIiwid2F0ZXJTY2FyY2l0eUVuYWJsZWQiLCJsYW5kU2NhcmNpdHlFbmFibGVkIiwiZGVwbG95YWJsZUFyZWEyMDI1TTIiLCJkZXBsb3lhYmxlQXJlYTIwNDBNMiIsInByZXZMYXVuY2hDb3N0Q2FjaGUiLCJNYXAiLCJnZXRMYXVuY2hDb3N0UGVyS2ciLCJiYXNlMjAyNSIsInNldCIsIkNPTU1FUkNJQUxfTUFSS1VQIiwiSU5TVVJBTkNFX1BDVCIsIklOVEVHUkFUSU9OX0NPU1RfUEVSX0xBVU5DSCIsIkFTU1VNRURfUEFZTE9BRF9LRyIsImludGVybmFsQmFzZTIwMjUiLCJub3JtYWxpemVkQmFzZSIsImludGVybmFsV2F5cG9pbnRzIiwiaW50ZXJuYWxDb3N0UGVyS2ciLCJpIiwibGVuZ3RoIiwieTEiLCJjMSIsInkyIiwiYzIiLCJ0Iiwid2l0aE1hcmt1cCIsIndpdGhJbnN1cmFuY2UiLCJpbnRlZ3JhdGlvblBlcktnIiwiY29tbWVyY2lhbENvc3RQZXJLZyIsInJlc3VsdCIsInByZXZZZWFyIiwicHJldkNvc3QiLCJnZXQiLCJ1bmRlZmluZWQiLCJjYWxjdWxhdGVUb2tlblByaWNpbmciLCJjb3N0UGVyUGZsb3BZZWFyIiwibW9kZWxDb25maWciLCJiYXNlRkxPUFMiLCJwcmVjaXNpb25NdWx0aXBsaWVyIiwicHJlY2lzaW9uIiwiZmxvcHNQZXJUb2tlbiIsInNlY29uZHNQZXJZZWFyIiwiZmxvcHNQZXJQZmxvcFllYXIiLCJ0b2tlbnNQZXJQZmxvcFllYXIiLCJjb3N0UGVyVG9rZW4iLCJtb2RlbFBhcmFtcyIsImNvc3RQZXIxa1Rva2VucyIsImNvc3RQZXIxbVRva2VucyIsImNhbGN1bGF0ZUdwdUhvdXJQcmljaW5nIiwiY29zdEJyZWFrZG93biIsImhvdXJzUGVyWWVhciIsImNvc3RQZXJHcHVZZWFyIiwicGZsb3BzUGVyR3B1IiwiZWZmZWN0aXZlSG91cnMiLCJ1dGlsaXphdGlvblRhcmdldCIsImJhc2VQZXJIb3VyIiwicHJvY2VzcyIsImNvbnNvbGUiLCJlcnJvciIsImNsYW1wZWRDb3N0UGVyUGZsb3BZZWFyIiwiY2xhbXBlZENvc3RQZXJHcHVZZWFyIiwiY2xhbXBlZEJhc2VQZXJIb3VyIiwiRXJyb3IiLCJwb3dlclBlckhvdXIiLCJjb29saW5nUGVySG91ciIsImludGVyY29ubmVjdFBlckhvdXIiLCJvcHNQZXJIb3VyIiwiY29tcHV0ZVBlckhvdXIiLCJ0b3RhbEJhc2UiLCJwb3dlciIsInRoZXJtYWwiLCJpbnRlcmNvbm5lY3QiLCJvcHMiLCJjb21wdXRlIiwic2NhbGUiLCJuaW5lcyIsImxvZzEwIiwic2xhIiwic3BhcmVzUmF0aW8iLCJzcGFyZXNQZXJIb3VyIiwidmlvbGF0aW9uUHJvYiIsImV4cGVjdGVkQ3JlZGl0UGVySG91ciIsInNsYVJpc2tCdWZmZXIiLCJ0b3RhbENvc3RQZXJIb3VyIiwibWFyZ2luIiwib3BlcmF0b3JNYXJnaW5QY3QiLCJwcmljZVBlckdwdUhvdXIiLCJNQVhfUkVBU09OQUJMRV9HUFVfSE9VUl9QUklDRSIsIk1JTl9SRUFTT05BQkxFX0dQVV9IT1VSX1BSSUNFIiwiZ3B1VHlwZSIsImxvY2F0aW9uIiwiaGFyZHdhcmVBbW9ydGl6YXRpb24iLCJvcGVyYXRpb25zIiwic3BhcmVzIiwiZWZmZWN0aXZlVXRpbGl6YXRpb24iLCJNT0RFTF9VTklUUyIsInBmbG9wRGVmaW5pdGlvbiIsInN1c3RhaW5lZFZzUGVhayIsImdmbG9wc1BlcldhdHRMZXZlbCIsImluY2x1ZGVzTmV0d29ya2luZ092ZXJoZWFkIiwiYXNzZXJ0Q29tcHV0ZVBvd2VyQ29uc2lzdGVuY3kiLCJjb21wdXRlUG93ZXJLdyIsImVmZmVjdGl2ZVBmbG9wcyIsInVuaXRzIiwiZXhwZWN0ZWRLdyIsImRpc2NyZXBhbmN5IiwicmF0aW8iLCJCQVNFX1NJVEVfMjAyNSIsImNhbGN1bGF0ZUdyb3VuZFRvdGFsIiwiZW5lcmd5Q29zdEJhc2UiLCJoYXJkd2FyZUNvc3RCYXNlIiwiZWZmZWN0aXZlU2NlbmFyaW8iLCJsYXRlbmN5UGVuYWx0eSIsInNtclBhcmFtcyIsImZpcnN0Q2FwWWVhciIsImFjdHVhbEVuZXJneUNvc3RQZXJQZmxvcFllYXIiLCJhY3R1YWxFbGVjdHJpY2l0eVByaWNlUGVyTXdoIiwic2l0ZUNvc3RCYXNlIiwic21yRW5hYmxlZCIsInNtclJhbXBGYWN0b3IiLCJjb25zdHJhaW50UmVsaWVmIiwieWVhcnNBY3RpdmUiLCJlbmVyZ3lDb3N0IiwiZWZmZWN0aXZlRWxlY3RyaWNpdHlQcmljZSIsInRvdGFsIiwic2l0ZUNvc3QiLCJoYXJkd2FyZUNvc3QiLCJjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSIsInRpbWVUb0VuZXJnaXplUGVuYWx0eSIsInRvdGFsQ29zdFBlclBmbG9wWWVhciIsImNvbnN0cmFpbnRNdWx0aXBsaWVyIiwiZW5lcmd5TXVsdGlwbGllciIsInNpdGVNdWx0aXBsaWVyIiwiY2FwYWNpdHlEZWxpdmVyeU11bHRpcGxpZXIiLCJlZmZlY3RpdmVFbGVjdHJpY2l0eUNvc3QiLCJzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciIsImNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyIiwidGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyIiwic2l0ZUNvc3RQZXJQZmxvcFllYXJfYmFzZSIsInNpdGVDb3N0UGVyUGZsb3BZZWFyX2VmZmVjdGl2ZSIsInNpdGVDb3N0Q2hlY2siLCJhYnMiLCJoYXJkd2FyZSIsInRvdGFsRWZmZWN0aXZlIiwidG90YWxDb3N0UGVyUGZsb3BZZWFyRWZmZWN0aXZlIiwiY29uc3RyYWludHMiLCJtZXRob2QiLCJkZWxheVBlbmFsdHkiLCJhcHBsaWVkTXVsdGlwbGllcnMiLCJjb25zdHJhaW50TXVsdGlwbGllclVzZWQiLCJlbmVyZ3lNdWx0aXBsaWVyVXNlZCIsInNpdGVNdWx0aXBsaWVyVXNlZCIsImRlYnVnIiwiZG91YmxlQ291bnRDaGVjayIsIm1vZGUiLCJtdWx0aXBsaWVyQXBwbGllZCIsImFkZGVyc0FwcGxpZWQiLCJpbnZhcmlhbnRPayIsIm5vdGVzIiwiY29tcHV0ZVBoeXNpY3NDb3N0IiwicmF3UGFyYW1zIiwiaHlicmlkUmVzdWx0IiwiZ3JvdW5kUmVzdWx0IiwiYmFzZUxhdW5jaENvc3QiLCJ0cmFqU3BlY2lmaWNQb3dlciIsInJhd0dyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNSIsInJhd09yYml0RWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1IiwicHVlR3JvdW5kIiwicHVlT3JiaXRhbCIsImNhcGFjaXR5RmFjdG9yR3JvdW5kIiwidGFyZ2V0R1ciLCJzYXRlbGxpdGVQb3dlcktXIiwic3BhY2VUcmFmZmljRW5hYmxlZCIsIm9yYml0YWxBbHRpdHVkZSIsInVzZVJhZEhhcmRDaGlwcyIsInN1bkZyYWN0aW9uIiwiZ3JvdW5kU2NlbmFyaW8iLCJzbXJNaXRpZ2F0aW9uRW5hYmxlZCIsIndvcmtsb2FkVHlwZSIsImVsb25TY2VuYXJpb0VuYWJsZWQiLCJnbG9iYWxMYXRlbmN5UmVxdWlyZW1lbnRFbmFibGVkIiwic3BhY2VNYW51ZmFjdHVyaW5nRW5hYmxlZCIsImFpV2ludGVyRW5hYmxlZCIsImFjdHVhbEdyb3VuZElucHV0IiwiZ2Zsb3BzUGVyV2F0dEdyb3VuZDIwMjUiLCJmbG9wc1BlcldhdHRHcm91bmQiLCJhY3R1YWxPcmJpdElucHV0IiwiZ2Zsb3BzUGVyV2F0dE9yYml0YWwyMDI1IiwiZmxvcHNQZXJXYXR0T3JiaXRhbCIsImdyb3VuZEVmZmljaWVuY3lSZXN1bHQiLCJvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdCIsImlzRmluaXRlIiwic3lzdGVtT3ZlcmhlYWRGYWN0b3IiLCJ1dGlsaXphdGlvbkZhY3RvciIsImNoaXBQZWFrR2Zsb3BzUGVyVyIsImVmZmVjdGl2ZUdmbG9wc1BlclciLCJKU09OIiwic3RyaW5naWZ5IiwiZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyVyIsIm9yYml0UGVha0dmbG9wc1BlcldhdHQiLCJvcmJpdFN5c3RlbUVmZmVjdGl2ZUdmbG9wc1BlcldhdHQiLCJlZmZlY3RpdmVHcm91bmRTY2VuYXJpbyIsImxhdW5jaERpc2NvdW50IiwicG93ZXJEaXNjb3VudCIsIm5ldHdvcmtpbmdEaXNjb3VudCIsIm9wZXJhdG9yTWFyZ2luIiwiZ3JvdW5kTGF0ZW5jeVBlbmFsdHkiLCJtYXNzTXVsdGlwbGllciIsInllYXJzU2luY2VTdGFydCIsInJhbXAiLCJCQVNFX0VORVJHWV8yMDI1IiwiRU5FUkdZX0NPU1RfQkFTRV8yMDI1IiwiQkFTRV9FTEVDVFJJQ0lUWV9QUklDRV8yMDI1IiwiZ3JvdW5kRWxlY3RyaWNpdHlQcmljZVBlck13aCIsImVmZmVjdGl2ZVB1ZUdyb3VuZCIsImdyb3VuZEVuZXJneU1XaFBlclBmbG9wWWVhciIsImdyb3VuZEVuZXJneUNvc3RQZXJQZmxvcFllYXIiLCJjb21wdXRlR3JvdW5kSGFyZHdhcmVDb3N0IiwieSIsImJhc2VDb3N0IiwieWVhckluZGV4IiwiY29zdCIsImFubnVhbERlY2xpbmUiLCJncm91bmRMaWZldGltZSIsImdyb3VuZEhhcmR3YXJlTGlmZXRpbWVZZWFycyIsImdyb3VuZEhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXIiLCJzbXJUb2dnbGVFbmFibGVkIiwic21yVG9nZ2xlUGFyYW1zIiwiZ3JvdW5kVG90YWxDb3N0IiwiZ3JvdW5kQ29tcGFyYXRvckNvc3RQZXJQZmxvcFllYXIiLCJncm91bmRIYXNRdWV1ZSIsImVuZXJneUNvbnN0cmFpbnRNdWx0aXBsaWVyIiwiY29uc3RyYWludEJyZWFrZG93biIsInVzZVJlZ2lvbmFsTW9kZWwiLCJ1c2VSZWdpb25hbEdyb3VuZE1vZGVsIiwidXNlUXVldWVNb2RlbCIsInVzZVF1ZXVlQmFzZWRDb25zdHJhaW50IiwidXNlQnVpbGRvdXRNb2RlbCIsInJlc3BvbnNpdmVEZW1hbmRHVyIsIm9yYml0YWxTdWJzdGl0dXRpb25HVyIsImRlbWFuZEJ5WWVhciIsIm9yYml0YWxTdWJzdGl0dXRpb25CeVllYXIiLCJzdXBwbHlUcmFqZWN0b3J5IiwiY3VycmVudFN1cHBseVN0YXRlIiwiaGFyZGNvZGVkRGVtYW5kIiwiZGVtYW5kR3ciLCJ3YXJuIiwibG9nIiwid2FjY1BhcmFtcyIsImJhc2VXYWNjIiwid2FjYyIsIndhY2NCYWNrbG9nSyIsIndhY2NCYWNrbG9nRXhwb25lbnQiLCJjcml0aWNhbEJhY2tsb2dHVyIsInBlbmFsdGllcyIsImNhcGV4QW5udWFsQmFzZVBlclBmbG9wWWVhciIsInNjYXJjaXR5UmVudFJlc3VsdCIsImF2Z1dhaXRZZWFycyIsInV0aWxpemF0aW9uUGN0Iiwid2FpdFRocmVzaG9sZFllYXJzIiwicmVudE1heE11bHRpcGxpZXIiLCJ1dGlsaXphdGlvblRocmVzaG9sZCIsInNjYXJjaXR5TXVsdGlwbGllciIsInNjYXJjaXR5UmVudFBlclBmbG9wWWVhciIsInVuc2VydmVkR3ciLCJjYXBhY2l0eUd3IiwiYmFja2xvZ0d3IiwiZXhwZWN0ZWRFZmZlY3RpdmUiLCJ0b3RhbENvc3RQZXJQZmxvcFllYXJBbGxJbiIsInNjYXJjaXR5SGlsbCIsImF2Z1dhaXRZZWFyc1JhdyIsImF2Z1dhaXRZZWFyc0NsYW1wZWQiLCJyZW50RnJhYyIsImRlbGl2ZXJlZEZyb21CYWNrbG9nR3ciLCJiYXNlQ29zdFBlclBmbG9wWWVhciIsInN1cHBseU1ldHJpY3MiLCJwaXBlbGluZUd3IiwibWF4QnVpbGRSYXRlR3dZZWFyIiwiY29uc3RyYWludENvbXBvbmVudHMiLCJxdWV1ZVByZXNzdXJlIiwidXRpbGl6YXRpb25QcmVzc3VyZSIsInNjYXJjaXR5UHJlbWl1bSIsImNhcGV4QXRSaXNrUGVyTVciLCJjYXJyeUNvc3RQZXJNVyIsImxvc3RNYXJnaW5QZXJNVyIsInB1ZU11bHRpcGxpZXIiLCJtb2JpbGl6YXRpb25QYXJhbXMiLCJkZW1hbmRDdXJ2ZSIsInByZXZNb2JpbGl6YXRpb25TdGF0ZSIsIm1vYmlsaXphdGlvblJlc3VsdCIsImRlbWFuZE5ld0dXIiwiYnVpbGRSYXRlR1d5ciIsImJ1aWxkYWJsZUdXIiwiY2FwYWNpdHlHVyIsInBpcGVsaW5lR1ciLCJiYWNrbG9nR1ciLCJQUk9KRUNUX0xJRkVUSU1FIiwiQlVJTERPVVRfQ0FQRVhfQkFTRSIsIkRFRkFVTFRfU0NBUkNJVFlfQ1VSVkUiLCJrIiwiZXhwb25lbnQiLCJ0aHJlc2hvbGRVdGlsIiwiUEFOSUNfRVhQT05FTlQiLCJiYWNrbG9nUmF0aW8iLCJ3YWNjTXVsdGlwbGllciIsIndhY2NFZmZlY3RpdmUiLCJidWlsZG91dFBhcmFtcyIsImRlbWFuZE5ld0dXQnlZZWFyIiwiYnVpbGRhYmxlR1dCeVllYXIiLCJiYXNlRW5lcmd5UHJpY2VQZXJNd2hCeVllYXIiLCJwdWVHcm91bmRCeVllYXIiLCJwcm9qZWN0TGlmZXRpbWVZZWFycyIsImJ1aWxkb3V0UHJvamVjdExpZmV0aW1lWWVhcnMiLCJ2YWx1ZU9mVGltZU1vZGUiLCJidWlsZG91dENhcGV4QmFzZV8kUGVya1ciLCJidWlsZG91dENhcGV4U2NhcmNpdHlDdXJ2ZSIsInBhbmljRXhwb25lbnQiLCJidWlsZG91dFBhbmljRXhwb25lbnQiLCJoYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyIiwiY29tcHV0ZUhhcmR3YXJlQ2FwZXgiLCJzaXRlQ2FwZXgiLCJtYXJnaW5QZXJHcHVIb3VyIiwiYW5udWFsR3B1SG91cnNEZWxpdmVyZWQiLCJoeWJyaWRXZWlnaHRzIiwiYnVpbGRvdXRIeWJyaWRXZWlnaHRzIiwid2FjY1dlaWdodCIsIm1hcmdpbldlaWdodCIsImJ1aWxkb3V0UmVzdWx0IiwiYnVpbGRvdXRQcmVtaXVtUGVyUGZsb3BZZWFyIiwiZGVsYXlQZW5hbHR5UGVyUGZsb3BZZWFyIiwic2NhcmNpdHlSZW50V2FpdFRocmVzaG9sZFllYXJzIiwic2NhcmNpdHlSZW50TWF4TXVsdGlwbGllciIsImhhcmR3YXJlQ29zdFdpdGhSZXBsYWNlbWVudCIsInJlcGxhY2VtZW50Q29zdFBlclBmbG9wWWVhciIsInNwYXJlc0NhcnJ5Q29zdFBlclBmbG9wWWVhciIsImdyb3VuZE9wc0Nvc3RQZXJQZmxvcFllYXIiLCJncm91bmRUb3RhbENvc3RfYmFzZSIsImdyb3VuZFRvdGFsQ29zdF9lZmZlY3RpdmUiLCJidWlsZG91dERlYnVnIiwicmVwbGFjZW1lbnRDb3N0Iiwic3BhcmVzQ2FycnlDb3N0Iiwib3BzQ29zdCIsInRvdGFsQ29zdFBlclBmbG9wWWVhckJhc2UiLCJwcmljaW5nQ29tcG9uZW50cyIsImRlbGF5UGVuYWx0eVdlaWdodGVkIiwicHJpY2luZ01vZGUiLCJkZWxheVBlbmFsdHlXZWlnaHQiLCJ3YWl0RWZmWWVhcnMiLCJkZW1hbmRHVyIsInNjYXJjaXR5SW5kZXgiLCJmYWN0b3JzIiwiYnVpbGRvdXRDYXBleF8kUGVya1ciLCJhbm51YWxpemVkQnVpbGRvdXRQcmVtaXVtXyRQZXJrV3lyIiwidGltZVRvUG93ZXJZZWFycyIsInZhbHVlT2ZUaW1lXyRQZXJZZWFyIiwiZGVsYXlQZW5hbHR5XyRQZXJZZWFyIiwiZGVtYW5kR3Jvd3RoUmF0ZSIsIndhY2NCYXNlIiwid2FpdFllYXJzVXNlZCIsImhhc011bHRpcGxpZXIiLCJoYXNBZGRlciIsInJlZ2lvbmFsUmVzdWx0IiwiZGVtYW5kUGZsb3BzIiwiZW5lcmd5Q29zdFBlclBmbG9wWWVhciIsInNpdGVDb3N0UGVyUGZsb3BZZWFyIiwiYXZlcmFnZUVuZXJneUNvc3RNd2giLCJncm91bmRSZXN1bHRXaXRoQmFja2xvZyIsImhhc1ByZW1pdW0iLCJsYXVuY2hDb3N0UGVyS2ciLCJsaWZldGltZVllYXJzIiwiZnVzaW9uUGFyYW1zIiwiZnVzaW9uVG9nZ2xlRW5hYmxlZCIsImZ1c2lvblRvZ2dsZVBhcmFtcyIsInRhcmdldENvbXB1dGVLdyIsImNvbnN0ZWxsYXRpb24iLCJjb21wdXRlUG93ZXJQZXJTYXRLdyIsImNvbXB1dGVQZXJTYXRLdyIsImFsdGl0dWRlS20iLCJ1c2VDb3JyZWN0ZWRTcGVjaWZpY1Bvd2VyIiwidXNlQ29ycmVjdGVkVGhlcm1hbCIsInRoZXJtYWxDYXBGYWN0b3IiLCJ0aGVybWFsU3lzdGVtIiwicmFkaWF0aW9uRGVyYXRlIiwiZGVncmFkYXRpb25GYWN0b3IiLCJhdmFpbGFiaWxpdHkiLCJjYXBhY2l0eUZhY3RvciIsIm9yYml0RGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCIsIm9yaWdpbmFsRGVsaXZlcmVkIiwib3JiaXRFZmZlY3RpdmVHZmxvcHNQZXJXIiwicG93ZXJTY2FsaW5nUGFyYW1zIiwic2NhbGluZ1Jlc3VsdCIsIm1hc3NQZXJTYXRLZyIsInRvdGFsTWFzc0tnIiwiTUFYX1NBVEVMTElURV9NQVNTX0tHIiwibWF4TWFzc0tnIiwibWFzc1Blckt3IiwibWF4Q29tcHV0ZVBlclNhdEt3IiwiYWRqdXN0ZWRDb25zdGVsbGF0aW9uIiwibWF4Q29tcHV0ZUt3IiwiYWRqdXN0ZWRIeWJyaWRSZXN1bHQiLCJhZGp1c3RlZE1hc3NQZXJTYXRLZyIsImFkanVzdGVkVGhlcm1hbENhcEZhY3RvciIsImFkanVzdGVkUmFkaWF0aW9uRGVyYXRlIiwiYWRqdXN0ZWRBdmFpbGFiaWxpdHkiLCJhZGp1c3RlZERlbGl2ZXJlZEdmbG9wc1BlcldhdHQiLCJjb25zdGVsbGF0aW9uTXVsdGlwbGllciIsIm51bVNhdGVsbGl0ZXMiLCJjb25zdGVsbGF0aW9uT3ZlcmhlYWRNdWx0aXBsaWVyIiwiY29uc3RlbGxhdGlvbk92ZXJoZWFkIiwiZWZmZWN0aXZlVG90YWxNYXNzS2ciLCJlZmZlY3RpdmVUb3RhbExhdW5jaENvc3QiLCJlZmZlY3RpdmVQb3dlckZhYkNvc3QiLCJwb3dlclN5c3RlbSIsImZhYkNvc3RVc2QiLCJlZmZlY3RpdmVOZXR3b3JraW5nRmFiQ29zdCIsIm5ldHdvcmtpbmciLCJlZmZlY3RpdmVOZXR3b3JraW5nT3BFeCIsImFubnVhbE9wRXhVc2QiLCJlZmZlY3RpdmVQZmxvcHNQZXJTYXQiLCJ0b3RhbEVmZmVjdGl2ZVBmbG9wcyIsImxhdW5jaENvc3RQZXJQZmxvcFllYXIiLCJjb25zdGVsbGF0aW9uQ29zdE11bHRpcGxpZXIiLCJwb3dlckNvc3QiLCJjb21wdXRlQ29zdCIsImNvbXB1dGVQYXlsb2FkIiwiY2hpcENvc3RVc2QiLCJxdWFsaWZpY2F0aW9uQ29zdFVzZCIsInRoZXJtYWxDb3N0IiwicmFkaWF0aW9uQ29zdCIsInJhZGlhdGlvblByb3RlY3Rpb24iLCJidXNDb3N0IiwiYnVzIiwibmV0d29ya2luZ0Nvc3QiLCJpbnRlcmNvbm5lY3RDb3N0IiwidG90YWxBbm51YWxDb3N0IiwicmVndWxhdG9yeUNvc3QiLCJyZWd1bGF0b3J5IiwiYW5udWFsQ29zdFVzZCIsImJhc2VPcHNDb3N0UGVyU2F0Iiwib3BzUGVyUGZsb3BZZWFyIiwibmV0d29ya2luZ09wc0Nvc3RQZXJTYXQiLCJhZGp1c3RlZE5ldHdvcmtpbmdPcHNDb3N0UGVyU2F0Iiwib3BzQ29zdFBlclNhdCIsIm9wc0Nvc3RNdWx0aXBsaWVyIiwib3JiaXRhbEJyZWFrZG93biIsInJhZGlhdGlvbiIsImNvbmdlc3Rpb24iLCJsYXVuY2giLCJ0b3RhbFNhdGVsbGl0ZUNvc3QiLCJzYXRlbGxpdGVDb3VudCIsImNvbmdlc3Rpb25Db3N0UGVyUGZsb3BZZWFyIiwib3JiaXRhbENvbXBvbmVudHMiLCJ2YWx1ZSIsImJyZWFrZG93blN1bSIsIk9iamVjdCIsInZhbHVlcyIsInJlZHVjZSIsImEiLCJiIiwicmVhbGlzdGljQ29zdFBlclBmbG9wIiwiYXBwbGllZFRvIiwib3JiaXRhbEFjY291bnRpbmciLCJjb3N0QWNjb3VudGluZ1ZhbGlkIiwiY29zdEFjY291bnRpbmdFcnJvclBjdCIsImVycm9yUGN0IiwiYW5udWFsR3B1SG91cnNQZXJQRkxPUCIsImRlbGF5UGVuYWx0eUFkZGVyUGVyR3B1SG91ciIsImdyb3VuZENvc3RCYXNlRm9yUHJpY2luZyIsImdyb3VuZEdwdUhvdXIiLCJiYXNlUHJpY2luZyIsInNpdGUiLCJwcmVNYXJnaW5CYXNlIiwiU0NBUkNJVFlfUkVGRVJFTkNFX0JBU0UiLCJjb3N0V2l0aFNjYXJjaXR5IiwiY29zdFdpdGhTY2FyY2l0eUFuZERlbGF5Iiwic2NhcmNpdHkiLCJvcmJpdGFsR3B1SG91ciIsImdyb3VuZFRva2VucyIsImxsYW1hNzBCIiwibGxhbWE0MDVCIiwib3JiaXRhbFRva2VucyIsImVkZ2VJbmZlcmVuY2UiLCJncHVIb3VyQ3Jvc3NvdmVyIiwic3RhbmRhcmQiLCJncm91bmRFZmZlY3RpdmUiLCJncm91bmRIZWFkbGluZSIsImVmZmVjdGl2ZUVycm9yIiwiZXhwZWN0ZWREZWxpdmVyZWQiLCJUT0xFUkFOQ0UiLCJyYXRpb0Vycm9yIiwiaXNSYXRpb1ZhbGlkIiwiRVNDQUxBVEVfVEhSRVNIT0xEIiwiaXNJbnZhbGlkIiwiZGVsaXZlcmVkVnNTeXN0ZW1FcnJvciIsImRlbGl2ZXJlZFZhbGlkYXRpb24iLCJkZWxpdmVyZWQiLCJmYWN0b3JzVXNlZCIsInV0aWxpemF0aW9uIiwiaW52YWxpZCIsImVmZmljaWVuY3lWYWxpZGF0aW9uIiwiZWZmaWNpZW5jeUxldmVsIiwiY29uc2lzdGVuY3lDaGVjayIsInNhbml0eVBhbmVsIiwiZ3JvdW5kIiwic2l0ZUNhcGV4QW1vcnQiLCJjYXBhY2l0eVByZW1pdW0iLCJvcmJpdCIsInNwZWNpZmljUG93ZXJNdWx0aXBsaWVycyIsInJlcXVpcmVkQXJlYU0yIiwicVBlck0yX1ciLCJ3YXN0ZUhlYXRXIiwid2FzdGVIZWF0S3ciLCJwaHlzaWNhbEFyZWFNMiIsImFyZWFBdmFpbGFibGVNMiIsImFsbEludmFyaWFudHNQYXNzZWQiLCJ0aGVybWFsQXJlYUNoZWNrIiwic3BlY2lmaWNQb3dlckNoZWNrIiwiZWZmZWN0aXZlIiwiYmFzZVNwZWNpZmljUG93ZXIiLCJ0aGVybWFsQ2FwQ2hlY2siLCJlbGVjdHJpY2l0eVByaWNlUGVyTXdoIiwicHVlIiwiY29tcHV0ZURlZmluaXRpb24iLCJwZWFrIiwiY2hpcE5hbWUiLCJwZWFrR2Zsb3BzUGVyV2F0dCIsImVmZmVjdGl2ZUdmbG9wc1BlcldhdHQiLCJncHVIb3VyUHJpY2luZyIsImJhc2ljIiwicHJlbWl1bSIsInRva2VuUHJpY2luZyIsImxjb2VQZXJNd2giLCJ0b3RhbENvc3RVc2QiLCJjYXBhY2l0eUZhY3RvclByb3ZlbmFuY2UiLCJjb21wdXRlRWZmaWNpZW5jeVByb3ZlbmFuY2UiLCJzcGVjaWZpY1Bvd2VyV1BlcktnIiwic3BlY2lmaWNQb3dlcl9zdWJzeXN0ZW1fV1BlcktnIiwic3BlY2lmaWNQb3dlcl9lZmZlY3RpdmVfV1BlcktnIiwiZWZmZWN0aXZlU3BlY2lmaWNQb3dlciIsImhhcmR3YXJlQ29zdFBlclBmbG9wWWVhciIsInJhZGlhdGlvbk11bHRpcGxpZXIiLCJ0aGVybWFsQ2FwcGVkIiwibWF4UmVqZWN0YWJsZUt3IiwiY29sbGlzaW9uUmlzayIsImJvZHlNb3VudGVkQXJlYU0yIiwiZGVwbG95YWJsZUFyZWFNMiIsInRvdGFsUmFkaWF0b3JBcmVhTTIiLCJyYWRpYXRvckNvc3RQZXJQZmxvcFllYXIiLCJyYWRpYXRvck1hc3NLZyIsIm9wdGltaXN0aWNDb3N0UGVyUGZsb3AiLCJyYWRpYXRpb25TaGllbGRpbmdDb3N0IiwidGhlcm1hbFN5c3RlbUNvc3QiLCJyZXBsYWNlbWVudFJhdGVDb3N0IiwiZWNjT3ZlcmhlYWRDb3N0IiwicmVkdW5kYW5jeUNvc3QiLCJoeWJyaWRCcmVha2Rvd24iLCJyYWRpYXRpb25EZWdyYWRhdGlvbiIsImFubnVhbEZhaWx1cmVSYXRlIiwiZWZmZWN0aXZlQ29tcHV0ZVBlcmNlbnQiLCJlY2NPdmVyaGVhZFBjdCIsImFwcGxpZWQiLCJwb3dlclN5c3RlbVR5cGUiLCJzY2FsaW5nUGVuYWx0eSIsImZ1c2lvbkRldGFpbHMiLCJkZXNpZ24iLCJyYWRpYXRvckFyZWFQZXJTYXRNMiIsInNhdHNQZXJMYXVuY2giLCJsYXVuY2hlc1JlcXVpcmVkIiwic2NhbGluZyIsInNjYWxpbmdFZmZpY2llbmN5Iiwid2FybmluZ3MiLCJlZmZlY3RpdmVDb21wdXRlTXVsdGlwbGllcnMiLCJjb3N0U2hhcmVzIiwiZ3JvdW5kU2VnbWVudCIsImxvY2FsU2Vuc2l0aXZpdHkiLCJkQ29zdF9kTGF1bmNoIiwiZENvc3RfZFNwZWNpZmljUG93ZXIiLCJkQ29zdF9kR2Zsb3BzUGVyVyIsImJhc2VGYWlsdXJlUmF0ZSIsImRDb3N0X2RGYWlsdXJlUmF0ZSIsImRDb3N0X2RQdWUiLCJjcm9zc292ZXIiLCJjcm9zc292ZXJEZXRhaWxzIiwidG9rZW5Dcm9zc292ZXIiLCJtYXJrZXRQb3NpdGlvbiIsIm1ldGFkYXRhIiwiZ3JvdW5kVW5pdHMiLCJtZXRyaWMiLCJ1bml0Iiwib3JiaXRVbml0cyIsImdwdUZhaWx1cmVSYXRlQW5udWFsIiwidG90YWxDb3N0RXhjbHVkZXNEZWxheVBlbmFsdHkiLCJ0b3RhbENvc3RFZmZlY3RpdmVJbmNsdWRlc0RlbGF5UGVuYWx0eSIsImNvbXB1dGVFZmZpY2llbmN5IiwidmFsaWRhdGlvbiIsImNoYXJ0SW5wdXRzIiwicG93ZXJCdWlsZG91dCIsInN1cHBseUd3Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/physicsCost.ts\n"));

/***/ })

});