"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/compare/page",{

/***/ "(app-pages-browser)/./app/lib/model/physicsCost.ts":
/*!**************************************!*\
  !*** ./app/lib/model/physicsCost.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_SMR_PARAMS: function() { return /* binding */ DEFAULT_SMR_PARAMS; },\n/* harmony export */   GROUND_SCENARIOS: function() { return /* binding */ GROUND_SCENARIOS; },\n/* harmony export */   MODEL_UNITS: function() { return /* binding */ MODEL_UNITS; },\n/* harmony export */   computePhysicsCost: function() { return /* binding */ computePhysicsCost; },\n/* harmony export */   getLaunchCostPerKg: function() { return /* binding */ getLaunchCostPerKg; }\n/* harmony export */ });\n/* harmony import */ var _congestion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./congestion */ \"(app-pages-browser)/./app/lib/model/congestion.ts\");\n/* harmony import */ var _edgeInference__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./edgeInference */ \"(app-pages-browser)/./app/lib/model/edgeInference.ts\");\n/* harmony import */ var _orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./orbitalPhysics */ \"(app-pages-browser)/./app/lib/model/orbitalPhysics.ts\");\n/* harmony import */ var _ground_supply_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ground_supply_model */ \"(app-pages-browser)/./app/lib/model/ground_supply_model.ts\");\n/* harmony import */ var _ground_queue_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ground_queue_model */ \"(app-pages-browser)/./app/lib/model/ground_queue_model.ts\");\n/* harmony import */ var _ground_constraint_penalties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ground_constraint_penalties */ \"(app-pages-browser)/./app/lib/model/ground_constraint_penalties.ts\");\n/* harmony import */ var _ground_buildout__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ground_buildout */ \"(app-pages-browser)/./app/lib/model/ground_buildout.ts\");\n/* harmony import */ var _ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ground_ramping_mobilization */ \"(app-pages-browser)/./app/lib/model/ground_ramping_mobilization.ts\");\n/* harmony import */ var _compute_efficiency__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./compute_efficiency */ \"(app-pages-browser)/./app/lib/model/compute_efficiency.ts\");\n/* harmony import */ var _cost_accounting__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./cost_accounting */ \"(app-pages-browser)/./app/lib/model/cost_accounting.ts\");\n/* harmony import */ var _units__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./units */ \"(app-pages-browser)/./app/lib/model/units.ts\");\n/* harmony import */ var _constellation_sizing__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./constellation_sizing */ \"(app-pages-browser)/./app/lib/model/constellation_sizing.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst CONSTANTS = {\n    HOURS_PER_YEAR: 8760,\n    GROUND_HARDWARE_COST_PFLOP_2025: 15000,\n    GROUND_HARDWARE_LIFETIME: 3,\n    MIN_DELIVERED_GFLOPS_PER_W: 20\n};\nconst DEFAULT_SMR_PARAMS = {\n    enabled: false,\n    smrDeploymentStartYear: 2030,\n    smrRampUpYears: 5,\n    electricityCostWithSMR: 50,\n    gridConstraintRelief: 0.90,\n    coolingConstraintRelief: 0.50,\n    waterConstraintRelief: 0.30,\n    landConstraintRelief: 0.60,\n    smrCapexPremium: 1.15\n};\nconst GROUND_SCENARIOS = {\n    unconstrained: {\n        name: \"Unconstrained\",\n        description: \"SMRs + geographic arbitrage solve power/water constraints\",\n        constraintCap: 1.5,\n        gridGrowthRate: 0.02,\n        coolingGrowthRate: 0.01,\n        waterGrowthRate: 0.01,\n        landGrowthRate: 0.01\n    },\n    moderate: {\n        name: \"Moderate\",\n        description: \"Partial adaptation, some persistent friction\",\n        constraintCap: 3.0,\n        gridGrowthRate: 0.03,\n        coolingGrowthRate: 0.02,\n        waterGrowthRate: 0.015,\n        landGrowthRate: 0.015\n    },\n    constrained: {\n        name: \"Constrained (Aggressive Baseline)\",\n        description: \"Accelerated AI demand pressure on infrastructure\",\n        constraintCap: null,\n        gridGrowthRate: 0.07,\n        coolingGrowthRate: 0.04,\n        waterGrowthRate: 0.03,\n        landGrowthRate: 0.03\n    },\n    severe: {\n        name: \"Severe\",\n        description: \"Constrained + carbon tax + water scarcity crisis\",\n        constraintCap: null,\n        gridGrowthRate: 0.09,\n        coolingGrowthRate: 0.06,\n        waterGrowthRate: 0.05,\n        landGrowthRate: 0.04\n    }\n};\nfunction calculateGroundConstraint(year, scenarioKey, enabled) {\n    if (!enabled) return {\n        multiplier: 1.0,\n        breakdown: {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0\n        }\n    };\n    const scenario = GROUND_SCENARIOS[scenarioKey];\n    const yearsFromBase = Math.max(0, year - 2025);\n    const grid = Math.pow(1 + scenario.gridGrowthRate, yearsFromBase);\n    const cooling = Math.pow(1 + scenario.coolingGrowthRate, yearsFromBase);\n    const water = Math.pow(1 + scenario.waterGrowthRate, yearsFromBase);\n    const land = Math.pow(1 + scenario.landGrowthRate, yearsFromBase);\n    let multiplier = grid * cooling * water * land;\n    if (scenario.constraintCap !== null) {\n        multiplier = Math.min(multiplier, scenario.constraintCap);\n    }\n    return {\n        multiplier,\n        breakdown: {\n            grid,\n            cooling,\n            water,\n            land\n        }\n    };\n}\nfunction validateComputeEfficiency(gflopsPerWatt) {\n    let level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"system\";\n    const ranges = {\n        chip: {\n            min: 100,\n            max: 10000\n        },\n        system: {\n            min: 30,\n            max: 5000\n        },\n        datacenter: {\n            min: 10,\n            max: 1000\n        }\n    };\n    const range = ranges[level];\n    if (gflopsPerWatt < range.min || gflopsPerWatt > range.max) {\n        return {\n            valid: false,\n            warning: \"gflopsPerWatt=\".concat(gflopsPerWatt.toFixed(0), \" outside expected range for \").concat(level, \" level (\").concat(range.min, \"-\").concat(range.max, \")\")\n        };\n    }\n    return {\n        valid: true\n    };\n}\nconst SLA_TIERS = {\n    \"basic\": {\n        availabilityTarget: 0.99,\n        maxLatencyToGroundMs: 100,\n        minBandwidthGbps: 1,\n        maxRecoveryTimeMinutes: 60,\n        creditPerViolationPct: 10\n    },\n    \"standard\": {\n        availabilityTarget: 0.999,\n        maxLatencyToGroundMs: 50,\n        minBandwidthGbps: 10,\n        maxRecoveryTimeMinutes: 15,\n        creditPerViolationPct: 25\n    },\n    \"premium\": {\n        availabilityTarget: 0.9999,\n        maxLatencyToGroundMs: 20,\n        minBandwidthGbps: 100,\n        maxRecoveryTimeMinutes: 5,\n        creditPerViolationPct: 50\n    }\n};\nfunction applyStaticFreeze(params) {\n    if (!params.isStaticMode) return params;\n    return {\n        ...params,\n        launchCostKg: 1500,\n        specificPowerWKg: 36.5,\n        groundEffectiveGflopsPerW_2025: 30,\n        orbitEffectiveGflopsPerW_2025: 25,\n        groundConstraintsEnabled: true,\n        powerGridMultiplier: 1.0,\n        coolingMultiplier: 1.0,\n        waterScarcityEnabled: false,\n        landScarcityEnabled: false,\n        deployableArea2025M2: 75,\n        deployableArea2040M2: 75\n    };\n}\n// Cache for monotonicity check\nlet prevLaunchCostCache = new Map();\nfunction getLaunchCostPerKg(year, base2025) {\n    if (year <= 2025) {\n        prevLaunchCostCache.set(year, base2025);\n        return base2025;\n    }\n    const COMMERCIAL_MARKUP = 2.5;\n    const INSURANCE_PCT = 0.05;\n    const INTEGRATION_COST_PER_LAUNCH = 500000; // $500k per launch\n    const ASSUMED_PAYLOAD_KG = 100000; // 100t payload for integration cost amortization\n    // Internal SpaceX cost trajectory (marginal cost)\n    // Normalize base2025 to internal cost scale\n    const internalBase2025 = base2025 / (COMMERCIAL_MARKUP * (1 + INSURANCE_PCT)) - INTEGRATION_COST_PER_LAUNCH / ASSUMED_PAYLOAD_KG;\n    const normalizedBase = Math.max(internalBase2025, 600); // Ensure reasonable internal cost\n    const internalWaypoints = [\n        [\n            2025,\n            normalizedBase\n        ],\n        [\n            2026,\n            800\n        ],\n        [\n            2027,\n            400\n        ],\n        [\n            2028,\n            200\n        ],\n        [\n            2030,\n            75\n        ],\n        [\n            2035,\n            30\n        ],\n        [\n            2040,\n            20\n        ],\n        [\n            2045,\n            15\n        ],\n        [\n            2050,\n            10\n        ] // Internal cost floor\n    ];\n    // Find internal cost\n    let internalCostPerKg = normalizedBase;\n    for(let i = 0; i < internalWaypoints.length - 1; i++){\n        const [y1, c1] = internalWaypoints[i];\n        const [y2, c2] = internalWaypoints[i + 1];\n        if (year >= y1 && year <= y2) {\n            const t = (year - y1) / (y2 - y1);\n            internalCostPerKg = c1 * Math.pow(c2 / c1, t);\n            break;\n        }\n    }\n    if (year > internalWaypoints[internalWaypoints.length - 1][0]) {\n        internalCostPerKg = internalWaypoints[internalWaypoints.length - 1][1];\n    }\n    // Apply commercial markup\n    const withMarkup = internalCostPerKg * COMMERCIAL_MARKUP;\n    const withInsurance = withMarkup * (1 + INSURANCE_PCT);\n    const integrationPerKg = INTEGRATION_COST_PER_LAUNCH / ASSUMED_PAYLOAD_KG;\n    const commercialCostPerKg = withInsurance + integrationPerKg;\n    // Floor: commercial cost never below $30/kg (realistic minimum)\n    let result = Math.max(commercialCostPerKg, 30);\n    // Enforce monotonicity: never increase from previous year\n    const prevYear = year - 1;\n    const prevCost = prevLaunchCostCache.get(prevYear);\n    if (prevCost !== undefined && result > prevCost) {\n        result = prevCost; // Clamp to previous year's cost\n    }\n    prevLaunchCostCache.set(year, result);\n    return result;\n}\nfunction calculateTokenPricing(costPerPflopYear, modelConfig) {\n    const baseFLOPS = modelConfig.params * 2;\n    const precisionMultiplier = {\n        \"fp16\": 1.0,\n        \"fp8\": 0.5,\n        \"int8\": 0.5\n    }[modelConfig.precision];\n    const flopsPerToken = baseFLOPS * precisionMultiplier;\n    const secondsPerYear = 8760 * 3600;\n    const flopsPerPflopYear = 1e15 * secondsPerYear;\n    const tokensPerPflopYear = flopsPerPflopYear / flopsPerToken;\n    const costPerToken = costPerPflopYear / tokensPerPflopYear;\n    return {\n        modelParams: modelConfig.params,\n        precision: modelConfig.precision,\n        flopsPerToken,\n        tokensPerPflopYear,\n        costPerToken,\n        costPer1kTokens: costPerToken * 1000,\n        costPer1mTokens: costPerToken * 1e6\n    };\n}\nfunction calculateGpuHourPricing(costPerPflopYear, params, costBreakdown) {\n    const hoursPerYear = 8760;\n    const costPerGpuYear = costPerPflopYear * params.pflopsPerGpu;\n    const effectiveHours = hoursPerYear * params.utilizationTarget;\n    const basePerHour = costPerGpuYear / effectiveHours;\n    // DEFENSIVE CHECK: GPU-hour price should be in reasonable range ($0.01 to $100)\n    // If costPerPflopYear is insane (e.g., billions), this will catch it\n    if ( true && basePerHour > 1000) {\n        console.error(\"[GPU-HOUR PRICING] Year calculation: basePerHour=\".concat(basePerHour, \" > 1000. \") + \"costPerPflopYear=\".concat(costPerPflopYear, \", pflopsPerGpu=\").concat(params.pflopsPerGpu, \", \") + \"effectiveHours=\".concat(effectiveHours));\n        // Clamp to prevent chart explosion\n        const clampedCostPerPflopYear = Math.min(costPerPflopYear, 10000); // Cap at $10k/PFLOP-year\n        const clampedCostPerGpuYear = clampedCostPerPflopYear * params.pflopsPerGpu;\n        const clampedBasePerHour = clampedCostPerGpuYear / effectiveHours;\n        if (clampedBasePerHour > 100) {\n            throw new Error(\"[GPU-HOUR PRICING] Even after clamping, basePerHour=\".concat(clampedBasePerHour, \" > 100. \") + \"This indicates a unit error or calculation bug. Check costPerPflopYear input.\");\n        }\n    }\n    // Derive breakdown from cost components if provided\n    let powerPerHour = 0;\n    let coolingPerHour = 0;\n    let interconnectPerHour = 0;\n    let opsPerHour = 0;\n    let computePerHour = basePerHour;\n    if (costBreakdown) {\n        const totalBase = (costBreakdown.power || 0) + (costBreakdown.thermal || 0) + (costBreakdown.interconnect || 0) + (costBreakdown.ops || 0) + (costBreakdown.compute || 0);\n        if (totalBase > 0) {\n            // Scale breakdown components to GPU-hour\n            const scale = costPerGpuYear / (totalBase * params.pflopsPerGpu) / effectiveHours;\n            powerPerHour = (costBreakdown.power || 0) * params.pflopsPerGpu * scale;\n            coolingPerHour = (costBreakdown.thermal || 0) * params.pflopsPerGpu * scale;\n            interconnectPerHour = (costBreakdown.interconnect || 0) * params.pflopsPerGpu * scale;\n            opsPerHour = (costBreakdown.ops || 0) * params.pflopsPerGpu * scale;\n            computePerHour = (costBreakdown.compute || 0) * params.pflopsPerGpu * scale;\n        }\n    } else {\n        // Fallback: estimate ops as 5% of base\n        opsPerHour = basePerHour * 0.05;\n    }\n    const nines = -Math.log10(1 - params.sla.availabilityTarget);\n    const sparesRatio = 1 + 0.05 * nines;\n    const sparesPerHour = computePerHour * (sparesRatio - 1);\n    const violationProb = 1 - params.sla.availabilityTarget;\n    const expectedCreditPerHour = violationProb * params.sla.creditPerViolationPct / 100;\n    const slaRiskBuffer = basePerHour * expectedCreditPerHour * 2;\n    const totalCostPerHour = computePerHour + powerPerHour + coolingPerHour + interconnectPerHour + opsPerHour + sparesPerHour + slaRiskBuffer;\n    const margin = totalCostPerHour * params.operatorMarginPct;\n    let pricePerGpuHour = totalCostPerHour + margin;\n    // FINAL CLAMP: GPU-hour price must be in reasonable range ($0.01 to $100)\n    // This prevents chart explosion from unit errors or calculation bugs\n    const MAX_REASONABLE_GPU_HOUR_PRICE = 100;\n    const MIN_REASONABLE_GPU_HOUR_PRICE = 0.01;\n    if (pricePerGpuHour > MAX_REASONABLE_GPU_HOUR_PRICE) {\n        if (true) {\n            console.error(\"[GPU-HOUR PRICING] pricePerGpuHour=\".concat(pricePerGpuHour, \" > \").concat(MAX_REASONABLE_GPU_HOUR_PRICE, \". \") + \"Clamping to \".concat(MAX_REASONABLE_GPU_HOUR_PRICE, \". \") + \"costPerPflopYear=\".concat(costPerPflopYear, \", basePerHour=\").concat(basePerHour, \", totalCostPerHour=\").concat(totalCostPerHour));\n        }\n        pricePerGpuHour = MAX_REASONABLE_GPU_HOUR_PRICE;\n    }\n    if (pricePerGpuHour < MIN_REASONABLE_GPU_HOUR_PRICE && pricePerGpuHour > 0) {\n        pricePerGpuHour = MIN_REASONABLE_GPU_HOUR_PRICE;\n    }\n    return {\n        gpuType: \"H100-equivalent\",\n        location: params.location,\n        sla: params.sla,\n        pricePerGpuHour,\n        costBreakdown: {\n            hardwareAmortization: computePerHour,\n            power: powerPerHour,\n            cooling: coolingPerHour,\n            interconnect: interconnectPerHour,\n            operations: opsPerHour,\n            spares: sparesPerHour,\n            slaRiskBuffer,\n            margin\n        },\n        effectiveUtilization: params.utilizationTarget,\n        sparesRatio\n    };\n}\nconst MODEL_UNITS = {\n    pflopDefinition: \"fp16\",\n    sustainedVsPeak: \"sustained\",\n    gflopsPerWattLevel: \"system\",\n    includesNetworkingOverhead: false\n};\nfunction assertComputePowerConsistency(gflopsPerWatt, computePowerKw, effectivePflops) {\n    let units = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : MODEL_UNITS;\n    // 1 PFLOP = 1e6 GFLOPS\n    // Power (W) = GFLOPS / (GFLOPS/W) = (effectivePflops * 1e6) / gflopsPerWatt\n    // Power (kW) = Power (W) / 1000\n    // gflopsPerWatt is at system level (includes power conversion, cooling)\n    const expectedKw = effectivePflops * 1e6 / gflopsPerWatt / 1000;\n    const discrepancy = computePowerKw / expectedKw;\n    return {\n        valid: discrepancy > 0.5 && discrepancy < 2.0,\n        ratio: discrepancy,\n        expectedKw,\n        discrepancy\n    };\n}\nconst BASE_SITE_2025 = 1500; // Base site cost in 2025 ($/PFLOP-year)\nfunction calculateGroundTotal(year, params, energyCostBase, hardwareCostBase, isStaticMode, effectiveScenario) {\n    let latencyPenalty = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1.0, smrParams = arguments.length > 7 ? arguments[7] : void 0, firstCapYear = arguments.length > 8 ? arguments[8] : void 0, actualEnergyCostPerPflopYear = arguments.length > 9 ? arguments[9] : void 0, actualElectricityPricePerMwh = arguments.length > 10 ? arguments[10] : void 0;\n    const yearsFromBase = Math.max(0, year - 2025);\n    let siteCostBase = BASE_SITE_2025;\n    const enabled = params.groundConstraintsEnabled && !params.isStaticMode;\n    // SMR Toggle logic\n    const smrEnabled = (smrParams === null || smrParams === void 0 ? void 0 : smrParams.enabled) && year >= (smrParams.smrDeploymentStartYear || 2030);\n    let smrRampFactor = 0;\n    let constraintRelief = {\n        grid: 0,\n        cooling: 0,\n        water: 0,\n        land: 0\n    };\n    if (smrEnabled && smrParams) {\n        const yearsActive = year - smrParams.smrDeploymentStartYear;\n        smrRampFactor = Math.min(1, yearsActive / smrParams.smrRampUpYears);\n        // Apply constraint relief\n        constraintRelief = {\n            grid: smrParams.gridConstraintRelief * smrRampFactor,\n            cooling: smrParams.coolingConstraintRelief * smrRampFactor,\n            water: smrParams.waterConstraintRelief * smrRampFactor,\n            land: smrParams.landConstraintRelief * smrRampFactor\n        };\n        siteCostBase = BASE_SITE_2025 * (1 + (smrParams.smrCapexPremium - 1) * smrRampFactor);\n    }\n    // REFACTORED: Split energy (no multiplier) vs capacity/delivery premium (with multiplier)\n    // \n    // Energy cost: Raw electricity price * kWh (NO constraint multiplier)\n    // - Represents actual market electricity price\n    // - Grows with electricity price trajectory, not infrastructure scarcity\n    const energyCost = actualEnergyCostPerPflopYear !== null && actualEnergyCostPerPflopYear !== void 0 ? actualEnergyCostPerPflopYear : energyCostBase;\n    const effectiveElectricityPrice = actualElectricityPricePerMwh !== null && actualElectricityPricePerMwh !== void 0 ? actualElectricityPricePerMwh : 120;\n    if (!enabled) {\n        // No constraints: all costs at base, no premium\n        const total = (energyCost + siteCostBase + hardwareCostBase) * latencyPenalty;\n        return {\n            energyCost: energyCost * latencyPenalty,\n            siteCost: siteCostBase * latencyPenalty,\n            hardwareCost: hardwareCostBase * latencyPenalty,\n            capacityDeliveryPremium: 0,\n            timeToEnergizePenalty: 0,\n            totalCostPerPflopYear: total,\n            constraintMultiplier: 1.0,\n            breakdown: {\n                grid: 1.0,\n                cooling: 1.0,\n                water: 1.0,\n                land: 1.0,\n                energyMultiplier: 1.0,\n                siteMultiplier: 1.0,\n                capacityDeliveryMultiplier: 1.0\n            },\n            smrEnabled,\n            smrRampFactor,\n            effectiveElectricityCost: effectiveElectricityPrice,\n            constraintRelief\n        };\n    }\n    // CRITICAL FIX: Use queue-derived constraints, NOT time-based exponential\n    // This function is only used when NOT using buildout/queue models (legacy path)\n    // For consistency, use minimal constraints here (base costs only)\n    // Real constraint pricing should come from buildout/queue models\n    // GROUND COST ACCOUNTING: Explicit separation of components (ADDITIVE ONLY)\n    // \n    // 1. siteCapexAmortPerPflopYear: Pure amortized capex\n    //    - Buildings + power delivery inside site + cooling plant\n    //    - Base cost, NOT affected by constraint\n    const siteCapexAmortPerPflopYear = siteCostBase;\n    // 2. capacityDeliveryPremiumPerPflopYear: Scarcity price for firm MW at right place/time\n    //    - Set to zero in legacy path (constraints should come from buildout/queue models)\n    //    - This path is only for backward compatibility\n    const capacityDeliveryPremiumPerPflopYear = 0;\n    // 3. timeToEnergizePenaltyPerPflopYear: Financing cost of waiting (WACC + delay years)\n    //    - Set to zero in legacy path (delay penalties should come from buildout/queue models)\n    //    - This path is only for backward compatibility\n    const timeToEnergizePenaltyPerPflopYear = 0;\n    // CRITICAL: Remove double counting\n    // Do NOT include timeToEnergizePenalty in headline cost used for crossover\n    // (capacity gating in market share already accounts for backlog)\n    // Compute both base and effective costs:\n    const siteCostPerPflopYear_base = siteCapexAmortPerPflopYear + capacityDeliveryPremiumPerPflopYear;\n    const siteCostPerPflopYear_effective = siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + capacityDeliveryPremiumPerPflopYear;\n    // Validation: siteCost_effective must equal sum of components\n    const siteCostCheck = Math.abs(siteCostPerPflopYear_effective - (siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + capacityDeliveryPremiumPerPflopYear));\n    if (siteCostCheck > 0.01) {\n        throw new Error(\"Site cost accounting error: siteCost_effective=\".concat(siteCostPerPflopYear_effective, \" != sum(components)=\").concat(siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + capacityDeliveryPremiumPerPflopYear, \", diff=\").concat(siteCostCheck));\n    }\n    const hardware = hardwareCostBase;\n    // Headline cost for crossover: base only (excludes delay penalty, which is handled via capacity gating)\n    const total = (energyCost + siteCostPerPflopYear_base + hardware) * latencyPenalty;\n    // Effective/all-in cost: includes delay penalty (for reference/debug)\n    const totalEffective = (energyCost + siteCostPerPflopYear_effective + hardware) * latencyPenalty;\n    return {\n        energyCost: energyCost * latencyPenalty,\n        siteCost: siteCostPerPflopYear_base * latencyPenalty,\n        hardwareCost: hardware * latencyPenalty,\n        siteCapexAmortPerPflopYear: siteCapexAmortPerPflopYear * latencyPenalty,\n        capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear * latencyPenalty,\n        timeToEnergizePenalty: timeToEnergizePenaltyPerPflopYear * latencyPenalty,\n        totalCostPerPflopYear: total,\n        totalCostPerPflopYearEffective: totalEffective,\n        constraintMultiplier: 1.0,\n        breakdown: {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        },\n        constraints: {\n            method: \"adders\",\n            capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear * latencyPenalty,\n            delayPenalty: timeToEnergizePenaltyPerPflopYear * latencyPenalty,\n            appliedMultipliers: {\n                constraintMultiplierUsed: false,\n                energyMultiplierUsed: false,\n                siteMultiplierUsed: false\n            },\n            debug: {\n                doubleCountCheck: {\n                    mode: \"adders\",\n                    multiplierApplied: false,\n                    addersApplied: capacityDeliveryPremiumPerPflopYear > 0 || timeToEnergizePenaltyPerPflopYear > 0,\n                    invariantOk: true,\n                    notes: \"calculateGroundTotal uses adders only (capacityDeliveryPremium + timeToEnergizePenalty)\"\n                }\n            }\n        },\n        smrEnabled,\n        smrRampFactor,\n        effectiveElectricityCost: effectiveElectricityPrice,\n        constraintRelief\n    };\n}\nfunction computePhysicsCost(rawParams) {\n    let firstCapYear = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n    var _hybridResult_regulatory, _groundResult_constraints, _groundResult_constraints1, _params_edgeInference, _hybridResult_specificPowerMultipliers, _hybridResult_computePayload, _hybridResult_specificPowerMultipliers1, _groundResult_buildoutDebug, _groundResult_supplyMetrics, _groundResult_supplyMetrics1, _groundResult_supplyMetrics2, _groundResult_buildoutDebug1, _groundResult_supplyMetrics3, _groundResult_buildoutDebug2, _groundResult_buildoutDebug3;\n    const params = applyStaticFreeze(rawParams);\n    const { year, isStaticMode, launchCostKg: baseLaunchCost, specificPowerWKg: trajSpecificPower, groundEffectiveGflopsPerW_2025: rawGroundEffectiveGflopsPerW_2025, orbitEffectiveGflopsPerW_2025: rawOrbitEffectiveGflopsPerW_2025, pueGround, pueOrbital, capacityFactorGround, targetGW, satellitePowerKW, groundConstraintsEnabled, powerGridMultiplier, coolingMultiplier, waterScarcityEnabled, landScarcityEnabled, spaceTrafficEnabled, orbitalAltitude, useRadHardChips, sunFraction, groundScenario, smrMitigationEnabled, workloadType, elonScenarioEnabled, globalLatencyRequirementEnabled, spaceManufacturingEnabled, aiWinterEnabled } = params;\n    var _ref;\n    // CRITICAL FIX: Handle parameter name migration\n    // Old names: flopsPerWattGround, flopsPerWattOrbital (DEPRECATED - delete conversion logic)\n    // New names: groundEffectiveGflopsPerW_2025, orbitEffectiveGflopsPerW_2025\n    // Parameters are ALREADY in GFLOPS/W (not FLOPS/W) - no conversion needed\n    const actualGroundInput = (_ref = rawGroundEffectiveGflopsPerW_2025 !== null && rawGroundEffectiveGflopsPerW_2025 !== void 0 ? rawGroundEffectiveGflopsPerW_2025 : params.gflopsPerWattGround2025) !== null && _ref !== void 0 ? _ref : params.flopsPerWattGround;\n    var _ref1;\n    const actualOrbitInput = (_ref1 = rawOrbitEffectiveGflopsPerW_2025 !== null && rawOrbitEffectiveGflopsPerW_2025 !== void 0 ? rawOrbitEffectiveGflopsPerW_2025 : params.gflopsPerWattOrbital2025) !== null && _ref1 !== void 0 ? _ref1 : params.flopsPerWattOrbital;\n    // CANONICAL COMPUTE EFFICIENCY: Single source of truth for GFLOPS/W\n    // Parameter is interpreted as GFLOPS/W (not FLOPS/W) - no 1e9/1e12 conversions\n    let groundEfficiencyResult;\n    let orbitalEfficiencyResult;\n    // Ground: Use canonical ComputeEfficiency function\n    // CRITICAL FIX: Parameter is ALREADY in GFLOPS/W (not FLOPS/W)\n    // No unit conversion - treat input as effective GFLOPS/W directly\n    if (!actualGroundInput || !isFinite(actualGroundInput) || actualGroundInput <= 0) {\n        // Invalid input - use default\n        groundEfficiencyResult = (0,_compute_efficiency__WEBPACK_IMPORTED_MODULE_8__.getDefaultComputeEfficiency)(\"NVIDIA H100 SXM\", year, \"FP16\");\n    } else {\n        // Input is effective GFLOPS/W - derive chip peak assuming standard factors\n        // effective = chipPeak * utilization / systemOverhead\n        // So: chipPeak = effective * systemOverhead / utilization\n        const systemOverheadFactor = 1.18; // PUE 1.18 equivalent\n        const utilizationFactor = 0.70;\n        const chipPeakGflopsPerW = actualGroundInput * systemOverheadFactor / utilizationFactor;\n        // FAIL-FAST INVARIANT: Chip peak must be in realistic range [1, 20000] GFLOPS/W\n        if (chipPeakGflopsPerW < 1 || chipPeakGflopsPerW > 20000) {\n            throw new Error(\"GROUND COMPUTE EFFICIENCY UNIT MISMATCH: \" + \"chipPeakGflopsPerW=\".concat(chipPeakGflopsPerW.toFixed(2), \" is outside valid range [1, 20000] GFLOPS/W. \") + \"Input: actualGroundInput=\".concat(actualGroundInput, \", \") + \"This suggests a units error. Expected range: 30-5000 GFLOPS/W for system-level efficiency.\");\n        }\n        groundEfficiencyResult = (0,_compute_efficiency__WEBPACK_IMPORTED_MODULE_8__.ComputeEfficiency)({\n            chipPeakGflopsPerW,\n            utilizationFactor,\n            systemOverheadFactor\n        });\n        // FAIL-FAST INVARIANT: Effective GFLOPS/W must be in realistic range [1, 5000] GFLOPS/W\n        if (groundEfficiencyResult.effectiveGflopsPerW < 1 || groundEfficiencyResult.effectiveGflopsPerW > 5000) {\n            throw new Error(\"GROUND COMPUTE EFFICIENCY OUT OF RANGE: \" + \"effectiveGflopsPerW=\".concat(groundEfficiencyResult.effectiveGflopsPerW.toFixed(2), \" is outside valid range [1, 5000] GFLOPS/W. \") + \"Input: actualGroundInput=\".concat(actualGroundInput, \", \") + \"chipPeakGflopsPerW=\".concat(chipPeakGflopsPerW.toFixed(2), \". \") + \"This suggests a units error or invalid input.\");\n        }\n    }\n    // Orbital: Same logic - parameter is ALREADY in GFLOPS/W (not FLOPS/W)\n    // No unit conversion - treat input as effective GFLOPS/W directly\n    if (!actualOrbitInput || !isFinite(actualOrbitInput) || actualOrbitInput <= 0) {\n        // Invalid input - use default\n        orbitalEfficiencyResult = (0,_compute_efficiency__WEBPACK_IMPORTED_MODULE_8__.getDefaultComputeEfficiency)(\"H100-equivalent (rad-tolerant)\", year, \"FP16\");\n    } else {\n        // Input is effective GFLOPS/W - derive chip peak\n        const systemOverheadFactor = 1.18;\n        const utilizationFactor = 0.65;\n        const chipPeakGflopsPerW = actualOrbitInput * systemOverheadFactor / utilizationFactor;\n        // FAIL-FAST INVARIANT: Chip peak must be in realistic range [1, 20000] GFLOPS/W\n        if (chipPeakGflopsPerW < 1 || chipPeakGflopsPerW > 20000) {\n            throw new Error(\"ORBITAL COMPUTE EFFICIENCY UNIT MISMATCH: \" + \"chipPeakGflopsPerW=\".concat(chipPeakGflopsPerW.toFixed(2), \" is outside valid range [1, 20000] GFLOPS/W. \") + \"Input: actualOrbitInput=\".concat(actualOrbitInput, \", \") + \"This suggests a units error. Expected range: 25-4000 GFLOPS/W for system-level efficiency.\");\n        }\n        orbitalEfficiencyResult = (0,_compute_efficiency__WEBPACK_IMPORTED_MODULE_8__.ComputeEfficiency)({\n            chipPeakGflopsPerW,\n            utilizationFactor,\n            systemOverheadFactor\n        });\n        // FAIL-FAST INVARIANT: Effective GFLOPS/W must be in realistic range [1, 5000] GFLOPS/W\n        if (orbitalEfficiencyResult.effectiveGflopsPerW < 1 || orbitalEfficiencyResult.effectiveGflopsPerW > 5000) {\n            throw new Error(\"ORBITAL COMPUTE EFFICIENCY OUT OF RANGE: \" + \"effectiveGflopsPerW=\".concat(orbitalEfficiencyResult.effectiveGflopsPerW.toFixed(2), \" is outside valid range [1, 5000] GFLOPS/W. \") + \"Input: actualOrbitInput=\".concat(actualOrbitInput, \", \") + \"chipPeakGflopsPerW=\".concat(chipPeakGflopsPerW.toFixed(2), \". \") + \"This suggests a units error or invalid input.\");\n        }\n    }\n    // HARD ASSERT: Ground efficiency must always be populated and finite\n    if (!groundEfficiencyResult || !isFinite(groundEfficiencyResult.effectiveGflopsPerW) || groundEfficiencyResult.effectiveGflopsPerW <= 0) {\n        throw new Error(\"CRITICAL: Ground compute efficiency is invalid. \" + \"actualGroundInput=\".concat(actualGroundInput, \", \") + \"rawGroundEffectiveGflopsPerW_2025=\".concat(rawGroundEffectiveGflopsPerW_2025, \", \") + \"gflopsPerWattGround2025=\".concat(params.gflopsPerWattGround2025, \", \") + \"groundEfficiencyResult=\".concat(JSON.stringify(groundEfficiencyResult)));\n    }\n    // CRITICAL FIX: Standardize compute-efficiency level definitions\n    // Standard definitions:\n    // - peakGflopsPerWatt: chip peak (no utilization, no overhead, no derates)\n    // - systemEffectiveGflopsPerWatt: peak * utilization / systemOverheadFactor (SYSTEM-LEVEL EFFECTIVE)\n    // - deliveredGflopsPerWatt: systemEffective * thermalCapFactor * radiationDerate * availability\n    // Ground: systemEffective only (no delivery derates)\n    const groundEffectiveGflopsPerW = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(groundEfficiencyResult.effectiveGflopsPerW, \"ground efficiency calculation\");\n    // Orbital: Track all three levels\n    const orbitPeakGflopsPerWatt = orbitalEfficiencyResult.debug.chipPeakGflopsPerW;\n    const orbitSystemEffectiveGflopsPerWatt = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(orbitalEfficiencyResult.effectiveGflopsPerW, \"orbital systemEffective efficiency calculation\");\n    // NOTE: deliveredGflopsPerWatt will be calculated after thermal system is computed\n    // It will be: systemEffective * thermalCapFactor * radiationDerate * availability\n    // AI Winter: Constraints grow 50% slower\n    const effectiveGroundScenario = aiWinterEnabled && year >= 2028 ? {\n        ...GROUND_SCENARIOS[groundScenario],\n        gridGrowthRate: GROUND_SCENARIOS[groundScenario].gridGrowthRate * 0.5,\n        coolingGrowthRate: GROUND_SCENARIOS[groundScenario].coolingGrowthRate * 0.5,\n        waterGrowthRate: GROUND_SCENARIOS[groundScenario].waterGrowthRate * 0.5,\n        landGrowthRate: GROUND_SCENARIOS[groundScenario].landGrowthRate * 0.5\n    } : GROUND_SCENARIOS[groundScenario];\n    // Elon Scenario: Discounts\n    const launchDiscount = elonScenarioEnabled ? 0.50 : 1.0;\n    const powerDiscount = elonScenarioEnabled ? 0.70 : 1.0;\n    const networkingDiscount = elonScenarioEnabled ? 0.10 : 1.0;\n    const operatorMargin = elonScenarioEnabled ? 0.05 : 0.20;\n    // Global Latency: 3x ground overprovisioning penalty\n    const groundLatencyPenalty = globalLatencyRequirementEnabled && year >= 2028 ? 3.0 : 1.0;\n    // Space Manufacturing: Mass reduction\n    let massMultiplier = 1.0;\n    if (spaceManufacturingEnabled && year >= 2032) {\n        const yearsSinceStart = year - 2032;\n        const ramp = Math.min(1.0, yearsSinceStart / 5);\n        massMultiplier = 1.0 - 0.60 * ramp;\n    }\n    // EMERGENCY FIX: Use simple fixed 2025 base values\n    // These are the known-correct values from the emergency fix\n    // Don't try to calculate from flopsPerWatt - just use these constants\n    const BASE_ENERGY_2025 = 581; // $/PFLOP-year (fixed 2025 base)\n    const BASE_SITE_2025 = 1500; // $/PFLOP-year (fixed 2025 base)\n    const ENERGY_COST_BASE_2025 = BASE_ENERGY_2025; // Use fixed base, not calculated\n    // For reference/display (not used in constraint calculation)\n    const BASE_ELECTRICITY_PRICE_2025 = 120; // $/MWh (2025 baseline)\n    let groundElectricityPricePerMwh = BASE_ELECTRICITY_PRICE_2025;\n    if (!params.isStaticMode) {\n        groundElectricityPricePerMwh *= Math.pow(1.02, year - 2025);\n    }\n    const effectivePueGround = pueGround + (year - 2025) * 0.01;\n    // Convert GFLOPS/W to power: 1 PFLOP = 1e6 GFLOPS, so power (W) = (1e6 GFLOPS) / (GFLOPS/W)\n    const groundEnergyMWhPerPflopYear = 8760 * 1e6 / groundEffectiveGflopsPerW * effectivePueGround / 1e6;\n    const groundEnergyCostPerPflopYear = groundEnergyMWhPerPflopYear * groundElectricityPricePerMwh * capacityFactorGround;\n    const computeGroundHardwareCost = (y, baseCost)=>{\n        const yearIndex = y - 2025;\n        let cost = baseCost;\n        for(let i = 0; i < yearIndex; i++){\n            let annualDecline;\n            if (i < 3) annualDecline = 0.10;\n            else if (i < 6) annualDecline = 0.05;\n            else if (i < 10) annualDecline = 0.02;\n            else annualDecline = 0.005;\n            cost *= 1 - annualDecline;\n        }\n        return cost;\n    };\n    var _params_groundHardwareLifetimeYears;\n    const groundLifetime = (_params_groundHardwareLifetimeYears = params.groundHardwareLifetimeYears) !== null && _params_groundHardwareLifetimeYears !== void 0 ? _params_groundHardwareLifetimeYears : CONSTANTS.GROUND_HARDWARE_LIFETIME;\n    const groundHardwareCapexPerPflopYear = computeGroundHardwareCost(year, CONSTANTS.GROUND_HARDWARE_COST_PFLOP_2025) / groundLifetime;\n    const smrParams = params.smrToggleEnabled ? params.smrToggleParams || DEFAULT_SMR_PARAMS : undefined;\n    let groundResult;\n    let groundTotalCost;\n    let groundComparatorCostPerPflopYear; // Comparator cost for crossover (uses effective when queue exists)\n    let groundHasQueue = false; // Track if ground has queue/backlog (for debug and comparator cost)\n    let energyConstraintMultiplier;\n    let constraintBreakdown;\n    const useRegionalModel = params.useRegionalGroundModel === true && params.groundConstraintsEnabled && !params.isStaticMode;\n    // FIX: Make buildout model the default (it correctly uses responsive demand)\n    // Queue model requires full demand trajectory to work correctly, so it's opt-in only\n    // Only use queue model if explicitly enabled (useQueueBasedConstraint === true)\n    const useQueueModel = params.useQueueBasedConstraint === true && params.groundConstraintsEnabled && !params.isStaticMode && !useRegionalModel;\n    // Buildout model is the default (defaults to true unless explicitly disabled)\n    const useBuildoutModel = params.useBuildoutModel !== false && params.groundConstraintsEnabled && !params.isStaticMode && !useRegionalModel && !useQueueModel;\n    if (useQueueModel) {\n        // WARNING: Queue model requires full demand trajectory to work correctly\n        // Currently only receives current year's responsive demand, so previous years use hardcoded demand\n        // RECOMMENDED: Use buildout model instead (default) which correctly handles responsive demand\n        if (true) {\n            console.warn(\"[QUEUE MODEL] Year \".concat(year, \": Queue model is enabled but only receives current year's responsive demand. \") + \"Previous years (2025-\".concat(year - 1, \") will use hardcoded exponential demand. \") + \"For accurate S-curve behavior, use buildout model (default) instead.\");\n        }\n        // Pass responsive demand and orbital substitution to queue model (if available from trajectory.ts)\n        const responsiveDemandGW = params.responsiveDemandGW;\n        const orbitalSubstitutionGW = params.orbitalSubstitutionGW;\n        // Build demand map if responsive demand is provided\n        // NOTE: Only current year is passed - previous years will use hardcoded demand\n        const demandByYear = responsiveDemandGW !== undefined ? new Map([\n            [\n                year,\n                responsiveDemandGW\n            ]\n        ]) : undefined;\n        const orbitalSubstitutionByYear = orbitalSubstitutionGW !== undefined ? new Map([\n            [\n                year,\n                orbitalSubstitutionGW\n            ]\n        ]) : undefined;\n        const supplyTrajectory = (0,_ground_queue_model__WEBPACK_IMPORTED_MODULE_4__.generateGroundSupplyTrajectory)(2025, year, demandByYear, orbitalSubstitutionByYear);\n        const currentSupplyState = supplyTrajectory[supplyTrajectory.length - 1];\n        // Debug: Log if responsive demand is being used\n        if ( true && responsiveDemandGW !== undefined) {\n            const hardcodedDemand = (0,_ground_queue_model__WEBPACK_IMPORTED_MODULE_4__.getGlobalDemandGw)(year);\n            if (Math.abs(currentSupplyState.demandGw - hardcodedDemand) < 1e-6) {\n                console.warn(\"[QUEUE MODEL DEBUG] Year \".concat(year, \": Responsive demand (\").concat(responsiveDemandGW.toFixed(2), \" GW) was ignored. \") + \"Queue model using hardcoded: \".concat(currentSupplyState.demandGw.toFixed(2), \" GW\"));\n            } else {\n                console.log(\"[QUEUE MODEL DEBUG] Year \".concat(year, \": Using responsive demand \").concat(responsiveDemandGW.toFixed(2), \" GW \") + \"(queue model: \".concat(currentSupplyState.demandGw.toFixed(2), \" GW)\"));\n            }\n        }\n        var _params_wacc, _params_waccBacklogK, _params_waccBacklogExponent, _params_criticalBacklogGW;\n        // Calculate WACC-based penalties and multipliers\n        // Pass WACC parameters for capital rationing (WACC rises with backlog)\n        const waccParams = {\n            baseWacc: (_params_wacc = params.wacc) !== null && _params_wacc !== void 0 ? _params_wacc : 0.10,\n            waccBacklogK: (_params_waccBacklogK = params.waccBacklogK) !== null && _params_waccBacklogK !== void 0 ? _params_waccBacklogK : 0.5,\n            waccBacklogExponent: (_params_waccBacklogExponent = params.waccBacklogExponent) !== null && _params_waccBacklogExponent !== void 0 ? _params_waccBacklogExponent : 1.2,\n            criticalBacklogGW: (_params_criticalBacklogGW = params.criticalBacklogGW) !== null && _params_criticalBacklogGW !== void 0 ? _params_criticalBacklogGW : 50\n        };\n        const penalties = (0,_ground_constraint_penalties__WEBPACK_IMPORTED_MODULE_5__.calculateGroundConstraintPenalties)(currentSupplyState, groundEffectiveGflopsPerW, effectivePueGround, capacityFactorGround, waccParams);\n        const BASE_SITE_2025 = 1500;\n        // Energy cost: Use actual calculated value (NOT multiplied by constraint)\n        // CRITICAL FIX: Do NOT apply PUE multiplier - energy cost is base only\n        // PUE stress should be reflected in capacityDeliveryPremium, not energy multiplier\n        const energyCostBase = groundEnergyCostPerPflopYear;\n        const energyCost = energyCostBase; // Base energy cost only - no multiplier\n        // GROUND COST ACCOUNTING: Explicit separation of components (queue model)\n        const siteCostBase = BASE_SITE_2025;\n        // 1. siteCapexAmortPerPflopYear: Pure amortized capex (NOT affected by constraint)\n        const siteCapexAmortPerPflopYear = siteCostBase;\n        // CHOICE: Use delayPenalty + scarcityRent (Hill-based), NOT capacityDeliveryPremium\n        // Set capacityDeliveryPremium to 0 to avoid triple-charging\n        const capacityDeliveryPremiumPerPflopYear = 0; // NOT USED - using delayPenalty + scarcityRent instead\n        // 1. timeToEnergizePenaltyPerPflopYear: Bounded linear WACC carry (NOT exponential)\n        const timeToEnergizePenaltyPerPflopYear = penalties.timeToEnergizePenaltyPerPflopYear;\n        // 2. scarcityRentPerPflopYear: Hill function of avgWaitYears (w50=2.0, n=2.0, rentMax=0.65)\n        // Base cost for scarcity rent = hardware + site (no capacityDeliveryPremium)\n        const capexAnnualBasePerPflopYear = groundHardwareCapexPerPflopYear + siteCapexAmortPerPflopYear;\n        // Calculate scarcity multiplier using LOG-BASED function (never fully saturates)\n        // Returns multiplier (1.0 = no scarcity, 2.0 = 2x price) - MULTIPLICATIVE, not additive\n        const scarcityRentResult = (0,_ground_constraint_penalties__WEBPACK_IMPORTED_MODULE_5__.calculateScarcityRent)(currentSupplyState.avgWaitYears, currentSupplyState.utilizationPct, {\n            waitThresholdYears: 1.0,\n            rentMaxMultiplier: 2.0,\n            utilizationThreshold: 0.85\n        });\n        const scarcityMultiplier = scarcityRentResult.scarcityMultiplier;\n        // For backward compatibility: scarcityRentPerPflopYear = 0 (scarcity is now multiplicative)\n        const scarcityRentPerPflopYear = 0;\n        // Debug: verify queue model consistency\n        if (true) {\n            var _currentSupplyState_unservedGw;\n            const unservedGw = (_currentSupplyState_unservedGw = currentSupplyState.unservedGw) !== null && _currentSupplyState_unservedGw !== void 0 ? _currentSupplyState_unservedGw : currentSupplyState.demandGw - currentSupplyState.capacityGw;\n            if (currentSupplyState.demandGw < currentSupplyState.capacityGw && currentSupplyState.backlogGw > 50) {\n                console.warn(\"[QUEUE MODEL] Year \".concat(year, \": demandGw=\").concat(currentSupplyState.demandGw.toFixed(1), \" < capacityGw=\").concat(currentSupplyState.capacityGw.toFixed(1), \" \") + \"but backlogGw=\".concat(currentSupplyState.backlogGw.toFixed(1), \" > 50. This may indicate queue model issue.\"));\n            }\n        }\n        // CRITICAL: Remove double counting\n        // Do NOT include timeToEnergizePenalty + scarcityRent in headline cost used for crossover\n        // (capacity gating in market share already accounts for backlog)\n        // Compute both base and effective costs:\n        const siteCostPerPflopYear_base = siteCapexAmortPerPflopYear; // No capacityDeliveryPremium\n        const siteCostPerPflopYear_effective = siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + scarcityRentPerPflopYear;\n        // Validation\n        const expectedEffective = siteCapexAmortPerPflopYear + capacityDeliveryPremiumPerPflopYear + timeToEnergizePenaltyPerPflopYear + scarcityRentPerPflopYear;\n        const siteCostCheck = Math.abs(siteCostPerPflopYear_effective - expectedEffective);\n        if (siteCostCheck > 0.01) {\n            throw new Error(\"Site cost accounting error (queue model): siteCost_effective=\".concat(siteCostPerPflopYear_effective, \" != sum(components)=\").concat(expectedEffective, \" (siteCapex=\").concat(siteCapexAmortPerPflopYear, \", premium=\").concat(capacityDeliveryPremiumPerPflopYear, \", delay=\").concat(timeToEnergizePenaltyPerPflopYear, \", scarcity=\").concat(scarcityRentPerPflopYear, \"), diff=\").concat(siteCostCheck));\n        }\n        const hardwareCost = groundHardwareCapexPerPflopYear;\n        // UNIFIED SCARCITY ACCOUNTING: Keep totalCostPerPflopYear physical-only\n        // Scarcity (delayPenalty + scarcityRent) is treated purely in GPU-hour pricing, not in PFLOP-year cost\n        groundTotalCost = (energyCost + siteCostPerPflopYear_base + hardwareCost) * groundLatencyPenalty;\n        // For crossover: use base cost (scarcity is already reflected in GPU-hour pricing)\n        // This ensures we don't double-count scarcity\n        groundHasQueue = timeToEnergizePenaltyPerPflopYear > 0.01;\n        groundComparatorCostPerPflopYear = groundTotalCost; // Base cost only (scarcity in GPU-hour)\n        // CRITICAL FIX: Remove all multipliers - use additive terms only\n        // Multipliers are NOT applied to any dollar amounts\n        // All constraint effects are captured in capacityDeliveryPremium and timeToEnergizePenalty\n        energyConstraintMultiplier = 1.0; // Never applied - for backward compat only\n        // Constraint breakdown: all multipliers set to 1.0 (not applied)\n        // These are kept for debug/decomposition but never multiplied into costs\n        constraintBreakdown = {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        };\n        var _currentSupplyState_avgWaitYearsRaw, _currentSupplyState_unservedGw1, _currentSupplyState_deliveredFromBacklogGw, _currentSupplyState_unservedGw2, _currentSupplyState_deliveredFromBacklogGw1, _currentSupplyState_avgWaitYearsRaw1;\n        groundResult = {\n            energyCost: energyCost * groundLatencyPenalty,\n            siteCost: siteCostPerPflopYear_base * groundLatencyPenalty,\n            hardwareCost: hardwareCost * groundLatencyPenalty,\n            siteCapexAmortPerPflopYear: siteCapexAmortPerPflopYear * groundLatencyPenalty,\n            capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear * groundLatencyPenalty,\n            timeToEnergizePenalty: timeToEnergizePenaltyPerPflopYear * groundLatencyPenalty,\n            totalCostPerPflopYear: groundTotalCost,\n            totalCostPerPflopYearEffective: groundTotalCost,\n            totalCostPerPflopYearAllIn: groundTotalCost,\n            constraintMultiplier: 1.0,\n            breakdown: constraintBreakdown,\n            constraints: {\n                method: \"adders\",\n                capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear * groundLatencyPenalty,\n                delayPenalty: timeToEnergizePenaltyPerPflopYear * groundLatencyPenalty,\n                scarcityRentPerPflopYear: scarcityRentPerPflopYear * groundLatencyPenalty,\n                scarcityMultiplier: scarcityMultiplier,\n                appliedMultipliers: {\n                    constraintMultiplierUsed: false,\n                    energyMultiplierUsed: false,\n                    siteMultiplierUsed: false\n                },\n                // Debug fields for Hill-based scarcity rent (wait-time based)\n                scarcityHill: scarcityRentResult.scarcityHill,\n                avgWaitYearsRaw: (_currentSupplyState_avgWaitYearsRaw = currentSupplyState.avgWaitYearsRaw) !== null && _currentSupplyState_avgWaitYearsRaw !== void 0 ? _currentSupplyState_avgWaitYearsRaw : currentSupplyState.avgWaitYears,\n                avgWaitYearsClamped: scarcityRentResult.avgWaitYearsClamped,\n                rentFrac: scarcityRentResult.rentFrac,\n                // Additional debug fields for verification\n                backlogGw: currentSupplyState.backlogGw,\n                unservedGw: (_currentSupplyState_unservedGw1 = currentSupplyState.unservedGw) !== null && _currentSupplyState_unservedGw1 !== void 0 ? _currentSupplyState_unservedGw1 : 0,\n                deliveredFromBacklogGw: (_currentSupplyState_deliveredFromBacklogGw = currentSupplyState.deliveredFromBacklogGw) !== null && _currentSupplyState_deliveredFromBacklogGw !== void 0 ? _currentSupplyState_deliveredFromBacklogGw : 0,\n                baseCostPerPflopYear: capexAnnualBasePerPflopYear * groundLatencyPenalty,\n                totalCostPerPflopYear: groundTotalCost\n            },\n            supplyMetrics: {\n                demandGw: currentSupplyState.demandGw,\n                capacityGw: currentSupplyState.capacityGw,\n                pipelineGw: currentSupplyState.pipelineGw,\n                maxBuildRateGwYear: currentSupplyState.maxBuildRateGwYear,\n                avgWaitYears: currentSupplyState.avgWaitYears,\n                utilizationPct: currentSupplyState.utilizationPct,\n                // Debug fields for queue model verification\n                backlogGw: currentSupplyState.backlogGw,\n                unservedGw: (_currentSupplyState_unservedGw2 = currentSupplyState.unservedGw) !== null && _currentSupplyState_unservedGw2 !== void 0 ? _currentSupplyState_unservedGw2 : 0,\n                deliveredFromBacklogGw: (_currentSupplyState_deliveredFromBacklogGw1 = currentSupplyState.deliveredFromBacklogGw) !== null && _currentSupplyState_deliveredFromBacklogGw1 !== void 0 ? _currentSupplyState_deliveredFromBacklogGw1 : 0,\n                avgWaitYearsRaw: (_currentSupplyState_avgWaitYearsRaw1 = currentSupplyState.avgWaitYearsRaw) !== null && _currentSupplyState_avgWaitYearsRaw1 !== void 0 ? _currentSupplyState_avgWaitYearsRaw1 : currentSupplyState.avgWaitYears\n            },\n            constraintComponents: {\n                queuePressure: currentSupplyState.avgWaitYears > 0 ? 1 + currentSupplyState.avgWaitYears / 2 : 1,\n                utilizationPressure: currentSupplyState.utilizationPct > 0.85 ? 1 + (currentSupplyState.utilizationPct - 0.85) * 5 : 1,\n                scarcityPremium: penalties.siteMultiplier\n            },\n            // Debug fields for WACC penalties\n            backlogGw: penalties.backlogGw,\n            avgWaitYears: penalties.avgWaitYears,\n            capexAtRiskPerMW: penalties.capexAtRiskPerMW,\n            carryCostPerMW: penalties.carryCostPerMW,\n            lostMarginPerMW: penalties.lostMarginPerMW,\n            timeToEnergizePenaltyPerPflopYear: penalties.timeToEnergizePenaltyPerPflopYear,\n            pueMultiplier: penalties.pueMultiplier,\n            smrEnabled: false,\n            smrRampFactor: 0,\n            effectiveElectricityCost: groundElectricityPricePerMwh,\n            constraintRelief: {\n                grid: 0,\n                cooling: 0,\n                water: 0,\n                land: 0\n            }\n        };\n    } else if (useBuildoutModel) {\n        var _groundResult_buildoutDebug4;\n        // NEW: Ramping Mobilization Model\n        // Replaces constraint multiplier with explicit buildout capex premium and delay penalties\n        // Uses ramping buildout capacity with smooth interpolation\n        // Get mobilization parameters (use defaults if not provided)\n        const mobilizationParams = params.mobilizationParams ? {\n            ..._ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_MOBILIZATION_PARAMS,\n            ...params.mobilizationParams,\n            demandCurve: params.mobilizationParams.demandCurve || _ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_MOBILIZATION_PARAMS.demandCurve\n        } : _ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_MOBILIZATION_PARAMS;\n        var _params_prevMobilizationState;\n        // Get previous mobilization state from params (passed from trajectory)\n        // If not provided, calculate from previous year's demand\n        const prevMobilizationState = (_params_prevMobilizationState = params.prevMobilizationState) !== null && _params_prevMobilizationState !== void 0 ? _params_prevMobilizationState : null;\n        // Step mobilization state forward\n        // Pass responsive demand and orbital substitution if available (from trajectory.ts)\n        const responsiveDemandGW = params.responsiveDemandGW;\n        const orbitalSubstitutionGW = params.orbitalSubstitutionGW;\n        const mobilizationResult = (0,_ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__.stepMobilizationState)(prevMobilizationState, mobilizationParams, year, effectivePueGround, 0, orbitalSubstitutionGW, responsiveDemandGW // Pass responsive demand (overrides hardcoded)\n        );\n        // Extract values from mobilization model\n        const demandNewGW = mobilizationResult.demandNewGW;\n        const buildRateGWyr = mobilizationResult.buildRateGWyr;\n        const buildableGW = buildRateGWyr; // buildable = build rate\n        const capacityGW = mobilizationResult.capacityGW;\n        const pipelineGW = mobilizationResult.pipelineGW;\n        const backlogGW = mobilizationResult.backlogGW;\n        const avgWaitYears = mobilizationResult.avgWaitYears;\n        var _params_wacc1;\n        // Default buildout parameters\n        const baseWacc = (_params_wacc1 = params.wacc) !== null && _params_wacc1 !== void 0 ? _params_wacc1 : 0.10; // 10% base WACC\n        const PROJECT_LIFETIME = 20; // 20 years\n        const BUILDOUT_CAPEX_BASE = 2000; // $2k/kW base buildout capex (reduced from 3k)\n        const DEFAULT_SCARCITY_CURVE = {\n            k: 2.0,\n            exponent: 1.7,\n            thresholdUtil: 0.0\n        };\n        const PANIC_EXPONENT = 1.3; // Exponent for delay penalty panic regime\n        var _params_waccBacklogK1;\n        // Compute effective WACC (rises with backlog - capital rationing)\n        const waccBacklogK = (_params_waccBacklogK1 = params.waccBacklogK) !== null && _params_waccBacklogK1 !== void 0 ? _params_waccBacklogK1 : 0.5;\n        var _params_waccBacklogExponent1;\n        const waccBacklogExponent = (_params_waccBacklogExponent1 = params.waccBacklogExponent) !== null && _params_waccBacklogExponent1 !== void 0 ? _params_waccBacklogExponent1 : 1.2;\n        var _params_criticalBacklogGW1;\n        const criticalBacklogGW = (_params_criticalBacklogGW1 = params.criticalBacklogGW) !== null && _params_criticalBacklogGW1 !== void 0 ? _params_criticalBacklogGW1 : 50;\n        const backlogRatio = Math.max(0, backlogGW / criticalBacklogGW);\n        const waccMultiplier = 1 + waccBacklogK * Math.pow(backlogRatio, waccBacklogExponent);\n        const waccEffective = baseWacc * waccMultiplier;\n        var _params_buildoutProjectLifetimeYears, _params_valueOfTimeMode, _params_buildoutCapexBase_$PerkW, _params_buildoutCapexScarcityCurve, _params_buildoutPanicExponent, _params_buildoutHybridWeights;\n        // Calculate buildout constraints\n        const buildoutParams = {\n            demandNewGWByYear: demandNewGW,\n            buildableGWByYear: buildableGW,\n            backlogGW: backlogGW,\n            avgWaitYears: avgWaitYears,\n            baseEnergyPricePerMwhByYear: groundElectricityPricePerMwh,\n            pueGroundByYear: effectivePueGround,\n            wacc: waccEffective,\n            projectLifetimeYears: (_params_buildoutProjectLifetimeYears = params.buildoutProjectLifetimeYears) !== null && _params_buildoutProjectLifetimeYears !== void 0 ? _params_buildoutProjectLifetimeYears : PROJECT_LIFETIME,\n            valueOfTimeMode: (_params_valueOfTimeMode = params.valueOfTimeMode) !== null && _params_valueOfTimeMode !== void 0 ? _params_valueOfTimeMode : \"wacc_on_capex\",\n            buildoutCapexBase_$PerkW: (_params_buildoutCapexBase_$PerkW = params.buildoutCapexBase_$PerkW) !== null && _params_buildoutCapexBase_$PerkW !== void 0 ? _params_buildoutCapexBase_$PerkW : BUILDOUT_CAPEX_BASE,\n            buildoutCapexScarcityCurve: (_params_buildoutCapexScarcityCurve = params.buildoutCapexScarcityCurve) !== null && _params_buildoutCapexScarcityCurve !== void 0 ? _params_buildoutCapexScarcityCurve : DEFAULT_SCARCITY_CURVE,\n            panicExponent: (_params_buildoutPanicExponent = params.buildoutPanicExponent) !== null && _params_buildoutPanicExponent !== void 0 ? _params_buildoutPanicExponent : PANIC_EXPONENT,\n            hardwareCapexPerPflopYear: groundHardwareCapexPerPflopYear,\n            siteCapexAmortPerPflopYear: BASE_SITE_2025,\n            // Legacy fields (kept for backward compat, but not used in new calculation)\n            computeHardwareCapex: groundHardwareCapexPerPflopYear * (groundEffectiveGflopsPerW * capacityFactorGround / effectivePueGround / 1e6),\n            siteCapex: BASE_SITE_2025 * (groundEffectiveGflopsPerW * capacityFactorGround / effectivePueGround / 1e6),\n            marginPerGpuHour: 0.5,\n            annualGpuHoursDelivered: 8760 * capacityFactorGround,\n            hybridWeights: (_params_buildoutHybridWeights = params.buildoutHybridWeights) !== null && _params_buildoutHybridWeights !== void 0 ? _params_buildoutHybridWeights : {\n                waccWeight: 0.5,\n                marginWeight: 0.5\n            }\n        };\n        const buildoutResult = (0,_ground_buildout__WEBPACK_IMPORTED_MODULE_6__.calculateBuildoutConstraints)(null, buildoutParams, year, groundEffectiveGflopsPerW, effectivePueGround, capacityFactorGround);\n        // Energy cost: base energy only (NOT affected by buildout constraints)\n        const energyCost = groundEnergyCostPerPflopYear;\n        // Site cost: base capex + buildout premium (engineering cost only, not scarcity pricing)\n        const siteCapexAmortPerPflopYear = BASE_SITE_2025;\n        const buildoutPremiumPerPflopYear = buildoutResult.buildoutPremiumPerPflopYear; // Base engineering cost only\n        const delayPenaltyPerPflopYear = buildoutResult.delayPenaltyPerPflopYear; // Linear: WACC * capex * waitYears\n        // CRITICAL: Wait-time-based scarcity rent (EARLY, SATURATING)\n        // Define annualized capex base for scarcity rent calculation\n        const capexAnnualBasePerPflopYear = groundHardwareCapexPerPflopYear + siteCapexAmortPerPflopYear + buildoutPremiumPerPflopYear; // Include buildout premium as true engineering capex\n        // Calculate scarcity multiplier using LOG-BASED function (never fully saturates)\n        // Returns multiplier (1.0 = no scarcity, 2.0 = 2x price) - MULTIPLICATIVE, not additive\n        const utilizationPct = capacityGW > 0 ? Math.min(1.0, demandNewGW / capacityGW) : 1.0;\n        var _params_scarcityRentWaitThresholdYears, _params_scarcityRentMaxMultiplier;\n        const scarcityRentResult = (0,_ground_constraint_penalties__WEBPACK_IMPORTED_MODULE_5__.calculateScarcityRent)(avgWaitYears, utilizationPct, {\n            waitThresholdYears: (_params_scarcityRentWaitThresholdYears = params.scarcityRentWaitThresholdYears) !== null && _params_scarcityRentWaitThresholdYears !== void 0 ? _params_scarcityRentWaitThresholdYears : 1.0,\n            rentMaxMultiplier: (_params_scarcityRentMaxMultiplier = params.scarcityRentMaxMultiplier) !== null && _params_scarcityRentMaxMultiplier !== void 0 ? _params_scarcityRentMaxMultiplier : 2.0,\n            utilizationThreshold: 0.85\n        });\n        const scarcityMultiplier = scarcityRentResult.scarcityMultiplier;\n        // For backward compatibility: scarcityRentPerPflopYear = 0 (scarcity is now multiplicative)\n        const scarcityRentPerPflopYear = 0;\n        // Define three totals:\n        // 1. base: energy + siteCapexAmort + buildoutPremium + hardware (no scarcity pricing)\n        // 2. effective: includes delayPenalty + scarcityRent (used for crossover)\n        // 3. headline: same as base (for backward compatibility)\n        const siteCostPerPflopYear_base = siteCapexAmortPerPflopYear + buildoutPremiumPerPflopYear;\n        const siteCostPerPflopYear_effective = siteCapexAmortPerPflopYear + buildoutPremiumPerPflopYear + delayPenaltyPerPflopYear + scarcityRentPerPflopYear;\n        // Validation: ensure no double counting\n        if (params.useQueueBasedConstraint !== false) {\n            console.warn(\"[BUILDOUT] useQueueBasedConstraint should be false when useBuildoutModel is true to avoid double counting\");\n        }\n        // Double counting guardrails: ensure constraintMultiplier is 1.0 when useBuildoutModel is true\n        if (true) {\n            if ((groundResult === null || groundResult === void 0 ? void 0 : groundResult.constraintMultiplier) !== undefined && groundResult.constraintMultiplier !== 1.0) {\n                throw new Error(\"[DOUBLE COUNTING] useBuildoutModel=true but constraintMultiplier=\".concat(groundResult.constraintMultiplier, \" != 1.0 (year=\").concat(year, \")\"));\n            }\n        }\n        const hardwareCost = groundHardwareCapexPerPflopYear;\n        // Add replacement/ops costs to hardware cost\n        const hardwareCostWithReplacement = hardwareCost + replacementCostPerPflopYear + sparesCarryCostPerPflopYear + groundOpsCostPerPflopYear;\n        // Compute totals (include replacement/ops in all)\n        const groundTotalCost_base = (energyCost + siteCostPerPflopYear_base + hardwareCostWithReplacement) * groundLatencyPenalty;\n        const groundTotalCost_effective = (energyCost + siteCostPerPflopYear_effective + hardwareCostWithReplacement) * groundLatencyPenalty; // Includes delayPenalty + scarcityRent\n        // UNIFIED SCARCITY ACCOUNTING: Keep totalCostPerPflopYear physical-only\n        // Scarcity (delayPenalty + scarcityRent) is treated purely in GPU-hour pricing, not in PFLOP-year cost\n        groundTotalCost = groundTotalCost_base; // Physical costs only (scarcity in GPU-hour)\n        var _groundResult_buildoutDebug_backlogGW;\n        // Detect if ground has queue/backlog (constraints are active) - for diagnostics only\n        groundHasQueue = avgWaitYears > 0.05 || backlogGW > 0.05 || ((_groundResult_buildoutDebug_backlogGW = groundResult === null || groundResult === void 0 ? void 0 : (_groundResult_buildoutDebug4 = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug4 === void 0 ? void 0 : _groundResult_buildoutDebug4.backlogGW) !== null && _groundResult_buildoutDebug_backlogGW !== void 0 ? _groundResult_buildoutDebug_backlogGW : 0) > 0.05;\n        // For crossover: use base cost (scarcity is already reflected in GPU-hour pricing)\n        // This ensures we don't double-count scarcity\n        groundComparatorCostPerPflopYear = groundTotalCost; // Base cost only (scarcity in GPU-hour)\n        energyConstraintMultiplier = 1.0; // Energy NOT affected by buildout constraints\n        // Constraint breakdown: all 1.0 (no multipliers, use buildout terms instead)\n        constraintBreakdown = {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        };\n        groundResult = {\n            energyCost: energyCost * groundLatencyPenalty,\n            siteCost: siteCostPerPflopYear_base * groundLatencyPenalty,\n            hardwareCost: hardwareCostWithReplacement * groundLatencyPenalty,\n            // Replacement/ops breakdown\n            replacementCost: replacementCostPerPflopYear * groundLatencyPenalty,\n            sparesCarryCost: sparesCarryCostPerPflopYear * groundLatencyPenalty,\n            opsCost: groundOpsCostPerPflopYear * groundLatencyPenalty,\n            siteCapexAmortPerPflopYear: siteCapexAmortPerPflopYear * groundLatencyPenalty,\n            capacityDeliveryPremium: buildoutPremiumPerPflopYear * groundLatencyPenalty,\n            timeToEnergizePenalty: delayPenaltyPerPflopYear * groundLatencyPenalty,\n            totalCostPerPflopYear: groundTotalCost,\n            totalCostPerPflopYearBase: groundTotalCost_base,\n            totalCostPerPflopYearEffective: groundTotalCost,\n            totalCostPerPflopYearAllIn: groundTotalCost,\n            // Debug: show pricing components\n            pricingComponents: {\n                delayPenaltyWeighted: delayPenaltyWeighted * groundLatencyPenalty,\n                scarcityRentPerPflopYear: scarcityRentPerPflopYear * groundLatencyPenalty,\n                pricingMode,\n                delayPenaltyWeight,\n                rentFrac: scarcityRentResult.rentFrac,\n                waitEffYears: scarcityRentResult.waitEffYears,\n                // Debug fields for scarcity rent calculation\n                scarcityHill: scarcityRentResult.scarcityHill,\n                avgWaitYearsRaw: scarcityRentResult.avgWaitYearsRaw,\n                avgWaitYearsClamped: scarcityRentResult.avgWaitYearsClamped\n            },\n            constraintMultiplier: 1.0,\n            breakdown: constraintBreakdown,\n            supplyMetrics: {\n                demandGw: mobilizationResult.demandGW,\n                capacityGw: capacityGW,\n                pipelineGw: pipelineGW,\n                maxBuildRateGwYear: buildRateGWyr,\n                avgWaitYears: avgWaitYears,\n                utilizationPct: capacityGW > 0 ? mobilizationResult.demandGW / capacityGW : 0\n            },\n            // Buildout debug fields (from ramping mobilization model)\n            backlogGw: backlogGW,\n            avgWaitYears: avgWaitYears,\n            buildoutDebug: {\n                demandNewGW: demandNewGW,\n                buildableGW: buildableGW,\n                buildRateGWyr: buildRateGWyr,\n                capacityGW: capacityGW,\n                pipelineGW: pipelineGW,\n                scarcityIndex: buildoutResult.factors.scarcityIndex,\n                buildoutCapex_$PerkW: buildoutResult.factors.buildoutCapex_$PerkW,\n                annualizedBuildoutPremium_$PerkWyr: buildoutResult.factors.annualizedBuildoutPremium_$PerkWyr,\n                timeToPowerYears: avgWaitYears,\n                valueOfTime_$PerYear: buildoutResult.factors.valueOfTime_$PerYear,\n                delayPenalty_$PerYear: buildoutResult.factors.delayPenalty_$PerYear,\n                buildoutPremiumPerPflopYear: buildoutPremiumPerPflopYear,\n                delayPenaltyPerPflopYear: delayPenaltyPerPflopYear,\n                // Additional mobilization debug fields\n                demandGW: mobilizationResult.demandGW,\n                demandGrowthRate: mobilizationResult.demandGrowthRate,\n                backlogGW: mobilizationResult.backlogGW,\n                avgWaitYears: mobilizationResult.avgWaitYears\n            },\n            smrEnabled: false,\n            smrRampFactor: 0,\n            effectiveElectricityCost: groundElectricityPricePerMwh,\n            constraintRelief: {\n                grid: 0,\n                cooling: 0,\n                water: 0,\n                land: 0\n            },\n            constraints: {\n                method: \"adders\",\n                capacityDeliveryPremium: buildoutPremiumPerPflopYear * groundLatencyPenalty,\n                delayPenalty: delayPenaltyPerPflopYear * groundLatencyPenalty,\n                scarcityRentPerPflopYear: scarcityRentPerPflopYear * groundLatencyPenalty,\n                scarcityMultiplier: scarcityMultiplier,\n                appliedMultipliers: {\n                    constraintMultiplierUsed: false,\n                    energyMultiplierUsed: false,\n                    siteMultiplierUsed: false\n                },\n                waccBase: baseWacc,\n                waccEffective: waccEffective,\n                rentFrac: scarcityRentResult.rentFrac,\n                waitYearsUsed: scarcityRentResult.waitEffYears,\n                waitEffYears: scarcityRentResult.waitEffYears,\n                // Debug fields for scarcity rent calculation\n                scarcityHill: scarcityRentResult.scarcityHill,\n                avgWaitYearsRaw: scarcityRentResult.avgWaitYearsRaw,\n                avgWaitYearsClamped: scarcityRentResult.avgWaitYearsClamped,\n                debug: {\n                    doubleCountCheck: {\n                        mode: \"adders\",\n                        multiplierApplied: false,\n                        addersApplied: true,\n                        invariantOk: true,\n                        notes: \"Buildout model uses adders only (capacityDeliveryPremium + delayPenalty + scarcityRent)\"\n                    }\n                }\n            }\n        };\n        // Invariant: If using adders, multipliers must not be applied\n        if (true) {\n            const hasMultiplier = groundResult.constraintMultiplier !== 1.0;\n            const hasAdder = groundResult.capacityDeliveryPremium > 0 || groundResult.timeToEnergizePenalty > 0;\n            if (hasMultiplier && hasAdder) {\n                throw new Error(\"[DOUBLE COUNTING DETECTED] Year \".concat(year, \": constraintMultiplier=\").concat(groundResult.constraintMultiplier, \" != 1.0 \") + \"AND adders > 0 (capacityDeliveryPremium=\".concat(groundResult.capacityDeliveryPremium, \", \") + \"delayPenalty=\".concat(groundResult.timeToEnergizePenalty, \"). Both cannot be applied simultaneously.\"));\n            }\n        }\n    } else if (useRegionalModel) {\n        var _regionalResult_supplyMetrics, _regionalResult_supplyMetrics1;\n        const demandPflops = (0,_ground_supply_model__WEBPACK_IMPORTED_MODULE_3__.getGlobalDemandPflops)(year, groundEffectiveGflopsPerW);\n        const regionalResult = (0,_ground_supply_model__WEBPACK_IMPORTED_MODULE_3__.calculateRegionalGroundCost)(year, demandPflops, groundEffectiveGflopsPerW, effectivePueGround, capacityFactorGround, groundHardwareCapexPerPflopYear, undefined // Use default regions\n        );\n        // REFACTORED: Regional model - energy cost should NOT have constraint multiplier\n        // Regional model already separates energy (raw) from site (with constraint)\n        const energyCost = regionalResult.energyCostPerPflopYear; // Raw electricity (NO constraint multiplier)\n        const siteCost = regionalResult.siteCostPerPflopYear; // Site costs WITH constraint multiplier\n        // GROUND COST ACCOUNTING: Explicit separation for regional model\n        const siteCostBase = BASE_SITE_2025;\n        // 1. siteCapexAmortPerPflopYear: Base site capex (NOT affected by constraint)\n        const siteCapexAmortPerPflopYear = siteCostBase;\n        // 2. capacityDeliveryPremiumPerPflopYear: Premium above base (from constraint multiplier)\n        const capacityDeliveryPremiumPerPflopYear = Math.max(0, siteCost - siteCostBase);\n        // 3. timeToEnergizePenaltyPerPflopYear: Regional model doesn't model queue delay separately (0 for now)\n        const timeToEnergizePenaltyPerPflopYear = 0;\n        // INVARIANT: siteCostPerPflopYear = siteCapexAmort + timeToEnergizePenalty + capacityDeliveryPremium\n        const siteCostPerPflopYear = siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + capacityDeliveryPremiumPerPflopYear;\n        // Validation (allow small tolerance for regional model approximation)\n        const siteCostCheck = Math.abs(siteCost - siteCostPerPflopYear);\n        if (siteCostCheck > 1.0) {\n            throw new Error(\"Site cost accounting error (regional model): siteCost=\".concat(siteCost, \" != sum(components)=\").concat(siteCostPerPflopYear, \", diff=\").concat(siteCostCheck));\n        }\n        // CRITICAL FIX: Regional model already separates energy (no multiplier) from site (with premium)\n        // Do NOT apply constraintMultiplier - it's already reflected in siteCostPerPflopYear\n        const constraintMultiplier = 1.0; // Not applied - kept for backward compat only\n        groundTotalCost = regionalResult.totalCostPerPflopYear;\n        groundHasQueue = false; // Regional model doesn't model queue delay separately\n        groundComparatorCostPerPflopYear = groundTotalCost; // Use base cost for regional model\n        energyConstraintMultiplier = 1.0; // Never applied\n        constraintBreakdown = {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        };\n        var _regionalResult_supplyMetrics_pipelineGw, _regionalResult_supplyMetrics_avgWaitYears, _regionalResult_supplyMetrics2;\n        groundResult = {\n            energyCost: energyCost,\n            siteCost: siteCostPerPflopYear,\n            siteCapexAmortPerPflopYear: siteCapexAmortPerPflopYear,\n            capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear,\n            timeToEnergizePenalty: timeToEnergizePenaltyPerPflopYear,\n            hardwareCost: regionalResult.hardwareCapexPerPflopYear,\n            totalCostPerPflopYear: groundTotalCost,\n            constraintMultiplier: 1.0,\n            constraints: {\n                method: \"adders\",\n                capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear,\n                delayPenalty: 0,\n                appliedMultipliers: {\n                    constraintMultiplierUsed: false,\n                    energyMultiplierUsed: false,\n                    siteMultiplierUsed: false\n                },\n                debug: {\n                    doubleCountCheck: {\n                        mode: \"adders\",\n                        multiplierApplied: false,\n                        addersApplied: capacityDeliveryPremiumPerPflopYear > 0,\n                        invariantOk: true,\n                        notes: \"Regional model uses adders only (capacityDeliveryPremium from siteCost - siteCostBase)\"\n                    }\n                }\n            },\n            breakdown: constraintBreakdown,\n            smrEnabled: false,\n            smrRampFactor: 0,\n            effectiveElectricityCost: regionalResult.averageEnergyCostMwh,\n            constraintRelief: {\n                grid: 0,\n                cooling: 0,\n                water: 0,\n                land: 0\n            },\n            // Ensure backlogGw and avgWaitYears are always set (use supplyMetrics as fallback)\n            backlogGw: (_regionalResult_supplyMetrics_pipelineGw = (_regionalResult_supplyMetrics = regionalResult.supplyMetrics) === null || _regionalResult_supplyMetrics === void 0 ? void 0 : _regionalResult_supplyMetrics.pipelineGw) !== null && _regionalResult_supplyMetrics_pipelineGw !== void 0 ? _regionalResult_supplyMetrics_pipelineGw : 0,\n            avgWaitYears: (_regionalResult_supplyMetrics_avgWaitYears = (_regionalResult_supplyMetrics1 = regionalResult.supplyMetrics) === null || _regionalResult_supplyMetrics1 === void 0 ? void 0 : _regionalResult_supplyMetrics1.avgWaitYears) !== null && _regionalResult_supplyMetrics_avgWaitYears !== void 0 ? _regionalResult_supplyMetrics_avgWaitYears : 0,\n            supplyMetrics: (_regionalResult_supplyMetrics2 = regionalResult.supplyMetrics) !== null && _regionalResult_supplyMetrics2 !== void 0 ? _regionalResult_supplyMetrics2 : {\n                demandGw: 0,\n                capacityGw: 0,\n                pipelineGw: 0,\n                maxBuildRateGwYear: 0,\n                avgWaitYears: 0,\n                utilizationPct: 0\n            }\n        };\n    } else {\n        groundResult = calculateGroundTotal(year, params, ENERGY_COST_BASE_2025, groundHardwareCapexPerPflopYear, params.isStaticMode, effectiveGroundScenario, groundLatencyPenalty, smrParams, firstCapYear !== null && firstCapYear !== void 0 ? firstCapYear : null, groundEnergyCostPerPflopYear, groundElectricityPricePerMwh);\n        // CRITICAL FIX: Ensure backlogGw and avgWaitYears are always set (even if calculateGroundTotal doesn't provide them)\n        // Use supplyMetrics as fallback if available, otherwise 0\n        // Type assertion needed because calculateGroundTotal may not include these fields\n        const groundResultWithBacklog = groundResult;\n        if (!(\"backlogGw\" in groundResultWithBacklog) || groundResultWithBacklog.backlogGw === undefined) {\n            var _groundResultWithBacklog_supplyMetrics;\n            var _groundResultWithBacklog_supplyMetrics_pipelineGw;\n            groundResultWithBacklog.backlogGw = (_groundResultWithBacklog_supplyMetrics_pipelineGw = (_groundResultWithBacklog_supplyMetrics = groundResultWithBacklog.supplyMetrics) === null || _groundResultWithBacklog_supplyMetrics === void 0 ? void 0 : _groundResultWithBacklog_supplyMetrics.pipelineGw) !== null && _groundResultWithBacklog_supplyMetrics_pipelineGw !== void 0 ? _groundResultWithBacklog_supplyMetrics_pipelineGw : 0; // TEMP proxy\n        }\n        if (!(\"avgWaitYears\" in groundResultWithBacklog) || groundResultWithBacklog.avgWaitYears === undefined) {\n            var _groundResultWithBacklog_supplyMetrics1;\n            var _groundResultWithBacklog_supplyMetrics_avgWaitYears;\n            groundResultWithBacklog.avgWaitYears = (_groundResultWithBacklog_supplyMetrics_avgWaitYears = (_groundResultWithBacklog_supplyMetrics1 = groundResultWithBacklog.supplyMetrics) === null || _groundResultWithBacklog_supplyMetrics1 === void 0 ? void 0 : _groundResultWithBacklog_supplyMetrics1.avgWaitYears) !== null && _groundResultWithBacklog_supplyMetrics_avgWaitYears !== void 0 ? _groundResultWithBacklog_supplyMetrics_avgWaitYears : 0;\n        }\n        // Ensure supplyMetrics exists\n        if (!groundResultWithBacklog.supplyMetrics) {\n            var _groundResultWithBacklog_backlogGw, _groundResultWithBacklog_avgWaitYears;\n            groundResultWithBacklog.supplyMetrics = {\n                demandGw: 0,\n                capacityGw: 0,\n                pipelineGw: (_groundResultWithBacklog_backlogGw = groundResultWithBacklog.backlogGw) !== null && _groundResultWithBacklog_backlogGw !== void 0 ? _groundResultWithBacklog_backlogGw : 0,\n                maxBuildRateGwYear: 0,\n                avgWaitYears: (_groundResultWithBacklog_avgWaitYears = groundResultWithBacklog.avgWaitYears) !== null && _groundResultWithBacklog_avgWaitYears !== void 0 ? _groundResultWithBacklog_avgWaitYears : 0,\n                utilizationPct: 0\n            };\n        }\n        groundResult = groundResultWithBacklog;\n        groundTotalCost = groundResult.totalCostPerPflopYear;\n        var _groundResult_timeToEnergizePenalty;\n        groundHasQueue = ((_groundResult_timeToEnergizePenalty = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty !== void 0 ? _groundResult_timeToEnergizePenalty : 0) > 0.01; // Check if delay penalty exists\n        var _groundResult_totalCostPerPflopYearEffective;\n        groundComparatorCostPerPflopYear = groundHasQueue ? (_groundResult_totalCostPerPflopYearEffective = groundResult.totalCostPerPflopYearEffective) !== null && _groundResult_totalCostPerPflopYearEffective !== void 0 ? _groundResult_totalCostPerPflopYearEffective : groundResult.totalCostPerPflopYear : groundTotalCost;\n        // CRITICAL FIX: Never apply multipliers - all set to 1.0\n        energyConstraintMultiplier = 1.0; // Never applied\n        // Invariant: If using adders, multipliers must not be applied\n        if ( true && groundResult.constraints) {\n            const hasMultiplier = groundResult.constraintMultiplier !== 1.0;\n            const hasAdder = groundResult.constraints.capacityDeliveryPremium > 0 || groundResult.constraints.delayPenalty > 0;\n            if (hasMultiplier && hasAdder) {\n                throw new Error(\"[DOUBLE COUNTING DETECTED] Year \".concat(year, \": constraintMultiplier=\").concat(groundResult.constraintMultiplier, \" != 1.0 \") + \"AND adders > 0 (capacityDeliveryPremium=\".concat(groundResult.constraints.capacityDeliveryPremium, \", \") + \"delayPenalty=\".concat(groundResult.constraints.delayPenalty, \"). Both cannot be applied simultaneously.\"));\n            }\n        }\n        constraintBreakdown = {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        };\n        // Invariant: Check for double counting\n        if (true) {\n            const hasMultiplier = groundResult.constraintMultiplier !== 1.0 || groundResult.breakdown.energyMultiplier !== 1.0 || groundResult.breakdown.siteMultiplier !== 1.0;\n            const hasPremium = (groundResult.capacityDeliveryPremium || 0) > 0 || (groundResult.timeToEnergizePenalty || 0) > 0;\n            if (hasMultiplier && hasPremium) {\n                console.warn(\"[DOUBLE COUNTING DETECTED] Year \".concat(year, \": \") + \"Multipliers (constraint=\".concat(groundResult.constraintMultiplier, \", \") + \"energy=\".concat(groundResult.breakdown.energyMultiplier, \", \") + \"site=\".concat(groundResult.breakdown.siteMultiplier, \") AND \") + \"premiums (capacity=\".concat(groundResult.capacityDeliveryPremium, \", \") + \"delay=\".concat(groundResult.timeToEnergizePenalty, \") are both present. \") + \"This indicates double counting.\");\n            }\n        }\n    }\n    const launchCostPerKg = getLaunchCostPerKg(year, baseLaunchCost) * launchDiscount;\n    const lifetimeYears = 6;\n    // Fusion toggle params\n    const fusionParams = params.fusionToggleEnabled ? params.fusionToggleParams || {\n        ..._orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_FUSION_PARAMS,\n        enabled: true\n    } : undefined;\n    // CONSTELLATION SIZING: Design constellation to meet compute requirements\n    // Convert target compute (GW) to power (kW) for constellation sizing\n    const targetComputeKw = satellitePowerKW;\n    let constellation = (0,_constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.designConstellation)(targetComputeKw, _constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.SATELLITE_CONSTRAINTS, 100000, trajSpecificPower);\n    // Use per-satellite compute power for cost calculation\n    let computePowerPerSatKw = constellation.computePerSatKw;\n    let hybridResult = (0,_orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.computeSatelliteHybridCost)(year, launchCostPerKg, {\n        ..._orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_CONFIG,\n        computePowerKw: computePowerPerSatKw,\n        altitudeKm: orbitalAltitude,\n        lifetimeYears: lifetimeYears,\n        specificPowerWKg: trajSpecificPower,\n        useRadHardChips: useRadHardChips,\n        sunFraction: sunFraction,\n        workloadType: workloadType || \"inference\"\n    }, fusionParams, params.useCorrectedSpecificPower, params.useCorrectedThermal);\n    // CRITICAL FIX: Calculate delivered efficiency with ALL delivery derates\n    // delivered = systemEffective * thermalCapFactor * radiationDerate * availability\n    // Single source of truth for all three factors:\n    const thermalCapFactor = hybridResult.thermalSystem.thermalCapFactor;\n    const radiationDerate = hybridResult.degradationFactor || 1.0; // Hardware degradation from radiation (chip failures, ECC overhead)\n    const availability = hybridResult.capacityFactor || 1.0; // Capacity factor is uptime-inclusive (includes eclipse, degradation, radiation downtime, uptime)\n    // Calculate delivered efficiency (all derates applied multiplicatively)\n    // This is the true \"delivered\" efficiency that accounts for all operational constraints\n    let orbitDeliveredGflopsPerWatt = orbitSystemEffectiveGflopsPerWatt * thermalCapFactor * radiationDerate * availability;\n    // CRITICAL: If thermal constraint causes delivered efficiency to drop below minimum (20 GFLOPS/W),\n    // this indicates a severe thermal constraint that should be handled by expanding radiator or reducing compute\n    // For now, we clamp to minimum to prevent validation errors, but log a warning (only once per year)\n    if (orbitDeliveredGflopsPerWatt < CONSTANTS.MIN_DELIVERED_GFLOPS_PER_W) {\n        const originalDelivered = orbitDeliveredGflopsPerWatt;\n        orbitDeliveredGflopsPerWatt = CONSTANTS.MIN_DELIVERED_GFLOPS_PER_W;\n    // Log warning about severe thermal constraint (only in dev, and only once per year to reduce spam)\n    // The actual clamped value is available in orbit.computeEfficiency.validation metadata\n    // Thermal constraint warnings removed for cleaner console output\n    }\n    // Use delivered efficiency for all cost calculations\n    let orbitEffectiveGflopsPerW = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(orbitDeliveredGflopsPerWatt, \"orbital delivered efficiency calculation\");\n    // Power scaling calculation\n    const powerScalingParams = params.powerScalingParams || _orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_POWER_SCALING;\n    const scalingResult = (0,_orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.calculateScaledMass)(computePowerPerSatKw, powerScalingParams);\n    // CONSTELLATION SCALING: Apply constellation multiplier to mass and costs\n    // Per-satellite mass (already calculated for one satellite)\n    let massPerSatKg = hybridResult.totalMassKg * massMultiplier;\n    // CRITICAL FIX: Check if actual mass exceeds limit and re-split constellation if needed\n    // The simplified mass model in designConstellation may underestimate actual mass\n    // If actual mass exceeds limit, we need to split into smaller satellites\n    const MAX_SATELLITE_MASS_KG = _constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.SATELLITE_CONSTRAINTS.maxMassKg; // 10,000 kg from constraints\n    if (massPerSatKg > MAX_SATELLITE_MASS_KG) {\n        // Calculate required compute per satellite to stay under mass limit\n        // Mass scales roughly with compute power, so: massPerSatKg / computePowerPerSatKw = massPerKw\n        const massPerKw = massPerSatKg / computePowerPerSatKw;\n        const maxComputePerSatKw = MAX_SATELLITE_MASS_KG / massPerKw;\n        // Recalculate constellation with smaller satellites\n        const adjustedConstellation = (0,_constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.designConstellation)(targetComputeKw, {\n            ..._constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.SATELLITE_CONSTRAINTS,\n            maxComputeKw: maxComputePerSatKw * 0.9\n        }, 100000, trajSpecificPower);\n        // Recalculate hybrid cost with adjusted compute per satellite\n        const adjustedHybridResult = (0,_orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.computeSatelliteHybridCost)(year, launchCostPerKg, {\n            ..._orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_CONFIG,\n            computePowerKw: adjustedConstellation.computePerSatKw,\n            altitudeKm: orbitalAltitude,\n            lifetimeYears: lifetimeYears,\n            specificPowerWKg: trajSpecificPower,\n            useRadHardChips: useRadHardChips,\n            sunFraction: sunFraction,\n            workloadType: workloadType || \"inference\"\n        }, fusionParams, params.useCorrectedSpecificPower, params.useCorrectedThermal);\n        // Update with adjusted values\n        const adjustedMassPerSatKg = adjustedHybridResult.totalMassKg * massMultiplier;\n        if (adjustedMassPerSatKg > MAX_SATELLITE_MASS_KG) {\n            // Still too heavy - this shouldn't happen, but log a warning\n            console.warn(\"Satellite mass \".concat(adjustedMassPerSatKg.toFixed(0), \"kg still exceeds limit \").concat(MAX_SATELLITE_MASS_KG, \"kg \") + \"even after splitting to \".concat(adjustedConstellation.computePerSatKw.toFixed(1), \"kW per satellite. \") + \"Consider further reducing compute per satellite or improving specific power.\");\n        }\n        // Use adjusted constellation and hybrid result\n        constellation = adjustedConstellation;\n        hybridResult = adjustedHybridResult;\n        computePowerPerSatKw = adjustedConstellation.computePerSatKw;\n        massPerSatKg = adjustedMassPerSatKg;\n        // Recalculate delivered efficiency with adjusted thermal cap (all derates applied)\n        const adjustedThermalCapFactor = hybridResult.thermalSystem.thermalCapFactor;\n        const adjustedRadiationDerate = hybridResult.degradationFactor || 1.0;\n        const adjustedAvailability = hybridResult.capacityFactor || 1.0;\n        let adjustedDeliveredGflopsPerWatt = orbitSystemEffectiveGflopsPerWatt * adjustedThermalCapFactor * adjustedRadiationDerate * adjustedAvailability;\n        // Clamp to minimum if thermal constraint is too severe\n        if (adjustedDeliveredGflopsPerWatt < CONSTANTS.MIN_DELIVERED_GFLOPS_PER_W) {\n            adjustedDeliveredGflopsPerWatt = CONSTANTS.MIN_DELIVERED_GFLOPS_PER_W;\n        }\n        orbitEffectiveGflopsPerW = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(adjustedDeliveredGflopsPerWatt, \"orbital delivered efficiency (after constellation split)\");\n    }\n    // Scale costs by number of satellites and apply constellation overhead\n    // Calculate AFTER mass check so we use the adjusted constellation if it was split\n    const constellationMultiplier = constellation.numSatellites;\n    const constellationOverheadMultiplier = constellation.constellationOverhead;\n    // Total constellation mass\n    const effectiveTotalMassKg = massPerSatKg * constellation.numSatellites;\n    const effectiveTotalLaunchCost = effectiveTotalMassKg * launchCostPerKg;\n    // Apply Elon Scenario: Discounts\n    const effectivePowerFabCost = hybridResult.powerSystem.fabCostUsd * powerDiscount;\n    const effectiveNetworkingFabCost = hybridResult.networking.fabCostUsd * networkingDiscount;\n    const effectiveNetworkingOpEx = (hybridResult.networking.annualOpExUsd || 0) * networkingDiscount;\n    // Effective PFLOPs: per-satellite PFLOPs  number of satellites\n    const effectivePflopsPerSat = hybridResult.effectivePflops;\n    const totalEffectivePflops = effectivePflopsPerSat * constellation.numSatellites;\n    // Launch cost: total constellation launch cost / total PFLOPs\n    const launchCostPerPflopYear = effectiveTotalLaunchCost / totalEffectivePflops / lifetimeYears;\n    // CRITICAL FIX 1: Cost Accounting - ensure breakdown sums to total\n    // Calculate each component explicitly, scaled by constellation\n    // Per-satellite costs  number of satellites  constellation overhead\n    const constellationCostMultiplier = constellation.numSatellites * constellationOverheadMultiplier;\n    const powerCost = effectivePowerFabCost * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const computeCost = (hybridResult.computePayload.chipCostUsd + hybridResult.computePayload.qualificationCostUsd) * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const thermalCost = hybridResult.thermalSystem.fabCostUsd * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const radiationCost = hybridResult.radiationProtection.fabCostUsd * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const busCost = hybridResult.bus.fabCostUsd * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const networkingCost = effectiveNetworkingFabCost * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const interconnectCost = hybridResult.interconnect.totalAnnualCost * constellationCostMultiplier / totalEffectivePflops;\n    const regulatoryCost = (((_hybridResult_regulatory = hybridResult.regulatory) === null || _hybridResult_regulatory === void 0 ? void 0 : _hybridResult_regulatory.annualCostUsd) || 0) * constellationCostMultiplier / totalEffectivePflops;\n    // Ops cost scales with constellation overhead (more satellites = more ops complexity)\n    const baseOpsCostPerSat = hybridResult.opsPerPflopYear * effectivePflopsPerSat; // Total ops cost per satellite\n    const networkingOpsCostPerSat = (hybridResult.networking.annualOpExUsd || 0) - effectiveNetworkingOpEx; // Already per-sat\n    const adjustedNetworkingOpsCostPerSat = effectiveNetworkingOpEx; // Already per-sat\n    const opsCostPerSat = baseOpsCostPerSat - networkingOpsCostPerSat + adjustedNetworkingOpsCostPerSat;\n    // Scale ops cost by constellation (with overhead for coordination)\n    const opsCostMultiplier = constellation.numSatellites * (1 + 0.1 * Math.log10(constellation.numSatellites));\n    const opsCost = opsCostPerSat * opsCostMultiplier / totalEffectivePflops;\n    const orbitalBreakdown = {\n        power: powerCost,\n        compute: computeCost,\n        thermal: thermalCost,\n        radiation: radiationCost,\n        bus: busCost,\n        ops: opsCost,\n        congestion: 0,\n        networking: networkingCost,\n        interconnect: interconnectCost,\n        regulatory: regulatoryCost,\n        launch: launchCostPerPflopYear\n    };\n    const totalSatelliteCost = hybridResult.totalSatelliteCost * constellationCostMultiplier;\n    const satelliteCount = constellation.numSatellites; // Use actual constellation size\n    const congestion = (0,_congestion__WEBPACK_IMPORTED_MODULE_0__.calculateCongestion)(satelliteCount, totalSatelliteCost, year, 10000 + satelliteCount, spaceTrafficEnabled);\n    // Total fleet PFLOPS: use constellation total PFLOPs\n    // Already calculated as totalEffectivePflops above\n    orbitalBreakdown.congestion = spaceTrafficEnabled ? congestion.congestionCostPerPflopYear / totalEffectivePflops : 0;\n    // PATCH G: Cost Accounting Invariants\n    // Use assertCostAccounting to ensure breakdown sums to total exactly\n    const orbitalComponents = [\n        {\n            name: \"power\",\n            value: orbitalBreakdown.power\n        },\n        {\n            name: \"compute\",\n            value: orbitalBreakdown.compute\n        },\n        {\n            name: \"thermal\",\n            value: orbitalBreakdown.thermal\n        },\n        {\n            name: \"radiation\",\n            value: orbitalBreakdown.radiation\n        },\n        {\n            name: \"bus\",\n            value: orbitalBreakdown.bus\n        },\n        {\n            name: \"ops\",\n            value: orbitalBreakdown.ops\n        },\n        {\n            name: \"networking\",\n            value: orbitalBreakdown.networking\n        },\n        {\n            name: \"interconnect\",\n            value: orbitalBreakdown.interconnect\n        },\n        {\n            name: \"regulatory\",\n            value: orbitalBreakdown.regulatory\n        },\n        {\n            name: \"launch\",\n            value: orbitalBreakdown.launch\n        },\n        {\n            name: \"congestion\",\n            value: orbitalBreakdown.congestion\n        }\n    ];\n    const breakdownSum = Object.values(orbitalBreakdown).reduce((a, b)=>a + b, 0);\n    const realisticCostPerPflop = breakdownSum;\n    // Track applied multipliers for debugging\n    const appliedMultipliers = [\n        {\n            name: \"launchDiscount\",\n            value: launchDiscount,\n            appliedTo: \"launch cost\"\n        },\n        {\n            name: \"powerDiscount\",\n            value: powerDiscount,\n            appliedTo: \"power fab cost\"\n        },\n        {\n            name: \"networkingDiscount\",\n            value: networkingDiscount,\n            appliedTo: \"networking cost\"\n        },\n        {\n            name: \"massMultiplier\",\n            value: massMultiplier,\n            appliedTo: \"total mass\"\n        }\n    ];\n    // Assert cost accounting (throws if invalid)\n    const orbitalAccounting = (0,_cost_accounting__WEBPACK_IMPORTED_MODULE_9__.assertCostAccounting)(realisticCostPerPflop, orbitalComponents, appliedMultipliers);\n    const costAccountingValid = orbitalAccounting.valid;\n    const costAccountingErrorPct = orbitalAccounting.errorPct;\n    // FIX 5: GPU-hour breakdown must derive from annual cost breakdown\n    // GPU-hour pricing: Apply scarcity as MULTIPLICATIVE multiplier (not additive)\n    // delayPenalty remains additive (WACC carry cost), but scarcity rent is now multiplicative\n    const delayPenaltyPerPflopYear = ((_groundResult_constraints = groundResult.constraints) === null || _groundResult_constraints === void 0 ? void 0 : _groundResult_constraints.delayPenalty) || 0;\n    var _groundResult_constraints_scarcityMultiplier;\n    const scarcityMultiplier = (_groundResult_constraints_scarcityMultiplier = (_groundResult_constraints1 = groundResult.constraints) === null || _groundResult_constraints1 === void 0 ? void 0 : _groundResult_constraints1.scarcityMultiplier) !== null && _groundResult_constraints_scarcityMultiplier !== void 0 ? _groundResult_constraints_scarcityMultiplier : 1.0; // Multiplier from log-based function\n    // Convert delayPenalty to $/GPU-hour (still additive)\n    const pflopsPerGpu = 2.0;\n    const utilizationTarget = 0.85;\n    const hoursPerYear = 8760;\n    const annualGpuHoursPerPFLOP = hoursPerYear * utilizationTarget / pflopsPerGpu;\n    const delayPenaltyAdderPerGpuHour = delayPenaltyPerPflopYear / annualGpuHoursPerPFLOP;\n    // Note: Scarcity is now MULTIPLICATIVE (not additive), so no conversion check needed\n    // Scarcity multiplier is applied directly to base cost in GPU-hour pricing\n    // Use BASE cost (without scarcity) for GPU-hour pricing, then apply scarcity as multiplier\n    // This prevents double-counting: scarcity is multiplicative in GPU-hour pricing, not additive\n    // We want: baseCost (no scarcity) * scarcityMultiplier = total with scarcity\n    // Use groundResult.totalCostPerPflopYearBase if available (from buildout model), otherwise construct from components\n    const groundCostBaseForPricing = useBuildoutModel && (groundResult === null || groundResult === void 0 ? void 0 : groundResult.totalCostPerPflopYearBase) !== undefined ? groundResult.totalCostPerPflopYearBase : (groundResult.energyCost + groundResult.siteCost + groundResult.hardwareCost) * groundLatencyPenalty;\n    const groundGpuHour = (sla)=>{\n        const basePricing = calculateGpuHourPricing(groundCostBaseForPricing, {\n            pflopsPerGpu,\n            utilizationTarget,\n            operatorMarginPct: operatorMargin,\n            sla,\n            location: \"ground\"\n        }, {\n            compute: groundResult.hardwareCost,\n            power: groundResult.energyCost,\n            site: useBuildoutModel ? groundResult.siteCapexAmortPerPflopYear : groundResult.siteCost\n        });\n        // UNIFIED SCARCITY ACCOUNTING: Scarcity is MULTIPLICATIVE (not additive)\n        // CRITICAL FIX: Apply scarcity as premium on FIXED reference base, not declining base\n        // This prevents Moore's Law from eroding scarcity dollar amounts\n        // Extract base cost before margin (this declines with Moore's Law)\n        const preMarginBase = basePricing.pricePerGpuHour - (basePricing.costBreakdown.margin || 0);\n        // Scarcity premium based on FIXED reference, not declining base\n        // This ensures scarcity doesn't get eroded by Moore's Law\n        const SCARCITY_REFERENCE_BASE = 3.50; // Fixed 2025 market reference ($/GPU-hr)\n        const scarcityPremium = (scarcityMultiplier - 1) * SCARCITY_REFERENCE_BASE;\n        // Total cost = base (declining with Moore's Law) + scarcity (fixed) + delay\n        const costWithScarcity = preMarginBase + scarcityPremium;\n        const costWithScarcityAndDelay = costWithScarcity + delayPenaltyAdderPerGpuHour;\n        // Then add margin\n        const margin = costWithScarcityAndDelay * operatorMargin;\n        const pricePerGpuHour = costWithScarcityAndDelay + margin;\n        return {\n            ...basePricing,\n            pricePerGpuHour,\n            costBreakdown: {\n                ...basePricing.costBreakdown,\n                scarcity: scarcityPremium,\n                delayPenalty: delayPenaltyAdderPerGpuHour,\n                margin\n            }\n        };\n    };\n    const orbitalGpuHour = (sla)=>calculateGpuHourPricing(realisticCostPerPflop, {\n            pflopsPerGpu: 2.0,\n            utilizationTarget: 0.85,\n            operatorMarginPct: operatorMargin,\n            sla,\n            location: \"orbital\"\n        }, orbitalBreakdown); // Use full orbital breakdown\n    const groundTokens = {\n        llama70B: calculateTokenPricing(groundTotalCost, {\n            params: 70e9,\n            precision: \"fp16\"\n        }),\n        llama405B: calculateTokenPricing(groundTotalCost, {\n            params: 405e9,\n            precision: \"fp16\"\n        })\n    };\n    const orbitalTokens = {\n        llama70B: calculateTokenPricing(realisticCostPerPflop, {\n            params: 70e9,\n            precision: \"fp16\"\n        }),\n        llama405B: calculateTokenPricing(realisticCostPerPflop, {\n            params: 405e9,\n            precision: \"fp16\"\n        })\n    };\n    const edgeInference = ((_params_edgeInference = params.edgeInference) === null || _params_edgeInference === void 0 ? void 0 : _params_edgeInference.enabled) ? (0,_edgeInference__WEBPACK_IMPORTED_MODULE_1__.computeEdgeInferenceCosts)(year, params.edgeInference, launchCostPerKg, totalEffectivePflops / effectiveTotalMassKg) : undefined;\n    const gpuHourCrossover = orbitalGpuHour(SLA_TIERS.standard).pricePerGpuHour < groundGpuHour(SLA_TIERS.standard).pricePerGpuHour;\n    // ============================================================================\n    // DEBUG INVARIANTS (development mode only)\n    // ============================================================================\n    if (true) {\n        var _groundResult_supplyMetrics4, _groundResult_constraints2, _groundResult_constraints3;\n        var _groundResult_supplyMetrics_avgWaitYears;\n        // Invariant 1: If avgWaitYears > 0 then scarcity multiplier should be > 1.0 (scarcity is multiplicative in GPU-hour pricing)\n        const avgWaitYears = (_groundResult_supplyMetrics_avgWaitYears = (_groundResult_supplyMetrics4 = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics4 === void 0 ? void 0 : _groundResult_supplyMetrics4.avgWaitYears) !== null && _groundResult_supplyMetrics_avgWaitYears !== void 0 ? _groundResult_supplyMetrics_avgWaitYears : 0;\n        var _groundResult_constraints_scarcityMultiplier1;\n        const scarcityMultiplier = (_groundResult_constraints_scarcityMultiplier1 = (_groundResult_constraints2 = groundResult.constraints) === null || _groundResult_constraints2 === void 0 ? void 0 : _groundResult_constraints2.scarcityMultiplier) !== null && _groundResult_constraints_scarcityMultiplier1 !== void 0 ? _groundResult_constraints_scarcityMultiplier1 : 1.0;\n        if (avgWaitYears > 1.0 && scarcityMultiplier <= 1.0) {\n            console.warn(\"[INVARIANT VIOLATION] Year \".concat(year, \": avgWaitYears=\").concat(avgWaitYears, \" > 1.0 but scarcityMultiplier=\").concat(scarcityMultiplier, \" <= 1.0. \") + \"Scarcity multiplier should be > 1.0 when wait time exists (scarcity is multiplicative in GPU-hour pricing).\");\n        }\n        var _groundResult_totalCostPerPflopYearEffective1;\n        // Invariant 2: supplyMetrics.capacityGw is the effective capacity (bottleneck)\n        // Queue model uses coherent backlog based on unmet demand\n        // Invariant 3: GPU-hour chart yMax guard (prevented by explicit series extraction in chart component)\n        // This is handled in the chart component with explicit series extraction\n        // Invariant 4: Crossover uses effective ground cost\n        const groundEffective = (_groundResult_totalCostPerPflopYearEffective1 = groundResult.totalCostPerPflopYearEffective) !== null && _groundResult_totalCostPerPflopYearEffective1 !== void 0 ? _groundResult_totalCostPerPflopYearEffective1 : groundResult.totalCostPerPflopYear;\n        const groundHeadline = groundResult.totalCostPerPflopYear;\n        var _groundResult_constraints_delayPenalty;\n        const delayPenalty = (_groundResult_constraints_delayPenalty = (_groundResult_constraints3 = groundResult.constraints) === null || _groundResult_constraints3 === void 0 ? void 0 : _groundResult_constraints3.delayPenalty) !== null && _groundResult_constraints_delayPenalty !== void 0 ? _groundResult_constraints_delayPenalty : 0;\n        // Scarcity is now multiplicative (not additive), so don't add it to effective cost\n        const expectedEffective = groundHeadline + delayPenalty; // Scarcity applied in GPU-hour pricing, not PFLOP-year\n        const effectiveError = Math.abs(groundEffective - expectedEffective);\n        // Reuse scarcityMultiplier from Invariant 1 above\n        if (effectiveError > 0.01 && (delayPenalty > 0 || scarcityMultiplier > 1.0)) {\n            console.warn(\"[INVARIANT VIOLATION] Year \".concat(year, \": groundEffective=\").concat(groundEffective, \" != expected=\").concat(expectedEffective, \" \") + \"(headline=\".concat(groundHeadline, \", delayPenalty=\").concat(delayPenalty, \", scarcityMultiplier=\").concat(scarcityMultiplier, \"). \") + \"Crossover should use effective cost. Note: scarcity is multiplicative in GPU-hour pricing, not additive in PFLOP-year.\");\n        }\n    }\n    // CRITICAL FIX: Validate delivered efficiency by comparing like-for-like only\n    // expectedDelivered = systemEffectiveGflopsPerWatt * thermalCapFactor * radiationDerate * availability\n    // ratio = deliveredGflopsPerWatt / expectedDelivered\n    // If ratio is finite and |1 - ratio| <= tolerance (0.02), then valid=true, warning=null\n    // Else valid=false, warning describes the mismatch\n    // Remove any other comparisons (e.g., delivered vs systemEffective, delivered vs peak*utilization without overhead, etc.)\n    const expectedDelivered = orbitSystemEffectiveGflopsPerWatt * thermalCapFactor * radiationDerate * availability;\n    const ratio = orbitDeliveredGflopsPerWatt / Math.max(expectedDelivered, 1e-6);\n    const TOLERANCE = 0.02; // 2% tolerance\n    const ratioError = Math.abs(1 - ratio);\n    // CRITICAL: Fix validator logic - if ratio is finite and |1 - ratio| <= tolerance, then valid=true\n    const isRatioValid = isFinite(ratio) && ratioError <= TOLERANCE;\n    // Escalate: if mismatch > 5%, mark as invalid (don't just warn)\n    const ESCALATE_THRESHOLD = 0.05; // 5%\n    const isInvalid = !isRatioValid && ratioError > ESCALATE_THRESHOLD;\n    // Debug invariants: assert delivered <= systemEffective + eps\n    const deliveredVsSystemError = orbitDeliveredGflopsPerWatt - orbitSystemEffectiveGflopsPerWatt;\n    if (deliveredVsSystemError > 1e-6) {\n        console.warn(\"[INVARIANT VIOLATION] Delivered efficiency (\".concat(orbitDeliveredGflopsPerWatt.toFixed(2), \") > systemEffective (\").concat(orbitSystemEffectiveGflopsPerWatt.toFixed(2), \"). \") + \"Delivered must be <= systemEffective.\");\n    }\n    // Efficiency debug logging removed for cleaner console output\n    // Validation results are available in orbit.computeEfficiency.validation metadata\n    // CRITICAL: Validate delivered efficiency - compare delivered vs expectedDelivered only\n    // Make validator debug explicit with all factors\n    // If mismatch > 5%, mark run invalid and stop chart rendering (escalate, don't silently warn)\n    const deliveredValidation = {\n        valid: isRatioValid,\n        warning: isRatioValid ? undefined // Empty/null when valid\n         : \"Power/Efficiency mismatch: \".concat(ratio.toFixed(2), \"x discrepancy (expected=\").concat(expectedDelivered.toFixed(2), \", delivered=\").concat(orbitDeliveredGflopsPerWatt.toFixed(2), \")\"),\n        expectedDelivered,\n        delivered: orbitDeliveredGflopsPerWatt,\n        ratio,\n        factorsUsed: {\n            thermalCapFactor,\n            radiationDerate,\n            availability,\n            utilization: orbitalEfficiencyResult.debug.utilizationFactor,\n            systemOverheadFactor: orbitalEfficiencyResult.debug.systemOverheadFactor\n        },\n        // Escalate: if ratio is way off (> 5%), mark as invalid\n        invalid: !isRatioValid && Math.abs(1 - ratio) > 0.05\n    };\n    const efficiencyValidation = validateComputeEfficiency(orbitEffectiveGflopsPerW, params.efficiencyLevel);\n    const consistencyCheck = assertComputePowerConsistency(orbitEffectiveGflopsPerW, targetComputeKw, totalEffectivePflops, MODEL_UNITS);\n    var _groundResult_capacityDeliveryPremium, _groundResult_timeToEnergizePenalty1, _groundResult_siteCapexAmortPerPflopYear, _groundResult_timeToEnergizePenalty2, _groundResult_capacityDeliveryPremium1, _hybridResult_specificPowerMultipliers_massMultiplier, _hybridResult_thermalSystem_wasteHeatW, _hybridResult_thermalSystem_qPerM2_W, _hybridResult_thermalSystem_areaAvailableM2;\n    // SANITY PANEL: Comprehensive debug block per year\n    const sanityPanel = {\n        ground: {\n            effectiveGflopsPerW: groundEffectiveGflopsPerW,\n            energyCostPerPflopYear: groundResult.energyCost,\n            siteCapexAmort: (_groundResult_siteCapexAmortPerPflopYear = groundResult.siteCapexAmortPerPflopYear) !== null && _groundResult_siteCapexAmortPerPflopYear !== void 0 ? _groundResult_siteCapexAmortPerPflopYear : groundResult.siteCost - ((_groundResult_capacityDeliveryPremium = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium !== void 0 ? _groundResult_capacityDeliveryPremium : 0) - ((_groundResult_timeToEnergizePenalty1 = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty1 !== void 0 ? _groundResult_timeToEnergizePenalty1 : 0),\n            delayPenalty: (_groundResult_timeToEnergizePenalty2 = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty2 !== void 0 ? _groundResult_timeToEnergizePenalty2 : 0,\n            capacityPremium: (_groundResult_capacityDeliveryPremium1 = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium1 !== void 0 ? _groundResult_capacityDeliveryPremium1 : 0,\n            constraintMultiplier: groundResult.constraintMultiplier,\n            total: groundTotalCost\n        },\n        orbit: {\n            // REMOVED: effectiveSpecificPower (duplicate of specificPower_effective_WPerKg)\n            // Use specificPower_effective_WPerKg instead (canonical field)\n            massMultiplier: (_hybridResult_specificPowerMultipliers_massMultiplier = (_hybridResult_specificPowerMultipliers = hybridResult.specificPowerMultipliers) === null || _hybridResult_specificPowerMultipliers === void 0 ? void 0 : _hybridResult_specificPowerMultipliers.massMultiplier) !== null && _hybridResult_specificPowerMultipliers_massMultiplier !== void 0 ? _hybridResult_specificPowerMultipliers_massMultiplier : 1.0,\n            requiredAreaM2: hybridResult.thermalSystem.qPerM2_W ? ((_hybridResult_thermalSystem_wasteHeatW = hybridResult.thermalSystem.wasteHeatW) !== null && _hybridResult_thermalSystem_wasteHeatW !== void 0 ? _hybridResult_thermalSystem_wasteHeatW : hybridResult.thermalSystem.wasteHeatKw * 1000) / ((_hybridResult_thermalSystem_qPerM2_W = hybridResult.thermalSystem.qPerM2_W) !== null && _hybridResult_thermalSystem_qPerM2_W !== void 0 ? _hybridResult_thermalSystem_qPerM2_W : 1) : hybridResult.thermalSystem.physicalAreaM2,\n            areaAvailableM2: (_hybridResult_thermalSystem_areaAvailableM2 = hybridResult.thermalSystem.areaAvailableM2) !== null && _hybridResult_thermalSystem_areaAvailableM2 !== void 0 ? _hybridResult_thermalSystem_areaAvailableM2 : hybridResult.thermalSystem.physicalAreaM2,\n            thermalCapFactor: hybridResult.thermalSystem.thermalCapFactor,\n            total: realisticCostPerPflop\n        },\n        allInvariantsPassed: (()=>{\n            var _groundResult_siteCapexAmortPerPflopYear, _groundResult_timeToEnergizePenalty, _groundResult_capacityDeliveryPremium;\n            // Check key invariants\n            const siteCostCheck = Math.abs(groundResult.siteCost - (((_groundResult_siteCapexAmortPerPflopYear = groundResult.siteCapexAmortPerPflopYear) !== null && _groundResult_siteCapexAmortPerPflopYear !== void 0 ? _groundResult_siteCapexAmortPerPflopYear : 0) + ((_groundResult_timeToEnergizePenalty = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty !== void 0 ? _groundResult_timeToEnergizePenalty : 0) + ((_groundResult_capacityDeliveryPremium = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium !== void 0 ? _groundResult_capacityDeliveryPremium : 0))) < 0.01;\n            const thermalAreaCheck = hybridResult.thermalSystem.areaAvailableM2 ? Math.abs(hybridResult.thermalSystem.areaAvailableM2 - hybridResult.thermalSystem.physicalAreaM2) / hybridResult.thermalSystem.physicalAreaM2 < 0.01 : true;\n            const specificPowerCheck = hybridResult.specificPowerMultipliers ? hybridResult.specificPowerMultipliers.effective <= hybridResult.specificPowerMultipliers.baseSpecificPower * 1.01 : true;\n            const thermalCapCheck = hybridResult.thermalSystem.thermalCapFactor >= 0 && hybridResult.thermalSystem.thermalCapFactor <= 1;\n            return siteCostCheck && thermalAreaCheck && specificPowerCheck && thermalCapCheck;\n        })()\n    };\n    var _groundResult_capacityDeliveryPremium2, _groundResult_timeToEnergizePenalty3, _groundResult_siteCapexAmortPerPflopYear1, _groundResult_capacityDeliveryPremium3, _groundResult_timeToEnergizePenalty4, _hybridResult_specificPowerMultipliers_effective, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _ref10, _ref11;\n    return {\n        year,\n        mode: params.isStaticMode ? \"STATIC\" : \"DYNAMIC\",\n        sanityPanel,\n        ground: {\n            electricityPricePerMwh: groundElectricityPricePerMwh,\n            pue: effectivePueGround,\n            capacityFactor: capacityFactorGround,\n            // HARD ASSERT: All ground efficiency fields must be populated and finite\n            gflopsPerWatt: (()=>{\n                const value = groundEffectiveGflopsPerW;\n                if (!isFinite(value) || value <= 0) {\n                    throw new Error(\"ground.gflopsPerWatt is invalid: \".concat(value, \". actualGroundInput=\").concat(actualGroundInput));\n                }\n                return value;\n            })(),\n            computeDefinition: (()=>{\n                // CRITICAL FIX: Validate all computeDefinition fields to catch unit corruption\n                const peak = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(groundEfficiencyResult.debug.chipPeakGflopsPerW, \"ground.computeDefinition.peakGflopsPerWatt\");\n                const effective = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(groundEfficiencyResult.debug.effectiveGflopsPerW, \"ground.computeDefinition.effectiveGflopsPerWatt\");\n                const utilization = groundEfficiencyResult.debug.utilizationFactor;\n                if (!isFinite(utilization) || utilization <= 0 || utilization > 1) {\n                    throw new Error(\"ground.computeDefinition.utilizationFactor is invalid: \".concat(utilization));\n                }\n                return {\n                    chipName: \"NVIDIA H100 SXM\",\n                    precision: \"FP16\",\n                    peakGflopsPerWatt: peak,\n                    utilizationFactor: utilization,\n                    effectiveGflopsPerWatt: effective,\n                    notes: \"Datacenter deployment, system-level efficiency\"\n                };\n            })(),\n            energyCostPerPflopYear: (()=>{\n                const value = groundResult.energyCost;\n                if (!isFinite(value) || value < 0) {\n                    throw new Error(\"ground.energyCostPerPflopYear is invalid: \".concat(value, \". \") + \"Check: groundEffectiveGflopsPerW=\".concat(groundEffectiveGflopsPerW, \", \") + \"groundElectricityPricePerMwh=\".concat(groundElectricityPricePerMwh, \", \") + \"effectivePueGround=\".concat(effectivePueGround));\n                }\n                return value;\n            })(),\n            siteCostPerPflopYear: (()=>{\n                const value = groundResult.siteCost;\n                if (!isFinite(value) || value < 0) {\n                    throw new Error(\"ground.siteCostPerPflopYear is invalid: \".concat(value));\n                }\n                return value;\n            })(),\n            siteCapexAmortPerPflopYear: (_groundResult_siteCapexAmortPerPflopYear1 = groundResult.siteCapexAmortPerPflopYear) !== null && _groundResult_siteCapexAmortPerPflopYear1 !== void 0 ? _groundResult_siteCapexAmortPerPflopYear1 : groundResult.siteCost - ((_groundResult_capacityDeliveryPremium2 = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium2 !== void 0 ? _groundResult_capacityDeliveryPremium2 : 0) - ((_groundResult_timeToEnergizePenalty3 = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty3 !== void 0 ? _groundResult_timeToEnergizePenalty3 : 0),\n            capacityDeliveryPremium: (_groundResult_capacityDeliveryPremium3 = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium3 !== void 0 ? _groundResult_capacityDeliveryPremium3 : 0,\n            timeToEnergizePenalty: (_groundResult_timeToEnergizePenalty4 = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty4 !== void 0 ? _groundResult_timeToEnergizePenalty4 : 0,\n            hardwareCapexPerPflopYear: groundResult.hardwareCost,\n            constraintMultiplier: 1.0,\n            constraintBreakdown: {\n                ...constraintBreakdown,\n                capacityDeliveryMultiplier: 1.0\n            },\n            constraints: groundResult.constraints ? {\n                ...groundResult.constraints,\n                method: \"adders\"\n            } : {\n                method: \"adders\",\n                capacityDeliveryPremium: groundResult.capacityDeliveryPremium || 0,\n                delayPenalty: groundResult.timeToEnergizePenalty || 0,\n                appliedMultipliers: {\n                    constraintMultiplierUsed: false,\n                    energyMultiplierUsed: false,\n                    siteMultiplierUsed: false\n                }\n            },\n            supplyMetrics: groundResult.supplyMetrics,\n            constraintComponents: groundResult.constraintComponents,\n            totalCostPerPflopYear: (()=>{\n                const value = groundTotalCost;\n                if (!isFinite(value) || value <= 0) {\n                    throw new Error(\"ground.totalCostPerPflopYear is invalid: \".concat(value, \". \") + \"Components: energy=\".concat(groundResult.energyCost, \", site=\").concat(groundResult.siteCost, \", hardware=\").concat(groundResult.hardwareCost, \", \") + \"groundEffectiveGflopsPerW=\".concat(groundEffectiveGflopsPerW, \", actualGroundInput=\").concat(actualGroundInput));\n                }\n                return value;\n            })(),\n            gpuHourPricing: {\n                basic: groundGpuHour(SLA_TIERS.basic),\n                standard: groundGpuHour(SLA_TIERS.standard),\n                premium: groundGpuHour(SLA_TIERS.premium)\n            },\n            tokenPricing: groundTokens,\n            smrEnabled: groundResult.smrEnabled,\n            smrRampFactor: groundResult.smrRampFactor,\n            effectiveElectricityCost: groundResult.effectiveElectricityCost,\n            constraintRelief: groundResult.constraintRelief\n        },\n        orbit: {\n            lcoePerMwh: hybridResult.powerSystem.totalCostUsd / (satellitePowerKW * _orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.PHYSICS_CONSTANTS.HOURS_PER_YEAR * lifetimeYears * hybridResult.capacityFactor / 1000),\n            pue: pueOrbital,\n            capacityFactor: hybridResult.capacityFactor,\n            capacityFactorProvenance: (_hybridResult_computePayload = hybridResult.computePayload) === null || _hybridResult_computePayload === void 0 ? void 0 : _hybridResult_computePayload.capacityFactorProvenance,\n            gflopsPerWatt: orbitEffectiveGflopsPerW,\n            computeDefinition: {\n                chipName: \"H100-equivalent (rad-tolerant)\",\n                precision: \"FP16\",\n                peakGflopsPerWatt: (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(orbitPeakGflopsPerWatt, \"orbit.computeDefinition.peakGflopsPerWatt\"),\n                utilizationFactor: orbitalEfficiencyResult.debug.utilizationFactor,\n                effectiveGflopsPerWatt: orbitSystemEffectiveGflopsPerWatt,\n                // deliveredGflopsPerWatt is stored in orbit.computeEfficiency.gflopsPerWatt, not here\n                notes: \"Commercial rad-tolerant variant. peakGflopsPerWatt = chip peak. effectiveGflopsPerWatt = peak * utilization / systemOverheadFactor (system-level effective). deliveredGflopsPerWatt = systemEffective \\xd7 thermalCapFactor \\xd7 radiationDerate \\xd7 availability\"\n            },\n            computeEfficiencyProvenance: {\n                peakGflopsPerWatt: orbitalEfficiencyResult.debug.chipPeakGflopsPerW,\n                utilizationFactor: orbitalEfficiencyResult.debug.utilizationFactor,\n                systemOverheadFactor: orbitalEfficiencyResult.debug.systemOverheadFactor,\n                effectiveGflopsPerWatt: orbitalEfficiencyResult.debug.effectiveGflopsPerW\n            },\n            launchCostPerKg: launchCostPerKg,\n            specificPowerWPerKg: hybridResult.specificPowerWPerKg,\n            specificPower_subsystem_WPerKg: hybridResult.specificPowerWPerKg,\n            specificPower_effective_WPerKg: (_hybridResult_specificPowerMultipliers_effective = (_hybridResult_specificPowerMultipliers1 = hybridResult.specificPowerMultipliers) === null || _hybridResult_specificPowerMultipliers1 === void 0 ? void 0 : _hybridResult_specificPowerMultipliers1.effective) !== null && _hybridResult_specificPowerMultipliers_effective !== void 0 ? _hybridResult_specificPowerMultipliers_effective : scalingResult.effectiveSpecificPower,\n            // Use specificPowerMultipliers from hybridResult (calculated in orbitalPhysics.ts with correct mass fraction accounting)\n            specificPowerMultipliers: hybridResult.specificPowerMultipliers,\n            energyCostPerPflopYear: orbitalBreakdown.power,\n            hardwareCostPerPflopYear: orbitalBreakdown.compute,\n            launchCostPerPflopYear: orbitalBreakdown.launch,\n            radiationMultiplier: 1.0,\n            thermalCapFactor: hybridResult.thermalSystem.thermalCapFactor,\n            congestionCostPerPflopYear: orbitalBreakdown.congestion,\n            totalCostPerPflopYear: realisticCostPerPflop,\n            thermalCapped: hybridResult.thermalSystem.thermalCapped,\n            computePowerKw: targetComputeKw,\n            maxRejectableKw: hybridResult.thermalSystem.maxRejectableKw || hybridResult.thermalSystem.wasteHeatKw * 1.25,\n            collisionRisk: congestion.collisionRisk,\n            bodyMountedAreaM2: 0,\n            deployableAreaM2: hybridResult.thermalSystem.physicalAreaM2,\n            totalRadiatorAreaM2: hybridResult.thermalSystem.physicalAreaM2,\n            radiatorCostPerPflopYear: hybridResult.thermalSystem.totalCostUsd * constellationCostMultiplier / totalEffectivePflops / lifetimeYears,\n            radiatorMassKg: hybridResult.thermalSystem.totalMassKg,\n            optimisticCostPerPflop: orbitalBreakdown.power + orbitalBreakdown.compute + orbitalBreakdown.bus,\n            radiationShieldingCost: orbitalBreakdown.radiation,\n            thermalSystemCost: orbitalBreakdown.thermal,\n            replacementRateCost: orbitalBreakdown.ops,\n            eccOverheadCost: 0,\n            redundancyCost: 0,\n            realisticCostPerPflop,\n            hybridBreakdown: orbitalBreakdown,\n            gpuHourPricing: {\n                basic: orbitalGpuHour(SLA_TIERS.basic),\n                standard: orbitalGpuHour(SLA_TIERS.standard),\n                premium: orbitalGpuHour(SLA_TIERS.premium)\n            },\n            tokenPricing: orbitalTokens,\n            radiationDegradation: {\n                annualFailureRate: useRadHardChips ? 0.09 : 0.15,\n                effectiveComputePercent: hybridResult.degradationFactor,\n                eccOverheadPct: 0.05,\n                applied: true\n            },\n            powerSystemType: hybridResult.powerSystemType,\n            scalingPenalty: scalingResult.scalingPenalty,\n            // REMOVED: effectiveSpecificPower (duplicate of specificPower_effective_WPerKg)\n            // Use specificPower_effective_WPerKg instead (canonical field)\n            fusionDetails: hybridResult.fusionDetails,\n            // Constellation sizing\n            constellation: {\n                design: {\n                    numSatellites: constellation.numSatellites,\n                    computePerSatKw: constellation.computePerSatKw,\n                    massPerSatKg: massPerSatKg,\n                    radiatorAreaPerSatM2: constellation.radiatorAreaPerSatM2\n                },\n                launch: {\n                    satsPerLaunch: constellation.satsPerLaunch,\n                    launchesRequired: constellation.launchesRequired,\n                    totalMassKg: effectiveTotalMassKg\n                },\n                scaling: {\n                    constellationOverhead: constellation.constellationOverhead,\n                    scalingEfficiency: constellation.scalingEfficiency\n                },\n                warnings: constellation.warnings\n            },\n            // Debug blocks for analysis - explicitly track all efficiency levels\n            // Single source of truth: define orbit.computeEfficiencyLevels each year\n            // Note: computeEfficiencyLevels is stored in metadata, not directly on orbit\n            effectiveComputeMultipliers: {\n                thermalCapFactor: hybridResult.thermalSystem.thermalCapFactor,\n                radiationDerate: hybridResult.degradationFactor || 1.0,\n                availability: hybridResult.capacityFactor || 1.0,\n                utilization: orbitalEfficiencyResult.debug.utilizationFactor\n            },\n            costShares: (()=>{\n                const total = realisticCostPerPflop;\n                return {\n                    launch: orbitalBreakdown.launch / total * 100,\n                    power: orbitalBreakdown.power / total * 100,\n                    compute: orbitalBreakdown.compute / total * 100,\n                    thermal: orbitalBreakdown.thermal / total * 100,\n                    bus: orbitalBreakdown.bus / total * 100,\n                    ops: orbitalBreakdown.ops / total * 100,\n                    networking: orbitalBreakdown.networking / total * 100,\n                    groundSegment: orbitalBreakdown.regulatory / total * 100\n                };\n            })(),\n            localSensitivity: (()=>{\n                // Calculate local sensitivity: dCost/dParameter (approximate derivatives)\n                // dCost_dLaunch: launch cost scales linearly with launchCostPerKg\n                const dCost_dLaunch = orbitalBreakdown.launch / launchCostPerKg;\n                // dCost_dSpecificPower: power cost scales inversely with specific power (negative)\n                const dCost_dSpecificPower = -(orbitalBreakdown.power / trajSpecificPower);\n                // dCost_dGflopsPerW: power cost scales inversely with GFLOPS/W (negative)\n                const dCost_dGflopsPerW = -(orbitalBreakdown.power / orbitEffectiveGflopsPerW);\n                // dCost_dFailureRate: ops cost scales with failure rate\n                const baseFailureRate = useRadHardChips ? 0.09 : 0.15;\n                const dCost_dFailureRate = orbitalBreakdown.ops / baseFailureRate;\n                // dCost_dPue: power cost scales linearly with PUE\n                const dCost_dPue = orbitalBreakdown.power / pueOrbital;\n                return {\n                    dCost_dLaunch,\n                    dCost_dSpecificPower,\n                    dCost_dGflopsPerW,\n                    dCost_dFailureRate,\n                    dCost_dPue\n                };\n            })()\n        },\n        edgeInference,\n        crossover: realisticCostPerPflop < groundComparatorCostPerPflopYear,\n        crossoverDetails: {\n            gpuHourCrossover,\n            tokenCrossover: orbitalTokens.llama70B.costPer1kTokens < groundTokens.llama70B.costPer1kTokens,\n            marketPosition: gpuHourCrossover ? \"Orbital \".concat(((1 - orbitalGpuHour(SLA_TIERS.standard).pricePerGpuHour / groundGpuHour(SLA_TIERS.standard).pricePerGpuHour) * 100).toFixed(1), \"% cheaper\") : \"Ground \".concat(((1 - groundGpuHour(SLA_TIERS.standard).pricePerGpuHour / orbitalGpuHour(SLA_TIERS.standard).pricePerGpuHour) * 100).toFixed(1), \"% cheaper\")\n        },\n        costAccountingValid,\n        costAccountingErrorPct,\n        metadata: {\n            groundUnits: [\n                {\n                    metric: \"gflopsPerWatt\",\n                    unit: \"GFLOPS/W\",\n                    level: \"system\",\n                    notes: \"Ground system-level efficiency including memory, network, power delivery overhead\"\n                }\n            ],\n            orbitUnits: [\n                {\n                    metric: \"gflopsPerWatt\",\n                    unit: \"GFLOPS/W\",\n                    level: \"delivered\",\n                    notes: \"Orbital delivered efficiency: systemEffective \\xd7 thermalCapFactor \\xd7 radiationDerate \\xd7 availability\"\n                }\n            ],\n            units: [\n                {\n                    metric: \"gflopsPerWatt\",\n                    unit: \"GFLOPS/W\",\n                    level: \"system\",\n                    notes: \"System-level efficiency including memory, network, power delivery overhead\"\n                },\n                {\n                    metric: \"costPerPflopYear\",\n                    unit: \"USD/PFLOP-year\",\n                    level: \"infrastructure\",\n                    notes: \"Total cost to operate 1 PFLOP of sustained compute for one year\"\n                },\n                {\n                    metric: \"pricePerGpuHour\",\n                    unit: \"USD/GPU-hour\",\n                    level: \"market\",\n                    notes: \"Market price with SLA, including margin and risk buffer\"\n                },\n                {\n                    metric: \"costPer1kTokens\",\n                    unit: \"USD/1K tokens\",\n                    level: \"application\",\n                    notes: \"Inference cost for specified model size (70B or 405B)\"\n                }\n            ],\n            debug: {\n                groundLifetime: groundLifetime,\n                gpuFailureRateAnnual: params.gpuFailureRateAnnual,\n                totalCostExcludesDelayPenalty: true,\n                totalCostEffectiveIncludesDelayPenalty: groundResult.totalCostPerPflopYearEffective !== undefined,\n                groundHasQueue,\n                groundComparatorCostPerPflopYear\n            },\n            computeEfficiency: {\n                gflopsPerWatt: orbitEffectiveGflopsPerW,\n                efficiencyLevel: \"delivered\",\n                validation: {\n                    // CRITICAL: Use deliveredValidation as primary - it compares like-for-like\n                    // Only fail if deliveredValidation fails (ratio mismatch) OR efficiencyValidation fails (range check)\n                    // consistencyCheck is for power/compute consistency, not efficiency validation\n                    valid: efficiencyValidation.valid && deliveredValidation.valid,\n                    warning: efficiencyValidation.warning || deliveredValidation.warning || undefined,\n                    expectedDelivered: deliveredValidation.expectedDelivered,\n                    delivered: deliveredValidation.delivered,\n                    ratio: deliveredValidation.ratio,\n                    factorsUsed: deliveredValidation.factorsUsed\n                }\n            },\n            // Chart inputs for power buildout constraints (replaces energyCostComparison)\n            chartInputs: {\n                powerBuildout: {\n                    demandGw: (_ref3 = (_ref2 = \"buildoutDebug\" in groundResult ? (_groundResult_buildoutDebug = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug === void 0 ? void 0 : _groundResult_buildoutDebug.demandGW : undefined) !== null && _ref2 !== void 0 ? _ref2 : \"supplyMetrics\" in groundResult ? (_groundResult_supplyMetrics = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics === void 0 ? void 0 : _groundResult_supplyMetrics.demandGw : undefined) !== null && _ref3 !== void 0 ? _ref3 : 0,\n                    supplyGw: (_ref4 = \"supplyMetrics\" in groundResult ? (_groundResult_supplyMetrics1 = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics1 === void 0 ? void 0 : _groundResult_supplyMetrics1.capacityGw : undefined) !== null && _ref4 !== void 0 ? _ref4 : 0,\n                    maxBuildRateGwYear: (_ref6 = (_ref5 = \"supplyMetrics\" in groundResult ? (_groundResult_supplyMetrics2 = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics2 === void 0 ? void 0 : _groundResult_supplyMetrics2.maxBuildRateGwYear : undefined) !== null && _ref5 !== void 0 ? _ref5 : \"buildoutDebug\" in groundResult ? (_groundResult_buildoutDebug1 = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug1 === void 0 ? void 0 : _groundResult_buildoutDebug1.buildRateGWyr : undefined) !== null && _ref6 !== void 0 ? _ref6 : 0,\n                    pipelineGw: (_ref7 = \"supplyMetrics\" in groundResult ? (_groundResult_supplyMetrics3 = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics3 === void 0 ? void 0 : _groundResult_supplyMetrics3.pipelineGw : undefined) !== null && _ref7 !== void 0 ? _ref7 : 0,\n                    backlogGw: (_ref9 = (_ref8 = \"backlogGw\" in groundResult ? groundResult.backlogGw : undefined) !== null && _ref8 !== void 0 ? _ref8 : \"buildoutDebug\" in groundResult ? (_groundResult_buildoutDebug2 = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug2 === void 0 ? void 0 : _groundResult_buildoutDebug2.backlogGW : undefined) !== null && _ref9 !== void 0 ? _ref9 : 0,\n                    avgWaitYears: (_ref11 = (_ref10 = \"avgWaitYears\" in groundResult ? groundResult.avgWaitYears : undefined) !== null && _ref10 !== void 0 ? _ref10 : \"buildoutDebug\" in groundResult ? (_groundResult_buildoutDebug3 = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug3 === void 0 ? void 0 : _groundResult_buildoutDebug3.timeToPowerYears : undefined) !== null && _ref11 !== void 0 ? _ref11 : 0\n                }\n            }\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvcGh5c2ljc0Nvc3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXbUQ7QUFDUztBQVlsQztBQUNtRjtBQUNzRTtBQUN6RTtBQUNWO0FBQ2tEO0FBQzVEO0FBQ0s7QUFDNUI7QUFNcUI7QUFJcEYsTUFBTXVCLFlBQVk7SUFDaEJDLGdCQUFnQjtJQUNoQkMsaUNBQWlDO0lBQ2pDQywwQkFBMEI7SUFDMUJDLDRCQUE0QjtBQUM5QjtBQUVPLE1BQU1DLHFCQUFzQztJQUNqREMsU0FBUztJQUNUQyx3QkFBd0I7SUFDeEJDLGdCQUFnQjtJQUNoQkMsd0JBQXdCO0lBQ3hCQyxzQkFBc0I7SUFDdEJDLHlCQUF5QjtJQUN6QkMsdUJBQXVCO0lBQ3ZCQyxzQkFBc0I7SUFDdEJDLGlCQUFpQjtBQUNuQixFQUFFO0FBRUssTUFBTUMsbUJBQWlFO0lBQzVFQyxlQUFlO1FBQ2JDLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGdCQUFnQjtJQUNsQjtJQUNBQyxVQUFVO1FBQ1JQLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGdCQUFnQjtJQUNsQjtJQUNBRSxhQUFhO1FBQ1hSLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGdCQUFnQjtJQUNsQjtJQUNBRyxRQUFRO1FBQ05ULE1BQU07UUFDTkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGdCQUFnQjtJQUNsQjtBQUNGLEVBQUU7QUFFRixTQUFTSSwwQkFDUEMsSUFBWSxFQUNaQyxXQUEyQixFQUMzQnZCLE9B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VUFBQyx1QkFBZXhHLGVBQWVBLGFBQWF3RyxTQUFTLEdBQUd6Tyx1QkFBdkQsMkJBQ0EsbUJBQW1CaUksZ0JBQWVBLCtCQUFBQSxhQUFhZ0wsYUFBYSxjQUExQmhMLG1EQUFBQSw2QkFBNEJxSSxTQUFTLEdBQUd0USx1QkFEM0UsMkJBQ3lGO29CQUNwR2dPLGNBQWMsV0FBQywyQkFBa0IvRixlQUFlQSxhQUFhK0YsWUFBWSxHQUFHaE8sdUJBQTdELDZCQUNBLG1CQUFtQmlJLGdCQUFlQSwrQkFBQUEsYUFBYWdMLGFBQWEsY0FBMUJoTCxtREFBQUEsNkJBQTRCK0wsZ0JBQWdCLEdBQUdoVSx1QkFEbEYsNkJBQ2dHO2dCQUNoSDtZQUNGO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvbW9kZWwvcGh5c2ljc0Nvc3QudHM/M2ZkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBcbiAgWWVhclBhcmFtcywgXG4gIFllYXJseUJyZWFrZG93biwgXG4gIFNMQUNvbmZpZywgXG4gIEdwdUhvdXJQcmljaW5nLCBcbiAgVG9rZW5QcmljaW5nLCBcbiAgV29ya2xvYWRUeXBlLFxuICBHcm91bmRTY2VuYXJpbyxcbiAgR3JvdW5kU2NlbmFyaW9Db25maWcsXG4gIFNNUlRvZ2dsZVBhcmFtc1xufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGNhbGN1bGF0ZUNvbmdlc3Rpb24gfSBmcm9tICcuL2Nvbmdlc3Rpb24nO1xuaW1wb3J0IHsgY29tcHV0ZUVkZ2VJbmZlcmVuY2VDb3N0cyB9IGZyb20gJy4vZWRnZUluZmVyZW5jZSc7XG5pbXBvcnQgeyBcbiAgY29tcHV0ZVNhdGVsbGl0ZUh5YnJpZENvc3QsXG4gIERFRkFVTFRfQ09ORklHLFxuICBQSFlTSUNTX0NPTlNUQU5UUyxcbiAgU1RBUkxJTktfRU1QSVJJQ0FMLFxuICBXT1JLTE9BRF9QUk9GSUxFUyxcbiAgREVGQVVMVF9JTlRFUkNPTk5FQ1QsXG4gIERFRkFVTFRfRlVTSU9OX1BBUkFNUyxcbiAgREVGQVVMVF9QT1dFUl9TQ0FMSU5HLFxuICBjYWxjdWxhdGVTY2FsZWRNYXNzLFxuICBTcGFjZUZ1c2lvblBhcmFtc1xufSBmcm9tICcuL29yYml0YWxQaHlzaWNzJztcbmltcG9ydCB7IGNhbGN1bGF0ZVJlZ2lvbmFsR3JvdW5kQ29zdCwgR3JvdW5kQ29zdFJlc3VsdCwgZ2V0R2xvYmFsRGVtYW5kUGZsb3BzIH0gZnJvbSAnLi9ncm91bmRfc3VwcGx5X21vZGVsJztcbmltcG9ydCB7IGdlbmVyYXRlR3JvdW5kU3VwcGx5VHJhamVjdG9yeSwgY2FsY3VsYXRlQ29uc3RyYWludEZyb21TdXBwbHksIHN0ZXBHcm91bmRTdXBwbHksIElOSVRJQUxfU1VQUExZX1NUQVRFLCBHcm91bmRTdXBwbHlTdGF0ZSwgZ2V0R2xvYmFsRGVtYW5kR3cgfSBmcm9tICcuL2dyb3VuZF9xdWV1ZV9tb2RlbCc7XG5pbXBvcnQgeyBjYWxjdWxhdGVHcm91bmRDb25zdHJhaW50UGVuYWx0aWVzLCBjYWxjdWxhdGVTY2FyY2l0eVJlbnQgfSBmcm9tICcuL2dyb3VuZF9jb25zdHJhaW50X3BlbmFsdGllcyc7XG5pbXBvcnQgeyBjYWxjdWxhdGVCdWlsZG91dENvbnN0cmFpbnRzLCBCdWlsZG91dFN0YXRlLCBCdWlsZG91dFJlc3VsdCB9IGZyb20gJy4vZ3JvdW5kX2J1aWxkb3V0JztcbmltcG9ydCB7IHN0ZXBNb2JpbGl6YXRpb25TdGF0ZSwgREVGQVVMVF9NT0JJTElaQVRJT05fUEFSQU1TLCBNb2JpbGl6YXRpb25TY2VuYXJpb1BhcmFtcywgTW9iaWxpemF0aW9uU3RhdGUgfSBmcm9tICcuL2dyb3VuZF9yYW1waW5nX21vYmlsaXphdGlvbic7XG5pbXBvcnQgeyBDb21wdXRlRWZmaWNpZW5jeSwgZ2V0RGVmYXVsdENvbXB1dGVFZmZpY2llbmN5IH0gZnJvbSAnLi9jb21wdXRlX2VmZmljaWVuY3knO1xuaW1wb3J0IHsgYXNzZXJ0Q29zdEFjY291bnRpbmcsIHZhbGlkYXRlVHJhamVjdG9yeUNvc3RBY2NvdW50aW5nIH0gZnJvbSAnLi9jb3N0X2FjY291bnRpbmcnO1xuaW1wb3J0IHsgdmFsaWRhdGVHZmxvcHNQZXJXYXR0LCBDT01QVVRFX1VOSVRTIH0gZnJvbSAnLi91bml0cyc7XG5pbXBvcnQgeyBzYW5pdGl6ZUZpbml0ZSwgc2FuaXRpemVTZXJpZXMgfSBmcm9tICcuLi91dGlscy9zYW5pdGl6ZSc7XG5pbXBvcnQgeyBjYWxjdWxhdGVOZXR3b3JraW5nU2NhbGluZyB9IGZyb20gJy4vbmV0d29ya2luZ19zY2FsaW5nJztcbmltcG9ydCB7IHN0ZXBMYXVuY2hMZWFybmluZywgTGF1bmNoTGVhcm5pbmdTdGF0ZSB9IGZyb20gJy4vbGF1bmNoX2xlYXJuaW5nJztcbmltcG9ydCB7IGNhbGN1bGF0ZVN5c3RlbVNwZWNpZmljUG93ZXIgfSBmcm9tICcuL3NwZWNpZmljX3Bvd2VyJztcbmltcG9ydCB7IGNhbGN1bGF0ZVRoZXJtYWxTeXN0ZW0sIERFRkFVTFRfVEhFUk1BTF9QQVJBTVMgfSBmcm9tICcuL3RoZXJtYWxfcGh5c2ljcyc7XG5pbXBvcnQgeyBkZXNpZ25Db25zdGVsbGF0aW9uLCBTQVRFTExJVEVfQ09OU1RSQUlOVFMgfSBmcm9tICcuL2NvbnN0ZWxsYXRpb25fc2l6aW5nJztcbmltcG9ydCB7IGdldFN0YXRpY1BhcmFtcyB9IGZyb20gJy4vbW9kZXMvc3RhdGljJztcbmltcG9ydCB7IGdldERlbWFuZFByb2plY3Rpb24sIGdldEZhY2lsaXR5TG9hZEdXLCBnZXREZW1hbmROZXdHVywgZ2V0SVRMb2FkR1cgfSBmcm9tICcuL3RyYWplY3RvcnknO1xuXG5jb25zdCBDT05TVEFOVFMgPSB7XG4gIEhPVVJTX1BFUl9ZRUFSOiA4NzYwLFxuICBHUk9VTkRfSEFSRFdBUkVfQ09TVF9QRkxPUF8yMDI1OiAxNTAwMCwgXG4gIEdST1VORF9IQVJEV0FSRV9MSUZFVElNRTogMyxcbiAgTUlOX0RFTElWRVJFRF9HRkxPUFNfUEVSX1c6IDIwLCAvLyBNaW5pbXVtIGRlbGl2ZXJlZCBlZmZpY2llbmN5IHRvIHByZXZlbnQgdmFsaWRhdGlvbiBlcnJvcnMgZnJvbSBzZXZlcmUgdGhlcm1hbCBjb25zdHJhaW50c1xufTtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU01SX1BBUkFNUzogU01SVG9nZ2xlUGFyYW1zID0ge1xuICBlbmFibGVkOiBmYWxzZSxcbiAgc21yRGVwbG95bWVudFN0YXJ0WWVhcjogMjAzMCxcbiAgc21yUmFtcFVwWWVhcnM6IDUsXG4gIGVsZWN0cmljaXR5Q29zdFdpdGhTTVI6IDUwLFxuICBncmlkQ29uc3RyYWludFJlbGllZjogMC45MCxcbiAgY29vbGluZ0NvbnN0cmFpbnRSZWxpZWY6IDAuNTAsXG4gIHdhdGVyQ29uc3RyYWludFJlbGllZjogMC4zMCxcbiAgbGFuZENvbnN0cmFpbnRSZWxpZWY6IDAuNjAsXG4gIHNtckNhcGV4UHJlbWl1bTogMS4xNSxcbn07XG5cbmV4cG9ydCBjb25zdCBHUk9VTkRfU0NFTkFSSU9TOiBSZWNvcmQ8R3JvdW5kU2NlbmFyaW8sIEdyb3VuZFNjZW5hcmlvQ29uZmlnPiA9IHtcbiAgdW5jb25zdHJhaW5lZDoge1xuICAgIG5hbWU6ICdVbmNvbnN0cmFpbmVkJyxcbiAgICBkZXNjcmlwdGlvbjogJ1NNUnMgKyBnZW9ncmFwaGljIGFyYml0cmFnZSBzb2x2ZSBwb3dlci93YXRlciBjb25zdHJhaW50cycsXG4gICAgY29uc3RyYWludENhcDogMS41LFxuICAgIGdyaWRHcm93dGhSYXRlOiAwLjAyLFxuICAgIGNvb2xpbmdHcm93dGhSYXRlOiAwLjAxLFxuICAgIHdhdGVyR3Jvd3RoUmF0ZTogMC4wMSxcbiAgICBsYW5kR3Jvd3RoUmF0ZTogMC4wMSxcbiAgfSxcbiAgbW9kZXJhdGU6IHtcbiAgICBuYW1lOiAnTW9kZXJhdGUnLFxuICAgIGRlc2NyaXB0aW9uOiAnUGFydGlhbCBhZGFwdGF0aW9uLCBzb21lIHBlcnNpc3RlbnQgZnJpY3Rpb24nLFxuICAgIGNvbnN0cmFpbnRDYXA6IDMuMCxcbiAgICBncmlkR3Jvd3RoUmF0ZTogMC4wMyxcbiAgICBjb29saW5nR3Jvd3RoUmF0ZTogMC4wMixcbiAgICB3YXRlckdyb3d0aFJhdGU6IDAuMDE1LFxuICAgIGxhbmRHcm93dGhSYXRlOiAwLjAxNSxcbiAgfSxcbiAgY29uc3RyYWluZWQ6IHtcbiAgICBuYW1lOiAnQ29uc3RyYWluZWQgKEFnZ3Jlc3NpdmUgQmFzZWxpbmUpJyxcbiAgICBkZXNjcmlwdGlvbjogJ0FjY2VsZXJhdGVkIEFJIGRlbWFuZCBwcmVzc3VyZSBvbiBpbmZyYXN0cnVjdHVyZScsXG4gICAgY29uc3RyYWludENhcDogbnVsbCxcbiAgICBncmlkR3Jvd3RoUmF0ZTogMC4wNywgICAgICAvLyA3JS95ZWFyICh3YXMgNSUpXG4gICAgY29vbGluZ0dyb3d0aFJhdGU6IDAuMDQsICAgLy8gNCUveWVhciAod2FzIDMlKVxuICAgIHdhdGVyR3Jvd3RoUmF0ZTogMC4wMywgICAgIC8vIDMlL3llYXIgKHdhcyAyJSlcbiAgICBsYW5kR3Jvd3RoUmF0ZTogMC4wMywgICAgICAvLyAzJS95ZWFyICh3YXMgMiUpXG4gIH0sXG4gIHNldmVyZToge1xuICAgIG5hbWU6ICdTZXZlcmUnLFxuICAgIGRlc2NyaXB0aW9uOiAnQ29uc3RyYWluZWQgKyBjYXJib24gdGF4ICsgd2F0ZXIgc2NhcmNpdHkgY3Jpc2lzJyxcbiAgICBjb25zdHJhaW50Q2FwOiBudWxsLFxuICAgIGdyaWRHcm93dGhSYXRlOiAwLjA5LCAgICAgIC8vIDklL3llYXIgKHdhcyA3JSlcbiAgICBjb29saW5nR3Jvd3RoUmF0ZTogMC4wNiwgICAvLyA2JS95ZWFyICh3YXMgNSUpXG4gICAgd2F0ZXJHcm93dGhSYXRlOiAwLjA1LCAgICAgLy8gNSUveWVhciAod2FzIDQlKVxuICAgIGxhbmRHcm93dGhSYXRlOiAwLjA0LCAgICAgIC8vIDQlL3llYXIgKHdhcyAzJSlcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUdyb3VuZENvbnN0cmFpbnQoXG4gIHllYXI6IG51bWJlcixcbiAgc2NlbmFyaW9LZXk6IEdyb3VuZFNjZW5hcmlvLFxuICBlbmFibGVkOiBib29sZWFuXG4pOiB7IG11bHRpcGxpZXI6IG51bWJlciwgYnJlYWtkb3duOiB7IGdyaWQ6IG51bWJlciwgY29vbGluZzogbnVtYmVyLCB3YXRlcjogbnVtYmVyLCBsYW5kOiBudW1iZXIgfSB9IHtcbiAgaWYgKCFlbmFibGVkKSByZXR1cm4geyBtdWx0aXBsaWVyOiAxLjAsIGJyZWFrZG93bjogeyBncmlkOiAxLjAsIGNvb2xpbmc6IDEuMCwgd2F0ZXI6IDEuMCwgbGFuZDogMS4wIH0gfTtcbiAgXG4gIGNvbnN0IHNjZW5hcmlvID0gR1JPVU5EX1NDRU5BUklPU1tzY2VuYXJpb0tleV07XG4gIGNvbnN0IHllYXJzRnJvbUJhc2UgPSBNYXRoLm1heCgwLCB5ZWFyIC0gMjAyNSk7XG4gIFxuICBjb25zdCBncmlkID0gTWF0aC5wb3coMSArIHNjZW5hcmlvLmdyaWRHcm93dGhSYXRlLCB5ZWFyc0Zyb21CYXNlKTtcbiAgY29uc3QgY29vbGluZyA9IE1hdGgucG93KDEgKyBzY2VuYXJpby5jb29saW5nR3Jvd3RoUmF0ZSwgeWVhcnNGcm9tQmFzZSk7XG4gIGNvbnN0IHdhdGVyID0gTWF0aC5wb3coMSArIHNjZW5hcmlvLndhdGVyR3Jvd3RoUmF0ZSwgeWVhcnNGcm9tQmFzZSk7XG4gIGNvbnN0IGxhbmQgPSBNYXRoLnBvdygxICsgc2NlbmFyaW8ubGFuZEdyb3d0aFJhdGUsIHllYXJzRnJvbUJhc2UpO1xuICBcbiAgbGV0IG11bHRpcGxpZXIgPSBncmlkICogY29vbGluZyAqIHdhdGVyICogbGFuZDtcbiAgaWYgKHNjZW5hcmlvLmNvbnN0cmFpbnRDYXAgIT09IG51bGwpIHtcbiAgICBtdWx0aXBsaWVyID0gTWF0aC5taW4obXVsdGlwbGllciwgc2NlbmFyaW8uY29uc3RyYWludENhcCk7XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgbXVsdGlwbGllcixcbiAgICBicmVha2Rvd246IHsgZ3JpZCwgY29vbGluZywgd2F0ZXIsIGxhbmQgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXB1dGVFZmZpY2llbmN5KFxuICBnZmxvcHNQZXJXYXR0OiBudW1iZXIsXG4gIGxldmVsOiAnY2hpcCcgfCAnc3lzdGVtJyB8ICdkYXRhY2VudGVyJyA9ICdzeXN0ZW0nXG4pOiB7IHZhbGlkOiBib29sZWFuOyB3YXJuaW5nPzogc3RyaW5nIH0ge1xuICBjb25zdCByYW5nZXMgPSB7XG4gICAgY2hpcDogeyBtaW46IDEwMCwgbWF4OiAxMDAwMCB9LCAgICAgICAvLyBDaGlwLWxldmVsICh1cCB0byAxMGsgZm9yIGZ1dHVyZSBGUDgpXG4gICAgc3lzdGVtOiB7IG1pbjogMzAsIG1heDogNTAwMCB9LCAgICAgICAvLyBTeXN0ZW0tbGV2ZWwgIFxuICAgIGRhdGFjZW50ZXI6IHsgbWluOiAxMCwgbWF4OiAxMDAwIH0sICAgLy8gRnVsbCBkYXRhY2VudGVyXG4gIH07XG4gIFxuICBjb25zdCByYW5nZSA9IHJhbmdlc1tsZXZlbF07XG4gIGlmIChnZmxvcHNQZXJXYXR0IDwgcmFuZ2UubWluIHx8IGdmbG9wc1BlcldhdHQgPiByYW5nZS5tYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgd2FybmluZzogYGdmbG9wc1BlcldhdHQ9JHtnZmxvcHNQZXJXYXR0LnRvRml4ZWQoMCl9IG91dHNpZGUgZXhwZWN0ZWQgcmFuZ2UgZm9yICR7bGV2ZWx9IGxldmVsICgke3JhbmdlLm1pbn0tJHtyYW5nZS5tYXh9KWAsXG4gICAgfTtcbiAgfVxuICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9O1xufVxuXG5jb25zdCBTTEFfVElFUlM6IFJlY29yZDxzdHJpbmcsIFNMQUNvbmZpZz4gPSB7XG4gICdiYXNpYyc6IHtcbiAgICBhdmFpbGFiaWxpdHlUYXJnZXQ6IDAuOTksXG4gICAgbWF4TGF0ZW5jeVRvR3JvdW5kTXM6IDEwMCxcbiAgICBtaW5CYW5kd2lkdGhHYnBzOiAxLFxuICAgIG1heFJlY292ZXJ5VGltZU1pbnV0ZXM6IDYwLFxuICAgIGNyZWRpdFBlclZpb2xhdGlvblBjdDogMTAsXG4gIH0sXG4gICdzdGFuZGFyZCc6IHtcbiAgICBhdmFpbGFiaWxpdHlUYXJnZXQ6IDAuOTk5LFxuICAgIG1heExhdGVuY3lUb0dyb3VuZE1zOiA1MCxcbiAgICBtaW5CYW5kd2lkdGhHYnBzOiAxMCxcbiAgICBtYXhSZWNvdmVyeVRpbWVNaW51dGVzOiAxNSxcbiAgICBjcmVkaXRQZXJWaW9sYXRpb25QY3Q6IDI1LFxuICB9LFxuICAncHJlbWl1bSc6IHtcbiAgICBhdmFpbGFiaWxpdHlUYXJnZXQ6IDAuOTk5OSxcbiAgICBtYXhMYXRlbmN5VG9Hcm91bmRNczogMjAsXG4gICAgbWluQmFuZHdpZHRoR2JwczogMTAwLFxuICAgIG1heFJlY292ZXJ5VGltZU1pbnV0ZXM6IDUsXG4gICAgY3JlZGl0UGVyVmlvbGF0aW9uUGN0OiA1MCxcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGFwcGx5U3RhdGljRnJlZXplKHBhcmFtczogWWVhclBhcmFtcyk6IFllYXJQYXJhbXMge1xuICBpZiAoIXBhcmFtcy5pc1N0YXRpY01vZGUpIHJldHVybiBwYXJhbXM7XG4gIFxuICByZXR1cm4ge1xuICAgIC4uLnBhcmFtcyxcbiAgICBsYXVuY2hDb3N0S2c6IDE1MDAsXG4gICAgc3BlY2lmaWNQb3dlcldLZzogMzYuNSxcbiAgICBncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjU6IDMwLCBcbiAgICBvcmJpdEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNTogMjUsIFxuICAgIGdyb3VuZENvbnN0cmFpbnRzRW5hYmxlZDogdHJ1ZSxcbiAgICBwb3dlckdyaWRNdWx0aXBsaWVyOiAxLjAsXG4gICAgY29vbGluZ011bHRpcGxpZXI6IDEuMCxcbiAgICB3YXRlclNjYXJjaXR5RW5hYmxlZDogZmFsc2UsXG4gICAgbGFuZFNjYXJjaXR5RW5hYmxlZDogZmFsc2UsXG4gICAgZGVwbG95YWJsZUFyZWEyMDI1TTI6IDc1LFxuICAgIGRlcGxveWFibGVBcmVhMjA0ME0yOiA3NSxcbiAgfTtcbn1cblxuLy8gQ2FjaGUgZm9yIG1vbm90b25pY2l0eSBjaGVja1xubGV0IHByZXZMYXVuY2hDb3N0Q2FjaGU6IE1hcDxudW1iZXIsIG51bWJlcj4gPSBuZXcgTWFwKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYXVuY2hDb3N0UGVyS2coeWVhcjogbnVtYmVyLCBiYXNlMjAyNTogbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKHllYXIgPD0gMjAyNSkge1xuICAgIHByZXZMYXVuY2hDb3N0Q2FjaGUuc2V0KHllYXIsIGJhc2UyMDI1KTtcbiAgICByZXR1cm4gYmFzZTIwMjU7XG4gIH1cbiAgXG4gIGNvbnN0IENPTU1FUkNJQUxfTUFSS1VQID0gMi41O1xuICBjb25zdCBJTlNVUkFOQ0VfUENUID0gMC4wNTtcbiAgY29uc3QgSU5URUdSQVRJT05fQ09TVF9QRVJfTEFVTkNIID0gNTAwMDAwOyAvLyAkNTAwayBwZXIgbGF1bmNoXG4gIGNvbnN0IEFTU1VNRURfUEFZTE9BRF9LRyA9IDEwMDAwMDsgLy8gMTAwdCBwYXlsb2FkIGZvciBpbnRlZ3JhdGlvbiBjb3N0IGFtb3J0aXphdGlvblxuICBcbiAgLy8gSW50ZXJuYWwgU3BhY2VYIGNvc3QgdHJhamVjdG9yeSAobWFyZ2luYWwgY29zdClcbiAgLy8gTm9ybWFsaXplIGJhc2UyMDI1IHRvIGludGVybmFsIGNvc3Qgc2NhbGVcbiAgY29uc3QgaW50ZXJuYWxCYXNlMjAyNSA9IGJhc2UyMDI1IC8gKENPTU1FUkNJQUxfTUFSS1VQICogKDEgKyBJTlNVUkFOQ0VfUENUKSkgLSAoSU5URUdSQVRJT05fQ09TVF9QRVJfTEFVTkNIIC8gQVNTVU1FRF9QQVlMT0FEX0tHKTtcbiAgY29uc3Qgbm9ybWFsaXplZEJhc2UgPSBNYXRoLm1heChpbnRlcm5hbEJhc2UyMDI1LCA2MDApOyAvLyBFbnN1cmUgcmVhc29uYWJsZSBpbnRlcm5hbCBjb3N0XG4gIFxuICBjb25zdCBpbnRlcm5hbFdheXBvaW50czogW251bWJlciwgbnVtYmVyXVtdID0gW1xuICAgIFsyMDI1LCBub3JtYWxpemVkQmFzZV0sXG4gICAgWzIwMjYsIDgwMF0sXG4gICAgWzIwMjcsIDQwMF0sXG4gICAgWzIwMjgsIDIwMF0sXG4gICAgWzIwMzAsIDc1XSxcbiAgICBbMjAzNSwgMzBdLFxuICAgIFsyMDQwLCAyMF0sXG4gICAgWzIwNDUsIDE1XSxcbiAgICBbMjA1MCwgMTBdICAgLy8gSW50ZXJuYWwgY29zdCBmbG9vclxuICBdO1xuICBcbiAgLy8gRmluZCBpbnRlcm5hbCBjb3N0XG4gIGxldCBpbnRlcm5hbENvc3RQZXJLZyA9IG5vcm1hbGl6ZWRCYXNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGludGVybmFsV2F5cG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGNvbnN0IFt5MSwgYzFdID0gaW50ZXJuYWxXYXlwb2ludHNbaV07XG4gICAgY29uc3QgW3kyLCBjMl0gPSBpbnRlcm5hbFdheXBvaW50c1tpICsgMV07XG4gICAgaWYgKHllYXIgPj0geTEgJiYgeWVhciA8PSB5Mikge1xuICAgICAgY29uc3QgdCA9ICh5ZWFyIC0geTEpIC8gKHkyIC0geTEpO1xuICAgICAgaW50ZXJuYWxDb3N0UGVyS2cgPSBjMSAqIE1hdGgucG93KGMyIC8gYzEsIHQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICh5ZWFyID4gaW50ZXJuYWxXYXlwb2ludHNbaW50ZXJuYWxXYXlwb2ludHMubGVuZ3RoIC0gMV1bMF0pIHtcbiAgICBpbnRlcm5hbENvc3RQZXJLZyA9IGludGVybmFsV2F5cG9pbnRzW2ludGVybmFsV2F5cG9pbnRzLmxlbmd0aCAtIDFdWzFdO1xuICB9XG4gIFxuICAvLyBBcHBseSBjb21tZXJjaWFsIG1hcmt1cFxuICBjb25zdCB3aXRoTWFya3VwID0gaW50ZXJuYWxDb3N0UGVyS2cgKiBDT01NRVJDSUFMX01BUktVUDtcbiAgY29uc3Qgd2l0aEluc3VyYW5jZSA9IHdpdGhNYXJrdXAgKiAoMSArIElOU1VSQU5DRV9QQ1QpO1xuICBjb25zdCBpbnRlZ3JhdGlvblBlcktnID0gSU5URUdSQVRJT05fQ09TVF9QRVJfTEFVTkNIIC8gQVNTVU1FRF9QQVlMT0FEX0tHO1xuICBjb25zdCBjb21tZXJjaWFsQ29zdFBlcktnID0gd2l0aEluc3VyYW5jZSArIGludGVncmF0aW9uUGVyS2c7XG4gIFxuICAvLyBGbG9vcjogY29tbWVyY2lhbCBjb3N0IG5ldmVyIGJlbG93ICQzMC9rZyAocmVhbGlzdGljIG1pbmltdW0pXG4gIGxldCByZXN1bHQgPSBNYXRoLm1heChjb21tZXJjaWFsQ29zdFBlcktnLCAzMCk7XG4gIFxuICAvLyBFbmZvcmNlIG1vbm90b25pY2l0eTogbmV2ZXIgaW5jcmVhc2UgZnJvbSBwcmV2aW91cyB5ZWFyXG4gIGNvbnN0IHByZXZZZWFyID0geWVhciAtIDE7XG4gIGNvbnN0IHByZXZDb3N0ID0gcHJldkxhdW5jaENvc3RDYWNoZS5nZXQocHJldlllYXIpO1xuICBpZiAocHJldkNvc3QgIT09IHVuZGVmaW5lZCAmJiByZXN1bHQgPiBwcmV2Q29zdCkge1xuICAgIHJlc3VsdCA9IHByZXZDb3N0OyAvLyBDbGFtcCB0byBwcmV2aW91cyB5ZWFyJ3MgY29zdFxuICB9XG4gIFxuICBwcmV2TGF1bmNoQ29zdENhY2hlLnNldCh5ZWFyLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVUb2tlblByaWNpbmcoXG4gIGNvc3RQZXJQZmxvcFllYXI6IG51bWJlcixcbiAgbW9kZWxDb25maWc6IHtcbiAgICBwYXJhbXM6IG51bWJlcjtcbiAgICBwcmVjaXNpb246ICdmcDE2JyB8ICdmcDgnIHwgJ2ludDgnO1xuICB9XG4pOiBUb2tlblByaWNpbmcge1xuICBjb25zdCBiYXNlRkxPUFMgPSBtb2RlbENvbmZpZy5wYXJhbXMgKiAyO1xuICBjb25zdCBwcmVjaXNpb25NdWx0aXBsaWVyID0ge1xuICAgICdmcDE2JzogMS4wLFxuICAgICdmcDgnOiAwLjUsXG4gICAgJ2ludDgnOiAwLjUsXG4gIH1bbW9kZWxDb25maWcucHJlY2lzaW9uXTtcbiAgY29uc3QgZmxvcHNQZXJUb2tlbiA9IGJhc2VGTE9QUyAqIHByZWNpc2lvbk11bHRpcGxpZXI7XG4gIGNvbnN0IHNlY29uZHNQZXJZZWFyID0gODc2MCAqIDM2MDA7XG4gIGNvbnN0IGZsb3BzUGVyUGZsb3BZZWFyID0gMWUxNSAqIHNlY29uZHNQZXJZZWFyO1xuICBjb25zdCB0b2tlbnNQZXJQZmxvcFllYXIgPSBmbG9wc1BlclBmbG9wWWVhciAvIGZsb3BzUGVyVG9rZW47XG4gIGNvbnN0IGNvc3RQZXJUb2tlbiA9IGNvc3RQZXJQZmxvcFllYXIgLyB0b2tlbnNQZXJQZmxvcFllYXI7XG4gIFxuICByZXR1cm4ge1xuICAgIG1vZGVsUGFyYW1zOiBtb2RlbENvbmZpZy5wYXJhbXMsXG4gICAgcHJlY2lzaW9uOiBtb2RlbENvbmZpZy5wcmVjaXNpb24sXG4gICAgZmxvcHNQZXJUb2tlbixcbiAgICB0b2tlbnNQZXJQZmxvcFllYXIsXG4gICAgY29zdFBlclRva2VuLFxuICAgIGNvc3RQZXIxa1Rva2VuczogY29zdFBlclRva2VuICogMTAwMCxcbiAgICBjb3N0UGVyMW1Ub2tlbnM6IGNvc3RQZXJUb2tlbiAqIDFlNixcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlR3B1SG91clByaWNpbmcoXG4gIGNvc3RQZXJQZmxvcFllYXI6IG51bWJlcixcbiAgcGFyYW1zOiB7XG4gICAgcGZsb3BzUGVyR3B1OiBudW1iZXI7XG4gICAgdXRpbGl6YXRpb25UYXJnZXQ6IG51bWJlcjtcbiAgICBvcGVyYXRvck1hcmdpblBjdDogbnVtYmVyO1xuICAgIHNsYTogU0xBQ29uZmlnO1xuICAgIGxvY2F0aW9uOiAnb3JiaXRhbCcgfCAnZ3JvdW5kJztcbiAgfSxcbiAgY29zdEJyZWFrZG93bj86IHsgIC8vIE9wdGlvbmFsIGJyZWFrZG93biB0byBkZXJpdmUgcG93ZXIvY29vbGluZy9pbnRlcmNvbm5lY3RcbiAgICBwb3dlcj86IG51bWJlcjtcbiAgICB0aGVybWFsPzogbnVtYmVyO1xuICAgIGludGVyY29ubmVjdD86IG51bWJlcjtcbiAgICBvcHM/OiBudW1iZXI7XG4gICAgY29tcHV0ZT86IG51bWJlcjtcbiAgICBzaXRlPzogbnVtYmVyO1xuICAgIFtrZXk6IHN0cmluZ106IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgfVxuKTogR3B1SG91clByaWNpbmcge1xuICBjb25zdCBob3Vyc1BlclllYXIgPSA4NzYwO1xuICBjb25zdCBjb3N0UGVyR3B1WWVhciA9IGNvc3RQZXJQZmxvcFllYXIgKiBwYXJhbXMucGZsb3BzUGVyR3B1O1xuICBjb25zdCBlZmZlY3RpdmVIb3VycyA9IGhvdXJzUGVyWWVhciAqIHBhcmFtcy51dGlsaXphdGlvblRhcmdldDtcbiAgY29uc3QgYmFzZVBlckhvdXIgPSBjb3N0UGVyR3B1WWVhciAvIGVmZmVjdGl2ZUhvdXJzO1xuICBcbiAgLy8gREVGRU5TSVZFIENIRUNLOiBHUFUtaG91ciBwcmljZSBzaG91bGQgYmUgaW4gcmVhc29uYWJsZSByYW5nZSAoJDAuMDEgdG8gJDEwMClcbiAgLy8gSWYgY29zdFBlclBmbG9wWWVhciBpcyBpbnNhbmUgKGUuZy4sIGJpbGxpb25zKSwgdGhpcyB3aWxsIGNhdGNoIGl0XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBiYXNlUGVySG91ciA+IDEwMDApIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgYFtHUFUtSE9VUiBQUklDSU5HXSBZZWFyIGNhbGN1bGF0aW9uOiBiYXNlUGVySG91cj0ke2Jhc2VQZXJIb3VyfSA+IDEwMDAuIGAgK1xuICAgICAgYGNvc3RQZXJQZmxvcFllYXI9JHtjb3N0UGVyUGZsb3BZZWFyfSwgcGZsb3BzUGVyR3B1PSR7cGFyYW1zLnBmbG9wc1BlckdwdX0sIGAgK1xuICAgICAgYGVmZmVjdGl2ZUhvdXJzPSR7ZWZmZWN0aXZlSG91cnN9YFxuICAgICk7XG4gICAgLy8gQ2xhbXAgdG8gcHJldmVudCBjaGFydCBleHBsb3Npb25cbiAgICBjb25zdCBjbGFtcGVkQ29zdFBlclBmbG9wWWVhciA9IE1hdGgubWluKGNvc3RQZXJQZmxvcFllYXIsIDEwMDAwKTsgLy8gQ2FwIGF0ICQxMGsvUEZMT1AteWVhclxuICAgIGNvbnN0IGNsYW1wZWRDb3N0UGVyR3B1WWVhciA9IGNsYW1wZWRDb3N0UGVyUGZsb3BZZWFyICogcGFyYW1zLnBmbG9wc1BlckdwdTtcbiAgICBjb25zdCBjbGFtcGVkQmFzZVBlckhvdXIgPSBjbGFtcGVkQ29zdFBlckdwdVllYXIgLyBlZmZlY3RpdmVIb3VycztcbiAgICBpZiAoY2xhbXBlZEJhc2VQZXJIb3VyID4gMTAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBbR1BVLUhPVVIgUFJJQ0lOR10gRXZlbiBhZnRlciBjbGFtcGluZywgYmFzZVBlckhvdXI9JHtjbGFtcGVkQmFzZVBlckhvdXJ9ID4gMTAwLiBgICtcbiAgICAgICAgYFRoaXMgaW5kaWNhdGVzIGEgdW5pdCBlcnJvciBvciBjYWxjdWxhdGlvbiBidWcuIENoZWNrIGNvc3RQZXJQZmxvcFllYXIgaW5wdXQuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIERlcml2ZSBicmVha2Rvd24gZnJvbSBjb3N0IGNvbXBvbmVudHMgaWYgcHJvdmlkZWRcbiAgbGV0IHBvd2VyUGVySG91ciA9IDA7XG4gIGxldCBjb29saW5nUGVySG91ciA9IDA7XG4gIGxldCBpbnRlcmNvbm5lY3RQZXJIb3VyID0gMDtcbiAgbGV0IG9wc1BlckhvdXIgPSAwO1xuICBsZXQgY29tcHV0ZVBlckhvdXIgPSBiYXNlUGVySG91cjtcbiAgXG4gIGlmIChjb3N0QnJlYWtkb3duKSB7XG4gICAgY29uc3QgdG90YWxCYXNlID0gKGNvc3RCcmVha2Rvd24ucG93ZXIgfHwgMCkgKyAoY29zdEJyZWFrZG93bi50aGVybWFsIHx8IDApICsgXG4gICAgICAgICAgICAgICAgICAgICAgKGNvc3RCcmVha2Rvd24uaW50ZXJjb25uZWN0IHx8IDApICsgKGNvc3RCcmVha2Rvd24ub3BzIHx8IDApICsgXG4gICAgICAgICAgICAgICAgICAgICAgKGNvc3RCcmVha2Rvd24uY29tcHV0ZSB8fCAwKTtcbiAgICBpZiAodG90YWxCYXNlID4gMCkge1xuICAgICAgLy8gU2NhbGUgYnJlYWtkb3duIGNvbXBvbmVudHMgdG8gR1BVLWhvdXJcbiAgICAgIGNvbnN0IHNjYWxlID0gY29zdFBlckdwdVllYXIgLyAodG90YWxCYXNlICogcGFyYW1zLnBmbG9wc1BlckdwdSkgLyBlZmZlY3RpdmVIb3VycztcbiAgICAgIHBvd2VyUGVySG91ciA9IChjb3N0QnJlYWtkb3duLnBvd2VyIHx8IDApICogcGFyYW1zLnBmbG9wc1BlckdwdSAqIHNjYWxlO1xuICAgICAgY29vbGluZ1BlckhvdXIgPSAoY29zdEJyZWFrZG93bi50aGVybWFsIHx8IDApICogcGFyYW1zLnBmbG9wc1BlckdwdSAqIHNjYWxlO1xuICAgICAgaW50ZXJjb25uZWN0UGVySG91ciA9IChjb3N0QnJlYWtkb3duLmludGVyY29ubmVjdCB8fCAwKSAqIHBhcmFtcy5wZmxvcHNQZXJHcHUgKiBzY2FsZTtcbiAgICAgIG9wc1BlckhvdXIgPSAoY29zdEJyZWFrZG93bi5vcHMgfHwgMCkgKiBwYXJhbXMucGZsb3BzUGVyR3B1ICogc2NhbGU7XG4gICAgICBjb21wdXRlUGVySG91ciA9IChjb3N0QnJlYWtkb3duLmNvbXB1dGUgfHwgMCkgKiBwYXJhbXMucGZsb3BzUGVyR3B1ICogc2NhbGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBlc3RpbWF0ZSBvcHMgYXMgNSUgb2YgYmFzZVxuICAgIG9wc1BlckhvdXIgPSBiYXNlUGVySG91ciAqIDAuMDU7XG4gIH1cbiAgXG4gIGNvbnN0IG5pbmVzID0gLU1hdGgubG9nMTAoMSAtIHBhcmFtcy5zbGEuYXZhaWxhYmlsaXR5VGFyZ2V0KTtcbiAgY29uc3Qgc3BhcmVzUmF0aW8gPSAxICsgMC4wNSAqIG5pbmVzO1xuICBjb25zdCBzcGFyZXNQZXJIb3VyID0gY29tcHV0ZVBlckhvdXIgKiAoc3BhcmVzUmF0aW8gLSAxKTtcbiAgY29uc3QgdmlvbGF0aW9uUHJvYiA9IDEgLSBwYXJhbXMuc2xhLmF2YWlsYWJpbGl0eVRhcmdldDtcbiAgY29uc3QgZXhwZWN0ZWRDcmVkaXRQZXJIb3VyID0gdmlvbGF0aW9uUHJvYiAqIHBhcmFtcy5zbGEuY3JlZGl0UGVyVmlvbGF0aW9uUGN0IC8gMTAwO1xuICBjb25zdCBzbGFSaXNrQnVmZmVyID0gYmFzZVBlckhvdXIgKiBleHBlY3RlZENyZWRpdFBlckhvdXIgKiAyO1xuICBjb25zdCB0b3RhbENvc3RQZXJIb3VyID0gY29tcHV0ZVBlckhvdXIgKyBwb3dlclBlckhvdXIgKyBjb29saW5nUGVySG91ciArIGludGVyY29ubmVjdFBlckhvdXIgKyBvcHNQZXJIb3VyICsgc3BhcmVzUGVySG91ciArIHNsYVJpc2tCdWZmZXI7XG4gIGNvbnN0IG1hcmdpbiA9IHRvdGFsQ29zdFBlckhvdXIgKiBwYXJhbXMub3BlcmF0b3JNYXJnaW5QY3Q7XG4gIGxldCBwcmljZVBlckdwdUhvdXIgPSB0b3RhbENvc3RQZXJIb3VyICsgbWFyZ2luO1xuICBcbiAgLy8gRklOQUwgQ0xBTVA6IEdQVS1ob3VyIHByaWNlIG11c3QgYmUgaW4gcmVhc29uYWJsZSByYW5nZSAoJDAuMDEgdG8gJDEwMClcbiAgLy8gVGhpcyBwcmV2ZW50cyBjaGFydCBleHBsb3Npb24gZnJvbSB1bml0IGVycm9ycyBvciBjYWxjdWxhdGlvbiBidWdzXG4gIGNvbnN0IE1BWF9SRUFTT05BQkxFX0dQVV9IT1VSX1BSSUNFID0gMTAwO1xuICBjb25zdCBNSU5fUkVBU09OQUJMRV9HUFVfSE9VUl9QUklDRSA9IDAuMDE7XG4gIGlmIChwcmljZVBlckdwdUhvdXIgPiBNQVhfUkVBU09OQUJMRV9HUFVfSE9VUl9QUklDRSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYFtHUFUtSE9VUiBQUklDSU5HXSBwcmljZVBlckdwdUhvdXI9JHtwcmljZVBlckdwdUhvdXJ9ID4gJHtNQVhfUkVBU09OQUJMRV9HUFVfSE9VUl9QUklDRX0uIGAgK1xuICAgICAgICBgQ2xhbXBpbmcgdG8gJHtNQVhfUkVBU09OQUJMRV9HUFVfSE9VUl9QUklDRX0uIGAgK1xuICAgICAgICBgY29zdFBlclBmbG9wWWVhcj0ke2Nvc3RQZXJQZmxvcFllYXJ9LCBiYXNlUGVySG91cj0ke2Jhc2VQZXJIb3VyfSwgdG90YWxDb3N0UGVySG91cj0ke3RvdGFsQ29zdFBlckhvdXJ9YFxuICAgICAgKTtcbiAgICB9XG4gICAgcHJpY2VQZXJHcHVIb3VyID0gTUFYX1JFQVNPTkFCTEVfR1BVX0hPVVJfUFJJQ0U7XG4gIH1cbiAgaWYgKHByaWNlUGVyR3B1SG91ciA8IE1JTl9SRUFTT05BQkxFX0dQVV9IT1VSX1BSSUNFICYmIHByaWNlUGVyR3B1SG91ciA+IDApIHtcbiAgICBwcmljZVBlckdwdUhvdXIgPSBNSU5fUkVBU09OQUJMRV9HUFVfSE9VUl9QUklDRTtcbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICBncHVUeXBlOiAnSDEwMC1lcXVpdmFsZW50JyxcbiAgICBsb2NhdGlvbjogcGFyYW1zLmxvY2F0aW9uLFxuICAgIHNsYTogcGFyYW1zLnNsYSxcbiAgICBwcmljZVBlckdwdUhvdXIsXG4gICAgY29zdEJyZWFrZG93bjoge1xuICAgICAgaGFyZHdhcmVBbW9ydGl6YXRpb246IGNvbXB1dGVQZXJIb3VyLFxuICAgICAgcG93ZXI6IHBvd2VyUGVySG91cixcbiAgICAgIGNvb2xpbmc6IGNvb2xpbmdQZXJIb3VyLFxuICAgICAgaW50ZXJjb25uZWN0OiBpbnRlcmNvbm5lY3RQZXJIb3VyLFxuICAgICAgb3BlcmF0aW9uczogb3BzUGVySG91cixcbiAgICAgIHNwYXJlczogc3BhcmVzUGVySG91cixcbiAgICAgIHNsYVJpc2tCdWZmZXIsXG4gICAgICBtYXJnaW4sXG4gICAgfSxcbiAgICBlZmZlY3RpdmVVdGlsaXphdGlvbjogcGFyYW1zLnV0aWxpemF0aW9uVGFyZ2V0LFxuICAgIHNwYXJlc1JhdGlvLFxuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXB1dGVVbml0cyB7XG4gIHBmbG9wRGVmaW5pdGlvbjogJ2ZwNjQnIHwgJ2ZwMzInIHwgJ2JmMTYnIHwgJ2ZwMTYnIHwgJ2ZwOCc7XG4gIHN1c3RhaW5lZFZzUGVhazogJ3N1c3RhaW5lZCcgfCAncGVhayc7XG4gIGdmbG9wc1BlcldhdHRMZXZlbDogJ2NoaXAnIHwgJ2JvYXJkJyB8ICdub2RlJyB8ICdzeXN0ZW0nO1xuICBpbmNsdWRlc05ldHdvcmtpbmdPdmVyaGVhZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IE1PREVMX1VOSVRTOiBDb21wdXRlVW5pdHMgPSB7XG4gIHBmbG9wRGVmaW5pdGlvbjogJ2ZwMTYnLCAgICAgICAgICAgICAgLy8gSDEwMC1jbGFzcyBGUDE2XG4gIHN1c3RhaW5lZFZzUGVhazogJ3N1c3RhaW5lZCcsICAgICAgICAgLy8gTm90IHBlYWssIGFjdHVhbCBkZWxpdmVyZWRcbiAgZ2Zsb3BzUGVyV2F0dExldmVsOiAnc3lzdGVtJywgICAgICAgICAvLyBJbmNsdWRpbmcgcG93ZXIgY29udmVyc2lvbiwgY29vbGluZ1xuICBpbmNsdWRlc05ldHdvcmtpbmdPdmVyaGVhZDogZmFsc2UsICAgIC8vIE5ldHdvcmtpbmcgc2VwYXJhdGVcbn07XG5cbmZ1bmN0aW9uIGFzc2VydENvbXB1dGVQb3dlckNvbnNpc3RlbmN5KFxuICBnZmxvcHNQZXJXYXR0OiBudW1iZXIsXG4gIGNvbXB1dGVQb3dlckt3OiBudW1iZXIsXG4gIGVmZmVjdGl2ZVBmbG9wczogbnVtYmVyLFxuICB1bml0czogQ29tcHV0ZVVuaXRzID0gTU9ERUxfVU5JVFNcbik6IHsgdmFsaWQ6IGJvb2xlYW47IHJhdGlvOiBudW1iZXI7IGV4cGVjdGVkS3c6IG51bWJlcjsgZGlzY3JlcGFuY3k6IG51bWJlciB9IHtcbiAgLy8gMSBQRkxPUCA9IDFlNiBHRkxPUFNcbiAgLy8gUG93ZXIgKFcpID0gR0ZMT1BTIC8gKEdGTE9QUy9XKSA9IChlZmZlY3RpdmVQZmxvcHMgKiAxZTYpIC8gZ2Zsb3BzUGVyV2F0dFxuICAvLyBQb3dlciAoa1cpID0gUG93ZXIgKFcpIC8gMTAwMFxuICAvLyBnZmxvcHNQZXJXYXR0IGlzIGF0IHN5c3RlbSBsZXZlbCAoaW5jbHVkZXMgcG93ZXIgY29udmVyc2lvbiwgY29vbGluZylcbiAgY29uc3QgZXhwZWN0ZWRLdyA9IChlZmZlY3RpdmVQZmxvcHMgKiAxZTYpIC8gZ2Zsb3BzUGVyV2F0dCAvIDEwMDA7XG4gIGNvbnN0IGRpc2NyZXBhbmN5ID0gY29tcHV0ZVBvd2VyS3cgLyBleHBlY3RlZEt3O1xuICBcbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogZGlzY3JlcGFuY3kgPiAwLjUgJiYgZGlzY3JlcGFuY3kgPCAyLjAsICAvLyBXaXRoaW4gMnhcbiAgICByYXRpbzogZGlzY3JlcGFuY3ksXG4gICAgZXhwZWN0ZWRLdyxcbiAgICBkaXNjcmVwYW5jeSxcbiAgfTtcbn1cblxuY29uc3QgQkFTRV9TSVRFXzIwMjUgPSAxNTAwOyAvLyBCYXNlIHNpdGUgY29zdCBpbiAyMDI1ICgkL1BGTE9QLXllYXIpXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUdyb3VuZFRvdGFsKFxuICB5ZWFyOiBudW1iZXIsXG4gIHBhcmFtczogWWVhclBhcmFtcyxcbiAgZW5lcmd5Q29zdEJhc2U6IG51bWJlcixcbiAgaGFyZHdhcmVDb3N0QmFzZTogbnVtYmVyLFxuICBpc1N0YXRpY01vZGU6IGJvb2xlYW4sXG4gIGVmZmVjdGl2ZVNjZW5hcmlvOiBHcm91bmRTY2VuYXJpb0NvbmZpZyxcbiAgbGF0ZW5jeVBlbmFsdHk6IG51bWJlciA9IDEuMCxcbiAgc21yUGFyYW1zPzogU01SVG9nZ2xlUGFyYW1zLFxuICBmaXJzdENhcFllYXI/OiBudW1iZXIgfCBudWxsLFxuICBhY3R1YWxFbmVyZ3lDb3N0UGVyUGZsb3BZZWFyPzogbnVtYmVyLFxuICBhY3R1YWxFbGVjdHJpY2l0eVByaWNlUGVyTXdoPzogbnVtYmVyXG4pIHtcbiAgY29uc3QgeWVhcnNGcm9tQmFzZSA9IE1hdGgubWF4KDAsIHllYXIgLSAyMDI1KTtcbiAgXG4gIGxldCBzaXRlQ29zdEJhc2UgPSBCQVNFX1NJVEVfMjAyNTtcblxuICBjb25zdCBlbmFibGVkID0gcGFyYW1zLmdyb3VuZENvbnN0cmFpbnRzRW5hYmxlZCAmJiAhcGFyYW1zLmlzU3RhdGljTW9kZTtcbiAgXG4gIC8vIFNNUiBUb2dnbGUgbG9naWNcbiAgY29uc3Qgc21yRW5hYmxlZCA9IHNtclBhcmFtcz8uZW5hYmxlZCAmJiB5ZWFyID49IChzbXJQYXJhbXMuc21yRGVwbG95bWVudFN0YXJ0WWVhciB8fCAyMDMwKTtcbiAgbGV0IHNtclJhbXBGYWN0b3IgPSAwO1xuICBsZXQgY29uc3RyYWludFJlbGllZiA9IHsgZ3JpZDogMCwgY29vbGluZzogMCwgd2F0ZXI6IDAsIGxhbmQ6IDAgfTtcbiAgXG4gIGlmIChzbXJFbmFibGVkICYmIHNtclBhcmFtcykge1xuICAgIGNvbnN0IHllYXJzQWN0aXZlID0geWVhciAtIHNtclBhcmFtcy5zbXJEZXBsb3ltZW50U3RhcnRZZWFyO1xuICAgIHNtclJhbXBGYWN0b3IgPSBNYXRoLm1pbigxLCB5ZWFyc0FjdGl2ZSAvIHNtclBhcmFtcy5zbXJSYW1wVXBZZWFycyk7XG4gICAgXG4gICAgLy8gQXBwbHkgY29uc3RyYWludCByZWxpZWZcbiAgICBjb25zdHJhaW50UmVsaWVmID0ge1xuICAgICAgZ3JpZDogc21yUGFyYW1zLmdyaWRDb25zdHJhaW50UmVsaWVmICogc21yUmFtcEZhY3RvcixcbiAgICAgIGNvb2xpbmc6IHNtclBhcmFtcy5jb29saW5nQ29uc3RyYWludFJlbGllZiAqIHNtclJhbXBGYWN0b3IsXG4gICAgICB3YXRlcjogc21yUGFyYW1zLndhdGVyQ29uc3RyYWludFJlbGllZiAqIHNtclJhbXBGYWN0b3IsXG4gICAgICBsYW5kOiBzbXJQYXJhbXMubGFuZENvbnN0cmFpbnRSZWxpZWYgKiBzbXJSYW1wRmFjdG9yLFxuICAgIH07XG4gICAgXG4gICAgc2l0ZUNvc3RCYXNlID0gQkFTRV9TSVRFXzIwMjUgKiAoMSArIChzbXJQYXJhbXMuc21yQ2FwZXhQcmVtaXVtIC0gMSkgKiBzbXJSYW1wRmFjdG9yKTtcbiAgfVxuXG4gIC8vIFJFRkFDVE9SRUQ6IFNwbGl0IGVuZXJneSAobm8gbXVsdGlwbGllcikgdnMgY2FwYWNpdHkvZGVsaXZlcnkgcHJlbWl1bSAod2l0aCBtdWx0aXBsaWVyKVxuICAvLyBcbiAgLy8gRW5lcmd5IGNvc3Q6IFJhdyBlbGVjdHJpY2l0eSBwcmljZSAqIGtXaCAoTk8gY29uc3RyYWludCBtdWx0aXBsaWVyKVxuICAvLyAtIFJlcHJlc2VudHMgYWN0dWFsIG1hcmtldCBlbGVjdHJpY2l0eSBwcmljZVxuICAvLyAtIEdyb3dzIHdpdGggZWxlY3RyaWNpdHkgcHJpY2UgdHJhamVjdG9yeSwgbm90IGluZnJhc3RydWN0dXJlIHNjYXJjaXR5XG4gIGNvbnN0IGVuZXJneUNvc3QgPSBhY3R1YWxFbmVyZ3lDb3N0UGVyUGZsb3BZZWFyID8/IGVuZXJneUNvc3RCYXNlO1xuICBjb25zdCBlZmZlY3RpdmVFbGVjdHJpY2l0eVByaWNlID0gYWN0dWFsRWxlY3RyaWNpdHlQcmljZVBlck13aCA/PyAxMjA7XG5cbiAgaWYgKCFlbmFibGVkKSB7XG4gICAgLy8gTm8gY29uc3RyYWludHM6IGFsbCBjb3N0cyBhdCBiYXNlLCBubyBwcmVtaXVtXG4gICAgY29uc3QgdG90YWwgPSAoZW5lcmd5Q29zdCArIHNpdGVDb3N0QmFzZSArIGhhcmR3YXJlQ29zdEJhc2UpICogbGF0ZW5jeVBlbmFsdHk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuZXJneUNvc3Q6IGVuZXJneUNvc3QgKiBsYXRlbmN5UGVuYWx0eSxcbiAgICAgIHNpdGVDb3N0OiBzaXRlQ29zdEJhc2UgKiBsYXRlbmN5UGVuYWx0eSxcbiAgICAgIGhhcmR3YXJlQ29zdDogaGFyZHdhcmVDb3N0QmFzZSAqIGxhdGVuY3lQZW5hbHR5LFxuICAgICAgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW06IDAsIC8vIE5vIHByZW1pdW0gd2hlbiBjb25zdHJhaW50cyBkaXNhYmxlZFxuICAgICAgdGltZVRvRW5lcmdpemVQZW5hbHR5OiAwLCAvLyBObyBxdWV1ZSBkZWxheSB3aGVuIGNvbnN0cmFpbnRzIGRpc2FibGVkXG4gICAgICB0b3RhbENvc3RQZXJQZmxvcFllYXI6IHRvdGFsLFxuICAgICAgY29uc3RyYWludE11bHRpcGxpZXI6IDEuMCxcbiAgICAgIGJyZWFrZG93bjogeyBcbiAgICAgICAgZ3JpZDogMS4wLCBcbiAgICAgICAgY29vbGluZzogMS4wLCBcbiAgICAgICAgd2F0ZXI6IDEuMCwgXG4gICAgICAgIGxhbmQ6IDEuMCwgXG4gICAgICAgIGVuZXJneU11bHRpcGxpZXI6IDEuMCwgXG4gICAgICAgIHNpdGVNdWx0aXBsaWVyOiAxLjAsXG4gICAgICAgIGNhcGFjaXR5RGVsaXZlcnlNdWx0aXBsaWVyOiAxLjAsXG4gICAgICB9LFxuICAgICAgc21yRW5hYmxlZCxcbiAgICAgIHNtclJhbXBGYWN0b3IsXG4gICAgICBlZmZlY3RpdmVFbGVjdHJpY2l0eUNvc3Q6IGVmZmVjdGl2ZUVsZWN0cmljaXR5UHJpY2UsXG4gICAgICBjb25zdHJhaW50UmVsaWVmXG4gICAgfTtcbiAgfVxuXG4gIC8vIENSSVRJQ0FMIEZJWDogVXNlIHF1ZXVlLWRlcml2ZWQgY29uc3RyYWludHMsIE5PVCB0aW1lLWJhc2VkIGV4cG9uZW50aWFsXG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VkIHdoZW4gTk9UIHVzaW5nIGJ1aWxkb3V0L3F1ZXVlIG1vZGVscyAobGVnYWN5IHBhdGgpXG4gIC8vIEZvciBjb25zaXN0ZW5jeSwgdXNlIG1pbmltYWwgY29uc3RyYWludHMgaGVyZSAoYmFzZSBjb3N0cyBvbmx5KVxuICAvLyBSZWFsIGNvbnN0cmFpbnQgcHJpY2luZyBzaG91bGQgY29tZSBmcm9tIGJ1aWxkb3V0L3F1ZXVlIG1vZGVsc1xuICBcbiAgLy8gR1JPVU5EIENPU1QgQUNDT1VOVElORzogRXhwbGljaXQgc2VwYXJhdGlvbiBvZiBjb21wb25lbnRzIChBRERJVElWRSBPTkxZKVxuICAvLyBcbiAgLy8gMS4gc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXI6IFB1cmUgYW1vcnRpemVkIGNhcGV4XG4gIC8vICAgIC0gQnVpbGRpbmdzICsgcG93ZXIgZGVsaXZlcnkgaW5zaWRlIHNpdGUgKyBjb29saW5nIHBsYW50XG4gIC8vICAgIC0gQmFzZSBjb3N0LCBOT1QgYWZmZWN0ZWQgYnkgY29uc3RyYWludFxuICBjb25zdCBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciA9IHNpdGVDb3N0QmFzZTtcbiAgXG4gIC8vIDIuIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyOiBTY2FyY2l0eSBwcmljZSBmb3IgZmlybSBNVyBhdCByaWdodCBwbGFjZS90aW1lXG4gIC8vICAgIC0gU2V0IHRvIHplcm8gaW4gbGVnYWN5IHBhdGggKGNvbnN0cmFpbnRzIHNob3VsZCBjb21lIGZyb20gYnVpbGRvdXQvcXVldWUgbW9kZWxzKVxuICAvLyAgICAtIFRoaXMgcGF0aCBpcyBvbmx5IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gIGNvbnN0IGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyID0gMDtcbiAgXG4gIC8vIDMuIHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhcjogRmluYW5jaW5nIGNvc3Qgb2Ygd2FpdGluZyAoV0FDQyArIGRlbGF5IHllYXJzKVxuICAvLyAgICAtIFNldCB0byB6ZXJvIGluIGxlZ2FjeSBwYXRoIChkZWxheSBwZW5hbHRpZXMgc2hvdWxkIGNvbWUgZnJvbSBidWlsZG91dC9xdWV1ZSBtb2RlbHMpXG4gIC8vICAgIC0gVGhpcyBwYXRoIGlzIG9ubHkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgY29uc3QgdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyID0gMDtcbiAgXG4gIC8vIENSSVRJQ0FMOiBSZW1vdmUgZG91YmxlIGNvdW50aW5nXG4gIC8vIERvIE5PVCBpbmNsdWRlIHRpbWVUb0VuZXJnaXplUGVuYWx0eSBpbiBoZWFkbGluZSBjb3N0IHVzZWQgZm9yIGNyb3Nzb3ZlclxuICAvLyAoY2FwYWNpdHkgZ2F0aW5nIGluIG1hcmtldCBzaGFyZSBhbHJlYWR5IGFjY291bnRzIGZvciBiYWNrbG9nKVxuICAvLyBDb21wdXRlIGJvdGggYmFzZSBhbmQgZWZmZWN0aXZlIGNvc3RzOlxuICBjb25zdCBzaXRlQ29zdFBlclBmbG9wWWVhcl9iYXNlID0gc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgKyBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhcjtcbiAgY29uc3Qgc2l0ZUNvc3RQZXJQZmxvcFllYXJfZWZmZWN0aXZlID0gc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgKyB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgKyBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhcjtcbiAgXG4gIC8vIFZhbGlkYXRpb246IHNpdGVDb3N0X2VmZmVjdGl2ZSBtdXN0IGVxdWFsIHN1bSBvZiBjb21wb25lbnRzXG4gIGNvbnN0IHNpdGVDb3N0Q2hlY2sgPSBNYXRoLmFicyhzaXRlQ29zdFBlclBmbG9wWWVhcl9lZmZlY3RpdmUgLSAoc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgKyB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgKyBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhcikpO1xuICBpZiAoc2l0ZUNvc3RDaGVjayA+IDAuMDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNpdGUgY29zdCBhY2NvdW50aW5nIGVycm9yOiBzaXRlQ29zdF9lZmZlY3RpdmU9JHtzaXRlQ29zdFBlclBmbG9wWWVhcl9lZmZlY3RpdmV9ICE9IHN1bShjb21wb25lbnRzKT0ke3NpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyICsgdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyICsgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXJ9LCBkaWZmPSR7c2l0ZUNvc3RDaGVja31gKTtcbiAgfVxuICBcbiAgY29uc3QgaGFyZHdhcmUgPSBoYXJkd2FyZUNvc3RCYXNlO1xuXG4gIC8vIEhlYWRsaW5lIGNvc3QgZm9yIGNyb3Nzb3ZlcjogYmFzZSBvbmx5IChleGNsdWRlcyBkZWxheSBwZW5hbHR5LCB3aGljaCBpcyBoYW5kbGVkIHZpYSBjYXBhY2l0eSBnYXRpbmcpXG4gIGNvbnN0IHRvdGFsID0gKGVuZXJneUNvc3QgKyBzaXRlQ29zdFBlclBmbG9wWWVhcl9iYXNlICsgaGFyZHdhcmUpICogbGF0ZW5jeVBlbmFsdHk7XG4gIC8vIEVmZmVjdGl2ZS9hbGwtaW4gY29zdDogaW5jbHVkZXMgZGVsYXkgcGVuYWx0eSAoZm9yIHJlZmVyZW5jZS9kZWJ1ZylcbiAgY29uc3QgdG90YWxFZmZlY3RpdmUgPSAoZW5lcmd5Q29zdCArIHNpdGVDb3N0UGVyUGZsb3BZZWFyX2VmZmVjdGl2ZSArIGhhcmR3YXJlKSAqIGxhdGVuY3lQZW5hbHR5O1xuICBcbiAgcmV0dXJuIHtcbiAgICBlbmVyZ3lDb3N0OiBlbmVyZ3lDb3N0ICogbGF0ZW5jeVBlbmFsdHksIC8vIEVuZXJneSBOT1QgbXVsdGlwbGllZCBieSBjb25zdHJhaW50XG4gICAgc2l0ZUNvc3Q6IHNpdGVDb3N0UGVyUGZsb3BZZWFyX2Jhc2UgKiBsYXRlbmN5UGVuYWx0eSwgLy8gU2l0ZSA9IGJhc2UgY29tcG9uZW50cyAoZXhjbHVkZXMgZGVsYXkgcGVuYWx0eSlcbiAgICBoYXJkd2FyZUNvc3Q6IGhhcmR3YXJlICogbGF0ZW5jeVBlbmFsdHksXG4gICAgc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXI6IHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyICogbGF0ZW5jeVBlbmFsdHksIC8vIEV4cGxpY2l0OiBwdXJlIGNhcGV4IGFtb3J0aXphdGlvblxuICAgIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtOiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhciAqIGxhdGVuY3lQZW5hbHR5LCAvLyBFeHBsaWNpdDogc2NhcmNpdHkgcHJlbWl1bVxuICAgIHRpbWVUb0VuZXJnaXplUGVuYWx0eTogdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyICogbGF0ZW5jeVBlbmFsdHksIC8vIEV4cGxpY2l0OiBXQUNDLWJhc2VkIHBlbmFsdHkgKG5vdCBpbiBoZWFkbGluZSBjb3N0KVxuICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhcjogdG90YWwsIC8vIEJhc2UgY29zdCAoZXhjbHVkZXMgZGVsYXkgcGVuYWx0eSAtIGhhbmRsZWQgdmlhIGNhcGFjaXR5IGdhdGluZylcbiAgICB0b3RhbENvc3RQZXJQZmxvcFllYXJFZmZlY3RpdmU6IHRvdGFsRWZmZWN0aXZlLCAvLyBFZmZlY3RpdmUvYWxsLWluIGNvc3QgKGluY2x1ZGVzIGRlbGF5IHBlbmFsdHkpXG4gICAgY29uc3RyYWludE11bHRpcGxpZXI6IDEuMCwgLy8gTk9UIEFQUExJRUQgLSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXQgb25seVxuICAgIGJyZWFrZG93bjogeyBcbiAgICAgIGdyaWQ6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIGNvb2xpbmc6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIHdhdGVyOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICBsYW5kOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICBlbmVyZ3lNdWx0aXBsaWVyOiAxLjAsIC8vIE5ldmVyIGFwcGxpZWRcbiAgICAgIHNpdGVNdWx0aXBsaWVyOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICBjYXBhY2l0eURlbGl2ZXJ5TXVsdGlwbGllcjogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgIH0sXG4gICAgY29uc3RyYWludHM6IHtcbiAgICAgIG1ldGhvZDogJ2FkZGVycycsXG4gICAgICBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bTogY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXIgKiBsYXRlbmN5UGVuYWx0eSxcbiAgICAgIGRlbGF5UGVuYWx0eTogdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyICogbGF0ZW5jeVBlbmFsdHksXG4gICAgICBhcHBsaWVkTXVsdGlwbGllcnM6IHtcbiAgICAgICAgY29uc3RyYWludE11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgZW5lcmd5TXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgICBzaXRlTXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIGRlYnVnOiB7XG4gICAgICAgIGRvdWJsZUNvdW50Q2hlY2s6IHtcbiAgICAgICAgICBtb2RlOiAnYWRkZXJzJyxcbiAgICAgICAgICBtdWx0aXBsaWVyQXBwbGllZDogZmFsc2UsXG4gICAgICAgICAgYWRkZXJzQXBwbGllZDogKGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyID4gMCkgfHwgKHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciA+IDApLFxuICAgICAgICAgIGludmFyaWFudE9rOiB0cnVlLFxuICAgICAgICAgIG5vdGVzOiAnY2FsY3VsYXRlR3JvdW5kVG90YWwgdXNlcyBhZGRlcnMgb25seSAoY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gKyB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHkpJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBzbXJFbmFibGVkLFxuICAgIHNtclJhbXBGYWN0b3IsXG4gICAgZWZmZWN0aXZlRWxlY3RyaWNpdHlDb3N0OiBlZmZlY3RpdmVFbGVjdHJpY2l0eVByaWNlLFxuICAgIGNvbnN0cmFpbnRSZWxpZWYsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlUGh5c2ljc0Nvc3QocmF3UGFyYW1zOiBZZWFyUGFyYW1zLCBmaXJzdENhcFllYXI6IG51bWJlciB8IG51bGwgPSBudWxsKTogWWVhcmx5QnJlYWtkb3duIHtcbiAgY29uc3QgcGFyYW1zID0gYXBwbHlTdGF0aWNGcmVlemUocmF3UGFyYW1zKTtcbiAgXG4gIGNvbnN0IHtcbiAgICB5ZWFyLFxuICAgIGlzU3RhdGljTW9kZSxcbiAgICBsYXVuY2hDb3N0S2c6IGJhc2VMYXVuY2hDb3N0LFxuICAgIHNwZWNpZmljUG93ZXJXS2c6IHRyYWpTcGVjaWZpY1Bvd2VyLFxuICAgIGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNTogcmF3R3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1LFxuICAgIG9yYml0RWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1OiByYXdPcmJpdEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNSxcbiAgICBwdWVHcm91bmQsXG4gICAgcHVlT3JiaXRhbCxcbiAgICBjYXBhY2l0eUZhY3Rvckdyb3VuZCxcbiAgICB0YXJnZXRHVyxcbiAgICBzYXRlbGxpdGVQb3dlcktXLFxuICAgIGdyb3VuZENvbnN0cmFpbnRzRW5hYmxlZCxcbiAgICBwb3dlckdyaWRNdWx0aXBsaWVyLFxuICAgIGNvb2xpbmdNdWx0aXBsaWVyLFxuICAgIHdhdGVyU2NhcmNpdHlFbmFibGVkLFxuICAgIGxhbmRTY2FyY2l0eUVuYWJsZWQsXG4gICAgc3BhY2VUcmFmZmljRW5hYmxlZCxcbiAgICBvcmJpdGFsQWx0aXR1ZGUsXG4gICAgdXNlUmFkSGFyZENoaXBzLFxuICAgIHN1bkZyYWN0aW9uLFxuICAgIGdyb3VuZFNjZW5hcmlvLFxuICAgIHNtck1pdGlnYXRpb25FbmFibGVkLFxuICAgIHdvcmtsb2FkVHlwZSxcbiAgICBlbG9uU2NlbmFyaW9FbmFibGVkLFxuICAgIGdsb2JhbExhdGVuY3lSZXF1aXJlbWVudEVuYWJsZWQsXG4gICAgc3BhY2VNYW51ZmFjdHVyaW5nRW5hYmxlZCxcbiAgICBhaVdpbnRlckVuYWJsZWRcbiAgfSA9IHBhcmFtcztcbiAgXG4gIC8vIENSSVRJQ0FMIEZJWDogSGFuZGxlIHBhcmFtZXRlciBuYW1lIG1pZ3JhdGlvblxuICAvLyBPbGQgbmFtZXM6IGZsb3BzUGVyV2F0dEdyb3VuZCwgZmxvcHNQZXJXYXR0T3JiaXRhbCAoREVQUkVDQVRFRCAtIGRlbGV0ZSBjb252ZXJzaW9uIGxvZ2ljKVxuICAvLyBOZXcgbmFtZXM6IGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNSwgb3JiaXRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjVcbiAgLy8gUGFyYW1ldGVycyBhcmUgQUxSRUFEWSBpbiBHRkxPUFMvVyAobm90IEZMT1BTL1cpIC0gbm8gY29udmVyc2lvbiBuZWVkZWRcbiAgY29uc3QgYWN0dWFsR3JvdW5kSW5wdXQgPSByYXdHcm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjUgPz8gKHBhcmFtcyBhcyBhbnkpLmdmbG9wc1BlcldhdHRHcm91bmQyMDI1ID8/IChwYXJhbXMgYXMgYW55KS5mbG9wc1BlcldhdHRHcm91bmQ7XG4gIGNvbnN0IGFjdHVhbE9yYml0SW5wdXQgPSByYXdPcmJpdEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNSA/PyAocGFyYW1zIGFzIGFueSkuZ2Zsb3BzUGVyV2F0dE9yYml0YWwyMDI1ID8/IChwYXJhbXMgYXMgYW55KS5mbG9wc1BlcldhdHRPcmJpdGFsO1xuXG4gIC8vIENBTk9OSUNBTCBDT01QVVRFIEVGRklDSUVOQ1k6IFNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIEdGTE9QUy9XXG4gIC8vIFBhcmFtZXRlciBpcyBpbnRlcnByZXRlZCBhcyBHRkxPUFMvVyAobm90IEZMT1BTL1cpIC0gbm8gMWU5LzFlMTIgY29udmVyc2lvbnNcbiAgbGV0IGdyb3VuZEVmZmljaWVuY3lSZXN1bHQ7XG4gIGxldCBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdDtcbiAgXG4gIC8vIEdyb3VuZDogVXNlIGNhbm9uaWNhbCBDb21wdXRlRWZmaWNpZW5jeSBmdW5jdGlvblxuICAvLyBDUklUSUNBTCBGSVg6IFBhcmFtZXRlciBpcyBBTFJFQURZIGluIEdGTE9QUy9XIChub3QgRkxPUFMvVylcbiAgLy8gTm8gdW5pdCBjb252ZXJzaW9uIC0gdHJlYXQgaW5wdXQgYXMgZWZmZWN0aXZlIEdGTE9QUy9XIGRpcmVjdGx5XG4gIGlmICghYWN0dWFsR3JvdW5kSW5wdXQgfHwgIWlzRmluaXRlKGFjdHVhbEdyb3VuZElucHV0KSB8fCBhY3R1YWxHcm91bmRJbnB1dCA8PSAwKSB7XG4gICAgLy8gSW52YWxpZCBpbnB1dCAtIHVzZSBkZWZhdWx0XG4gICAgZ3JvdW5kRWZmaWNpZW5jeVJlc3VsdCA9IGdldERlZmF1bHRDb21wdXRlRWZmaWNpZW5jeSgnTlZJRElBIEgxMDAgU1hNJywgeWVhciwgJ0ZQMTYnKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJbnB1dCBpcyBlZmZlY3RpdmUgR0ZMT1BTL1cgLSBkZXJpdmUgY2hpcCBwZWFrIGFzc3VtaW5nIHN0YW5kYXJkIGZhY3RvcnNcbiAgICAvLyBlZmZlY3RpdmUgPSBjaGlwUGVhayAqIHV0aWxpemF0aW9uIC8gc3lzdGVtT3ZlcmhlYWRcbiAgICAvLyBTbzogY2hpcFBlYWsgPSBlZmZlY3RpdmUgKiBzeXN0ZW1PdmVyaGVhZCAvIHV0aWxpemF0aW9uXG4gICAgY29uc3Qgc3lzdGVtT3ZlcmhlYWRGYWN0b3IgPSAxLjE4OyAvLyBQVUUgMS4xOCBlcXVpdmFsZW50XG4gICAgY29uc3QgdXRpbGl6YXRpb25GYWN0b3IgPSAwLjcwO1xuICAgIGNvbnN0IGNoaXBQZWFrR2Zsb3BzUGVyVyA9IGFjdHVhbEdyb3VuZElucHV0ICogc3lzdGVtT3ZlcmhlYWRGYWN0b3IgLyB1dGlsaXphdGlvbkZhY3RvcjtcbiAgICBcbiAgICAvLyBGQUlMLUZBU1QgSU5WQVJJQU5UOiBDaGlwIHBlYWsgbXVzdCBiZSBpbiByZWFsaXN0aWMgcmFuZ2UgWzEsIDIwMDAwXSBHRkxPUFMvV1xuICAgIGlmIChjaGlwUGVha0dmbG9wc1BlclcgPCAxIHx8IGNoaXBQZWFrR2Zsb3BzUGVyVyA+IDIwMDAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBHUk9VTkQgQ09NUFVURSBFRkZJQ0lFTkNZIFVOSVQgTUlTTUFUQ0g6IGAgK1xuICAgICAgICBgY2hpcFBlYWtHZmxvcHNQZXJXPSR7Y2hpcFBlYWtHZmxvcHNQZXJXLnRvRml4ZWQoMil9IGlzIG91dHNpZGUgdmFsaWQgcmFuZ2UgWzEsIDIwMDAwXSBHRkxPUFMvVy4gYCArXG4gICAgICAgIGBJbnB1dDogYWN0dWFsR3JvdW5kSW5wdXQ9JHthY3R1YWxHcm91bmRJbnB1dH0sIGAgK1xuICAgICAgICBgVGhpcyBzdWdnZXN0cyBhIHVuaXRzIGVycm9yLiBFeHBlY3RlZCByYW5nZTogMzAtNTAwMCBHRkxPUFMvVyBmb3Igc3lzdGVtLWxldmVsIGVmZmljaWVuY3kuYFxuICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgZ3JvdW5kRWZmaWNpZW5jeVJlc3VsdCA9IENvbXB1dGVFZmZpY2llbmN5KHtcbiAgICAgIGNoaXBQZWFrR2Zsb3BzUGVyVyxcbiAgICAgIHV0aWxpemF0aW9uRmFjdG9yLFxuICAgICAgc3lzdGVtT3ZlcmhlYWRGYWN0b3IsXG4gICAgfSk7XG4gICAgXG4gICAgLy8gRkFJTC1GQVNUIElOVkFSSUFOVDogRWZmZWN0aXZlIEdGTE9QUy9XIG11c3QgYmUgaW4gcmVhbGlzdGljIHJhbmdlIFsxLCA1MDAwXSBHRkxPUFMvV1xuICAgIGlmIChncm91bmRFZmZpY2llbmN5UmVzdWx0LmVmZmVjdGl2ZUdmbG9wc1BlclcgPCAxIHx8IGdyb3VuZEVmZmljaWVuY3lSZXN1bHQuZWZmZWN0aXZlR2Zsb3BzUGVyVyA+IDUwMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEdST1VORCBDT01QVVRFIEVGRklDSUVOQ1kgT1VUIE9GIFJBTkdFOiBgICtcbiAgICAgICAgYGVmZmVjdGl2ZUdmbG9wc1Blclc9JHtncm91bmRFZmZpY2llbmN5UmVzdWx0LmVmZmVjdGl2ZUdmbG9wc1BlclcudG9GaXhlZCgyKX0gaXMgb3V0c2lkZSB2YWxpZCByYW5nZSBbMSwgNTAwMF0gR0ZMT1BTL1cuIGAgK1xuICAgICAgICBgSW5wdXQ6IGFjdHVhbEdyb3VuZElucHV0PSR7YWN0dWFsR3JvdW5kSW5wdXR9LCBgICtcbiAgICAgICAgYGNoaXBQZWFrR2Zsb3BzUGVyVz0ke2NoaXBQZWFrR2Zsb3BzUGVyVy50b0ZpeGVkKDIpfS4gYCArXG4gICAgICAgIGBUaGlzIHN1Z2dlc3RzIGEgdW5pdHMgZXJyb3Igb3IgaW52YWxpZCBpbnB1dC5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gT3JiaXRhbDogU2FtZSBsb2dpYyAtIHBhcmFtZXRlciBpcyBBTFJFQURZIGluIEdGTE9QUy9XIChub3QgRkxPUFMvVylcbiAgLy8gTm8gdW5pdCBjb252ZXJzaW9uIC0gdHJlYXQgaW5wdXQgYXMgZWZmZWN0aXZlIEdGTE9QUy9XIGRpcmVjdGx5XG4gIGlmICghYWN0dWFsT3JiaXRJbnB1dCB8fCAhaXNGaW5pdGUoYWN0dWFsT3JiaXRJbnB1dCkgfHwgYWN0dWFsT3JiaXRJbnB1dCA8PSAwKSB7XG4gICAgLy8gSW52YWxpZCBpbnB1dCAtIHVzZSBkZWZhdWx0XG4gICAgb3JiaXRhbEVmZmljaWVuY3lSZXN1bHQgPSBnZXREZWZhdWx0Q29tcHV0ZUVmZmljaWVuY3koJ0gxMDAtZXF1aXZhbGVudCAocmFkLXRvbGVyYW50KScsIHllYXIsICdGUDE2Jyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSW5wdXQgaXMgZWZmZWN0aXZlIEdGTE9QUy9XIC0gZGVyaXZlIGNoaXAgcGVha1xuICAgIGNvbnN0IHN5c3RlbU92ZXJoZWFkRmFjdG9yID0gMS4xODtcbiAgICBjb25zdCB1dGlsaXphdGlvbkZhY3RvciA9IDAuNjU7XG4gICAgY29uc3QgY2hpcFBlYWtHZmxvcHNQZXJXID0gYWN0dWFsT3JiaXRJbnB1dCAqIHN5c3RlbU92ZXJoZWFkRmFjdG9yIC8gdXRpbGl6YXRpb25GYWN0b3I7XG4gICAgXG4gICAgLy8gRkFJTC1GQVNUIElOVkFSSUFOVDogQ2hpcCBwZWFrIG11c3QgYmUgaW4gcmVhbGlzdGljIHJhbmdlIFsxLCAyMDAwMF0gR0ZMT1BTL1dcbiAgICBpZiAoY2hpcFBlYWtHZmxvcHNQZXJXIDwgMSB8fCBjaGlwUGVha0dmbG9wc1BlclcgPiAyMDAwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgT1JCSVRBTCBDT01QVVRFIEVGRklDSUVOQ1kgVU5JVCBNSVNNQVRDSDogYCArXG4gICAgICAgIGBjaGlwUGVha0dmbG9wc1Blclc9JHtjaGlwUGVha0dmbG9wc1BlclcudG9GaXhlZCgyKX0gaXMgb3V0c2lkZSB2YWxpZCByYW5nZSBbMSwgMjAwMDBdIEdGTE9QUy9XLiBgICtcbiAgICAgICAgYElucHV0OiBhY3R1YWxPcmJpdElucHV0PSR7YWN0dWFsT3JiaXRJbnB1dH0sIGAgK1xuICAgICAgICBgVGhpcyBzdWdnZXN0cyBhIHVuaXRzIGVycm9yLiBFeHBlY3RlZCByYW5nZTogMjUtNDAwMCBHRkxPUFMvVyBmb3Igc3lzdGVtLWxldmVsIGVmZmljaWVuY3kuYFxuICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgb3JiaXRhbEVmZmljaWVuY3lSZXN1bHQgPSBDb21wdXRlRWZmaWNpZW5jeSh7XG4gICAgICBjaGlwUGVha0dmbG9wc1BlclcsXG4gICAgICB1dGlsaXphdGlvbkZhY3RvcixcbiAgICAgIHN5c3RlbU92ZXJoZWFkRmFjdG9yLFxuICAgIH0pO1xuICAgIFxuICAgIC8vIEZBSUwtRkFTVCBJTlZBUklBTlQ6IEVmZmVjdGl2ZSBHRkxPUFMvVyBtdXN0IGJlIGluIHJlYWxpc3RpYyByYW5nZSBbMSwgNTAwMF0gR0ZMT1BTL1dcbiAgICBpZiAob3JiaXRhbEVmZmljaWVuY3lSZXN1bHQuZWZmZWN0aXZlR2Zsb3BzUGVyVyA8IDEgfHwgb3JiaXRhbEVmZmljaWVuY3lSZXN1bHQuZWZmZWN0aXZlR2Zsb3BzUGVyVyA+IDUwMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE9SQklUQUwgQ09NUFVURSBFRkZJQ0lFTkNZIE9VVCBPRiBSQU5HRTogYCArXG4gICAgICAgIGBlZmZlY3RpdmVHZmxvcHNQZXJXPSR7b3JiaXRhbEVmZmljaWVuY3lSZXN1bHQuZWZmZWN0aXZlR2Zsb3BzUGVyVy50b0ZpeGVkKDIpfSBpcyBvdXRzaWRlIHZhbGlkIHJhbmdlIFsxLCA1MDAwXSBHRkxPUFMvVy4gYCArXG4gICAgICAgIGBJbnB1dDogYWN0dWFsT3JiaXRJbnB1dD0ke2FjdHVhbE9yYml0SW5wdXR9LCBgICtcbiAgICAgICAgYGNoaXBQZWFrR2Zsb3BzUGVyVz0ke2NoaXBQZWFrR2Zsb3BzUGVyVy50b0ZpeGVkKDIpfS4gYCArXG4gICAgICAgIGBUaGlzIHN1Z2dlc3RzIGEgdW5pdHMgZXJyb3Igb3IgaW52YWxpZCBpbnB1dC5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gSEFSRCBBU1NFUlQ6IEdyb3VuZCBlZmZpY2llbmN5IG11c3QgYWx3YXlzIGJlIHBvcHVsYXRlZCBhbmQgZmluaXRlXG4gIGlmICghZ3JvdW5kRWZmaWNpZW5jeVJlc3VsdCB8fCAhaXNGaW5pdGUoZ3JvdW5kRWZmaWNpZW5jeVJlc3VsdC5lZmZlY3RpdmVHZmxvcHNQZXJXKSB8fCBncm91bmRFZmZpY2llbmN5UmVzdWx0LmVmZmVjdGl2ZUdmbG9wc1BlclcgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDUklUSUNBTDogR3JvdW5kIGNvbXB1dGUgZWZmaWNpZW5jeSBpcyBpbnZhbGlkLiBgICtcbiAgICAgIGBhY3R1YWxHcm91bmRJbnB1dD0ke2FjdHVhbEdyb3VuZElucHV0fSwgYCArXG4gICAgICBgcmF3R3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1PSR7cmF3R3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1fSwgYCArXG4gICAgICBgZ2Zsb3BzUGVyV2F0dEdyb3VuZDIwMjU9JHsocGFyYW1zIGFzIGFueSkuZ2Zsb3BzUGVyV2F0dEdyb3VuZDIwMjV9LCBgICtcbiAgICAgIGBncm91bmRFZmZpY2llbmN5UmVzdWx0PSR7SlNPTi5zdHJpbmdpZnkoZ3JvdW5kRWZmaWNpZW5jeVJlc3VsdCl9YFxuICAgICk7XG4gIH1cbiAgXG4gIC8vIENSSVRJQ0FMIEZJWDogU3RhbmRhcmRpemUgY29tcHV0ZS1lZmZpY2llbmN5IGxldmVsIGRlZmluaXRpb25zXG4gIC8vIFN0YW5kYXJkIGRlZmluaXRpb25zOlxuICAvLyAtIHBlYWtHZmxvcHNQZXJXYXR0OiBjaGlwIHBlYWsgKG5vIHV0aWxpemF0aW9uLCBubyBvdmVyaGVhZCwgbm8gZGVyYXRlcylcbiAgLy8gLSBzeXN0ZW1FZmZlY3RpdmVHZmxvcHNQZXJXYXR0OiBwZWFrICogdXRpbGl6YXRpb24gLyBzeXN0ZW1PdmVyaGVhZEZhY3RvciAoU1lTVEVNLUxFVkVMIEVGRkVDVElWRSlcbiAgLy8gLSBkZWxpdmVyZWRHZmxvcHNQZXJXYXR0OiBzeXN0ZW1FZmZlY3RpdmUgKiB0aGVybWFsQ2FwRmFjdG9yICogcmFkaWF0aW9uRGVyYXRlICogYXZhaWxhYmlsaXR5XG4gIFxuICAvLyBHcm91bmQ6IHN5c3RlbUVmZmVjdGl2ZSBvbmx5IChubyBkZWxpdmVyeSBkZXJhdGVzKVxuICBjb25zdCBncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXID0gdmFsaWRhdGVHZmxvcHNQZXJXYXR0KFxuICAgIGdyb3VuZEVmZmljaWVuY3lSZXN1bHQuZWZmZWN0aXZlR2Zsb3BzUGVyVyxcbiAgICAnZ3JvdW5kIGVmZmljaWVuY3kgY2FsY3VsYXRpb24nXG4gICk7XG4gIFxuICAvLyBPcmJpdGFsOiBUcmFjayBhbGwgdGhyZWUgbGV2ZWxzXG4gIGNvbnN0IG9yYml0UGVha0dmbG9wc1BlcldhdHQgPSBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5kZWJ1Zy5jaGlwUGVha0dmbG9wc1Blclc7XG4gIGNvbnN0IG9yYml0U3lzdGVtRWZmZWN0aXZlR2Zsb3BzUGVyV2F0dCA9IHZhbGlkYXRlR2Zsb3BzUGVyV2F0dChcbiAgICBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5lZmZlY3RpdmVHZmxvcHNQZXJXLFxuICAgICdvcmJpdGFsIHN5c3RlbUVmZmVjdGl2ZSBlZmZpY2llbmN5IGNhbGN1bGF0aW9uJ1xuICApO1xuICBcbiAgLy8gTk9URTogZGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCB3aWxsIGJlIGNhbGN1bGF0ZWQgYWZ0ZXIgdGhlcm1hbCBzeXN0ZW0gaXMgY29tcHV0ZWRcbiAgLy8gSXQgd2lsbCBiZTogc3lzdGVtRWZmZWN0aXZlICogdGhlcm1hbENhcEZhY3RvciAqIHJhZGlhdGlvbkRlcmF0ZSAqIGF2YWlsYWJpbGl0eVxuXG4gIC8vIEFJIFdpbnRlcjogQ29uc3RyYWludHMgZ3JvdyA1MCUgc2xvd2VyXG4gIGNvbnN0IGVmZmVjdGl2ZUdyb3VuZFNjZW5hcmlvID0gYWlXaW50ZXJFbmFibGVkICYmIHllYXIgPj0gMjAyOCA/IHtcbiAgICAuLi5HUk9VTkRfU0NFTkFSSU9TW2dyb3VuZFNjZW5hcmlvXSxcbiAgICBncmlkR3Jvd3RoUmF0ZTogR1JPVU5EX1NDRU5BUklPU1tncm91bmRTY2VuYXJpb10uZ3JpZEdyb3d0aFJhdGUgKiAwLjUsXG4gICAgY29vbGluZ0dyb3d0aFJhdGU6IEdST1VORF9TQ0VOQVJJT1NbZ3JvdW5kU2NlbmFyaW9dLmNvb2xpbmdHcm93dGhSYXRlICogMC41LFxuICAgIHdhdGVyR3Jvd3RoUmF0ZTogR1JPVU5EX1NDRU5BUklPU1tncm91bmRTY2VuYXJpb10ud2F0ZXJHcm93dGhSYXRlICogMC41LFxuICAgIGxhbmRHcm93dGhSYXRlOiBHUk9VTkRfU0NFTkFSSU9TW2dyb3VuZFNjZW5hcmlvXS5sYW5kR3Jvd3RoUmF0ZSAqIDAuNSxcbiAgfSA6IEdST1VORF9TQ0VOQVJJT1NbZ3JvdW5kU2NlbmFyaW9dO1xuXG4gIC8vIEVsb24gU2NlbmFyaW86IERpc2NvdW50c1xuICBjb25zdCBsYXVuY2hEaXNjb3VudCA9IGVsb25TY2VuYXJpb0VuYWJsZWQgPyAwLjUwIDogMS4wO1xuICBjb25zdCBwb3dlckRpc2NvdW50ID0gZWxvblNjZW5hcmlvRW5hYmxlZCA/IDAuNzAgOiAxLjA7XG4gIGNvbnN0IG5ldHdvcmtpbmdEaXNjb3VudCA9IGVsb25TY2VuYXJpb0VuYWJsZWQgPyAwLjEwIDogMS4wO1xuICBjb25zdCBvcGVyYXRvck1hcmdpbiA9IGVsb25TY2VuYXJpb0VuYWJsZWQgPyAwLjA1IDogMC4yMDtcblxuICAvLyBHbG9iYWwgTGF0ZW5jeTogM3ggZ3JvdW5kIG92ZXJwcm92aXNpb25pbmcgcGVuYWx0eVxuICBjb25zdCBncm91bmRMYXRlbmN5UGVuYWx0eSA9IChnbG9iYWxMYXRlbmN5UmVxdWlyZW1lbnRFbmFibGVkICYmIHllYXIgPj0gMjAyOCkgPyAzLjAgOiAxLjA7XG5cbiAgLy8gU3BhY2UgTWFudWZhY3R1cmluZzogTWFzcyByZWR1Y3Rpb25cbiAgbGV0IG1hc3NNdWx0aXBsaWVyID0gMS4wO1xuICBpZiAoc3BhY2VNYW51ZmFjdHVyaW5nRW5hYmxlZCAmJiB5ZWFyID49IDIwMzIpIHtcbiAgICBjb25zdCB5ZWFyc1NpbmNlU3RhcnQgPSB5ZWFyIC0gMjAzMjtcbiAgICBjb25zdCByYW1wID0gTWF0aC5taW4oMS4wLCB5ZWFyc1NpbmNlU3RhcnQgLyA1KTtcbiAgICBtYXNzTXVsdGlwbGllciA9IDEuMCAtICgwLjYwICogcmFtcCk7XG4gIH1cblxuICAvLyBFTUVSR0VOQ1kgRklYOiBVc2Ugc2ltcGxlIGZpeGVkIDIwMjUgYmFzZSB2YWx1ZXNcbiAgLy8gVGhlc2UgYXJlIHRoZSBrbm93bi1jb3JyZWN0IHZhbHVlcyBmcm9tIHRoZSBlbWVyZ2VuY3kgZml4XG4gIC8vIERvbid0IHRyeSB0byBjYWxjdWxhdGUgZnJvbSBmbG9wc1BlcldhdHQgLSBqdXN0IHVzZSB0aGVzZSBjb25zdGFudHNcbiAgY29uc3QgQkFTRV9FTkVSR1lfMjAyNSA9IDU4MTsgICAgICAvLyAkL1BGTE9QLXllYXIgKGZpeGVkIDIwMjUgYmFzZSlcbiAgY29uc3QgQkFTRV9TSVRFXzIwMjUgPSAxNTAwOyAgICAgIC8vICQvUEZMT1AteWVhciAoZml4ZWQgMjAyNSBiYXNlKVxuICBjb25zdCBFTkVSR1lfQ09TVF9CQVNFXzIwMjUgPSBCQVNFX0VORVJHWV8yMDI1OyAvLyBVc2UgZml4ZWQgYmFzZSwgbm90IGNhbGN1bGF0ZWRcbiAgXG4gIC8vIEZvciByZWZlcmVuY2UvZGlzcGxheSAobm90IHVzZWQgaW4gY29uc3RyYWludCBjYWxjdWxhdGlvbilcbiAgY29uc3QgQkFTRV9FTEVDVFJJQ0lUWV9QUklDRV8yMDI1ID0gMTIwOyAvLyAkL01XaCAoMjAyNSBiYXNlbGluZSlcbiAgbGV0IGdyb3VuZEVsZWN0cmljaXR5UHJpY2VQZXJNd2ggPSBCQVNFX0VMRUNUUklDSVRZX1BSSUNFXzIwMjU7IFxuICBpZiAoIXBhcmFtcy5pc1N0YXRpY01vZGUpIHtcbiAgICBncm91bmRFbGVjdHJpY2l0eVByaWNlUGVyTXdoICo9IE1hdGgucG93KDEuMDIsIHllYXIgLSAyMDI1KTtcbiAgfVxuICBcbiAgY29uc3QgZWZmZWN0aXZlUHVlR3JvdW5kID0gcHVlR3JvdW5kICsgKCh5ZWFyIC0gMjAyNSkgKiAwLjAxKTtcbiAgLy8gQ29udmVydCBHRkxPUFMvVyB0byBwb3dlcjogMSBQRkxPUCA9IDFlNiBHRkxPUFMsIHNvIHBvd2VyIChXKSA9ICgxZTYgR0ZMT1BTKSAvIChHRkxPUFMvVylcbiAgY29uc3QgZ3JvdW5kRW5lcmd5TVdoUGVyUGZsb3BZZWFyID0gKDg3NjAgKiAxZTYgLyBncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXKSAqIGVmZmVjdGl2ZVB1ZUdyb3VuZCAvIDFlNjtcbiAgY29uc3QgZ3JvdW5kRW5lcmd5Q29zdFBlclBmbG9wWWVhciA9IGdyb3VuZEVuZXJneU1XaFBlclBmbG9wWWVhciAqIChncm91bmRFbGVjdHJpY2l0eVByaWNlUGVyTXdoKSAqIGNhcGFjaXR5RmFjdG9yR3JvdW5kO1xuXG4gIGNvbnN0IGNvbXB1dGVHcm91bmRIYXJkd2FyZUNvc3QgPSAoeTogbnVtYmVyLCBiYXNlQ29zdDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgeWVhckluZGV4ID0geSAtIDIwMjU7XG4gICAgbGV0IGNvc3QgPSBiYXNlQ29zdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHllYXJJbmRleDsgaSsrKSB7XG4gICAgICBsZXQgYW5udWFsRGVjbGluZTtcbiAgICAgIGlmIChpIDwgMykgYW5udWFsRGVjbGluZSA9IDAuMTA7XG4gICAgICBlbHNlIGlmIChpIDwgNikgYW5udWFsRGVjbGluZSA9IDAuMDU7XG4gICAgICBlbHNlIGlmIChpIDwgMTApIGFubnVhbERlY2xpbmUgPSAwLjAyO1xuICAgICAgZWxzZSBhbm51YWxEZWNsaW5lID0gMC4wMDU7XG4gICAgICBjb3N0ICo9ICgxIC0gYW5udWFsRGVjbGluZSk7XG4gICAgfVxuICAgIHJldHVybiBjb3N0O1xuICB9O1xuICBjb25zdCBncm91bmRMaWZldGltZSA9IHBhcmFtcy5ncm91bmRIYXJkd2FyZUxpZmV0aW1lWWVhcnMgPz8gQ09OU1RBTlRTLkdST1VORF9IQVJEV0FSRV9MSUZFVElNRTtcbiAgY29uc3QgZ3JvdW5kSGFyZHdhcmVDYXBleFBlclBmbG9wWWVhciA9IGNvbXB1dGVHcm91bmRIYXJkd2FyZUNvc3QoeWVhciwgQ09OU1RBTlRTLkdST1VORF9IQVJEV0FSRV9DT1NUX1BGTE9QXzIwMjUpIC8gZ3JvdW5kTGlmZXRpbWU7XG5cbiAgY29uc3Qgc21yUGFyYW1zID0gcGFyYW1zLnNtclRvZ2dsZUVuYWJsZWQgPyAocGFyYW1zLnNtclRvZ2dsZVBhcmFtcyB8fCBERUZBVUxUX1NNUl9QQVJBTVMpIDogdW5kZWZpbmVkO1xuICBcbiAgbGV0IGdyb3VuZFJlc3VsdDtcbiAgbGV0IGdyb3VuZFRvdGFsQ29zdDogbnVtYmVyO1xuICBsZXQgZ3JvdW5kQ29tcGFyYXRvckNvc3RQZXJQZmxvcFllYXI6IG51bWJlcjsgLy8gQ29tcGFyYXRvciBjb3N0IGZvciBjcm9zc292ZXIgKHVzZXMgZWZmZWN0aXZlIHdoZW4gcXVldWUgZXhpc3RzKVxuICBsZXQgZ3JvdW5kSGFzUXVldWU6IGJvb2xlYW4gPSBmYWxzZTsgLy8gVHJhY2sgaWYgZ3JvdW5kIGhhcyBxdWV1ZS9iYWNrbG9nIChmb3IgZGVidWcgYW5kIGNvbXBhcmF0b3IgY29zdClcbiAgbGV0IGVuZXJneUNvbnN0cmFpbnRNdWx0aXBsaWVyOiBudW1iZXI7XG4gIGxldCBjb25zdHJhaW50QnJlYWtkb3duOiB7XG4gICAgZ3JpZDogbnVtYmVyO1xuICAgIGNvb2xpbmc6IG51bWJlcjtcbiAgICB3YXRlcjogbnVtYmVyO1xuICAgIGxhbmQ6IG51bWJlcjtcbiAgICBlbmVyZ3lNdWx0aXBsaWVyOiBudW1iZXI7XG4gICAgc2l0ZU11bHRpcGxpZXI6IG51bWJlcjtcbiAgICBjYXBhY2l0eURlbGl2ZXJ5TXVsdGlwbGllcj86IG51bWJlcjtcbiAgfTtcbiAgXG4gIGNvbnN0IHVzZVJlZ2lvbmFsTW9kZWwgPSBwYXJhbXMudXNlUmVnaW9uYWxHcm91bmRNb2RlbCA9PT0gdHJ1ZSAmJiBwYXJhbXMuZ3JvdW5kQ29uc3RyYWludHNFbmFibGVkICYmICFwYXJhbXMuaXNTdGF0aWNNb2RlO1xuICBcbiAgLy8gRklYOiBNYWtlIGJ1aWxkb3V0IG1vZGVsIHRoZSBkZWZhdWx0IChpdCBjb3JyZWN0bHkgdXNlcyByZXNwb25zaXZlIGRlbWFuZClcbiAgLy8gUXVldWUgbW9kZWwgcmVxdWlyZXMgZnVsbCBkZW1hbmQgdHJhamVjdG9yeSB0byB3b3JrIGNvcnJlY3RseSwgc28gaXQncyBvcHQtaW4gb25seVxuICAvLyBPbmx5IHVzZSBxdWV1ZSBtb2RlbCBpZiBleHBsaWNpdGx5IGVuYWJsZWQgKHVzZVF1ZXVlQmFzZWRDb25zdHJhaW50ID09PSB0cnVlKVxuICBjb25zdCB1c2VRdWV1ZU1vZGVsID0gcGFyYW1zLnVzZVF1ZXVlQmFzZWRDb25zdHJhaW50ID09PSB0cnVlICYmIHBhcmFtcy5ncm91bmRDb25zdHJhaW50c0VuYWJsZWQgJiYgIXBhcmFtcy5pc1N0YXRpY01vZGUgJiYgIXVzZVJlZ2lvbmFsTW9kZWw7XG4gIC8vIEJ1aWxkb3V0IG1vZGVsIGlzIHRoZSBkZWZhdWx0IChkZWZhdWx0cyB0byB0cnVlIHVubGVzcyBleHBsaWNpdGx5IGRpc2FibGVkKVxuICBjb25zdCB1c2VCdWlsZG91dE1vZGVsID0gKHBhcmFtcy51c2VCdWlsZG91dE1vZGVsICE9PSBmYWxzZSkgJiYgcGFyYW1zLmdyb3VuZENvbnN0cmFpbnRzRW5hYmxlZCAmJiAhcGFyYW1zLmlzU3RhdGljTW9kZSAmJiAhdXNlUmVnaW9uYWxNb2RlbCAmJiAhdXNlUXVldWVNb2RlbDtcbiAgXG4gIGlmICh1c2VRdWV1ZU1vZGVsKSB7XG4gICAgLy8gV0FSTklORzogUXVldWUgbW9kZWwgcmVxdWlyZXMgZnVsbCBkZW1hbmQgdHJhamVjdG9yeSB0byB3b3JrIGNvcnJlY3RseVxuICAgIC8vIEN1cnJlbnRseSBvbmx5IHJlY2VpdmVzIGN1cnJlbnQgeWVhcidzIHJlc3BvbnNpdmUgZGVtYW5kLCBzbyBwcmV2aW91cyB5ZWFycyB1c2UgaGFyZGNvZGVkIGRlbWFuZFxuICAgIC8vIFJFQ09NTUVOREVEOiBVc2UgYnVpbGRvdXQgbW9kZWwgaW5zdGVhZCAoZGVmYXVsdCkgd2hpY2ggY29ycmVjdGx5IGhhbmRsZXMgcmVzcG9uc2l2ZSBkZW1hbmRcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFtRVUVVRSBNT0RFTF0gWWVhciAke3llYXJ9OiBRdWV1ZSBtb2RlbCBpcyBlbmFibGVkIGJ1dCBvbmx5IHJlY2VpdmVzIGN1cnJlbnQgeWVhcidzIHJlc3BvbnNpdmUgZGVtYW5kLiBgICtcbiAgICAgICAgYFByZXZpb3VzIHllYXJzICgyMDI1LSR7eWVhci0xfSkgd2lsbCB1c2UgaGFyZGNvZGVkIGV4cG9uZW50aWFsIGRlbWFuZC4gYCArXG4gICAgICAgIGBGb3IgYWNjdXJhdGUgUy1jdXJ2ZSBiZWhhdmlvciwgdXNlIGJ1aWxkb3V0IG1vZGVsIChkZWZhdWx0KSBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIC8vIFBhc3MgcmVzcG9uc2l2ZSBkZW1hbmQgYW5kIG9yYml0YWwgc3Vic3RpdHV0aW9uIHRvIHF1ZXVlIG1vZGVsIChpZiBhdmFpbGFibGUgZnJvbSB0cmFqZWN0b3J5LnRzKVxuICAgIGNvbnN0IHJlc3BvbnNpdmVEZW1hbmRHVyA9IChwYXJhbXMgYXMgYW55KS5yZXNwb25zaXZlRGVtYW5kR1cgYXMgbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9yYml0YWxTdWJzdGl0dXRpb25HVyA9IChwYXJhbXMgYXMgYW55KS5vcmJpdGFsU3Vic3RpdHV0aW9uR1cgYXMgbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIFxuICAgIC8vIEJ1aWxkIGRlbWFuZCBtYXAgaWYgcmVzcG9uc2l2ZSBkZW1hbmQgaXMgcHJvdmlkZWRcbiAgICAvLyBOT1RFOiBPbmx5IGN1cnJlbnQgeWVhciBpcyBwYXNzZWQgLSBwcmV2aW91cyB5ZWFycyB3aWxsIHVzZSBoYXJkY29kZWQgZGVtYW5kXG4gICAgY29uc3QgZGVtYW5kQnlZZWFyID0gcmVzcG9uc2l2ZURlbWFuZEdXICE9PSB1bmRlZmluZWQgXG4gICAgICA/IG5ldyBNYXAoW1t5ZWFyLCByZXNwb25zaXZlRGVtYW5kR1ddXSlcbiAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9yYml0YWxTdWJzdGl0dXRpb25CeVllYXIgPSBvcmJpdGFsU3Vic3RpdHV0aW9uR1cgIT09IHVuZGVmaW5lZFxuICAgICAgPyBuZXcgTWFwKFtbeWVhciwgb3JiaXRhbFN1YnN0aXR1dGlvbkdXXV0pXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICBcbiAgICBjb25zdCBzdXBwbHlUcmFqZWN0b3J5ID0gZ2VuZXJhdGVHcm91bmRTdXBwbHlUcmFqZWN0b3J5KDIwMjUsIHllYXIsIGRlbWFuZEJ5WWVhciwgb3JiaXRhbFN1YnN0aXR1dGlvbkJ5WWVhcik7XG4gICAgY29uc3QgY3VycmVudFN1cHBseVN0YXRlID0gc3VwcGx5VHJhamVjdG9yeVtzdXBwbHlUcmFqZWN0b3J5Lmxlbmd0aCAtIDFdO1xuICAgIFxuICAgIC8vIERlYnVnOiBMb2cgaWYgcmVzcG9uc2l2ZSBkZW1hbmQgaXMgYmVpbmcgdXNlZFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiByZXNwb25zaXZlRGVtYW5kR1cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgaGFyZGNvZGVkRGVtYW5kID0gZ2V0R2xvYmFsRGVtYW5kR3coeWVhcik7XG4gICAgICBpZiAoTWF0aC5hYnMoY3VycmVudFN1cHBseVN0YXRlLmRlbWFuZEd3IC0gaGFyZGNvZGVkRGVtYW5kKSA8IDFlLTYpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBbUVVFVUUgTU9ERUwgREVCVUddIFllYXIgJHt5ZWFyfTogUmVzcG9uc2l2ZSBkZW1hbmQgKCR7cmVzcG9uc2l2ZURlbWFuZEdXLnRvRml4ZWQoMil9IEdXKSB3YXMgaWdub3JlZC4gYCArXG4gICAgICAgICAgYFF1ZXVlIG1vZGVsIHVzaW5nIGhhcmRjb2RlZDogJHtjdXJyZW50U3VwcGx5U3RhdGUuZGVtYW5kR3cudG9GaXhlZCgyKX0gR1dgXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgW1FVRVVFIE1PREVMIERFQlVHXSBZZWFyICR7eWVhcn06IFVzaW5nIHJlc3BvbnNpdmUgZGVtYW5kICR7cmVzcG9uc2l2ZURlbWFuZEdXLnRvRml4ZWQoMil9IEdXIGAgK1xuICAgICAgICAgIGAocXVldWUgbW9kZWw6ICR7Y3VycmVudFN1cHBseVN0YXRlLmRlbWFuZEd3LnRvRml4ZWQoMil9IEdXKWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIFdBQ0MtYmFzZWQgcGVuYWx0aWVzIGFuZCBtdWx0aXBsaWVyc1xuICAgIC8vIFBhc3MgV0FDQyBwYXJhbWV0ZXJzIGZvciBjYXBpdGFsIHJhdGlvbmluZyAoV0FDQyByaXNlcyB3aXRoIGJhY2tsb2cpXG4gICAgY29uc3Qgd2FjY1BhcmFtcyA9IHtcbiAgICAgIGJhc2VXYWNjOiBwYXJhbXMud2FjYyA/PyAwLjEwLFxuICAgICAgd2FjY0JhY2tsb2dLOiBwYXJhbXMud2FjY0JhY2tsb2dLID8/IDAuNSxcbiAgICAgIHdhY2NCYWNrbG9nRXhwb25lbnQ6IHBhcmFtcy53YWNjQmFja2xvZ0V4cG9uZW50ID8/IDEuMixcbiAgICAgIGNyaXRpY2FsQmFja2xvZ0dXOiBwYXJhbXMuY3JpdGljYWxCYWNrbG9nR1cgPz8gNTAsXG4gICAgfTtcbiAgICBjb25zdCBwZW5hbHRpZXMgPSBjYWxjdWxhdGVHcm91bmRDb25zdHJhaW50UGVuYWx0aWVzKFxuICAgICAgY3VycmVudFN1cHBseVN0YXRlLFxuICAgICAgZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyVyxcbiAgICAgIGVmZmVjdGl2ZVB1ZUdyb3VuZCxcbiAgICAgIGNhcGFjaXR5RmFjdG9yR3JvdW5kLFxuICAgICAgd2FjY1BhcmFtc1xuICAgICk7XG4gICAgXG4gICAgY29uc3QgQkFTRV9TSVRFXzIwMjUgPSAxNTAwO1xuICAgIFxuICAgIC8vIEVuZXJneSBjb3N0OiBVc2UgYWN0dWFsIGNhbGN1bGF0ZWQgdmFsdWUgKE5PVCBtdWx0aXBsaWVkIGJ5IGNvbnN0cmFpbnQpXG4gICAgLy8gQ1JJVElDQUwgRklYOiBEbyBOT1QgYXBwbHkgUFVFIG11bHRpcGxpZXIgLSBlbmVyZ3kgY29zdCBpcyBiYXNlIG9ubHlcbiAgICAvLyBQVUUgc3RyZXNzIHNob3VsZCBiZSByZWZsZWN0ZWQgaW4gY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0sIG5vdCBlbmVyZ3kgbXVsdGlwbGllclxuICAgIGNvbnN0IGVuZXJneUNvc3RCYXNlID0gZ3JvdW5kRW5lcmd5Q29zdFBlclBmbG9wWWVhcjtcbiAgICBjb25zdCBlbmVyZ3lDb3N0ID0gZW5lcmd5Q29zdEJhc2U7IC8vIEJhc2UgZW5lcmd5IGNvc3Qgb25seSAtIG5vIG11bHRpcGxpZXJcbiAgICBcbiAgICAvLyBHUk9VTkQgQ09TVCBBQ0NPVU5USU5HOiBFeHBsaWNpdCBzZXBhcmF0aW9uIG9mIGNvbXBvbmVudHMgKHF1ZXVlIG1vZGVsKVxuICAgIGNvbnN0IHNpdGVDb3N0QmFzZSA9IEJBU0VfU0lURV8yMDI1O1xuICAgIFxuICAgIC8vIDEuIHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyOiBQdXJlIGFtb3J0aXplZCBjYXBleCAoTk9UIGFmZmVjdGVkIGJ5IGNvbnN0cmFpbnQpXG4gICAgY29uc3Qgc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgPSBzaXRlQ29zdEJhc2U7XG4gICAgXG4gICAgLy8gQ0hPSUNFOiBVc2UgZGVsYXlQZW5hbHR5ICsgc2NhcmNpdHlSZW50IChIaWxsLWJhc2VkKSwgTk9UIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtXG4gICAgLy8gU2V0IGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtIHRvIDAgdG8gYXZvaWQgdHJpcGxlLWNoYXJnaW5nXG4gICAgY29uc3QgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXIgPSAwOyAvLyBOT1QgVVNFRCAtIHVzaW5nIGRlbGF5UGVuYWx0eSArIHNjYXJjaXR5UmVudCBpbnN0ZWFkXG4gICAgXG4gICAgLy8gMS4gdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyOiBCb3VuZGVkIGxpbmVhciBXQUNDIGNhcnJ5IChOT1QgZXhwb25lbnRpYWwpXG4gICAgY29uc3QgdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyID0gcGVuYWx0aWVzLnRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhcjtcbiAgICBcbiAgICAvLyAyLiBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXI6IEhpbGwgZnVuY3Rpb24gb2YgYXZnV2FpdFllYXJzICh3NTA9Mi4wLCBuPTIuMCwgcmVudE1heD0wLjY1KVxuICAgIC8vIEJhc2UgY29zdCBmb3Igc2NhcmNpdHkgcmVudCA9IGhhcmR3YXJlICsgc2l0ZSAobm8gY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0pXG4gICAgY29uc3QgY2FwZXhBbm51YWxCYXNlUGVyUGZsb3BZZWFyID0gXG4gICAgICBncm91bmRIYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyICtcbiAgICAgIHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBzY2FyY2l0eSBtdWx0aXBsaWVyIHVzaW5nIExPRy1CQVNFRCBmdW5jdGlvbiAobmV2ZXIgZnVsbHkgc2F0dXJhdGVzKVxuICAgIC8vIFJldHVybnMgbXVsdGlwbGllciAoMS4wID0gbm8gc2NhcmNpdHksIDIuMCA9IDJ4IHByaWNlKSAtIE1VTFRJUExJQ0FUSVZFLCBub3QgYWRkaXRpdmVcbiAgICBjb25zdCBzY2FyY2l0eVJlbnRSZXN1bHQgPSBjYWxjdWxhdGVTY2FyY2l0eVJlbnQoXG4gICAgICBjdXJyZW50U3VwcGx5U3RhdGUuYXZnV2FpdFllYXJzLFxuICAgICAgY3VycmVudFN1cHBseVN0YXRlLnV0aWxpemF0aW9uUGN0LCAvLyBQYXNzIHV0aWxpemF0aW9uIGZvciB0aHJlc2hvbGQgZ2F0ZVxuICAgICAge1xuICAgICAgICB3YWl0VGhyZXNob2xkWWVhcnM6IDEuMCwgLy8gTWluaW11bSB3YWl0IGJlZm9yZSBzY2FyY2l0eSBhY3RpdmF0ZXNcbiAgICAgICAgcmVudE1heE11bHRpcGxpZXI6IDIuMCwgLy8gTWF4aW11bSBwcmljZSBtdWx0aXBsaWVyICgyeCA9IDEwMCUgaW5jcmVhc2UpXG4gICAgICAgIHV0aWxpemF0aW9uVGhyZXNob2xkOiAwLjg1LCAvLyBVdGlsaXphdGlvbiB0aHJlc2hvbGRcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IHNjYXJjaXR5TXVsdGlwbGllciA9IHNjYXJjaXR5UmVudFJlc3VsdC5zY2FyY2l0eU11bHRpcGxpZXI7XG4gICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IHNjYXJjaXR5UmVudFBlclBmbG9wWWVhciA9IDAgKHNjYXJjaXR5IGlzIG5vdyBtdWx0aXBsaWNhdGl2ZSlcbiAgICBjb25zdCBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXIgPSAwO1xuICAgIFxuICAgIC8vIERlYnVnOiB2ZXJpZnkgcXVldWUgbW9kZWwgY29uc2lzdGVuY3lcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGNvbnN0IHVuc2VydmVkR3cgPSBjdXJyZW50U3VwcGx5U3RhdGUudW5zZXJ2ZWRHdyA/PyAoY3VycmVudFN1cHBseVN0YXRlLmRlbWFuZEd3IC0gY3VycmVudFN1cHBseVN0YXRlLmNhcGFjaXR5R3cpO1xuICAgICAgaWYgKGN1cnJlbnRTdXBwbHlTdGF0ZS5kZW1hbmRHdyA8IGN1cnJlbnRTdXBwbHlTdGF0ZS5jYXBhY2l0eUd3ICYmIGN1cnJlbnRTdXBwbHlTdGF0ZS5iYWNrbG9nR3cgPiA1MCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFtRVUVVRSBNT0RFTF0gWWVhciAke3llYXJ9OiBkZW1hbmRHdz0ke2N1cnJlbnRTdXBwbHlTdGF0ZS5kZW1hbmRHdy50b0ZpeGVkKDEpfSA8IGNhcGFjaXR5R3c9JHtjdXJyZW50U3VwcGx5U3RhdGUuY2FwYWNpdHlHdy50b0ZpeGVkKDEpfSBgICtcbiAgICAgICAgICBgYnV0IGJhY2tsb2dHdz0ke2N1cnJlbnRTdXBwbHlTdGF0ZS5iYWNrbG9nR3cudG9GaXhlZCgxKX0gPiA1MC4gVGhpcyBtYXkgaW5kaWNhdGUgcXVldWUgbW9kZWwgaXNzdWUuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDUklUSUNBTDogUmVtb3ZlIGRvdWJsZSBjb3VudGluZ1xuICAgIC8vIERvIE5PVCBpbmNsdWRlIHRpbWVUb0VuZXJnaXplUGVuYWx0eSArIHNjYXJjaXR5UmVudCBpbiBoZWFkbGluZSBjb3N0IHVzZWQgZm9yIGNyb3Nzb3ZlclxuICAgIC8vIChjYXBhY2l0eSBnYXRpbmcgaW4gbWFya2V0IHNoYXJlIGFscmVhZHkgYWNjb3VudHMgZm9yIGJhY2tsb2cpXG4gICAgLy8gQ29tcHV0ZSBib3RoIGJhc2UgYW5kIGVmZmVjdGl2ZSBjb3N0czpcbiAgICBjb25zdCBzaXRlQ29zdFBlclBmbG9wWWVhcl9iYXNlID0gc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXI7IC8vIE5vIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtXG4gICAgY29uc3Qgc2l0ZUNvc3RQZXJQZmxvcFllYXJfZWZmZWN0aXZlID0gc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgKyB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgKyBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXI7XG4gICAgXG4gICAgLy8gVmFsaWRhdGlvblxuICAgIGNvbnN0IGV4cGVjdGVkRWZmZWN0aXZlID0gc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgKyBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhciArIHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciArIHNjYXJjaXR5UmVudFBlclBmbG9wWWVhcjtcbiAgICBjb25zdCBzaXRlQ29zdENoZWNrID0gTWF0aC5hYnMoc2l0ZUNvc3RQZXJQZmxvcFllYXJfZWZmZWN0aXZlIC0gZXhwZWN0ZWRFZmZlY3RpdmUpO1xuICAgIGlmIChzaXRlQ29zdENoZWNrID4gMC4wMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaXRlIGNvc3QgYWNjb3VudGluZyBlcnJvciAocXVldWUgbW9kZWwpOiBzaXRlQ29zdF9lZmZlY3RpdmU9JHtzaXRlQ29zdFBlclBmbG9wWWVhcl9lZmZlY3RpdmV9ICE9IHN1bShjb21wb25lbnRzKT0ke2V4cGVjdGVkRWZmZWN0aXZlfSAoc2l0ZUNhcGV4PSR7c2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXJ9LCBwcmVtaXVtPSR7Y2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXJ9LCBkZWxheT0ke3RpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhcn0sIHNjYXJjaXR5PSR7c2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyfSksIGRpZmY9JHtzaXRlQ29zdENoZWNrfWApO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBoYXJkd2FyZUNvc3QgPSBncm91bmRIYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyO1xuICAgIFxuICAgIC8vIFVOSUZJRUQgU0NBUkNJVFkgQUNDT1VOVElORzogS2VlcCB0b3RhbENvc3RQZXJQZmxvcFllYXIgcGh5c2ljYWwtb25seVxuICAgIC8vIFNjYXJjaXR5IChkZWxheVBlbmFsdHkgKyBzY2FyY2l0eVJlbnQpIGlzIHRyZWF0ZWQgcHVyZWx5IGluIEdQVS1ob3VyIHByaWNpbmcsIG5vdCBpbiBQRkxPUC15ZWFyIGNvc3RcbiAgICBncm91bmRUb3RhbENvc3QgPSAoZW5lcmd5Q29zdCArIHNpdGVDb3N0UGVyUGZsb3BZZWFyX2Jhc2UgKyBoYXJkd2FyZUNvc3QpICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHk7XG4gICAgXG4gICAgLy8gRm9yIGNyb3Nzb3ZlcjogdXNlIGJhc2UgY29zdCAoc2NhcmNpdHkgaXMgYWxyZWFkeSByZWZsZWN0ZWQgaW4gR1BVLWhvdXIgcHJpY2luZylcbiAgICAvLyBUaGlzIGVuc3VyZXMgd2UgZG9uJ3QgZG91YmxlLWNvdW50IHNjYXJjaXR5XG4gICAgZ3JvdW5kSGFzUXVldWUgPSB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgPiAwLjAxO1xuICAgIGdyb3VuZENvbXBhcmF0b3JDb3N0UGVyUGZsb3BZZWFyID0gZ3JvdW5kVG90YWxDb3N0OyAvLyBCYXNlIGNvc3Qgb25seSAoc2NhcmNpdHkgaW4gR1BVLWhvdXIpXG4gICAgXG4gICAgLy8gQ1JJVElDQUwgRklYOiBSZW1vdmUgYWxsIG11bHRpcGxpZXJzIC0gdXNlIGFkZGl0aXZlIHRlcm1zIG9ubHlcbiAgICAvLyBNdWx0aXBsaWVycyBhcmUgTk9UIGFwcGxpZWQgdG8gYW55IGRvbGxhciBhbW91bnRzXG4gICAgLy8gQWxsIGNvbnN0cmFpbnQgZWZmZWN0cyBhcmUgY2FwdHVyZWQgaW4gY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gYW5kIHRpbWVUb0VuZXJnaXplUGVuYWx0eVxuICAgIGVuZXJneUNvbnN0cmFpbnRNdWx0aXBsaWVyID0gMS4wOyAvLyBOZXZlciBhcHBsaWVkIC0gZm9yIGJhY2t3YXJkIGNvbXBhdCBvbmx5XG4gICAgXG4gICAgLy8gQ29uc3RyYWludCBicmVha2Rvd246IGFsbCBtdWx0aXBsaWVycyBzZXQgdG8gMS4wIChub3QgYXBwbGllZClcbiAgICAvLyBUaGVzZSBhcmUga2VwdCBmb3IgZGVidWcvZGVjb21wb3NpdGlvbiBidXQgbmV2ZXIgbXVsdGlwbGllZCBpbnRvIGNvc3RzXG4gICAgY29uc3RyYWludEJyZWFrZG93biA9IHtcbiAgICAgIGdyaWQ6IDEuMCwgLy8gTm90IGFwcGxpZWQgLSBjb25zdHJhaW50IGVmZmVjdHMgaW4gY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1cbiAgICAgIGNvb2xpbmc6IDEuMCwgLy8gTm90IGFwcGxpZWQgLSBjb25zdHJhaW50IGVmZmVjdHMgaW4gY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1cbiAgICAgIHdhdGVyOiAxLjAsIC8vIE5vdCBhcHBsaWVkIC0gY29uc3RyYWludCBlZmZlY3RzIGluIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtXG4gICAgICBsYW5kOiAxLjAsIC8vIE5vdCBhcHBsaWVkIC0gY29uc3RyYWludCBlZmZlY3RzIGluIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtXG4gICAgICBlbmVyZ3lNdWx0aXBsaWVyOiAxLjAsIC8vIE5ldmVyIGFwcGxpZWQgLSBlbmVyZ3kgY29zdCBpcyBiYXNlIG9ubHlcbiAgICAgIHNpdGVNdWx0aXBsaWVyOiAxLjAsIC8vIE5vdCBhcHBsaWVkIC0gY29uc3RyYWludCBlZmZlY3RzIGluIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtXG4gICAgICBjYXBhY2l0eURlbGl2ZXJ5TXVsdGlwbGllcjogMS4wLCAvLyBOb3QgYXBwbGllZCAtIGNvbnN0cmFpbnQgZWZmZWN0cyBpbiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVxuICAgIH07XG4gICAgXG4gICAgZ3JvdW5kUmVzdWx0ID0ge1xuICAgICAgZW5lcmd5Q29zdDogZW5lcmd5Q29zdCAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LCAvLyBFbmVyZ3kgd2l0aCBQVUUgbXVsdGlwbGllclxuICAgICAgc2l0ZUNvc3Q6IHNpdGVDb3N0UGVyUGZsb3BZZWFyX2Jhc2UgKiBncm91bmRMYXRlbmN5UGVuYWx0eSwgLy8gU2l0ZSA9IGJhc2UgY29tcG9uZW50cyAoZXhjbHVkZXMgZGVsYXkgcGVuYWx0eSlcbiAgICAgIGhhcmR3YXJlQ29zdDogaGFyZHdhcmVDb3N0ICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhcjogc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSwgLy8gRXhwbGljaXQ6IHB1cmUgY2FwZXhcbiAgICAgIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtOiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LCAvLyBFeHBsaWNpdDogc2NhcmNpdHkgcHJlbWl1bVxuICAgICAgdGltZVRvRW5lcmdpemVQZW5hbHR5OiB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSwgLy8gRXhwbGljaXQ6IFdBQ0MtYmFzZWQgcGVuYWx0eSAobm90IGluIGhlYWRsaW5lIGNvc3QpXG4gICAgICB0b3RhbENvc3RQZXJQZmxvcFllYXI6IGdyb3VuZFRvdGFsQ29zdCwgLy8gUGh5c2ljYWwgY29zdHMgb25seSAoc2NhcmNpdHkgdHJlYXRlZCBpbiBHUFUtaG91ciBwcmljaW5nKVxuICAgICAgdG90YWxDb3N0UGVyUGZsb3BZZWFyRWZmZWN0aXZlOiBncm91bmRUb3RhbENvc3QsIC8vIFNhbWUgYXMgYmFzZSAoc2NhcmNpdHkgaW4gR1BVLWhvdXIsIG5vdCBQRkxPUC15ZWFyKVxuICAgICAgdG90YWxDb3N0UGVyUGZsb3BZZWFyQWxsSW46IGdyb3VuZFRvdGFsQ29zdCwgLy8gU2FtZSBhcyBiYXNlIChzY2FyY2l0eSBpbiBHUFUtaG91ciwgbm90IFBGTE9QLXllYXIpXG4gICAgICBjb25zdHJhaW50TXVsdGlwbGllcjogMS4wLCAvLyBOT1QgQVBQTElFRCAtIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdCBvbmx5XG4gICAgICBicmVha2Rvd246IGNvbnN0cmFpbnRCcmVha2Rvd24sXG4gICAgICBjb25zdHJhaW50czoge1xuICAgICAgICBtZXRob2Q6ICdhZGRlcnMnLFxuICAgICAgICBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bTogY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSwgLy8gU2V0IHRvIDAgKG5vdCB1c2VkKVxuICAgICAgICBkZWxheVBlbmFsdHk6IHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LCAvLyBCb3VuZGVkIGxpbmVhciBXQUNDIGNhcnJ5XG4gICAgICAgIHNjYXJjaXR5UmVudFBlclBmbG9wWWVhcjogc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksIC8vIEJhY2t3YXJkIGNvbXBhdCAobm93IDAsIHNjYXJjaXR5IGlzIG11bHRpcGxpY2F0aXZlKVxuICAgICAgICBzY2FyY2l0eU11bHRpcGxpZXI6IHNjYXJjaXR5TXVsdGlwbGllciwgLy8gTXVsdGlwbGljYXRpdmUgc2NhcmNpdHkgKDEuMCA9IG5vIHNjYXJjaXR5LCAyLjAgPSAyeCBwcmljZSlcbiAgICAgICAgYXBwbGllZE11bHRpcGxpZXJzOiB7XG4gICAgICAgICAgY29uc3RyYWludE11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgICBlbmVyZ3lNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgICAgc2l0ZU11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRGVidWcgZmllbGRzIGZvciBIaWxsLWJhc2VkIHNjYXJjaXR5IHJlbnQgKHdhaXQtdGltZSBiYXNlZClcbiAgICAgICAgc2NhcmNpdHlIaWxsOiBzY2FyY2l0eVJlbnRSZXN1bHQuc2NhcmNpdHlIaWxsLFxuICAgICAgICBhdmdXYWl0WWVhcnNSYXc6IGN1cnJlbnRTdXBwbHlTdGF0ZS5hdmdXYWl0WWVhcnNSYXcgPz8gY3VycmVudFN1cHBseVN0YXRlLmF2Z1dhaXRZZWFycyxcbiAgICAgICAgYXZnV2FpdFllYXJzQ2xhbXBlZDogc2NhcmNpdHlSZW50UmVzdWx0LmF2Z1dhaXRZZWFyc0NsYW1wZWQsXG4gICAgICAgIHJlbnRGcmFjOiBzY2FyY2l0eVJlbnRSZXN1bHQucmVudEZyYWMsXG4gICAgICAgIC8vIEFkZGl0aW9uYWwgZGVidWcgZmllbGRzIGZvciB2ZXJpZmljYXRpb25cbiAgICAgICAgYmFja2xvZ0d3OiBjdXJyZW50U3VwcGx5U3RhdGUuYmFja2xvZ0d3LFxuICAgICAgICB1bnNlcnZlZEd3OiBjdXJyZW50U3VwcGx5U3RhdGUudW5zZXJ2ZWRHdyA/PyAwLFxuICAgICAgICBkZWxpdmVyZWRGcm9tQmFja2xvZ0d3OiBjdXJyZW50U3VwcGx5U3RhdGUuZGVsaXZlcmVkRnJvbUJhY2tsb2dHdyA/PyAwLFxuICAgICAgICBiYXNlQ29zdFBlclBmbG9wWWVhcjogY2FwZXhBbm51YWxCYXNlUGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhcjogZ3JvdW5kVG90YWxDb3N0LFxuICAgICAgfSxcbiAgICAgIHN1cHBseU1ldHJpY3M6IHtcbiAgICAgICAgZGVtYW5kR3c6IGN1cnJlbnRTdXBwbHlTdGF0ZS5kZW1hbmRHdyxcbiAgICAgICAgY2FwYWNpdHlHdzogY3VycmVudFN1cHBseVN0YXRlLmNhcGFjaXR5R3csXG4gICAgICAgIHBpcGVsaW5lR3c6IGN1cnJlbnRTdXBwbHlTdGF0ZS5waXBlbGluZUd3LFxuICAgICAgICBtYXhCdWlsZFJhdGVHd1llYXI6IGN1cnJlbnRTdXBwbHlTdGF0ZS5tYXhCdWlsZFJhdGVHd1llYXIsXG4gICAgICAgIGF2Z1dhaXRZZWFyczogY3VycmVudFN1cHBseVN0YXRlLmF2Z1dhaXRZZWFycyxcbiAgICAgICAgdXRpbGl6YXRpb25QY3Q6IGN1cnJlbnRTdXBwbHlTdGF0ZS51dGlsaXphdGlvblBjdCxcbiAgICAgICAgLy8gRGVidWcgZmllbGRzIGZvciBxdWV1ZSBtb2RlbCB2ZXJpZmljYXRpb25cbiAgICAgICAgYmFja2xvZ0d3OiBjdXJyZW50U3VwcGx5U3RhdGUuYmFja2xvZ0d3LFxuICAgICAgICB1bnNlcnZlZEd3OiBjdXJyZW50U3VwcGx5U3RhdGUudW5zZXJ2ZWRHdyA/PyAwLFxuICAgICAgICBkZWxpdmVyZWRGcm9tQmFja2xvZ0d3OiBjdXJyZW50U3VwcGx5U3RhdGUuZGVsaXZlcmVkRnJvbUJhY2tsb2dHdyA/PyAwLFxuICAgICAgICBhdmdXYWl0WWVhcnNSYXc6IGN1cnJlbnRTdXBwbHlTdGF0ZS5hdmdXYWl0WWVhcnNSYXcgPz8gY3VycmVudFN1cHBseVN0YXRlLmF2Z1dhaXRZZWFycyxcbiAgICAgIH0sXG4gICAgICBjb25zdHJhaW50Q29tcG9uZW50czoge1xuICAgICAgICBxdWV1ZVByZXNzdXJlOiBjdXJyZW50U3VwcGx5U3RhdGUuYXZnV2FpdFllYXJzID4gMCA/IDEgKyBjdXJyZW50U3VwcGx5U3RhdGUuYXZnV2FpdFllYXJzIC8gMiA6IDEsXG4gICAgICAgIHV0aWxpemF0aW9uUHJlc3N1cmU6IGN1cnJlbnRTdXBwbHlTdGF0ZS51dGlsaXphdGlvblBjdCA+IDAuODUgPyAxICsgKGN1cnJlbnRTdXBwbHlTdGF0ZS51dGlsaXphdGlvblBjdCAtIDAuODUpICogNSA6IDEsXG4gICAgICAgIHNjYXJjaXR5UHJlbWl1bTogcGVuYWx0aWVzLnNpdGVNdWx0aXBsaWVyLFxuICAgICAgfSxcbiAgICAgIC8vIERlYnVnIGZpZWxkcyBmb3IgV0FDQyBwZW5hbHRpZXNcbiAgICAgIGJhY2tsb2dHdzogcGVuYWx0aWVzLmJhY2tsb2dHdyxcbiAgICAgIGF2Z1dhaXRZZWFyczogcGVuYWx0aWVzLmF2Z1dhaXRZZWFycyxcbiAgICAgIGNhcGV4QXRSaXNrUGVyTVc6IHBlbmFsdGllcy5jYXBleEF0Umlza1Blck1XLFxuICAgICAgY2FycnlDb3N0UGVyTVc6IHBlbmFsdGllcy5jYXJyeUNvc3RQZXJNVyxcbiAgICAgIGxvc3RNYXJnaW5QZXJNVzogcGVuYWx0aWVzLmxvc3RNYXJnaW5QZXJNVyxcbiAgICAgIHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhcjogcGVuYWx0aWVzLnRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhcixcbiAgICAgIHB1ZU11bHRpcGxpZXI6IHBlbmFsdGllcy5wdWVNdWx0aXBsaWVyLFxuICAgICAgc21yRW5hYmxlZDogZmFsc2UsXG4gICAgICBzbXJSYW1wRmFjdG9yOiAwLFxuICAgICAgZWZmZWN0aXZlRWxlY3RyaWNpdHlDb3N0OiBncm91bmRFbGVjdHJpY2l0eVByaWNlUGVyTXdoLFxuICAgICAgY29uc3RyYWludFJlbGllZjogeyBncmlkOiAwLCBjb29saW5nOiAwLCB3YXRlcjogMCwgbGFuZDogMCB9LFxuICAgIH07XG4gIH0gZWxzZSBpZiAodXNlQnVpbGRvdXRNb2RlbCkge1xuICAgIC8vIE5FVzogUmFtcGluZyBNb2JpbGl6YXRpb24gTW9kZWxcbiAgICAvLyBSZXBsYWNlcyBjb25zdHJhaW50IG11bHRpcGxpZXIgd2l0aCBleHBsaWNpdCBidWlsZG91dCBjYXBleCBwcmVtaXVtIGFuZCBkZWxheSBwZW5hbHRpZXNcbiAgICAvLyBVc2VzIHJhbXBpbmcgYnVpbGRvdXQgY2FwYWNpdHkgd2l0aCBzbW9vdGggaW50ZXJwb2xhdGlvblxuICAgIFxuICAgIC8vIEdldCBtb2JpbGl6YXRpb24gcGFyYW1ldGVycyAodXNlIGRlZmF1bHRzIGlmIG5vdCBwcm92aWRlZClcbiAgICBjb25zdCBtb2JpbGl6YXRpb25QYXJhbXM6IE1vYmlsaXphdGlvblNjZW5hcmlvUGFyYW1zID0gcGFyYW1zLm1vYmlsaXphdGlvblBhcmFtcyA/IHtcbiAgICAgIC4uLkRFRkFVTFRfTU9CSUxJWkFUSU9OX1BBUkFNUyxcbiAgICAgIC4uLnBhcmFtcy5tb2JpbGl6YXRpb25QYXJhbXMsXG4gICAgICBkZW1hbmRDdXJ2ZTogKHBhcmFtcy5tb2JpbGl6YXRpb25QYXJhbXMuZGVtYW5kQ3VydmUgfHwgREVGQVVMVF9NT0JJTElaQVRJT05fUEFSQU1TLmRlbWFuZEN1cnZlKSBhcyAncGllY2V3aXNlX2V4cG9uZW50aWFsJyxcbiAgICB9IDogREVGQVVMVF9NT0JJTElaQVRJT05fUEFSQU1TO1xuICAgIFxuICAgIC8vIEdldCBwcmV2aW91cyBtb2JpbGl6YXRpb24gc3RhdGUgZnJvbSBwYXJhbXMgKHBhc3NlZCBmcm9tIHRyYWplY3RvcnkpXG4gICAgLy8gSWYgbm90IHByb3ZpZGVkLCBjYWxjdWxhdGUgZnJvbSBwcmV2aW91cyB5ZWFyJ3MgZGVtYW5kXG4gICAgY29uc3QgcHJldk1vYmlsaXphdGlvblN0YXRlOiBNb2JpbGl6YXRpb25TdGF0ZSB8IG51bGwgPSAocGFyYW1zIGFzIGFueSkucHJldk1vYmlsaXphdGlvblN0YXRlID8/IG51bGw7XG4gICAgXG4gICAgLy8gU3RlcCBtb2JpbGl6YXRpb24gc3RhdGUgZm9yd2FyZFxuICAgIC8vIFBhc3MgcmVzcG9uc2l2ZSBkZW1hbmQgYW5kIG9yYml0YWwgc3Vic3RpdHV0aW9uIGlmIGF2YWlsYWJsZSAoZnJvbSB0cmFqZWN0b3J5LnRzKVxuICAgIGNvbnN0IHJlc3BvbnNpdmVEZW1hbmRHVyA9IChwYXJhbXMgYXMgYW55KS5yZXNwb25zaXZlRGVtYW5kR1cgYXMgbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9yYml0YWxTdWJzdGl0dXRpb25HVyA9IChwYXJhbXMgYXMgYW55KS5vcmJpdGFsU3Vic3RpdHV0aW9uR1cgYXMgbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IG1vYmlsaXphdGlvblJlc3VsdCA9IHN0ZXBNb2JpbGl6YXRpb25TdGF0ZShcbiAgICAgIHByZXZNb2JpbGl6YXRpb25TdGF0ZSxcbiAgICAgIG1vYmlsaXphdGlvblBhcmFtcyxcbiAgICAgIHllYXIsXG4gICAgICBlZmZlY3RpdmVQdWVHcm91bmQsXG4gICAgICAwLCAvLyByZXRpcmVtZW50c0dXID0gMCBmb3Igbm93XG4gICAgICBvcmJpdGFsU3Vic3RpdHV0aW9uR1csIC8vIFBhc3Mgb3JiaXRhbCBzdWJzdGl0dXRpb24gZm9yIGJhY2tsb2cgZHJhaW5cbiAgICAgIHJlc3BvbnNpdmVEZW1hbmRHVyAvLyBQYXNzIHJlc3BvbnNpdmUgZGVtYW5kIChvdmVycmlkZXMgaGFyZGNvZGVkKVxuICAgICk7XG4gICAgXG4gICAgLy8gRXh0cmFjdCB2YWx1ZXMgZnJvbSBtb2JpbGl6YXRpb24gbW9kZWxcbiAgICBjb25zdCBkZW1hbmROZXdHVyA9IG1vYmlsaXphdGlvblJlc3VsdC5kZW1hbmROZXdHVztcbiAgICBjb25zdCBidWlsZFJhdGVHV3lyID0gbW9iaWxpemF0aW9uUmVzdWx0LmJ1aWxkUmF0ZUdXeXI7XG4gICAgY29uc3QgYnVpbGRhYmxlR1cgPSBidWlsZFJhdGVHV3lyOyAvLyBidWlsZGFibGUgPSBidWlsZCByYXRlXG4gICAgY29uc3QgY2FwYWNpdHlHVyA9IG1vYmlsaXphdGlvblJlc3VsdC5jYXBhY2l0eUdXO1xuICAgIGNvbnN0IHBpcGVsaW5lR1cgPSBtb2JpbGl6YXRpb25SZXN1bHQucGlwZWxpbmVHVztcbiAgICBjb25zdCBiYWNrbG9nR1cgPSBtb2JpbGl6YXRpb25SZXN1bHQuYmFja2xvZ0dXO1xuICAgIGNvbnN0IGF2Z1dhaXRZZWFycyA9IG1vYmlsaXphdGlvblJlc3VsdC5hdmdXYWl0WWVhcnM7XG4gICAgXG4gICAgLy8gRGVmYXVsdCBidWlsZG91dCBwYXJhbWV0ZXJzXG4gICAgY29uc3QgYmFzZVdhY2MgPSBwYXJhbXMud2FjYyA/PyAwLjEwOyAvLyAxMCUgYmFzZSBXQUNDXG4gICAgY29uc3QgUFJPSkVDVF9MSUZFVElNRSA9IDIwOyAvLyAyMCB5ZWFyc1xuICAgIGNvbnN0IEJVSUxET1VUX0NBUEVYX0JBU0UgPSAyMDAwOyAvLyAkMmsva1cgYmFzZSBidWlsZG91dCBjYXBleCAocmVkdWNlZCBmcm9tIDNrKVxuICAgIGNvbnN0IERFRkFVTFRfU0NBUkNJVFlfQ1VSVkUgPSB7XG4gICAgICBrOiAyLjAsIC8vIGJ1aWxkb3V0SyAoaW5jcmVhc2VkIGZyb20gMC41IGZvciBzaGFycGVyIHNjYWxpbmcpXG4gICAgICBleHBvbmVudDogMS43LCAvLyBidWlsZG91dEV4cG9uZW50IChpbmNyZWFzZWQgZnJvbSAxLjUgZm9yIHNoYXJwZXIgc2NhbGluZylcbiAgICAgIHRocmVzaG9sZFV0aWw6IDAuMCwgLy8gUHJlbWl1bSBraWNrcyBpbiBpbW1lZGlhdGVseVxuICAgIH07XG4gICAgY29uc3QgUEFOSUNfRVhQT05FTlQgPSAxLjM7IC8vIEV4cG9uZW50IGZvciBkZWxheSBwZW5hbHR5IHBhbmljIHJlZ2ltZVxuICAgIFxuICAgIC8vIENvbXB1dGUgZWZmZWN0aXZlIFdBQ0MgKHJpc2VzIHdpdGggYmFja2xvZyAtIGNhcGl0YWwgcmF0aW9uaW5nKVxuICAgIGNvbnN0IHdhY2NCYWNrbG9nSyA9IHBhcmFtcy53YWNjQmFja2xvZ0sgPz8gMC41O1xuICAgIGNvbnN0IHdhY2NCYWNrbG9nRXhwb25lbnQgPSBwYXJhbXMud2FjY0JhY2tsb2dFeHBvbmVudCA/PyAxLjI7XG4gICAgY29uc3QgY3JpdGljYWxCYWNrbG9nR1cgPSBwYXJhbXMuY3JpdGljYWxCYWNrbG9nR1cgPz8gNTA7XG4gICAgY29uc3QgYmFja2xvZ1JhdGlvID0gTWF0aC5tYXgoMCwgYmFja2xvZ0dXIC8gY3JpdGljYWxCYWNrbG9nR1cpO1xuICAgIGNvbnN0IHdhY2NNdWx0aXBsaWVyID0gMSArIHdhY2NCYWNrbG9nSyAqIE1hdGgucG93KGJhY2tsb2dSYXRpbywgd2FjY0JhY2tsb2dFeHBvbmVudCk7XG4gICAgY29uc3Qgd2FjY0VmZmVjdGl2ZSA9IGJhc2VXYWNjICogd2FjY011bHRpcGxpZXI7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIGJ1aWxkb3V0IGNvbnN0cmFpbnRzXG4gICAgY29uc3QgYnVpbGRvdXRQYXJhbXMgPSB7XG4gICAgICBkZW1hbmROZXdHV0J5WWVhcjogZGVtYW5kTmV3R1csXG4gICAgICBidWlsZGFibGVHV0J5WWVhcjogYnVpbGRhYmxlR1csXG4gICAgICBiYWNrbG9nR1c6IGJhY2tsb2dHVywgLy8gUGFzcyBmcm9tIG1vYmlsaXphdGlvbiBtb2RlbFxuICAgICAgYXZnV2FpdFllYXJzOiBhdmdXYWl0WWVhcnMsIC8vIFBhc3MgZnJvbSBtb2JpbGl6YXRpb24gbW9kZWxcbiAgICAgIGJhc2VFbmVyZ3lQcmljZVBlck13aEJ5WWVhcjogZ3JvdW5kRWxlY3RyaWNpdHlQcmljZVBlck13aCxcbiAgICAgIHB1ZUdyb3VuZEJ5WWVhcjogZWZmZWN0aXZlUHVlR3JvdW5kLFxuICAgICAgd2FjYzogd2FjY0VmZmVjdGl2ZSwgLy8gVXNlIGVmZmVjdGl2ZSBXQUNDIChyaXNlcyB3aXRoIGJhY2tsb2cpXG4gICAgICBwcm9qZWN0TGlmZXRpbWVZZWFyczogcGFyYW1zLmJ1aWxkb3V0UHJvamVjdExpZmV0aW1lWWVhcnMgPz8gUFJPSkVDVF9MSUZFVElNRSxcbiAgICAgIHZhbHVlT2ZUaW1lTW9kZTogcGFyYW1zLnZhbHVlT2ZUaW1lTW9kZSA/PyAnd2FjY19vbl9jYXBleCcsIC8vIERlZmF1bHQgdG8gd2FjY19vbl9jYXBleFxuICAgICAgYnVpbGRvdXRDYXBleEJhc2VfJFBlcmtXOiBwYXJhbXMuYnVpbGRvdXRDYXBleEJhc2VfJFBlcmtXID8/IEJVSUxET1VUX0NBUEVYX0JBU0UsXG4gICAgICBidWlsZG91dENhcGV4U2NhcmNpdHlDdXJ2ZTogcGFyYW1zLmJ1aWxkb3V0Q2FwZXhTY2FyY2l0eUN1cnZlID8/IERFRkFVTFRfU0NBUkNJVFlfQ1VSVkUsXG4gICAgICBwYW5pY0V4cG9uZW50OiBwYXJhbXMuYnVpbGRvdXRQYW5pY0V4cG9uZW50ID8/IFBBTklDX0VYUE9ORU5ULFxuICAgICAgaGFyZHdhcmVDYXBleFBlclBmbG9wWWVhcjogZ3JvdW5kSGFyZHdhcmVDYXBleFBlclBmbG9wWWVhciwgLy8gUGFzcyBkaXJlY3RseSAobm90IGNvbnZlcnRlZCB0byBrVylcbiAgICAgIHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyOiBCQVNFX1NJVEVfMjAyNSwgLy8gUGFzcyBkaXJlY3RseSAobm90IGNvbnZlcnRlZCB0byBrVylcbiAgICAgIC8vIExlZ2FjeSBmaWVsZHMgKGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdCwgYnV0IG5vdCB1c2VkIGluIG5ldyBjYWxjdWxhdGlvbilcbiAgICAgIGNvbXB1dGVIYXJkd2FyZUNhcGV4OiBncm91bmRIYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyICogKGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlclcgKiBjYXBhY2l0eUZhY3Rvckdyb3VuZCAvIGVmZmVjdGl2ZVB1ZUdyb3VuZCAvIDFlNiksXG4gICAgICBzaXRlQ2FwZXg6IEJBU0VfU0lURV8yMDI1ICogKGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlclcgKiBjYXBhY2l0eUZhY3Rvckdyb3VuZCAvIGVmZmVjdGl2ZVB1ZUdyb3VuZCAvIDFlNiksXG4gICAgICBtYXJnaW5QZXJHcHVIb3VyOiAwLjUsXG4gICAgICBhbm51YWxHcHVIb3Vyc0RlbGl2ZXJlZDogODc2MCAqIGNhcGFjaXR5RmFjdG9yR3JvdW5kLFxuICAgICAgaHlicmlkV2VpZ2h0czogcGFyYW1zLmJ1aWxkb3V0SHlicmlkV2VpZ2h0cyA/PyB7IHdhY2NXZWlnaHQ6IDAuNSwgbWFyZ2luV2VpZ2h0OiAwLjUgfSxcbiAgICB9O1xuICAgIFxuICAgIGNvbnN0IGJ1aWxkb3V0UmVzdWx0ID0gY2FsY3VsYXRlQnVpbGRvdXRDb25zdHJhaW50cyhcbiAgICAgIG51bGwsIC8vIFN0YXRlIGlzIG5vdyBtYW5hZ2VkIGJ5IG1vYmlsaXphdGlvbiBtb2RlbFxuICAgICAgYnVpbGRvdXRQYXJhbXMsXG4gICAgICB5ZWFyLFxuICAgICAgZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyVyxcbiAgICAgIGVmZmVjdGl2ZVB1ZUdyb3VuZCxcbiAgICAgIGNhcGFjaXR5RmFjdG9yR3JvdW5kXG4gICAgKTtcbiAgICBcbiAgICAvLyBFbmVyZ3kgY29zdDogYmFzZSBlbmVyZ3kgb25seSAoTk9UIGFmZmVjdGVkIGJ5IGJ1aWxkb3V0IGNvbnN0cmFpbnRzKVxuICAgIGNvbnN0IGVuZXJneUNvc3QgPSBncm91bmRFbmVyZ3lDb3N0UGVyUGZsb3BZZWFyO1xuICAgIFxuICAgIC8vIFNpdGUgY29zdDogYmFzZSBjYXBleCArIGJ1aWxkb3V0IHByZW1pdW0gKGVuZ2luZWVyaW5nIGNvc3Qgb25seSwgbm90IHNjYXJjaXR5IHByaWNpbmcpXG4gICAgY29uc3Qgc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgPSBCQVNFX1NJVEVfMjAyNTtcbiAgICBjb25zdCBidWlsZG91dFByZW1pdW1QZXJQZmxvcFllYXIgPSBidWlsZG91dFJlc3VsdC5idWlsZG91dFByZW1pdW1QZXJQZmxvcFllYXI7IC8vIEJhc2UgZW5naW5lZXJpbmcgY29zdCBvbmx5XG4gICAgY29uc3QgZGVsYXlQZW5hbHR5UGVyUGZsb3BZZWFyID0gYnVpbGRvdXRSZXN1bHQuZGVsYXlQZW5hbHR5UGVyUGZsb3BZZWFyOyAvLyBMaW5lYXI6IFdBQ0MgKiBjYXBleCAqIHdhaXRZZWFyc1xuICAgIFxuICAgIC8vIENSSVRJQ0FMOiBXYWl0LXRpbWUtYmFzZWQgc2NhcmNpdHkgcmVudCAoRUFSTFksIFNBVFVSQVRJTkcpXG4gICAgLy8gRGVmaW5lIGFubnVhbGl6ZWQgY2FwZXggYmFzZSBmb3Igc2NhcmNpdHkgcmVudCBjYWxjdWxhdGlvblxuICAgIGNvbnN0IGNhcGV4QW5udWFsQmFzZVBlclBmbG9wWWVhciA9IFxuICAgICAgZ3JvdW5kSGFyZHdhcmVDYXBleFBlclBmbG9wWWVhciArXG4gICAgICBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciArXG4gICAgICBidWlsZG91dFByZW1pdW1QZXJQZmxvcFllYXI7IC8vIEluY2x1ZGUgYnVpbGRvdXQgcHJlbWl1bSBhcyB0cnVlIGVuZ2luZWVyaW5nIGNhcGV4XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHNjYXJjaXR5IG11bHRpcGxpZXIgdXNpbmcgTE9HLUJBU0VEIGZ1bmN0aW9uIChuZXZlciBmdWxseSBzYXR1cmF0ZXMpXG4gICAgLy8gUmV0dXJucyBtdWx0aXBsaWVyICgxLjAgPSBubyBzY2FyY2l0eSwgMi4wID0gMnggcHJpY2UpIC0gTVVMVElQTElDQVRJVkUsIG5vdCBhZGRpdGl2ZVxuICAgIGNvbnN0IHV0aWxpemF0aW9uUGN0ID0gY2FwYWNpdHlHVyA+IDAgPyBNYXRoLm1pbigxLjAsIGRlbWFuZE5ld0dXIC8gY2FwYWNpdHlHVykgOiAxLjA7XG4gICAgY29uc3Qgc2NhcmNpdHlSZW50UmVzdWx0ID0gY2FsY3VsYXRlU2NhcmNpdHlSZW50KFxuICAgICAgYXZnV2FpdFllYXJzLFxuICAgICAgdXRpbGl6YXRpb25QY3QsIC8vIFBhc3MgdXRpbGl6YXRpb24gZm9yIHRocmVzaG9sZCBnYXRlXG4gICAgICB7XG4gICAgICAgIHdhaXRUaHJlc2hvbGRZZWFyczogcGFyYW1zLnNjYXJjaXR5UmVudFdhaXRUaHJlc2hvbGRZZWFycyA/PyAxLjAsIC8vIE1pbmltdW0gd2FpdCBiZWZvcmUgc2NhcmNpdHkgYWN0aXZhdGVzXG4gICAgICAgIHJlbnRNYXhNdWx0aXBsaWVyOiBwYXJhbXMuc2NhcmNpdHlSZW50TWF4TXVsdGlwbGllciA/PyAyLjAsIC8vIE1heGltdW0gcHJpY2UgbXVsdGlwbGllciAoMnggPSAxMDAlIGluY3JlYXNlKVxuICAgICAgICB1dGlsaXphdGlvblRocmVzaG9sZDogMC44NSwgLy8gVXRpbGl6YXRpb24gdGhyZXNob2xkXG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBzY2FyY2l0eU11bHRpcGxpZXIgPSBzY2FyY2l0eVJlbnRSZXN1bHQuc2NhcmNpdHlNdWx0aXBsaWVyO1xuICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXIgPSAwIChzY2FyY2l0eSBpcyBub3cgbXVsdGlwbGljYXRpdmUpXG4gICAgY29uc3Qgc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyID0gMDtcbiAgICBcbiAgICAvLyBEZWZpbmUgdGhyZWUgdG90YWxzOlxuICAgIC8vIDEuIGJhc2U6IGVuZXJneSArIHNpdGVDYXBleEFtb3J0ICsgYnVpbGRvdXRQcmVtaXVtICsgaGFyZHdhcmUgKG5vIHNjYXJjaXR5IHByaWNpbmcpXG4gICAgLy8gMi4gZWZmZWN0aXZlOiBpbmNsdWRlcyBkZWxheVBlbmFsdHkgKyBzY2FyY2l0eVJlbnQgKHVzZWQgZm9yIGNyb3Nzb3ZlcilcbiAgICAvLyAzLiBoZWFkbGluZTogc2FtZSBhcyBiYXNlIChmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbiAgICBjb25zdCBzaXRlQ29zdFBlclBmbG9wWWVhcl9iYXNlID0gc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgKyBidWlsZG91dFByZW1pdW1QZXJQZmxvcFllYXI7XG4gICAgY29uc3Qgc2l0ZUNvc3RQZXJQZmxvcFllYXJfZWZmZWN0aXZlID0gc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgKyBidWlsZG91dFByZW1pdW1QZXJQZmxvcFllYXIgKyBkZWxheVBlbmFsdHlQZXJQZmxvcFllYXIgKyBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXI7XG4gICAgXG4gICAgLy8gVmFsaWRhdGlvbjogZW5zdXJlIG5vIGRvdWJsZSBjb3VudGluZ1xuICAgIGlmIChwYXJhbXMudXNlUXVldWVCYXNlZENvbnN0cmFpbnQgIT09IGZhbHNlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFtCVUlMRE9VVF0gdXNlUXVldWVCYXNlZENvbnN0cmFpbnQgc2hvdWxkIGJlIGZhbHNlIHdoZW4gdXNlQnVpbGRvdXRNb2RlbCBpcyB0cnVlIHRvIGF2b2lkIGRvdWJsZSBjb3VudGluZ2ApO1xuICAgIH1cbiAgICBcbiAgICAvLyBEb3VibGUgY291bnRpbmcgZ3VhcmRyYWlsczogZW5zdXJlIGNvbnN0cmFpbnRNdWx0aXBsaWVyIGlzIDEuMCB3aGVuIHVzZUJ1aWxkb3V0TW9kZWwgaXMgdHJ1ZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgaWYgKGdyb3VuZFJlc3VsdD8uY29uc3RyYWludE11bHRpcGxpZXIgIT09IHVuZGVmaW5lZCAmJiBncm91bmRSZXN1bHQuY29uc3RyYWludE11bHRpcGxpZXIgIT09IDEuMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtET1VCTEUgQ09VTlRJTkddIHVzZUJ1aWxkb3V0TW9kZWw9dHJ1ZSBidXQgY29uc3RyYWludE11bHRpcGxpZXI9JHtncm91bmRSZXN1bHQuY29uc3RyYWludE11bHRpcGxpZXJ9ICE9IDEuMCAoeWVhcj0ke3llYXJ9KWApO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBoYXJkd2FyZUNvc3QgPSBncm91bmRIYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyO1xuICAgIFxuICAgIC8vIEFkZCByZXBsYWNlbWVudC9vcHMgY29zdHMgdG8gaGFyZHdhcmUgY29zdFxuICAgIGNvbnN0IGhhcmR3YXJlQ29zdFdpdGhSZXBsYWNlbWVudCA9IGhhcmR3YXJlQ29zdCArIHJlcGxhY2VtZW50Q29zdFBlclBmbG9wWWVhciArIHNwYXJlc0NhcnJ5Q29zdFBlclBmbG9wWWVhciArIGdyb3VuZE9wc0Nvc3RQZXJQZmxvcFllYXI7XG4gICAgXG4gICAgLy8gQ29tcHV0ZSB0b3RhbHMgKGluY2x1ZGUgcmVwbGFjZW1lbnQvb3BzIGluIGFsbClcbiAgICBjb25zdCBncm91bmRUb3RhbENvc3RfYmFzZSA9IChlbmVyZ3lDb3N0ICsgc2l0ZUNvc3RQZXJQZmxvcFllYXJfYmFzZSArIGhhcmR3YXJlQ29zdFdpdGhSZXBsYWNlbWVudCkgKiBncm91bmRMYXRlbmN5UGVuYWx0eTtcbiAgICBjb25zdCBncm91bmRUb3RhbENvc3RfZWZmZWN0aXZlID0gKGVuZXJneUNvc3QgKyBzaXRlQ29zdFBlclBmbG9wWWVhcl9lZmZlY3RpdmUgKyBoYXJkd2FyZUNvc3RXaXRoUmVwbGFjZW1lbnQpICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHk7IC8vIEluY2x1ZGVzIGRlbGF5UGVuYWx0eSArIHNjYXJjaXR5UmVudFxuICAgIFxuICAgIC8vIFVOSUZJRUQgU0NBUkNJVFkgQUNDT1VOVElORzogS2VlcCB0b3RhbENvc3RQZXJQZmxvcFllYXIgcGh5c2ljYWwtb25seVxuICAgIC8vIFNjYXJjaXR5IChkZWxheVBlbmFsdHkgKyBzY2FyY2l0eVJlbnQpIGlzIHRyZWF0ZWQgcHVyZWx5IGluIEdQVS1ob3VyIHByaWNpbmcsIG5vdCBpbiBQRkxPUC15ZWFyIGNvc3RcbiAgICBncm91bmRUb3RhbENvc3QgPSBncm91bmRUb3RhbENvc3RfYmFzZTsgLy8gUGh5c2ljYWwgY29zdHMgb25seSAoc2NhcmNpdHkgaW4gR1BVLWhvdXIpXG4gICAgXG4gICAgLy8gRGV0ZWN0IGlmIGdyb3VuZCBoYXMgcXVldWUvYmFja2xvZyAoY29uc3RyYWludHMgYXJlIGFjdGl2ZSkgLSBmb3IgZGlhZ25vc3RpY3Mgb25seVxuICAgIGdyb3VuZEhhc1F1ZXVlID1cbiAgICAgIChhdmdXYWl0WWVhcnMgPiAwLjA1KSB8fFxuICAgICAgKGJhY2tsb2dHVyA+IDAuMDUpIHx8XG4gICAgICAoKGdyb3VuZFJlc3VsdCBhcyBhbnkpPy5idWlsZG91dERlYnVnPy5iYWNrbG9nR1cgPz8gMCkgPiAwLjA1O1xuICAgIFxuICAgIC8vIEZvciBjcm9zc292ZXI6IHVzZSBiYXNlIGNvc3QgKHNjYXJjaXR5IGlzIGFscmVhZHkgcmVmbGVjdGVkIGluIEdQVS1ob3VyIHByaWNpbmcpXG4gICAgLy8gVGhpcyBlbnN1cmVzIHdlIGRvbid0IGRvdWJsZS1jb3VudCBzY2FyY2l0eVxuICAgIGdyb3VuZENvbXBhcmF0b3JDb3N0UGVyUGZsb3BZZWFyID0gZ3JvdW5kVG90YWxDb3N0OyAvLyBCYXNlIGNvc3Qgb25seSAoc2NhcmNpdHkgaW4gR1BVLWhvdXIpXG4gICAgXG4gICAgZW5lcmd5Q29uc3RyYWludE11bHRpcGxpZXIgPSAxLjA7IC8vIEVuZXJneSBOT1QgYWZmZWN0ZWQgYnkgYnVpbGRvdXQgY29uc3RyYWludHNcbiAgICBcbiAgICAvLyBDb25zdHJhaW50IGJyZWFrZG93bjogYWxsIDEuMCAobm8gbXVsdGlwbGllcnMsIHVzZSBidWlsZG91dCB0ZXJtcyBpbnN0ZWFkKVxuICAgIGNvbnN0cmFpbnRCcmVha2Rvd24gPSB7XG4gICAgICBncmlkOiAxLjAsXG4gICAgICBjb29saW5nOiAxLjAsXG4gICAgICB3YXRlcjogMS4wLFxuICAgICAgbGFuZDogMS4wLFxuICAgICAgZW5lcmd5TXVsdGlwbGllcjogMS4wLCAvLyBFbmVyZ3kgTk9UIGFmZmVjdGVkXG4gICAgICBzaXRlTXVsdGlwbGllcjogMS4wLCAvLyBObyBtdWx0aXBsaWVyLCB1c2UgYnVpbGRvdXQgcHJlbWl1bVxuICAgICAgY2FwYWNpdHlEZWxpdmVyeU11bHRpcGxpZXI6IDEuMCwgLy8gTm8gbXVsdGlwbGllciwgdXNlIGJ1aWxkb3V0IHByZW1pdW1cbiAgICB9O1xuICAgIFxuICAgIGdyb3VuZFJlc3VsdCA9IHtcbiAgICAgIGVuZXJneUNvc3Q6IGVuZXJneUNvc3QgKiBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgIHNpdGVDb3N0OiBzaXRlQ29zdFBlclBmbG9wWWVhcl9iYXNlICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICBoYXJkd2FyZUNvc3Q6IGhhcmR3YXJlQ29zdFdpdGhSZXBsYWNlbWVudCAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LFxuICAgICAgLy8gUmVwbGFjZW1lbnQvb3BzIGJyZWFrZG93blxuICAgICAgcmVwbGFjZW1lbnRDb3N0OiByZXBsYWNlbWVudENvc3RQZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgIHNwYXJlc0NhcnJ5Q29zdDogc3BhcmVzQ2FycnlDb3N0UGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICBvcHNDb3N0OiBncm91bmRPcHNDb3N0UGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhcjogc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtOiBidWlsZG91dFByZW1pdW1QZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSwgLy8gQnVpbGRvdXQgcHJlbWl1bSByZXBsYWNlcyBvbGQgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1cbiAgICAgIHRpbWVUb0VuZXJnaXplUGVuYWx0eTogZGVsYXlQZW5hbHR5UGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksIC8vIERlbGF5IHBlbmFsdHkgKGxpbmVhcjogV0FDQyAqIGNhcGV4ICogd2FpdFllYXJzKVxuICAgICAgdG90YWxDb3N0UGVyUGZsb3BZZWFyOiBncm91bmRUb3RhbENvc3QsIC8vIFBoeXNpY2FsIGNvc3RzIG9ubHkgKHNjYXJjaXR5IHRyZWF0ZWQgaW4gR1BVLWhvdXIgcHJpY2luZylcbiAgICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhckJhc2U6IGdyb3VuZFRvdGFsQ29zdF9iYXNlLCAvLyBCYXNlIGNvc3QgKG5vIHNjYXJjaXR5IHByaWNpbmcpXG4gICAgICB0b3RhbENvc3RQZXJQZmxvcFllYXJFZmZlY3RpdmU6IGdyb3VuZFRvdGFsQ29zdCwgLy8gU2FtZSBhcyBiYXNlIChzY2FyY2l0eSBpbiBHUFUtaG91ciwgbm90IFBGTE9QLXllYXIpXG4gICAgICB0b3RhbENvc3RQZXJQZmxvcFllYXJBbGxJbjogZ3JvdW5kVG90YWxDb3N0LCAvLyBTYW1lIGFzIGJhc2UgKHNjYXJjaXR5IGluIEdQVS1ob3VyLCBub3QgUEZMT1AteWVhcilcbiAgICAgIC8vIERlYnVnOiBzaG93IHByaWNpbmcgY29tcG9uZW50c1xuICAgICAgcHJpY2luZ0NvbXBvbmVudHM6IHtcbiAgICAgICAgZGVsYXlQZW5hbHR5V2VpZ2h0ZWQ6IGRlbGF5UGVuYWx0eVdlaWdodGVkICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICAgIHNjYXJjaXR5UmVudFBlclBmbG9wWWVhcjogc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICAgIHByaWNpbmdNb2RlLFxuICAgICAgICBkZWxheVBlbmFsdHlXZWlnaHQsXG4gICAgICAgIHJlbnRGcmFjOiBzY2FyY2l0eVJlbnRSZXN1bHQucmVudEZyYWMsXG4gICAgICAgIHdhaXRFZmZZZWFyczogc2NhcmNpdHlSZW50UmVzdWx0LndhaXRFZmZZZWFycyxcbiAgICAgICAgLy8gRGVidWcgZmllbGRzIGZvciBzY2FyY2l0eSByZW50IGNhbGN1bGF0aW9uXG4gICAgICAgIHNjYXJjaXR5SGlsbDogc2NhcmNpdHlSZW50UmVzdWx0LnNjYXJjaXR5SGlsbCxcbiAgICAgICAgYXZnV2FpdFllYXJzUmF3OiBzY2FyY2l0eVJlbnRSZXN1bHQuYXZnV2FpdFllYXJzUmF3LFxuICAgICAgICBhdmdXYWl0WWVhcnNDbGFtcGVkOiBzY2FyY2l0eVJlbnRSZXN1bHQuYXZnV2FpdFllYXJzQ2xhbXBlZCxcbiAgICAgIH0sXG4gICAgICBjb25zdHJhaW50TXVsdGlwbGllcjogMS4wLCAvLyBObyBjb25zdHJhaW50IG11bHRpcGxpZXIgLSB1c2UgYnVpbGRvdXQgdGVybXNcbiAgICAgIGJyZWFrZG93bjogY29uc3RyYWludEJyZWFrZG93bixcbiAgICAgIHN1cHBseU1ldHJpY3M6IHtcbiAgICAgICAgZGVtYW5kR3c6IG1vYmlsaXphdGlvblJlc3VsdC5kZW1hbmRHVyxcbiAgICAgICAgY2FwYWNpdHlHdzogY2FwYWNpdHlHVyxcbiAgICAgICAgcGlwZWxpbmVHdzogcGlwZWxpbmVHVyxcbiAgICAgICAgbWF4QnVpbGRSYXRlR3dZZWFyOiBidWlsZFJhdGVHV3lyLFxuICAgICAgICBhdmdXYWl0WWVhcnM6IGF2Z1dhaXRZZWFycyxcbiAgICAgICAgdXRpbGl6YXRpb25QY3Q6IGNhcGFjaXR5R1cgPiAwID8gbW9iaWxpemF0aW9uUmVzdWx0LmRlbWFuZEdXIC8gY2FwYWNpdHlHVyA6IDAsXG4gICAgICB9LFxuICAgICAgLy8gQnVpbGRvdXQgZGVidWcgZmllbGRzIChmcm9tIHJhbXBpbmcgbW9iaWxpemF0aW9uIG1vZGVsKVxuICAgICAgYmFja2xvZ0d3OiBiYWNrbG9nR1csXG4gICAgICBhdmdXYWl0WWVhcnM6IGF2Z1dhaXRZZWFycyxcbiAgICAgIGJ1aWxkb3V0RGVidWc6IHtcbiAgICAgICAgZGVtYW5kTmV3R1c6IGRlbWFuZE5ld0dXLFxuICAgICAgICBidWlsZGFibGVHVzogYnVpbGRhYmxlR1csXG4gICAgICAgIGJ1aWxkUmF0ZUdXeXI6IGJ1aWxkUmF0ZUdXeXIsXG4gICAgICAgIGNhcGFjaXR5R1c6IGNhcGFjaXR5R1csXG4gICAgICAgIHBpcGVsaW5lR1c6IHBpcGVsaW5lR1csXG4gICAgICAgIHNjYXJjaXR5SW5kZXg6IGJ1aWxkb3V0UmVzdWx0LmZhY3RvcnMuc2NhcmNpdHlJbmRleCxcbiAgICAgICAgYnVpbGRvdXRDYXBleF8kUGVya1c6IGJ1aWxkb3V0UmVzdWx0LmZhY3RvcnMuYnVpbGRvdXRDYXBleF8kUGVya1csXG4gICAgICAgIGFubnVhbGl6ZWRCdWlsZG91dFByZW1pdW1fJFBlcmtXeXI6IGJ1aWxkb3V0UmVzdWx0LmZhY3RvcnMuYW5udWFsaXplZEJ1aWxkb3V0UHJlbWl1bV8kUGVya1d5cixcbiAgICAgICAgdGltZVRvUG93ZXJZZWFyczogYXZnV2FpdFllYXJzLFxuICAgICAgICB2YWx1ZU9mVGltZV8kUGVyWWVhcjogYnVpbGRvdXRSZXN1bHQuZmFjdG9ycy52YWx1ZU9mVGltZV8kUGVyWWVhcixcbiAgICAgICAgZGVsYXlQZW5hbHR5XyRQZXJZZWFyOiBidWlsZG91dFJlc3VsdC5mYWN0b3JzLmRlbGF5UGVuYWx0eV8kUGVyWWVhcixcbiAgICAgICAgYnVpbGRvdXRQcmVtaXVtUGVyUGZsb3BZZWFyOiBidWlsZG91dFByZW1pdW1QZXJQZmxvcFllYXIsXG4gICAgICAgIGRlbGF5UGVuYWx0eVBlclBmbG9wWWVhcjogZGVsYXlQZW5hbHR5UGVyUGZsb3BZZWFyLFxuICAgICAgICAvLyBBZGRpdGlvbmFsIG1vYmlsaXphdGlvbiBkZWJ1ZyBmaWVsZHNcbiAgICAgICAgZGVtYW5kR1c6IG1vYmlsaXphdGlvblJlc3VsdC5kZW1hbmRHVyxcbiAgICAgICAgZGVtYW5kR3Jvd3RoUmF0ZTogbW9iaWxpemF0aW9uUmVzdWx0LmRlbWFuZEdyb3d0aFJhdGUsXG4gICAgICAgIGJhY2tsb2dHVzogbW9iaWxpemF0aW9uUmVzdWx0LmJhY2tsb2dHVyxcbiAgICAgICAgYXZnV2FpdFllYXJzOiBtb2JpbGl6YXRpb25SZXN1bHQuYXZnV2FpdFllYXJzLFxuICAgICAgfSxcbiAgICAgIHNtckVuYWJsZWQ6IGZhbHNlLFxuICAgICAgc21yUmFtcEZhY3RvcjogMCxcbiAgICAgIGVmZmVjdGl2ZUVsZWN0cmljaXR5Q29zdDogZ3JvdW5kRWxlY3RyaWNpdHlQcmljZVBlck13aCxcbiAgICAgIGNvbnN0cmFpbnRSZWxpZWY6IHsgZ3JpZDogMCwgY29vbGluZzogMCwgd2F0ZXI6IDAsIGxhbmQ6IDAgfSxcbiAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgIG1ldGhvZDogJ2FkZGVycycsXG4gICAgICAgIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtOiBidWlsZG91dFByZW1pdW1QZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgICAgZGVsYXlQZW5hbHR5OiBkZWxheVBlbmFsdHlQZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgICAgc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyOiBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSwgLy8gQmFja3dhcmQgY29tcGF0IChub3cgMCwgc2NhcmNpdHkgaXMgbXVsdGlwbGljYXRpdmUpXG4gICAgICAgIHNjYXJjaXR5TXVsdGlwbGllcjogc2NhcmNpdHlNdWx0aXBsaWVyLCAvLyBNdWx0aXBsaWNhdGl2ZSBzY2FyY2l0eSAoMS4wID0gbm8gc2NhcmNpdHksIDIuMCA9IDJ4IHByaWNlKVxuICAgICAgICBhcHBsaWVkTXVsdGlwbGllcnM6IHtcbiAgICAgICAgICBjb25zdHJhaW50TXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgICAgIGVuZXJneU11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgICBzaXRlTXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICB3YWNjQmFzZTogYmFzZVdhY2MsXG4gICAgICAgIHdhY2NFZmZlY3RpdmU6IHdhY2NFZmZlY3RpdmUsXG4gICAgICAgIHJlbnRGcmFjOiBzY2FyY2l0eVJlbnRSZXN1bHQucmVudEZyYWMsXG4gICAgICAgIHdhaXRZZWFyc1VzZWQ6IHNjYXJjaXR5UmVudFJlc3VsdC53YWl0RWZmWWVhcnMsIC8vIFdhaXQgdGltZSB1c2VkIGZvciBzY2FyY2l0eSByZW50IGNhbGN1bGF0aW9uXG4gICAgICAgIHdhaXRFZmZZZWFyczogc2NhcmNpdHlSZW50UmVzdWx0LndhaXRFZmZZZWFycywgLy8gQWxpYXMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgLy8gRGVidWcgZmllbGRzIGZvciBzY2FyY2l0eSByZW50IGNhbGN1bGF0aW9uXG4gICAgICAgIHNjYXJjaXR5SGlsbDogc2NhcmNpdHlSZW50UmVzdWx0LnNjYXJjaXR5SGlsbCxcbiAgICAgICAgYXZnV2FpdFllYXJzUmF3OiBzY2FyY2l0eVJlbnRSZXN1bHQuYXZnV2FpdFllYXJzUmF3LFxuICAgICAgICBhdmdXYWl0WWVhcnNDbGFtcGVkOiBzY2FyY2l0eVJlbnRSZXN1bHQuYXZnV2FpdFllYXJzQ2xhbXBlZCxcbiAgICAgICAgZGVidWc6IHtcbiAgICAgICAgICBkb3VibGVDb3VudENoZWNrOiB7XG4gICAgICAgICAgICBtb2RlOiAnYWRkZXJzJyxcbiAgICAgICAgICAgIG11bHRpcGxpZXJBcHBsaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIGFkZGVyc0FwcGxpZWQ6IHRydWUsXG4gICAgICAgICAgICBpbnZhcmlhbnRPazogdHJ1ZSxcbiAgICAgICAgICAgIG5vdGVzOiAnQnVpbGRvdXQgbW9kZWwgdXNlcyBhZGRlcnMgb25seSAoY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gKyBkZWxheVBlbmFsdHkgKyBzY2FyY2l0eVJlbnQpJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICAgIFxuICAgIC8vIEludmFyaWFudDogSWYgdXNpbmcgYWRkZXJzLCBtdWx0aXBsaWVycyBtdXN0IG5vdCBiZSBhcHBsaWVkXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBjb25zdCBoYXNNdWx0aXBsaWVyID0gZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRNdWx0aXBsaWVyICE9PSAxLjA7XG4gICAgICBjb25zdCBoYXNBZGRlciA9IChncm91bmRSZXN1bHQuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gPiAwKSB8fCAoZ3JvdW5kUmVzdWx0LnRpbWVUb0VuZXJnaXplUGVuYWx0eSA+IDApO1xuICAgICAgaWYgKGhhc011bHRpcGxpZXIgJiYgaGFzQWRkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBbRE9VQkxFIENPVU5USU5HIERFVEVDVEVEXSBZZWFyICR7eWVhcn06IGNvbnN0cmFpbnRNdWx0aXBsaWVyPSR7Z3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRNdWx0aXBsaWVyfSAhPSAxLjAgYCArXG4gICAgICAgICAgYEFORCBhZGRlcnMgPiAwIChjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bT0ke2dyb3VuZFJlc3VsdC5jYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bX0sIGAgK1xuICAgICAgICAgIGBkZWxheVBlbmFsdHk9JHtncm91bmRSZXN1bHQudGltZVRvRW5lcmdpemVQZW5hbHR5fSkuIEJvdGggY2Fubm90IGJlIGFwcGxpZWQgc2ltdWx0YW5lb3VzbHkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh1c2VSZWdpb25hbE1vZGVsKSB7XG4gICAgY29uc3QgZGVtYW5kUGZsb3BzID0gZ2V0R2xvYmFsRGVtYW5kUGZsb3BzKHllYXIsIGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlclcpO1xuICAgIGNvbnN0IHJlZ2lvbmFsUmVzdWx0ID0gY2FsY3VsYXRlUmVnaW9uYWxHcm91bmRDb3N0KFxuICAgICAgeWVhcixcbiAgICAgIGRlbWFuZFBmbG9wcyxcbiAgICAgIGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlclcsXG4gICAgICBlZmZlY3RpdmVQdWVHcm91bmQsXG4gICAgICBjYXBhY2l0eUZhY3Rvckdyb3VuZCxcbiAgICAgIGdyb3VuZEhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXIsXG4gICAgICB1bmRlZmluZWQgLy8gVXNlIGRlZmF1bHQgcmVnaW9uc1xuICAgICk7XG4gICAgXG4gICAgLy8gUkVGQUNUT1JFRDogUmVnaW9uYWwgbW9kZWwgLSBlbmVyZ3kgY29zdCBzaG91bGQgTk9UIGhhdmUgY29uc3RyYWludCBtdWx0aXBsaWVyXG4gICAgLy8gUmVnaW9uYWwgbW9kZWwgYWxyZWFkeSBzZXBhcmF0ZXMgZW5lcmd5IChyYXcpIGZyb20gc2l0ZSAod2l0aCBjb25zdHJhaW50KVxuICAgIGNvbnN0IGVuZXJneUNvc3QgPSByZWdpb25hbFJlc3VsdC5lbmVyZ3lDb3N0UGVyUGZsb3BZZWFyOyAvLyBSYXcgZWxlY3RyaWNpdHkgKE5PIGNvbnN0cmFpbnQgbXVsdGlwbGllcilcbiAgICBjb25zdCBzaXRlQ29zdCA9IHJlZ2lvbmFsUmVzdWx0LnNpdGVDb3N0UGVyUGZsb3BZZWFyOyAvLyBTaXRlIGNvc3RzIFdJVEggY29uc3RyYWludCBtdWx0aXBsaWVyXG4gICAgXG4gICAgLy8gR1JPVU5EIENPU1QgQUNDT1VOVElORzogRXhwbGljaXQgc2VwYXJhdGlvbiBmb3IgcmVnaW9uYWwgbW9kZWxcbiAgICBjb25zdCBzaXRlQ29zdEJhc2UgPSBCQVNFX1NJVEVfMjAyNTtcbiAgICBcbiAgICAvLyAxLiBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhcjogQmFzZSBzaXRlIGNhcGV4IChOT1QgYWZmZWN0ZWQgYnkgY29uc3RyYWludClcbiAgICBjb25zdCBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciA9IHNpdGVDb3N0QmFzZTtcbiAgICBcbiAgICAvLyAyLiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhcjogUHJlbWl1bSBhYm92ZSBiYXNlIChmcm9tIGNvbnN0cmFpbnQgbXVsdGlwbGllcilcbiAgICBjb25zdCBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhciA9IE1hdGgubWF4KDAsIHNpdGVDb3N0IC0gc2l0ZUNvc3RCYXNlKTtcbiAgICBcbiAgICAvLyAzLiB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXI6IFJlZ2lvbmFsIG1vZGVsIGRvZXNuJ3QgbW9kZWwgcXVldWUgZGVsYXkgc2VwYXJhdGVseSAoMCBmb3Igbm93KVxuICAgIGNvbnN0IHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciA9IDA7XG4gICAgXG4gICAgLy8gSU5WQVJJQU5UOiBzaXRlQ29zdFBlclBmbG9wWWVhciA9IHNpdGVDYXBleEFtb3J0ICsgdGltZVRvRW5lcmdpemVQZW5hbHR5ICsgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1cbiAgICBjb25zdCBzaXRlQ29zdFBlclBmbG9wWWVhciA9IHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyICsgdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyICsgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXI7XG4gICAgXG4gICAgLy8gVmFsaWRhdGlvbiAoYWxsb3cgc21hbGwgdG9sZXJhbmNlIGZvciByZWdpb25hbCBtb2RlbCBhcHByb3hpbWF0aW9uKVxuICAgIGNvbnN0IHNpdGVDb3N0Q2hlY2sgPSBNYXRoLmFicyhzaXRlQ29zdCAtIHNpdGVDb3N0UGVyUGZsb3BZZWFyKTtcbiAgICBpZiAoc2l0ZUNvc3RDaGVjayA+IDEuMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaXRlIGNvc3QgYWNjb3VudGluZyBlcnJvciAocmVnaW9uYWwgbW9kZWwpOiBzaXRlQ29zdD0ke3NpdGVDb3N0fSAhPSBzdW0oY29tcG9uZW50cyk9JHtzaXRlQ29zdFBlclBmbG9wWWVhcn0sIGRpZmY9JHtzaXRlQ29zdENoZWNrfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBDUklUSUNBTCBGSVg6IFJlZ2lvbmFsIG1vZGVsIGFscmVhZHkgc2VwYXJhdGVzIGVuZXJneSAobm8gbXVsdGlwbGllcikgZnJvbSBzaXRlICh3aXRoIHByZW1pdW0pXG4gICAgLy8gRG8gTk9UIGFwcGx5IGNvbnN0cmFpbnRNdWx0aXBsaWVyIC0gaXQncyBhbHJlYWR5IHJlZmxlY3RlZCBpbiBzaXRlQ29zdFBlclBmbG9wWWVhclxuICAgIGNvbnN0IGNvbnN0cmFpbnRNdWx0aXBsaWVyID0gMS4wOyAvLyBOb3QgYXBwbGllZCAtIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdCBvbmx5XG4gICAgXG4gICAgZ3JvdW5kVG90YWxDb3N0ID0gcmVnaW9uYWxSZXN1bHQudG90YWxDb3N0UGVyUGZsb3BZZWFyO1xuICAgIGdyb3VuZEhhc1F1ZXVlID0gZmFsc2U7IC8vIFJlZ2lvbmFsIG1vZGVsIGRvZXNuJ3QgbW9kZWwgcXVldWUgZGVsYXkgc2VwYXJhdGVseVxuICAgIGdyb3VuZENvbXBhcmF0b3JDb3N0UGVyUGZsb3BZZWFyID0gZ3JvdW5kVG90YWxDb3N0OyAvLyBVc2UgYmFzZSBjb3N0IGZvciByZWdpb25hbCBtb2RlbFxuICAgIGVuZXJneUNvbnN0cmFpbnRNdWx0aXBsaWVyID0gMS4wOyAvLyBOZXZlciBhcHBsaWVkXG4gICAgY29uc3RyYWludEJyZWFrZG93biA9IHtcbiAgICAgIGdyaWQ6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIGNvb2xpbmc6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIHdhdGVyOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICBsYW5kOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICBlbmVyZ3lNdWx0aXBsaWVyOiAxLjAsIC8vIE5ldmVyIGFwcGxpZWRcbiAgICAgIHNpdGVNdWx0aXBsaWVyOiAxLjAsIC8vIE5vdCBhcHBsaWVkIC0gY29uc3RyYWludCBlZmZlY3RzIGFscmVhZHkgaW4gc2l0ZUNvc3RcbiAgICAgIGNhcGFjaXR5RGVsaXZlcnlNdWx0aXBsaWVyOiAxLjAsIC8vIE5vdCBhcHBsaWVkIC0gY29uc3RyYWludCBlZmZlY3RzIGFscmVhZHkgaW4gc2l0ZUNvc3RcbiAgICB9O1xuICAgIFxuICAgIGdyb3VuZFJlc3VsdCA9IHtcbiAgICAgIGVuZXJneUNvc3Q6IGVuZXJneUNvc3QsIC8vIFJhdyBlbGVjdHJpY2l0eSBjb3N0IChOTyBjb25zdHJhaW50IG11bHRpcGxpZXIpXG4gICAgICBzaXRlQ29zdDogc2l0ZUNvc3RQZXJQZmxvcFllYXIsIC8vIFNpdGUgPSBzdW0gb2YgY29tcG9uZW50cyAoSU5WQVJJQU5UKVxuICAgICAgc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXI6IHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyLCAvLyBFeHBsaWNpdDogcHVyZSBjYXBleFxuICAgICAgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW06IGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyLCAvLyBFeHBsaWNpdDogc2NhcmNpdHkgcHJlbWl1bVxuICAgICAgdGltZVRvRW5lcmdpemVQZW5hbHR5OiB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIsIC8vIFJlZ2lvbmFsIG1vZGVsOiAwIChub3QgbW9kZWxlZCBzZXBhcmF0ZWx5KVxuICAgICAgaGFyZHdhcmVDb3N0OiByZWdpb25hbFJlc3VsdC5oYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyLFxuICAgICAgdG90YWxDb3N0UGVyUGZsb3BZZWFyOiBncm91bmRUb3RhbENvc3QsXG4gICAgICBjb25zdHJhaW50TXVsdGlwbGllcjogMS4wLCAvLyBOT1QgQVBQTElFRCAtIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdCBvbmx5XG4gICAgICBjb25zdHJhaW50czoge1xuICAgICAgICBtZXRob2Q6ICdhZGRlcnMnLFxuICAgICAgICBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bTogY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXIsIC8vIEZyb20gcmVnaW9uYWwgbW9kZWwgc2l0ZUNvc3QgLSBzaXRlQ29zdEJhc2VcbiAgICAgICAgZGVsYXlQZW5hbHR5OiAwLCAvLyBSZWdpb25hbCBtb2RlbCBkb2Vzbid0IG1vZGVsIGRlbGF5IHNlcGFyYXRlbHlcbiAgICAgICAgYXBwbGllZE11bHRpcGxpZXJzOiB7XG4gICAgICAgICAgY29uc3RyYWludE11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgICBlbmVyZ3lNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgICAgc2l0ZU11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgZGVidWc6IHtcbiAgICAgICAgICBkb3VibGVDb3VudENoZWNrOiB7XG4gICAgICAgICAgICBtb2RlOiAnYWRkZXJzJyxcbiAgICAgICAgICAgIG11bHRpcGxpZXJBcHBsaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIGFkZGVyc0FwcGxpZWQ6IGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyID4gMCxcbiAgICAgICAgICAgIGludmFyaWFudE9rOiB0cnVlLFxuICAgICAgICAgICAgbm90ZXM6ICdSZWdpb25hbCBtb2RlbCB1c2VzIGFkZGVycyBvbmx5IChjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSBmcm9tIHNpdGVDb3N0IC0gc2l0ZUNvc3RCYXNlKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBicmVha2Rvd246IGNvbnN0cmFpbnRCcmVha2Rvd24sXG4gICAgICBzbXJFbmFibGVkOiBmYWxzZSxcbiAgICAgIHNtclJhbXBGYWN0b3I6IDAsXG4gICAgICBlZmZlY3RpdmVFbGVjdHJpY2l0eUNvc3Q6IHJlZ2lvbmFsUmVzdWx0LmF2ZXJhZ2VFbmVyZ3lDb3N0TXdoLFxuICAgICAgY29uc3RyYWludFJlbGllZjogeyBncmlkOiAwLCBjb29saW5nOiAwLCB3YXRlcjogMCwgbGFuZDogMCB9LFxuICAgICAgLy8gRW5zdXJlIGJhY2tsb2dHdyBhbmQgYXZnV2FpdFllYXJzIGFyZSBhbHdheXMgc2V0ICh1c2Ugc3VwcGx5TWV0cmljcyBhcyBmYWxsYmFjaylcbiAgICAgIGJhY2tsb2dHdzogcmVnaW9uYWxSZXN1bHQuc3VwcGx5TWV0cmljcz8ucGlwZWxpbmVHdyA/PyAwLCAvLyBURU1QIHByb3h5OiB1c2UgcGlwZWxpbmUgYXMgcGxhY2Vob2xkZXJcbiAgICAgIGF2Z1dhaXRZZWFyczogcmVnaW9uYWxSZXN1bHQuc3VwcGx5TWV0cmljcz8uYXZnV2FpdFllYXJzID8/IDAsXG4gICAgICBzdXBwbHlNZXRyaWNzOiByZWdpb25hbFJlc3VsdC5zdXBwbHlNZXRyaWNzID8/IHtcbiAgICAgICAgZGVtYW5kR3c6IDAsXG4gICAgICAgIGNhcGFjaXR5R3c6IDAsXG4gICAgICAgIHBpcGVsaW5lR3c6IDAsXG4gICAgICAgIG1heEJ1aWxkUmF0ZUd3WWVhcjogMCxcbiAgICAgICAgYXZnV2FpdFllYXJzOiAwLFxuICAgICAgICB1dGlsaXphdGlvblBjdDogMCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBncm91bmRSZXN1bHQgPSBjYWxjdWxhdGVHcm91bmRUb3RhbChcbiAgICAgIHllYXIsXG4gICAgICBwYXJhbXMsXG4gICAgICBFTkVSR1lfQ09TVF9CQVNFXzIwMjUsXG4gICAgICBncm91bmRIYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyLFxuICAgICAgcGFyYW1zLmlzU3RhdGljTW9kZSxcbiAgICAgIGVmZmVjdGl2ZUdyb3VuZFNjZW5hcmlvLFxuICAgICAgZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICBzbXJQYXJhbXMsXG4gICAgICBmaXJzdENhcFllYXIgPz8gbnVsbCxcbiAgICAgIGdyb3VuZEVuZXJneUNvc3RQZXJQZmxvcFllYXIsXG4gICAgICBncm91bmRFbGVjdHJpY2l0eVByaWNlUGVyTXdoXG4gICAgKTtcblxuICAgIC8vIENSSVRJQ0FMIEZJWDogRW5zdXJlIGJhY2tsb2dHdyBhbmQgYXZnV2FpdFllYXJzIGFyZSBhbHdheXMgc2V0IChldmVuIGlmIGNhbGN1bGF0ZUdyb3VuZFRvdGFsIGRvZXNuJ3QgcHJvdmlkZSB0aGVtKVxuICAgIC8vIFVzZSBzdXBwbHlNZXRyaWNzIGFzIGZhbGxiYWNrIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIDBcbiAgICAvLyBUeXBlIGFzc2VydGlvbiBuZWVkZWQgYmVjYXVzZSBjYWxjdWxhdGVHcm91bmRUb3RhbCBtYXkgbm90IGluY2x1ZGUgdGhlc2UgZmllbGRzXG4gICAgY29uc3QgZ3JvdW5kUmVzdWx0V2l0aEJhY2tsb2cgPSBncm91bmRSZXN1bHQgYXMgYW55O1xuICAgIGlmICghKCdiYWNrbG9nR3cnIGluIGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nKSB8fCBncm91bmRSZXN1bHRXaXRoQmFja2xvZy5iYWNrbG9nR3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZ3JvdW5kUmVzdWx0V2l0aEJhY2tsb2cuYmFja2xvZ0d3ID0gZ3JvdW5kUmVzdWx0V2l0aEJhY2tsb2cuc3VwcGx5TWV0cmljcz8ucGlwZWxpbmVHdyA/PyAwOyAvLyBURU1QIHByb3h5XG4gICAgfVxuICAgIGlmICghKCdhdmdXYWl0WWVhcnMnIGluIGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nKSB8fCBncm91bmRSZXN1bHRXaXRoQmFja2xvZy5hdmdXYWl0WWVhcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZ3JvdW5kUmVzdWx0V2l0aEJhY2tsb2cuYXZnV2FpdFllYXJzID0gZ3JvdW5kUmVzdWx0V2l0aEJhY2tsb2cuc3VwcGx5TWV0cmljcz8uYXZnV2FpdFllYXJzID8/IDA7XG4gICAgfVxuICAgIC8vIEVuc3VyZSBzdXBwbHlNZXRyaWNzIGV4aXN0c1xuICAgIGlmICghZ3JvdW5kUmVzdWx0V2l0aEJhY2tsb2cuc3VwcGx5TWV0cmljcykge1xuICAgICAgZ3JvdW5kUmVzdWx0V2l0aEJhY2tsb2cuc3VwcGx5TWV0cmljcyA9IHtcbiAgICAgICAgZGVtYW5kR3c6IDAsXG4gICAgICAgIGNhcGFjaXR5R3c6IDAsXG4gICAgICAgIHBpcGVsaW5lR3c6IGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nLmJhY2tsb2dHdyA/PyAwLFxuICAgICAgICBtYXhCdWlsZFJhdGVHd1llYXI6IDAsXG4gICAgICAgIGF2Z1dhaXRZZWFyczogZ3JvdW5kUmVzdWx0V2l0aEJhY2tsb2cuYXZnV2FpdFllYXJzID8/IDAsXG4gICAgICAgIHV0aWxpemF0aW9uUGN0OiAwLFxuICAgICAgfTtcbiAgICB9XG4gICAgZ3JvdW5kUmVzdWx0ID0gZ3JvdW5kUmVzdWx0V2l0aEJhY2tsb2c7XG5cbiAgICBncm91bmRUb3RhbENvc3QgPSBncm91bmRSZXN1bHQudG90YWxDb3N0UGVyUGZsb3BZZWFyO1xuICAgIGdyb3VuZEhhc1F1ZXVlID0gKGdyb3VuZFJlc3VsdC50aW1lVG9FbmVyZ2l6ZVBlbmFsdHkgPz8gMCkgPiAwLjAxOyAvLyBDaGVjayBpZiBkZWxheSBwZW5hbHR5IGV4aXN0c1xuICAgIGdyb3VuZENvbXBhcmF0b3JDb3N0UGVyUGZsb3BZZWFyID0gZ3JvdW5kSGFzUXVldWVcbiAgICAgID8gKGdyb3VuZFJlc3VsdC50b3RhbENvc3RQZXJQZmxvcFllYXJFZmZlY3RpdmUgPz8gZ3JvdW5kUmVzdWx0LnRvdGFsQ29zdFBlclBmbG9wWWVhcilcbiAgICAgIDogZ3JvdW5kVG90YWxDb3N0O1xuICAgIC8vIENSSVRJQ0FMIEZJWDogTmV2ZXIgYXBwbHkgbXVsdGlwbGllcnMgLSBhbGwgc2V0IHRvIDEuMFxuICAgIGVuZXJneUNvbnN0cmFpbnRNdWx0aXBsaWVyID0gMS4wOyAvLyBOZXZlciBhcHBsaWVkXG4gICAgXG4gICAgLy8gSW52YXJpYW50OiBJZiB1c2luZyBhZGRlcnMsIG11bHRpcGxpZXJzIG11c3Qgbm90IGJlIGFwcGxpZWRcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRzKSB7XG4gICAgICBjb25zdCBoYXNNdWx0aXBsaWVyID0gZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRNdWx0aXBsaWVyICE9PSAxLjA7XG4gICAgICBjb25zdCBoYXNBZGRlciA9IChncm91bmRSZXN1bHQuY29uc3RyYWludHMuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gPiAwKSB8fCAoZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRzLmRlbGF5UGVuYWx0eSA+IDApO1xuICAgICAgaWYgKGhhc011bHRpcGxpZXIgJiYgaGFzQWRkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBbRE9VQkxFIENPVU5USU5HIERFVEVDVEVEXSBZZWFyICR7eWVhcn06IGNvbnN0cmFpbnRNdWx0aXBsaWVyPSR7Z3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRNdWx0aXBsaWVyfSAhPSAxLjAgYCArXG4gICAgICAgICAgYEFORCBhZGRlcnMgPiAwIChjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bT0ke2dyb3VuZFJlc3VsdC5jb25zdHJhaW50cy5jYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bX0sIGAgK1xuICAgICAgICAgIGBkZWxheVBlbmFsdHk9JHtncm91bmRSZXN1bHQuY29uc3RyYWludHMuZGVsYXlQZW5hbHR5fSkuIEJvdGggY2Fubm90IGJlIGFwcGxpZWQgc2ltdWx0YW5lb3VzbHkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJhaW50QnJlYWtkb3duID0ge1xuICAgICAgZ3JpZDogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgY29vbGluZzogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgd2F0ZXI6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIGxhbmQ6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIGVuZXJneU11bHRpcGxpZXI6IDEuMCwgLy8gTmV2ZXIgYXBwbGllZFxuICAgICAgc2l0ZU11bHRpcGxpZXI6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIGNhcGFjaXR5RGVsaXZlcnlNdWx0aXBsaWVyOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgfTtcbiAgICBcbiAgICAvLyBJbnZhcmlhbnQ6IENoZWNrIGZvciBkb3VibGUgY291bnRpbmdcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGNvbnN0IGhhc011bHRpcGxpZXIgPSAoZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRNdWx0aXBsaWVyICE9PSAxLjApIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdyb3VuZFJlc3VsdC5icmVha2Rvd24uZW5lcmd5TXVsdGlwbGllciAhPT0gMS4wKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdyb3VuZFJlc3VsdC5icmVha2Rvd24uc2l0ZU11bHRpcGxpZXIgIT09IDEuMCk7XG4gICAgICBjb25zdCBoYXNQcmVtaXVtID0gKGdyb3VuZFJlc3VsdC5jYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSB8fCAwKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChncm91bmRSZXN1bHQudGltZVRvRW5lcmdpemVQZW5hbHR5IHx8IDApID4gMDtcbiAgICAgIGlmIChoYXNNdWx0aXBsaWVyICYmIGhhc1ByZW1pdW0pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBbRE9VQkxFIENPVU5USU5HIERFVEVDVEVEXSBZZWFyICR7eWVhcn06IGAgK1xuICAgICAgICAgIGBNdWx0aXBsaWVycyAoY29uc3RyYWludD0ke2dyb3VuZFJlc3VsdC5jb25zdHJhaW50TXVsdGlwbGllcn0sIGAgK1xuICAgICAgICAgIGBlbmVyZ3k9JHtncm91bmRSZXN1bHQuYnJlYWtkb3duLmVuZXJneU11bHRpcGxpZXJ9LCBgICtcbiAgICAgICAgICBgc2l0ZT0ke2dyb3VuZFJlc3VsdC5icmVha2Rvd24uc2l0ZU11bHRpcGxpZXJ9KSBBTkQgYCArXG4gICAgICAgICAgYHByZW1pdW1zIChjYXBhY2l0eT0ke2dyb3VuZFJlc3VsdC5jYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bX0sIGAgK1xuICAgICAgICAgIGBkZWxheT0ke2dyb3VuZFJlc3VsdC50aW1lVG9FbmVyZ2l6ZVBlbmFsdHl9KSBhcmUgYm90aCBwcmVzZW50LiBgICtcbiAgICAgICAgICBgVGhpcyBpbmRpY2F0ZXMgZG91YmxlIGNvdW50aW5nLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBsYXVuY2hDb3N0UGVyS2cgPSBnZXRMYXVuY2hDb3N0UGVyS2coeWVhciwgYmFzZUxhdW5jaENvc3QpICogbGF1bmNoRGlzY291bnQ7XG4gIGNvbnN0IGxpZmV0aW1lWWVhcnMgPSA2O1xuICBcbiAgLy8gRnVzaW9uIHRvZ2dsZSBwYXJhbXNcbiAgY29uc3QgZnVzaW9uUGFyYW1zID0gcGFyYW1zLmZ1c2lvblRvZ2dsZUVuYWJsZWQgXG4gICAgPyAocGFyYW1zLmZ1c2lvblRvZ2dsZVBhcmFtcyB8fCB7IC4uLkRFRkFVTFRfRlVTSU9OX1BBUkFNUywgZW5hYmxlZDogdHJ1ZSB9KVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIC8vIENPTlNURUxMQVRJT04gU0laSU5HOiBEZXNpZ24gY29uc3RlbGxhdGlvbiB0byBtZWV0IGNvbXB1dGUgcmVxdWlyZW1lbnRzXG4gIC8vIENvbnZlcnQgdGFyZ2V0IGNvbXB1dGUgKEdXKSB0byBwb3dlciAoa1cpIGZvciBjb25zdGVsbGF0aW9uIHNpemluZ1xuICBjb25zdCB0YXJnZXRDb21wdXRlS3cgPSBzYXRlbGxpdGVQb3dlcktXO1xuICBsZXQgY29uc3RlbGxhdGlvbiA9IGRlc2lnbkNvbnN0ZWxsYXRpb24oXG4gICAgdGFyZ2V0Q29tcHV0ZUt3LFxuICAgIFNBVEVMTElURV9DT05TVFJBSU5UUyxcbiAgICAxMDAwMDAsIC8vIFN0YXJzaGlwOiAxMDB0IHRvIExFT1xuICAgIHRyYWpTcGVjaWZpY1Bvd2VyXG4gICk7XG4gIFxuICAvLyBVc2UgcGVyLXNhdGVsbGl0ZSBjb21wdXRlIHBvd2VyIGZvciBjb3N0IGNhbGN1bGF0aW9uXG4gIGxldCBjb21wdXRlUG93ZXJQZXJTYXRLdyA9IGNvbnN0ZWxsYXRpb24uY29tcHV0ZVBlclNhdEt3O1xuXG4gIGxldCBoeWJyaWRSZXN1bHQgPSBjb21wdXRlU2F0ZWxsaXRlSHlicmlkQ29zdChcbiAgICB5ZWFyLCBcbiAgICBsYXVuY2hDb3N0UGVyS2csIFxuICAgIHtcbiAgICAgIC4uLkRFRkFVTFRfQ09ORklHLFxuICAgICAgY29tcHV0ZVBvd2VyS3c6IGNvbXB1dGVQb3dlclBlclNhdEt3LCAvLyBVc2UgcGVyLXNhdGVsbGl0ZSBwb3dlclxuICAgICAgYWx0aXR1ZGVLbTogb3JiaXRhbEFsdGl0dWRlLFxuICAgICAgbGlmZXRpbWVZZWFyczogbGlmZXRpbWVZZWFycyxcbiAgICAgIHNwZWNpZmljUG93ZXJXS2c6IHRyYWpTcGVjaWZpY1Bvd2VyLFxuICAgICAgdXNlUmFkSGFyZENoaXBzOiB1c2VSYWRIYXJkQ2hpcHMsXG4gICAgICBzdW5GcmFjdGlvbjogc3VuRnJhY3Rpb24sXG4gICAgICB3b3JrbG9hZFR5cGU6IHdvcmtsb2FkVHlwZSB8fCAnaW5mZXJlbmNlJ1xuICAgIH0sIFxuICAgIGZ1c2lvblBhcmFtcyxcbiAgICBwYXJhbXMudXNlQ29ycmVjdGVkU3BlY2lmaWNQb3dlcixcbiAgICBwYXJhbXMudXNlQ29ycmVjdGVkVGhlcm1hbFxuICApO1xuICBcbiAgLy8gQ1JJVElDQUwgRklYOiBDYWxjdWxhdGUgZGVsaXZlcmVkIGVmZmljaWVuY3kgd2l0aCBBTEwgZGVsaXZlcnkgZGVyYXRlc1xuICAvLyBkZWxpdmVyZWQgPSBzeXN0ZW1FZmZlY3RpdmUgKiB0aGVybWFsQ2FwRmFjdG9yICogcmFkaWF0aW9uRGVyYXRlICogYXZhaWxhYmlsaXR5XG4gIC8vIFNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIGFsbCB0aHJlZSBmYWN0b3JzOlxuICBjb25zdCB0aGVybWFsQ2FwRmFjdG9yID0gaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0udGhlcm1hbENhcEZhY3RvcjtcbiAgY29uc3QgcmFkaWF0aW9uRGVyYXRlID0gaHlicmlkUmVzdWx0LmRlZ3JhZGF0aW9uRmFjdG9yIHx8IDEuMDsgLy8gSGFyZHdhcmUgZGVncmFkYXRpb24gZnJvbSByYWRpYXRpb24gKGNoaXAgZmFpbHVyZXMsIEVDQyBvdmVyaGVhZClcbiAgY29uc3QgYXZhaWxhYmlsaXR5ID0gaHlicmlkUmVzdWx0LmNhcGFjaXR5RmFjdG9yIHx8IDEuMDsgLy8gQ2FwYWNpdHkgZmFjdG9yIGlzIHVwdGltZS1pbmNsdXNpdmUgKGluY2x1ZGVzIGVjbGlwc2UsIGRlZ3JhZGF0aW9uLCByYWRpYXRpb24gZG93bnRpbWUsIHVwdGltZSlcbiAgXG4gIC8vIENhbGN1bGF0ZSBkZWxpdmVyZWQgZWZmaWNpZW5jeSAoYWxsIGRlcmF0ZXMgYXBwbGllZCBtdWx0aXBsaWNhdGl2ZWx5KVxuICAvLyBUaGlzIGlzIHRoZSB0cnVlIFwiZGVsaXZlcmVkXCIgZWZmaWNpZW5jeSB0aGF0IGFjY291bnRzIGZvciBhbGwgb3BlcmF0aW9uYWwgY29uc3RyYWludHNcbiAgbGV0IG9yYml0RGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCA9IG9yYml0U3lzdGVtRWZmZWN0aXZlR2Zsb3BzUGVyV2F0dCAqIHRoZXJtYWxDYXBGYWN0b3IgKiByYWRpYXRpb25EZXJhdGUgKiBhdmFpbGFiaWxpdHk7XG4gIFxuICAvLyBDUklUSUNBTDogSWYgdGhlcm1hbCBjb25zdHJhaW50IGNhdXNlcyBkZWxpdmVyZWQgZWZmaWNpZW5jeSB0byBkcm9wIGJlbG93IG1pbmltdW0gKDIwIEdGTE9QUy9XKSxcbiAgLy8gdGhpcyBpbmRpY2F0ZXMgYSBzZXZlcmUgdGhlcm1hbCBjb25zdHJhaW50IHRoYXQgc2hvdWxkIGJlIGhhbmRsZWQgYnkgZXhwYW5kaW5nIHJhZGlhdG9yIG9yIHJlZHVjaW5nIGNvbXB1dGVcbiAgLy8gRm9yIG5vdywgd2UgY2xhbXAgdG8gbWluaW11bSB0byBwcmV2ZW50IHZhbGlkYXRpb24gZXJyb3JzLCBidXQgbG9nIGEgd2FybmluZyAob25seSBvbmNlIHBlciB5ZWFyKVxuICBpZiAob3JiaXREZWxpdmVyZWRHZmxvcHNQZXJXYXR0IDwgQ09OU1RBTlRTLk1JTl9ERUxJVkVSRURfR0ZMT1BTX1BFUl9XKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxEZWxpdmVyZWQgPSBvcmJpdERlbGl2ZXJlZEdmbG9wc1BlcldhdHQ7XG4gICAgb3JiaXREZWxpdmVyZWRHZmxvcHNQZXJXYXR0ID0gQ09OU1RBTlRTLk1JTl9ERUxJVkVSRURfR0ZMT1BTX1BFUl9XO1xuICAgIFxuICAgIC8vIExvZyB3YXJuaW5nIGFib3V0IHNldmVyZSB0aGVybWFsIGNvbnN0cmFpbnQgKG9ubHkgaW4gZGV2LCBhbmQgb25seSBvbmNlIHBlciB5ZWFyIHRvIHJlZHVjZSBzcGFtKVxuICAgIC8vIFRoZSBhY3R1YWwgY2xhbXBlZCB2YWx1ZSBpcyBhdmFpbGFibGUgaW4gb3JiaXQuY29tcHV0ZUVmZmljaWVuY3kudmFsaWRhdGlvbiBtZXRhZGF0YVxuICAgIC8vIFRoZXJtYWwgY29uc3RyYWludCB3YXJuaW5ncyByZW1vdmVkIGZvciBjbGVhbmVyIGNvbnNvbGUgb3V0cHV0XG4gIH1cbiAgXG4gIC8vIFVzZSBkZWxpdmVyZWQgZWZmaWNpZW5jeSBmb3IgYWxsIGNvc3QgY2FsY3VsYXRpb25zXG4gIGxldCBvcmJpdEVmZmVjdGl2ZUdmbG9wc1BlclcgPSB2YWxpZGF0ZUdmbG9wc1BlcldhdHQoXG4gICAgb3JiaXREZWxpdmVyZWRHZmxvcHNQZXJXYXR0LFxuICAgICdvcmJpdGFsIGRlbGl2ZXJlZCBlZmZpY2llbmN5IGNhbGN1bGF0aW9uJ1xuICApO1xuICBcbiAgLy8gUG93ZXIgc2NhbGluZyBjYWxjdWxhdGlvblxuICBjb25zdCBwb3dlclNjYWxpbmdQYXJhbXMgPSBwYXJhbXMucG93ZXJTY2FsaW5nUGFyYW1zIHx8IERFRkFVTFRfUE9XRVJfU0NBTElORztcbiAgY29uc3Qgc2NhbGluZ1Jlc3VsdCA9IGNhbGN1bGF0ZVNjYWxlZE1hc3MoY29tcHV0ZVBvd2VyUGVyU2F0S3csIHBvd2VyU2NhbGluZ1BhcmFtcyk7XG5cbiAgLy8gQ09OU1RFTExBVElPTiBTQ0FMSU5HOiBBcHBseSBjb25zdGVsbGF0aW9uIG11bHRpcGxpZXIgdG8gbWFzcyBhbmQgY29zdHNcbiAgLy8gUGVyLXNhdGVsbGl0ZSBtYXNzIChhbHJlYWR5IGNhbGN1bGF0ZWQgZm9yIG9uZSBzYXRlbGxpdGUpXG4gIGxldCBtYXNzUGVyU2F0S2cgPSBoeWJyaWRSZXN1bHQudG90YWxNYXNzS2cgKiBtYXNzTXVsdGlwbGllcjtcbiAgXG4gIC8vIENSSVRJQ0FMIEZJWDogQ2hlY2sgaWYgYWN0dWFsIG1hc3MgZXhjZWVkcyBsaW1pdCBhbmQgcmUtc3BsaXQgY29uc3RlbGxhdGlvbiBpZiBuZWVkZWRcbiAgLy8gVGhlIHNpbXBsaWZpZWQgbWFzcyBtb2RlbCBpbiBkZXNpZ25Db25zdGVsbGF0aW9uIG1heSB1bmRlcmVzdGltYXRlIGFjdHVhbCBtYXNzXG4gIC8vIElmIGFjdHVhbCBtYXNzIGV4Y2VlZHMgbGltaXQsIHdlIG5lZWQgdG8gc3BsaXQgaW50byBzbWFsbGVyIHNhdGVsbGl0ZXNcbiAgY29uc3QgTUFYX1NBVEVMTElURV9NQVNTX0tHID0gU0FURUxMSVRFX0NPTlNUUkFJTlRTLm1heE1hc3NLZzsgLy8gMTAsMDAwIGtnIGZyb20gY29uc3RyYWludHNcbiAgaWYgKG1hc3NQZXJTYXRLZyA+IE1BWF9TQVRFTExJVEVfTUFTU19LRykge1xuICAgIC8vIENhbGN1bGF0ZSByZXF1aXJlZCBjb21wdXRlIHBlciBzYXRlbGxpdGUgdG8gc3RheSB1bmRlciBtYXNzIGxpbWl0XG4gICAgLy8gTWFzcyBzY2FsZXMgcm91Z2hseSB3aXRoIGNvbXB1dGUgcG93ZXIsIHNvOiBtYXNzUGVyU2F0S2cgLyBjb21wdXRlUG93ZXJQZXJTYXRLdyA9IG1hc3NQZXJLd1xuICAgIGNvbnN0IG1hc3NQZXJLdyA9IG1hc3NQZXJTYXRLZyAvIGNvbXB1dGVQb3dlclBlclNhdEt3O1xuICAgIGNvbnN0IG1heENvbXB1dGVQZXJTYXRLdyA9IE1BWF9TQVRFTExJVEVfTUFTU19LRyAvIG1hc3NQZXJLdztcbiAgICBcbiAgICAvLyBSZWNhbGN1bGF0ZSBjb25zdGVsbGF0aW9uIHdpdGggc21hbGxlciBzYXRlbGxpdGVzXG4gICAgY29uc3QgYWRqdXN0ZWRDb25zdGVsbGF0aW9uID0gZGVzaWduQ29uc3RlbGxhdGlvbihcbiAgICAgIHRhcmdldENvbXB1dGVLdyxcbiAgICAgIHtcbiAgICAgICAgLi4uU0FURUxMSVRFX0NPTlNUUkFJTlRTLFxuICAgICAgICBtYXhDb21wdXRlS3c6IG1heENvbXB1dGVQZXJTYXRLdyAqIDAuOSwgLy8gVXNlIDkwJSBvZiBtYXggdG8gbGVhdmUgbWFyZ2luXG4gICAgICB9LFxuICAgICAgMTAwMDAwLCAvLyBTdGFyc2hpcDogMTAwdCB0byBMRU9cbiAgICAgIHRyYWpTcGVjaWZpY1Bvd2VyXG4gICAgKTtcbiAgICBcbiAgICAvLyBSZWNhbGN1bGF0ZSBoeWJyaWQgY29zdCB3aXRoIGFkanVzdGVkIGNvbXB1dGUgcGVyIHNhdGVsbGl0ZVxuICAgIGNvbnN0IGFkanVzdGVkSHlicmlkUmVzdWx0ID0gY29tcHV0ZVNhdGVsbGl0ZUh5YnJpZENvc3QoXG4gICAgICB5ZWFyLCBcbiAgICAgIGxhdW5jaENvc3RQZXJLZywgXG4gICAgICB7XG4gICAgICAgIC4uLkRFRkFVTFRfQ09ORklHLFxuICAgICAgICBjb21wdXRlUG93ZXJLdzogYWRqdXN0ZWRDb25zdGVsbGF0aW9uLmNvbXB1dGVQZXJTYXRLdyxcbiAgICAgICAgYWx0aXR1ZGVLbTogb3JiaXRhbEFsdGl0dWRlLFxuICAgICAgICBsaWZldGltZVllYXJzOiBsaWZldGltZVllYXJzLFxuICAgICAgICBzcGVjaWZpY1Bvd2VyV0tnOiB0cmFqU3BlY2lmaWNQb3dlcixcbiAgICAgICAgdXNlUmFkSGFyZENoaXBzOiB1c2VSYWRIYXJkQ2hpcHMsXG4gICAgICAgIHN1bkZyYWN0aW9uOiBzdW5GcmFjdGlvbixcbiAgICAgICAgd29ya2xvYWRUeXBlOiB3b3JrbG9hZFR5cGUgfHwgJ2luZmVyZW5jZSdcbiAgICAgIH0sIFxuICAgICAgZnVzaW9uUGFyYW1zLFxuICAgICAgcGFyYW1zLnVzZUNvcnJlY3RlZFNwZWNpZmljUG93ZXIsXG4gICAgICBwYXJhbXMudXNlQ29ycmVjdGVkVGhlcm1hbFxuICAgICk7XG4gICAgXG4gICAgLy8gVXBkYXRlIHdpdGggYWRqdXN0ZWQgdmFsdWVzXG4gICAgY29uc3QgYWRqdXN0ZWRNYXNzUGVyU2F0S2cgPSBhZGp1c3RlZEh5YnJpZFJlc3VsdC50b3RhbE1hc3NLZyAqIG1hc3NNdWx0aXBsaWVyO1xuICAgIGlmIChhZGp1c3RlZE1hc3NQZXJTYXRLZyA+IE1BWF9TQVRFTExJVEVfTUFTU19LRykge1xuICAgICAgLy8gU3RpbGwgdG9vIGhlYXZ5IC0gdGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBidXQgbG9nIGEgd2FybmluZ1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgU2F0ZWxsaXRlIG1hc3MgJHthZGp1c3RlZE1hc3NQZXJTYXRLZy50b0ZpeGVkKDApfWtnIHN0aWxsIGV4Y2VlZHMgbGltaXQgJHtNQVhfU0FURUxMSVRFX01BU1NfS0d9a2cgYCArXG4gICAgICAgIGBldmVuIGFmdGVyIHNwbGl0dGluZyB0byAke2FkanVzdGVkQ29uc3RlbGxhdGlvbi5jb21wdXRlUGVyU2F0S3cudG9GaXhlZCgxKX1rVyBwZXIgc2F0ZWxsaXRlLiBgICtcbiAgICAgICAgYENvbnNpZGVyIGZ1cnRoZXIgcmVkdWNpbmcgY29tcHV0ZSBwZXIgc2F0ZWxsaXRlIG9yIGltcHJvdmluZyBzcGVjaWZpYyBwb3dlci5gXG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICAvLyBVc2UgYWRqdXN0ZWQgY29uc3RlbGxhdGlvbiBhbmQgaHlicmlkIHJlc3VsdFxuICAgIGNvbnN0ZWxsYXRpb24gPSBhZGp1c3RlZENvbnN0ZWxsYXRpb247XG4gICAgaHlicmlkUmVzdWx0ID0gYWRqdXN0ZWRIeWJyaWRSZXN1bHQ7XG4gICAgY29tcHV0ZVBvd2VyUGVyU2F0S3cgPSBhZGp1c3RlZENvbnN0ZWxsYXRpb24uY29tcHV0ZVBlclNhdEt3O1xuICAgIG1hc3NQZXJTYXRLZyA9IGFkanVzdGVkTWFzc1BlclNhdEtnO1xuICAgIFxuICAgIC8vIFJlY2FsY3VsYXRlIGRlbGl2ZXJlZCBlZmZpY2llbmN5IHdpdGggYWRqdXN0ZWQgdGhlcm1hbCBjYXAgKGFsbCBkZXJhdGVzIGFwcGxpZWQpXG4gICAgY29uc3QgYWRqdXN0ZWRUaGVybWFsQ2FwRmFjdG9yID0gaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0udGhlcm1hbENhcEZhY3RvcjtcbiAgICBjb25zdCBhZGp1c3RlZFJhZGlhdGlvbkRlcmF0ZSA9IGh5YnJpZFJlc3VsdC5kZWdyYWRhdGlvbkZhY3RvciB8fCAxLjA7XG4gICAgY29uc3QgYWRqdXN0ZWRBdmFpbGFiaWxpdHkgPSBoeWJyaWRSZXN1bHQuY2FwYWNpdHlGYWN0b3IgfHwgMS4wO1xuICAgIGxldCBhZGp1c3RlZERlbGl2ZXJlZEdmbG9wc1BlcldhdHQgPSBvcmJpdFN5c3RlbUVmZmVjdGl2ZUdmbG9wc1BlcldhdHQgKiBhZGp1c3RlZFRoZXJtYWxDYXBGYWN0b3IgKiBhZGp1c3RlZFJhZGlhdGlvbkRlcmF0ZSAqIGFkanVzdGVkQXZhaWxhYmlsaXR5O1xuICAgIFxuICAgIC8vIENsYW1wIHRvIG1pbmltdW0gaWYgdGhlcm1hbCBjb25zdHJhaW50IGlzIHRvbyBzZXZlcmVcbiAgICBpZiAoYWRqdXN0ZWREZWxpdmVyZWRHZmxvcHNQZXJXYXR0IDwgQ09OU1RBTlRTLk1JTl9ERUxJVkVSRURfR0ZMT1BTX1BFUl9XKSB7XG4gICAgICBhZGp1c3RlZERlbGl2ZXJlZEdmbG9wc1BlcldhdHQgPSBDT05TVEFOVFMuTUlOX0RFTElWRVJFRF9HRkxPUFNfUEVSX1c7XG4gICAgfVxuICAgIFxuICAgIG9yYml0RWZmZWN0aXZlR2Zsb3BzUGVyVyA9IHZhbGlkYXRlR2Zsb3BzUGVyV2F0dChcbiAgICAgIGFkanVzdGVkRGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCxcbiAgICAgICdvcmJpdGFsIGRlbGl2ZXJlZCBlZmZpY2llbmN5IChhZnRlciBjb25zdGVsbGF0aW9uIHNwbGl0KSdcbiAgICApO1xuICB9XG4gIFxuICAvLyBTY2FsZSBjb3N0cyBieSBudW1iZXIgb2Ygc2F0ZWxsaXRlcyBhbmQgYXBwbHkgY29uc3RlbGxhdGlvbiBvdmVyaGVhZFxuICAvLyBDYWxjdWxhdGUgQUZURVIgbWFzcyBjaGVjayBzbyB3ZSB1c2UgdGhlIGFkanVzdGVkIGNvbnN0ZWxsYXRpb24gaWYgaXQgd2FzIHNwbGl0XG4gIGNvbnN0IGNvbnN0ZWxsYXRpb25NdWx0aXBsaWVyID0gY29uc3RlbGxhdGlvbi5udW1TYXRlbGxpdGVzO1xuICBjb25zdCBjb25zdGVsbGF0aW9uT3ZlcmhlYWRNdWx0aXBsaWVyID0gY29uc3RlbGxhdGlvbi5jb25zdGVsbGF0aW9uT3ZlcmhlYWQ7XG4gIFxuICAvLyBUb3RhbCBjb25zdGVsbGF0aW9uIG1hc3NcbiAgY29uc3QgZWZmZWN0aXZlVG90YWxNYXNzS2cgPSBtYXNzUGVyU2F0S2cgKiBjb25zdGVsbGF0aW9uLm51bVNhdGVsbGl0ZXM7XG4gIGNvbnN0IGVmZmVjdGl2ZVRvdGFsTGF1bmNoQ29zdCA9IGVmZmVjdGl2ZVRvdGFsTWFzc0tnICogbGF1bmNoQ29zdFBlcktnO1xuXG4gIC8vIEFwcGx5IEVsb24gU2NlbmFyaW86IERpc2NvdW50c1xuICBjb25zdCBlZmZlY3RpdmVQb3dlckZhYkNvc3QgPSBoeWJyaWRSZXN1bHQucG93ZXJTeXN0ZW0uZmFiQ29zdFVzZCAqIHBvd2VyRGlzY291bnQ7XG4gIGNvbnN0IGVmZmVjdGl2ZU5ldHdvcmtpbmdGYWJDb3N0ID0gaHlicmlkUmVzdWx0Lm5ldHdvcmtpbmcuZmFiQ29zdFVzZCAqIG5ldHdvcmtpbmdEaXNjb3VudDtcbiAgY29uc3QgZWZmZWN0aXZlTmV0d29ya2luZ09wRXggPSAoaHlicmlkUmVzdWx0Lm5ldHdvcmtpbmcuYW5udWFsT3BFeFVzZCB8fCAwKSAqIG5ldHdvcmtpbmdEaXNjb3VudDtcblxuICAvLyBFZmZlY3RpdmUgUEZMT1BzOiBwZXItc2F0ZWxsaXRlIFBGTE9QcyDDlyBudW1iZXIgb2Ygc2F0ZWxsaXRlc1xuICBjb25zdCBlZmZlY3RpdmVQZmxvcHNQZXJTYXQgPSBoeWJyaWRSZXN1bHQuZWZmZWN0aXZlUGZsb3BzO1xuICBjb25zdCB0b3RhbEVmZmVjdGl2ZVBmbG9wcyA9IGVmZmVjdGl2ZVBmbG9wc1BlclNhdCAqIGNvbnN0ZWxsYXRpb24ubnVtU2F0ZWxsaXRlcztcbiAgXG4gIC8vIExhdW5jaCBjb3N0OiB0b3RhbCBjb25zdGVsbGF0aW9uIGxhdW5jaCBjb3N0IC8gdG90YWwgUEZMT1BzXG4gIGNvbnN0IGxhdW5jaENvc3RQZXJQZmxvcFllYXIgPSBlZmZlY3RpdmVUb3RhbExhdW5jaENvc3QgLyB0b3RhbEVmZmVjdGl2ZVBmbG9wcyAvIGxpZmV0aW1lWWVhcnM7XG5cbiAgLy8gQ1JJVElDQUwgRklYIDE6IENvc3QgQWNjb3VudGluZyAtIGVuc3VyZSBicmVha2Rvd24gc3VtcyB0byB0b3RhbFxuICAvLyBDYWxjdWxhdGUgZWFjaCBjb21wb25lbnQgZXhwbGljaXRseSwgc2NhbGVkIGJ5IGNvbnN0ZWxsYXRpb25cbiAgLy8gUGVyLXNhdGVsbGl0ZSBjb3N0cyDDlyBudW1iZXIgb2Ygc2F0ZWxsaXRlcyDDlyBjb25zdGVsbGF0aW9uIG92ZXJoZWFkXG4gIGNvbnN0IGNvbnN0ZWxsYXRpb25Db3N0TXVsdGlwbGllciA9IGNvbnN0ZWxsYXRpb24ubnVtU2F0ZWxsaXRlcyAqIGNvbnN0ZWxsYXRpb25PdmVyaGVhZE11bHRpcGxpZXI7XG4gIFxuICBjb25zdCBwb3dlckNvc3QgPSAoZWZmZWN0aXZlUG93ZXJGYWJDb3N0ICogY29uc3RlbGxhdGlvbkNvc3RNdWx0aXBsaWVyKSAvIHRvdGFsRWZmZWN0aXZlUGZsb3BzIC8gbGlmZXRpbWVZZWFycztcbiAgY29uc3QgY29tcHV0ZUNvc3QgPSAoKGh5YnJpZFJlc3VsdC5jb21wdXRlUGF5bG9hZC5jaGlwQ29zdFVzZCArIGh5YnJpZFJlc3VsdC5jb21wdXRlUGF5bG9hZC5xdWFsaWZpY2F0aW9uQ29zdFVzZCkgKiBjb25zdGVsbGF0aW9uQ29zdE11bHRpcGxpZXIpIC8gdG90YWxFZmZlY3RpdmVQZmxvcHMgLyBsaWZldGltZVllYXJzO1xuICBjb25zdCB0aGVybWFsQ29zdCA9IChoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS5mYWJDb3N0VXNkICogY29uc3RlbGxhdGlvbkNvc3RNdWx0aXBsaWVyKSAvIHRvdGFsRWZmZWN0aXZlUGZsb3BzIC8gbGlmZXRpbWVZZWFycztcbiAgY29uc3QgcmFkaWF0aW9uQ29zdCA9IChoeWJyaWRSZXN1bHQucmFkaWF0aW9uUHJvdGVjdGlvbi5mYWJDb3N0VXNkICogY29uc3RlbGxhdGlvbkNvc3RNdWx0aXBsaWVyKSAvIHRvdGFsRWZmZWN0aXZlUGZsb3BzIC8gbGlmZXRpbWVZZWFycztcbiAgY29uc3QgYnVzQ29zdCA9IChoeWJyaWRSZXN1bHQuYnVzLmZhYkNvc3RVc2QgKiBjb25zdGVsbGF0aW9uQ29zdE11bHRpcGxpZXIpIC8gdG90YWxFZmZlY3RpdmVQZmxvcHMgLyBsaWZldGltZVllYXJzO1xuICBjb25zdCBuZXR3b3JraW5nQ29zdCA9IChlZmZlY3RpdmVOZXR3b3JraW5nRmFiQ29zdCAqIGNvbnN0ZWxsYXRpb25Db3N0TXVsdGlwbGllcikgLyB0b3RhbEVmZmVjdGl2ZVBmbG9wcyAvIGxpZmV0aW1lWWVhcnM7XG4gIGNvbnN0IGludGVyY29ubmVjdENvc3QgPSAoaHlicmlkUmVzdWx0LmludGVyY29ubmVjdC50b3RhbEFubnVhbENvc3QgKiBjb25zdGVsbGF0aW9uQ29zdE11bHRpcGxpZXIpIC8gdG90YWxFZmZlY3RpdmVQZmxvcHM7XG4gIGNvbnN0IHJlZ3VsYXRvcnlDb3N0ID0gKChoeWJyaWRSZXN1bHQucmVndWxhdG9yeT8uYW5udWFsQ29zdFVzZCB8fCAwKSAqIGNvbnN0ZWxsYXRpb25Db3N0TXVsdGlwbGllcikgLyB0b3RhbEVmZmVjdGl2ZVBmbG9wcztcbiAgXG4gIC8vIE9wcyBjb3N0IHNjYWxlcyB3aXRoIGNvbnN0ZWxsYXRpb24gb3ZlcmhlYWQgKG1vcmUgc2F0ZWxsaXRlcyA9IG1vcmUgb3BzIGNvbXBsZXhpdHkpXG4gIGNvbnN0IGJhc2VPcHNDb3N0UGVyU2F0ID0gaHlicmlkUmVzdWx0Lm9wc1BlclBmbG9wWWVhciAqIGVmZmVjdGl2ZVBmbG9wc1BlclNhdDsgLy8gVG90YWwgb3BzIGNvc3QgcGVyIHNhdGVsbGl0ZVxuICBjb25zdCBuZXR3b3JraW5nT3BzQ29zdFBlclNhdCA9IChoeWJyaWRSZXN1bHQubmV0d29ya2luZy5hbm51YWxPcEV4VXNkIHx8IDApIC0gZWZmZWN0aXZlTmV0d29ya2luZ09wRXg7IC8vIEFscmVhZHkgcGVyLXNhdFxuICBjb25zdCBhZGp1c3RlZE5ldHdvcmtpbmdPcHNDb3N0UGVyU2F0ID0gZWZmZWN0aXZlTmV0d29ya2luZ09wRXg7IC8vIEFscmVhZHkgcGVyLXNhdFxuICBjb25zdCBvcHNDb3N0UGVyU2F0ID0gYmFzZU9wc0Nvc3RQZXJTYXQgLSBuZXR3b3JraW5nT3BzQ29zdFBlclNhdCArIGFkanVzdGVkTmV0d29ya2luZ09wc0Nvc3RQZXJTYXQ7XG4gIFxuICAvLyBTY2FsZSBvcHMgY29zdCBieSBjb25zdGVsbGF0aW9uICh3aXRoIG92ZXJoZWFkIGZvciBjb29yZGluYXRpb24pXG4gIGNvbnN0IG9wc0Nvc3RNdWx0aXBsaWVyID0gY29uc3RlbGxhdGlvbi5udW1TYXRlbGxpdGVzICogKDEgKyAwLjEgKiBNYXRoLmxvZzEwKGNvbnN0ZWxsYXRpb24ubnVtU2F0ZWxsaXRlcykpO1xuICBjb25zdCBvcHNDb3N0ID0gKG9wc0Nvc3RQZXJTYXQgKiBvcHNDb3N0TXVsdGlwbGllcikgLyB0b3RhbEVmZmVjdGl2ZVBmbG9wcztcblxuICBjb25zdCBvcmJpdGFsQnJlYWtkb3duID0ge1xuICAgIHBvd2VyOiBwb3dlckNvc3QsXG4gICAgY29tcHV0ZTogY29tcHV0ZUNvc3QsXG4gICAgdGhlcm1hbDogdGhlcm1hbENvc3QsXG4gICAgcmFkaWF0aW9uOiByYWRpYXRpb25Db3N0LFxuICAgIGJ1czogYnVzQ29zdCxcbiAgICBvcHM6IG9wc0Nvc3QsXG4gICAgY29uZ2VzdGlvbjogMCwgLy8gQ2FsY3VsYXRlZCBiZWxvd1xuICAgIG5ldHdvcmtpbmc6IG5ldHdvcmtpbmdDb3N0LFxuICAgIGludGVyY29ubmVjdDogaW50ZXJjb25uZWN0Q29zdCxcbiAgICByZWd1bGF0b3J5OiByZWd1bGF0b3J5Q29zdCxcbiAgICBsYXVuY2g6IGxhdW5jaENvc3RQZXJQZmxvcFllYXJcbiAgfTtcblxuICBjb25zdCB0b3RhbFNhdGVsbGl0ZUNvc3QgPSBoeWJyaWRSZXN1bHQudG90YWxTYXRlbGxpdGVDb3N0ICogY29uc3RlbGxhdGlvbkNvc3RNdWx0aXBsaWVyO1xuICBjb25zdCBzYXRlbGxpdGVDb3VudCA9IGNvbnN0ZWxsYXRpb24ubnVtU2F0ZWxsaXRlczsgLy8gVXNlIGFjdHVhbCBjb25zdGVsbGF0aW9uIHNpemVcbiAgY29uc3QgY29uZ2VzdGlvbiA9IGNhbGN1bGF0ZUNvbmdlc3Rpb24oc2F0ZWxsaXRlQ291bnQsIHRvdGFsU2F0ZWxsaXRlQ29zdCwgeWVhciwgMTAwMDAgKyBzYXRlbGxpdGVDb3VudCwgc3BhY2VUcmFmZmljRW5hYmxlZCk7XG4gIFxuICAvLyBUb3RhbCBmbGVldCBQRkxPUFM6IHVzZSBjb25zdGVsbGF0aW9uIHRvdGFsIFBGTE9Qc1xuICAvLyBBbHJlYWR5IGNhbGN1bGF0ZWQgYXMgdG90YWxFZmZlY3RpdmVQZmxvcHMgYWJvdmVcbiAgb3JiaXRhbEJyZWFrZG93bi5jb25nZXN0aW9uID0gc3BhY2VUcmFmZmljRW5hYmxlZCA/IChjb25nZXN0aW9uLmNvbmdlc3Rpb25Db3N0UGVyUGZsb3BZZWFyIC8gdG90YWxFZmZlY3RpdmVQZmxvcHMpIDogMDtcblxuICAvLyBQQVRDSCBHOiBDb3N0IEFjY291bnRpbmcgSW52YXJpYW50c1xuICAvLyBVc2UgYXNzZXJ0Q29zdEFjY291bnRpbmcgdG8gZW5zdXJlIGJyZWFrZG93biBzdW1zIHRvIHRvdGFsIGV4YWN0bHlcbiAgY29uc3Qgb3JiaXRhbENvbXBvbmVudHMgPSBbXG4gICAgeyBuYW1lOiAncG93ZXInLCB2YWx1ZTogb3JiaXRhbEJyZWFrZG93bi5wb3dlciB9LFxuICAgIHsgbmFtZTogJ2NvbXB1dGUnLCB2YWx1ZTogb3JiaXRhbEJyZWFrZG93bi5jb21wdXRlIH0sXG4gICAgeyBuYW1lOiAndGhlcm1hbCcsIHZhbHVlOiBvcmJpdGFsQnJlYWtkb3duLnRoZXJtYWwgfSxcbiAgICB7IG5hbWU6ICdyYWRpYXRpb24nLCB2YWx1ZTogb3JiaXRhbEJyZWFrZG93bi5yYWRpYXRpb24gfSxcbiAgICB7IG5hbWU6ICdidXMnLCB2YWx1ZTogb3JiaXRhbEJyZWFrZG93bi5idXMgfSxcbiAgICB7IG5hbWU6ICdvcHMnLCB2YWx1ZTogb3JiaXRhbEJyZWFrZG93bi5vcHMgfSxcbiAgICB7IG5hbWU6ICduZXR3b3JraW5nJywgdmFsdWU6IG9yYml0YWxCcmVha2Rvd24ubmV0d29ya2luZyB9LFxuICAgIHsgbmFtZTogJ2ludGVyY29ubmVjdCcsIHZhbHVlOiBvcmJpdGFsQnJlYWtkb3duLmludGVyY29ubmVjdCB9LFxuICAgIHsgbmFtZTogJ3JlZ3VsYXRvcnknLCB2YWx1ZTogb3JiaXRhbEJyZWFrZG93bi5yZWd1bGF0b3J5IH0sXG4gICAgeyBuYW1lOiAnbGF1bmNoJywgdmFsdWU6IG9yYml0YWxCcmVha2Rvd24ubGF1bmNoIH0sXG4gICAgeyBuYW1lOiAnY29uZ2VzdGlvbicsIHZhbHVlOiBvcmJpdGFsQnJlYWtkb3duLmNvbmdlc3Rpb24gfSxcbiAgXTtcbiAgXG4gIGNvbnN0IGJyZWFrZG93blN1bSA9IE9iamVjdC52YWx1ZXMob3JiaXRhbEJyZWFrZG93bikucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gIGNvbnN0IHJlYWxpc3RpY0Nvc3RQZXJQZmxvcCA9IGJyZWFrZG93blN1bTtcbiAgXG4gIC8vIFRyYWNrIGFwcGxpZWQgbXVsdGlwbGllcnMgZm9yIGRlYnVnZ2luZ1xuICBjb25zdCBhcHBsaWVkTXVsdGlwbGllcnM6IEFycmF5PHsgbmFtZTogc3RyaW5nOyB2YWx1ZTogbnVtYmVyOyBhcHBsaWVkVG86IHN0cmluZyB9PiA9IFtcbiAgICB7IG5hbWU6ICdsYXVuY2hEaXNjb3VudCcsIHZhbHVlOiBsYXVuY2hEaXNjb3VudCwgYXBwbGllZFRvOiAnbGF1bmNoIGNvc3QnIH0sXG4gICAgeyBuYW1lOiAncG93ZXJEaXNjb3VudCcsIHZhbHVlOiBwb3dlckRpc2NvdW50LCBhcHBsaWVkVG86ICdwb3dlciBmYWIgY29zdCcgfSxcbiAgICB7IG5hbWU6ICduZXR3b3JraW5nRGlzY291bnQnLCB2YWx1ZTogbmV0d29ya2luZ0Rpc2NvdW50LCBhcHBsaWVkVG86ICduZXR3b3JraW5nIGNvc3QnIH0sXG4gICAgeyBuYW1lOiAnbWFzc011bHRpcGxpZXInLCB2YWx1ZTogbWFzc011bHRpcGxpZXIsIGFwcGxpZWRUbzogJ3RvdGFsIG1hc3MnIH0sXG4gIF07XG4gIFxuICAvLyBBc3NlcnQgY29zdCBhY2NvdW50aW5nICh0aHJvd3MgaWYgaW52YWxpZClcbiAgY29uc3Qgb3JiaXRhbEFjY291bnRpbmcgPSBhc3NlcnRDb3N0QWNjb3VudGluZyhyZWFsaXN0aWNDb3N0UGVyUGZsb3AsIG9yYml0YWxDb21wb25lbnRzLCBhcHBsaWVkTXVsdGlwbGllcnMpO1xuICBjb25zdCBjb3N0QWNjb3VudGluZ1ZhbGlkID0gb3JiaXRhbEFjY291bnRpbmcudmFsaWQ7XG4gIGNvbnN0IGNvc3RBY2NvdW50aW5nRXJyb3JQY3QgPSBvcmJpdGFsQWNjb3VudGluZy5lcnJvclBjdDtcblxuICAvLyBGSVggNTogR1BVLWhvdXIgYnJlYWtkb3duIG11c3QgZGVyaXZlIGZyb20gYW5udWFsIGNvc3QgYnJlYWtkb3duXG4gIC8vIEdQVS1ob3VyIHByaWNpbmc6IEFwcGx5IHNjYXJjaXR5IGFzIE1VTFRJUExJQ0FUSVZFIG11bHRpcGxpZXIgKG5vdCBhZGRpdGl2ZSlcbiAgLy8gZGVsYXlQZW5hbHR5IHJlbWFpbnMgYWRkaXRpdmUgKFdBQ0MgY2FycnkgY29zdCksIGJ1dCBzY2FyY2l0eSByZW50IGlzIG5vdyBtdWx0aXBsaWNhdGl2ZVxuICBjb25zdCBkZWxheVBlbmFsdHlQZXJQZmxvcFllYXIgPSBncm91bmRSZXN1bHQuY29uc3RyYWludHM/LmRlbGF5UGVuYWx0eSB8fCAwO1xuICBjb25zdCBzY2FyY2l0eU11bHRpcGxpZXIgPSBncm91bmRSZXN1bHQuY29uc3RyYWludHM/LnNjYXJjaXR5TXVsdGlwbGllciA/PyAxLjA7IC8vIE11bHRpcGxpZXIgZnJvbSBsb2ctYmFzZWQgZnVuY3Rpb25cbiAgXG4gIC8vIENvbnZlcnQgZGVsYXlQZW5hbHR5IHRvICQvR1BVLWhvdXIgKHN0aWxsIGFkZGl0aXZlKVxuICBjb25zdCBwZmxvcHNQZXJHcHUgPSAyLjA7XG4gIGNvbnN0IHV0aWxpemF0aW9uVGFyZ2V0ID0gMC44NTtcbiAgY29uc3QgaG91cnNQZXJZZWFyID0gODc2MDtcbiAgY29uc3QgYW5udWFsR3B1SG91cnNQZXJQRkxPUCA9IGhvdXJzUGVyWWVhciAqIHV0aWxpemF0aW9uVGFyZ2V0IC8gcGZsb3BzUGVyR3B1O1xuICBjb25zdCBkZWxheVBlbmFsdHlBZGRlclBlckdwdUhvdXIgPSBkZWxheVBlbmFsdHlQZXJQZmxvcFllYXIgLyBhbm51YWxHcHVIb3Vyc1BlclBGTE9QO1xuICBcbiAgLy8gTm90ZTogU2NhcmNpdHkgaXMgbm93IE1VTFRJUExJQ0FUSVZFIChub3QgYWRkaXRpdmUpLCBzbyBubyBjb252ZXJzaW9uIGNoZWNrIG5lZWRlZFxuICAvLyBTY2FyY2l0eSBtdWx0aXBsaWVyIGlzIGFwcGxpZWQgZGlyZWN0bHkgdG8gYmFzZSBjb3N0IGluIEdQVS1ob3VyIHByaWNpbmdcbiAgXG4gIC8vIFVzZSBCQVNFIGNvc3QgKHdpdGhvdXQgc2NhcmNpdHkpIGZvciBHUFUtaG91ciBwcmljaW5nLCB0aGVuIGFwcGx5IHNjYXJjaXR5IGFzIG11bHRpcGxpZXJcbiAgLy8gVGhpcyBwcmV2ZW50cyBkb3VibGUtY291bnRpbmc6IHNjYXJjaXR5IGlzIG11bHRpcGxpY2F0aXZlIGluIEdQVS1ob3VyIHByaWNpbmcsIG5vdCBhZGRpdGl2ZVxuICAvLyBXZSB3YW50OiBiYXNlQ29zdCAobm8gc2NhcmNpdHkpICogc2NhcmNpdHlNdWx0aXBsaWVyID0gdG90YWwgd2l0aCBzY2FyY2l0eVxuICAvLyBVc2UgZ3JvdW5kUmVzdWx0LnRvdGFsQ29zdFBlclBmbG9wWWVhckJhc2UgaWYgYXZhaWxhYmxlIChmcm9tIGJ1aWxkb3V0IG1vZGVsKSwgb3RoZXJ3aXNlIGNvbnN0cnVjdCBmcm9tIGNvbXBvbmVudHNcbiAgY29uc3QgZ3JvdW5kQ29zdEJhc2VGb3JQcmljaW5nID0gdXNlQnVpbGRvdXRNb2RlbCAmJiBncm91bmRSZXN1bHQ/LnRvdGFsQ29zdFBlclBmbG9wWWVhckJhc2UgIT09IHVuZGVmaW5lZFxuICAgID8gZ3JvdW5kUmVzdWx0LnRvdGFsQ29zdFBlclBmbG9wWWVhckJhc2VcbiAgICA6IChncm91bmRSZXN1bHQuZW5lcmd5Q29zdCArIGdyb3VuZFJlc3VsdC5zaXRlQ29zdCArIGdyb3VuZFJlc3VsdC5oYXJkd2FyZUNvc3QpICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHk7XG4gIFxuICBjb25zdCBncm91bmRHcHVIb3VyID0gKHNsYTogU0xBQ29uZmlnKSA9PiB7XG4gICAgY29uc3QgYmFzZVByaWNpbmcgPSBjYWxjdWxhdGVHcHVIb3VyUHJpY2luZyhncm91bmRDb3N0QmFzZUZvclByaWNpbmcsIHtcbiAgICAgIHBmbG9wc1BlckdwdSxcbiAgICAgIHV0aWxpemF0aW9uVGFyZ2V0LFxuICAgICAgb3BlcmF0b3JNYXJnaW5QY3Q6IG9wZXJhdG9yTWFyZ2luLFxuICAgICAgc2xhLFxuICAgICAgbG9jYXRpb246ICdncm91bmQnXG4gICAgfSwge1xuICAgICAgY29tcHV0ZTogZ3JvdW5kUmVzdWx0LmhhcmR3YXJlQ29zdCxcbiAgICAgIHBvd2VyOiBncm91bmRSZXN1bHQuZW5lcmd5Q29zdCxcbiAgICAgIHNpdGU6IHVzZUJ1aWxkb3V0TW9kZWwgPyBncm91bmRSZXN1bHQuc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgOiBncm91bmRSZXN1bHQuc2l0ZUNvc3QsXG4gICAgICAvLyBHcm91bmQgY29vbGluZyBpbmNsdWRlZCBpbiBlbmVyZ3ksIGludGVyY29ubmVjdCBtaW5pbWFsXG4gICAgfSk7XG4gICAgXG4gICAgLy8gVU5JRklFRCBTQ0FSQ0lUWSBBQ0NPVU5USU5HOiBTY2FyY2l0eSBpcyBNVUxUSVBMSUNBVElWRSAobm90IGFkZGl0aXZlKVxuICAgIC8vIENSSVRJQ0FMIEZJWDogQXBwbHkgc2NhcmNpdHkgYXMgcHJlbWl1bSBvbiBGSVhFRCByZWZlcmVuY2UgYmFzZSwgbm90IGRlY2xpbmluZyBiYXNlXG4gICAgLy8gVGhpcyBwcmV2ZW50cyBNb29yZSdzIExhdyBmcm9tIGVyb2Rpbmcgc2NhcmNpdHkgZG9sbGFyIGFtb3VudHNcbiAgICBcbiAgICAvLyBFeHRyYWN0IGJhc2UgY29zdCBiZWZvcmUgbWFyZ2luICh0aGlzIGRlY2xpbmVzIHdpdGggTW9vcmUncyBMYXcpXG4gICAgY29uc3QgcHJlTWFyZ2luQmFzZSA9IGJhc2VQcmljaW5nLnByaWNlUGVyR3B1SG91ciAtIChiYXNlUHJpY2luZy5jb3N0QnJlYWtkb3duLm1hcmdpbiB8fCAwKTtcbiAgICBcbiAgICAvLyBTY2FyY2l0eSBwcmVtaXVtIGJhc2VkIG9uIEZJWEVEIHJlZmVyZW5jZSwgbm90IGRlY2xpbmluZyBiYXNlXG4gICAgLy8gVGhpcyBlbnN1cmVzIHNjYXJjaXR5IGRvZXNuJ3QgZ2V0IGVyb2RlZCBieSBNb29yZSdzIExhd1xuICAgIGNvbnN0IFNDQVJDSVRZX1JFRkVSRU5DRV9CQVNFID0gMy41MDsgLy8gRml4ZWQgMjAyNSBtYXJrZXQgcmVmZXJlbmNlICgkL0dQVS1ocilcbiAgICBjb25zdCBzY2FyY2l0eVByZW1pdW0gPSAoc2NhcmNpdHlNdWx0aXBsaWVyIC0gMSkgKiBTQ0FSQ0lUWV9SRUZFUkVOQ0VfQkFTRTtcbiAgICBcbiAgICAvLyBUb3RhbCBjb3N0ID0gYmFzZSAoZGVjbGluaW5nIHdpdGggTW9vcmUncyBMYXcpICsgc2NhcmNpdHkgKGZpeGVkKSArIGRlbGF5XG4gICAgY29uc3QgY29zdFdpdGhTY2FyY2l0eSA9IHByZU1hcmdpbkJhc2UgKyBzY2FyY2l0eVByZW1pdW07XG4gICAgY29uc3QgY29zdFdpdGhTY2FyY2l0eUFuZERlbGF5ID0gY29zdFdpdGhTY2FyY2l0eSArIGRlbGF5UGVuYWx0eUFkZGVyUGVyR3B1SG91cjtcbiAgICBcbiAgICAvLyBUaGVuIGFkZCBtYXJnaW5cbiAgICBjb25zdCBtYXJnaW4gPSBjb3N0V2l0aFNjYXJjaXR5QW5kRGVsYXkgKiBvcGVyYXRvck1hcmdpbjtcbiAgICBjb25zdCBwcmljZVBlckdwdUhvdXIgPSBjb3N0V2l0aFNjYXJjaXR5QW5kRGVsYXkgKyBtYXJnaW47XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmJhc2VQcmljaW5nLFxuICAgICAgcHJpY2VQZXJHcHVIb3VyLFxuICAgICAgY29zdEJyZWFrZG93bjoge1xuICAgICAgICAuLi5iYXNlUHJpY2luZy5jb3N0QnJlYWtkb3duLFxuICAgICAgICBzY2FyY2l0eTogc2NhcmNpdHlQcmVtaXVtLCAvLyBGaXhlZC1iYXNlIHNjYXJjaXR5IHByZW1pdW0gKGRvZXNuJ3QgZGVjbGluZSB3aXRoIE1vb3JlJ3MgTGF3KVxuICAgICAgICBkZWxheVBlbmFsdHk6IGRlbGF5UGVuYWx0eUFkZGVyUGVyR3B1SG91ciwgLy8gRGVsYXkgcGVuYWx0eSAoV0FDQyBjYXJyeSlcbiAgICAgICAgbWFyZ2luLCAvLyBvdmVyd3JpdGUgd2l0aCByZWNvbXB1dGVkIG1hcmdpblxuICAgICAgfSxcbiAgICB9O1xuICB9O1xuXG4gIGNvbnN0IG9yYml0YWxHcHVIb3VyID0gKHNsYTogU0xBQ29uZmlnKSA9PiBjYWxjdWxhdGVHcHVIb3VyUHJpY2luZyhyZWFsaXN0aWNDb3N0UGVyUGZsb3AsIHtcbiAgICBwZmxvcHNQZXJHcHU6IDIuMCxcbiAgICB1dGlsaXphdGlvblRhcmdldDogMC44NSxcbiAgICBvcGVyYXRvck1hcmdpblBjdDogb3BlcmF0b3JNYXJnaW4sXG4gICAgc2xhLFxuICAgIGxvY2F0aW9uOiAnb3JiaXRhbCdcbiAgfSwgb3JiaXRhbEJyZWFrZG93bik7IC8vIFVzZSBmdWxsIG9yYml0YWwgYnJlYWtkb3duXG5cbiAgY29uc3QgZ3JvdW5kVG9rZW5zID0ge1xuICAgIGxsYW1hNzBCOiBjYWxjdWxhdGVUb2tlblByaWNpbmcoZ3JvdW5kVG90YWxDb3N0LCB7IHBhcmFtczogNzBlOSwgcHJlY2lzaW9uOiAnZnAxNicgfSksXG4gICAgbGxhbWE0MDVCOiBjYWxjdWxhdGVUb2tlblByaWNpbmcoZ3JvdW5kVG90YWxDb3N0LCB7IHBhcmFtczogNDA1ZTksIHByZWNpc2lvbjogJ2ZwMTYnIH0pXG4gIH07XG5cbiAgY29uc3Qgb3JiaXRhbFRva2VucyA9IHtcbiAgICBsbGFtYTcwQjogY2FsY3VsYXRlVG9rZW5QcmljaW5nKHJlYWxpc3RpY0Nvc3RQZXJQZmxvcCwgeyBwYXJhbXM6IDcwZTksIHByZWNpc2lvbjogJ2ZwMTYnIH0pLFxuICAgIGxsYW1hNDA1QjogY2FsY3VsYXRlVG9rZW5QcmljaW5nKHJlYWxpc3RpY0Nvc3RQZXJQZmxvcCwgeyBwYXJhbXM6IDQwNWU5LCBwcmVjaXNpb246ICdmcDE2JyB9KVxuICB9O1xuXG4gIGNvbnN0IGVkZ2VJbmZlcmVuY2UgPSBwYXJhbXMuZWRnZUluZmVyZW5jZT8uZW5hYmxlZCBcbiAgICA/IGNvbXB1dGVFZGdlSW5mZXJlbmNlQ29zdHMoeWVhciwgcGFyYW1zLmVkZ2VJbmZlcmVuY2UsIGxhdW5jaENvc3RQZXJLZywgdG90YWxFZmZlY3RpdmVQZmxvcHMgLyBlZmZlY3RpdmVUb3RhbE1hc3NLZylcbiAgICA6IHVuZGVmaW5lZDtcblxuICBjb25zdCBncHVIb3VyQ3Jvc3NvdmVyID0gb3JiaXRhbEdwdUhvdXIoU0xBX1RJRVJTLnN0YW5kYXJkKS5wcmljZVBlckdwdUhvdXIgPCBncm91bmRHcHVIb3VyKFNMQV9USUVSUy5zdGFuZGFyZCkucHJpY2VQZXJHcHVIb3VyO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gREVCVUcgSU5WQVJJQU5UUyAoZGV2ZWxvcG1lbnQgbW9kZSBvbmx5KVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIC8vIEludmFyaWFudCAxOiBJZiBhdmdXYWl0WWVhcnMgPiAwIHRoZW4gc2NhcmNpdHkgbXVsdGlwbGllciBzaG91bGQgYmUgPiAxLjAgKHNjYXJjaXR5IGlzIG11bHRpcGxpY2F0aXZlIGluIEdQVS1ob3VyIHByaWNpbmcpXG4gICAgY29uc3QgYXZnV2FpdFllYXJzID0gZ3JvdW5kUmVzdWx0LnN1cHBseU1ldHJpY3M/LmF2Z1dhaXRZZWFycyA/PyAwO1xuICAgIGNvbnN0IHNjYXJjaXR5TXVsdGlwbGllciA9IGdyb3VuZFJlc3VsdC5jb25zdHJhaW50cz8uc2NhcmNpdHlNdWx0aXBsaWVyID8/IDEuMDtcbiAgICBpZiAoYXZnV2FpdFllYXJzID4gMS4wICYmIHNjYXJjaXR5TXVsdGlwbGllciA8PSAxLjApIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFtJTlZBUklBTlQgVklPTEFUSU9OXSBZZWFyICR7eWVhcn06IGF2Z1dhaXRZZWFycz0ke2F2Z1dhaXRZZWFyc30gPiAxLjAgYnV0IHNjYXJjaXR5TXVsdGlwbGllcj0ke3NjYXJjaXR5TXVsdGlwbGllcn0gPD0gMS4wLiBgICtcbiAgICAgICAgYFNjYXJjaXR5IG11bHRpcGxpZXIgc2hvdWxkIGJlID4gMS4wIHdoZW4gd2FpdCB0aW1lIGV4aXN0cyAoc2NhcmNpdHkgaXMgbXVsdGlwbGljYXRpdmUgaW4gR1BVLWhvdXIgcHJpY2luZykuYFxuICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSW52YXJpYW50IDI6IHN1cHBseU1ldHJpY3MuY2FwYWNpdHlHdyBpcyB0aGUgZWZmZWN0aXZlIGNhcGFjaXR5IChib3R0bGVuZWNrKVxuICAgIC8vIFF1ZXVlIG1vZGVsIHVzZXMgY29oZXJlbnQgYmFja2xvZyBiYXNlZCBvbiB1bm1ldCBkZW1hbmRcbiAgICBcbiAgICAvLyBJbnZhcmlhbnQgMzogR1BVLWhvdXIgY2hhcnQgeU1heCBndWFyZCAocHJldmVudGVkIGJ5IGV4cGxpY2l0IHNlcmllcyBleHRyYWN0aW9uIGluIGNoYXJ0IGNvbXBvbmVudClcbiAgICAvLyBUaGlzIGlzIGhhbmRsZWQgaW4gdGhlIGNoYXJ0IGNvbXBvbmVudCB3aXRoIGV4cGxpY2l0IHNlcmllcyBleHRyYWN0aW9uXG4gICAgXG4gICAgLy8gSW52YXJpYW50IDQ6IENyb3Nzb3ZlciB1c2VzIGVmZmVjdGl2ZSBncm91bmQgY29zdFxuICAgIGNvbnN0IGdyb3VuZEVmZmVjdGl2ZSA9IGdyb3VuZFJlc3VsdC50b3RhbENvc3RQZXJQZmxvcFllYXJFZmZlY3RpdmUgPz8gZ3JvdW5kUmVzdWx0LnRvdGFsQ29zdFBlclBmbG9wWWVhcjtcbiAgICBjb25zdCBncm91bmRIZWFkbGluZSA9IGdyb3VuZFJlc3VsdC50b3RhbENvc3RQZXJQZmxvcFllYXI7XG4gICAgY29uc3QgZGVsYXlQZW5hbHR5ID0gZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRzPy5kZWxheVBlbmFsdHkgPz8gMDtcbiAgICAvLyBTY2FyY2l0eSBpcyBub3cgbXVsdGlwbGljYXRpdmUgKG5vdCBhZGRpdGl2ZSksIHNvIGRvbid0IGFkZCBpdCB0byBlZmZlY3RpdmUgY29zdFxuICAgIGNvbnN0IGV4cGVjdGVkRWZmZWN0aXZlID0gZ3JvdW5kSGVhZGxpbmUgKyBkZWxheVBlbmFsdHk7IC8vIFNjYXJjaXR5IGFwcGxpZWQgaW4gR1BVLWhvdXIgcHJpY2luZywgbm90IFBGTE9QLXllYXJcbiAgICBjb25zdCBlZmZlY3RpdmVFcnJvciA9IE1hdGguYWJzKGdyb3VuZEVmZmVjdGl2ZSAtIGV4cGVjdGVkRWZmZWN0aXZlKTtcbiAgICAvLyBSZXVzZSBzY2FyY2l0eU11bHRpcGxpZXIgZnJvbSBJbnZhcmlhbnQgMSBhYm92ZVxuICAgIGlmIChlZmZlY3RpdmVFcnJvciA+IDAuMDEgJiYgKGRlbGF5UGVuYWx0eSA+IDAgfHwgc2NhcmNpdHlNdWx0aXBsaWVyID4gMS4wKSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW0lOVkFSSUFOVCBWSU9MQVRJT05dIFllYXIgJHt5ZWFyfTogZ3JvdW5kRWZmZWN0aXZlPSR7Z3JvdW5kRWZmZWN0aXZlfSAhPSBleHBlY3RlZD0ke2V4cGVjdGVkRWZmZWN0aXZlfSBgICtcbiAgICAgICAgYChoZWFkbGluZT0ke2dyb3VuZEhlYWRsaW5lfSwgZGVsYXlQZW5hbHR5PSR7ZGVsYXlQZW5hbHR5fSwgc2NhcmNpdHlNdWx0aXBsaWVyPSR7c2NhcmNpdHlNdWx0aXBsaWVyfSkuIGAgK1xuICAgICAgICBgQ3Jvc3NvdmVyIHNob3VsZCB1c2UgZWZmZWN0aXZlIGNvc3QuIE5vdGU6IHNjYXJjaXR5IGlzIG11bHRpcGxpY2F0aXZlIGluIEdQVS1ob3VyIHByaWNpbmcsIG5vdCBhZGRpdGl2ZSBpbiBQRkxPUC15ZWFyLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ1JJVElDQUwgRklYOiBWYWxpZGF0ZSBkZWxpdmVyZWQgZWZmaWNpZW5jeSBieSBjb21wYXJpbmcgbGlrZS1mb3ItbGlrZSBvbmx5XG4gIC8vIGV4cGVjdGVkRGVsaXZlcmVkID0gc3lzdGVtRWZmZWN0aXZlR2Zsb3BzUGVyV2F0dCAqIHRoZXJtYWxDYXBGYWN0b3IgKiByYWRpYXRpb25EZXJhdGUgKiBhdmFpbGFiaWxpdHlcbiAgLy8gcmF0aW8gPSBkZWxpdmVyZWRHZmxvcHNQZXJXYXR0IC8gZXhwZWN0ZWREZWxpdmVyZWRcbiAgLy8gSWYgcmF0aW8gaXMgZmluaXRlIGFuZCB8MSAtIHJhdGlvfCA8PSB0b2xlcmFuY2UgKDAuMDIpLCB0aGVuIHZhbGlkPXRydWUsIHdhcm5pbmc9bnVsbFxuICAvLyBFbHNlIHZhbGlkPWZhbHNlLCB3YXJuaW5nIGRlc2NyaWJlcyB0aGUgbWlzbWF0Y2hcbiAgLy8gUmVtb3ZlIGFueSBvdGhlciBjb21wYXJpc29ucyAoZS5nLiwgZGVsaXZlcmVkIHZzIHN5c3RlbUVmZmVjdGl2ZSwgZGVsaXZlcmVkIHZzIHBlYWsqdXRpbGl6YXRpb24gd2l0aG91dCBvdmVyaGVhZCwgZXRjLilcbiAgY29uc3QgZXhwZWN0ZWREZWxpdmVyZWQgPSBvcmJpdFN5c3RlbUVmZmVjdGl2ZUdmbG9wc1BlcldhdHQgKiB0aGVybWFsQ2FwRmFjdG9yICogcmFkaWF0aW9uRGVyYXRlICogYXZhaWxhYmlsaXR5O1xuICBjb25zdCByYXRpbyA9IG9yYml0RGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCAvIE1hdGgubWF4KGV4cGVjdGVkRGVsaXZlcmVkLCAxZS02KTtcbiAgY29uc3QgVE9MRVJBTkNFID0gMC4wMjsgLy8gMiUgdG9sZXJhbmNlXG4gIGNvbnN0IHJhdGlvRXJyb3IgPSBNYXRoLmFicygxIC0gcmF0aW8pO1xuICBcbiAgLy8gQ1JJVElDQUw6IEZpeCB2YWxpZGF0b3IgbG9naWMgLSBpZiByYXRpbyBpcyBmaW5pdGUgYW5kIHwxIC0gcmF0aW98IDw9IHRvbGVyYW5jZSwgdGhlbiB2YWxpZD10cnVlXG4gIGNvbnN0IGlzUmF0aW9WYWxpZCA9IGlzRmluaXRlKHJhdGlvKSAmJiByYXRpb0Vycm9yIDw9IFRPTEVSQU5DRTtcbiAgXG4gIC8vIEVzY2FsYXRlOiBpZiBtaXNtYXRjaCA+IDUlLCBtYXJrIGFzIGludmFsaWQgKGRvbid0IGp1c3Qgd2FybilcbiAgY29uc3QgRVNDQUxBVEVfVEhSRVNIT0xEID0gMC4wNTsgLy8gNSVcbiAgY29uc3QgaXNJbnZhbGlkID0gIWlzUmF0aW9WYWxpZCAmJiByYXRpb0Vycm9yID4gRVNDQUxBVEVfVEhSRVNIT0xEO1xuICBcbiAgLy8gRGVidWcgaW52YXJpYW50czogYXNzZXJ0IGRlbGl2ZXJlZCA8PSBzeXN0ZW1FZmZlY3RpdmUgKyBlcHNcbiAgY29uc3QgZGVsaXZlcmVkVnNTeXN0ZW1FcnJvciA9IG9yYml0RGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCAtIG9yYml0U3lzdGVtRWZmZWN0aXZlR2Zsb3BzUGVyV2F0dDtcbiAgaWYgKGRlbGl2ZXJlZFZzU3lzdGVtRXJyb3IgPiAxZS02KSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYFtJTlZBUklBTlQgVklPTEFUSU9OXSBEZWxpdmVyZWQgZWZmaWNpZW5jeSAoJHtvcmJpdERlbGl2ZXJlZEdmbG9wc1BlcldhdHQudG9GaXhlZCgyKX0pID4gc3lzdGVtRWZmZWN0aXZlICgke29yYml0U3lzdGVtRWZmZWN0aXZlR2Zsb3BzUGVyV2F0dC50b0ZpeGVkKDIpfSkuIGAgK1xuICAgICAgYERlbGl2ZXJlZCBtdXN0IGJlIDw9IHN5c3RlbUVmZmVjdGl2ZS5gXG4gICAgKTtcbiAgfVxuICBcbiAgLy8gRWZmaWNpZW5jeSBkZWJ1ZyBsb2dnaW5nIHJlbW92ZWQgZm9yIGNsZWFuZXIgY29uc29sZSBvdXRwdXRcbiAgLy8gVmFsaWRhdGlvbiByZXN1bHRzIGFyZSBhdmFpbGFibGUgaW4gb3JiaXQuY29tcHV0ZUVmZmljaWVuY3kudmFsaWRhdGlvbiBtZXRhZGF0YVxuICBcbiAgLy8gQ1JJVElDQUw6IFZhbGlkYXRlIGRlbGl2ZXJlZCBlZmZpY2llbmN5IC0gY29tcGFyZSBkZWxpdmVyZWQgdnMgZXhwZWN0ZWREZWxpdmVyZWQgb25seVxuICAvLyBNYWtlIHZhbGlkYXRvciBkZWJ1ZyBleHBsaWNpdCB3aXRoIGFsbCBmYWN0b3JzXG4gIC8vIElmIG1pc21hdGNoID4gNSUsIG1hcmsgcnVuIGludmFsaWQgYW5kIHN0b3AgY2hhcnQgcmVuZGVyaW5nIChlc2NhbGF0ZSwgZG9uJ3Qgc2lsZW50bHkgd2FybilcbiAgY29uc3QgZGVsaXZlcmVkVmFsaWRhdGlvbiA9IHtcbiAgICB2YWxpZDogaXNSYXRpb1ZhbGlkLFxuICAgIHdhcm5pbmc6IGlzUmF0aW9WYWxpZCBcbiAgICAgID8gdW5kZWZpbmVkIC8vIEVtcHR5L251bGwgd2hlbiB2YWxpZFxuICAgICAgOiBgUG93ZXIvRWZmaWNpZW5jeSBtaXNtYXRjaDogJHtyYXRpby50b0ZpeGVkKDIpfXggZGlzY3JlcGFuY3kgKGV4cGVjdGVkPSR7ZXhwZWN0ZWREZWxpdmVyZWQudG9GaXhlZCgyKX0sIGRlbGl2ZXJlZD0ke29yYml0RGVsaXZlcmVkR2Zsb3BzUGVyV2F0dC50b0ZpeGVkKDIpfSlgLFxuICAgIGV4cGVjdGVkRGVsaXZlcmVkLFxuICAgIGRlbGl2ZXJlZDogb3JiaXREZWxpdmVyZWRHZmxvcHNQZXJXYXR0LFxuICAgIHJhdGlvLFxuICAgIGZhY3RvcnNVc2VkOiB7XG4gICAgICB0aGVybWFsQ2FwRmFjdG9yLFxuICAgICAgcmFkaWF0aW9uRGVyYXRlLFxuICAgICAgYXZhaWxhYmlsaXR5LFxuICAgICAgdXRpbGl6YXRpb246IG9yYml0YWxFZmZpY2llbmN5UmVzdWx0LmRlYnVnLnV0aWxpemF0aW9uRmFjdG9yLFxuICAgICAgc3lzdGVtT3ZlcmhlYWRGYWN0b3I6IG9yYml0YWxFZmZpY2llbmN5UmVzdWx0LmRlYnVnLnN5c3RlbU92ZXJoZWFkRmFjdG9yLFxuICAgIH0sXG4gICAgLy8gRXNjYWxhdGU6IGlmIHJhdGlvIGlzIHdheSBvZmYgKD4gNSUpLCBtYXJrIGFzIGludmFsaWRcbiAgICBpbnZhbGlkOiAhaXNSYXRpb1ZhbGlkICYmIE1hdGguYWJzKDEgLSByYXRpbykgPiAwLjA1LFxuICB9O1xuICBcbiAgY29uc3QgZWZmaWNpZW5jeVZhbGlkYXRpb24gPSB2YWxpZGF0ZUNvbXB1dGVFZmZpY2llbmN5KG9yYml0RWZmZWN0aXZlR2Zsb3BzUGVyVywgcGFyYW1zLmVmZmljaWVuY3lMZXZlbCk7XG4gIGNvbnN0IGNvbnNpc3RlbmN5Q2hlY2sgPSBhc3NlcnRDb21wdXRlUG93ZXJDb25zaXN0ZW5jeShvcmJpdEVmZmVjdGl2ZUdmbG9wc1BlclcsIHRhcmdldENvbXB1dGVLdywgdG90YWxFZmZlY3RpdmVQZmxvcHMsIE1PREVMX1VOSVRTKTtcblxuICAvLyBTQU5JVFkgUEFORUw6IENvbXByZWhlbnNpdmUgZGVidWcgYmxvY2sgcGVyIHllYXJcbiAgY29uc3Qgc2FuaXR5UGFuZWwgPSB7XG4gICAgZ3JvdW5kOiB7XG4gICAgICBlZmZlY3RpdmVHZmxvcHNQZXJXOiBncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXLFxuICAgICAgZW5lcmd5Q29zdFBlclBmbG9wWWVhcjogZ3JvdW5kUmVzdWx0LmVuZXJneUNvc3QsXG4gICAgICBzaXRlQ2FwZXhBbW9ydDogZ3JvdW5kUmVzdWx0LnNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyID8/IChncm91bmRSZXN1bHQuc2l0ZUNvc3QgLSAoZ3JvdW5kUmVzdWx0LmNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtID8/IDApIC0gKGdyb3VuZFJlc3VsdC50aW1lVG9FbmVyZ2l6ZVBlbmFsdHkgPz8gMCkpLFxuICAgICAgZGVsYXlQZW5hbHR5OiBncm91bmRSZXN1bHQudGltZVRvRW5lcmdpemVQZW5hbHR5ID8/IDAsXG4gICAgICBjYXBhY2l0eVByZW1pdW06IGdyb3VuZFJlc3VsdC5jYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSA/PyAwLFxuICAgICAgY29uc3RyYWludE11bHRpcGxpZXI6IGdyb3VuZFJlc3VsdC5jb25zdHJhaW50TXVsdGlwbGllcixcbiAgICAgIHRvdGFsOiBncm91bmRUb3RhbENvc3QsXG4gICAgfSxcbiAgICBvcmJpdDoge1xuICAgICAgLy8gUkVNT1ZFRDogZWZmZWN0aXZlU3BlY2lmaWNQb3dlciAoZHVwbGljYXRlIG9mIHNwZWNpZmljUG93ZXJfZWZmZWN0aXZlX1dQZXJLZylcbiAgICAgIC8vIFVzZSBzcGVjaWZpY1Bvd2VyX2VmZmVjdGl2ZV9XUGVyS2cgaW5zdGVhZCAoY2Fub25pY2FsIGZpZWxkKVxuICAgICAgbWFzc011bHRpcGxpZXI6IGh5YnJpZFJlc3VsdC5zcGVjaWZpY1Bvd2VyTXVsdGlwbGllcnM/Lm1hc3NNdWx0aXBsaWVyID8/IDEuMCxcbiAgICAgIHJlcXVpcmVkQXJlYU0yOiBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS5xUGVyTTJfVyA/IChoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS53YXN0ZUhlYXRXID8/IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLndhc3RlSGVhdEt3ICogMTAwMCkgLyAoaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0ucVBlck0yX1cgPz8gMSkgOiBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS5waHlzaWNhbEFyZWFNMixcbiAgICAgIGFyZWFBdmFpbGFibGVNMjogaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0uYXJlYUF2YWlsYWJsZU0yID8/IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnBoeXNpY2FsQXJlYU0yLFxuICAgICAgdGhlcm1hbENhcEZhY3RvcjogaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0udGhlcm1hbENhcEZhY3RvcixcbiAgICAgIHRvdGFsOiByZWFsaXN0aWNDb3N0UGVyUGZsb3AsXG4gICAgfSxcbiAgICBhbGxJbnZhcmlhbnRzUGFzc2VkOiAoKCkgPT4ge1xuICAgICAgLy8gQ2hlY2sga2V5IGludmFyaWFudHNcbiAgICAgIGNvbnN0IHNpdGVDb3N0Q2hlY2sgPSBNYXRoLmFicyhncm91bmRSZXN1bHQuc2l0ZUNvc3QgLSAoKGdyb3VuZFJlc3VsdC5zaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciA/PyAwKSArIChncm91bmRSZXN1bHQudGltZVRvRW5lcmdpemVQZW5hbHR5ID8/IDApICsgKGdyb3VuZFJlc3VsdC5jYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSA/PyAwKSkpIDwgMC4wMTtcbiAgICAgIGNvbnN0IHRoZXJtYWxBcmVhQ2hlY2sgPSBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS5hcmVhQXZhaWxhYmxlTTIgPyBNYXRoLmFicyhoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS5hcmVhQXZhaWxhYmxlTTIgLSBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS5waHlzaWNhbEFyZWFNMikgLyBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS5waHlzaWNhbEFyZWFNMiA8IDAuMDEgOiB0cnVlO1xuICAgICAgY29uc3Qgc3BlY2lmaWNQb3dlckNoZWNrID0gaHlicmlkUmVzdWx0LnNwZWNpZmljUG93ZXJNdWx0aXBsaWVycyA/IGh5YnJpZFJlc3VsdC5zcGVjaWZpY1Bvd2VyTXVsdGlwbGllcnMuZWZmZWN0aXZlIDw9IGh5YnJpZFJlc3VsdC5zcGVjaWZpY1Bvd2VyTXVsdGlwbGllcnMuYmFzZVNwZWNpZmljUG93ZXIgKiAxLjAxIDogdHJ1ZTtcbiAgICAgIGNvbnN0IHRoZXJtYWxDYXBDaGVjayA9IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnRoZXJtYWxDYXBGYWN0b3IgPj0gMCAmJiBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS50aGVybWFsQ2FwRmFjdG9yIDw9IDE7XG4gICAgICByZXR1cm4gc2l0ZUNvc3RDaGVjayAmJiB0aGVybWFsQXJlYUNoZWNrICYmIHNwZWNpZmljUG93ZXJDaGVjayAmJiB0aGVybWFsQ2FwQ2hlY2s7XG4gICAgfSkoKSxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHllYXIsXG4gICAgbW9kZTogcGFyYW1zLmlzU3RhdGljTW9kZSA/ICdTVEFUSUMnIDogJ0RZTkFNSUMnLFxuICAgIHNhbml0eVBhbmVsLFxuICAgIGdyb3VuZDoge1xuICAgICAgZWxlY3RyaWNpdHlQcmljZVBlck13aDogZ3JvdW5kRWxlY3RyaWNpdHlQcmljZVBlck13aCxcbiAgICAgIHB1ZTogZWZmZWN0aXZlUHVlR3JvdW5kLFxuICAgICAgY2FwYWNpdHlGYWN0b3I6IGNhcGFjaXR5RmFjdG9yR3JvdW5kLFxuICAgICAgLy8gSEFSRCBBU1NFUlQ6IEFsbCBncm91bmQgZWZmaWNpZW5jeSBmaWVsZHMgbXVzdCBiZSBwb3B1bGF0ZWQgYW5kIGZpbml0ZVxuICAgICAgZ2Zsb3BzUGVyV2F0dDogKCgpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXO1xuICAgICAgICBpZiAoIWlzRmluaXRlKHZhbHVlKSB8fCB2YWx1ZSA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBncm91bmQuZ2Zsb3BzUGVyV2F0dCBpcyBpbnZhbGlkOiAke3ZhbHVlfS4gYWN0dWFsR3JvdW5kSW5wdXQ9JHthY3R1YWxHcm91bmRJbnB1dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KSgpLCAvLyBFZmZlY3RpdmUgKHN5c3RlbSkgR0ZMT1BTL1dcbiAgICAgIGNvbXB1dGVEZWZpbml0aW9uOiAoKCkgPT4ge1xuICAgICAgICAvLyBDUklUSUNBTCBGSVg6IFZhbGlkYXRlIGFsbCBjb21wdXRlRGVmaW5pdGlvbiBmaWVsZHMgdG8gY2F0Y2ggdW5pdCBjb3JydXB0aW9uXG4gICAgICAgIGNvbnN0IHBlYWsgPSB2YWxpZGF0ZUdmbG9wc1BlcldhdHQoXG4gICAgICAgICAgZ3JvdW5kRWZmaWNpZW5jeVJlc3VsdC5kZWJ1Zy5jaGlwUGVha0dmbG9wc1BlclcsXG4gICAgICAgICAgJ2dyb3VuZC5jb21wdXRlRGVmaW5pdGlvbi5wZWFrR2Zsb3BzUGVyV2F0dCdcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgZWZmZWN0aXZlID0gdmFsaWRhdGVHZmxvcHNQZXJXYXR0KFxuICAgICAgICAgIGdyb3VuZEVmZmljaWVuY3lSZXN1bHQuZGVidWcuZWZmZWN0aXZlR2Zsb3BzUGVyVyxcbiAgICAgICAgICAnZ3JvdW5kLmNvbXB1dGVEZWZpbml0aW9uLmVmZmVjdGl2ZUdmbG9wc1BlcldhdHQnXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHV0aWxpemF0aW9uID0gZ3JvdW5kRWZmaWNpZW5jeVJlc3VsdC5kZWJ1Zy51dGlsaXphdGlvbkZhY3RvcjtcbiAgICAgICAgXG4gICAgICAgIGlmICghaXNGaW5pdGUodXRpbGl6YXRpb24pIHx8IHV0aWxpemF0aW9uIDw9IDAgfHwgdXRpbGl6YXRpb24gPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBncm91bmQuY29tcHV0ZURlZmluaXRpb24udXRpbGl6YXRpb25GYWN0b3IgaXMgaW52YWxpZDogJHt1dGlsaXphdGlvbn1gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGlwTmFtZTogJ05WSURJQSBIMTAwIFNYTScsXG4gICAgICAgICAgcHJlY2lzaW9uOiAnRlAxNicsXG4gICAgICAgICAgcGVha0dmbG9wc1BlcldhdHQ6IHBlYWssXG4gICAgICAgICAgdXRpbGl6YXRpb25GYWN0b3I6IHV0aWxpemF0aW9uLFxuICAgICAgICAgIGVmZmVjdGl2ZUdmbG9wc1BlcldhdHQ6IGVmZmVjdGl2ZSxcbiAgICAgICAgICBub3RlczogJ0RhdGFjZW50ZXIgZGVwbG95bWVudCwgc3lzdGVtLWxldmVsIGVmZmljaWVuY3knLFxuICAgICAgICB9O1xuICAgICAgfSkoKSxcbiAgICAgIGVuZXJneUNvc3RQZXJQZmxvcFllYXI6ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ3JvdW5kUmVzdWx0LmVuZXJneUNvc3Q7XG4gICAgICAgIGlmICghaXNGaW5pdGUodmFsdWUpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBncm91bmQuZW5lcmd5Q29zdFBlclBmbG9wWWVhciBpcyBpbnZhbGlkOiAke3ZhbHVlfS4gYCArXG4gICAgICAgICAgICBgQ2hlY2s6IGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1Blclc9JHtncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXfSwgYCArXG4gICAgICAgICAgICBgZ3JvdW5kRWxlY3RyaWNpdHlQcmljZVBlck13aD0ke2dyb3VuZEVsZWN0cmljaXR5UHJpY2VQZXJNd2h9LCBgICtcbiAgICAgICAgICAgIGBlZmZlY3RpdmVQdWVHcm91bmQ9JHtlZmZlY3RpdmVQdWVHcm91bmR9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSkoKSwgLy8gUmF3IGVsZWN0cmljaXR5IChOTyBjb25zdHJhaW50IG11bHRpcGxpZXIpXG4gICAgICBzaXRlQ29zdFBlclBmbG9wWWVhcjogKCgpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBncm91bmRSZXN1bHQuc2l0ZUNvc3Q7XG4gICAgICAgIGlmICghaXNGaW5pdGUodmFsdWUpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZ3JvdW5kLnNpdGVDb3N0UGVyUGZsb3BZZWFyIGlzIGludmFsaWQ6ICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSkoKSwgLy8gU2l0ZSBjb3N0cyA9IHN1bSBvZiBjb21wb25lbnRzIChJTlZBUklBTlQpXG4gICAgICBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhcjogZ3JvdW5kUmVzdWx0LnNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyID8/IChncm91bmRSZXN1bHQuc2l0ZUNvc3QgLSAoZ3JvdW5kUmVzdWx0LmNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtID8/IDApIC0gKGdyb3VuZFJlc3VsdC50aW1lVG9FbmVyZ2l6ZVBlbmFsdHkgPz8gMCkpLCAvLyBQdXJlIGNhcGV4IGFtb3J0aXphdGlvblxuICAgICAgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW06IGdyb3VuZFJlc3VsdC5jYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSA/PyAwLCAvLyBFeHBsaWNpdCBjYXBhY2l0eS9kZWxpdmVyeSBwcmVtaXVtIChpbmRlcGVuZGVudClcbiAgICAgIHRpbWVUb0VuZXJnaXplUGVuYWx0eTogZ3JvdW5kUmVzdWx0LnRpbWVUb0VuZXJnaXplUGVuYWx0eSA/PyAwLCAvLyBRdWV1ZSBkZWxheSBwZW5hbHR5IChXQUNDLWJhc2VkLCBpbmRlcGVuZGVudClcbiAgICAgIGhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXI6IGdyb3VuZFJlc3VsdC5oYXJkd2FyZUNvc3QsXG4gICAgICBjb25zdHJhaW50TXVsdGlwbGllcjogMS4wLCAvLyBOT1QgQVBQTElFRCAtIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdCBvbmx5XG4gICAgICBjb25zdHJhaW50QnJlYWtkb3duOiB7XG4gICAgICAgIC4uLmNvbnN0cmFpbnRCcmVha2Rvd24sXG4gICAgICAgIGNhcGFjaXR5RGVsaXZlcnlNdWx0aXBsaWVyOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICB9LFxuICAgICAgY29uc3RyYWludHM6IChncm91bmRSZXN1bHQuY29uc3RyYWludHMgPyB7XG4gICAgICAgIC4uLmdyb3VuZFJlc3VsdC5jb25zdHJhaW50cyxcbiAgICAgICAgbWV0aG9kOiAnYWRkZXJzJyBhcyBjb25zdCxcbiAgICAgIH0gOiB7XG4gICAgICAgIG1ldGhvZDogJ2FkZGVycycgYXMgY29uc3QsXG4gICAgICAgIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtOiAoZ3JvdW5kUmVzdWx0LmNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtIHx8IDApLFxuICAgICAgICBkZWxheVBlbmFsdHk6IChncm91bmRSZXN1bHQudGltZVRvRW5lcmdpemVQZW5hbHR5IHx8IDApLFxuICAgICAgICBhcHBsaWVkTXVsdGlwbGllcnM6IHtcbiAgICAgICAgICBjb25zdHJhaW50TXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgICAgIGVuZXJneU11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgICBzaXRlTXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgfSkgYXMgeyBtZXRob2Q6ICdhZGRlcnMnOyBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bTogbnVtYmVyOyBkZWxheVBlbmFsdHk6IG51bWJlcjsgYXBwbGllZE11bHRpcGxpZXJzOiB7IGNvbnN0cmFpbnRNdWx0aXBsaWVyVXNlZDogYm9vbGVhbjsgZW5lcmd5TXVsdGlwbGllclVzZWQ6IGJvb2xlYW47IHNpdGVNdWx0aXBsaWVyVXNlZDogYm9vbGVhbjsgfTsgZGVidWc/OiBhbnkgfSxcbiAgICAgIHN1cHBseU1ldHJpY3M6IChncm91bmRSZXN1bHQgYXMgYW55KS5zdXBwbHlNZXRyaWNzLFxuICAgICAgY29uc3RyYWludENvbXBvbmVudHM6IChncm91bmRSZXN1bHQgYXMgYW55KS5jb25zdHJhaW50Q29tcG9uZW50cyxcbiAgICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhcjogKCgpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBncm91bmRUb3RhbENvc3Q7XG4gICAgICAgIGlmICghaXNGaW5pdGUodmFsdWUpIHx8IHZhbHVlIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgZ3JvdW5kLnRvdGFsQ29zdFBlclBmbG9wWWVhciBpcyBpbnZhbGlkOiAke3ZhbHVlfS4gYCArXG4gICAgICAgICAgICBgQ29tcG9uZW50czogZW5lcmd5PSR7Z3JvdW5kUmVzdWx0LmVuZXJneUNvc3R9LCBzaXRlPSR7Z3JvdW5kUmVzdWx0LnNpdGVDb3N0fSwgaGFyZHdhcmU9JHtncm91bmRSZXN1bHQuaGFyZHdhcmVDb3N0fSwgYCArXG4gICAgICAgICAgICBgZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyVz0ke2dyb3VuZEVmZmVjdGl2ZUdmbG9wc1Blcld9LCBhY3R1YWxHcm91bmRJbnB1dD0ke2FjdHVhbEdyb3VuZElucHV0fWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pKCksXG4gICAgICBncHVIb3VyUHJpY2luZzoge1xuICAgICAgICBiYXNpYzogZ3JvdW5kR3B1SG91cihTTEFfVElFUlMuYmFzaWMpLFxuICAgICAgICBzdGFuZGFyZDogZ3JvdW5kR3B1SG91cihTTEFfVElFUlMuc3RhbmRhcmQpLFxuICAgICAgICBwcmVtaXVtOiBncm91bmRHcHVIb3VyKFNMQV9USUVSUy5wcmVtaXVtKSxcbiAgICAgIH0sXG4gICAgICB0b2tlblByaWNpbmc6IGdyb3VuZFRva2VucyxcbiAgICAgIHNtckVuYWJsZWQ6IGdyb3VuZFJlc3VsdC5zbXJFbmFibGVkLFxuICAgICAgc21yUmFtcEZhY3RvcjogZ3JvdW5kUmVzdWx0LnNtclJhbXBGYWN0b3IsXG4gICAgICBlZmZlY3RpdmVFbGVjdHJpY2l0eUNvc3Q6IGdyb3VuZFJlc3VsdC5lZmZlY3RpdmVFbGVjdHJpY2l0eUNvc3QsXG4gICAgICBjb25zdHJhaW50UmVsaWVmOiBncm91bmRSZXN1bHQuY29uc3RyYWludFJlbGllZlxuICAgIH0sXG4gICAgb3JiaXQ6IHtcbiAgICAgIGxjb2VQZXJNd2g6IChoeWJyaWRSZXN1bHQucG93ZXJTeXN0ZW0udG90YWxDb3N0VXNkKSAvIChzYXRlbGxpdGVQb3dlcktXICogUEhZU0lDU19DT05TVEFOVFMuSE9VUlNfUEVSX1lFQVIgKiBsaWZldGltZVllYXJzICogaHlicmlkUmVzdWx0LmNhcGFjaXR5RmFjdG9yIC8gMTAwMCksXG4gICAgICBwdWU6IHB1ZU9yYml0YWwsXG4gICAgICBjYXBhY2l0eUZhY3RvcjogaHlicmlkUmVzdWx0LmNhcGFjaXR5RmFjdG9yLFxuICAgICAgY2FwYWNpdHlGYWN0b3JQcm92ZW5hbmNlOiBoeWJyaWRSZXN1bHQuY29tcHV0ZVBheWxvYWQ/LmNhcGFjaXR5RmFjdG9yUHJvdmVuYW5jZSwgLy8gRGVidWc6IENGIGJyZWFrZG93blxuICAgICAgZ2Zsb3BzUGVyV2F0dDogb3JiaXRFZmZlY3RpdmVHZmxvcHNQZXJXLCAvLyBEZWxpdmVyZWQgR0ZMT1BTL1cgKHN5c3RlbUVmZmVjdGl2ZSDDlyB0aGVybWFsQ2FwIMOXIHJhZGlhdGlvbkRlcmF0ZSDDlyBhdmFpbGFiaWxpdHkpXG4gICAgICBjb21wdXRlRGVmaW5pdGlvbjoge1xuICAgICAgICBjaGlwTmFtZTogJ0gxMDAtZXF1aXZhbGVudCAocmFkLXRvbGVyYW50KScsXG4gICAgICAgIHByZWNpc2lvbjogJ0ZQMTYnLFxuICAgICAgICBwZWFrR2Zsb3BzUGVyV2F0dDogdmFsaWRhdGVHZmxvcHNQZXJXYXR0KFxuICAgICAgICAgIG9yYml0UGVha0dmbG9wc1BlcldhdHQsXG4gICAgICAgICAgJ29yYml0LmNvbXB1dGVEZWZpbml0aW9uLnBlYWtHZmxvcHNQZXJXYXR0J1xuICAgICAgICApLFxuICAgICAgICB1dGlsaXphdGlvbkZhY3Rvcjogb3JiaXRhbEVmZmljaWVuY3lSZXN1bHQuZGVidWcudXRpbGl6YXRpb25GYWN0b3IsXG4gICAgICAgIGVmZmVjdGl2ZUdmbG9wc1BlcldhdHQ6IG9yYml0U3lzdGVtRWZmZWN0aXZlR2Zsb3BzUGVyV2F0dCwgLy8gU3lzdGVtLWVmZmVjdGl2ZSA9IHBlYWsgKiB1dGlsaXphdGlvbiAvIHN5c3RlbU92ZXJoZWFkRmFjdG9yIChTWVNURU0tTEVWRUwgRUZGRUNUSVZFKVxuICAgICAgICAvLyBkZWxpdmVyZWRHZmxvcHNQZXJXYXR0IGlzIHN0b3JlZCBpbiBvcmJpdC5jb21wdXRlRWZmaWNpZW5jeS5nZmxvcHNQZXJXYXR0LCBub3QgaGVyZVxuICAgICAgICBub3RlczogJ0NvbW1lcmNpYWwgcmFkLXRvbGVyYW50IHZhcmlhbnQuIHBlYWtHZmxvcHNQZXJXYXR0ID0gY2hpcCBwZWFrLiBlZmZlY3RpdmVHZmxvcHNQZXJXYXR0ID0gcGVhayAqIHV0aWxpemF0aW9uIC8gc3lzdGVtT3ZlcmhlYWRGYWN0b3IgKHN5c3RlbS1sZXZlbCBlZmZlY3RpdmUpLiBkZWxpdmVyZWRHZmxvcHNQZXJXYXR0ID0gc3lzdGVtRWZmZWN0aXZlIMOXIHRoZXJtYWxDYXBGYWN0b3Igw5cgcmFkaWF0aW9uRGVyYXRlIMOXIGF2YWlsYWJpbGl0eScsXG4gICAgICB9LFxuICAgICAgY29tcHV0ZUVmZmljaWVuY3lQcm92ZW5hbmNlOiB7XG4gICAgICAgIHBlYWtHZmxvcHNQZXJXYXR0OiBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5kZWJ1Zy5jaGlwUGVha0dmbG9wc1BlclcsXG4gICAgICAgIHV0aWxpemF0aW9uRmFjdG9yOiBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5kZWJ1Zy51dGlsaXphdGlvbkZhY3RvcixcbiAgICAgICAgc3lzdGVtT3ZlcmhlYWRGYWN0b3I6IG9yYml0YWxFZmZpY2llbmN5UmVzdWx0LmRlYnVnLnN5c3RlbU92ZXJoZWFkRmFjdG9yLFxuICAgICAgICBlZmZlY3RpdmVHZmxvcHNQZXJXYXR0OiBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5kZWJ1Zy5lZmZlY3RpdmVHZmxvcHNQZXJXLFxuICAgICAgfSwgLy8gRGVidWc6IEdGTE9QUy9XIGJyZWFrZG93blxuICAgICAgbGF1bmNoQ29zdFBlcktnOiBsYXVuY2hDb3N0UGVyS2csXG4gICAgICBzcGVjaWZpY1Bvd2VyV1BlcktnOiBoeWJyaWRSZXN1bHQuc3BlY2lmaWNQb3dlcldQZXJLZywgLy8gRGVwcmVjYXRlZDogdXNlIHNwZWNpZmljUG93ZXJfc3Vic3lzdGVtX1dQZXJLZ1xuICAgICAgc3BlY2lmaWNQb3dlcl9zdWJzeXN0ZW1fV1BlcktnOiBoeWJyaWRSZXN1bHQuc3BlY2lmaWNQb3dlcldQZXJLZywgLy8gU3Vic3lzdGVtLWxldmVsIChzb2xhciBhcnJheSBvbmx5KVxuICAgICAgc3BlY2lmaWNQb3dlcl9lZmZlY3RpdmVfV1BlcktnOiBoeWJyaWRSZXN1bHQuc3BlY2lmaWNQb3dlck11bHRpcGxpZXJzPy5lZmZlY3RpdmUgPz8gc2NhbGluZ1Jlc3VsdC5lZmZlY3RpdmVTcGVjaWZpY1Bvd2VyLCAvLyBFZmZlY3RpdmUgc3BhY2VjcmFmdC1sZXZlbCAoZnJvbSBtdWx0aXBsaWVycyBjYWxjdWxhdGlvbilcbiAgICAgIC8vIFVzZSBzcGVjaWZpY1Bvd2VyTXVsdGlwbGllcnMgZnJvbSBoeWJyaWRSZXN1bHQgKGNhbGN1bGF0ZWQgaW4gb3JiaXRhbFBoeXNpY3MudHMgd2l0aCBjb3JyZWN0IG1hc3MgZnJhY3Rpb24gYWNjb3VudGluZylcbiAgICAgIHNwZWNpZmljUG93ZXJNdWx0aXBsaWVyczogaHlicmlkUmVzdWx0LnNwZWNpZmljUG93ZXJNdWx0aXBsaWVycyxcbiAgICAgIGVuZXJneUNvc3RQZXJQZmxvcFllYXI6IG9yYml0YWxCcmVha2Rvd24ucG93ZXIsXG4gICAgICBoYXJkd2FyZUNvc3RQZXJQZmxvcFllYXI6IG9yYml0YWxCcmVha2Rvd24uY29tcHV0ZSxcbiAgICAgIGxhdW5jaENvc3RQZXJQZmxvcFllYXI6IG9yYml0YWxCcmVha2Rvd24ubGF1bmNoLFxuICAgICAgcmFkaWF0aW9uTXVsdGlwbGllcjogMS4wLFxuICAgICAgdGhlcm1hbENhcEZhY3RvcjogaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0udGhlcm1hbENhcEZhY3RvcixcbiAgICAgIGNvbmdlc3Rpb25Db3N0UGVyUGZsb3BZZWFyOiBvcmJpdGFsQnJlYWtkb3duLmNvbmdlc3Rpb24sXG4gICAgICB0b3RhbENvc3RQZXJQZmxvcFllYXI6IHJlYWxpc3RpY0Nvc3RQZXJQZmxvcCwgXG4gICAgICB0aGVybWFsQ2FwcGVkOiBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS50aGVybWFsQ2FwcGVkLFxuICAgICAgY29tcHV0ZVBvd2VyS3c6IHRhcmdldENvbXB1dGVLdywgLy8gVG90YWwgY29uc3RlbGxhdGlvbiBjb21wdXRlIHBvd2VyXG4gICAgICBtYXhSZWplY3RhYmxlS3c6IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLm1heFJlamVjdGFibGVLdyB8fCBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS53YXN0ZUhlYXRLdyAqIDEuMjUsXG4gICAgICBjb2xsaXNpb25SaXNrOiBjb25nZXN0aW9uLmNvbGxpc2lvblJpc2ssXG4gICAgICBib2R5TW91bnRlZEFyZWFNMjogMCxcbiAgICAgIGRlcGxveWFibGVBcmVhTTI6IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnBoeXNpY2FsQXJlYU0yLFxuICAgICAgdG90YWxSYWRpYXRvckFyZWFNMjogaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0ucGh5c2ljYWxBcmVhTTIsXG4gICAgICByYWRpYXRvckNvc3RQZXJQZmxvcFllYXI6IChoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS50b3RhbENvc3RVc2QgKiBjb25zdGVsbGF0aW9uQ29zdE11bHRpcGxpZXIpIC8gdG90YWxFZmZlY3RpdmVQZmxvcHMgLyBsaWZldGltZVllYXJzLFxuICAgICAgcmFkaWF0b3JNYXNzS2c6IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnRvdGFsTWFzc0tnLFxuICAgICAgb3B0aW1pc3RpY0Nvc3RQZXJQZmxvcDogb3JiaXRhbEJyZWFrZG93bi5wb3dlciArIG9yYml0YWxCcmVha2Rvd24uY29tcHV0ZSArIG9yYml0YWxCcmVha2Rvd24uYnVzLFxuICAgICAgcmFkaWF0aW9uU2hpZWxkaW5nQ29zdDogb3JiaXRhbEJyZWFrZG93bi5yYWRpYXRpb24sXG4gICAgICB0aGVybWFsU3lzdGVtQ29zdDogb3JiaXRhbEJyZWFrZG93bi50aGVybWFsLFxuICAgICAgcmVwbGFjZW1lbnRSYXRlQ29zdDogb3JiaXRhbEJyZWFrZG93bi5vcHMsXG4gICAgICBlY2NPdmVyaGVhZENvc3Q6IDAsXG4gICAgICByZWR1bmRhbmN5Q29zdDogMCxcbiAgICAgIHJlYWxpc3RpY0Nvc3RQZXJQZmxvcCxcbiAgICAgIGh5YnJpZEJyZWFrZG93bjogb3JiaXRhbEJyZWFrZG93bixcbiAgICAgIGdwdUhvdXJQcmljaW5nOiB7XG4gICAgICAgIGJhc2ljOiBvcmJpdGFsR3B1SG91cihTTEFfVElFUlMuYmFzaWMpLFxuICAgICAgICBzdGFuZGFyZDogb3JiaXRhbEdwdUhvdXIoU0xBX1RJRVJTLnN0YW5kYXJkKSxcbiAgICAgICAgcHJlbWl1bTogb3JiaXRhbEdwdUhvdXIoU0xBX1RJRVJTLnByZW1pdW0pLFxuICAgICAgfSxcbiAgICAgIHRva2VuUHJpY2luZzogb3JiaXRhbFRva2VucyxcbiAgICAgIHJhZGlhdGlvbkRlZ3JhZGF0aW9uOiB7XG4gICAgICAgIGFubnVhbEZhaWx1cmVSYXRlOiB1c2VSYWRIYXJkQ2hpcHMgPyAwLjA5IDogMC4xNSxcbiAgICAgICAgZWZmZWN0aXZlQ29tcHV0ZVBlcmNlbnQ6IGh5YnJpZFJlc3VsdC5kZWdyYWRhdGlvbkZhY3RvcixcbiAgICAgICAgZWNjT3ZlcmhlYWRQY3Q6IDAuMDUsXG4gICAgICAgIGFwcGxpZWQ6IHRydWVcbiAgICAgIH0sXG4gICAgICBwb3dlclN5c3RlbVR5cGU6IGh5YnJpZFJlc3VsdC5wb3dlclN5c3RlbVR5cGUsXG4gICAgICBzY2FsaW5nUGVuYWx0eTogc2NhbGluZ1Jlc3VsdC5zY2FsaW5nUGVuYWx0eSxcbiAgICAgIC8vIFJFTU9WRUQ6IGVmZmVjdGl2ZVNwZWNpZmljUG93ZXIgKGR1cGxpY2F0ZSBvZiBzcGVjaWZpY1Bvd2VyX2VmZmVjdGl2ZV9XUGVyS2cpXG4gICAgICAvLyBVc2Ugc3BlY2lmaWNQb3dlcl9lZmZlY3RpdmVfV1BlcktnIGluc3RlYWQgKGNhbm9uaWNhbCBmaWVsZClcbiAgICAgIGZ1c2lvbkRldGFpbHM6IGh5YnJpZFJlc3VsdC5mdXNpb25EZXRhaWxzLFxuICAgICAgXG4gICAgICAvLyBDb25zdGVsbGF0aW9uIHNpemluZ1xuICAgICAgY29uc3RlbGxhdGlvbjoge1xuICAgICAgICBkZXNpZ246IHtcbiAgICAgICAgICBudW1TYXRlbGxpdGVzOiBjb25zdGVsbGF0aW9uLm51bVNhdGVsbGl0ZXMsXG4gICAgICAgICAgY29tcHV0ZVBlclNhdEt3OiBjb25zdGVsbGF0aW9uLmNvbXB1dGVQZXJTYXRLdyxcbiAgICAgICAgICBtYXNzUGVyU2F0S2c6IG1hc3NQZXJTYXRLZyxcbiAgICAgICAgICByYWRpYXRvckFyZWFQZXJTYXRNMjogY29uc3RlbGxhdGlvbi5yYWRpYXRvckFyZWFQZXJTYXRNMixcbiAgICAgICAgfSxcbiAgICAgICAgbGF1bmNoOiB7XG4gICAgICAgICAgc2F0c1BlckxhdW5jaDogY29uc3RlbGxhdGlvbi5zYXRzUGVyTGF1bmNoLFxuICAgICAgICAgIGxhdW5jaGVzUmVxdWlyZWQ6IGNvbnN0ZWxsYXRpb24ubGF1bmNoZXNSZXF1aXJlZCxcbiAgICAgICAgICB0b3RhbE1hc3NLZzogZWZmZWN0aXZlVG90YWxNYXNzS2csXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxpbmc6IHtcbiAgICAgICAgICBjb25zdGVsbGF0aW9uT3ZlcmhlYWQ6IGNvbnN0ZWxsYXRpb24uY29uc3RlbGxhdGlvbk92ZXJoZWFkLFxuICAgICAgICAgIHNjYWxpbmdFZmZpY2llbmN5OiBjb25zdGVsbGF0aW9uLnNjYWxpbmdFZmZpY2llbmN5LFxuICAgICAgICB9LFxuICAgICAgICB3YXJuaW5nczogY29uc3RlbGxhdGlvbi53YXJuaW5ncyxcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIC8vIERlYnVnIGJsb2NrcyBmb3IgYW5hbHlzaXMgLSBleHBsaWNpdGx5IHRyYWNrIGFsbCBlZmZpY2llbmN5IGxldmVsc1xuICAgICAgLy8gU2luZ2xlIHNvdXJjZSBvZiB0cnV0aDogZGVmaW5lIG9yYml0LmNvbXB1dGVFZmZpY2llbmN5TGV2ZWxzIGVhY2ggeWVhclxuICAgICAgLy8gTm90ZTogY29tcHV0ZUVmZmljaWVuY3lMZXZlbHMgaXMgc3RvcmVkIGluIG1ldGFkYXRhLCBub3QgZGlyZWN0bHkgb24gb3JiaXRcbiAgICAgIGVmZmVjdGl2ZUNvbXB1dGVNdWx0aXBsaWVyczoge1xuICAgICAgICB0aGVybWFsQ2FwRmFjdG9yOiBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS50aGVybWFsQ2FwRmFjdG9yLFxuICAgICAgICByYWRpYXRpb25EZXJhdGU6IGh5YnJpZFJlc3VsdC5kZWdyYWRhdGlvbkZhY3RvciB8fCAxLjAsXG4gICAgICAgIGF2YWlsYWJpbGl0eTogaHlicmlkUmVzdWx0LmNhcGFjaXR5RmFjdG9yIHx8IDEuMCxcbiAgICAgICAgdXRpbGl6YXRpb246IG9yYml0YWxFZmZpY2llbmN5UmVzdWx0LmRlYnVnLnV0aWxpemF0aW9uRmFjdG9yLFxuICAgICAgfSxcbiAgICAgIGNvc3RTaGFyZXM6ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gcmVhbGlzdGljQ29zdFBlclBmbG9wO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxhdW5jaDogKG9yYml0YWxCcmVha2Rvd24ubGF1bmNoIC8gdG90YWwpICogMTAwLFxuICAgICAgICAgIHBvd2VyOiAob3JiaXRhbEJyZWFrZG93bi5wb3dlciAvIHRvdGFsKSAqIDEwMCxcbiAgICAgICAgICBjb21wdXRlOiAob3JiaXRhbEJyZWFrZG93bi5jb21wdXRlIC8gdG90YWwpICogMTAwLFxuICAgICAgICAgIHRoZXJtYWw6IChvcmJpdGFsQnJlYWtkb3duLnRoZXJtYWwgLyB0b3RhbCkgKiAxMDAsXG4gICAgICAgICAgYnVzOiAob3JiaXRhbEJyZWFrZG93bi5idXMgLyB0b3RhbCkgKiAxMDAsXG4gICAgICAgICAgb3BzOiAob3JiaXRhbEJyZWFrZG93bi5vcHMgLyB0b3RhbCkgKiAxMDAsXG4gICAgICAgICAgbmV0d29ya2luZzogKG9yYml0YWxCcmVha2Rvd24ubmV0d29ya2luZyAvIHRvdGFsKSAqIDEwMCxcbiAgICAgICAgICBncm91bmRTZWdtZW50OiAob3JiaXRhbEJyZWFrZG93bi5yZWd1bGF0b3J5IC8gdG90YWwpICogMTAwLCAvLyBSZWd1bGF0b3J5IGluY2x1ZGVzIGdyb3VuZCBzZWdtZW50XG4gICAgICAgIH07XG4gICAgICB9KSgpLFxuICAgICAgbG9jYWxTZW5zaXRpdml0eTogKCgpID0+IHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGxvY2FsIHNlbnNpdGl2aXR5OiBkQ29zdC9kUGFyYW1ldGVyIChhcHByb3hpbWF0ZSBkZXJpdmF0aXZlcylcbiAgICAgICAgXG4gICAgICAgIC8vIGRDb3N0X2RMYXVuY2g6IGxhdW5jaCBjb3N0IHNjYWxlcyBsaW5lYXJseSB3aXRoIGxhdW5jaENvc3RQZXJLZ1xuICAgICAgICBjb25zdCBkQ29zdF9kTGF1bmNoID0gb3JiaXRhbEJyZWFrZG93bi5sYXVuY2ggLyBsYXVuY2hDb3N0UGVyS2c7XG4gICAgICAgIFxuICAgICAgICAvLyBkQ29zdF9kU3BlY2lmaWNQb3dlcjogcG93ZXIgY29zdCBzY2FsZXMgaW52ZXJzZWx5IHdpdGggc3BlY2lmaWMgcG93ZXIgKG5lZ2F0aXZlKVxuICAgICAgICBjb25zdCBkQ29zdF9kU3BlY2lmaWNQb3dlciA9IC0ob3JiaXRhbEJyZWFrZG93bi5wb3dlciAvIHRyYWpTcGVjaWZpY1Bvd2VyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIGRDb3N0X2RHZmxvcHNQZXJXOiBwb3dlciBjb3N0IHNjYWxlcyBpbnZlcnNlbHkgd2l0aCBHRkxPUFMvVyAobmVnYXRpdmUpXG4gICAgICAgIGNvbnN0IGRDb3N0X2RHZmxvcHNQZXJXID0gLShvcmJpdGFsQnJlYWtkb3duLnBvd2VyIC8gb3JiaXRFZmZlY3RpdmVHZmxvcHNQZXJXKTtcbiAgICAgICAgXG4gICAgICAgIC8vIGRDb3N0X2RGYWlsdXJlUmF0ZTogb3BzIGNvc3Qgc2NhbGVzIHdpdGggZmFpbHVyZSByYXRlXG4gICAgICAgIGNvbnN0IGJhc2VGYWlsdXJlUmF0ZSA9IHVzZVJhZEhhcmRDaGlwcyA/IDAuMDkgOiAwLjE1O1xuICAgICAgICBjb25zdCBkQ29zdF9kRmFpbHVyZVJhdGUgPSBvcmJpdGFsQnJlYWtkb3duLm9wcyAvIGJhc2VGYWlsdXJlUmF0ZTtcbiAgICAgICAgXG4gICAgICAgIC8vIGRDb3N0X2RQdWU6IHBvd2VyIGNvc3Qgc2NhbGVzIGxpbmVhcmx5IHdpdGggUFVFXG4gICAgICAgIGNvbnN0IGRDb3N0X2RQdWUgPSBvcmJpdGFsQnJlYWtkb3duLnBvd2VyIC8gcHVlT3JiaXRhbDtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZENvc3RfZExhdW5jaCxcbiAgICAgICAgICBkQ29zdF9kU3BlY2lmaWNQb3dlcixcbiAgICAgICAgICBkQ29zdF9kR2Zsb3BzUGVyVyxcbiAgICAgICAgICBkQ29zdF9kRmFpbHVyZVJhdGUsXG4gICAgICAgICAgZENvc3RfZFB1ZSxcbiAgICAgICAgfTtcbiAgICAgIH0pKCksXG4gICAgfSxcbiAgICBlZGdlSW5mZXJlbmNlLFxuICAgIGNyb3Nzb3ZlcjogcmVhbGlzdGljQ29zdFBlclBmbG9wIDwgZ3JvdW5kQ29tcGFyYXRvckNvc3RQZXJQZmxvcFllYXIsXG4gICAgY3Jvc3NvdmVyRGV0YWlsczoge1xuICAgICAgZ3B1SG91ckNyb3Nzb3ZlcixcbiAgICAgIHRva2VuQ3Jvc3NvdmVyOiBvcmJpdGFsVG9rZW5zLmxsYW1hNzBCLmNvc3RQZXIxa1Rva2VucyA8IGdyb3VuZFRva2Vucy5sbGFtYTcwQi5jb3N0UGVyMWtUb2tlbnMsXG4gICAgICBtYXJrZXRQb3NpdGlvbjogZ3B1SG91ckNyb3Nzb3ZlciBcbiAgICAgICAgPyBgT3JiaXRhbCAkeygoMSAtIG9yYml0YWxHcHVIb3VyKFNMQV9USUVSUy5zdGFuZGFyZCkucHJpY2VQZXJHcHVIb3VyIC8gZ3JvdW5kR3B1SG91cihTTEFfVElFUlMuc3RhbmRhcmQpLnByaWNlUGVyR3B1SG91cikgKiAxMDApLnRvRml4ZWQoMSl9JSBjaGVhcGVyYFxuICAgICAgICA6IGBHcm91bmQgJHsoKDEgLSBncm91bmRHcHVIb3VyKFNMQV9USUVSUy5zdGFuZGFyZCkucHJpY2VQZXJHcHVIb3VyIC8gb3JiaXRhbEdwdUhvdXIoU0xBX1RJRVJTLnN0YW5kYXJkKS5wcmljZVBlckdwdUhvdXIpICogMTAwKS50b0ZpeGVkKDEpfSUgY2hlYXBlcmAsXG4gICAgfSxcbiAgICBjb3N0QWNjb3VudGluZ1ZhbGlkLFxuICAgIGNvc3RBY2NvdW50aW5nRXJyb3JQY3QsXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIGdyb3VuZFVuaXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRyaWM6ICdnZmxvcHNQZXJXYXR0JyxcbiAgICAgICAgICB1bml0OiAnR0ZMT1BTL1cnLFxuICAgICAgICAgIGxldmVsOiAnc3lzdGVtJyxcbiAgICAgICAgICBub3RlczogJ0dyb3VuZCBzeXN0ZW0tbGV2ZWwgZWZmaWNpZW5jeSBpbmNsdWRpbmcgbWVtb3J5LCBuZXR3b3JrLCBwb3dlciBkZWxpdmVyeSBvdmVyaGVhZCcsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgb3JiaXRVbml0czogW1xuICAgICAgICB7XG4gICAgICAgICAgbWV0cmljOiAnZ2Zsb3BzUGVyV2F0dCcsXG4gICAgICAgICAgdW5pdDogJ0dGTE9QUy9XJyxcbiAgICAgICAgICBsZXZlbDogJ2RlbGl2ZXJlZCcsXG4gICAgICAgICAgbm90ZXM6ICdPcmJpdGFsIGRlbGl2ZXJlZCBlZmZpY2llbmN5OiBzeXN0ZW1FZmZlY3RpdmUgw5cgdGhlcm1hbENhcEZhY3RvciDDlyByYWRpYXRpb25EZXJhdGUgw5cgYXZhaWxhYmlsaXR5JyxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICB1bml0czogW1xuICAgICAgICB7XG4gICAgICAgICAgbWV0cmljOiAnZ2Zsb3BzUGVyV2F0dCcsXG4gICAgICAgICAgdW5pdDogJ0dGTE9QUy9XJyxcbiAgICAgICAgICBsZXZlbDogJ3N5c3RlbScsXG4gICAgICAgICAgbm90ZXM6ICdTeXN0ZW0tbGV2ZWwgZWZmaWNpZW5jeSBpbmNsdWRpbmcgbWVtb3J5LCBuZXR3b3JrLCBwb3dlciBkZWxpdmVyeSBvdmVyaGVhZCcsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRyaWM6ICdjb3N0UGVyUGZsb3BZZWFyJyxcbiAgICAgICAgICB1bml0OiAnVVNEL1BGTE9QLXllYXInLFxuICAgICAgICAgIGxldmVsOiAnaW5mcmFzdHJ1Y3R1cmUnLFxuICAgICAgICAgIG5vdGVzOiAnVG90YWwgY29zdCB0byBvcGVyYXRlIDEgUEZMT1Agb2Ygc3VzdGFpbmVkIGNvbXB1dGUgZm9yIG9uZSB5ZWFyJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG1ldHJpYzogJ3ByaWNlUGVyR3B1SG91cicsXG4gICAgICAgICAgdW5pdDogJ1VTRC9HUFUtaG91cicsXG4gICAgICAgICAgbGV2ZWw6ICdtYXJrZXQnLFxuICAgICAgICAgIG5vdGVzOiAnTWFya2V0IHByaWNlIHdpdGggU0xBLCBpbmNsdWRpbmcgbWFyZ2luIGFuZCByaXNrIGJ1ZmZlcicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRyaWM6ICdjb3N0UGVyMWtUb2tlbnMnLFxuICAgICAgICAgIHVuaXQ6ICdVU0QvMUsgdG9rZW5zJyxcbiAgICAgICAgICBsZXZlbDogJ2FwcGxpY2F0aW9uJyxcbiAgICAgICAgICBub3RlczogJ0luZmVyZW5jZSBjb3N0IGZvciBzcGVjaWZpZWQgbW9kZWwgc2l6ZSAoNzBCIG9yIDQwNUIpJyxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWJ1Zzoge1xuICAgICAgICBncm91bmRMaWZldGltZTogZ3JvdW5kTGlmZXRpbWUsXG4gICAgICAgIGdwdUZhaWx1cmVSYXRlQW5udWFsOiBwYXJhbXMuZ3B1RmFpbHVyZVJhdGVBbm51YWwsXG4gICAgICAgIHRvdGFsQ29zdEV4Y2x1ZGVzRGVsYXlQZW5hbHR5OiB0cnVlLCAvLyBIZWFkbGluZSBjb3N0IGV4Y2x1ZGVzIGRlbGF5IHBlbmFsdHkgKGhhbmRsZWQgdmlhIGNhcGFjaXR5IGdhdGluZylcbiAgICAgICAgdG90YWxDb3N0RWZmZWN0aXZlSW5jbHVkZXNEZWxheVBlbmFsdHk6IGdyb3VuZFJlc3VsdC50b3RhbENvc3RQZXJQZmxvcFllYXJFZmZlY3RpdmUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgZ3JvdW5kSGFzUXVldWUsXG4gICAgICAgIGdyb3VuZENvbXBhcmF0b3JDb3N0UGVyUGZsb3BZZWFyLFxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVFZmZpY2llbmN5OiB7XG4gICAgICAgIGdmbG9wc1BlcldhdHQ6IG9yYml0RWZmZWN0aXZlR2Zsb3BzUGVyVywgLy8gRGVsaXZlcmVkIGVmZmljaWVuY3kgKGFsaWFzKVxuICAgICAgICBlZmZpY2llbmN5TGV2ZWw6ICdkZWxpdmVyZWQnLCAvLyBDaGFuZ2VkIGZyb20gJ3N5c3RlbScgdG8gJ2RlbGl2ZXJlZCdcbiAgICAgICAgdmFsaWRhdGlvbjoge1xuICAgICAgICAgIC8vIENSSVRJQ0FMOiBVc2UgZGVsaXZlcmVkVmFsaWRhdGlvbiBhcyBwcmltYXJ5IC0gaXQgY29tcGFyZXMgbGlrZS1mb3ItbGlrZVxuICAgICAgICAgIC8vIE9ubHkgZmFpbCBpZiBkZWxpdmVyZWRWYWxpZGF0aW9uIGZhaWxzIChyYXRpbyBtaXNtYXRjaCkgT1IgZWZmaWNpZW5jeVZhbGlkYXRpb24gZmFpbHMgKHJhbmdlIGNoZWNrKVxuICAgICAgICAgIC8vIGNvbnNpc3RlbmN5Q2hlY2sgaXMgZm9yIHBvd2VyL2NvbXB1dGUgY29uc2lzdGVuY3ksIG5vdCBlZmZpY2llbmN5IHZhbGlkYXRpb25cbiAgICAgICAgICB2YWxpZDogZWZmaWNpZW5jeVZhbGlkYXRpb24udmFsaWQgJiYgZGVsaXZlcmVkVmFsaWRhdGlvbi52YWxpZCxcbiAgICAgICAgICB3YXJuaW5nOiBlZmZpY2llbmN5VmFsaWRhdGlvbi53YXJuaW5nIHx8IGRlbGl2ZXJlZFZhbGlkYXRpb24ud2FybmluZyB8fCB1bmRlZmluZWQsIC8vIE9ubHkgZWZmaWNpZW5jeSBvciBkZWxpdmVyZWQgbWlzbWF0Y2ggd2FybmluZ3NcbiAgICAgICAgICBleHBlY3RlZERlbGl2ZXJlZDogZGVsaXZlcmVkVmFsaWRhdGlvbi5leHBlY3RlZERlbGl2ZXJlZCxcbiAgICAgICAgICBkZWxpdmVyZWQ6IGRlbGl2ZXJlZFZhbGlkYXRpb24uZGVsaXZlcmVkLFxuICAgICAgICAgIHJhdGlvOiBkZWxpdmVyZWRWYWxpZGF0aW9uLnJhdGlvLFxuICAgICAgICAgIGZhY3RvcnNVc2VkOiBkZWxpdmVyZWRWYWxpZGF0aW9uLmZhY3RvcnNVc2VkLFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQ2hhcnQgaW5wdXRzIGZvciBwb3dlciBidWlsZG91dCBjb25zdHJhaW50cyAocmVwbGFjZXMgZW5lcmd5Q29zdENvbXBhcmlzb24pXG4gICAgICBjaGFydElucHV0czoge1xuICAgICAgICBwb3dlckJ1aWxkb3V0OiB7XG4gICAgICAgICAgZGVtYW5kR3c6ICgnYnVpbGRvdXREZWJ1ZycgaW4gZ3JvdW5kUmVzdWx0ID8gZ3JvdW5kUmVzdWx0LmJ1aWxkb3V0RGVidWc/LmRlbWFuZEdXIDogdW5kZWZpbmVkKSA/PyBcbiAgICAgICAgICAgICAgICAgICAgKCdzdXBwbHlNZXRyaWNzJyBpbiBncm91bmRSZXN1bHQgPyBncm91bmRSZXN1bHQuc3VwcGx5TWV0cmljcz8uZGVtYW5kR3cgOiB1bmRlZmluZWQpID8/IDAsXG4gICAgICAgICAgc3VwcGx5R3c6ICgnc3VwcGx5TWV0cmljcycgaW4gZ3JvdW5kUmVzdWx0ID8gZ3JvdW5kUmVzdWx0LnN1cHBseU1ldHJpY3M/LmNhcGFjaXR5R3cgOiB1bmRlZmluZWQpID8/IDAsXG4gICAgICAgICAgbWF4QnVpbGRSYXRlR3dZZWFyOiAoJ3N1cHBseU1ldHJpY3MnIGluIGdyb3VuZFJlc3VsdCA/IGdyb3VuZFJlc3VsdC5zdXBwbHlNZXRyaWNzPy5tYXhCdWlsZFJhdGVHd1llYXIgOiB1bmRlZmluZWQpID8/IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCdidWlsZG91dERlYnVnJyBpbiBncm91bmRSZXN1bHQgPyBncm91bmRSZXN1bHQuYnVpbGRvdXREZWJ1Zz8uYnVpbGRSYXRlR1d5ciA6IHVuZGVmaW5lZCkgPz8gMCxcbiAgICAgICAgICBwaXBlbGluZUd3OiAoJ3N1cHBseU1ldHJpY3MnIGluIGdyb3VuZFJlc3VsdCA/IGdyb3VuZFJlc3VsdC5zdXBwbHlNZXRyaWNzPy5waXBlbGluZUd3IDogdW5kZWZpbmVkKSA/PyAwLFxuICAgICAgICAgIGJhY2tsb2dHdzogKCdiYWNrbG9nR3cnIGluIGdyb3VuZFJlc3VsdCA/IGdyb3VuZFJlc3VsdC5iYWNrbG9nR3cgOiB1bmRlZmluZWQpID8/IFxuICAgICAgICAgICAgICAgICAgICAgKCdidWlsZG91dERlYnVnJyBpbiBncm91bmRSZXN1bHQgPyBncm91bmRSZXN1bHQuYnVpbGRvdXREZWJ1Zz8uYmFja2xvZ0dXIDogdW5kZWZpbmVkKSA/PyAwLFxuICAgICAgICAgIGF2Z1dhaXRZZWFyczogKCdhdmdXYWl0WWVhcnMnIGluIGdyb3VuZFJlc3VsdCA/IGdyb3VuZFJlc3VsdC5hdmdXYWl0WWVhcnMgOiB1bmRlZmluZWQpID8/IFxuICAgICAgICAgICAgICAgICAgICAgICAgKCdidWlsZG91dERlYnVnJyBpbiBncm91bmRSZXN1bHQgPyBncm91bmRSZXN1bHQuYnVpbGRvdXREZWJ1Zz8udGltZVRvUG93ZXJZZWFycyA6IHVuZGVmaW5lZCkgPz8gMCxcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG4iXSwibmFtZXMiOlsiY2FsY3VsYXRlQ29uZ2VzdGlvbiIsImNvbXB1dGVFZGdlSW5mZXJlbmNlQ29zdHMiLCJjb21wdXRlU2F0ZWxsaXRlSHlicmlkQ29zdCIsIkRFRkFVTFRfQ09ORklHIiwiUEhZU0lDU19DT05TVEFOVFMiLCJERUZBVUxUX0ZVU0lPTl9QQVJBTVMiLCJERUZBVUxUX1BPV0VSX1NDQUxJTkciLCJjYWxjdWxhdGVTY2FsZWRNYXNzIiwiY2FsY3VsYXRlUmVnaW9uYWxHcm91bmRDb3N0IiwiZ2V0R2xvYmFsRGVtYW5kUGZsb3BzIiwiZ2VuZXJhdGVHcm91bmRTdXBwbHlUcmFqZWN0b3J5IiwiZ2V0R2xvYmFsRGVtYW5kR3ciLCJjYWxjdWxhdGVHcm91bmRDb25zdHJhaW50UGVuYWx0aWVzIiwiY2FsY3VsYXRlU2NhcmNpdHlSZW50IiwiY2FsY3VsYXRlQnVpbGRvdXRDb25zdHJhaW50cyIsInN0ZXBNb2JpbGl6YXRpb25TdGF0ZSIsIkRFRkFVTFRfTU9CSUxJWkFUSU9OX1BBUkFNUyIsIkNvbXB1dGVFZmZpY2llbmN5IiwiZ2V0RGVmYXVsdENvbXB1dGVFZmZpY2llbmN5IiwiYXNzZXJ0Q29zdEFjY291bnRpbmciLCJ2YWxpZGF0ZUdmbG9wc1BlcldhdHQiLCJkZXNpZ25Db25zdGVsbGF0aW9uIiwiU0FURUxMSVRFX0NPTlNUUkFJTlRTIiwiQ09OU1RBTlRTIiwiSE9VUlNfUEVSX1lFQVIiLCJHUk9VTkRfSEFSRFdBUkVfQ09TVF9QRkxPUF8yMDI1IiwiR1JPVU5EX0hBUkRXQVJFX0xJRkVUSU1FIiwiTUlOX0RFTElWRVJFRF9HRkxPUFNfUEVSX1ciLCJERUZBVUxUX1NNUl9QQVJBTVMiLCJlbmFibGVkIiwic21yRGVwbG95bWVudFN0YXJ0WWVhciIsInNtclJhbXBVcFllYXJzIiwiZWxlY3RyaWNpdHlDb3N0V2l0aFNNUiIsImdyaWRDb25zdHJhaW50UmVsaWVmIiwiY29vbGluZ0NvbnN0cmFpbnRSZWxpZWYiLCJ3YXRlckNvbnN0cmFpbnRSZWxpZWYiLCJsYW5kQ29uc3RyYWludFJlbGllZiIsInNtckNhcGV4UHJlbWl1bSIsIkdST1VORF9TQ0VOQVJJT1MiLCJ1bmNvbnN0cmFpbmVkIiwibmFtZSIsImRlc2NyaXB0aW9uIiwiY29uc3RyYWludENhcCIsImdyaWRHcm93dGhSYXRlIiwiY29vbGluZ0dyb3d0aFJhdGUiLCJ3YXRlckdyb3d0aFJhdGUiLCJsYW5kR3Jvd3RoUmF0ZSIsIm1vZGVyYXRlIiwiY29uc3RyYWluZWQiLCJzZXZlcmUiLCJjYWxjdWxhdGVHcm91bmRDb25zdHJhaW50IiwieWVhciIsInNjZW5hcmlvS2V5IiwibXVsdGlwbGllciIsImJyZWFrZG93biIsImdyaWQiLCJjb29saW5nIiwid2F0ZXIiLCJsYW5kIiwic2NlbmFyaW8iLCJ5ZWFyc0Zyb21CYXNlIiwiTWF0aCIsIm1heCIsInBvdyIsIm1pbiIsInZhbGlkYXRlQ29tcHV0ZUVmZmljaWVuY3kiLCJnZmxvcHNQZXJXYXR0IiwibGV2ZWwiLCJyYW5nZXMiLCJjaGlwIiwic3lzdGVtIiwiZGF0YWNlbnRlciIsInJhbmdlIiwidmFsaWQiLCJ3YXJuaW5nIiwidG9GaXhlZCIsIlNMQV9USUVSUyIsImF2YWlsYWJpbGl0eVRhcmdldCIsIm1heExhdGVuY3lUb0dyb3VuZE1zIiwibWluQmFuZHdpZHRoR2JwcyIsIm1heFJlY292ZXJ5VGltZU1pbnV0ZXMiLCJjcmVkaXRQZXJWaW9sYXRpb25QY3QiLCJhcHBseVN0YXRpY0ZyZWV6ZSIsInBhcmFtcyIsImlzU3RhdGljTW9kZSIsImxhdW5jaENvc3RLZyIsInNwZWNpZmljUG93ZXJXS2ciLCJncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjUiLCJvcmJpdEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNSIsImdyb3VuZENvbnN0cmFpbnRzRW5hYmxlZCIsInBvd2VyR3JpZE11bHRpcGxpZXIiLCJjb29saW5nTXVsdGlwbGllciIsIndhdGVyU2NhcmNpdHlFbmFibGVkIiwibGFuZFNjYXJjaXR5RW5hYmxlZCIsImRlcGxveWFibGVBcmVhMjAyNU0yIiwiZGVwbG95YWJsZUFyZWEyMDQwTTIiLCJwcmV2TGF1bmNoQ29zdENhY2hlIiwiTWFwIiwiZ2V0TGF1bmNoQ29zdFBlcktnIiwiYmFzZTIwMjUiLCJzZXQiLCJDT01NRVJDSUFMX01BUktVUCIsIklOU1VSQU5DRV9QQ1QiLCJJTlRFR1JBVElPTl9DT1NUX1BFUl9MQVVOQ0giLCJBU1NVTUVEX1BBWUxPQURfS0ciLCJpbnRlcm5hbEJhc2UyMDI1Iiwibm9ybWFsaXplZEJhc2UiLCJpbnRlcm5hbFdheXBvaW50cyIsImludGVybmFsQ29zdFBlcktnIiwiaSIsImxlbmd0aCIsInkxIiwiYzEiLCJ5MiIsImMyIiwidCIsIndpdGhNYXJrdXAiLCJ3aXRoSW5zdXJhbmNlIiwiaW50ZWdyYXRpb25QZXJLZyIsImNvbW1lcmNpYWxDb3N0UGVyS2ciLCJyZXN1bHQiLCJwcmV2WWVhciIsInByZXZDb3N0IiwiZ2V0IiwidW5kZWZpbmVkIiwiY2FsY3VsYXRlVG9rZW5QcmljaW5nIiwiY29zdFBlclBmbG9wWWVhciIsIm1vZGVsQ29uZmlnIiwiYmFzZUZMT1BTIiwicHJlY2lzaW9uTXVsdGlwbGllciIsInByZWNpc2lvbiIsImZsb3BzUGVyVG9rZW4iLCJzZWNvbmRzUGVyWWVhciIsImZsb3BzUGVyUGZsb3BZZWFyIiwidG9rZW5zUGVyUGZsb3BZZWFyIiwiY29zdFBlclRva2VuIiwibW9kZWxQYXJhbXMiLCJjb3N0UGVyMWtUb2tlbnMiLCJjb3N0UGVyMW1Ub2tlbnMiLCJjYWxjdWxhdGVHcHVIb3VyUHJpY2luZyIsImNvc3RCcmVha2Rvd24iLCJob3Vyc1BlclllYXIiLCJjb3N0UGVyR3B1WWVhciIsInBmbG9wc1BlckdwdSIsImVmZmVjdGl2ZUhvdXJzIiwidXRpbGl6YXRpb25UYXJnZXQiLCJiYXNlUGVySG91ciIsInByb2Nlc3MiLCJjb25zb2xlIiwiZXJyb3IiLCJjbGFtcGVkQ29zdFBlclBmbG9wWWVhciIsImNsYW1wZWRDb3N0UGVyR3B1WWVhciIsImNsYW1wZWRCYXNlUGVySG91ciIsIkVycm9yIiwicG93ZXJQZXJIb3VyIiwiY29vbGluZ1BlckhvdXIiLCJpbnRlcmNvbm5lY3RQZXJIb3VyIiwib3BzUGVySG91ciIsImNvbXB1dGVQZXJIb3VyIiwidG90YWxCYXNlIiwicG93ZXIiLCJ0aGVybWFsIiwiaW50ZXJjb25uZWN0Iiwib3BzIiwiY29tcHV0ZSIsInNjYWxlIiwibmluZXMiLCJsb2cxMCIsInNsYSIsInNwYXJlc1JhdGlvIiwic3BhcmVzUGVySG91ciIsInZpb2xhdGlvblByb2IiLCJleHBlY3RlZENyZWRpdFBlckhvdXIiLCJzbGFSaXNrQnVmZmVyIiwidG90YWxDb3N0UGVySG91ciIsIm1hcmdpbiIsIm9wZXJhdG9yTWFyZ2luUGN0IiwicHJpY2VQZXJHcHVIb3VyIiwiTUFYX1JFQVNPTkFCTEVfR1BVX0hPVVJfUFJJQ0UiLCJNSU5fUkVBU09OQUJMRV9HUFVfSE9VUl9QUklDRSIsImdwdVR5cGUiLCJsb2NhdGlvbiIsImhhcmR3YXJlQW1vcnRpemF0aW9uIiwib3BlcmF0aW9ucyIsInNwYXJlcyIsImVmZmVjdGl2ZVV0aWxpemF0aW9uIiwiTU9ERUxfVU5JVFMiLCJwZmxvcERlZmluaXRpb24iLCJzdXN0YWluZWRWc1BlYWsiLCJnZmxvcHNQZXJXYXR0TGV2ZWwiLCJpbmNsdWRlc05ldHdvcmtpbmdPdmVyaGVhZCIsImFzc2VydENvbXB1dGVQb3dlckNvbnNpc3RlbmN5IiwiY29tcHV0ZVBvd2VyS3ciLCJlZmZlY3RpdmVQZmxvcHMiLCJ1bml0cyIsImV4cGVjdGVkS3ciLCJkaXNjcmVwYW5jeSIsInJhdGlvIiwiQkFTRV9TSVRFXzIwMjUiLCJjYWxjdWxhdGVHcm91bmRUb3RhbCIsImVuZXJneUNvc3RCYXNlIiwiaGFyZHdhcmVDb3N0QmFzZSIsImVmZmVjdGl2ZVNjZW5hcmlvIiwibGF0ZW5jeVBlbmFsdHkiLCJzbXJQYXJhbXMiLCJmaXJzdENhcFllYXIiLCJhY3R1YWxFbmVyZ3lDb3N0UGVyUGZsb3BZZWFyIiwiYWN0dWFsRWxlY3RyaWNpdHlQcmljZVBlck13aCIsInNpdGVDb3N0QmFzZSIsInNtckVuYWJsZWQiLCJzbXJSYW1wRmFjdG9yIiwiY29uc3RyYWludFJlbGllZiIsInllYXJzQWN0aXZlIiwiZW5lcmd5Q29zdCIsImVmZmVjdGl2ZUVsZWN0cmljaXR5UHJpY2UiLCJ0b3RhbCIsInNpdGVDb3N0IiwiaGFyZHdhcmVDb3N0IiwiY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0iLCJ0aW1lVG9FbmVyZ2l6ZVBlbmFsdHkiLCJ0b3RhbENvc3RQZXJQZmxvcFllYXIiLCJjb25zdHJhaW50TXVsdGlwbGllciIsImVuZXJneU11bHRpcGxpZXIiLCJzaXRlTXVsdGlwbGllciIsImNhcGFjaXR5RGVsaXZlcnlNdWx0aXBsaWVyIiwiZWZmZWN0aXZlRWxlY3RyaWNpdHlDb3N0Iiwic2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIiLCJjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhciIsInRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciIsInNpdGVDb3N0UGVyUGZsb3BZZWFyX2Jhc2UiLCJzaXRlQ29zdFBlclBmbG9wWWVhcl9lZmZlY3RpdmUiLCJzaXRlQ29zdENoZWNrIiwiYWJzIiwiaGFyZHdhcmUiLCJ0b3RhbEVmZmVjdGl2ZSIsInRvdGFsQ29zdFBlclBmbG9wWWVhckVmZmVjdGl2ZSIsImNvbnN0cmFpbnRzIiwibWV0aG9kIiwiZGVsYXlQZW5hbHR5IiwiYXBwbGllZE11bHRpcGxpZXJzIiwiY29uc3RyYWludE11bHRpcGxpZXJVc2VkIiwiZW5lcmd5TXVsdGlwbGllclVzZWQiLCJzaXRlTXVsdGlwbGllclVzZWQiLCJkZWJ1ZyIsImRvdWJsZUNvdW50Q2hlY2siLCJtb2RlIiwibXVsdGlwbGllckFwcGxpZWQiLCJhZGRlcnNBcHBsaWVkIiwiaW52YXJpYW50T2siLCJub3RlcyIsImNvbXB1dGVQaHlzaWNzQ29zdCIsInJhd1BhcmFtcyIsImh5YnJpZFJlc3VsdCIsImdyb3VuZFJlc3VsdCIsImJhc2VMYXVuY2hDb3N0IiwidHJhalNwZWNpZmljUG93ZXIiLCJyYXdHcm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjUiLCJyYXdPcmJpdEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNSIsInB1ZUdyb3VuZCIsInB1ZU9yYml0YWwiLCJjYXBhY2l0eUZhY3Rvckdyb3VuZCIsInRhcmdldEdXIiwic2F0ZWxsaXRlUG93ZXJLVyIsInNwYWNlVHJhZmZpY0VuYWJsZWQiLCJvcmJpdGFsQWx0aXR1ZGUiLCJ1c2VSYWRIYXJkQ2hpcHMiLCJzdW5GcmFjdGlvbiIsImdyb3VuZFNjZW5hcmlvIiwic21yTWl0aWdhdGlvbkVuYWJsZWQiLCJ3b3JrbG9hZFR5cGUiLCJlbG9uU2NlbmFyaW9FbmFibGVkIiwiZ2xvYmFsTGF0ZW5jeVJlcXVpcmVtZW50RW5hYmxlZCIsInNwYWNlTWFudWZhY3R1cmluZ0VuYWJsZWQiLCJhaVdpbnRlckVuYWJsZWQiLCJhY3R1YWxHcm91bmRJbnB1dCIsImdmbG9wc1BlcldhdHRHcm91bmQyMDI1IiwiZmxvcHNQZXJXYXR0R3JvdW5kIiwiYWN0dWFsT3JiaXRJbnB1dCIsImdmbG9wc1BlcldhdHRPcmJpdGFsMjAyNSIsImZsb3BzUGVyV2F0dE9yYml0YWwiLCJncm91bmRFZmZpY2llbmN5UmVzdWx0Iiwib3JiaXRhbEVmZmljaWVuY3lSZXN1bHQiLCJpc0Zpbml0ZSIsInN5c3RlbU92ZXJoZWFkRmFjdG9yIiwidXRpbGl6YXRpb25GYWN0b3IiLCJjaGlwUGVha0dmbG9wc1BlclciLCJlZmZlY3RpdmVHZmxvcHNQZXJXIiwiSlNPTiIsInN0cmluZ2lmeSIsImdyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlclciLCJvcmJpdFBlYWtHZmxvcHNQZXJXYXR0Iiwib3JiaXRTeXN0ZW1FZmZlY3RpdmVHZmxvcHNQZXJXYXR0IiwiZWZmZWN0aXZlR3JvdW5kU2NlbmFyaW8iLCJsYXVuY2hEaXNjb3VudCIsInBvd2VyRGlzY291bnQiLCJuZXR3b3JraW5nRGlzY291bnQiLCJvcGVyYXRvck1hcmdpbiIsImdyb3VuZExhdGVuY3lQZW5hbHR5IiwibWFzc011bHRpcGxpZXIiLCJ5ZWFyc1NpbmNlU3RhcnQiLCJyYW1wIiwiQkFTRV9FTkVSR1lfMjAyNSIsIkVORVJHWV9DT1NUX0JBU0VfMjAyNSIsIkJBU0VfRUxFQ1RSSUNJVFlfUFJJQ0VfMjAyNSIsImdyb3VuZEVsZWN0cmljaXR5UHJpY2VQZXJNd2giLCJlZmZlY3RpdmVQdWVHcm91bmQiLCJncm91bmRFbmVyZ3lNV2hQZXJQZmxvcFllYXIiLCJncm91bmRFbmVyZ3lDb3N0UGVyUGZsb3BZZWFyIiwiY29tcHV0ZUdyb3VuZEhhcmR3YXJlQ29zdCIsInkiLCJiYXNlQ29zdCIsInllYXJJbmRleCIsImNvc3QiLCJhbm51YWxEZWNsaW5lIiwiZ3JvdW5kTGlmZXRpbWUiLCJncm91bmRIYXJkd2FyZUxpZmV0aW1lWWVhcnMiLCJncm91bmRIYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyIiwic21yVG9nZ2xlRW5hYmxlZCIsInNtclRvZ2dsZVBhcmFtcyIsImdyb3VuZFRvdGFsQ29zdCIsImdyb3VuZENvbXBhcmF0b3JDb3N0UGVyUGZsb3BZZWFyIiwiZ3JvdW5kSGFzUXVldWUiLCJlbmVyZ3lDb25zdHJhaW50TXVsdGlwbGllciIsImNvbnN0cmFpbnRCcmVha2Rvd24iLCJ1c2VSZWdpb25hbE1vZGVsIiwidXNlUmVnaW9uYWxHcm91bmRNb2RlbCIsInVzZVF1ZXVlTW9kZWwiLCJ1c2VRdWV1ZUJhc2VkQ29uc3RyYWludCIsInVzZUJ1aWxkb3V0TW9kZWwiLCJ3YXJuIiwicmVzcG9uc2l2ZURlbWFuZEdXIiwib3JiaXRhbFN1YnN0aXR1dGlvbkdXIiwiZGVtYW5kQnlZZWFyIiwib3JiaXRhbFN1YnN0aXR1dGlvbkJ5WWVhciIsInN1cHBseVRyYWplY3RvcnkiLCJjdXJyZW50U3VwcGx5U3RhdGUiLCJoYXJkY29kZWREZW1hbmQiLCJkZW1hbmRHdyIsImxvZyIsIndhY2NQYXJhbXMiLCJiYXNlV2FjYyIsIndhY2MiLCJ3YWNjQmFja2xvZ0siLCJ3YWNjQmFja2xvZ0V4cG9uZW50IiwiY3JpdGljYWxCYWNrbG9nR1ciLCJwZW5hbHRpZXMiLCJjYXBleEFubnVhbEJhc2VQZXJQZmxvcFllYXIiLCJzY2FyY2l0eVJlbnRSZXN1bHQiLCJhdmdXYWl0WWVhcnMiLCJ1dGlsaXphdGlvblBjdCIsIndhaXRUaHJlc2hvbGRZZWFycyIsInJlbnRNYXhNdWx0aXBsaWVyIiwidXRpbGl6YXRpb25UaHJlc2hvbGQiLCJzY2FyY2l0eU11bHRpcGxpZXIiLCJzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXIiLCJ1bnNlcnZlZEd3IiwiY2FwYWNpdHlHdyIsImJhY2tsb2dHdyIsImV4cGVjdGVkRWZmZWN0aXZlIiwidG90YWxDb3N0UGVyUGZsb3BZZWFyQWxsSW4iLCJzY2FyY2l0eUhpbGwiLCJhdmdXYWl0WWVhcnNSYXciLCJhdmdXYWl0WWVhcnNDbGFtcGVkIiwicmVudEZyYWMiLCJkZWxpdmVyZWRGcm9tQmFja2xvZ0d3IiwiYmFzZUNvc3RQZXJQZmxvcFllYXIiLCJzdXBwbHlNZXRyaWNzIiwicGlwZWxpbmVHdyIsIm1heEJ1aWxkUmF0ZUd3WWVhciIsImNvbnN0cmFpbnRDb21wb25lbnRzIiwicXVldWVQcmVzc3VyZSIsInV0aWxpemF0aW9uUHJlc3N1cmUiLCJzY2FyY2l0eVByZW1pdW0iLCJjYXBleEF0Umlza1Blck1XIiwiY2FycnlDb3N0UGVyTVciLCJsb3N0TWFyZ2luUGVyTVciLCJwdWVNdWx0aXBsaWVyIiwibW9iaWxpemF0aW9uUGFyYW1zIiwiZGVtYW5kQ3VydmUiLCJwcmV2TW9iaWxpemF0aW9uU3RhdGUiLCJtb2JpbGl6YXRpb25SZXN1bHQiLCJkZW1hbmROZXdHVyIsImJ1aWxkUmF0ZUdXeXIiLCJidWlsZGFibGVHVyIsImNhcGFjaXR5R1ciLCJwaXBlbGluZUdXIiwiYmFja2xvZ0dXIiwiUFJPSkVDVF9MSUZFVElNRSIsIkJVSUxET1VUX0NBUEVYX0JBU0UiLCJERUZBVUxUX1NDQVJDSVRZX0NVUlZFIiwiayIsImV4cG9uZW50IiwidGhyZXNob2xkVXRpbCIsIlBBTklDX0VYUE9ORU5UIiwiYmFja2xvZ1JhdGlvIiwid2FjY011bHRpcGxpZXIiLCJ3YWNjRWZmZWN0aXZlIiwiYnVpbGRvdXRQYXJhbXMiLCJkZW1hbmROZXdHV0J5WWVhciIsImJ1aWxkYWJsZUdXQnlZZWFyIiwiYmFzZUVuZXJneVByaWNlUGVyTXdoQnlZZWFyIiwicHVlR3JvdW5kQnlZZWFyIiwicHJvamVjdExpZmV0aW1lWWVhcnMiLCJidWlsZG91dFByb2plY3RMaWZldGltZVllYXJzIiwidmFsdWVPZlRpbWVNb2RlIiwiYnVpbGRvdXRDYXBleEJhc2VfJFBlcmtXIiwiYnVpbGRvdXRDYXBleFNjYXJjaXR5Q3VydmUiLCJwYW5pY0V4cG9uZW50IiwiYnVpbGRvdXRQYW5pY0V4cG9uZW50IiwiaGFyZHdhcmVDYXBleFBlclBmbG9wWWVhciIsImNvbXB1dGVIYXJkd2FyZUNhcGV4Iiwic2l0ZUNhcGV4IiwibWFyZ2luUGVyR3B1SG91ciIsImFubnVhbEdwdUhvdXJzRGVsaXZlcmVkIiwiaHlicmlkV2VpZ2h0cyIsImJ1aWxkb3V0SHlicmlkV2VpZ2h0cyIsIndhY2NXZWlnaHQiLCJtYXJnaW5XZWlnaHQiLCJidWlsZG91dFJlc3VsdCIsImJ1aWxkb3V0UHJlbWl1bVBlclBmbG9wWWVhciIsImRlbGF5UGVuYWx0eVBlclBmbG9wWWVhciIsInNjYXJjaXR5UmVudFdhaXRUaHJlc2hvbGRZZWFycyIsInNjYXJjaXR5UmVudE1heE11bHRpcGxpZXIiLCJoYXJkd2FyZUNvc3RXaXRoUmVwbGFjZW1lbnQiLCJyZXBsYWNlbWVudENvc3RQZXJQZmxvcFllYXIiLCJzcGFyZXNDYXJyeUNvc3RQZXJQZmxvcFllYXIiLCJncm91bmRPcHNDb3N0UGVyUGZsb3BZZWFyIiwiZ3JvdW5kVG90YWxDb3N0X2Jhc2UiLCJncm91bmRUb3RhbENvc3RfZWZmZWN0aXZlIiwiYnVpbGRvdXREZWJ1ZyIsInJlcGxhY2VtZW50Q29zdCIsInNwYXJlc0NhcnJ5Q29zdCIsIm9wc0Nvc3QiLCJ0b3RhbENvc3RQZXJQZmxvcFllYXJCYXNlIiwicHJpY2luZ0NvbXBvbmVudHMiLCJkZWxheVBlbmFsdHlXZWlnaHRlZCIsInByaWNpbmdNb2RlIiwiZGVsYXlQZW5hbHR5V2VpZ2h0Iiwid2FpdEVmZlllYXJzIiwiZGVtYW5kR1ciLCJzY2FyY2l0eUluZGV4IiwiZmFjdG9ycyIsImJ1aWxkb3V0Q2FwZXhfJFBlcmtXIiwiYW5udWFsaXplZEJ1aWxkb3V0UHJlbWl1bV8kUGVya1d5ciIsInRpbWVUb1Bvd2VyWWVhcnMiLCJ2YWx1ZU9mVGltZV8kUGVyWWVhciIsImRlbGF5UGVuYWx0eV8kUGVyWWVhciIsImRlbWFuZEdyb3d0aFJhdGUiLCJ3YWNjQmFzZSIsIndhaXRZZWFyc1VzZWQiLCJoYXNNdWx0aXBsaWVyIiwiaGFzQWRkZXIiLCJyZWdpb25hbFJlc3VsdCIsImRlbWFuZFBmbG9wcyIsImVuZXJneUNvc3RQZXJQZmxvcFllYXIiLCJzaXRlQ29zdFBlclBmbG9wWWVhciIsImF2ZXJhZ2VFbmVyZ3lDb3N0TXdoIiwiZ3JvdW5kUmVzdWx0V2l0aEJhY2tsb2ciLCJoYXNQcmVtaXVtIiwibGF1bmNoQ29zdFBlcktnIiwibGlmZXRpbWVZZWFycyIsImZ1c2lvblBhcmFtcyIsImZ1c2lvblRvZ2dsZUVuYWJsZWQiLCJmdXNpb25Ub2dnbGVQYXJhbXMiLCJ0YXJnZXRDb21wdXRlS3ciLCJjb25zdGVsbGF0aW9uIiwiY29tcHV0ZVBvd2VyUGVyU2F0S3ciLCJjb21wdXRlUGVyU2F0S3ciLCJhbHRpdHVkZUttIiwidXNlQ29ycmVjdGVkU3BlY2lmaWNQb3dlciIsInVzZUNvcnJlY3RlZFRoZXJtYWwiLCJ0aGVybWFsQ2FwRmFjdG9yIiwidGhlcm1hbFN5c3RlbSIsInJhZGlhdGlvbkRlcmF0ZSIsImRlZ3JhZGF0aW9uRmFjdG9yIiwiYXZhaWxhYmlsaXR5IiwiY2FwYWNpdHlGYWN0b3IiLCJvcmJpdERlbGl2ZXJlZEdmbG9wc1BlcldhdHQiLCJvcmlnaW5hbERlbGl2ZXJlZCIsIm9yYml0RWZmZWN0aXZlR2Zsb3BzUGVyVyIsInBvd2VyU2NhbGluZ1BhcmFtcyIsInNjYWxpbmdSZXN1bHQiLCJtYXNzUGVyU2F0S2ciLCJ0b3RhbE1hc3NLZyIsIk1BWF9TQVRFTExJVEVfTUFTU19LRyIsIm1heE1hc3NLZyIsIm1hc3NQZXJLdyIsIm1heENvbXB1dGVQZXJTYXRLdyIsImFkanVzdGVkQ29uc3RlbGxhdGlvbiIsIm1heENvbXB1dGVLdyIsImFkanVzdGVkSHlicmlkUmVzdWx0IiwiYWRqdXN0ZWRNYXNzUGVyU2F0S2ciLCJhZGp1c3RlZFRoZXJtYWxDYXBGYWN0b3IiLCJhZGp1c3RlZFJhZGlhdGlvbkRlcmF0ZSIsImFkanVzdGVkQXZhaWxhYmlsaXR5IiwiYWRqdXN0ZWREZWxpdmVyZWRHZmxvcHNQZXJXYXR0IiwiY29uc3RlbGxhdGlvbk11bHRpcGxpZXIiLCJudW1TYXRlbGxpdGVzIiwiY29uc3RlbGxhdGlvbk92ZXJoZWFkTXVsdGlwbGllciIsImNvbnN0ZWxsYXRpb25PdmVyaGVhZCIsImVmZmVjdGl2ZVRvdGFsTWFzc0tnIiwiZWZmZWN0aXZlVG90YWxMYXVuY2hDb3N0IiwiZWZmZWN0aXZlUG93ZXJGYWJDb3N0IiwicG93ZXJTeXN0ZW0iLCJmYWJDb3N0VXNkIiwiZWZmZWN0aXZlTmV0d29ya2luZ0ZhYkNvc3QiLCJuZXR3b3JraW5nIiwiZWZmZWN0aXZlTmV0d29ya2luZ09wRXgiLCJhbm51YWxPcEV4VXNkIiwiZWZmZWN0aXZlUGZsb3BzUGVyU2F0IiwidG90YWxFZmZlY3RpdmVQZmxvcHMiLCJsYXVuY2hDb3N0UGVyUGZsb3BZZWFyIiwiY29uc3RlbGxhdGlvbkNvc3RNdWx0aXBsaWVyIiwicG93ZXJDb3N0IiwiY29tcHV0ZUNvc3QiLCJjb21wdXRlUGF5bG9hZCIsImNoaXBDb3N0VXNkIiwicXVhbGlmaWNhdGlvbkNvc3RVc2QiLCJ0aGVybWFsQ29zdCIsInJhZGlhdGlvbkNvc3QiLCJyYWRpYXRpb25Qcm90ZWN0aW9uIiwiYnVzQ29zdCIsImJ1cyIsIm5ldHdvcmtpbmdDb3N0IiwiaW50ZXJjb25uZWN0Q29zdCIsInRvdGFsQW5udWFsQ29zdCIsInJlZ3VsYXRvcnlDb3N0IiwicmVndWxhdG9yeSIsImFubnVhbENvc3RVc2QiLCJiYXNlT3BzQ29zdFBlclNhdCIsIm9wc1BlclBmbG9wWWVhciIsIm5ldHdvcmtpbmdPcHNDb3N0UGVyU2F0IiwiYWRqdXN0ZWROZXR3b3JraW5nT3BzQ29zdFBlclNhdCIsIm9wc0Nvc3RQZXJTYXQiLCJvcHNDb3N0TXVsdGlwbGllciIsIm9yYml0YWxCcmVha2Rvd24iLCJyYWRpYXRpb24iLCJjb25nZXN0aW9uIiwibGF1bmNoIiwidG90YWxTYXRlbGxpdGVDb3N0Iiwic2F0ZWxsaXRlQ291bnQiLCJjb25nZXN0aW9uQ29zdFBlclBmbG9wWWVhciIsIm9yYml0YWxDb21wb25lbnRzIiwidmFsdWUiLCJicmVha2Rvd25TdW0iLCJPYmplY3QiLCJ2YWx1ZXMiLCJyZWR1Y2UiLCJhIiwiYiIsInJlYWxpc3RpY0Nvc3RQZXJQZmxvcCIsImFwcGxpZWRUbyIsIm9yYml0YWxBY2NvdW50aW5nIiwiY29zdEFjY291bnRpbmdWYWxpZCIsImNvc3RBY2NvdW50aW5nRXJyb3JQY3QiLCJlcnJvclBjdCIsImFubnVhbEdwdUhvdXJzUGVyUEZMT1AiLCJkZWxheVBlbmFsdHlBZGRlclBlckdwdUhvdXIiLCJncm91bmRDb3N0QmFzZUZvclByaWNpbmciLCJncm91bmRHcHVIb3VyIiwiYmFzZVByaWNpbmciLCJzaXRlIiwicHJlTWFyZ2luQmFzZSIsIlNDQVJDSVRZX1JFRkVSRU5DRV9CQVNFIiwiY29zdFdpdGhTY2FyY2l0eSIsImNvc3RXaXRoU2NhcmNpdHlBbmREZWxheSIsInNjYXJjaXR5Iiwib3JiaXRhbEdwdUhvdXIiLCJncm91bmRUb2tlbnMiLCJsbGFtYTcwQiIsImxsYW1hNDA1QiIsIm9yYml0YWxUb2tlbnMiLCJlZGdlSW5mZXJlbmNlIiwiZ3B1SG91ckNyb3Nzb3ZlciIsInN0YW5kYXJkIiwiZ3JvdW5kRWZmZWN0aXZlIiwiZ3JvdW5kSGVhZGxpbmUiLCJlZmZlY3RpdmVFcnJvciIsImV4cGVjdGVkRGVsaXZlcmVkIiwiVE9MRVJBTkNFIiwicmF0aW9FcnJvciIsImlzUmF0aW9WYWxpZCIsIkVTQ0FMQVRFX1RIUkVTSE9MRCIsImlzSW52YWxpZCIsImRlbGl2ZXJlZFZzU3lzdGVtRXJyb3IiLCJkZWxpdmVyZWRWYWxpZGF0aW9uIiwiZGVsaXZlcmVkIiwiZmFjdG9yc1VzZWQiLCJ1dGlsaXphdGlvbiIsImludmFsaWQiLCJlZmZpY2llbmN5VmFsaWRhdGlvbiIsImVmZmljaWVuY3lMZXZlbCIsImNvbnNpc3RlbmN5Q2hlY2siLCJzYW5pdHlQYW5lbCIsImdyb3VuZCIsInNpdGVDYXBleEFtb3J0IiwiY2FwYWNpdHlQcmVtaXVtIiwib3JiaXQiLCJzcGVjaWZpY1Bvd2VyTXVsdGlwbGllcnMiLCJyZXF1aXJlZEFyZWFNMiIsInFQZXJNMl9XIiwid2FzdGVIZWF0VyIsIndhc3RlSGVhdEt3IiwicGh5c2ljYWxBcmVhTTIiLCJhcmVhQXZhaWxhYmxlTTIiLCJhbGxJbnZhcmlhbnRzUGFzc2VkIiwidGhlcm1hbEFyZWFDaGVjayIsInNwZWNpZmljUG93ZXJDaGVjayIsImVmZmVjdGl2ZSIsImJhc2VTcGVjaWZpY1Bvd2VyIiwidGhlcm1hbENhcENoZWNrIiwiZWxlY3RyaWNpdHlQcmljZVBlck13aCIsInB1ZSIsImNvbXB1dGVEZWZpbml0aW9uIiwicGVhayIsImNoaXBOYW1lIiwicGVha0dmbG9wc1BlcldhdHQiLCJlZmZlY3RpdmVHZmxvcHNQZXJXYXR0IiwiZ3B1SG91clByaWNpbmciLCJiYXNpYyIsInByZW1pdW0iLCJ0b2tlblByaWNpbmciLCJsY29lUGVyTXdoIiwidG90YWxDb3N0VXNkIiwiY2FwYWNpdHlGYWN0b3JQcm92ZW5hbmNlIiwiY29tcHV0ZUVmZmljaWVuY3lQcm92ZW5hbmNlIiwic3BlY2lmaWNQb3dlcldQZXJLZyIsInNwZWNpZmljUG93ZXJfc3Vic3lzdGVtX1dQZXJLZyIsInNwZWNpZmljUG93ZXJfZWZmZWN0aXZlX1dQZXJLZyIsImVmZmVjdGl2ZVNwZWNpZmljUG93ZXIiLCJoYXJkd2FyZUNvc3RQZXJQZmxvcFllYXIiLCJyYWRpYXRpb25NdWx0aXBsaWVyIiwidGhlcm1hbENhcHBlZCIsIm1heFJlamVjdGFibGVLdyIsImNvbGxpc2lvblJpc2siLCJib2R5TW91bnRlZEFyZWFNMiIsImRlcGxveWFibGVBcmVhTTIiLCJ0b3RhbFJhZGlhdG9yQXJlYU0yIiwicmFkaWF0b3JDb3N0UGVyUGZsb3BZZWFyIiwicmFkaWF0b3JNYXNzS2ciLCJvcHRpbWlzdGljQ29zdFBlclBmbG9wIiwicmFkaWF0aW9uU2hpZWxkaW5nQ29zdCIsInRoZXJtYWxTeXN0ZW1Db3N0IiwicmVwbGFjZW1lbnRSYXRlQ29zdCIsImVjY092ZXJoZWFkQ29zdCIsInJlZHVuZGFuY3lDb3N0IiwiaHlicmlkQnJlYWtkb3duIiwicmFkaWF0aW9uRGVncmFkYXRpb24iLCJhbm51YWxGYWlsdXJlUmF0ZSIsImVmZmVjdGl2ZUNvbXB1dGVQZXJjZW50IiwiZWNjT3ZlcmhlYWRQY3QiLCJhcHBsaWVkIiwicG93ZXJTeXN0ZW1UeXBlIiwic2NhbGluZ1BlbmFsdHkiLCJmdXNpb25EZXRhaWxzIiwiZGVzaWduIiwicmFkaWF0b3JBcmVhUGVyU2F0TTIiLCJzYXRzUGVyTGF1bmNoIiwibGF1bmNoZXNSZXF1aXJlZCIsInNjYWxpbmciLCJzY2FsaW5nRWZmaWNpZW5jeSIsIndhcm5pbmdzIiwiZWZmZWN0aXZlQ29tcHV0ZU11bHRpcGxpZXJzIiwiY29zdFNoYXJlcyIsImdyb3VuZFNlZ21lbnQiLCJsb2NhbFNlbnNpdGl2aXR5IiwiZENvc3RfZExhdW5jaCIsImRDb3N0X2RTcGVjaWZpY1Bvd2VyIiwiZENvc3RfZEdmbG9wc1BlclciLCJiYXNlRmFpbHVyZVJhdGUiLCJkQ29zdF9kRmFpbHVyZVJhdGUiLCJkQ29zdF9kUHVlIiwiY3Jvc3NvdmVyIiwiY3Jvc3NvdmVyRGV0YWlscyIsInRva2VuQ3Jvc3NvdmVyIiwibWFya2V0UG9zaXRpb24iLCJtZXRhZGF0YSIsImdyb3VuZFVuaXRzIiwibWV0cmljIiwidW5pdCIsIm9yYml0VW5pdHMiLCJncHVGYWlsdXJlUmF0ZUFubnVhbCIsInRvdGFsQ29zdEV4Y2x1ZGVzRGVsYXlQZW5hbHR5IiwidG90YWxDb3N0RWZmZWN0aXZlSW5jbHVkZXNEZWxheVBlbmFsdHkiLCJjb21wdXRlRWZmaWNpZW5jeSIsInZhbGlkYXRpb24iLCJjaGFydElucHV0cyIsInBvd2VyQnVpbGRvdXQiLCJzdXBwbHlHdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/physicsCost.ts\n"));

/***/ })

});