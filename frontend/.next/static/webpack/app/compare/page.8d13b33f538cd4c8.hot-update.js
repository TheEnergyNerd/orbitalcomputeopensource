"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/compare/page",{

/***/ "(app-pages-browser)/./app/lib/model/trajectory.ts":
/*!*************************************!*\
  !*** ./app/lib/model/trajectory.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MARKET_PROVIDERS: function() { return /* binding */ MARKET_PROVIDERS; },\n/* harmony export */   calculateMarketShare: function() { return /* binding */ calculateMarketShare; },\n/* harmony export */   calculateResponsiveDemand: function() { return /* binding */ calculateResponsiveDemand; },\n/* harmony export */   computeTrajectory: function() { return /* binding */ computeTrajectory; },\n/* harmony export */   findCrossoverYear: function() { return /* binding */ findCrossoverYear; },\n/* harmony export */   findCrossoverYearEffectivePflop: function() { return /* binding */ findCrossoverYearEffectivePflop; },\n/* harmony export */   generateFinalAnalysis: function() { return /* binding */ generateFinalAnalysis; },\n/* harmony export */   getDemandNewGW: function() { return /* binding */ getDemandNewGW; },\n/* harmony export */   getDemandProjection: function() { return /* binding */ getDemandProjection; },\n/* harmony export */   getFacilityLoadGW: function() { return /* binding */ getFacilityLoadGW; },\n/* harmony export */   getITLoadGW: function() { return /* binding */ getITLoadGW; },\n/* harmony export */   projectMarketPrice: function() { return /* binding */ projectMarketPrice; }\n/* harmony export */ });\n/* harmony import */ var _physicsCost__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./physicsCost */ \"(app-pages-browser)/./app/lib/model/physicsCost.ts\");\n/* harmony import */ var _launch_learning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./launch_learning */ \"(app-pages-browser)/./app/lib/model/launch_learning.ts\");\n/* harmony import */ var _modes_static__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modes/static */ \"(app-pages-browser)/./app/lib/model/modes/static.ts\");\n/* harmony import */ var _monteCarloCrossover__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./monteCarloCrossover */ \"(app-pages-browser)/./app/lib/model/monteCarloCrossover.ts\");\n\n\n\n\n/**\n * Find crossover year using GPU-hour pricing (preferred, includes scarcity)\n * Uses scarcity-inclusive comparator consistently\n */ function findCrossoverYear(trajectory) {\n    const crossing = trajectory.find((d)=>{\n        var _d_ground_constraints, _d_ground_constraints1;\n        var _d_ground_totalCostPerPflopYearEffective;\n        // Use effective ground cost (includes delayPenalty + scarcityRent) for crossover\n        const groundEffectiveCost = (_d_ground_totalCostPerPflopYearEffective = d.ground.totalCostPerPflopYearEffective) !== null && _d_ground_totalCostPerPflopYearEffective !== void 0 ? _d_ground_totalCostPerPflopYearEffective : d.ground.totalCostPerPflopYear + (((_d_ground_constraints = d.ground.constraints) === null || _d_ground_constraints === void 0 ? void 0 : _d_ground_constraints.delayPenalty) || 0) + (((_d_ground_constraints1 = d.ground.constraints) === null || _d_ground_constraints1 === void 0 ? void 0 : _d_ground_constraints1.scarcityRentPerPflopYear) || 0);\n        var _d_orbit_totalCostPerPflopYearEffective;\n        const orbitCost = (_d_orbit_totalCostPerPflopYearEffective = d.orbit.totalCostPerPflopYearEffective) !== null && _d_orbit_totalCostPerPflopYearEffective !== void 0 ? _d_orbit_totalCostPerPflopYearEffective : d.orbit.totalCostPerPflopYear;\n        return Number.isFinite(orbitCost) && Number.isFinite(groundEffectiveCost) && orbitCost < groundEffectiveCost;\n    });\n    return crossing ? crossing.year : null;\n}\n/**\n * Find crossover year using effective PFLOP-year cost (includes scarcity adders)\n * Uses scarcity-inclusive comparator: delayPenalty + scarcityRent\n * capacityDeliveryPremium is engineering cost, not scarcity pricing\n */ function findCrossoverYearEffectivePflop(trajectory) {\n    const crossing = trajectory.find((d)=>{\n        var _d_ground_constraints, _d_ground_constraints1;\n        var _d_ground_totalCostPerPflopYearEffective;\n        // Ground effective cost includes: base + delayPenalty + scarcityRent\n        const groundEffectiveCost = (_d_ground_totalCostPerPflopYearEffective = d.ground.totalCostPerPflopYearEffective) !== null && _d_ground_totalCostPerPflopYearEffective !== void 0 ? _d_ground_totalCostPerPflopYearEffective : d.ground.totalCostPerPflopYear + (((_d_ground_constraints = d.ground.constraints) === null || _d_ground_constraints === void 0 ? void 0 : _d_ground_constraints.delayPenalty) || 0) + (((_d_ground_constraints1 = d.ground.constraints) === null || _d_ground_constraints1 === void 0 ? void 0 : _d_ground_constraints1.scarcityRentPerPflopYear) || 0);\n        var _d_orbit_totalCostPerPflopYearEffective;\n        const orbitCost = (_d_orbit_totalCostPerPflopYearEffective = d.orbit.totalCostPerPflopYearEffective) !== null && _d_orbit_totalCostPerPflopYearEffective !== void 0 ? _d_orbit_totalCostPerPflopYearEffective : d.orbit.totalCostPerPflopYear;\n        return orbitCost < groundEffectiveCost;\n    });\n    return crossing ? crossing.year : null;\n}\n// Calculate market share based on cost ratio\n// When orbital is 50% cheaper, it gets ~80% of NEW capacity\n// When orbital is 2x more expensive, it gets ~5% (niche applications)\nfunction calculateMarketShare(year, orbitalCostPerPflop, groundCostPerPflop, totalDemandGW) {\n    let orbitalFeasible = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true, groundFeasible = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true, orbitalCostAccountingValid = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : true, groundCostAccountingValid = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : true, // Additional parameters for served compute calculation\n    demandGW = arguments.length > 8 ? arguments[8] : void 0, backlogGW = arguments.length > 9 ? arguments[9] : void 0, buildRateGWyr = arguments.length > 10 ? arguments[10] : void 0, avgWaitYears = arguments.length > 11 ? arguments[11] : void 0, orbitMaxDeployableComputeGW // Maximum orbital capacity (from launch/manufacturing constraints)\n     = arguments.length > 12 ? arguments[12] : void 0;\n    // CRITICAL FIX: Feasibility gating\n    // Check if both systems are feasible before computing shares\n    const orbitalActuallyFeasible = orbitalFeasible && orbitalCostAccountingValid;\n    const groundActuallyFeasible = groundFeasible && groundCostAccountingValid;\n    // If neither is feasible, default to ground (conservative)\n    if (!orbitalActuallyFeasible && !groundActuallyFeasible) {\n        return {\n            year,\n            totalDemandGW,\n            orbitalShareFrac: 0,\n            orbitalCapacityGW: 0,\n            orbitalRevenue: 0,\n            groundShareFrac: 1.0,\n            groundCapacityGW: totalDemandGW,\n            debug: {\n                shareConvention: \"frac\",\n                orbitalFeasible: false,\n                groundFeasible: false,\n                orbitalShareFrac: 0,\n                groundShareFrac: 1.0,\n                orbitalCapacityGW: 0,\n                groundCapacityGW: totalDemandGW,\n                orbitalRevenue: 0,\n                groundRevenue: totalDemandGW * 2e9\n            }\n        };\n    }\n    // If only one is feasible, it gets 100%\n    if (!orbitalActuallyFeasible) {\n        return {\n            year,\n            totalDemandGW,\n            orbitalShareFrac: 0,\n            orbitalCapacityGW: 0,\n            orbitalRevenue: 0,\n            groundShareFrac: 1.0,\n            groundCapacityGW: totalDemandGW,\n            debug: {\n                shareConvention: \"frac\",\n                orbitalFeasible: false,\n                groundFeasible: true,\n                orbitalShareFrac: 0,\n                groundShareFrac: 1.0,\n                orbitalCapacityGW: 0,\n                groundCapacityGW: totalDemandGW,\n                orbitalRevenue: 0,\n                groundRevenue: totalDemandGW * 2e9\n            }\n        };\n    }\n    if (!groundActuallyFeasible) {\n        return {\n            year,\n            totalDemandGW,\n            orbitalShareFrac: 1.0,\n            orbitalCapacityGW: totalDemandGW,\n            orbitalRevenue: totalDemandGW * 2e9,\n            groundShareFrac: 0,\n            groundCapacityGW: 0,\n            debug: {\n                shareConvention: \"frac\",\n                orbitalFeasible: true,\n                groundFeasible: false,\n                orbitalShareFrac: 1.0,\n                groundShareFrac: 0,\n                orbitalCapacityGW: totalDemandGW,\n                groundCapacityGW: 0,\n                orbitalRevenue: totalDemandGW * 2e9,\n                groundRevenue: 0\n            }\n        };\n    }\n    // Hard rules: shares are always 0..1 fractions, served compute cannot exceed feasible compute\n    const demand = demandGW !== null && demandGW !== void 0 ? demandGW : totalDemandGW;\n    const backlogGWActual = backlogGW !== null && backlogGW !== void 0 ? backlogGW : 0;\n    const buildRateGWyrActual = buildRateGWyr !== null && buildRateGWyr !== void 0 ? buildRateGWyr : 0;\n    const avgWaitYearsActual = avgWaitYears !== null && avgWaitYears !== void 0 ? avgWaitYears : 0;\n    // HARD FEASIBILITY GATING: If avgWaitYears > 3 OR backlog > 25% of demand, ground cannot serve all marginal demand\n    // This forces spillover to orbital earlier, making crossover happen the right way (feasibility, not fake pricing)\n    const groundHasSevereQueue = avgWaitYearsActual > 3 || backlogGWActual > 0.25 * demand;\n    // Ground feasible capacity: reduced by queue pressure\n    const groundFeasibleGW = groundActuallyFeasible ? groundHasSevereQueue ? Math.max(0, demand * 0.5 - backlogGWActual) // Severe queue: ground can only serve 50% of demand\n     : Math.max(0, demand - backlogGWActual) // Normal: ground can serve demand minus backlog\n     : 0;\n    // Orbital feasible capacity: can serve remainder (up to max deployable)\n    const orbitFeasibleGW = orbitalActuallyFeasible ? Math.min(demand - groundFeasibleGW, orbitMaxDeployableComputeGW !== null && orbitMaxDeployableComputeGW !== void 0 ? orbitMaxDeployableComputeGW : demand) : 0;\n    const maxServable = Math.min(demand, groundFeasibleGW + orbitFeasibleGW);\n    // Compute desired shares (0..1) from cost ratios (logit model)\n    const costRatio = orbitalCostPerPflop / groundCostPerPflop;\n    const logitFactor = Math.exp(-5 * (costRatio - 1)); // When orbital is 50% cheaper, it gets ~80% of NEW capacity\n    const orbitalShareFracDesired = logitFactor / (1 + logitFactor);\n    const groundShareFracDesired = 1 - orbitalShareFracDesired;\n    // Convert to served, then clamp by feasibility\n    let orbitServed = orbitalShareFracDesired * maxServable;\n    let groundServed = groundShareFracDesired * maxServable;\n    orbitServed = Math.min(orbitServed, orbitFeasibleGW);\n    groundServed = Math.min(groundServed, groundFeasibleGW);\n    // If clamping reduced one side, reassign remainder if possible\n    const remainder = maxServable - (orbitServed + groundServed);\n    if (remainder > 0) {\n        const orbitRoom = orbitFeasibleGW - orbitServed;\n        const groundRoom = groundFeasibleGW - groundServed;\n        const addToOrbit = Math.min(remainder, Math.max(0, orbitRoom));\n        orbitServed += addToOrbit;\n        groundServed += Math.min(remainder - addToOrbit, Math.max(0, groundRoom));\n    }\n    // Recalculate shares from actual served (ensures shares are 0..1 and sum to 1)\n    const totalServedGW = orbitServed + groundServed;\n    const orbitalShareFrac = totalServedGW > 0 ? orbitServed / totalServedGW : 0;\n    const groundShareFrac = totalServedGW > 0 ? groundServed / totalServedGW : 0;\n    // Use served values for capacity\n    const groundServedComputeGW = groundServed;\n    const orbitServedComputeGW = orbitServed;\n    const groundFeasibleComputeGW = groundFeasibleGW;\n    const orbitFeasibleComputeGW = orbitFeasibleGW;\n    // Capacity served (GW)\n    const orbitalCapacityGW = orbitServedComputeGW;\n    const groundCapacityGW = groundServedComputeGW;\n    // Revenue per GW (assume $2B/GW/year for compute services)\n    const revenuePerGW = 2e9;\n    const orbitalRevenue = orbitalCapacityGW * revenuePerGW;\n    const groundRevenue = groundCapacityGW * revenuePerGW;\n    // Invariants\n    if (orbitalCapacityGW === 0 && orbitalRevenue !== 0) {\n        throw new Error(\"orbitalCapacityGW=0 but orbitalRevenue=\".concat(orbitalRevenue, \" > 0\"));\n    }\n    if (orbitalRevenue > 0 && orbitalCapacityGW <= 0) {\n        throw new Error(\"orbitalRevenue=\".concat(orbitalRevenue, \" > 0 but orbitalCapacityGW=\").concat(orbitalCapacityGW, \" <= 0\"));\n    }\n    if (orbitFeasibleComputeGW === 0 && orbitalShareFrac !== 0) {\n        throw new Error(\"orbitFeasibleComputeGW=0 but orbitalShareFrac=\".concat(orbitalShareFrac, \" > 0\"));\n    }\n    // Shares should sum to 1.0 when both feasible and totalServed > 0\n    if (totalServedGW > 0) {\n        const shareSum = orbitalShareFrac + groundShareFrac;\n        if (Math.abs(shareSum - 1.0) > 1e-6) {\n            throw new Error(\"Market share sum must equal 1.0, got \".concat(shareSum, \" (orbital=\").concat(orbitalShareFrac, \", ground=\").concat(groundShareFrac, \")\"));\n        }\n    }\n    return {\n        year,\n        totalDemandGW,\n        orbitalShareFrac,\n        orbitalCapacityGW,\n        orbitalRevenue,\n        groundShareFrac,\n        groundCapacityGW,\n        debug: {\n            shareConvention: \"frac\",\n            orbitalFeasible: true,\n            groundFeasible: true,\n            orbitalShareFrac,\n            groundShareFrac,\n            orbitalCapacityGW,\n            groundCapacityGW,\n            orbitalRevenue,\n            groundRevenue,\n            demandComputeGW: demand,\n            groundServedComputeGW,\n            orbitServedComputeGW,\n            groundFeasibleComputeGW,\n            orbitFeasibleComputeGW,\n            backlogGW: backlogGWActual,\n            buildRateGWyr: buildRateGWyrActual,\n            avgWaitYears: avgWaitYears !== null && avgWaitYears !== void 0 ? avgWaitYears : 0\n        }\n    };\n}\nfunction projectMarketPrice(basePrice, baseYear, targetYear) {\n    let annualDeclineRate = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.10;\n    const years = targetYear - baseYear;\n    return basePrice * Math.pow(1 - annualDeclineRate, years);\n}\nconst MARKET_PROVIDERS = [\n    {\n        name: \"AWS H100\",\n        price: 4.50,\n        decline: 0.10\n    },\n    {\n        name: \"Azure H100\",\n        price: 4.00,\n        decline: 0.10\n    },\n    {\n        name: \"CoreWeave\",\n        price: 2.23,\n        decline: 0.12\n    },\n    {\n        name: \"Lambda Labs\",\n        price: 2.49,\n        decline: 0.10\n    }\n];\n// ============================================================================\n// DEMAND MODEL: Installed IT Load (GW) with Piecewise Exponential Growth\n// ============================================================================\n// \n// Model: IT_GW(t) = installed IT load in GW\n// Targets:\n//   - IT_GW(2025) = IT0 (baseline)\n//   - IT_GW(2040) = 450 GW\n//   - IT_GW(2060) = 3000 GW (multi-TW by 2060)\n//\n// Piecewise exponential:\n//   - 2025-2040: IT_GW(t) = IT0 * exp(r1 * (t - 2025))\n//   - 2040-2060: IT_GW(t) = IT_GW(2040) * exp(r2 * (t - 2040))\n//\n// Then derive:\n//   - Facility_GW(t) = IT_GW(t) * PUE(t)  (hits transmission/substation constraints)\n//   - DemandNewGW(t) = max(0, Facility_GW(t) - Facility_GW(t-1))\n// LEGACY: Hardcoded demand anchors (kept for backward compatibility, but replaced by responsive demand)\nconst IT_GW_2025 = 120; // Baseline installed IT load in 2025 (GW)\nconst IT_GW_2040_TARGET = 450; // Target installed IT load in 2040 (GW)\nconst IT_GW_2060_TARGET = 3000; // Target installed IT load in 2060 (GW)\n// Calculate growth rates\nconst R1 = Math.log(IT_GW_2040_TARGET / IT_GW_2025) / 15; // Growth rate 2025-2040\nconst R2 = Math.log(IT_GW_2060_TARGET / IT_GW_2040_TARGET) / 20; // Growth rate 2040-2060\n/**\n * Calculate price-responsive demand that creates S-curve\n * \n * Demand responds to:\n * - Price elasticity: higher ground prices reduce demand\n * - Wait elasticity: longer waits reduce demand\n * - Orbital substitution: if orbital cheaper, demand shifts\n */ function calculateResponsiveDemand(year, groundPricePerGpuHour, orbitalPricePerGpuHour, avgWaitYears, prevDemandState) {\n    // Baseline demand: 10% CAGR from 120 GW, TAPERED after 20 years\n    const yearsFrom2025 = year - 2025;\n    const growthRate = 0.10; // 10% CAGR\n    const taper = 1 / (1 + Math.exp((yearsFrom2025 - 20) / 5)); // Tapers after 2045\n    const effectiveGrowth = growthRate * (0.5 + 0.5 * taper); // 10% -> 5% CAGR\n    const baselineGW = 120 * Math.pow(1 + effectiveGrowth, yearsFrom2025);\n    // BALANCE: Allow S-curve while preventing oscillation\n    // Use exponential smoothing on price and wait factors - balanced for S-curve formation\n    const SMOOTHING_ALPHA = 0.25; // 25% weight on new value, 75% on previous (allows S-curve while preventing oscillation)\n    // Price elasticity: demand drops as ground price rises (REDUCED to prevent oscillation)\n    const baselinePrice = 4.00; // $/GPU-hr reference\n    const priceRatio = groundPricePerGpuHour / baselinePrice;\n    const priceElasticity = -0.2; // REDUCED from -0.3 to -0.2 (less aggressive)\n    const priceFactorRaw = Math.pow(priceRatio, priceElasticity);\n    // Smooth price factor using previous state\n    const prevPriceFactor = prevDemandState ? prevDemandState.effectiveGW / prevDemandState.baselineGW : priceFactorRaw;\n    const priceFactor = SMOOTHING_ALPHA * priceFactorRaw + (1 - SMOOTHING_ALPHA) * prevPriceFactor;\n    // Wait elasticity: demand drops with longer waits (REDUCED to prevent oscillation)\n    const waitElasticity = -0.10; // REDUCED from -0.15 to -0.10 (less aggressive)\n    const waitFactorRaw = Math.exp(avgWaitYears * waitElasticity / 5);\n    // Smooth wait factor using previous state\n    const prevWaitFactor = prevDemandState ? prevDemandState.effectiveGW / (prevDemandState.baselineGW * prevPriceFactor) : waitFactorRaw;\n    const waitFactor = SMOOTHING_ALPHA * waitFactorRaw + (1 - SMOOTHING_ALPHA) * prevWaitFactor;\n    // Effective total demand (may shift to orbital)\n    // Add minimum floor to prevent demand from collapsing too quickly\n    const effectiveGWRaw = baselineGW * priceFactor * waitFactor;\n    const minDemandFrac = 0.5; // Demand can't drop below 50% of baseline\n    const effectiveGW = Math.max(baselineGW * minDemandFrac, effectiveGWRaw);\n    // FIXED: Orbital substitution with smoothing to prevent cobweb oscillation\n    const groundOrbitalRatio = groundPricePerGpuHour / Math.max(orbitalPricePerGpuHour, 0.01);\n    // Gentler curve (k=1.0 instead of 2.0, midpoint=1.5 instead of 1.3)\n    // At ratio 1.2: ~5% shifts, ratio 1.5: ~25%, ratio 2.0: ~50%\n    let targetOrbitalShare = 0;\n    if (groundOrbitalRatio > 1.0) {\n        targetOrbitalShare = 1 / (1 + Math.exp(-1.0 * (groundOrbitalRatio - 1.5)));\n    }\n    var _prevDemandState_orbitalShare;\n    // Smooth orbital share (max 15% change per year) - prevents instant switching\n    const prevOrbitalShare = (_prevDemandState_orbitalShare = prevDemandState === null || prevDemandState === void 0 ? void 0 : prevDemandState.orbitalShare) !== null && _prevDemandState_orbitalShare !== void 0 ? _prevDemandState_orbitalShare : 0;\n    const maxShareChangePerYear = 0.15; // Max 15% shift per year\n    const shareChange = targetOrbitalShare - prevOrbitalShare;\n    const smoothedChange = Math.sign(shareChange) * Math.min(Math.abs(shareChange), maxShareChangePerYear);\n    const orbitalShare = Math.max(0, Math.min(1, prevOrbitalShare + smoothedChange));\n    // Calculate ground demand\n    let groundDemandGW = effectiveGW * (1 - orbitalShare);\n    // DEBUG: Log raw demand before smoothing\n    if (true) {\n        var _prevDemandState_groundDemandGW;\n        console.log(\"[DEMAND DEBUG] Year \".concat(year, \": raw groundDemandGW=\").concat(groundDemandGW.toFixed(1)));\n        var _prevDemandState_groundDemandGW_toFixed;\n        console.log(\"[DEMAND DEBUG]   prevDemandState=\".concat(prevDemandState ? \"exists, groundDemandGW=\".concat((_prevDemandState_groundDemandGW_toFixed = (_prevDemandState_groundDemandGW = prevDemandState.groundDemandGW) === null || _prevDemandState_groundDemandGW === void 0 ? void 0 : _prevDemandState_groundDemandGW.toFixed(1)) !== null && _prevDemandState_groundDemandGW_toFixed !== void 0 ? _prevDemandState_groundDemandGW_toFixed : \"undefined\") : \"NULL\"));\n    }\n    // FIXED: Add demand momentum (max 5% change per year) - prevents wild swings and sawtooth oscillation\n    // Use explicit check instead of truthy check to handle 0 values correctly\n    if (prevDemandState !== null && prevDemandState.groundDemandGW !== undefined && prevDemandState.groundDemandGW > 0) {\n        const maxDemandChangePerYear = 0.05; // Max 5% change per year (tighter constraint to eliminate oscillation)\n        const demandChangeRatio = groundDemandGW / prevDemandState.groundDemandGW;\n        if (true) {\n            console.log(\"[DEMAND DEBUG]   changeRatio=\".concat(demandChangeRatio.toFixed(3), \" (max allowed: \").concat((1 + maxDemandChangePerYear).toFixed(3), \" to \").concat((1 - maxDemandChangePerYear).toFixed(3), \")\"));\n        }\n        if (demandChangeRatio > 1 + maxDemandChangePerYear) {\n            const clamped = prevDemandState.groundDemandGW * (1 + maxDemandChangePerYear);\n            if (true) {\n                console.log(\"[DEMAND DEBUG]   CLAMPED UP from \".concat(groundDemandGW.toFixed(1), \" to \").concat(clamped.toFixed(1)));\n            }\n            groundDemandGW = clamped;\n        } else if (demandChangeRatio < 1 - maxDemandChangePerYear) {\n            const clamped = prevDemandState.groundDemandGW * (1 - maxDemandChangePerYear);\n            if (true) {\n                console.log(\"[DEMAND DEBUG]   CLAMPED DOWN from \".concat(groundDemandGW.toFixed(1), \" to \").concat(clamped.toFixed(1)));\n            }\n            groundDemandGW = clamped;\n        } else {\n            if (true) {\n                console.log(\"[DEMAND DEBUG]   NO CLAMP (within bounds)\");\n            }\n        }\n    } else {\n        if (true) {\n            console.log(\"[DEMAND DEBUG]   NO SMOOTHING (prevDemandState check failed: \".concat(prevDemandState === null ? \"null\" : prevDemandState.groundDemandGW === undefined ? \"undefined\" : \"zero or negative\", \")\"));\n        }\n    }\n    const orbitalDemandGW = effectiveGW - groundDemandGW;\n    return {\n        year,\n        baselineGW,\n        effectiveGW,\n        groundDemandGW,\n        orbitalDemandGW,\n        orbitalShare\n    };\n}\n/**\n * Calculate installed IT load (GW) for a given year\n */ function getITLoadGW(year) {\n    if (year < 2025) {\n        return IT_GW_2025;\n    }\n    if (year <= 2040) {\n        // Phase 1: 2025-2040\n        const yearsFrom2025 = year - 2025;\n        return IT_GW_2025 * Math.exp(R1 * yearsFrom2025);\n    }\n    // Phase 2: 2040-2060\n    const yearsFrom2040 = year - 2040;\n    return IT_GW_2040_TARGET * Math.exp(R2 * yearsFrom2040);\n}\n/**\n * Calculate facility load (GW) = IT load * PUE\n */ function getFacilityLoadGW(year) {\n    let pue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1.3;\n    const itLoadGW = getITLoadGW(year);\n    return itLoadGW * pue;\n}\n/**\n * Calculate new demand (GW) = max(0, Facility_GW(t) - Facility_GW(t-1))\n */ function getDemandNewGW(year) {\n    let pue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1.3;\n    const facilityGW = getFacilityLoadGW(year, pue);\n    const facilityGWPrev = getFacilityLoadGW(year - 1, pue);\n    return Math.max(0, facilityGW - facilityGWPrev);\n}\n/**\n * Legacy function: returns IT load (not facility load)\n * Kept for backward compatibility\n */ function getDemandProjection(year) {\n    return getITLoadGW(year);\n}\nfunction computeTrajectory(options) {\n    // Re-export crossover analysis functions for convenience\n    // Users can import from trajectory.ts or crossoverAnalysis.ts\n    const years = Array.from({\n        length: 26\n    }, (_, i)=>2025 + i); // 2025-2050 (26 years)\n    const trajectory = [];\n    let firstCapYear = null; // Track when constraint cap was first hit\n    // Launch learning: Track cumulative mass to orbit\n    let launchLearningState = null;\n    const BASELINE_MASS_KG = 1000000; // 1M kg baseline for doublings calculation\n    const LAUNCH_COST_0_PER_KG = 1500; // Initial launch cost in 2025\n    // Responsive demand: Track demand state across years for S-curve behavior\n    let prevDemandState = null;\n    let prevYearBreakdown = null;\n    // Buildout state: Track across years for backlog calculation\n    let buildoutState = null;\n    // Mobilization state: Track across years for capacity/backlog evolution\n    let mobilizationState = null;\n    for (const year of years){\n        var _prevYearBreakdown_ground_gpuHourPricing_standard, _prevYearBreakdown_ground_gpuHourPricing, _prevYearBreakdown_ground, _prevYearBreakdown_orbit_gpuHourPricing_standard, _prevYearBreakdown_orbit_gpuHourPricing, _prevYearBreakdown_orbit, _prevYearBreakdown_ground_supplyMetrics, _prevYearBreakdown_ground1, _breakdown_ground, _breakdown_ground1, _breakdown_orbit_constellation, _breakdown_orbit, _breakdown_metadata_chartInputs, _breakdown_metadata, _breakdown_ground2, _breakdown_ground_buildoutDebug, _breakdown_ground3, _breakdown_ground_buildoutDebug1, _breakdown_ground4, _breakdown_ground_supplyMetrics, _breakdown_ground5, _breakdown_ground6, _breakdown_ground_buildoutDebug2, _breakdown_ground7, _breakdown_ground_supplyMetrics1, _breakdown_ground8, _params_orbitMaxDeployableComputeGWByYear, _breakdown_ground9;\n        const params = options.mode === \"STATIC\" ? (0,_modes_static__WEBPACK_IMPORTED_MODULE_2__.getStaticParams)(year) : options.paramsByYear(year);\n        // Apply launch learning if enabled\n        let launchCostPerKg = (0,_physicsCost__WEBPACK_IMPORTED_MODULE_0__.getLaunchCostPerKg)(year, params.launchCostKg);\n        let paramsWithLaunchCost = params;\n        if (options.useLaunchLearning) {\n            // Estimate mass demanded from compute power: ~1000 kg per MW compute\n            // Use targetGW as proxy for orbital compute demand\n            const computePowerMW = params.targetGW * 1000; // Convert GW to MW\n            const massPerMW = 1000; // Rough estimate: 1000 kg per MW\n            const massDemandedKg = computePowerMW * massPerMW;\n            const launchLearningResult = (0,_launch_learning__WEBPACK_IMPORTED_MODULE_1__.stepLaunchLearning)(launchLearningState, {\n                year,\n                massDemandedKg,\n                baselineMassKg: BASELINE_MASS_KG,\n                launchCost0PerKg: LAUNCH_COST_0_PER_KG,\n                learningRate: 0.15,\n                maxFlightsPerYear: 1000,\n                payloadPerFlightKg: 100000\n            });\n            launchCostPerKg = launchLearningResult.launchCostPerKg;\n            launchLearningState = launchLearningResult.state;\n            // Override launch cost in params for this year\n            paramsWithLaunchCost = {\n                ...params,\n                launchCostKg: launchCostPerKg\n            };\n        }\n        var _params_pueGround;\n        // SINGLE SOURCE OF TRUTH: compute demand in GW using RESPONSIVE demand\n        // Demand responds to prices, wait times, and orbital substitution (creates S-curve)\n        // NOTE: We use PREVIOUS year's prices to calculate current year's demand (avoids circular dependency)\n        const groundPue = (_params_pueGround = params.pueGround) !== null && _params_pueGround !== void 0 ? _params_pueGround : 1.3;\n        var _prevYearBreakdown_ground_gpuHourPricing_standard_pricePerGpuHour;\n        // Get prices from previous year (or estimates for first year)\n        const prevGroundPrice = (_prevYearBreakdown_ground_gpuHourPricing_standard_pricePerGpuHour = prevYearBreakdown === null || prevYearBreakdown === void 0 ? void 0 : (_prevYearBreakdown_ground = prevYearBreakdown.ground) === null || _prevYearBreakdown_ground === void 0 ? void 0 : (_prevYearBreakdown_ground_gpuHourPricing = _prevYearBreakdown_ground.gpuHourPricing) === null || _prevYearBreakdown_ground_gpuHourPricing === void 0 ? void 0 : (_prevYearBreakdown_ground_gpuHourPricing_standard = _prevYearBreakdown_ground_gpuHourPricing.standard) === null || _prevYearBreakdown_ground_gpuHourPricing_standard === void 0 ? void 0 : _prevYearBreakdown_ground_gpuHourPricing_standard.pricePerGpuHour) !== null && _prevYearBreakdown_ground_gpuHourPricing_standard_pricePerGpuHour !== void 0 ? _prevYearBreakdown_ground_gpuHourPricing_standard_pricePerGpuHour : 4.00;\n        var _prevYearBreakdown_orbit_gpuHourPricing_standard_pricePerGpuHour;\n        const prevOrbitalPrice = (_prevYearBreakdown_orbit_gpuHourPricing_standard_pricePerGpuHour = prevYearBreakdown === null || prevYearBreakdown === void 0 ? void 0 : (_prevYearBreakdown_orbit = prevYearBreakdown.orbit) === null || _prevYearBreakdown_orbit === void 0 ? void 0 : (_prevYearBreakdown_orbit_gpuHourPricing = _prevYearBreakdown_orbit.gpuHourPricing) === null || _prevYearBreakdown_orbit_gpuHourPricing === void 0 ? void 0 : (_prevYearBreakdown_orbit_gpuHourPricing_standard = _prevYearBreakdown_orbit_gpuHourPricing.standard) === null || _prevYearBreakdown_orbit_gpuHourPricing_standard === void 0 ? void 0 : _prevYearBreakdown_orbit_gpuHourPricing_standard.pricePerGpuHour) !== null && _prevYearBreakdown_orbit_gpuHourPricing_standard_pricePerGpuHour !== void 0 ? _prevYearBreakdown_orbit_gpuHourPricing_standard_pricePerGpuHour : 25.00;\n        var _prevYearBreakdown_ground_supplyMetrics_avgWaitYears;\n        const prevAvgWait = (_prevYearBreakdown_ground_supplyMetrics_avgWaitYears = prevYearBreakdown === null || prevYearBreakdown === void 0 ? void 0 : (_prevYearBreakdown_ground1 = prevYearBreakdown.ground) === null || _prevYearBreakdown_ground1 === void 0 ? void 0 : (_prevYearBreakdown_ground_supplyMetrics = _prevYearBreakdown_ground1.supplyMetrics) === null || _prevYearBreakdown_ground_supplyMetrics === void 0 ? void 0 : _prevYearBreakdown_ground_supplyMetrics.avgWaitYears) !== null && _prevYearBreakdown_ground_supplyMetrics_avgWaitYears !== void 0 ? _prevYearBreakdown_ground_supplyMetrics_avgWaitYears : 0;\n        // Calculate responsive demand (price/wait elastic, orbital substitution)\n        const demandState = calculateResponsiveDemand(year, prevGroundPrice, prevOrbitalPrice, prevAvgWait, prevDemandState);\n        prevDemandState = demandState;\n        // Pass firstCapYear, mobilizationState, and responsive demand to computePhysicsCost\n        // Add mobilization state and responsive demand to params so they can be used for backlog calculation\n        const paramsWithMobilization = {\n            ...paramsWithLaunchCost,\n            prevMobilizationState: mobilizationState,\n            responsiveDemandGW: demandState.groundDemandGW,\n            orbitalSubstitutionGW: demandState.orbitalDemandGW\n        }; // Type assertion needed since YearParams doesn't include these fields\n        const breakdown = (0,_physicsCost__WEBPACK_IMPORTED_MODULE_0__.computePhysicsCost)(paramsWithMobilization, firstCapYear);\n        // Update launch learning state with actual mass from breakdown (for next iteration)\n        if (options.useLaunchLearning && breakdown.orbit && breakdown.orbit.hybridBreakdown) {\n        // Use actual mass from hybrid breakdown if available\n        // Mass is not directly in orbital breakdown, but we can estimate from launch cost\n        // For now, use the mass demanded estimate (will be refined in next iteration)\n        }\n        const constraintBreakdown = breakdown.ground.constraintBreakdown;\n        if (constraintBreakdown && \"capYear\" in constraintBreakdown && constraintBreakdown.capYear !== null && constraintBreakdown.capYear !== undefined) {\n            const thisCapYear = constraintBreakdown.capYear;\n            if (firstCapYear === null || thisCapYear < firstCapYear) {\n                firstCapYear = thisCapYear;\n            }\n        }\n        var _breakdown_ground_pue;\n        // Use responsive ground demand (facility load = ground demand * PUE)\n        const actualGroundPue = (_breakdown_ground_pue = (_breakdown_ground = breakdown.ground) === null || _breakdown_ground === void 0 ? void 0 : _breakdown_ground.pue) !== null && _breakdown_ground_pue !== void 0 ? _breakdown_ground_pue : groundPue;\n        const demandComputeGW = demandState.groundDemandGW * actualGroundPue; // Convert IT load to facility load\n        const orbitalDemandGW = demandState.orbitalDemandGW * actualGroundPue; // For orbital capacity planning\n        // CRITICAL: Ensure ground.buildoutDebug.demandGW matches single source of truth\n        // Override any value from buildout model to ensure consistency\n        if ((_breakdown_ground1 = breakdown.ground) === null || _breakdown_ground1 === void 0 ? void 0 : _breakdown_ground1.buildoutDebug) {\n            breakdown.ground.buildoutDebug.demandGW = demandComputeGW;\n        }\n        // Use demandComputeGW for all market calculations (single source of truth)\n        const totalDemandGW = demandComputeGW;\n        const orbitalFeasible = breakdown.orbit && breakdown.orbit.totalCostPerPflopYear > 0 && breakdown.orbit.totalCostPerPflopYear < Infinity;\n        const groundFeasible = breakdown.ground && breakdown.ground.totalCostPerPflopYear > 0 && breakdown.ground.totalCostPerPflopYear < Infinity;\n        const orbitalCostAccountingValid = breakdown.costAccountingValid !== false;\n        const groundCostAccountingValid = breakdown.costAccountingValid !== false;\n        // Calculate orbital capacity GW from constellation: (numSatellites * computePerSatKw) / 1e6\n        // kW -> GW conversion: divide by 1,000,000 (1e6)\n        // CRITICAL: computePerSatKw is in kW, so divide by 1e6 to get GW (not 1e3 for MW)\n        let orbitalCapacityGW_fromSats = 0;\n        if ((_breakdown_orbit = breakdown.orbit) === null || _breakdown_orbit === void 0 ? void 0 : (_breakdown_orbit_constellation = _breakdown_orbit.constellation) === null || _breakdown_orbit_constellation === void 0 ? void 0 : _breakdown_orbit_constellation.design) {\n            const { numSatellites, computePerSatKw } = breakdown.orbit.constellation.design;\n            // kW -> GW: divide by 1,000,000 (1e6), NOT 1,000 (1e3)\n            orbitalCapacityGW_fromSats = numSatellites * computePerSatKw / 1000000;\n            // Invariant: 1 satellite at 111 kW should be 0.000111 GW, not 1.144 GW\n            if ( true && numSatellites === 1) {\n                const expectedGW = computePerSatKw / 1000000;\n                const error = Math.abs(orbitalCapacityGW_fromSats - expectedGW) / Math.max(expectedGW, 1e-9);\n                if (error > 0.01) {\n                    throw new Error(\"[ORBITAL CAPACITY BUG] Year \".concat(year, \": 1 satellite at \").concat(computePerSatKw, \" kW should be \").concat(expectedGW, \" GW, \") + \"but got \".concat(orbitalCapacityGW_fromSats, \" GW. Check kW->GW conversion (must divide by 1e6, not 1e3).\"));\n                }\n            }\n        }\n        const chartPB = (_breakdown_metadata = breakdown.metadata) === null || _breakdown_metadata === void 0 ? void 0 : (_breakdown_metadata_chartInputs = _breakdown_metadata.chartInputs) === null || _breakdown_metadata_chartInputs === void 0 ? void 0 : _breakdown_metadata_chartInputs.powerBuildout;\n        const chartBacklog = chartPB === null || chartPB === void 0 ? void 0 : chartPB.backlogGw;\n        const chartAvgWait = chartPB === null || chartPB === void 0 ? void 0 : chartPB.avgWaitYears;\n        const chartBuildRate = chartPB === null || chartPB === void 0 ? void 0 : chartPB.maxBuildRateGwYear;\n        // Prefer buildoutDebug when present.\n        // If ground/backlog fields exist but are 0 while chartInputs says >0, use chartInputs.\n        // Remove the pipelineGw proxy entirely (it's not backlog and causes silent unit/meaning corruption).\n        const backlogFromGround = (_breakdown_ground2 = breakdown.ground) === null || _breakdown_ground2 === void 0 ? void 0 : _breakdown_ground2.backlogGw;\n        const backlogFromBuildout = (_breakdown_ground3 = breakdown.ground) === null || _breakdown_ground3 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug = _breakdown_ground3.buildoutDebug) === null || _breakdown_ground_buildoutDebug === void 0 ? void 0 : _breakdown_ground_buildoutDebug.backlogGW;\n        var _ref, _ref1;\n        let backlogGW = (_ref1 = (_ref = backlogFromBuildout !== undefined ? backlogFromBuildout : undefined) !== null && _ref !== void 0 ? _ref : backlogFromGround !== undefined && backlogFromGround > 0 ? backlogFromGround : undefined) !== null && _ref1 !== void 0 ? _ref1 : chartBacklog !== undefined && chartBacklog > 0 ? chartBacklog : 0;\n        const buildRateFromBuildout = (_breakdown_ground4 = breakdown.ground) === null || _breakdown_ground4 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug1 = _breakdown_ground4.buildoutDebug) === null || _breakdown_ground_buildoutDebug1 === void 0 ? void 0 : _breakdown_ground_buildoutDebug1.buildRateGWyr;\n        const buildRateFromSupply = (_breakdown_ground5 = breakdown.ground) === null || _breakdown_ground5 === void 0 ? void 0 : (_breakdown_ground_supplyMetrics = _breakdown_ground5.supplyMetrics) === null || _breakdown_ground_supplyMetrics === void 0 ? void 0 : _breakdown_ground_supplyMetrics.maxBuildRateGwYear;\n        var _ref2, _ref3;\n        const buildRateGWyr = (_ref3 = (_ref2 = buildRateFromBuildout !== undefined ? buildRateFromBuildout : undefined) !== null && _ref2 !== void 0 ? _ref2 : buildRateFromSupply !== undefined ? buildRateFromSupply : undefined) !== null && _ref3 !== void 0 ? _ref3 : chartBuildRate !== undefined ? chartBuildRate : 0;\n        const avgWaitFromGround = (_breakdown_ground6 = breakdown.ground) === null || _breakdown_ground6 === void 0 ? void 0 : _breakdown_ground6.avgWaitYears;\n        const avgWaitFromBuildout = (_breakdown_ground7 = breakdown.ground) === null || _breakdown_ground7 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug2 = _breakdown_ground7.buildoutDebug) === null || _breakdown_ground_buildoutDebug2 === void 0 ? void 0 : _breakdown_ground_buildoutDebug2.timeToPowerYears;\n        const avgWaitFromSupply = (_breakdown_ground8 = breakdown.ground) === null || _breakdown_ground8 === void 0 ? void 0 : (_breakdown_ground_supplyMetrics1 = _breakdown_ground8.supplyMetrics) === null || _breakdown_ground_supplyMetrics1 === void 0 ? void 0 : _breakdown_ground_supplyMetrics1.avgWaitYears;\n        var _ref4, _ref5, _ref6;\n        let avgWaitYears = (_ref6 = (_ref5 = (_ref4 = avgWaitFromBuildout !== undefined ? avgWaitFromBuildout : undefined) !== null && _ref4 !== void 0 ? _ref4 : avgWaitFromGround !== undefined && avgWaitFromGround > 0 ? avgWaitFromGround : undefined) !== null && _ref5 !== void 0 ? _ref5 : avgWaitFromSupply !== undefined && avgWaitFromSupply > 0 ? avgWaitFromSupply : undefined) !== null && _ref6 !== void 0 ? _ref6 : chartAvgWait !== undefined && chartAvgWait > 0 ? chartAvgWait : 0;\n        // Self-heal plumbing mismatches: if chartInputs has positive value but chosen is 0, use chartInputs\n        // Log structured error but never throw (prevents chart from disappearing)\n        if ((chartBacklog !== null && chartBacklog !== void 0 ? chartBacklog : 0) > 0 && backlogGW === 0 && chartBacklog !== undefined) {\n            backlogGW = chartBacklog;\n            if (true) {\n                var _breakdown_ground10, _breakdown_ground_buildoutDebug3, _breakdown_ground11, _breakdown_ground_supplyMetrics2, _breakdown_ground12;\n                console.error(\"[BACKLOG PLUMBING] Year \".concat(year, \": chartInputs.backlogGw=\").concat(chartBacklog, \" but fallback chain returned 0. \") + \"Self-healed: using chartInputs. \" + \"Candidates: ground.backlogGw=\".concat((_breakdown_ground10 = breakdown.ground) === null || _breakdown_ground10 === void 0 ? void 0 : _breakdown_ground10.backlogGw, \", \") + \"buildoutDebug.backlogGW=\".concat((_breakdown_ground11 = breakdown.ground) === null || _breakdown_ground11 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug3 = _breakdown_ground11.buildoutDebug) === null || _breakdown_ground_buildoutDebug3 === void 0 ? void 0 : _breakdown_ground_buildoutDebug3.backlogGW, \", \") + \"supplyMetrics.pipelineGw=\".concat((_breakdown_ground12 = breakdown.ground) === null || _breakdown_ground12 === void 0 ? void 0 : (_breakdown_ground_supplyMetrics2 = _breakdown_ground12.supplyMetrics) === null || _breakdown_ground_supplyMetrics2 === void 0 ? void 0 : _breakdown_ground_supplyMetrics2.pipelineGw));\n            }\n        }\n        if ((chartAvgWait !== null && chartAvgWait !== void 0 ? chartAvgWait : 0) > 0 && avgWaitYears === 0 && chartAvgWait !== undefined) {\n            avgWaitYears = chartAvgWait;\n            if (true) {\n                var _breakdown_ground13, _breakdown_ground_buildoutDebug4, _breakdown_ground14, _breakdown_ground_supplyMetrics3, _breakdown_ground15;\n                console.error(\"[WAIT PLUMBING] Year \".concat(year, \": chartInputs.avgWaitYears=\").concat(chartAvgWait, \" but fallback chain returned 0. \") + \"Self-healed: using chartInputs. \" + \"Candidates: ground.avgWaitYears=\".concat((_breakdown_ground13 = breakdown.ground) === null || _breakdown_ground13 === void 0 ? void 0 : _breakdown_ground13.avgWaitYears, \", \") + \"buildoutDebug.timeToPowerYears=\".concat((_breakdown_ground14 = breakdown.ground) === null || _breakdown_ground14 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug4 = _breakdown_ground14.buildoutDebug) === null || _breakdown_ground_buildoutDebug4 === void 0 ? void 0 : _breakdown_ground_buildoutDebug4.timeToPowerYears, \", \") + \"supplyMetrics.avgWaitYears=\".concat((_breakdown_ground15 = breakdown.ground) === null || _breakdown_ground15 === void 0 ? void 0 : (_breakdown_ground_supplyMetrics3 = _breakdown_ground15.supplyMetrics) === null || _breakdown_ground_supplyMetrics3 === void 0 ? void 0 : _breakdown_ground_supplyMetrics3.avgWaitYears));\n            }\n        }\n        var _params_orbitMaxDeployableComputeGWByYear1;\n        // Calculate orbitMaxDeployableComputeGW from constellation capacity or scenario params\n        // Canonical orbital capacity from constellation: (numSatellites * computePerSatKw) / 1e6\n        const orbitMaxDeployableComputeGW = orbitalFeasible ? (_params_orbitMaxDeployableComputeGWByYear1 = (_params_orbitMaxDeployableComputeGWByYear = params.orbitMaxDeployableComputeGWByYear) === null || _params_orbitMaxDeployableComputeGWByYear === void 0 ? void 0 : _params_orbitMaxDeployableComputeGWByYear.call(params, year)) !== null && _params_orbitMaxDeployableComputeGWByYear1 !== void 0 ? _params_orbitMaxDeployableComputeGWByYear1 : orbitalCapacityGW_fromSats : 0;\n        // Fix orbit feasibility gating: use orbitMaxDeployableComputeGW, not orbitalCapacityGW placeholder\n        const orbitalFeasibleForShare = orbitalFeasible && orbitMaxDeployableComputeGW > 0;\n        const marketAnalysis = calculateMarketShare(year, breakdown.orbit.totalCostPerPflopYear, breakdown.ground.totalCostPerPflopYear, totalDemandGW, orbitalFeasibleForShare, groundFeasible, orbitalCostAccountingValid, groundCostAccountingValid, demandComputeGW, backlogGW, buildRateGWyr, avgWaitYears, orbitMaxDeployableComputeGW);\n        breakdown.market = {\n            totalDemandGW: demandComputeGW,\n            orbitalShareFrac: marketAnalysis.orbitalShareFrac,\n            orbitalCapacityGW: marketAnalysis.orbitalCapacityGW,\n            orbitalRevenue: marketAnalysis.orbitalRevenue,\n            groundShareFrac: marketAnalysis.groundShareFrac,\n            groundCapacityGW: marketAnalysis.groundCapacityGW,\n            debug: {\n                ...marketAnalysis.debug,\n                demandComputeGW: demandComputeGW,\n                orbitalCapacityGW_fromSats: orbitalCapacityGW_fromSats\n            }\n        };\n        // Invariant: demand scalar consistency\n        if ( true && breakdown.market) {\n            var _breakdown_market_debug, _breakdown_ground_buildoutDebug5, _breakdown_ground16;\n            const marketDemand = breakdown.market.totalDemandGW;\n            const marketDebugDemand = (_breakdown_market_debug = breakdown.market.debug) === null || _breakdown_market_debug === void 0 ? void 0 : _breakdown_market_debug.demandComputeGW;\n            const buildoutDemand = (_breakdown_ground16 = breakdown.ground) === null || _breakdown_ground16 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug5 = _breakdown_ground16.buildoutDebug) === null || _breakdown_ground_buildoutDebug5 === void 0 ? void 0 : _breakdown_ground_buildoutDebug5.demandGW;\n            if (marketDebugDemand !== undefined && Math.abs(marketDemand - marketDebugDemand) > 1e-6) {\n                throw new Error(\"[DEMAND SCALAR BUG] Year \".concat(year, \": market.totalDemandGW=\").concat(marketDemand, \" != \") + \"market.debug.demandComputeGW=\".concat(marketDebugDemand, \". Must be equal.\"));\n            }\n            if (buildoutDemand !== undefined && Math.abs(marketDemand - buildoutDemand) > 1e-6) {\n                throw new Error(\"[DEMAND SCALAR BUG] Year \".concat(year, \": market.totalDemandGW=\").concat(marketDemand, \" != \") + \"ground.buildoutDebug.demandGW=\".concat(buildoutDemand, \". Must be equal.\"));\n            }\n        }\n        // Update mobilization state for next year (use extracted values, not breakdown.ground which might be 0)\n        if ((_breakdown_ground9 = breakdown.ground) === null || _breakdown_ground9 === void 0 ? void 0 : _breakdown_ground9.buildoutDebug) {\n            const buildoutDebug = breakdown.ground.buildoutDebug;\n            var _buildoutDebug_demandGW, _buildoutDebug_buildRateGWyr, _buildoutDebug_capacityGW, _buildoutDebug_pipelineGW;\n            mobilizationState = {\n                year,\n                demandGW: (_buildoutDebug_demandGW = buildoutDebug.demandGW) !== null && _buildoutDebug_demandGW !== void 0 ? _buildoutDebug_demandGW : 0,\n                demandNewGW: buildoutDebug.demandNewGW,\n                buildRateGWyr: (_buildoutDebug_buildRateGWyr = buildoutDebug.buildRateGWyr) !== null && _buildoutDebug_buildRateGWyr !== void 0 ? _buildoutDebug_buildRateGWyr : buildRateGWyr,\n                capacityGW: (_buildoutDebug_capacityGW = buildoutDebug.capacityGW) !== null && _buildoutDebug_capacityGW !== void 0 ? _buildoutDebug_capacityGW : 0,\n                pipelineGW: (_buildoutDebug_pipelineGW = buildoutDebug.pipelineGW) !== null && _buildoutDebug_pipelineGW !== void 0 ? _buildoutDebug_pipelineGW : 0,\n                backlogGW: backlogGW,\n                avgWaitYears: avgWaitYears\n            };\n        }\n        trajectory.push(breakdown);\n        // Update previous year breakdown for next iteration (for responsive demand calculation)\n        prevYearBreakdown = breakdown;\n    }\n    return trajectory;\n}\nfunction generateFinalAnalysis(options, baseTrajectory) {\n    var _baseTrajectory__crossoverDetails;\n    const baseCrossover = findCrossoverYear(baseTrajectory);\n    const baseCrossoverEffectivePflop = findCrossoverYearEffectivePflop(baseTrajectory);\n    const baseParams = options.paramsByYear(2025);\n    // 1. Sensitivity Analysis\n    const parametersToTest = [\n        {\n            key: \"launchCostKg\",\n            name: \"Launch Cost (2035)\",\n            values: [\n                50,\n                100,\n                150,\n                200,\n                300\n            ],\n            yearToModify: 2035\n        },\n        {\n            key: \"gpuFailureRate\",\n            name: \"GPU Failure Rate\",\n            values: [\n                0.05,\n                0.10,\n                0.15,\n                0.20,\n                0.25\n            ],\n            yearToModify: null\n        },\n        {\n            key: \"hardwareLearningRate\",\n            name: \"Hardware Learning Rate\",\n            values: [\n                0.08,\n                0.10,\n                0.12,\n                0.15\n            ],\n            yearToModify: null\n        }\n    ];\n    const sensitivities = parametersToTest.map((p)=>{\n        const crossoverYears = p.values.map((val)=>{\n            const testTrajectory = computeTrajectory({\n                ...options,\n                paramsByYear: (y)=>{\n                    const params = options.paramsByYear(y);\n                    if (p.yearToModify && y === p.yearToModify) {\n                        return {\n                            ...params,\n                            [p.key]: val\n                        };\n                    } else if (!p.yearToModify) {\n                        return {\n                            ...params,\n                            [p.key]: val\n                        };\n                    }\n                    return params;\n                }\n            });\n            return findCrossoverYear(testTrajectory);\n        });\n        const validYears = crossoverYears.filter((y)=>y !== null);\n        const maxDelta = validYears.length > 1 ? Math.max(...validYears) - Math.min(...validYears) : 0;\n        const impact = maxDelta >= 4 ? \"high\" : maxDelta >= 2 ? \"medium\" : \"low\";\n        return {\n            parameter: p.name,\n            baseValue: baseParams[p.key] || 0,\n            testValues: p.values,\n            crossoverYears,\n            impact: impact\n        };\n    });\n    // 2. Scenario Benchmarks\n    const scenarios = [\n        {\n            name: \"Bull Case\",\n            description: \"Mature Starship, commercial chips, severe ground constraints\",\n            keyAssumptions: [\n                \"Launch $75/kg by 2035\",\n                \"Commercial chips\",\n                \"Severe ground constraints\"\n            ],\n            crossoverYear: findCrossoverYear(computeTrajectory({\n                ...options,\n                paramsByYear: (y)=>({\n                        ...options.paramsByYear(y),\n                        launchCostKg: (0,_physicsCost__WEBPACK_IMPORTED_MODULE_0__.getLaunchCostPerKg)(y, 1500),\n                        useRadHardChips: false,\n                        groundScenario: \"severe\"\n                    })\n            }))\n        },\n        {\n            name: \"Base Case\",\n            description: \"Current model assumptions (Rad-tolerant baseline)\",\n            keyAssumptions: [\n                \"Launch $75/kg by 2035\",\n                \"Rad-tolerant chips\",\n                \"Standard ground constraints\"\n            ],\n            crossoverYear: baseCrossover\n        },\n        {\n            name: \"Bear Case\",\n            description: \"Rad-hard required, SMRs solve ground power\",\n            keyAssumptions: [\n                \"Launch $300/kg by 2035\",\n                \"Rad-hard chips\",\n                \"Unconstrained ground\"\n            ],\n            crossoverYear: findCrossoverYear(computeTrajectory({\n                ...options,\n                paramsByYear: (y)=>({\n                        ...options.paramsByYear(y),\n                        launchCostKg: projectMarketPrice(1500, 2025, y, 0.10),\n                        useRadHardChips: true,\n                        groundScenario: \"unconstrained\"\n                    })\n            }))\n        }\n    ];\n    // 3. Market Comparison\n    const marketComparison = MARKET_PROVIDERS.map((p)=>{\n        var _baseTrajectory_find;\n        const projectedPrices = [];\n        for(let y = 2025; y <= 2050; y++){\n            projectedPrices.push({\n                year: y,\n                price: projectMarketPrice(p.price, 2024, y, p.decline)\n            });\n        }\n        const orbitalBeatsYear = ((_baseTrajectory_find = baseTrajectory.find((d)=>{\n            const projected = projectMarketPrice(p.price, 2024, d.year, p.decline);\n            return d.orbit.gpuHourPricing.standard.pricePerGpuHour < projected;\n        })) === null || _baseTrajectory_find === void 0 ? void 0 : _baseTrajectory_find.year) || null;\n        return {\n            provider: p.name,\n            currentPrice: p.price,\n            currentYear: 2024,\n            projectedDecline: p.decline,\n            projectedPrices,\n            orbitalBeatsYear\n        };\n    });\n    // 4. Ground Scenario Label\n    const selectedScenario = _physicsCost__WEBPACK_IMPORTED_MODULE_0__.GROUND_SCENARIOS[baseParams.groundScenario];\n    const groundScenarioLabel = {\n        name: selectedScenario.name,\n        description: selectedScenario.description,\n        constraintMultiplier2040: 1.0,\n        assumptions: [\n            \"Grid growth: \".concat((selectedScenario.gridGrowthRate * 100).toFixed(1), \"%/year\"),\n            \"Cooling growth: \".concat((selectedScenario.coolingGrowthRate * 100).toFixed(1), \"%/year\"),\n            selectedScenario.constraintCap ? \"Constraint cap: \".concat(selectedScenario.constraintCap, \"x\") : \"No constraint cap\"\n        ]\n    };\n    // 5. Validation Checks\n    const lastYear = baseTrajectory[baseTrajectory.length - 1];\n    const firstYear = baseTrajectory[0];\n    const allChecks = [\n        {\n            name: \"Cost breakdown sums to total\",\n            passed: !!lastYear.costAccountingValid,\n            value: lastYear.costAccountingErrorPct,\n            expected: \"<0.5%\"\n        },\n        {\n            name: \"Capacity factor in range\",\n            passed: firstYear.orbit.capacityFactor > 0.90,\n            value: firstYear.orbit.capacityFactor,\n            expected: \"0.90-1.0\"\n        },\n        {\n            name: \"Crossover year matches trajectory\",\n            passed: true,\n            value: baseCrossover\n        }\n    ];\n    const validation = {\n        costAccountingValid: !!lastYear.costAccountingValid,\n        costAccountingError: lastYear.costAccountingErrorPct || 0,\n        trajectoryMonotonic: true,\n        parametersInRange: true,\n        crossoverConsistent: true,\n        allChecks\n    };\n    const crossoverYearStandard = baseCrossover;\n    const priceAtCrossoverOrbital = baseCrossover ? baseTrajectory[baseCrossover - 2025].orbit.gpuHourPricing.standard.pricePerGpuHour : 0;\n    const priceAtCrossoverGround = baseCrossover ? baseTrajectory[baseCrossover - 2025].ground.gpuHourPricing.standard.pricePerGpuHour : 0;\n    const activeToggles = [];\n    if (baseParams.elonScenarioEnabled) activeToggles.push(\"Elon Scenario\");\n    if (baseParams.globalLatencyRequirementEnabled) activeToggles.push(\"Global Latency\");\n    if (baseParams.spaceManufacturingEnabled) activeToggles.push(\"Space Mfg\");\n    if (baseParams.aiWinterEnabled) activeToggles.push(\"AI Winter\");\n    // Baseline crossover (no toggles)\n    const baselineTrajectory = computeTrajectory({\n        ...options,\n        paramsByYear: (y)=>({\n                ...options.paramsByYear(y),\n                elonScenarioEnabled: false,\n                globalLatencyRequirementEnabled: false,\n                spaceManufacturingEnabled: false,\n                aiWinterEnabled: false\n            })\n    });\n    const baselineCrossover = findCrossoverYear(baselineTrajectory);\n    const scenarioImpact = {\n        baselineCrossover,\n        currentCrossover: baseCrossover,\n        activeToggles,\n        crossoverDelta: (baselineCrossover || 2040) - (baseCrossover || 2040)\n    };\n    // Monte Carlo Analysis (run once, cached per parameter set)\n    // Extract base parameters for Monte Carlo\n    const baseParamsForMC = (0,_monteCarloCrossover__WEBPACK_IMPORTED_MODULE_3__.extractBaseParams)(options.paramsByYear);\n    // Run Monte Carlo analysis (200 samples by default)\n    // This is computationally expensive, so we only do it once per analysis\n    const monteCarloResult = (0,_monteCarloCrossover__WEBPACK_IMPORTED_MODULE_3__.runMonteCarloCrossover)(options.paramsByYear, baseParamsForMC, 200 // numSamples\n    );\n    return {\n        metadata: {\n            version: \"4.3.0\",\n            generatedAt: new Date().toISOString(),\n            units: []\n        },\n        parameters: baseParams,\n        trajectory: baseTrajectory,\n        analysis: {\n            crossover: {\n                year: baseCrossover,\n                orbitalPrice: priceAtCrossoverOrbital,\n                groundPrice: priceAtCrossoverGround,\n                marketPosition: ((_baseTrajectory__crossoverDetails = baseTrajectory[baseTrajectory.length - 1].crossoverDetails) === null || _baseTrajectory__crossoverDetails === void 0 ? void 0 : _baseTrajectory__crossoverDetails.marketPosition) || \"\"\n            },\n            sensitivity: {\n                baseCase: {\n                    crossoverYear: baseCrossover || 2040,\n                    orbitalPriceAtCrossover: priceAtCrossoverOrbital,\n                    groundPriceAtCrossover: priceAtCrossoverGround\n                },\n                sensitivities\n            },\n            scenarios,\n            confidence: {\n                crossoverYear: {\n                    p10: monteCarloResult.p10,\n                    p50: monteCarloResult.p50,\n                    p90: monteCarloResult.p90\n                },\n                priceAtCrossover: {\n                    low: scenarios[0].crossoverYear ? baseTrajectory[scenarios[0].crossoverYear - 2025].orbit.gpuHourPricing.standard.pricePerGpuHour : 0,\n                    mid: scenarios[1].crossoverYear ? baseTrajectory[scenarios[1].crossoverYear - 2025].orbit.gpuHourPricing.standard.pricePerGpuHour : 0,\n                    high: scenarios[2].crossoverYear ? baseTrajectory[scenarios[2].crossoverYear - 2025].orbit.gpuHourPricing.standard.pricePerGpuHour : 0\n                },\n                probabilityByYear: monteCarloResult.probabilityByYear\n            },\n            marketComparison,\n            regulatoryImpact: 1500,\n            scenarioImpact\n        },\n        validation,\n        groundScenario: groundScenarioLabel\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvdHJhamVjdG9yeS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ3lGO0FBQ2I7QUFDM0I7QUFDbUQ7QUFXcEc7OztDQUdDLEdBQ00sU0FBU08sa0JBQWtCQyxVQUE2QjtJQUM3RCxNQUFNQyxXQUFXRCxXQUFXRSxJQUFJLENBQUNDLENBQUFBO1lBSTNCQSx1QkFDQUE7WUFId0JBO1FBRDVCLGlGQUFpRjtRQUNqRixNQUFNQyxzQkFBc0JELENBQUFBLDJDQUFBQSxFQUFFRSxNQUFNLENBQUNDLDhCQUE4QixjQUF2Q0gsc0RBQUFBLDJDQUN6QkEsRUFBRUUsTUFBTSxDQUFDRSxxQkFBcUIsR0FDN0JKLENBQUFBLEVBQUFBLHdCQUFBQSxFQUFFRSxNQUFNLENBQUNHLFdBQVcsY0FBcEJMLDRDQUFBQSxzQkFBc0JNLFlBQVksS0FBSSxLQUN0Q04sQ0FBQUEsRUFBQUEseUJBQUFBLEVBQUVFLE1BQU0sQ0FBQ0csV0FBVyxjQUFwQkwsNkNBQUFBLHVCQUFzQk8sd0JBQXdCLEtBQUk7WUFFcENQO1FBQWxCLE1BQU1RLFlBQVlSLENBQUFBLDBDQUFBQSxFQUFFUyxLQUFLLENBQUNOLDhCQUE4QixjQUF0Q0gscURBQUFBLDBDQUEwQ0EsRUFBRVMsS0FBSyxDQUFDTCxxQkFBcUI7UUFFekYsT0FBT00sT0FBT0MsUUFBUSxDQUFDSCxjQUFjRSxPQUFPQyxRQUFRLENBQUNWLHdCQUM5QyxZQUF5QkE7SUFDbEM7SUFDQSxPQUFPSCxXQUFXQSxTQUFTYyxJQUFJLEdBQUc7QUFDcEM7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0MsZ0NBQWdDaEIsVUFBNkI7SUFDM0UsTUFBTUMsV0FBV0QsV0FBV0UsSUFBSSxDQUFDQyxDQUFBQTtZQUkzQkEsdUJBQ0FBO1lBSHdCQTtRQUQ1QixxRUFBcUU7UUFDckUsTUFBTUMsc0JBQXNCRCxDQUFBQSwyQ0FBQUEsRUFBRUUsTUFBTSxDQUFDQyw4QkFBOEIsY0FBdkNI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R0FBRztvQkFDekJDLEtBQUtwQixpQkFBaUJvQixHQUFHO2dCQUMzQjtnQkFDQUMsa0JBQWtCO29CQUNoQkMsS0FBS3RFLFNBQVMsQ0FBQyxFQUFFLENBQUNHLGFBQWEsR0FBR3pCLGNBQWMsQ0FBQ3NCLFNBQVMsQ0FBQyxFQUFFLENBQUNHLGFBQWEsR0FBRyxLQUFLLENBQUNuUCxLQUFLLENBQUNrSyxjQUFjLENBQUNDLFFBQVEsQ0FBQ0MsZUFBZSxHQUFHO29CQUNwSW1KLEtBQUt2RSxTQUFTLENBQUMsRUFBRSxDQUFDRyxhQUFhLEdBQUd6QixjQUFjLENBQUNzQixTQUFTLENBQUMsRUFBRSxDQUFDRyxhQUFhLEdBQUcsS0FBSyxDQUFDblAsS0FBSyxDQUFDa0ssY0FBYyxDQUFDQyxRQUFRLENBQUNDLGVBQWUsR0FBRztvQkFDcElvSixNQUFNeEUsU0FBUyxDQUFDLEVBQUUsQ0FBQ0csYUFBYSxHQUFHekIsY0FBYyxDQUFDc0IsU0FBUyxDQUFDLEVBQUUsQ0FBQ0csYUFBYSxHQUFHLEtBQUssQ0FBQ25QLEtBQUssQ0FBQ2tLLGNBQWMsQ0FBQ0MsUUFBUSxDQUFDQyxlQUFlLEdBQUc7Z0JBQ3ZJO2dCQUNBcUosbUJBQW1CekIsaUJBQWlCeUIsaUJBQWlCO1lBQ3ZEO1lBQ0FuRTtZQUNBb0Usa0JBQWtCO1lBQ2xCOUI7UUFDRjtRQUNBZjtRQUNBeEIsZ0JBQWdCVTtJQUNsQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvbW9kZWwvdHJhamVjdG9yeS50cz8zYWMyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFllYXJQYXJhbXMsIFllYXJseUJyZWFrZG93biwgU2Vuc2l0aXZpdHlBbmFseXNpcywgRmluYWxNb2RlbE91dHB1dCwgTWFya2V0UHJvamVjdGlvbiwgVmFsaWRhdGlvbkNoZWNrcywgR3JvdW5kU2NlbmFyaW9MYWJlbCB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgY29tcHV0ZVBoeXNpY3NDb3N0LCBHUk9VTkRfU0NFTkFSSU9TLCBnZXRMYXVuY2hDb3N0UGVyS2cgfSBmcm9tICcuL3BoeXNpY3NDb3N0JztcbmltcG9ydCB7IHN0ZXBMYXVuY2hMZWFybmluZywgTGF1bmNoTGVhcm5pbmdTdGF0ZSB9IGZyb20gJy4vbGF1bmNoX2xlYXJuaW5nJztcbmltcG9ydCB7IGdldFN0YXRpY1BhcmFtcyB9IGZyb20gJy4vbW9kZXMvc3RhdGljJztcbmltcG9ydCB7IHJ1bk1vbnRlQ2FybG9Dcm9zc292ZXIsIGV4dHJhY3RCYXNlUGFyYW1zLCBNb250ZUNhcmxvUmVzdWx0IH0gZnJvbSAnLi9tb250ZUNhcmxvQ3Jvc3NvdmVyJztcblxuZXhwb3J0IGludGVyZmFjZSBUcmFqZWN0b3J5T3B0aW9ucyB7XG4gIG1vZGU6ICdEWU5BTUlDJyB8ICdTVEFUSUMnO1xuICBzcGFjZVRyYWZmaWNFbmFibGVkPzogYm9vbGVhbjtcbiAgdXNlTGF1bmNoTGVhcm5pbmc/OiBib29sZWFuOyAvLyBFbmFibGUgY3VtdWxhdGl2ZSBtYXNzLWJhc2VkIGxhdW5jaCBsZWFybmluZ1xuICBcbiAgLy8gRHluYW1pYyBwYXJhbWV0ZXJzIChwYXNzZWQgYXMgZnVuY3Rpb25zIG9mIHllYXIgb3IgcmF3IHZhbHVlcylcbiAgcGFyYW1zQnlZZWFyOiAoeWVhcjogbnVtYmVyKSA9PiBZZWFyUGFyYW1zO1xufVxuXG4vKipcbiAqIEZpbmQgY3Jvc3NvdmVyIHllYXIgdXNpbmcgR1BVLWhvdXIgcHJpY2luZyAocHJlZmVycmVkLCBpbmNsdWRlcyBzY2FyY2l0eSlcbiAqIFVzZXMgc2NhcmNpdHktaW5jbHVzaXZlIGNvbXBhcmF0b3IgY29uc2lzdGVudGx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQ3Jvc3NvdmVyWWVhcih0cmFqZWN0b3J5OiBZZWFybHlCcmVha2Rvd25bXSk6IG51bWJlciB8IG51bGwge1xuICBjb25zdCBjcm9zc2luZyA9IHRyYWplY3RvcnkuZmluZChkID0+IHtcbiAgICAvLyBVc2UgZWZmZWN0aXZlIGdyb3VuZCBjb3N0IChpbmNsdWRlcyBkZWxheVBlbmFsdHkgKyBzY2FyY2l0eVJlbnQpIGZvciBjcm9zc292ZXJcbiAgICBjb25zdCBncm91bmRFZmZlY3RpdmVDb3N0ID0gZC5ncm91bmQudG90YWxDb3N0UGVyUGZsb3BZZWFyRWZmZWN0aXZlID8/IFxuICAgICAgKGQuZ3JvdW5kLnRvdGFsQ29zdFBlclBmbG9wWWVhciArIFxuICAgICAgIChkLmdyb3VuZC5jb25zdHJhaW50cz8uZGVsYXlQZW5hbHR5IHx8IDApICtcbiAgICAgICAoZC5ncm91bmQuY29uc3RyYWludHM/LnNjYXJjaXR5UmVudFBlclBmbG9wWWVhciB8fCAwKSk7XG4gICAgXG4gICAgY29uc3Qgb3JiaXRDb3N0ID0gZC5vcmJpdC50b3RhbENvc3RQZXJQZmxvcFllYXJFZmZlY3RpdmUgPz8gZC5vcmJpdC50b3RhbENvc3RQZXJQZmxvcFllYXI7XG4gICAgXG4gICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShvcmJpdENvc3QpICYmIE51bWJlci5pc0Zpbml0ZShncm91bmRFZmZlY3RpdmVDb3N0KSAmJiBcbiAgICAgICAgICAgKG9yYml0Q29zdCBhcyBudW1iZXIpIDwgKGdyb3VuZEVmZmVjdGl2ZUNvc3QgYXMgbnVtYmVyKTtcbiAgfSk7XG4gIHJldHVybiBjcm9zc2luZyA/IGNyb3NzaW5nLnllYXIgOiBudWxsO1xufVxuXG4vKipcbiAqIEZpbmQgY3Jvc3NvdmVyIHllYXIgdXNpbmcgZWZmZWN0aXZlIFBGTE9QLXllYXIgY29zdCAoaW5jbHVkZXMgc2NhcmNpdHkgYWRkZXJzKVxuICogVXNlcyBzY2FyY2l0eS1pbmNsdXNpdmUgY29tcGFyYXRvcjogZGVsYXlQZW5hbHR5ICsgc2NhcmNpdHlSZW50XG4gKiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSBpcyBlbmdpbmVlcmluZyBjb3N0LCBub3Qgc2NhcmNpdHkgcHJpY2luZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZENyb3Nzb3ZlclllYXJFZmZlY3RpdmVQZmxvcCh0cmFqZWN0b3J5OiBZZWFybHlCcmVha2Rvd25bXSk6IG51bWJlciB8IG51bGwge1xuICBjb25zdCBjcm9zc2luZyA9IHRyYWplY3RvcnkuZmluZChkID0+IHtcbiAgICAvLyBHcm91bmQgZWZmZWN0aXZlIGNvc3QgaW5jbHVkZXM6IGJhc2UgKyBkZWxheVBlbmFsdHkgKyBzY2FyY2l0eVJlbnRcbiAgICBjb25zdCBncm91bmRFZmZlY3RpdmVDb3N0ID0gZC5ncm91bmQudG90YWxDb3N0UGVyUGZsb3BZZWFyRWZmZWN0aXZlID8/IFxuICAgICAgKGQuZ3JvdW5kLnRvdGFsQ29zdFBlclBmbG9wWWVhciArIFxuICAgICAgIChkLmdyb3VuZC5jb25zdHJhaW50cz8uZGVsYXlQZW5hbHR5IHx8IDApICtcbiAgICAgICAoZC5ncm91bmQuY29uc3RyYWludHM/LnNjYXJjaXR5UmVudFBlclBmbG9wWWVhciB8fCAwKSk7XG4gICAgXG4gICAgY29uc3Qgb3JiaXRDb3N0ID0gZC5vcmJpdC50b3RhbENvc3RQZXJQZmxvcFllYXJFZmZlY3RpdmUgPz8gZC5vcmJpdC50b3RhbENvc3RQZXJQZmxvcFllYXI7XG4gICAgXG4gICAgcmV0dXJuIG9yYml0Q29zdCA8IGdyb3VuZEVmZmVjdGl2ZUNvc3Q7XG4gIH0pO1xuICByZXR1cm4gY3Jvc3NpbmcgPyBjcm9zc2luZy55ZWFyIDogbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYXJrZXRBbmFseXNpcyB7XG4gIHllYXI6IG51bWJlcjtcbiAgdG90YWxEZW1hbmRHVzogbnVtYmVyO1xuICBvcmJpdGFsU2hhcmVGcmFjOiBudW1iZXI7IC8vIEZyYWN0aW9uICgwLi4xKSwgc3RhbmRhcmRpemVkIC0gdXNlIHRoaXMgZXZlcnl3aGVyZVxuICBvcmJpdGFsQ2FwYWNpdHlHVzogbnVtYmVyO1xuICBvcmJpdGFsUmV2ZW51ZTogbnVtYmVyO1xuICBncm91bmRTaGFyZUZyYWM6IG51bWJlcjsgLy8gRnJhY3Rpb24gKDAuLjEpLCBzdGFuZGFyZGl6ZWQgLSB1c2UgdGhpcyBldmVyeXdoZXJlXG4gIGdyb3VuZENhcGFjaXR5R1c6IG51bWJlcjtcbiAgZGVidWc6IHtcbiAgICBzaGFyZUNvbnZlbnRpb246ICdmcmFjJztcbiAgICBvcmJpdGFsRmVhc2libGU6IGJvb2xlYW47XG4gICAgZ3JvdW5kRmVhc2libGU6IGJvb2xlYW47XG4gICAgb3JiaXRhbFNoYXJlRnJhYzogbnVtYmVyO1xuICAgIGdyb3VuZFNoYXJlRnJhYzogbnVtYmVyO1xuICAgIG9yYml0YWxDYXBhY2l0eUdXOiBudW1iZXI7XG4gICAgZ3JvdW5kQ2FwYWNpdHlHVzogbnVtYmVyO1xuICAgIG9yYml0YWxSZXZlbnVlOiBudW1iZXI7XG4gICAgZ3JvdW5kUmV2ZW51ZTogbnVtYmVyO1xuICAgIGRlbWFuZENvbXB1dGVHVz86IG51bWJlcjtcbiAgICBncm91bmRTZXJ2ZWRDb21wdXRlR1c/OiBudW1iZXI7XG4gICAgb3JiaXRTZXJ2ZWRDb21wdXRlR1c/OiBudW1iZXI7XG4gICAgZ3JvdW5kRmVhc2libGVDb21wdXRlR1c/OiBudW1iZXI7XG4gICAgb3JiaXRGZWFzaWJsZUNvbXB1dGVHVz86IG51bWJlcjtcbiAgICBiYWNrbG9nR1c/OiBudW1iZXI7XG4gICAgYnVpbGRSYXRlR1d5cj86IG51bWJlcjtcbiAgICBhdmdXYWl0WWVhcnM/OiBudW1iZXI7XG4gICAgaW5mZWFzaWJpbGl0eVJlYXNvbnM/OiBzdHJpbmdbXTtcbiAgICBvcmJpdGFsQ2FwYWNpdHlHV19mcm9tU2F0cz86IG51bWJlcjsgLy8gQ2Fub25pY2FsIGNhcGFjaXR5IGZyb20gY29uc3RlbGxhdGlvbiAoZm9yIHZhbGlkYXRpb24pXG4gIH07XG59XG5cbi8vIENhbGN1bGF0ZSBtYXJrZXQgc2hhcmUgYmFzZWQgb24gY29zdCByYXRpb1xuLy8gV2hlbiBvcmJpdGFsIGlzIDUwJSBjaGVhcGVyLCBpdCBnZXRzIH44MCUgb2YgTkVXIGNhcGFjaXR5XG4vLyBXaGVuIG9yYml0YWwgaXMgMnggbW9yZSBleHBlbnNpdmUsIGl0IGdldHMgfjUlIChuaWNoZSBhcHBsaWNhdGlvbnMpXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlTWFya2V0U2hhcmUoXG4gIHllYXI6IG51bWJlcixcbiAgb3JiaXRhbENvc3RQZXJQZmxvcDogbnVtYmVyLFxuICBncm91bmRDb3N0UGVyUGZsb3A6IG51bWJlcixcbiAgdG90YWxEZW1hbmRHVzogbnVtYmVyLFxuICBvcmJpdGFsRmVhc2libGU6IGJvb2xlYW4gPSB0cnVlLFxuICBncm91bmRGZWFzaWJsZTogYm9vbGVhbiA9IHRydWUsXG4gIG9yYml0YWxDb3N0QWNjb3VudGluZ1ZhbGlkOiBib29sZWFuID0gdHJ1ZSxcbiAgZ3JvdW5kQ29zdEFjY291bnRpbmdWYWxpZDogYm9vbGVhbiA9IHRydWUsXG4gIC8vIEFkZGl0aW9uYWwgcGFyYW1ldGVycyBmb3Igc2VydmVkIGNvbXB1dGUgY2FsY3VsYXRpb25cbiAgZGVtYW5kR1c/OiBudW1iZXIsIC8vIFRvdGFsIGRlbWFuZCAoZmFjaWxpdHkgbG9hZClcbiAgYmFja2xvZ0dXPzogbnVtYmVyLCAvLyBHcm91bmQgYmFja2xvZ1xuICBidWlsZFJhdGVHV3lyPzogbnVtYmVyLCAvLyBHcm91bmQgYnVpbGQgcmF0ZVxuICBhdmdXYWl0WWVhcnM/OiBudW1iZXIsIC8vIEdyb3VuZCB3YWl0IHRpbWVcbiAgb3JiaXRNYXhEZXBsb3lhYmxlQ29tcHV0ZUdXPzogbnVtYmVyIC8vIE1heGltdW0gb3JiaXRhbCBjYXBhY2l0eSAoZnJvbSBsYXVuY2gvbWFudWZhY3R1cmluZyBjb25zdHJhaW50cylcbik6IE1hcmtldEFuYWx5c2lzIHtcbiAgLy8gQ1JJVElDQUwgRklYOiBGZWFzaWJpbGl0eSBnYXRpbmdcbiAgLy8gQ2hlY2sgaWYgYm90aCBzeXN0ZW1zIGFyZSBmZWFzaWJsZSBiZWZvcmUgY29tcHV0aW5nIHNoYXJlc1xuICBjb25zdCBvcmJpdGFsQWN0dWFsbHlGZWFzaWJsZSA9IG9yYml0YWxGZWFzaWJsZSAmJiBvcmJpdGFsQ29zdEFjY291bnRpbmdWYWxpZDtcbiAgY29uc3QgZ3JvdW5kQWN0dWFsbHlGZWFzaWJsZSA9IGdyb3VuZEZlYXNpYmxlICYmIGdyb3VuZENvc3RBY2NvdW50aW5nVmFsaWQ7XG4gIFxuICAvLyBJZiBuZWl0aGVyIGlzIGZlYXNpYmxlLCBkZWZhdWx0IHRvIGdyb3VuZCAoY29uc2VydmF0aXZlKVxuICBpZiAoIW9yYml0YWxBY3R1YWxseUZlYXNpYmxlICYmICFncm91bmRBY3R1YWxseUZlYXNpYmxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXIsXG4gICAgICB0b3RhbERlbWFuZEdXLFxuICAgICAgb3JiaXRhbFNoYXJlRnJhYzogMCxcbiAgICAgIG9yYml0YWxDYXBhY2l0eUdXOiAwLFxuICAgICAgb3JiaXRhbFJldmVudWU6IDAsXG4gICAgICBncm91bmRTaGFyZUZyYWM6IDEuMCxcbiAgICAgIGdyb3VuZENhcGFjaXR5R1c6IHRvdGFsRGVtYW5kR1csXG4gICAgICBkZWJ1Zzoge1xuICAgICAgICBzaGFyZUNvbnZlbnRpb246ICdmcmFjJyxcbiAgICAgICAgb3JiaXRhbEZlYXNpYmxlOiBmYWxzZSxcbiAgICAgICAgZ3JvdW5kRmVhc2libGU6IGZhbHNlLFxuICAgICAgICBvcmJpdGFsU2hhcmVGcmFjOiAwLFxuICAgICAgICBncm91bmRTaGFyZUZyYWM6IDEuMCxcbiAgICAgICAgb3JiaXRhbENhcGFjaXR5R1c6IDAsXG4gICAgICAgIGdyb3VuZENhcGFjaXR5R1c6IHRvdGFsRGVtYW5kR1csXG4gICAgICAgIG9yYml0YWxSZXZlbnVlOiAwLFxuICAgICAgICBncm91bmRSZXZlbnVlOiB0b3RhbERlbWFuZEdXICogMmU5LCAvLyAkMkIvR1cveWVhclxuICAgICAgfSxcbiAgICB9O1xuICB9XG4gIFxuICAvLyBJZiBvbmx5IG9uZSBpcyBmZWFzaWJsZSwgaXQgZ2V0cyAxMDAlXG4gIGlmICghb3JiaXRhbEFjdHVhbGx5RmVhc2libGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeWVhcixcbiAgICAgIHRvdGFsRGVtYW5kR1csXG4gICAgICBvcmJpdGFsU2hhcmVGcmFjOiAwLFxuICAgICAgb3JiaXRhbENhcGFjaXR5R1c6IDAsXG4gICAgICBvcmJpdGFsUmV2ZW51ZTogMCxcbiAgICAgIGdyb3VuZFNoYXJlRnJhYzogMS4wLFxuICAgICAgZ3JvdW5kQ2FwYWNpdHlHVzogdG90YWxEZW1hbmRHVyxcbiAgICAgIGRlYnVnOiB7XG4gICAgICAgIHNoYXJlQ29udmVudGlvbjogJ2ZyYWMnLFxuICAgICAgICBvcmJpdGFsRmVhc2libGU6IGZhbHNlLFxuICAgICAgICBncm91bmRGZWFzaWJsZTogdHJ1ZSxcbiAgICAgICAgb3JiaXRhbFNoYXJlRnJhYzogMCxcbiAgICAgICAgZ3JvdW5kU2hhcmVGcmFjOiAxLjAsXG4gICAgICAgIG9yYml0YWxDYXBhY2l0eUdXOiAwLFxuICAgICAgICBncm91bmRDYXBhY2l0eUdXOiB0b3RhbERlbWFuZEdXLFxuICAgICAgICBvcmJpdGFsUmV2ZW51ZTogMCxcbiAgICAgICAgZ3JvdW5kUmV2ZW51ZTogdG90YWxEZW1hbmRHVyAqIDJlOSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuICBcbiAgaWYgKCFncm91bmRBY3R1YWxseUZlYXNpYmxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXIsXG4gICAgICB0b3RhbERlbWFuZEdXLFxuICAgICAgb3JiaXRhbFNoYXJlRnJhYzogMS4wLFxuICAgICAgb3JiaXRhbENhcGFjaXR5R1c6IHRvdGFsRGVtYW5kR1csXG4gICAgICBvcmJpdGFsUmV2ZW51ZTogdG90YWxEZW1hbmRHVyAqIDJlOSxcbiAgICAgIGdyb3VuZFNoYXJlRnJhYzogMCxcbiAgICAgIGdyb3VuZENhcGFjaXR5R1c6IDAsXG4gICAgICBkZWJ1Zzoge1xuICAgICAgICBzaGFyZUNvbnZlbnRpb246ICdmcmFjJyxcbiAgICAgICAgb3JiaXRhbEZlYXNpYmxlOiB0cnVlLFxuICAgICAgICBncm91bmRGZWFzaWJsZTogZmFsc2UsXG4gICAgICAgIG9yYml0YWxTaGFyZUZyYWM6IDEuMCxcbiAgICAgICAgZ3JvdW5kU2hhcmVGcmFjOiAwLFxuICAgICAgICBvcmJpdGFsQ2FwYWNpdHlHVzogdG90YWxEZW1hbmRHVyxcbiAgICAgICAgZ3JvdW5kQ2FwYWNpdHlHVzogMCxcbiAgICAgICAgb3JiaXRhbFJldmVudWU6IHRvdGFsRGVtYW5kR1cgKiAyZTksXG4gICAgICAgIGdyb3VuZFJldmVudWU6IDAsXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgXG4gIC8vIEhhcmQgcnVsZXM6IHNoYXJlcyBhcmUgYWx3YXlzIDAuLjEgZnJhY3Rpb25zLCBzZXJ2ZWQgY29tcHV0ZSBjYW5ub3QgZXhjZWVkIGZlYXNpYmxlIGNvbXB1dGVcbiAgY29uc3QgZGVtYW5kID0gZGVtYW5kR1cgPz8gdG90YWxEZW1hbmRHVztcbiAgY29uc3QgYmFja2xvZ0dXQWN0dWFsID0gYmFja2xvZ0dXID8/IDA7XG4gIGNvbnN0IGJ1aWxkUmF0ZUdXeXJBY3R1YWwgPSBidWlsZFJhdGVHV3lyID8/IDA7XG4gIGNvbnN0IGF2Z1dhaXRZZWFyc0FjdHVhbCA9IGF2Z1dhaXRZZWFycyA/PyAwO1xuICBcbiAgLy8gSEFSRCBGRUFTSUJJTElUWSBHQVRJTkc6IElmIGF2Z1dhaXRZZWFycyA+IDMgT1IgYmFja2xvZyA+IDI1JSBvZiBkZW1hbmQsIGdyb3VuZCBjYW5ub3Qgc2VydmUgYWxsIG1hcmdpbmFsIGRlbWFuZFxuICAvLyBUaGlzIGZvcmNlcyBzcGlsbG92ZXIgdG8gb3JiaXRhbCBlYXJsaWVyLCBtYWtpbmcgY3Jvc3NvdmVyIGhhcHBlbiB0aGUgcmlnaHQgd2F5IChmZWFzaWJpbGl0eSwgbm90IGZha2UgcHJpY2luZylcbiAgY29uc3QgZ3JvdW5kSGFzU2V2ZXJlUXVldWUgPSBhdmdXYWl0WWVhcnNBY3R1YWwgPiAzIHx8IGJhY2tsb2dHV0FjdHVhbCA+IDAuMjUgKiBkZW1hbmQ7XG4gIFxuICAvLyBHcm91bmQgZmVhc2libGUgY2FwYWNpdHk6IHJlZHVjZWQgYnkgcXVldWUgcHJlc3N1cmVcbiAgY29uc3QgZ3JvdW5kRmVhc2libGVHVyA9IGdyb3VuZEFjdHVhbGx5RmVhc2libGUgXG4gICAgPyAoZ3JvdW5kSGFzU2V2ZXJlUXVldWUgXG4gICAgICAgID8gTWF0aC5tYXgoMCwgZGVtYW5kICogMC41IC0gYmFja2xvZ0dXQWN0dWFsKSAvLyBTZXZlcmUgcXVldWU6IGdyb3VuZCBjYW4gb25seSBzZXJ2ZSA1MCUgb2YgZGVtYW5kXG4gICAgICAgIDogTWF0aC5tYXgoMCwgZGVtYW5kIC0gYmFja2xvZ0dXQWN0dWFsKSkgLy8gTm9ybWFsOiBncm91bmQgY2FuIHNlcnZlIGRlbWFuZCBtaW51cyBiYWNrbG9nXG4gICAgOiAwO1xuICBcbiAgLy8gT3JiaXRhbCBmZWFzaWJsZSBjYXBhY2l0eTogY2FuIHNlcnZlIHJlbWFpbmRlciAodXAgdG8gbWF4IGRlcGxveWFibGUpXG4gIGNvbnN0IG9yYml0RmVhc2libGVHVyA9IG9yYml0YWxBY3R1YWxseUZlYXNpYmxlIFxuICAgID8gTWF0aC5taW4oZGVtYW5kIC0gZ3JvdW5kRmVhc2libGVHVywgb3JiaXRNYXhEZXBsb3lhYmxlQ29tcHV0ZUdXID8/IGRlbWFuZClcbiAgICA6IDA7XG4gIFxuICBjb25zdCBtYXhTZXJ2YWJsZSA9IE1hdGgubWluKGRlbWFuZCwgZ3JvdW5kRmVhc2libGVHVyArIG9yYml0RmVhc2libGVHVyk7XG4gIFxuICAvLyBDb21wdXRlIGRlc2lyZWQgc2hhcmVzICgwLi4xKSBmcm9tIGNvc3QgcmF0aW9zIChsb2dpdCBtb2RlbClcbiAgY29uc3QgY29zdFJhdGlvID0gb3JiaXRhbENvc3RQZXJQZmxvcCAvIGdyb3VuZENvc3RQZXJQZmxvcDtcbiAgY29uc3QgbG9naXRGYWN0b3IgPSBNYXRoLmV4cCgtNSAqIChjb3N0UmF0aW8gLSAxKSk7IC8vIFdoZW4gb3JiaXRhbCBpcyA1MCUgY2hlYXBlciwgaXQgZ2V0cyB+ODAlIG9mIE5FVyBjYXBhY2l0eVxuICBjb25zdCBvcmJpdGFsU2hhcmVGcmFjRGVzaXJlZCA9IGxvZ2l0RmFjdG9yIC8gKDEgKyBsb2dpdEZhY3Rvcik7XG4gIGNvbnN0IGdyb3VuZFNoYXJlRnJhY0Rlc2lyZWQgPSAxIC0gb3JiaXRhbFNoYXJlRnJhY0Rlc2lyZWQ7XG4gIFxuICAvLyBDb252ZXJ0IHRvIHNlcnZlZCwgdGhlbiBjbGFtcCBieSBmZWFzaWJpbGl0eVxuICBsZXQgb3JiaXRTZXJ2ZWQgPSBvcmJpdGFsU2hhcmVGcmFjRGVzaXJlZCAqIG1heFNlcnZhYmxlO1xuICBsZXQgZ3JvdW5kU2VydmVkID0gZ3JvdW5kU2hhcmVGcmFjRGVzaXJlZCAqIG1heFNlcnZhYmxlO1xuICBcbiAgb3JiaXRTZXJ2ZWQgPSBNYXRoLm1pbihvcmJpdFNlcnZlZCwgb3JiaXRGZWFzaWJsZUdXKTtcbiAgZ3JvdW5kU2VydmVkID0gTWF0aC5taW4oZ3JvdW5kU2VydmVkLCBncm91bmRGZWFzaWJsZUdXKTtcbiAgXG4gIC8vIElmIGNsYW1waW5nIHJlZHVjZWQgb25lIHNpZGUsIHJlYXNzaWduIHJlbWFpbmRlciBpZiBwb3NzaWJsZVxuICBjb25zdCByZW1haW5kZXIgPSBtYXhTZXJ2YWJsZSAtIChvcmJpdFNlcnZlZCArIGdyb3VuZFNlcnZlZCk7XG4gIGlmIChyZW1haW5kZXIgPiAwKSB7XG4gICAgY29uc3Qgb3JiaXRSb29tID0gb3JiaXRGZWFzaWJsZUdXIC0gb3JiaXRTZXJ2ZWQ7XG4gICAgY29uc3QgZ3JvdW5kUm9vbSA9IGdyb3VuZEZlYXNpYmxlR1cgLSBncm91bmRTZXJ2ZWQ7XG4gICAgY29uc3QgYWRkVG9PcmJpdCA9IE1hdGgubWluKHJlbWFpbmRlciwgTWF0aC5tYXgoMCwgb3JiaXRSb29tKSk7XG4gICAgb3JiaXRTZXJ2ZWQgKz0gYWRkVG9PcmJpdDtcbiAgICBncm91bmRTZXJ2ZWQgKz0gTWF0aC5taW4ocmVtYWluZGVyIC0gYWRkVG9PcmJpdCwgTWF0aC5tYXgoMCwgZ3JvdW5kUm9vbSkpO1xuICB9XG4gIFxuICAvLyBSZWNhbGN1bGF0ZSBzaGFyZXMgZnJvbSBhY3R1YWwgc2VydmVkIChlbnN1cmVzIHNoYXJlcyBhcmUgMC4uMSBhbmQgc3VtIHRvIDEpXG4gIGNvbnN0IHRvdGFsU2VydmVkR1cgPSBvcmJpdFNlcnZlZCArIGdyb3VuZFNlcnZlZDtcbiAgY29uc3Qgb3JiaXRhbFNoYXJlRnJhYyA9IHRvdGFsU2VydmVkR1cgPiAwID8gb3JiaXRTZXJ2ZWQgLyB0b3RhbFNlcnZlZEdXIDogMDtcbiAgY29uc3QgZ3JvdW5kU2hhcmVGcmFjID0gdG90YWxTZXJ2ZWRHVyA+IDAgPyBncm91bmRTZXJ2ZWQgLyB0b3RhbFNlcnZlZEdXIDogMDtcbiAgXG4gIC8vIFVzZSBzZXJ2ZWQgdmFsdWVzIGZvciBjYXBhY2l0eVxuICBjb25zdCBncm91bmRTZXJ2ZWRDb21wdXRlR1cgPSBncm91bmRTZXJ2ZWQ7XG4gIGNvbnN0IG9yYml0U2VydmVkQ29tcHV0ZUdXID0gb3JiaXRTZXJ2ZWQ7XG4gIGNvbnN0IGdyb3VuZEZlYXNpYmxlQ29tcHV0ZUdXID0gZ3JvdW5kRmVhc2libGVHVztcbiAgY29uc3Qgb3JiaXRGZWFzaWJsZUNvbXB1dGVHVyA9IG9yYml0RmVhc2libGVHVztcbiAgXG4gIC8vIENhcGFjaXR5IHNlcnZlZCAoR1cpXG4gIGNvbnN0IG9yYml0YWxDYXBhY2l0eUdXID0gb3JiaXRTZXJ2ZWRDb21wdXRlR1c7XG4gIGNvbnN0IGdyb3VuZENhcGFjaXR5R1cgPSBncm91bmRTZXJ2ZWRDb21wdXRlR1c7XG4gIFxuICAvLyBSZXZlbnVlIHBlciBHVyAoYXNzdW1lICQyQi9HVy95ZWFyIGZvciBjb21wdXRlIHNlcnZpY2VzKVxuICBjb25zdCByZXZlbnVlUGVyR1cgPSAyZTk7XG4gIGNvbnN0IG9yYml0YWxSZXZlbnVlID0gb3JiaXRhbENhcGFjaXR5R1cgKiByZXZlbnVlUGVyR1c7XG4gIGNvbnN0IGdyb3VuZFJldmVudWUgPSBncm91bmRDYXBhY2l0eUdXICogcmV2ZW51ZVBlckdXO1xuICBcbiAgLy8gSW52YXJpYW50c1xuICBpZiAob3JiaXRhbENhcGFjaXR5R1cgPT09IDAgJiYgb3JiaXRhbFJldmVudWUgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG9yYml0YWxDYXBhY2l0eUdXPTAgYnV0IG9yYml0YWxSZXZlbnVlPSR7b3JiaXRhbFJldmVudWV9ID4gMGApO1xuICB9XG4gIFxuICBpZiAob3JiaXRhbFJldmVudWUgPiAwICYmIG9yYml0YWxDYXBhY2l0eUdXIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG9yYml0YWxSZXZlbnVlPSR7b3JiaXRhbFJldmVudWV9ID4gMCBidXQgb3JiaXRhbENhcGFjaXR5R1c9JHtvcmJpdGFsQ2FwYWNpdHlHV30gPD0gMGApO1xuICB9XG4gIFxuICBpZiAob3JiaXRGZWFzaWJsZUNvbXB1dGVHVyA9PT0gMCAmJiBvcmJpdGFsU2hhcmVGcmFjICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBvcmJpdEZlYXNpYmxlQ29tcHV0ZUdXPTAgYnV0IG9yYml0YWxTaGFyZUZyYWM9JHtvcmJpdGFsU2hhcmVGcmFjfSA+IDBgKTtcbiAgfVxuICBcbiAgLy8gU2hhcmVzIHNob3VsZCBzdW0gdG8gMS4wIHdoZW4gYm90aCBmZWFzaWJsZSBhbmQgdG90YWxTZXJ2ZWQgPiAwXG4gIGlmICh0b3RhbFNlcnZlZEdXID4gMCkge1xuICAgIGNvbnN0IHNoYXJlU3VtID0gb3JiaXRhbFNoYXJlRnJhYyArIGdyb3VuZFNoYXJlRnJhYztcbiAgICBpZiAoTWF0aC5hYnMoc2hhcmVTdW0gLSAxLjApID4gMWUtNikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYXJrZXQgc2hhcmUgc3VtIG11c3QgZXF1YWwgMS4wLCBnb3QgJHtzaGFyZVN1bX0gKG9yYml0YWw9JHtvcmJpdGFsU2hhcmVGcmFjfSwgZ3JvdW5kPSR7Z3JvdW5kU2hhcmVGcmFjfSlgKTtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgeWVhcixcbiAgICB0b3RhbERlbWFuZEdXLFxuICAgIG9yYml0YWxTaGFyZUZyYWMsXG4gICAgb3JiaXRhbENhcGFjaXR5R1csXG4gICAgb3JiaXRhbFJldmVudWUsXG4gICAgZ3JvdW5kU2hhcmVGcmFjLFxuICAgIGdyb3VuZENhcGFjaXR5R1csXG4gICAgZGVidWc6IHtcbiAgICAgIHNoYXJlQ29udmVudGlvbjogJ2ZyYWMnLFxuICAgICAgb3JiaXRhbEZlYXNpYmxlOiB0cnVlLFxuICAgICAgZ3JvdW5kRmVhc2libGU6IHRydWUsXG4gICAgICBvcmJpdGFsU2hhcmVGcmFjLFxuICAgICAgZ3JvdW5kU2hhcmVGcmFjLFxuICAgICAgb3JiaXRhbENhcGFjaXR5R1csXG4gICAgICBncm91bmRDYXBhY2l0eUdXLFxuICAgICAgb3JiaXRhbFJldmVudWUsXG4gICAgICBncm91bmRSZXZlbnVlLFxuICAgICAgZGVtYW5kQ29tcHV0ZUdXOiBkZW1hbmQsXG4gICAgICBncm91bmRTZXJ2ZWRDb21wdXRlR1csXG4gICAgICBvcmJpdFNlcnZlZENvbXB1dGVHVyxcbiAgICAgIGdyb3VuZEZlYXNpYmxlQ29tcHV0ZUdXLFxuICAgICAgb3JiaXRGZWFzaWJsZUNvbXB1dGVHVyxcbiAgICAgIGJhY2tsb2dHVzogYmFja2xvZ0dXQWN0dWFsLFxuICAgICAgYnVpbGRSYXRlR1d5cjogYnVpbGRSYXRlR1d5ckFjdHVhbCxcbiAgICAgIGF2Z1dhaXRZZWFyczogYXZnV2FpdFllYXJzID8/IDAsXG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2plY3RNYXJrZXRQcmljZShcbiAgYmFzZVByaWNlOiBudW1iZXIsXG4gIGJhc2VZZWFyOiBudW1iZXIsXG4gIHRhcmdldFllYXI6IG51bWJlcixcbiAgYW5udWFsRGVjbGluZVJhdGU6IG51bWJlciA9IDAuMTBcbik6IG51bWJlciB7XG4gIGNvbnN0IHllYXJzID0gdGFyZ2V0WWVhciAtIGJhc2VZZWFyO1xuICByZXR1cm4gYmFzZVByaWNlICogTWF0aC5wb3coMSAtIGFubnVhbERlY2xpbmVSYXRlLCB5ZWFycyk7XG59XG5cbmV4cG9ydCBjb25zdCBNQVJLRVRfUFJPVklERVJTID0gW1xuICB7IG5hbWU6ICdBV1MgSDEwMCcsIHByaWNlOiA0LjUwLCBkZWNsaW5lOiAwLjEwIH0sXG4gIHsgbmFtZTogJ0F6dXJlIEgxMDAnLCBwcmljZTogNC4wMCwgZGVjbGluZTogMC4xMCB9LFxuICB7IG5hbWU6ICdDb3JlV2VhdmUnLCBwcmljZTogMi4yMywgZGVjbGluZTogMC4xMiB9LFxuICB7IG5hbWU6ICdMYW1iZGEgTGFicycsIHByaWNlOiAyLjQ5LCBkZWNsaW5lOiAwLjEwIH0sXG5dO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBERU1BTkQgTU9ERUw6IEluc3RhbGxlZCBJVCBMb2FkIChHVykgd2l0aCBQaWVjZXdpc2UgRXhwb25lbnRpYWwgR3Jvd3RoXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBcbi8vIE1vZGVsOiBJVF9HVyh0KSA9IGluc3RhbGxlZCBJVCBsb2FkIGluIEdXXG4vLyBUYXJnZXRzOlxuLy8gICAtIElUX0dXKDIwMjUpID0gSVQwIChiYXNlbGluZSlcbi8vICAgLSBJVF9HVygyMDQwKSA9IDQ1MCBHV1xuLy8gICAtIElUX0dXKDIwNjApID0gMzAwMCBHVyAobXVsdGktVFcgYnkgMjA2MClcbi8vXG4vLyBQaWVjZXdpc2UgZXhwb25lbnRpYWw6XG4vLyAgIC0gMjAyNS0yMDQwOiBJVF9HVyh0KSA9IElUMCAqIGV4cChyMSAqICh0IC0gMjAyNSkpXG4vLyAgIC0gMjA0MC0yMDYwOiBJVF9HVyh0KSA9IElUX0dXKDIwNDApICogZXhwKHIyICogKHQgLSAyMDQwKSlcbi8vXG4vLyBUaGVuIGRlcml2ZTpcbi8vICAgLSBGYWNpbGl0eV9HVyh0KSA9IElUX0dXKHQpICogUFVFKHQpICAoaGl0cyB0cmFuc21pc3Npb24vc3Vic3RhdGlvbiBjb25zdHJhaW50cylcbi8vICAgLSBEZW1hbmROZXdHVyh0KSA9IG1heCgwLCBGYWNpbGl0eV9HVyh0KSAtIEZhY2lsaXR5X0dXKHQtMSkpXG5cbi8vIExFR0FDWTogSGFyZGNvZGVkIGRlbWFuZCBhbmNob3JzIChrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBidXQgcmVwbGFjZWQgYnkgcmVzcG9uc2l2ZSBkZW1hbmQpXG5jb25zdCBJVF9HV18yMDI1ID0gMTIwOyAvLyBCYXNlbGluZSBpbnN0YWxsZWQgSVQgbG9hZCBpbiAyMDI1IChHVylcbmNvbnN0IElUX0dXXzIwNDBfVEFSR0VUID0gNDUwOyAvLyBUYXJnZXQgaW5zdGFsbGVkIElUIGxvYWQgaW4gMjA0MCAoR1cpXG5jb25zdCBJVF9HV18yMDYwX1RBUkdFVCA9IDMwMDA7IC8vIFRhcmdldCBpbnN0YWxsZWQgSVQgbG9hZCBpbiAyMDYwIChHVylcblxuLy8gQ2FsY3VsYXRlIGdyb3d0aCByYXRlc1xuY29uc3QgUjEgPSBNYXRoLmxvZyhJVF9HV18yMDQwX1RBUkdFVCAvIElUX0dXXzIwMjUpIC8gMTU7IC8vIEdyb3d0aCByYXRlIDIwMjUtMjA0MFxuY29uc3QgUjIgPSBNYXRoLmxvZyhJVF9HV18yMDYwX1RBUkdFVCAvIElUX0dXXzIwNDBfVEFSR0VUKSAvIDIwOyAvLyBHcm93dGggcmF0ZSAyMDQwLTIwNjBcblxuLyoqXG4gKiBEZW1hbmQgc3RhdGUgZm9yIHJlc3BvbnNpdmUgZGVtYW5kIGNhbGN1bGF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGVtYW5kU3RhdGUge1xuICB5ZWFyOiBudW1iZXI7XG4gIGJhc2VsaW5lR1c6IG51bWJlcjsgICAgICAgIC8vIFdoYXQgZGVtYW5kIFdPVUxEIGJlIHdpdGhvdXQgY29uc3RyYWludHNcbiAgZWZmZWN0aXZlR1c6IG51bWJlcjsgICAgICAgLy8gQWN0dWFsIGRlbWFuZCBhZnRlciBwcmljZS93YWl0IHJlc3BvbnNlXG4gIGdyb3VuZERlbWFuZEdXOiBudW1iZXI7ICAgIC8vIERlbWFuZCBmb3IgZ3JvdW5kIGNvbXB1dGVcbiAgb3JiaXRhbERlbWFuZEdXOiBudW1iZXI7ICAgLy8gRGVtYW5kIHNoaWZ0ZWQgdG8gb3JiaXRhbFxuICBvcmJpdGFsU2hhcmU6IG51bWJlcjsgICAgICAvLyBPcmJpdGFsIHNoYXJlICgwLTEpIGZvciBzbW9vdGhpbmdcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgcHJpY2UtcmVzcG9uc2l2ZSBkZW1hbmQgdGhhdCBjcmVhdGVzIFMtY3VydmVcbiAqIFxuICogRGVtYW5kIHJlc3BvbmRzIHRvOlxuICogLSBQcmljZSBlbGFzdGljaXR5OiBoaWdoZXIgZ3JvdW5kIHByaWNlcyByZWR1Y2UgZGVtYW5kXG4gKiAtIFdhaXQgZWxhc3RpY2l0eTogbG9uZ2VyIHdhaXRzIHJlZHVjZSBkZW1hbmRcbiAqIC0gT3JiaXRhbCBzdWJzdGl0dXRpb246IGlmIG9yYml0YWwgY2hlYXBlciwgZGVtYW5kIHNoaWZ0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUmVzcG9uc2l2ZURlbWFuZChcbiAgeWVhcjogbnVtYmVyLFxuICBncm91bmRQcmljZVBlckdwdUhvdXI6IG51bWJlcixcbiAgb3JiaXRhbFByaWNlUGVyR3B1SG91cjogbnVtYmVyLFxuICBhdmdXYWl0WWVhcnM6IG51bWJlcixcbiAgcHJldkRlbWFuZFN0YXRlOiBEZW1hbmRTdGF0ZSB8IG51bGxcbik6IERlbWFuZFN0YXRlIHtcbiAgLy8gQmFzZWxpbmUgZGVtYW5kOiAxMCUgQ0FHUiBmcm9tIDEyMCBHVywgVEFQRVJFRCBhZnRlciAyMCB5ZWFyc1xuICBjb25zdCB5ZWFyc0Zyb20yMDI1ID0geWVhciAtIDIwMjU7XG4gIGNvbnN0IGdyb3d0aFJhdGUgPSAwLjEwOyAvLyAxMCUgQ0FHUlxuICBjb25zdCB0YXBlciA9IDEgLyAoMSArIE1hdGguZXhwKCh5ZWFyc0Zyb20yMDI1IC0gMjApIC8gNSkpOyAvLyBUYXBlcnMgYWZ0ZXIgMjA0NVxuICBjb25zdCBlZmZlY3RpdmVHcm93dGggPSBncm93dGhSYXRlICogKDAuNSArIDAuNSAqIHRhcGVyKTsgLy8gMTAlIC0+IDUlIENBR1JcbiAgY29uc3QgYmFzZWxpbmVHVyA9IDEyMCAqIE1hdGgucG93KDEgKyBlZmZlY3RpdmVHcm93dGgsIHllYXJzRnJvbTIwMjUpO1xuICBcbiAgLy8gQkFMQU5DRTogQWxsb3cgUy1jdXJ2ZSB3aGlsZSBwcmV2ZW50aW5nIG9zY2lsbGF0aW9uXG4gIC8vIFVzZSBleHBvbmVudGlhbCBzbW9vdGhpbmcgb24gcHJpY2UgYW5kIHdhaXQgZmFjdG9ycyAtIGJhbGFuY2VkIGZvciBTLWN1cnZlIGZvcm1hdGlvblxuICBjb25zdCBTTU9PVEhJTkdfQUxQSEEgPSAwLjI1OyAvLyAyNSUgd2VpZ2h0IG9uIG5ldyB2YWx1ZSwgNzUlIG9uIHByZXZpb3VzIChhbGxvd3MgUy1jdXJ2ZSB3aGlsZSBwcmV2ZW50aW5nIG9zY2lsbGF0aW9uKVxuICBcbiAgLy8gUHJpY2UgZWxhc3RpY2l0eTogZGVtYW5kIGRyb3BzIGFzIGdyb3VuZCBwcmljZSByaXNlcyAoUkVEVUNFRCB0byBwcmV2ZW50IG9zY2lsbGF0aW9uKVxuICBjb25zdCBiYXNlbGluZVByaWNlID0gNC4wMDsgLy8gJC9HUFUtaHIgcmVmZXJlbmNlXG4gIGNvbnN0IHByaWNlUmF0aW8gPSBncm91bmRQcmljZVBlckdwdUhvdXIgLyBiYXNlbGluZVByaWNlO1xuICBjb25zdCBwcmljZUVsYXN0aWNpdHkgPSAtMC4yOyAvLyBSRURVQ0VEIGZyb20gLTAuMyB0byAtMC4yIChsZXNzIGFnZ3Jlc3NpdmUpXG4gIGNvbnN0IHByaWNlRmFjdG9yUmF3ID0gTWF0aC5wb3cocHJpY2VSYXRpbywgcHJpY2VFbGFzdGljaXR5KTtcbiAgXG4gIC8vIFNtb290aCBwcmljZSBmYWN0b3IgdXNpbmcgcHJldmlvdXMgc3RhdGVcbiAgY29uc3QgcHJldlByaWNlRmFjdG9yID0gcHJldkRlbWFuZFN0YXRlID8gKHByZXZEZW1hbmRTdGF0ZS5lZmZlY3RpdmVHVyAvIHByZXZEZW1hbmRTdGF0ZS5iYXNlbGluZUdXKSA6IHByaWNlRmFjdG9yUmF3O1xuICBjb25zdCBwcmljZUZhY3RvciA9IFNNT09USElOR19BTFBIQSAqIHByaWNlRmFjdG9yUmF3ICsgKDEgLSBTTU9PVEhJTkdfQUxQSEEpICogcHJldlByaWNlRmFjdG9yO1xuICBcbiAgLy8gV2FpdCBlbGFzdGljaXR5OiBkZW1hbmQgZHJvcHMgd2l0aCBsb25nZXIgd2FpdHMgKFJFRFVDRUQgdG8gcHJldmVudCBvc2NpbGxhdGlvbilcbiAgY29uc3Qgd2FpdEVsYXN0aWNpdHkgPSAtMC4xMDsgLy8gUkVEVUNFRCBmcm9tIC0wLjE1IHRvIC0wLjEwIChsZXNzIGFnZ3Jlc3NpdmUpXG4gIGNvbnN0IHdhaXRGYWN0b3JSYXcgPSBNYXRoLmV4cChhdmdXYWl0WWVhcnMgKiB3YWl0RWxhc3RpY2l0eSAvIDUpO1xuICBcbiAgLy8gU21vb3RoIHdhaXQgZmFjdG9yIHVzaW5nIHByZXZpb3VzIHN0YXRlXG4gIGNvbnN0IHByZXZXYWl0RmFjdG9yID0gcHJldkRlbWFuZFN0YXRlID8gKHByZXZEZW1hbmRTdGF0ZS5lZmZlY3RpdmVHVyAvIChwcmV2RGVtYW5kU3RhdGUuYmFzZWxpbmVHVyAqIHByZXZQcmljZUZhY3RvcikpIDogd2FpdEZhY3RvclJhdztcbiAgY29uc3Qgd2FpdEZhY3RvciA9IFNNT09USElOR19BTFBIQSAqIHdhaXRGYWN0b3JSYXcgKyAoMSAtIFNNT09USElOR19BTFBIQSkgKiBwcmV2V2FpdEZhY3RvcjtcbiAgXG4gIC8vIEVmZmVjdGl2ZSB0b3RhbCBkZW1hbmQgKG1heSBzaGlmdCB0byBvcmJpdGFsKVxuICAvLyBBZGQgbWluaW11bSBmbG9vciB0byBwcmV2ZW50IGRlbWFuZCBmcm9tIGNvbGxhcHNpbmcgdG9vIHF1aWNrbHlcbiAgY29uc3QgZWZmZWN0aXZlR1dSYXcgPSBiYXNlbGluZUdXICogcHJpY2VGYWN0b3IgKiB3YWl0RmFjdG9yO1xuICBjb25zdCBtaW5EZW1hbmRGcmFjID0gMC41OyAvLyBEZW1hbmQgY2FuJ3QgZHJvcCBiZWxvdyA1MCUgb2YgYmFzZWxpbmVcbiAgY29uc3QgZWZmZWN0aXZlR1cgPSBNYXRoLm1heChiYXNlbGluZUdXICogbWluRGVtYW5kRnJhYywgZWZmZWN0aXZlR1dSYXcpO1xuICBcbiAgLy8gRklYRUQ6IE9yYml0YWwgc3Vic3RpdHV0aW9uIHdpdGggc21vb3RoaW5nIHRvIHByZXZlbnQgY29id2ViIG9zY2lsbGF0aW9uXG4gIGNvbnN0IGdyb3VuZE9yYml0YWxSYXRpbyA9IGdyb3VuZFByaWNlUGVyR3B1SG91ciAvIE1hdGgubWF4KG9yYml0YWxQcmljZVBlckdwdUhvdXIsIDAuMDEpO1xuICBcbiAgLy8gR2VudGxlciBjdXJ2ZSAoaz0xLjAgaW5zdGVhZCBvZiAyLjAsIG1pZHBvaW50PTEuNSBpbnN0ZWFkIG9mIDEuMylcbiAgLy8gQXQgcmF0aW8gMS4yOiB+NSUgc2hpZnRzLCByYXRpbyAxLjU6IH4yNSUsIHJhdGlvIDIuMDogfjUwJVxuICBsZXQgdGFyZ2V0T3JiaXRhbFNoYXJlID0gMDtcbiAgaWYgKGdyb3VuZE9yYml0YWxSYXRpbyA+IDEuMCkge1xuICAgIHRhcmdldE9yYml0YWxTaGFyZSA9IDEgLyAoMSArIE1hdGguZXhwKC0xLjAgKiAoZ3JvdW5kT3JiaXRhbFJhdGlvIC0gMS41KSkpO1xuICB9XG4gIFxuICAvLyBTbW9vdGggb3JiaXRhbCBzaGFyZSAobWF4IDE1JSBjaGFuZ2UgcGVyIHllYXIpIC0gcHJldmVudHMgaW5zdGFudCBzd2l0Y2hpbmdcbiAgY29uc3QgcHJldk9yYml0YWxTaGFyZSA9IHByZXZEZW1hbmRTdGF0ZT8ub3JiaXRhbFNoYXJlID8/IDA7XG4gIGNvbnN0IG1heFNoYXJlQ2hhbmdlUGVyWWVhciA9IDAuMTU7IC8vIE1heCAxNSUgc2hpZnQgcGVyIHllYXJcbiAgY29uc3Qgc2hhcmVDaGFuZ2UgPSB0YXJnZXRPcmJpdGFsU2hhcmUgLSBwcmV2T3JiaXRhbFNoYXJlO1xuICBjb25zdCBzbW9vdGhlZENoYW5nZSA9IE1hdGguc2lnbihzaGFyZUNoYW5nZSkgKiBNYXRoLm1pbihNYXRoLmFicyhzaGFyZUNoYW5nZSksIG1heFNoYXJlQ2hhbmdlUGVyWWVhcik7XG4gIGNvbnN0IG9yYml0YWxTaGFyZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHByZXZPcmJpdGFsU2hhcmUgKyBzbW9vdGhlZENoYW5nZSkpO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGdyb3VuZCBkZW1hbmRcbiAgbGV0IGdyb3VuZERlbWFuZEdXID0gZWZmZWN0aXZlR1cgKiAoMSAtIG9yYml0YWxTaGFyZSk7XG4gIFxuICAvLyBERUJVRzogTG9nIHJhdyBkZW1hbmQgYmVmb3JlIHNtb290aGluZ1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnNvbGUubG9nKGBbREVNQU5EIERFQlVHXSBZZWFyICR7eWVhcn06IHJhdyBncm91bmREZW1hbmRHVz0ke2dyb3VuZERlbWFuZEdXLnRvRml4ZWQoMSl9YCk7XG4gICAgY29uc29sZS5sb2coYFtERU1BTkQgREVCVUddICAgcHJldkRlbWFuZFN0YXRlPSR7cHJldkRlbWFuZFN0YXRlID8gYGV4aXN0cywgZ3JvdW5kRGVtYW5kR1c9JHtwcmV2RGVtYW5kU3RhdGUuZ3JvdW5kRGVtYW5kR1c/LnRvRml4ZWQoMSkgPz8gJ3VuZGVmaW5lZCd9YCA6ICdOVUxMJ31gKTtcbiAgfVxuICBcbiAgLy8gRklYRUQ6IEFkZCBkZW1hbmQgbW9tZW50dW0gKG1heCA1JSBjaGFuZ2UgcGVyIHllYXIpIC0gcHJldmVudHMgd2lsZCBzd2luZ3MgYW5kIHNhd3Rvb3RoIG9zY2lsbGF0aW9uXG4gIC8vIFVzZSBleHBsaWNpdCBjaGVjayBpbnN0ZWFkIG9mIHRydXRoeSBjaGVjayB0byBoYW5kbGUgMCB2YWx1ZXMgY29ycmVjdGx5XG4gIGlmIChwcmV2RGVtYW5kU3RhdGUgIT09IG51bGwgJiYgcHJldkRlbWFuZFN0YXRlLmdyb3VuZERlbWFuZEdXICE9PSB1bmRlZmluZWQgJiYgcHJldkRlbWFuZFN0YXRlLmdyb3VuZERlbWFuZEdXID4gMCkge1xuICAgIGNvbnN0IG1heERlbWFuZENoYW5nZVBlclllYXIgPSAwLjA1OyAvLyBNYXggNSUgY2hhbmdlIHBlciB5ZWFyICh0aWdodGVyIGNvbnN0cmFpbnQgdG8gZWxpbWluYXRlIG9zY2lsbGF0aW9uKVxuICAgIGNvbnN0IGRlbWFuZENoYW5nZVJhdGlvID0gZ3JvdW5kRGVtYW5kR1cgLyBwcmV2RGVtYW5kU3RhdGUuZ3JvdW5kRGVtYW5kR1c7XG4gICAgXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbREVNQU5EIERFQlVHXSAgIGNoYW5nZVJhdGlvPSR7ZGVtYW5kQ2hhbmdlUmF0aW8udG9GaXhlZCgzKX0gKG1heCBhbGxvd2VkOiAkeygxICsgbWF4RGVtYW5kQ2hhbmdlUGVyWWVhcikudG9GaXhlZCgzKX0gdG8gJHsoMSAtIG1heERlbWFuZENoYW5nZVBlclllYXIpLnRvRml4ZWQoMyl9KWApO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZGVtYW5kQ2hhbmdlUmF0aW8gPiAxICsgbWF4RGVtYW5kQ2hhbmdlUGVyWWVhcikge1xuICAgICAgY29uc3QgY2xhbXBlZCA9IHByZXZEZW1hbmRTdGF0ZS5ncm91bmREZW1hbmRHVyAqICgxICsgbWF4RGVtYW5kQ2hhbmdlUGVyWWVhcik7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0RFTUFORCBERUJVR10gICBDTEFNUEVEIFVQIGZyb20gJHtncm91bmREZW1hbmRHVy50b0ZpeGVkKDEpfSB0byAke2NsYW1wZWQudG9GaXhlZCgxKX1gKTtcbiAgICAgIH1cbiAgICAgIGdyb3VuZERlbWFuZEdXID0gY2xhbXBlZDtcbiAgICB9IGVsc2UgaWYgKGRlbWFuZENoYW5nZVJhdGlvIDwgMSAtIG1heERlbWFuZENoYW5nZVBlclllYXIpIHtcbiAgICAgIGNvbnN0IGNsYW1wZWQgPSBwcmV2RGVtYW5kU3RhdGUuZ3JvdW5kRGVtYW5kR1cgKiAoMSAtIG1heERlbWFuZENoYW5nZVBlclllYXIpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtERU1BTkQgREVCVUddICAgQ0xBTVBFRCBET1dOIGZyb20gJHtncm91bmREZW1hbmRHVy50b0ZpeGVkKDEpfSB0byAke2NsYW1wZWQudG9GaXhlZCgxKX1gKTtcbiAgICAgIH1cbiAgICAgIGdyb3VuZERlbWFuZEdXID0gY2xhbXBlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtERU1BTkQgREVCVUddICAgTk8gQ0xBTVAgKHdpdGhpbiBib3VuZHMpYCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW0RFTUFORCBERUJVR10gICBOTyBTTU9PVEhJTkcgKHByZXZEZW1hbmRTdGF0ZSBjaGVjayBmYWlsZWQ6ICR7cHJldkRlbWFuZFN0YXRlID09PSBudWxsID8gJ251bGwnIDogcHJldkRlbWFuZFN0YXRlLmdyb3VuZERlbWFuZEdXID09PSB1bmRlZmluZWQgPyAndW5kZWZpbmVkJyA6ICd6ZXJvIG9yIG5lZ2F0aXZlJ30pYCk7XG4gICAgfVxuICB9XG4gIFxuICBjb25zdCBvcmJpdGFsRGVtYW5kR1cgPSBlZmZlY3RpdmVHVyAtIGdyb3VuZERlbWFuZEdXO1xuICBcbiAgcmV0dXJuIHtcbiAgICB5ZWFyLFxuICAgIGJhc2VsaW5lR1csXG4gICAgZWZmZWN0aXZlR1csXG4gICAgZ3JvdW5kRGVtYW5kR1csXG4gICAgb3JiaXRhbERlbWFuZEdXLFxuICAgIG9yYml0YWxTaGFyZSwgLy8gVHJhY2sgZm9yIHNtb290aGluZyBpbiBuZXh0IGl0ZXJhdGlvblxuICB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBpbnN0YWxsZWQgSVQgbG9hZCAoR1cpIGZvciBhIGdpdmVuIHllYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldElUTG9hZEdXKHllYXI6IG51bWJlcik6IG51bWJlciB7XG4gIGlmICh5ZWFyIDwgMjAyNSkge1xuICAgIHJldHVybiBJVF9HV18yMDI1O1xuICB9XG4gIFxuICBpZiAoeWVhciA8PSAyMDQwKSB7XG4gICAgLy8gUGhhc2UgMTogMjAyNS0yMDQwXG4gICAgY29uc3QgeWVhcnNGcm9tMjAyNSA9IHllYXIgLSAyMDI1O1xuICAgIHJldHVybiBJVF9HV18yMDI1ICogTWF0aC5leHAoUjEgKiB5ZWFyc0Zyb20yMDI1KTtcbiAgfVxuICBcbiAgLy8gUGhhc2UgMjogMjA0MC0yMDYwXG4gIGNvbnN0IHllYXJzRnJvbTIwNDAgPSB5ZWFyIC0gMjA0MDtcbiAgcmV0dXJuIElUX0dXXzIwNDBfVEFSR0VUICogTWF0aC5leHAoUjIgKiB5ZWFyc0Zyb20yMDQwKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgZmFjaWxpdHkgbG9hZCAoR1cpID0gSVQgbG9hZCAqIFBVRVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmFjaWxpdHlMb2FkR1coeWVhcjogbnVtYmVyLCBwdWU6IG51bWJlciA9IDEuMyk6IG51bWJlciB7XG4gIGNvbnN0IGl0TG9hZEdXID0gZ2V0SVRMb2FkR1coeWVhcik7XG4gIHJldHVybiBpdExvYWRHVyAqIHB1ZTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgbmV3IGRlbWFuZCAoR1cpID0gbWF4KDAsIEZhY2lsaXR5X0dXKHQpIC0gRmFjaWxpdHlfR1codC0xKSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERlbWFuZE5ld0dXKHllYXI6IG51bWJlciwgcHVlOiBudW1iZXIgPSAxLjMpOiBudW1iZXIge1xuICBjb25zdCBmYWNpbGl0eUdXID0gZ2V0RmFjaWxpdHlMb2FkR1coeWVhciwgcHVlKTtcbiAgY29uc3QgZmFjaWxpdHlHV1ByZXYgPSBnZXRGYWNpbGl0eUxvYWRHVyh5ZWFyIC0gMSwgcHVlKTtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIGZhY2lsaXR5R1cgLSBmYWNpbGl0eUdXUHJldik7XG59XG5cbi8qKlxuICogTGVnYWN5IGZ1bmN0aW9uOiByZXR1cm5zIElUIGxvYWQgKG5vdCBmYWNpbGl0eSBsb2FkKVxuICogS2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVtYW5kUHJvamVjdGlvbih5ZWFyOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gZ2V0SVRMb2FkR1coeWVhcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlVHJhamVjdG9yeShvcHRpb25zOiBUcmFqZWN0b3J5T3B0aW9ucyk6IFllYXJseUJyZWFrZG93bltdIHtcbiAgLy8gUmUtZXhwb3J0IGNyb3Nzb3ZlciBhbmFseXNpcyBmdW5jdGlvbnMgZm9yIGNvbnZlbmllbmNlXG4gIC8vIFVzZXJzIGNhbiBpbXBvcnQgZnJvbSB0cmFqZWN0b3J5LnRzIG9yIGNyb3Nzb3ZlckFuYWx5c2lzLnRzXG4gIGNvbnN0IHllYXJzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjYgfSwgKF8sIGkpID0+IDIwMjUgKyBpKTsgLy8gMjAyNS0yMDUwICgyNiB5ZWFycylcbiAgY29uc3QgdHJhamVjdG9yeTogWWVhcmx5QnJlYWtkb3duW10gPSBbXTtcbiAgbGV0IGZpcnN0Q2FwWWVhcjogbnVtYmVyIHwgbnVsbCA9IG51bGw7IC8vIFRyYWNrIHdoZW4gY29uc3RyYWludCBjYXAgd2FzIGZpcnN0IGhpdFxuICBcbiAgLy8gTGF1bmNoIGxlYXJuaW5nOiBUcmFjayBjdW11bGF0aXZlIG1hc3MgdG8gb3JiaXRcbiAgbGV0IGxhdW5jaExlYXJuaW5nU3RhdGU6IExhdW5jaExlYXJuaW5nU3RhdGUgfCBudWxsID0gbnVsbDtcbiAgY29uc3QgQkFTRUxJTkVfTUFTU19LRyA9IDFfMDAwXzAwMDsgLy8gMU0ga2cgYmFzZWxpbmUgZm9yIGRvdWJsaW5ncyBjYWxjdWxhdGlvblxuICBjb25zdCBMQVVOQ0hfQ09TVF8wX1BFUl9LRyA9IDE1MDA7IC8vIEluaXRpYWwgbGF1bmNoIGNvc3QgaW4gMjAyNVxuICBcbiAgLy8gUmVzcG9uc2l2ZSBkZW1hbmQ6IFRyYWNrIGRlbWFuZCBzdGF0ZSBhY3Jvc3MgeWVhcnMgZm9yIFMtY3VydmUgYmVoYXZpb3JcbiAgbGV0IHByZXZEZW1hbmRTdGF0ZTogRGVtYW5kU3RhdGUgfCBudWxsID0gbnVsbDtcbiAgbGV0IHByZXZZZWFyQnJlYWtkb3duOiBZZWFybHlCcmVha2Rvd24gfCBudWxsID0gbnVsbDtcbiAgXG4gIC8vIEJ1aWxkb3V0IHN0YXRlOiBUcmFjayBhY3Jvc3MgeWVhcnMgZm9yIGJhY2tsb2cgY2FsY3VsYXRpb25cbiAgbGV0IGJ1aWxkb3V0U3RhdGU6IGltcG9ydCgnLi9ncm91bmRfYnVpbGRvdXQnKS5CdWlsZG91dFN0YXRlIHwgbnVsbCA9IG51bGw7XG4gIFxuICAvLyBNb2JpbGl6YXRpb24gc3RhdGU6IFRyYWNrIGFjcm9zcyB5ZWFycyBmb3IgY2FwYWNpdHkvYmFja2xvZyBldm9sdXRpb25cbiAgbGV0IG1vYmlsaXphdGlvblN0YXRlOiBpbXBvcnQoJy4vZ3JvdW5kX3JhbXBpbmdfbW9iaWxpemF0aW9uJykuTW9iaWxpemF0aW9uU3RhdGUgfCBudWxsID0gbnVsbDtcblxuICBmb3IgKGNvbnN0IHllYXIgb2YgeWVhcnMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBvcHRpb25zLm1vZGUgPT09ICdTVEFUSUMnIFxuICAgICAgPyBnZXRTdGF0aWNQYXJhbXMoeWVhcilcbiAgICAgIDogb3B0aW9ucy5wYXJhbXNCeVllYXIoeWVhcik7XG5cbiAgICAvLyBBcHBseSBsYXVuY2ggbGVhcm5pbmcgaWYgZW5hYmxlZFxuICAgIGxldCBsYXVuY2hDb3N0UGVyS2cgPSBnZXRMYXVuY2hDb3N0UGVyS2coeWVhciwgcGFyYW1zLmxhdW5jaENvc3RLZyk7XG4gICAgbGV0IHBhcmFtc1dpdGhMYXVuY2hDb3N0ID0gcGFyYW1zO1xuICAgIGlmIChvcHRpb25zLnVzZUxhdW5jaExlYXJuaW5nKSB7XG4gICAgICAvLyBFc3RpbWF0ZSBtYXNzIGRlbWFuZGVkIGZyb20gY29tcHV0ZSBwb3dlcjogfjEwMDAga2cgcGVyIE1XIGNvbXB1dGVcbiAgICAgIC8vIFVzZSB0YXJnZXRHVyBhcyBwcm94eSBmb3Igb3JiaXRhbCBjb21wdXRlIGRlbWFuZFxuICAgICAgY29uc3QgY29tcHV0ZVBvd2VyTVcgPSBwYXJhbXMudGFyZ2V0R1cgKiAxMDAwOyAvLyBDb252ZXJ0IEdXIHRvIE1XXG4gICAgICBjb25zdCBtYXNzUGVyTVcgPSAxMDAwOyAvLyBSb3VnaCBlc3RpbWF0ZTogMTAwMCBrZyBwZXIgTVdcbiAgICAgIGNvbnN0IG1hc3NEZW1hbmRlZEtnID0gY29tcHV0ZVBvd2VyTVcgKiBtYXNzUGVyTVc7XG4gICAgICBcbiAgICAgIGNvbnN0IGxhdW5jaExlYXJuaW5nUmVzdWx0ID0gc3RlcExhdW5jaExlYXJuaW5nKGxhdW5jaExlYXJuaW5nU3RhdGUsIHtcbiAgICAgICAgeWVhcixcbiAgICAgICAgbWFzc0RlbWFuZGVkS2csXG4gICAgICAgIGJhc2VsaW5lTWFzc0tnOiBCQVNFTElORV9NQVNTX0tHLFxuICAgICAgICBsYXVuY2hDb3N0MFBlcktnOiBMQVVOQ0hfQ09TVF8wX1BFUl9LRyxcbiAgICAgICAgbGVhcm5pbmdSYXRlOiAwLjE1LCAvLyAxNSUgcmVkdWN0aW9uIHBlciBkb3VibGluZ1xuICAgICAgICBtYXhGbGlnaHRzUGVyWWVhcjogMTAwMCxcbiAgICAgICAgcGF5bG9hZFBlckZsaWdodEtnOiAxMDBfMDAwLCAvLyBTdGFyc2hpcCBjYXBhY2l0eVxuICAgICAgfSk7XG4gICAgICBsYXVuY2hDb3N0UGVyS2cgPSBsYXVuY2hMZWFybmluZ1Jlc3VsdC5sYXVuY2hDb3N0UGVyS2c7XG4gICAgICBsYXVuY2hMZWFybmluZ1N0YXRlID0gbGF1bmNoTGVhcm5pbmdSZXN1bHQuc3RhdGU7XG4gICAgICBcbiAgICAgIC8vIE92ZXJyaWRlIGxhdW5jaCBjb3N0IGluIHBhcmFtcyBmb3IgdGhpcyB5ZWFyXG4gICAgICBwYXJhbXNXaXRoTGF1bmNoQ29zdCA9IHsgLi4ucGFyYW1zLCBsYXVuY2hDb3N0S2c6IGxhdW5jaENvc3RQZXJLZyB9O1xuICAgIH1cblxuICAgIC8vIFNJTkdMRSBTT1VSQ0UgT0YgVFJVVEg6IGNvbXB1dGUgZGVtYW5kIGluIEdXIHVzaW5nIFJFU1BPTlNJVkUgZGVtYW5kXG4gICAgLy8gRGVtYW5kIHJlc3BvbmRzIHRvIHByaWNlcywgd2FpdCB0aW1lcywgYW5kIG9yYml0YWwgc3Vic3RpdHV0aW9uIChjcmVhdGVzIFMtY3VydmUpXG4gICAgLy8gTk9URTogV2UgdXNlIFBSRVZJT1VTIHllYXIncyBwcmljZXMgdG8gY2FsY3VsYXRlIGN1cnJlbnQgeWVhcidzIGRlbWFuZCAoYXZvaWRzIGNpcmN1bGFyIGRlcGVuZGVuY3kpXG4gICAgY29uc3QgZ3JvdW5kUHVlID0gcGFyYW1zLnB1ZUdyb3VuZCA/PyAxLjM7XG4gICAgXG4gICAgLy8gR2V0IHByaWNlcyBmcm9tIHByZXZpb3VzIHllYXIgKG9yIGVzdGltYXRlcyBmb3IgZmlyc3QgeWVhcilcbiAgICBjb25zdCBwcmV2R3JvdW5kUHJpY2UgPSBwcmV2WWVhckJyZWFrZG93bj8uZ3JvdW5kPy5ncHVIb3VyUHJpY2luZz8uc3RhbmRhcmQ/LnByaWNlUGVyR3B1SG91ciA/PyA0LjAwO1xuICAgIGNvbnN0IHByZXZPcmJpdGFsUHJpY2UgPSBwcmV2WWVhckJyZWFrZG93bj8ub3JiaXQ/LmdwdUhvdXJQcmljaW5nPy5zdGFuZGFyZD8ucHJpY2VQZXJHcHVIb3VyID8/IDI1LjAwO1xuICAgIGNvbnN0IHByZXZBdmdXYWl0ID0gcHJldlllYXJCcmVha2Rvd24/Lmdyb3VuZD8uc3VwcGx5TWV0cmljcz8uYXZnV2FpdFllYXJzID8/IDA7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHJlc3BvbnNpdmUgZGVtYW5kIChwcmljZS93YWl0IGVsYXN0aWMsIG9yYml0YWwgc3Vic3RpdHV0aW9uKVxuICAgIGNvbnN0IGRlbWFuZFN0YXRlID0gY2FsY3VsYXRlUmVzcG9uc2l2ZURlbWFuZChcbiAgICAgIHllYXIsXG4gICAgICBwcmV2R3JvdW5kUHJpY2UsXG4gICAgICBwcmV2T3JiaXRhbFByaWNlLFxuICAgICAgcHJldkF2Z1dhaXQsXG4gICAgICBwcmV2RGVtYW5kU3RhdGVcbiAgICApO1xuICAgIHByZXZEZW1hbmRTdGF0ZSA9IGRlbWFuZFN0YXRlO1xuICAgIFxuICAgIC8vIFBhc3MgZmlyc3RDYXBZZWFyLCBtb2JpbGl6YXRpb25TdGF0ZSwgYW5kIHJlc3BvbnNpdmUgZGVtYW5kIHRvIGNvbXB1dGVQaHlzaWNzQ29zdFxuICAgIC8vIEFkZCBtb2JpbGl6YXRpb24gc3RhdGUgYW5kIHJlc3BvbnNpdmUgZGVtYW5kIHRvIHBhcmFtcyBzbyB0aGV5IGNhbiBiZSB1c2VkIGZvciBiYWNrbG9nIGNhbGN1bGF0aW9uXG4gICAgY29uc3QgcGFyYW1zV2l0aE1vYmlsaXphdGlvbiA9IHtcbiAgICAgIC4uLnBhcmFtc1dpdGhMYXVuY2hDb3N0LFxuICAgICAgcHJldk1vYmlsaXphdGlvblN0YXRlOiBtb2JpbGl6YXRpb25TdGF0ZSxcbiAgICAgIHJlc3BvbnNpdmVEZW1hbmRHVzogZGVtYW5kU3RhdGUuZ3JvdW5kRGVtYW5kR1csIC8vIFJlc3BvbnNpdmUgZ3JvdW5kIGRlbWFuZCAoSVQgbG9hZCwgbm90IGZhY2lsaXR5KVxuICAgICAgb3JiaXRhbFN1YnN0aXR1dGlvbkdXOiBkZW1hbmRTdGF0ZS5vcmJpdGFsRGVtYW5kR1csIC8vIERlbWFuZCBzaGlmdGVkIHRvIG9yYml0YWwgKGZvciBiYWNrbG9nIGRyYWluKVxuICAgIH0gYXMgYW55OyAvLyBUeXBlIGFzc2VydGlvbiBuZWVkZWQgc2luY2UgWWVhclBhcmFtcyBkb2Vzbid0IGluY2x1ZGUgdGhlc2UgZmllbGRzXG4gICAgY29uc3QgYnJlYWtkb3duID0gY29tcHV0ZVBoeXNpY3NDb3N0KHBhcmFtc1dpdGhNb2JpbGl6YXRpb24sIGZpcnN0Q2FwWWVhcik7XG4gICAgXG4gICAgLy8gVXBkYXRlIGxhdW5jaCBsZWFybmluZyBzdGF0ZSB3aXRoIGFjdHVhbCBtYXNzIGZyb20gYnJlYWtkb3duIChmb3IgbmV4dCBpdGVyYXRpb24pXG4gICAgaWYgKG9wdGlvbnMudXNlTGF1bmNoTGVhcm5pbmcgJiYgYnJlYWtkb3duLm9yYml0ICYmIGJyZWFrZG93bi5vcmJpdC5oeWJyaWRCcmVha2Rvd24pIHtcbiAgICAgIC8vIFVzZSBhY3R1YWwgbWFzcyBmcm9tIGh5YnJpZCBicmVha2Rvd24gaWYgYXZhaWxhYmxlXG4gICAgICAvLyBNYXNzIGlzIG5vdCBkaXJlY3RseSBpbiBvcmJpdGFsIGJyZWFrZG93biwgYnV0IHdlIGNhbiBlc3RpbWF0ZSBmcm9tIGxhdW5jaCBjb3N0XG4gICAgICAvLyBGb3Igbm93LCB1c2UgdGhlIG1hc3MgZGVtYW5kZWQgZXN0aW1hdGUgKHdpbGwgYmUgcmVmaW5lZCBpbiBuZXh0IGl0ZXJhdGlvbilcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY29uc3RyYWludEJyZWFrZG93biA9IGJyZWFrZG93bi5ncm91bmQuY29uc3RyYWludEJyZWFrZG93bjtcbiAgICBpZiAoY29uc3RyYWludEJyZWFrZG93biAmJiAnY2FwWWVhcicgaW4gY29uc3RyYWludEJyZWFrZG93biAmJiBjb25zdHJhaW50QnJlYWtkb3duLmNhcFllYXIgIT09IG51bGwgJiYgY29uc3RyYWludEJyZWFrZG93bi5jYXBZZWFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHRoaXNDYXBZZWFyID0gY29uc3RyYWludEJyZWFrZG93bi5jYXBZZWFyIGFzIG51bWJlcjtcbiAgICAgIGlmIChmaXJzdENhcFllYXIgPT09IG51bGwgfHwgdGhpc0NhcFllYXIgPCBmaXJzdENhcFllYXIpIHtcbiAgICAgICAgZmlyc3RDYXBZZWFyID0gdGhpc0NhcFllYXI7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFVzZSByZXNwb25zaXZlIGdyb3VuZCBkZW1hbmQgKGZhY2lsaXR5IGxvYWQgPSBncm91bmQgZGVtYW5kICogUFVFKVxuICAgIGNvbnN0IGFjdHVhbEdyb3VuZFB1ZSA9IGJyZWFrZG93bi5ncm91bmQ/LnB1ZSA/PyBncm91bmRQdWU7XG4gICAgY29uc3QgZGVtYW5kQ29tcHV0ZUdXID0gZGVtYW5kU3RhdGUuZ3JvdW5kRGVtYW5kR1cgKiBhY3R1YWxHcm91bmRQdWU7IC8vIENvbnZlcnQgSVQgbG9hZCB0byBmYWNpbGl0eSBsb2FkXG4gICAgY29uc3Qgb3JiaXRhbERlbWFuZEdXID0gZGVtYW5kU3RhdGUub3JiaXRhbERlbWFuZEdXICogYWN0dWFsR3JvdW5kUHVlOyAvLyBGb3Igb3JiaXRhbCBjYXBhY2l0eSBwbGFubmluZ1xuICAgIFxuICAgIC8vIENSSVRJQ0FMOiBFbnN1cmUgZ3JvdW5kLmJ1aWxkb3V0RGVidWcuZGVtYW5kR1cgbWF0Y2hlcyBzaW5nbGUgc291cmNlIG9mIHRydXRoXG4gICAgLy8gT3ZlcnJpZGUgYW55IHZhbHVlIGZyb20gYnVpbGRvdXQgbW9kZWwgdG8gZW5zdXJlIGNvbnNpc3RlbmN5XG4gICAgaWYgKGJyZWFrZG93bi5ncm91bmQ/LmJ1aWxkb3V0RGVidWcpIHtcbiAgICAgIGJyZWFrZG93bi5ncm91bmQuYnVpbGRvdXREZWJ1Zy5kZW1hbmRHVyA9IGRlbWFuZENvbXB1dGVHVztcbiAgICB9XG4gICAgXG4gICAgLy8gVXNlIGRlbWFuZENvbXB1dGVHVyBmb3IgYWxsIG1hcmtldCBjYWxjdWxhdGlvbnMgKHNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGgpXG4gICAgY29uc3QgdG90YWxEZW1hbmRHVyA9IGRlbWFuZENvbXB1dGVHVztcbiAgICBcbiAgICBjb25zdCBvcmJpdGFsRmVhc2libGUgPSBicmVha2Rvd24ub3JiaXQgJiYgYnJlYWtkb3duLm9yYml0LnRvdGFsQ29zdFBlclBmbG9wWWVhciA+IDAgJiYgYnJlYWtkb3duLm9yYml0LnRvdGFsQ29zdFBlclBmbG9wWWVhciA8IEluZmluaXR5O1xuICAgIGNvbnN0IGdyb3VuZEZlYXNpYmxlID0gYnJlYWtkb3duLmdyb3VuZCAmJiBicmVha2Rvd24uZ3JvdW5kLnRvdGFsQ29zdFBlclBmbG9wWWVhciA+IDAgJiYgYnJlYWtkb3duLmdyb3VuZC50b3RhbENvc3RQZXJQZmxvcFllYXIgPCBJbmZpbml0eTtcbiAgICBjb25zdCBvcmJpdGFsQ29zdEFjY291bnRpbmdWYWxpZCA9IGJyZWFrZG93bi5jb3N0QWNjb3VudGluZ1ZhbGlkICE9PSBmYWxzZTtcbiAgICBjb25zdCBncm91bmRDb3N0QWNjb3VudGluZ1ZhbGlkID0gYnJlYWtkb3duLmNvc3RBY2NvdW50aW5nVmFsaWQgIT09IGZhbHNlO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBvcmJpdGFsIGNhcGFjaXR5IEdXIGZyb20gY29uc3RlbGxhdGlvbjogKG51bVNhdGVsbGl0ZXMgKiBjb21wdXRlUGVyU2F0S3cpIC8gMWU2XG4gICAgLy8ga1cgLT4gR1cgY29udmVyc2lvbjogZGl2aWRlIGJ5IDEsMDAwLDAwMCAoMWU2KVxuICAgIC8vIENSSVRJQ0FMOiBjb21wdXRlUGVyU2F0S3cgaXMgaW4ga1csIHNvIGRpdmlkZSBieSAxZTYgdG8gZ2V0IEdXIChub3QgMWUzIGZvciBNVylcbiAgICBsZXQgb3JiaXRhbENhcGFjaXR5R1dfZnJvbVNhdHMgPSAwO1xuICAgIGlmIChicmVha2Rvd24ub3JiaXQ/LmNvbnN0ZWxsYXRpb24/LmRlc2lnbikge1xuICAgICAgY29uc3QgeyBudW1TYXRlbGxpdGVzLCBjb21wdXRlUGVyU2F0S3cgfSA9IGJyZWFrZG93bi5vcmJpdC5jb25zdGVsbGF0aW9uLmRlc2lnbjtcbiAgICAgIC8vIGtXIC0+IEdXOiBkaXZpZGUgYnkgMSwwMDAsMDAwICgxZTYpLCBOT1QgMSwwMDAgKDFlMylcbiAgICAgIG9yYml0YWxDYXBhY2l0eUdXX2Zyb21TYXRzID0gKG51bVNhdGVsbGl0ZXMgKiBjb21wdXRlUGVyU2F0S3cpIC8gMV8wMDBfMDAwO1xuICAgICAgXG4gICAgICAvLyBJbnZhcmlhbnQ6IDEgc2F0ZWxsaXRlIGF0IDExMSBrVyBzaG91bGQgYmUgMC4wMDAxMTEgR1csIG5vdCAxLjE0NCBHV1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIG51bVNhdGVsbGl0ZXMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRHVyA9IGNvbXB1dGVQZXJTYXRLdyAvIDFfMDAwXzAwMDtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBNYXRoLmFicyhvcmJpdGFsQ2FwYWNpdHlHV19mcm9tU2F0cyAtIGV4cGVjdGVkR1cpIC8gTWF0aC5tYXgoZXhwZWN0ZWRHVywgMWUtOSk7XG4gICAgICAgIGlmIChlcnJvciA+IDAuMDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgW09SQklUQUwgQ0FQQUNJVFkgQlVHXSBZZWFyICR7eWVhcn06IDEgc2F0ZWxsaXRlIGF0ICR7Y29tcHV0ZVBlclNhdEt3fSBrVyBzaG91bGQgYmUgJHtleHBlY3RlZEdXfSBHVywgYCArXG4gICAgICAgICAgICBgYnV0IGdvdCAke29yYml0YWxDYXBhY2l0eUdXX2Zyb21TYXRzfSBHVy4gQ2hlY2sga1ctPkdXIGNvbnZlcnNpb24gKG11c3QgZGl2aWRlIGJ5IDFlNiwgbm90IDFlMykuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3QgY2hhcnRQQiA9IGJyZWFrZG93bi5tZXRhZGF0YT8uY2hhcnRJbnB1dHM/LnBvd2VyQnVpbGRvdXQ7XG4gICAgY29uc3QgY2hhcnRCYWNrbG9nID0gY2hhcnRQQj8uYmFja2xvZ0d3O1xuICAgIGNvbnN0IGNoYXJ0QXZnV2FpdCA9IGNoYXJ0UEI/LmF2Z1dhaXRZZWFycztcbiAgICBjb25zdCBjaGFydEJ1aWxkUmF0ZSA9IGNoYXJ0UEI/Lm1heEJ1aWxkUmF0ZUd3WWVhcjtcbiAgICBcbiAgICAvLyBQcmVmZXIgYnVpbGRvdXREZWJ1ZyB3aGVuIHByZXNlbnQuXG4gICAgLy8gSWYgZ3JvdW5kL2JhY2tsb2cgZmllbGRzIGV4aXN0IGJ1dCBhcmUgMCB3aGlsZSBjaGFydElucHV0cyBzYXlzID4wLCB1c2UgY2hhcnRJbnB1dHMuXG4gICAgLy8gUmVtb3ZlIHRoZSBwaXBlbGluZUd3IHByb3h5IGVudGlyZWx5IChpdCdzIG5vdCBiYWNrbG9nIGFuZCBjYXVzZXMgc2lsZW50IHVuaXQvbWVhbmluZyBjb3JydXB0aW9uKS5cbiAgICBjb25zdCBiYWNrbG9nRnJvbUdyb3VuZCA9IGJyZWFrZG93bi5ncm91bmQ/LmJhY2tsb2dHdztcbiAgICBjb25zdCBiYWNrbG9nRnJvbUJ1aWxkb3V0ID0gYnJlYWtkb3duLmdyb3VuZD8uYnVpbGRvdXREZWJ1Zz8uYmFja2xvZ0dXO1xuICAgIGxldCBiYWNrbG9nR1cgPVxuICAgICAgKGJhY2tsb2dGcm9tQnVpbGRvdXQgIT09IHVuZGVmaW5lZCA/IGJhY2tsb2dGcm9tQnVpbGRvdXQgOiB1bmRlZmluZWQpID8/XG4gICAgICAoKGJhY2tsb2dGcm9tR3JvdW5kICE9PSB1bmRlZmluZWQgJiYgYmFja2xvZ0Zyb21Hcm91bmQgPiAwKSA/IGJhY2tsb2dGcm9tR3JvdW5kIDogdW5kZWZpbmVkKSA/P1xuICAgICAgKChjaGFydEJhY2tsb2cgIT09IHVuZGVmaW5lZCAmJiBjaGFydEJhY2tsb2cgPiAwKSA/IGNoYXJ0QmFja2xvZyA6IDApO1xuICAgIFxuICAgIGNvbnN0IGJ1aWxkUmF0ZUZyb21CdWlsZG91dCA9IGJyZWFrZG93bi5ncm91bmQ/LmJ1aWxkb3V0RGVidWc/LmJ1aWxkUmF0ZUdXeXI7XG4gICAgY29uc3QgYnVpbGRSYXRlRnJvbVN1cHBseSA9IGJyZWFrZG93bi5ncm91bmQ/LnN1cHBseU1ldHJpY3M/Lm1heEJ1aWxkUmF0ZUd3WWVhcjtcbiAgICBjb25zdCBidWlsZFJhdGVHV3lyID1cbiAgICAgIChidWlsZFJhdGVGcm9tQnVpbGRvdXQgIT09IHVuZGVmaW5lZCA/IGJ1aWxkUmF0ZUZyb21CdWlsZG91dCA6IHVuZGVmaW5lZCkgPz9cbiAgICAgIChidWlsZFJhdGVGcm9tU3VwcGx5ICE9PSB1bmRlZmluZWQgPyBidWlsZFJhdGVGcm9tU3VwcGx5IDogdW5kZWZpbmVkKSA/P1xuICAgICAgKGNoYXJ0QnVpbGRSYXRlICE9PSB1bmRlZmluZWQgPyBjaGFydEJ1aWxkUmF0ZSA6IDApO1xuICAgIFxuICAgIGNvbnN0IGF2Z1dhaXRGcm9tR3JvdW5kID0gYnJlYWtkb3duLmdyb3VuZD8uYXZnV2FpdFllYXJzO1xuICAgIGNvbnN0IGF2Z1dhaXRGcm9tQnVpbGRvdXQgPSBicmVha2Rvd24uZ3JvdW5kPy5idWlsZG91dERlYnVnPy50aW1lVG9Qb3dlclllYXJzO1xuICAgIGNvbnN0IGF2Z1dhaXRGcm9tU3VwcGx5ID0gYnJlYWtkb3duLmdyb3VuZD8uc3VwcGx5TWV0cmljcz8uYXZnV2FpdFllYXJzO1xuICAgIGxldCBhdmdXYWl0WWVhcnMgPVxuICAgICAgKGF2Z1dhaXRGcm9tQnVpbGRvdXQgIT09IHVuZGVmaW5lZCA/IGF2Z1dhaXRGcm9tQnVpbGRvdXQgOiB1bmRlZmluZWQpID8/XG4gICAgICAoKGF2Z1dhaXRGcm9tR3JvdW5kICE9PSB1bmRlZmluZWQgJiYgYXZnV2FpdEZyb21Hcm91bmQgPiAwKSA/IGF2Z1dhaXRGcm9tR3JvdW5kIDogdW5kZWZpbmVkKSA/P1xuICAgICAgKChhdmdXYWl0RnJvbVN1cHBseSAhPT0gdW5kZWZpbmVkICYmIGF2Z1dhaXRGcm9tU3VwcGx5ID4gMCkgPyBhdmdXYWl0RnJvbVN1cHBseSA6IHVuZGVmaW5lZCkgPz9cbiAgICAgICgoY2hhcnRBdmdXYWl0ICE9PSB1bmRlZmluZWQgJiYgY2hhcnRBdmdXYWl0ID4gMCkgPyBjaGFydEF2Z1dhaXQgOiAwKTtcbiAgICBcbiAgICAvLyBTZWxmLWhlYWwgcGx1bWJpbmcgbWlzbWF0Y2hlczogaWYgY2hhcnRJbnB1dHMgaGFzIHBvc2l0aXZlIHZhbHVlIGJ1dCBjaG9zZW4gaXMgMCwgdXNlIGNoYXJ0SW5wdXRzXG4gICAgLy8gTG9nIHN0cnVjdHVyZWQgZXJyb3IgYnV0IG5ldmVyIHRocm93IChwcmV2ZW50cyBjaGFydCBmcm9tIGRpc2FwcGVhcmluZylcbiAgICBpZiAoKGNoYXJ0QmFja2xvZyA/PyAwKSA+IDAgJiYgYmFja2xvZ0dXID09PSAwICYmIGNoYXJ0QmFja2xvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiYWNrbG9nR1cgPSBjaGFydEJhY2tsb2c7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGBbQkFDS0xPRyBQTFVNQklOR10gWWVhciAke3llYXJ9OiBjaGFydElucHV0cy5iYWNrbG9nR3c9JHtjaGFydEJhY2tsb2d9IGJ1dCBmYWxsYmFjayBjaGFpbiByZXR1cm5lZCAwLiBgICtcbiAgICAgICAgICBgU2VsZi1oZWFsZWQ6IHVzaW5nIGNoYXJ0SW5wdXRzLiBgICtcbiAgICAgICAgICBgQ2FuZGlkYXRlczogZ3JvdW5kLmJhY2tsb2dHdz0ke2JyZWFrZG93bi5ncm91bmQ/LmJhY2tsb2dHd30sIGAgK1xuICAgICAgICAgIGBidWlsZG91dERlYnVnLmJhY2tsb2dHVz0ke2JyZWFrZG93bi5ncm91bmQ/LmJ1aWxkb3V0RGVidWc/LmJhY2tsb2dHV30sIGAgK1xuICAgICAgICAgIGBzdXBwbHlNZXRyaWNzLnBpcGVsaW5lR3c9JHticmVha2Rvd24uZ3JvdW5kPy5zdXBwbHlNZXRyaWNzPy5waXBlbGluZUd3fWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKChjaGFydEF2Z1dhaXQgPz8gMCkgPiAwICYmIGF2Z1dhaXRZZWFycyA9PT0gMCAmJiBjaGFydEF2Z1dhaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXZnV2FpdFllYXJzID0gY2hhcnRBdmdXYWl0O1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgW1dBSVQgUExVTUJJTkddIFllYXIgJHt5ZWFyfTogY2hhcnRJbnB1dHMuYXZnV2FpdFllYXJzPSR7Y2hhcnRBdmdXYWl0fSBidXQgZmFsbGJhY2sgY2hhaW4gcmV0dXJuZWQgMC4gYCArXG4gICAgICAgICAgYFNlbGYtaGVhbGVkOiB1c2luZyBjaGFydElucHV0cy4gYCArXG4gICAgICAgICAgYENhbmRpZGF0ZXM6IGdyb3VuZC5hdmdXYWl0WWVhcnM9JHticmVha2Rvd24uZ3JvdW5kPy5hdmdXYWl0WWVhcnN9LCBgICtcbiAgICAgICAgICBgYnVpbGRvdXREZWJ1Zy50aW1lVG9Qb3dlclllYXJzPSR7YnJlYWtkb3duLmdyb3VuZD8uYnVpbGRvdXREZWJ1Zz8udGltZVRvUG93ZXJZZWFyc30sIGAgK1xuICAgICAgICAgIGBzdXBwbHlNZXRyaWNzLmF2Z1dhaXRZZWFycz0ke2JyZWFrZG93bi5ncm91bmQ/LnN1cHBseU1ldHJpY3M/LmF2Z1dhaXRZZWFyc31gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBvcmJpdE1heERlcGxveWFibGVDb21wdXRlR1cgZnJvbSBjb25zdGVsbGF0aW9uIGNhcGFjaXR5IG9yIHNjZW5hcmlvIHBhcmFtc1xuICAgIC8vIENhbm9uaWNhbCBvcmJpdGFsIGNhcGFjaXR5IGZyb20gY29uc3RlbGxhdGlvbjogKG51bVNhdGVsbGl0ZXMgKiBjb21wdXRlUGVyU2F0S3cpIC8gMWU2XG4gICAgY29uc3Qgb3JiaXRNYXhEZXBsb3lhYmxlQ29tcHV0ZUdXID0gb3JiaXRhbEZlYXNpYmxlIFxuICAgICAgPyAocGFyYW1zLm9yYml0TWF4RGVwbG95YWJsZUNvbXB1dGVHV0J5WWVhcj8uKHllYXIpID8/IG9yYml0YWxDYXBhY2l0eUdXX2Zyb21TYXRzKVxuICAgICAgOiAwO1xuICAgIFxuICAgIC8vIEZpeCBvcmJpdCBmZWFzaWJpbGl0eSBnYXRpbmc6IHVzZSBvcmJpdE1heERlcGxveWFibGVDb21wdXRlR1csIG5vdCBvcmJpdGFsQ2FwYWNpdHlHVyBwbGFjZWhvbGRlclxuICAgIGNvbnN0IG9yYml0YWxGZWFzaWJsZUZvclNoYXJlID0gb3JiaXRhbEZlYXNpYmxlICYmIChvcmJpdE1heERlcGxveWFibGVDb21wdXRlR1cgPiAwKTtcbiAgICBcbiAgICBjb25zdCBtYXJrZXRBbmFseXNpcyA9IGNhbGN1bGF0ZU1hcmtldFNoYXJlKFxuICAgICAgeWVhcixcbiAgICAgIGJyZWFrZG93bi5vcmJpdC50b3RhbENvc3RQZXJQZmxvcFllYXIsXG4gICAgICBicmVha2Rvd24uZ3JvdW5kLnRvdGFsQ29zdFBlclBmbG9wWWVhcixcbiAgICAgIHRvdGFsRGVtYW5kR1csXG4gICAgICBvcmJpdGFsRmVhc2libGVGb3JTaGFyZSxcbiAgICAgIGdyb3VuZEZlYXNpYmxlLFxuICAgICAgb3JiaXRhbENvc3RBY2NvdW50aW5nVmFsaWQsXG4gICAgICBncm91bmRDb3N0QWNjb3VudGluZ1ZhbGlkLFxuICAgICAgZGVtYW5kQ29tcHV0ZUdXLCAvLyBVc2Ugc2luZ2xlIHNvdXJjZSBvZiB0cnV0aCwgbm90IGdyb3VuZCBtb2RlbCBkZW1hbmRcbiAgICAgIGJhY2tsb2dHVyxcbiAgICAgIGJ1aWxkUmF0ZUdXeXIsXG4gICAgICBhdmdXYWl0WWVhcnMsXG4gICAgICBvcmJpdE1heERlcGxveWFibGVDb21wdXRlR1dcbiAgICApO1xuICAgIFxuICAgIGJyZWFrZG93bi5tYXJrZXQgPSB7XG4gICAgICB0b3RhbERlbWFuZEdXOiBkZW1hbmRDb21wdXRlR1csIC8vIFVzZSBzaW5nbGUgc291cmNlIG9mIHRydXRoIChub3QgbWFya2V0QW5hbHlzaXMudG90YWxEZW1hbmRHVyB3aGljaCBtYXkgZGlmZmVyKVxuICAgICAgb3JiaXRhbFNoYXJlRnJhYzogbWFya2V0QW5hbHlzaXMub3JiaXRhbFNoYXJlRnJhYyxcbiAgICAgIG9yYml0YWxDYXBhY2l0eUdXOiBtYXJrZXRBbmFseXNpcy5vcmJpdGFsQ2FwYWNpdHlHVyxcbiAgICAgIG9yYml0YWxSZXZlbnVlOiBtYXJrZXRBbmFseXNpcy5vcmJpdGFsUmV2ZW51ZSxcbiAgICAgIGdyb3VuZFNoYXJlRnJhYzogbWFya2V0QW5hbHlzaXMuZ3JvdW5kU2hhcmVGcmFjLFxuICAgICAgZ3JvdW5kQ2FwYWNpdHlHVzogbWFya2V0QW5hbHlzaXMuZ3JvdW5kQ2FwYWNpdHlHVyxcbiAgICAgIGRlYnVnOiB7XG4gICAgICAgIC4uLm1hcmtldEFuYWx5c2lzLmRlYnVnLFxuICAgICAgICBkZW1hbmRDb21wdXRlR1c6IGRlbWFuZENvbXB1dGVHVywgLy8gU2luZ2xlIHNvdXJjZSBvZiB0cnV0aFxuICAgICAgICBvcmJpdGFsQ2FwYWNpdHlHV19mcm9tU2F0czogb3JiaXRhbENhcGFjaXR5R1dfZnJvbVNhdHMsIC8vIENhbm9uaWNhbCBjYXBhY2l0eSBmcm9tIGNvbnN0ZWxsYXRpb24gKGZvciB2YWxpZGF0aW9uKVxuICAgICAgfSBhcyBNYXJrZXRBbmFseXNpc1snZGVidWcnXSwgLy8gVHlwZSBhc3NlcnRpb24gdG8gYWxsb3cgb3JiaXRhbENhcGFjaXR5R1dfZnJvbVNhdHNcbiAgICB9O1xuICAgIFxuICAgIC8vIEludmFyaWFudDogZGVtYW5kIHNjYWxhciBjb25zaXN0ZW5jeVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBicmVha2Rvd24ubWFya2V0KSB7XG4gICAgICBjb25zdCBtYXJrZXREZW1hbmQgPSBicmVha2Rvd24ubWFya2V0LnRvdGFsRGVtYW5kR1c7XG4gICAgICBjb25zdCBtYXJrZXREZWJ1Z0RlbWFuZCA9IGJyZWFrZG93bi5tYXJrZXQuZGVidWc/LmRlbWFuZENvbXB1dGVHVztcbiAgICAgIGNvbnN0IGJ1aWxkb3V0RGVtYW5kID0gYnJlYWtkb3duLmdyb3VuZD8uYnVpbGRvdXREZWJ1Zz8uZGVtYW5kR1c7XG4gICAgICBcbiAgICAgIGlmIChtYXJrZXREZWJ1Z0RlbWFuZCAhPT0gdW5kZWZpbmVkICYmIE1hdGguYWJzKG1hcmtldERlbWFuZCAtIG1hcmtldERlYnVnRGVtYW5kKSA+IDFlLTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBbREVNQU5EIFNDQUxBUiBCVUddIFllYXIgJHt5ZWFyfTogbWFya2V0LnRvdGFsRGVtYW5kR1c9JHttYXJrZXREZW1hbmR9ICE9IGAgK1xuICAgICAgICAgIGBtYXJrZXQuZGVidWcuZGVtYW5kQ29tcHV0ZUdXPSR7bWFya2V0RGVidWdEZW1hbmR9LiBNdXN0IGJlIGVxdWFsLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGJ1aWxkb3V0RGVtYW5kICE9PSB1bmRlZmluZWQgJiYgTWF0aC5hYnMobWFya2V0RGVtYW5kIC0gYnVpbGRvdXREZW1hbmQpID4gMWUtNikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFtERU1BTkQgU0NBTEFSIEJVR10gWWVhciAke3llYXJ9OiBtYXJrZXQudG90YWxEZW1hbmRHVz0ke21hcmtldERlbWFuZH0gIT0gYCArXG4gICAgICAgICAgYGdyb3VuZC5idWlsZG91dERlYnVnLmRlbWFuZEdXPSR7YnVpbGRvdXREZW1hbmR9LiBNdXN0IGJlIGVxdWFsLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIG1vYmlsaXphdGlvbiBzdGF0ZSBmb3IgbmV4dCB5ZWFyICh1c2UgZXh0cmFjdGVkIHZhbHVlcywgbm90IGJyZWFrZG93bi5ncm91bmQgd2hpY2ggbWlnaHQgYmUgMClcbiAgICBpZiAoYnJlYWtkb3duLmdyb3VuZD8uYnVpbGRvdXREZWJ1Zykge1xuICAgICAgY29uc3QgYnVpbGRvdXREZWJ1ZyA9IGJyZWFrZG93bi5ncm91bmQuYnVpbGRvdXREZWJ1ZztcbiAgICAgIG1vYmlsaXphdGlvblN0YXRlID0ge1xuICAgICAgICB5ZWFyLFxuICAgICAgICBkZW1hbmRHVzogYnVpbGRvdXREZWJ1Zy5kZW1hbmRHVyA/PyAwLFxuICAgICAgICBkZW1hbmROZXdHVzogYnVpbGRvdXREZWJ1Zy5kZW1hbmROZXdHVyxcbiAgICAgICAgYnVpbGRSYXRlR1d5cjogYnVpbGRvdXREZWJ1Zy5idWlsZFJhdGVHV3lyID8/IGJ1aWxkUmF0ZUdXeXIsXG4gICAgICAgIGNhcGFjaXR5R1c6IGJ1aWxkb3V0RGVidWcuY2FwYWNpdHlHVyA/PyAwLFxuICAgICAgICBwaXBlbGluZUdXOiBidWlsZG91dERlYnVnLnBpcGVsaW5lR1cgPz8gMCxcbiAgICAgICAgYmFja2xvZ0dXOiBiYWNrbG9nR1csIC8vIFVzZSBleHRyYWN0ZWQgdmFsdWUsIG5vdCBicmVha2Rvd24uZ3JvdW5kLmJhY2tsb2dHdyB3aGljaCBtaWdodCBiZSAwXG4gICAgICAgIGF2Z1dhaXRZZWFyczogYXZnV2FpdFllYXJzLCAvLyBVc2UgZXh0cmFjdGVkIHZhbHVlLCBub3QgYnJlYWtkb3duLmdyb3VuZC5hdmdXYWl0WWVhcnMgd2hpY2ggbWlnaHQgYmUgMFxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgdHJhamVjdG9yeS5wdXNoKGJyZWFrZG93bik7XG4gICAgXG4gICAgLy8gVXBkYXRlIHByZXZpb3VzIHllYXIgYnJlYWtkb3duIGZvciBuZXh0IGl0ZXJhdGlvbiAoZm9yIHJlc3BvbnNpdmUgZGVtYW5kIGNhbGN1bGF0aW9uKVxuICAgIHByZXZZZWFyQnJlYWtkb3duID0gYnJlYWtkb3duO1xuICB9XG5cbiAgcmV0dXJuIHRyYWplY3Rvcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUZpbmFsQW5hbHlzaXMoXG4gIG9wdGlvbnM6IFRyYWplY3RvcnlPcHRpb25zLFxuICBiYXNlVHJhamVjdG9yeTogWWVhcmx5QnJlYWtkb3duW11cbik6IEZpbmFsTW9kZWxPdXRwdXQge1xuICBjb25zdCBiYXNlQ3Jvc3NvdmVyID0gZmluZENyb3Nzb3ZlclllYXIoYmFzZVRyYWplY3RvcnkpO1xuICBjb25zdCBiYXNlQ3Jvc3NvdmVyRWZmZWN0aXZlUGZsb3AgPSBmaW5kQ3Jvc3NvdmVyWWVhckVmZmVjdGl2ZVBmbG9wKGJhc2VUcmFqZWN0b3J5KTtcbiAgY29uc3QgYmFzZVBhcmFtcyA9IG9wdGlvbnMucGFyYW1zQnlZZWFyKDIwMjUpO1xuICBcbiAgLy8gMS4gU2Vuc2l0aXZpdHkgQW5hbHlzaXNcbiAgY29uc3QgcGFyYW1ldGVyc1RvVGVzdCA9IFtcbiAgICB7IGtleTogJ2xhdW5jaENvc3RLZycsIG5hbWU6ICdMYXVuY2ggQ29zdCAoMjAzNSknLCB2YWx1ZXM6IFs1MCwgMTAwLCAxNTAsIDIwMCwgMzAwXSwgeWVhclRvTW9kaWZ5OiAyMDM1IH0sXG4gICAgeyBrZXk6ICdncHVGYWlsdXJlUmF0ZScsIG5hbWU6ICdHUFUgRmFpbHVyZSBSYXRlJywgdmFsdWVzOiBbMC4wNSwgMC4xMCwgMC4xNSwgMC4yMCwgMC4yNV0sIHllYXJUb01vZGlmeTogbnVsbCB9LFxuICAgIHsga2V5OiAnaGFyZHdhcmVMZWFybmluZ1JhdGUnLCBuYW1lOiAnSGFyZHdhcmUgTGVhcm5pbmcgUmF0ZScsIHZhbHVlczogWzAuMDgsIDAuMTAsIDAuMTIsIDAuMTVdLCB5ZWFyVG9Nb2RpZnk6IG51bGwgfSxcbiAgXTtcblxuICBjb25zdCBzZW5zaXRpdml0aWVzID0gcGFyYW1ldGVyc1RvVGVzdC5tYXAocCA9PiB7XG4gICAgY29uc3QgY3Jvc3NvdmVyWWVhcnMgPSBwLnZhbHVlcy5tYXAodmFsID0+IHtcbiAgICAgIGNvbnN0IHRlc3RUcmFqZWN0b3J5ID0gY29tcHV0ZVRyYWplY3Rvcnkoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBwYXJhbXNCeVllYXI6ICh5KSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gb3B0aW9ucy5wYXJhbXNCeVllYXIoeSk7XG4gICAgICAgICAgaWYgKHAueWVhclRvTW9kaWZ5ICYmIHkgPT09IHAueWVhclRvTW9kaWZ5KSB7XG4gICAgICAgICAgICAgcmV0dXJuIHsgLi4ucGFyYW1zLCBbcC5rZXldOiB2YWwgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFwLnllYXJUb01vZGlmeSkge1xuICAgICAgICAgICAgIHJldHVybiB7IC4uLnBhcmFtcywgW3Aua2V5XTogdmFsIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZpbmRDcm9zc292ZXJZZWFyKHRlc3RUcmFqZWN0b3J5KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHZhbGlkWWVhcnMgPSBjcm9zc292ZXJZZWFycy5maWx0ZXIoeSA9PiB5ICE9PSBudWxsKSBhcyBudW1iZXJbXTtcbiAgICBjb25zdCBtYXhEZWx0YSA9IHZhbGlkWWVhcnMubGVuZ3RoID4gMSA/IE1hdGgubWF4KC4uLnZhbGlkWWVhcnMpIC0gTWF0aC5taW4oLi4udmFsaWRZZWFycykgOiAwO1xuICAgIGNvbnN0IGltcGFjdCA9IG1heERlbHRhID49IDQgPyAnaGlnaCcgOiBtYXhEZWx0YSA+PSAyID8gJ21lZGl1bScgOiAnbG93JztcblxuICAgIHJldHVybiB7XG4gICAgICBwYXJhbWV0ZXI6IHAubmFtZSxcbiAgICAgIGJhc2VWYWx1ZTogKGJhc2VQYXJhbXNbcC5rZXkgYXMga2V5b2YgWWVhclBhcmFtc10gYXMgbnVtYmVyKSB8fCAwLFxuICAgICAgdGVzdFZhbHVlczogcC52YWx1ZXMsXG4gICAgICBjcm9zc292ZXJZZWFycyxcbiAgICAgIGltcGFjdDogaW1wYWN0IGFzICdoaWdoJyB8ICdtZWRpdW0nIHwgJ2xvdydcbiAgICB9O1xuICB9KTtcblxuICAvLyAyLiBTY2VuYXJpbyBCZW5jaG1hcmtzXG4gIGNvbnN0IHNjZW5hcmlvcyA9IFtcbiAgICB7XG4gICAgICBuYW1lOiAnQnVsbCBDYXNlJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnTWF0dXJlIFN0YXJzaGlwLCBjb21tZXJjaWFsIGNoaXBzLCBzZXZlcmUgZ3JvdW5kIGNvbnN0cmFpbnRzJyxcbiAgICAgIGtleUFzc3VtcHRpb25zOiBbJ0xhdW5jaCAkNzUva2cgYnkgMjAzNScsICdDb21tZXJjaWFsIGNoaXBzJywgJ1NldmVyZSBncm91bmQgY29uc3RyYWludHMnXSxcbiAgICAgIGNyb3Nzb3ZlclllYXI6IGZpbmRDcm9zc292ZXJZZWFyKGNvbXB1dGVUcmFqZWN0b3J5KHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgcGFyYW1zQnlZZWFyOiAoeSkgPT4gKHtcbiAgICAgICAgICAuLi5vcHRpb25zLnBhcmFtc0J5WWVhcih5KSxcbiAgICAgICAgICBsYXVuY2hDb3N0S2c6IGdldExhdW5jaENvc3RQZXJLZyh5LCAxNTAwKSxcbiAgICAgICAgICB1c2VSYWRIYXJkQ2hpcHM6IGZhbHNlLFxuICAgICAgICAgIGdyb3VuZFNjZW5hcmlvOiAnc2V2ZXJlJ1xuICAgICAgICB9KVxuICAgICAgfSkpXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnQmFzZSBDYXNlJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ3VycmVudCBtb2RlbCBhc3N1bXB0aW9ucyAoUmFkLXRvbGVyYW50IGJhc2VsaW5lKScsXG4gICAgICBrZXlBc3N1bXB0aW9uczogWydMYXVuY2ggJDc1L2tnIGJ5IDIwMzUnLCAnUmFkLXRvbGVyYW50IGNoaXBzJywgJ1N0YW5kYXJkIGdyb3VuZCBjb25zdHJhaW50cyddLFxuICAgICAgY3Jvc3NvdmVyWWVhcjogYmFzZUNyb3Nzb3ZlclxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ0JlYXIgQ2FzZScsXG4gICAgICBkZXNjcmlwdGlvbjogJ1JhZC1oYXJkIHJlcXVpcmVkLCBTTVJzIHNvbHZlIGdyb3VuZCBwb3dlcicsXG4gICAgICBrZXlBc3N1bXB0aW9uczogWydMYXVuY2ggJDMwMC9rZyBieSAyMDM1JywgJ1JhZC1oYXJkIGNoaXBzJywgJ1VuY29uc3RyYWluZWQgZ3JvdW5kJ10sXG4gICAgICBjcm9zc292ZXJZZWFyOiBmaW5kQ3Jvc3NvdmVyWWVhcihjb21wdXRlVHJhamVjdG9yeSh7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHBhcmFtc0J5WWVhcjogKHkpID0+ICh7XG4gICAgICAgICAgLi4ub3B0aW9ucy5wYXJhbXNCeVllYXIoeSksXG4gICAgICAgICAgbGF1bmNoQ29zdEtnOiBwcm9qZWN0TWFya2V0UHJpY2UoMTUwMCwgMjAyNSwgeSwgMC4xMCksXG4gICAgICAgICAgdXNlUmFkSGFyZENoaXBzOiB0cnVlLFxuICAgICAgICAgIGdyb3VuZFNjZW5hcmlvOiAndW5jb25zdHJhaW5lZCdcbiAgICAgICAgfSlcbiAgICAgIH0pKVxuICAgIH1cbiAgXTtcblxuICAvLyAzLiBNYXJrZXQgQ29tcGFyaXNvblxuICBjb25zdCBtYXJrZXRDb21wYXJpc29uOiBNYXJrZXRQcm9qZWN0aW9uW10gPSBNQVJLRVRfUFJPVklERVJTLm1hcChwID0+IHtcbiAgICBjb25zdCBwcm9qZWN0ZWRQcmljZXMgPSBbXTtcbiAgICBmb3IgKGxldCB5ID0gMjAyNTsgeSA8PSAyMDUwOyB5KyspIHtcbiAgICAgIHByb2plY3RlZFByaWNlcy5wdXNoKHsgeWVhcjogeSwgcHJpY2U6IHByb2plY3RNYXJrZXRQcmljZShwLnByaWNlLCAyMDI0LCB5LCBwLmRlY2xpbmUpIH0pO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBvcmJpdGFsQmVhdHNZZWFyID0gYmFzZVRyYWplY3RvcnkuZmluZChkID0+IHtcbiAgICAgIGNvbnN0IHByb2plY3RlZCA9IHByb2plY3RNYXJrZXRQcmljZShwLnByaWNlLCAyMDI0LCBkLnllYXIsIHAuZGVjbGluZSk7XG4gICAgICByZXR1cm4gZC5vcmJpdC5ncHVIb3VyUHJpY2luZy5zdGFuZGFyZC5wcmljZVBlckdwdUhvdXIgPCBwcm9qZWN0ZWQ7XG4gICAgfSk/LnllYXIgfHwgbnVsbDtcblxuICAgIHJldHVybiB7XG4gICAgICBwcm92aWRlcjogcC5uYW1lLFxuICAgICAgY3VycmVudFByaWNlOiBwLnByaWNlLFxuICAgICAgY3VycmVudFllYXI6IDIwMjQsXG4gICAgICBwcm9qZWN0ZWREZWNsaW5lOiBwLmRlY2xpbmUsXG4gICAgICBwcm9qZWN0ZWRQcmljZXMsXG4gICAgICBvcmJpdGFsQmVhdHNZZWFyXG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gNC4gR3JvdW5kIFNjZW5hcmlvIExhYmVsXG4gIGNvbnN0IHNlbGVjdGVkU2NlbmFyaW8gPSBHUk9VTkRfU0NFTkFSSU9TW2Jhc2VQYXJhbXMuZ3JvdW5kU2NlbmFyaW9dO1xuICBjb25zdCBncm91bmRTY2VuYXJpb0xhYmVsOiBHcm91bmRTY2VuYXJpb0xhYmVsID0ge1xuICAgIG5hbWU6IHNlbGVjdGVkU2NlbmFyaW8ubmFtZSxcbiAgICBkZXNjcmlwdGlvbjogc2VsZWN0ZWRTY2VuYXJpby5kZXNjcmlwdGlvbixcbiAgICBjb25zdHJhaW50TXVsdGlwbGllcjIwNDA6IDEuMCwgLy8gTm90IHVzZWQgLSBjb25zdHJhaW50cyBub3cgdXNlIGFkZGVycyBvbmx5XG4gICAgYXNzdW1wdGlvbnM6IFtcbiAgICAgIGBHcmlkIGdyb3d0aDogJHsoc2VsZWN0ZWRTY2VuYXJpby5ncmlkR3Jvd3RoUmF0ZSAqIDEwMCkudG9GaXhlZCgxKX0lL3llYXJgLFxuICAgICAgYENvb2xpbmcgZ3Jvd3RoOiAkeyhzZWxlY3RlZFNjZW5hcmlvLmNvb2xpbmdHcm93dGhSYXRlICogMTAwKS50b0ZpeGVkKDEpfSUveWVhcmAsXG4gICAgICBzZWxlY3RlZFNjZW5hcmlvLmNvbnN0cmFpbnRDYXAgPyBgQ29uc3RyYWludCBjYXA6ICR7c2VsZWN0ZWRTY2VuYXJpby5jb25zdHJhaW50Q2FwfXhgIDogJ05vIGNvbnN0cmFpbnQgY2FwJ1xuICAgIF1cbiAgfTtcblxuICAvLyA1LiBWYWxpZGF0aW9uIENoZWNrc1xuICBjb25zdCBsYXN0WWVhciA9IGJhc2VUcmFqZWN0b3J5W2Jhc2VUcmFqZWN0b3J5Lmxlbmd0aCAtIDFdO1xuICBjb25zdCBmaXJzdFllYXIgPSBiYXNlVHJhamVjdG9yeVswXTtcbiAgY29uc3QgYWxsQ2hlY2tzID0gW1xuICAgIHsgbmFtZTogJ0Nvc3QgYnJlYWtkb3duIHN1bXMgdG8gdG90YWwnLCBwYXNzZWQ6ICEhbGFzdFllYXIuY29zdEFjY291bnRpbmdWYWxpZCwgdmFsdWU6IGxhc3RZZWFyLmNvc3RBY2NvdW50aW5nRXJyb3JQY3QsIGV4cGVjdGVkOiAnPDAuNSUnIH0sXG4gICAgeyBuYW1lOiAnQ2FwYWNpdHkgZmFjdG9yIGluIHJhbmdlJywgcGFzc2VkOiBmaXJzdFllYXIub3JiaXQuY2FwYWNpdHlGYWN0b3IgPiAwLjkwLCB2YWx1ZTogZmlyc3RZZWFyLm9yYml0LmNhcGFjaXR5RmFjdG9yLCBleHBlY3RlZDogJzAuOTAtMS4wJyB9LFxuICAgIHsgbmFtZTogJ0Nyb3Nzb3ZlciB5ZWFyIG1hdGNoZXMgdHJhamVjdG9yeScsIHBhc3NlZDogdHJ1ZSwgdmFsdWU6IGJhc2VDcm9zc292ZXIgfSxcbiAgXTtcblxuICBjb25zdCB2YWxpZGF0aW9uOiBWYWxpZGF0aW9uQ2hlY2tzID0ge1xuICAgIGNvc3RBY2NvdW50aW5nVmFsaWQ6ICEhbGFzdFllYXIuY29zdEFjY291bnRpbmdWYWxpZCxcbiAgICBjb3N0QWNjb3VudGluZ0Vycm9yOiBsYXN0WWVhci5jb3N0QWNjb3VudGluZ0Vycm9yUGN0IHx8IDAsXG4gICAgdHJhamVjdG9yeU1vbm90b25pYzogdHJ1ZSwgLy8gU2ltcGxpZmllZFxuICAgIHBhcmFtZXRlcnNJblJhbmdlOiB0cnVlLFxuICAgIGNyb3Nzb3ZlckNvbnNpc3RlbnQ6IHRydWUsXG4gICAgYWxsQ2hlY2tzXG4gIH07XG5cbiAgY29uc3QgY3Jvc3NvdmVyWWVhclN0YW5kYXJkID0gYmFzZUNyb3Nzb3ZlcjtcbiAgY29uc3QgcHJpY2VBdENyb3Nzb3Zlck9yYml0YWwgPSBiYXNlQ3Jvc3NvdmVyID8gYmFzZVRyYWplY3RvcnlbYmFzZUNyb3Nzb3ZlciAtIDIwMjVdLm9yYml0LmdwdUhvdXJQcmljaW5nLnN0YW5kYXJkLnByaWNlUGVyR3B1SG91ciA6IDA7XG4gIGNvbnN0IHByaWNlQXRDcm9zc292ZXJHcm91bmQgPSBiYXNlQ3Jvc3NvdmVyID8gYmFzZVRyYWplY3RvcnlbYmFzZUNyb3Nzb3ZlciAtIDIwMjVdLmdyb3VuZC5ncHVIb3VyUHJpY2luZy5zdGFuZGFyZC5wcmljZVBlckdwdUhvdXIgOiAwO1xuXG4gIGNvbnN0IGFjdGl2ZVRvZ2dsZXMgPSBbXTtcbiAgaWYgKGJhc2VQYXJhbXMuZWxvblNjZW5hcmlvRW5hYmxlZCkgYWN0aXZlVG9nZ2xlcy5wdXNoKCdFbG9uIFNjZW5hcmlvJyk7XG4gIGlmIChiYXNlUGFyYW1zLmdsb2JhbExhdGVuY3lSZXF1aXJlbWVudEVuYWJsZWQpIGFjdGl2ZVRvZ2dsZXMucHVzaCgnR2xvYmFsIExhdGVuY3knKTtcbiAgaWYgKGJhc2VQYXJhbXMuc3BhY2VNYW51ZmFjdHVyaW5nRW5hYmxlZCkgYWN0aXZlVG9nZ2xlcy5wdXNoKCdTcGFjZSBNZmcnKTtcbiAgaWYgKGJhc2VQYXJhbXMuYWlXaW50ZXJFbmFibGVkKSBhY3RpdmVUb2dnbGVzLnB1c2goJ0FJIFdpbnRlcicpO1xuXG4gIC8vIEJhc2VsaW5lIGNyb3Nzb3ZlciAobm8gdG9nZ2xlcylcbiAgY29uc3QgYmFzZWxpbmVUcmFqZWN0b3J5ID0gY29tcHV0ZVRyYWplY3Rvcnkoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgcGFyYW1zQnlZZWFyOiAoeSkgPT4gKHtcbiAgICAgIC4uLm9wdGlvbnMucGFyYW1zQnlZZWFyKHkpLFxuICAgICAgZWxvblNjZW5hcmlvRW5hYmxlZDogZmFsc2UsXG4gICAgICBnbG9iYWxMYXRlbmN5UmVxdWlyZW1lbnRFbmFibGVkOiBmYWxzZSxcbiAgICAgIHNwYWNlTWFudWZhY3R1cmluZ0VuYWJsZWQ6IGZhbHNlLFxuICAgICAgYWlXaW50ZXJFbmFibGVkOiBmYWxzZVxuICAgIH0pXG4gIH0pO1xuICBjb25zdCBiYXNlbGluZUNyb3Nzb3ZlciA9IGZpbmRDcm9zc292ZXJZZWFyKGJhc2VsaW5lVHJhamVjdG9yeSk7XG5cbiAgY29uc3Qgc2NlbmFyaW9JbXBhY3QgPSB7XG4gICAgYmFzZWxpbmVDcm9zc292ZXIsXG4gICAgY3VycmVudENyb3Nzb3ZlcjogYmFzZUNyb3Nzb3ZlcixcbiAgICBhY3RpdmVUb2dnbGVzLFxuICAgIGNyb3Nzb3ZlckRlbHRhOiAoYmFzZWxpbmVDcm9zc292ZXIgfHwgMjA0MCkgLSAoYmFzZUNyb3Nzb3ZlciB8fCAyMDQwKVxuICB9O1xuXG4gIC8vIE1vbnRlIENhcmxvIEFuYWx5c2lzIChydW4gb25jZSwgY2FjaGVkIHBlciBwYXJhbWV0ZXIgc2V0KVxuICAvLyBFeHRyYWN0IGJhc2UgcGFyYW1ldGVycyBmb3IgTW9udGUgQ2FybG9cbiAgY29uc3QgYmFzZVBhcmFtc0Zvck1DID0gZXh0cmFjdEJhc2VQYXJhbXMob3B0aW9ucy5wYXJhbXNCeVllYXIpO1xuICBcbiAgLy8gUnVuIE1vbnRlIENhcmxvIGFuYWx5c2lzICgyMDAgc2FtcGxlcyBieSBkZWZhdWx0KVxuICAvLyBUaGlzIGlzIGNvbXB1dGF0aW9uYWxseSBleHBlbnNpdmUsIHNvIHdlIG9ubHkgZG8gaXQgb25jZSBwZXIgYW5hbHlzaXNcbiAgY29uc3QgbW9udGVDYXJsb1Jlc3VsdCA9IHJ1bk1vbnRlQ2FybG9Dcm9zc292ZXIoXG4gICAgb3B0aW9ucy5wYXJhbXNCeVllYXIsXG4gICAgYmFzZVBhcmFtc0Zvck1DLFxuICAgIDIwMCAvLyBudW1TYW1wbGVzXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBtZXRhZGF0YToge1xuICAgICAgdmVyc2lvbjogJzQuMy4wJyxcbiAgICAgIGdlbmVyYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB1bml0czogW10gXG4gICAgfSxcbiAgICBwYXJhbWV0ZXJzOiBiYXNlUGFyYW1zLFxuICAgIHRyYWplY3Rvcnk6IGJhc2VUcmFqZWN0b3J5LFxuICAgIGFuYWx5c2lzOiB7XG4gICAgICBjcm9zc292ZXI6IHtcbiAgICAgICAgeWVhcjogYmFzZUNyb3Nzb3ZlcixcbiAgICAgICAgb3JiaXRhbFByaWNlOiBwcmljZUF0Q3Jvc3NvdmVyT3JiaXRhbCxcbiAgICAgICAgZ3JvdW5kUHJpY2U6IHByaWNlQXRDcm9zc292ZXJHcm91bmQsXG4gICAgICAgIG1hcmtldFBvc2l0aW9uOiBiYXNlVHJhamVjdG9yeVtiYXNlVHJhamVjdG9yeS5sZW5ndGggLSAxXS5jcm9zc292ZXJEZXRhaWxzPy5tYXJrZXRQb3NpdGlvbiB8fCAnJ1xuICAgICAgfSxcbiAgICAgIHNlbnNpdGl2aXR5OiB7XG4gICAgICAgIGJhc2VDYXNlOiB7XG4gICAgICAgICAgY3Jvc3NvdmVyWWVhcjogYmFzZUNyb3Nzb3ZlciB8fCAyMDQwLFxuICAgICAgICAgIG9yYml0YWxQcmljZUF0Q3Jvc3NvdmVyOiBwcmljZUF0Q3Jvc3NvdmVyT3JiaXRhbCxcbiAgICAgICAgICBncm91bmRQcmljZUF0Q3Jvc3NvdmVyOiBwcmljZUF0Q3Jvc3NvdmVyR3JvdW5kLFxuICAgICAgICB9LFxuICAgICAgICBzZW5zaXRpdml0aWVzXG4gICAgICB9LFxuICAgICAgc2NlbmFyaW9zLFxuICAgICAgY29uZmlkZW5jZToge1xuICAgICAgICBjcm9zc292ZXJZZWFyOiB7XG4gICAgICAgICAgcDEwOiBtb250ZUNhcmxvUmVzdWx0LnAxMCwgLy8gRnJvbSBNb250ZSBDYXJsbyBhbmFseXNpc1xuICAgICAgICAgIHA1MDogbW9udGVDYXJsb1Jlc3VsdC5wNTAsIC8vIEZyb20gTW9udGUgQ2FybG8gYW5hbHlzaXNcbiAgICAgICAgICBwOTA6IG1vbnRlQ2FybG9SZXN1bHQucDkwLCAvLyBGcm9tIE1vbnRlIENhcmxvIGFuYWx5c2lzXG4gICAgICAgIH0sXG4gICAgICAgIHByaWNlQXRDcm9zc292ZXI6IHtcbiAgICAgICAgICBsb3c6IHNjZW5hcmlvc1swXS5jcm9zc292ZXJZZWFyID8gYmFzZVRyYWplY3Rvcnlbc2NlbmFyaW9zWzBdLmNyb3Nzb3ZlclllYXIgLSAyMDI1XS5vcmJpdC5ncHVIb3VyUHJpY2luZy5zdGFuZGFyZC5wcmljZVBlckdwdUhvdXIgOiAwLFxuICAgICAgICAgIG1pZDogc2NlbmFyaW9zWzFdLmNyb3Nzb3ZlclllYXIgPyBiYXNlVHJhamVjdG9yeVtzY2VuYXJpb3NbMV0uY3Jvc3NvdmVyWWVhciAtIDIwMjVdLm9yYml0LmdwdUhvdXJQcmljaW5nLnN0YW5kYXJkLnByaWNlUGVyR3B1SG91ciA6IDAsXG4gICAgICAgICAgaGlnaDogc2NlbmFyaW9zWzJdLmNyb3Nzb3ZlclllYXIgPyBiYXNlVHJhamVjdG9yeVtzY2VuYXJpb3NbMl0uY3Jvc3NvdmVyWWVhciAtIDIwMjVdLm9yYml0LmdwdUhvdXJQcmljaW5nLnN0YW5kYXJkLnByaWNlUGVyR3B1SG91ciA6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIHByb2JhYmlsaXR5QnlZZWFyOiBtb250ZUNhcmxvUmVzdWx0LnByb2JhYmlsaXR5QnlZZWFyLCAvLyBQcm9iYWJpbGl0eSBvcmJpdGFsIGNoZWFwZXIgYnkgeWVhciBYXG4gICAgICB9LFxuICAgICAgbWFya2V0Q29tcGFyaXNvbixcbiAgICAgIHJlZ3VsYXRvcnlJbXBhY3Q6IDE1MDAsXG4gICAgICBzY2VuYXJpb0ltcGFjdFxuICAgIH0sXG4gICAgdmFsaWRhdGlvbixcbiAgICBncm91bmRTY2VuYXJpbzogZ3JvdW5kU2NlbmFyaW9MYWJlbFxuICB9O1xufVxuIl0sIm5hbWVzIjpbImNvbXB1dGVQaHlzaWNzQ29zdCIsIkdST1VORF9TQ0VOQVJJT1MiLCJnZXRMYXVuY2hDb3N0UGVyS2ciLCJzdGVwTGF1bmNoTGVhcm5pbmciLCJnZXRTdGF0aWNQYXJhbXMiLCJydW5Nb250ZUNhcmxvQ3Jvc3NvdmVyIiwiZXh0cmFjdEJhc2VQYXJhbXMiLCJmaW5kQ3Jvc3NvdmVyWWVhciIsInRyYWplY3RvcnkiLCJjcm9zc2luZyIsImZpbmQiLCJkIiwiZ3JvdW5kRWZmZWN0aXZlQ29zdCIsImdyb3VuZCIsInRvdGFsQ29zdFBlclBmbG9wWWVhckVmZmVjdGl2ZSIsInRvdGFsQ29zdFBlclBmbG9wWWVhciIsImNvbnN0cmFpbnRzIiwiZGVsYXlQZW5hbHR5Iiwic2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyIiwib3JiaXRDb3N0Iiwib3JiaXQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInllYXIiLCJmaW5kQ3Jvc3NvdmVyWWVhckVmZmVjdGl2ZVBmbG9wIiwiY2FsY3VsYXRlTWFya2V0U2hhcmUiLCJvcmJpdGFsQ29zdFBlclBmbG9wIiwiZ3JvdW5kQ29zdFBlclBmbG9wIiwidG90YWxEZW1hbmRHVyIsIm9yYml0YWxGZWFzaWJsZSIsImdyb3VuZEZlYXNpYmxlIiwib3JiaXRhbENvc3RBY2NvdW50aW5nVmFsaWQiLCJncm91bmRDb3N0QWNjb3VudGluZ1ZhbGlkIiwiZGVtYW5kR1ciLCJiYWNrbG9nR1ciLCJidWlsZFJhdGVHV3lyIiwiYXZnV2FpdFllYXJzIiwib3JiaXRNYXhEZXBsb3lhYmxlQ29tcHV0ZUdXIiwib3JiaXRhbEFjdHVhbGx5RmVhc2libGUiLCJncm91bmRBY3R1YWxseUZlYXNpYmxlIiwib3JiaXRhbFNoYXJlRnJhYyIsIm9yYml0YWxDYXBhY2l0eUdXIiwib3JiaXRhbFJldmVudWUiLCJncm91bmRTaGFyZUZyYWMiLCJncm91bmRDYXBhY2l0eUdXIiwiZGVidWciLCJzaGFyZUNvbnZlbnRpb24iLCJncm91bmRSZXZlbnVlIiwiZGVtYW5kIiwiYmFja2xvZ0dXQWN0dWFsIiwiYnVpbGRSYXRlR1d5ckFjdHVhbCIsImF2Z1dhaXRZZWFyc0FjdHVhbCIsImdyb3VuZEhhc1NldmVyZVF1ZXVlIiwiZ3JvdW5kRmVhc2libGVHVyIsIk1hdGgiLCJtYXgiLCJvcmJpdEZlYXNpYmxlR1ciLCJtaW4iLCJtYXhTZXJ2YWJsZSIsImNvc3RSYXRpbyIsImxvZ2l0RmFjdG9yIiwiZXhwIiwib3JiaXRhbFNoYXJlRnJhY0Rlc2lyZWQiLCJncm91bmRTaGFyZUZyYWNEZXNpcmVkIiwib3JiaXRTZXJ2ZWQiLCJncm91bmRTZXJ2ZWQiLCJyZW1haW5kZXIiLCJvcmJpdFJvb20iLCJncm91bmRSb29tIiwiYWRkVG9PcmJpdCIsInRvdGFsU2VydmVkR1ciLCJncm91bmRTZXJ2ZWRDb21wdXRlR1ciLCJvcmJpdFNlcnZlZENvbXB1dGVHVyIsImdyb3VuZEZlYXNpYmxlQ29tcHV0ZUdXIiwib3JiaXRGZWFzaWJsZUNvbXB1dGVHVyIsInJldmVudWVQZXJHVyIsIkVycm9yIiwic2hhcmVTdW0iLCJhYnMiLCJkZW1hbmRDb21wdXRlR1ciLCJwcm9qZWN0TWFya2V0UHJpY2UiLCJiYXNlUHJpY2UiLCJiYXNlWWVhciIsInRhcmdldFllYXIiLCJhbm51YWxEZWNsaW5lUmF0ZSIsInllYXJzIiwicG93IiwiTUFSS0VUX1BST1ZJREVSUyIsIm5hbWUiLCJwcmljZSIsImRlY2xpbmUiLCJJVF9HV18yMDI1IiwiSVRfR1dfMjA0MF9UQVJHRVQiLCJJVF9HV18yMDYwX1RBUkdFVCIsIlIxIiwibG9nIiwiUjIiLCJjYWxjdWxhdGVSZXNwb25zaXZlRGVtYW5kIiwiZ3JvdW5kUHJpY2VQZXJHcHVIb3VyIiwib3JiaXRhbFByaWNlUGVyR3B1SG91ciIsInByZXZEZW1hbmRTdGF0ZSIsInllYXJzRnJvbTIwMjUiLCJncm93dGhSYXRlIiwidGFwZXIiLCJlZmZlY3RpdmVHcm93dGgiLCJiYXNlbGluZUdXIiwiU01PT1RISU5HX0FMUEhBIiwiYmFzZWxpbmVQcmljZSIsInByaWNlUmF0aW8iLCJwcmljZUVsYXN0aWNpdHkiLCJwcmljZUZhY3RvclJhdyIsInByZXZQcmljZUZhY3RvciIsImVmZmVjdGl2ZUdXIiwicHJpY2VGYWN0b3IiLCJ3YWl0RWxhc3RpY2l0eSIsIndhaXRGYWN0b3JSYXciLCJwcmV2V2FpdEZhY3RvciIsIndhaXRGYWN0b3IiLCJlZmZlY3RpdmVHV1JhdyIsIm1pbkRlbWFuZEZyYWMiLCJncm91bmRPcmJpdGFsUmF0aW8iLCJ0YXJnZXRPcmJpdGFsU2hhcmUiLCJwcmV2T3JiaXRhbFNoYXJlIiwib3JiaXRhbFNoYXJlIiwibWF4U2hhcmVDaGFuZ2VQZXJZZWFyIiwic2hhcmVDaGFuZ2UiLCJzbW9vdGhlZENoYW5nZSIsInNpZ24iLCJncm91bmREZW1hbmRHVyIsInByb2Nlc3MiLCJjb25zb2xlIiwidG9GaXhlZCIsInVuZGVmaW5lZCIsIm1heERlbWFuZENoYW5nZVBlclllYXIiLCJkZW1hbmRDaGFuZ2VSYXRpbyIsImNsYW1wZWQiLCJvcmJpdGFsRGVtYW5kR1ciLCJnZXRJVExvYWRHVyIsInllYXJzRnJvbTIwNDAiLCJnZXRGYWNpbGl0eUxvYWRHVyIsInB1ZSIsIml0TG9hZEdXIiwiZ2V0RGVtYW5kTmV3R1ciLCJmYWNpbGl0eUdXIiwiZmFjaWxpdHlHV1ByZXYiLCJnZXREZW1hbmRQcm9qZWN0aW9uIiwiY29tcHV0ZVRyYWplY3RvcnkiLCJvcHRpb25zIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJmaXJzdENhcFllYXIiLCJsYXVuY2hMZWFybmluZ1N0YXRlIiwiQkFTRUxJTkVfTUFTU19LRyIsIkxBVU5DSF9DT1NUXzBfUEVSX0tHIiwicHJldlllYXJCcmVha2Rvd24iLCJidWlsZG91dFN0YXRlIiwibW9iaWxpemF0aW9uU3RhdGUiLCJicmVha2Rvd24iLCJwYXJhbXMiLCJtb2RlIiwicGFyYW1zQnlZZWFyIiwibGF1bmNoQ29zdFBlcktnIiwibGF1bmNoQ29zdEtnIiwicGFyYW1zV2l0aExhdW5jaENvc3QiLCJ1c2VMYXVuY2hMZWFybmluZyIsImNvbXB1dGVQb3dlck1XIiwidGFyZ2V0R1ciLCJtYXNzUGVyTVciLCJtYXNzRGVtYW5kZWRLZyIsImxhdW5jaExlYXJuaW5nUmVzdWx0IiwiYmFzZWxpbmVNYXNzS2ciLCJsYXVuY2hDb3N0MFBlcktnIiwibGVhcm5pbmdSYXRlIiwibWF4RmxpZ2h0c1BlclllYXIiLCJwYXlsb2FkUGVyRmxpZ2h0S2ciLCJzdGF0ZSIsImdyb3VuZFB1ZSIsInB1ZUdyb3VuZCIsInByZXZHcm91bmRQcmljZSIsImdwdUhvdXJQcmljaW5nIiwic3RhbmRhcmQiLCJwcmljZVBlckdwdUhvdXIiLCJwcmV2T3JiaXRhbFByaWNlIiwicHJldkF2Z1dhaXQiLCJzdXBwbHlNZXRyaWNzIiwiZGVtYW5kU3RhdGUiLCJwYXJhbXNXaXRoTW9iaWxpemF0aW9uIiwicHJldk1vYmlsaXphdGlvblN0YXRlIiwicmVzcG9uc2l2ZURlbWFuZEdXIiwib3JiaXRhbFN1YnN0aXR1dGlvbkdXIiwiaHlicmlkQnJlYWtkb3duIiwiY29uc3RyYWludEJyZWFrZG93biIsImNhcFllYXIiLCJ0aGlzQ2FwWWVhciIsImFjdHVhbEdyb3VuZFB1ZSIsImJ1aWxkb3V0RGVidWciLCJJbmZpbml0eSIsImNvc3RBY2NvdW50aW5nVmFsaWQiLCJvcmJpdGFsQ2FwYWNpdHlHV19mcm9tU2F0cyIsImNvbnN0ZWxsYXRpb24iLCJkZXNpZ24iLCJudW1TYXRlbGxpdGVzIiwiY29tcHV0ZVBlclNhdEt3IiwiZXhwZWN0ZWRHVyIsImVycm9yIiwiY2hhcnRQQiIsIm1ldGFkYXRhIiwiY2hhcnRJbnB1dHMiLCJwb3dlckJ1aWxkb3V0IiwiY2hhcnRCYWNrbG9nIiwiYmFja2xvZ0d3IiwiY2hhcnRBdmdXYWl0IiwiY2hhcnRCdWlsZFJhdGUiLCJtYXhCdWlsZFJhdGVHd1llYXIiLCJiYWNrbG9nRnJvbUdyb3VuZCIsImJhY2tsb2dGcm9tQnVpbGRvdXQiLCJidWlsZFJhdGVGcm9tQnVpbGRvdXQiLCJidWlsZFJhdGVGcm9tU3VwcGx5IiwiYXZnV2FpdEZyb21Hcm91bmQiLCJhdmdXYWl0RnJvbUJ1aWxkb3V0IiwidGltZVRvUG93ZXJZZWFycyIsImF2Z1dhaXRGcm9tU3VwcGx5IiwicGlwZWxpbmVHdyIsIm9yYml0TWF4RGVwbG95YWJsZUNvbXB1dGVHV0J5WWVhciIsIm9yYml0YWxGZWFzaWJsZUZvclNoYXJlIiwibWFya2V0QW5hbHlzaXMiLCJtYXJrZXQiLCJtYXJrZXREZW1hbmQiLCJtYXJrZXREZWJ1Z0RlbWFuZCIsImJ1aWxkb3V0RGVtYW5kIiwiZGVtYW5kTmV3R1ciLCJjYXBhY2l0eUdXIiwicGlwZWxpbmVHVyIsInB1c2giLCJnZW5lcmF0ZUZpbmFsQW5hbHlzaXMiLCJiYXNlVHJhamVjdG9yeSIsImJhc2VDcm9zc292ZXIiLCJiYXNlQ3Jvc3NvdmVyRWZmZWN0aXZlUGZsb3AiLCJiYXNlUGFyYW1zIiwicGFyYW1ldGVyc1RvVGVzdCIsImtleSIsInZhbHVlcyIsInllYXJUb01vZGlmeSIsInNlbnNpdGl2aXRpZXMiLCJtYXAiLCJwIiwiY3Jvc3NvdmVyWWVhcnMiLCJ2YWwiLCJ0ZXN0VHJhamVjdG9yeSIsInkiLCJ2YWxpZFllYXJzIiwiZmlsdGVyIiwibWF4RGVsdGEiLCJpbXBhY3QiLCJwYXJhbWV0ZXIiLCJiYXNlVmFsdWUiLCJ0ZXN0VmFsdWVzIiwic2NlbmFyaW9zIiwiZGVzY3JpcHRpb24iLCJrZXlBc3N1bXB0aW9ucyIsImNyb3Nzb3ZlclllYXIiLCJ1c2VSYWRIYXJkQ2hpcHMiLCJncm91bmRTY2VuYXJpbyIsIm1hcmtldENvbXBhcmlzb24iLCJwcm9qZWN0ZWRQcmljZXMiLCJvcmJpdGFsQmVhdHNZZWFyIiwicHJvamVjdGVkIiwicHJvdmlkZXIiLCJjdXJyZW50UHJpY2UiLCJjdXJyZW50WWVhciIsInByb2plY3RlZERlY2xpbmUiLCJzZWxlY3RlZFNjZW5hcmlvIiwiZ3JvdW5kU2NlbmFyaW9MYWJlbCIsImNvbnN0cmFpbnRNdWx0aXBsaWVyMjA0MCIsImFzc3VtcHRpb25zIiwiZ3JpZEdyb3d0aFJhdGUiLCJjb29saW5nR3Jvd3RoUmF0ZSIsImNvbnN0cmFpbnRDYXAiLCJsYXN0WWVhciIsImZpcnN0WWVhciIsImFsbENoZWNrcyIsInBhc3NlZCIsInZhbHVlIiwiY29zdEFjY291bnRpbmdFcnJvclBjdCIsImV4cGVjdGVkIiwiY2FwYWNpdHlGYWN0b3IiLCJ2YWxpZGF0aW9uIiwiY29zdEFjY291bnRpbmdFcnJvciIsInRyYWplY3RvcnlNb25vdG9uaWMiLCJwYXJhbWV0ZXJzSW5SYW5nZSIsImNyb3Nzb3ZlckNvbnNpc3RlbnQiLCJjcm9zc292ZXJZZWFyU3RhbmRhcmQiLCJwcmljZUF0Q3Jvc3NvdmVyT3JiaXRhbCIsInByaWNlQXRDcm9zc292ZXJHcm91bmQiLCJhY3RpdmVUb2dnbGVzIiwiZWxvblNjZW5hcmlvRW5hYmxlZCIsImdsb2JhbExhdGVuY3lSZXF1aXJlbWVudEVuYWJsZWQiLCJzcGFjZU1hbnVmYWN0dXJpbmdFbmFibGVkIiwiYWlXaW50ZXJFbmFibGVkIiwiYmFzZWxpbmVUcmFqZWN0b3J5IiwiYmFzZWxpbmVDcm9zc292ZXIiLCJzY2VuYXJpb0ltcGFjdCIsImN1cnJlbnRDcm9zc292ZXIiLCJjcm9zc292ZXJEZWx0YSIsImJhc2VQYXJhbXNGb3JNQyIsIm1vbnRlQ2FybG9SZXN1bHQiLCJ2ZXJzaW9uIiwiZ2VuZXJhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1bml0cyIsInBhcmFtZXRlcnMiLCJhbmFseXNpcyIsImNyb3Nzb3ZlciIsIm9yYml0YWxQcmljZSIsImdyb3VuZFByaWNlIiwibWFya2V0UG9zaXRpb24iLCJjcm9zc292ZXJEZXRhaWxzIiwic2Vuc2l0aXZpdHkiLCJiYXNlQ2FzZSIsIm9yYml0YWxQcmljZUF0Q3Jvc3NvdmVyIiwiZ3JvdW5kUHJpY2VBdENyb3Nzb3ZlciIsImNvbmZpZGVuY2UiLCJwMTAiLCJwNTAiLCJwOTAiLCJwcmljZUF0Q3Jvc3NvdmVyIiwibG93IiwibWlkIiwiaGlnaCIsInByb2JhYmlsaXR5QnlZZWFyIiwicmVndWxhdG9yeUltcGFjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/trajectory.ts\n"));

/***/ })

});