"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/compare/page",{

/***/ "(app-pages-browser)/./app/lib/model/ground_ramping_mobilization.ts":
/*!******************************************************!*\
  !*** ./app/lib/model/ground_ramping_mobilization.ts ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_MOBILIZATION_PARAMS: function() { return /* binding */ DEFAULT_MOBILIZATION_PARAMS; },\n/* harmony export */   calculateBuildRateGWyr: function() { return /* binding */ calculateBuildRateGWyr; },\n/* harmony export */   calculateDemandGW: function() { return /* binding */ calculateDemandGW; },\n/* harmony export */   calculatePriceResponsiveBuildRateGWyr: function() { return /* binding */ calculatePriceResponsiveBuildRateGWyr; },\n/* harmony export */   calculatePriceResponsiveDemandGW: function() { return /* binding */ calculatePriceResponsiveDemandGW; },\n/* harmony export */   stepMobilizationState: function() { return /* binding */ stepMobilizationState; }\n/* harmony export */ });\n/**\n * Ground Ramping Mobilization Model\n * \n * Models demand growth with price-responsive demand and buildout capacity\n * ramping with investment response. Tracks capacity evolution, pipeline, backlog,\n * and wait times.\n * \n * NEW: Price-responsive demand and investment-responsive buildout (replaces fixed anchors)\n */ /**\n * Calculate price-responsive demand GW\n * \n * NEW: Demand responds to prices, wait times, and orbital substitution\n * Replaces fixed anchors with economic feedback\n */ function calculatePriceResponsiveDemandGW(year, groundPricePerGpuHour, orbitalPricePerGpuHour, avgWaitYears, params) {\n    let pue = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1.3;\n    // Base demand with organic growth (tapered, not exponential forever)\n    const yearsFrom2025 = year - 2025;\n    const growthTaper = Math.tanh(yearsFrom2025 / 30); // Tapers after ~30 years\n    const baseDemand = params.baseDemand2025GW * Math.pow(1 + params.organicGrowthRate, yearsFrom2025 * growthTaper);\n    // Price elasticity: higher prices reduce demand\n    const baselinePrice = 3.50; // $/GPU-hr baseline\n    const priceRatio = groundPricePerGpuHour / baselinePrice;\n    const priceFactor = Math.pow(priceRatio, params.priceElasticity);\n    // Wait elasticity: longer waits reduce demand\n    const waitFactor = Math.exp(-avgWaitYears * params.waitElasticity / 5);\n    // Orbital substitution: if orbital cheaper, demand shifts\n    const orbitalAdvantage = groundPricePerGpuHour / Math.max(orbitalPricePerGpuHour, 0.01);\n    const substitutionFactor = orbitalAdvantage > params.orbitalSubstitutionThreshold ? 1 / (1 + 0.5 * (orbitalAdvantage - params.orbitalSubstitutionThreshold)) : 1.0;\n    let demandGW = baseDemand * priceFactor * waitFactor * substitutionFactor;\n    // Apply PUE if demand is IT load (not facility load)\n    // Note: This function assumes facility load, so multiply by PUE if needed\n    // For now, return facility load (demand already includes PUE in baseDemand2025GW)\n    return Math.max(0, demandGW);\n}\n/**\n * Legacy function: Calculate demand GW using piecewise exponential to hit anchors\n * \n * DEPRECATED: Use calculatePriceResponsiveDemandGW instead\n * Kept for backward compatibility\n */ function calculateDemandGW(year, params) {\n    let pue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1.3;\n    const { demandAnchorsGW, demandIsFacilityLoad, demandCurve } = params;\n    const demand2025 = demandAnchorsGW[2025];\n    const demand2040 = demandAnchorsGW[2040];\n    const demand2060 = demandAnchorsGW[2060];\n    if (demandCurve !== \"piecewise_exponential\") {\n        throw new Error(\"Unsupported demandCurve: \".concat(demandCurve, \". Only 'piecewise_exponential' is supported.\"));\n    }\n    if (year < 2025) {\n        return demand2025;\n    }\n    let demandGW;\n    if (year <= 2040) {\n        // Phase 1: 2025-2040\n        // r1 = ln(demand2040 / demand2025) / (2040-2025)\n        const r1 = Math.log(demand2040 / demand2025) / (2040 - 2025);\n        const yearsFrom2025 = year - 2025;\n        demandGW = demand2025 * Math.exp(r1 * yearsFrom2025);\n    } else {\n        // Phase 2: 2040-2060\n        // r2 = ln(demand2060 / demand2040) / (2060-2040)\n        const r2 = Math.log(demand2060 / demand2040) / (2060 - 2040);\n        const yearsFrom2040 = year - 2040;\n        demandGW = demand2040 * Math.exp(r2 * yearsFrom2040);\n    }\n    // Apply PUE if demand is IT load (not facility load)\n    if (!demandIsFacilityLoad) {\n        demandGW = demandGW * pue;\n    }\n    // Hard asserts in dev mode\n    if (true) {\n        if (year === 2040) {\n            const actual2040 = demandGW;\n            const error2040 = Math.abs(actual2040 - demand2040) / demand2040;\n            if (error2040 >= 0.03) {\n                throw new Error(\"[DEMAND ANCHOR FAIL] demandGw(2040)=\".concat(actual2040.toFixed(2), \" GW, \") + \"expected=\".concat(demand2040, \" GW, error=\").concat((error2040 * 100).toFixed(2), \"% >= 3%\"));\n            }\n        }\n        if (year === 2060) {\n            if (demandGW < 2000) {\n                throw new Error(\"[DEMAND ANCHOR FAIL] demandGw(2060)=\".concat(demandGW.toFixed(2), \" GW < 2000 GW. \") + \"Must be >= 2000 GW (multi-TW target).\");\n            }\n        }\n    }\n    return demandGW;\n}\n/**\n * Calculate price-responsive buildout rate\n * \n * NEW: Buildout responds to margins and backlog\n * Replaces fixed anchors with investment feedback\n */ function calculatePriceResponsiveBuildRateGWyr(year, prevBuildRate, groundMargin, backlogGW, params) {\n    // Base growth (supply chain improvement)\n    const yearsFrom2025 = year - 2025;\n    const baseGrowth = Math.pow(1.03, yearsFrom2025); // 3% organic improvement\n    const baseBuildRate = params.baseBuildRate2025GWyr * baseGrowth;\n    // Investment response: higher margins attract more capital\n    const baselineMargin = 0.20; // 20% baseline margin\n    const marginRatio = groundMargin / baselineMargin;\n    const investmentMultiplier = 1 + params.investmentElasticity * Math.max(0, marginRatio - 1);\n    // Backlog response: higher backlog attracts more investment\n    const backlogMultiplier = 1 + params.backlogResponseK * Math.min(1, backlogGW / 100);\n    // Target build rate\n    let targetRate = baseBuildRate * investmentMultiplier * backlogMultiplier;\n    // Physical ceiling\n    targetRate = Math.min(targetRate, params.maxBuildRateGWyr);\n    // Ramp limit (can't increase faster than 25%/year)\n    const maxRate = prevBuildRate * (1 + params.rampLimitPerYear);\n    const minRate = prevBuildRate * (1 - params.rampLimitPerYear * 0.5); // Slower to decrease\n    targetRate = Math.max(minRate, Math.min(maxRate, targetRate));\n    return Math.max(0, targetRate);\n}\n/**\n * Legacy function: Smooth interpolation for buildout anchors\n * \n * DEPRECATED: Use calculatePriceResponsiveBuildRateGWyr instead\n * Kept for backward compatibility\n */ function calculateBuildRateGWyr(year, params) {\n    const { buildoutAnchorsGWyr, buildoutSmoothingYears } = params;\n    const anchors = buildoutAnchorsGWyr;\n    // Find surrounding anchors\n    const anchorYears = Object.keys(anchors).map(Number).sort((a, b)=>a - b);\n    // Before first anchor: use first anchor value\n    if (year <= anchorYears[0]) {\n        return anchors[anchorYears[0]];\n    }\n    // After last anchor: use last anchor value\n    if (year >= anchorYears[anchorYears.length - 1]) {\n        return anchors[anchorYears[anchorYears.length - 1]];\n    }\n    // Find surrounding anchors\n    let lowerYear = anchorYears[0];\n    let upperYear = anchorYears[anchorYears.length - 1];\n    for(let i = 0; i < anchorYears.length - 1; i++){\n        if (year >= anchorYears[i] && year <= anchorYears[i + 1]) {\n            lowerYear = anchorYears[i];\n            upperYear = anchorYears[i + 1];\n            break;\n        }\n    }\n    const lowerRate = anchors[lowerYear];\n    const upperRate = anchors[upperYear];\n    // Exponential interpolation for buildout ramp\n    const t = (year - lowerYear) / (upperYear - lowerYear);\n    const buildRate = lowerRate * Math.pow(upperRate / lowerRate, t);\n    // Apply smoothing: moving average over smoothing window\n    if (buildoutSmoothingYears > 0) {\n        const smoothingWindow = buildoutSmoothingYears;\n        let smoothedSum = buildRate;\n        let count = 1;\n        // Helper function to calculate unsmoothed rate\n        const getUnsmoothedRate = (y)=>{\n            if (y <= anchorYears[0]) return anchors[anchorYears[0]];\n            if (y >= anchorYears[anchorYears.length - 1]) return anchors[anchorYears[anchorYears.length - 1]];\n            let lower = anchorYears[0];\n            let upper = anchorYears[anchorYears.length - 1];\n            for(let i = 0; i < anchorYears.length - 1; i++){\n                if (y >= anchorYears[i] && y <= anchorYears[i + 1]) {\n                    lower = anchorYears[i];\n                    upper = anchorYears[i + 1];\n                    break;\n                }\n            }\n            const lowerRate = anchors[lower];\n            const upperRate = anchors[upper];\n            const t = (y - lower) / (upper - lower);\n            return lowerRate * Math.pow(upperRate / lowerRate, t);\n        };\n        for(let offset = 1; offset <= Math.floor(smoothingWindow / 2); offset++){\n            const prevYear = year - offset;\n            const nextYear = year + offset;\n            if (prevYear >= anchorYears[0]) {\n                const prevRate = getUnsmoothedRate(prevYear);\n                smoothedSum += prevRate;\n                count++;\n            }\n            if (nextYear <= anchorYears[anchorYears.length - 1]) {\n                const nextRate = getUnsmoothedRate(nextYear);\n                smoothedSum += nextRate;\n                count++;\n            }\n        }\n        return smoothedSum / count;\n    }\n    return buildRate;\n}\n/**\n * Calculate bottleneck rate from anchors (same interpolation as buildout)\n */ function calculateBottleneckRateGWyr(year, anchors) {\n    const anchorYears = [\n        2025,\n        2030,\n        2040,\n        2060\n    ];\n    // Before first anchor: use first anchor value\n    if (year <= anchorYears[0]) {\n        return anchors[2025];\n    }\n    // After last anchor: use last anchor value\n    if (year >= anchorYears[anchorYears.length - 1]) {\n        return anchors[2060];\n    }\n    // Find surrounding anchors\n    let lowerYear = anchorYears[0];\n    let upperYear = anchorYears[anchorYears.length - 1];\n    for(let i = 0; i < anchorYears.length - 1; i++){\n        if (year >= anchorYears[i] && year <= anchorYears[i + 1]) {\n            lowerYear = anchorYears[i];\n            upperYear = anchorYears[i + 1];\n            break;\n        }\n    }\n    const lowerRate = anchors[lowerYear];\n    const upperRate = anchors[upperYear];\n    // Exponential interpolation\n    const t = (year - lowerYear) / (upperYear - lowerYear);\n    return lowerRate * Math.pow(upperRate / lowerRate, t);\n}\n/**\n * Step mobilization state forward one year\n */ function stepMobilizationState(prevState, params, year) {\n    let pue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1.3, retirementsGW = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, orbitalSubstitutionGW = arguments.length > 5 ? arguments[5] : void 0, responsiveDemandGW // Optional: responsive demand (overrides hardcoded calculateDemandGW)\n     = arguments.length > 6 ? arguments[6] : void 0;\n    // Calculate demand: use responsive demand if provided, otherwise use hardcoded\n    const demandGW = responsiveDemandGW !== undefined ? responsiveDemandGW * pue // Convert IT load to facility load\n     : calculateDemandGW(year, params, pue);\n    var _prevState_demandGW;\n    const demandGWPrev = (_prevState_demandGW = prevState === null || prevState === void 0 ? void 0 : prevState.demandGW) !== null && _prevState_demandGW !== void 0 ? _prevState_demandGW : responsiveDemandGW !== undefined ? responsiveDemandGW * pue : calculateDemandGW(year - 1, params, pue);\n    const demandNewGW = Math.max(0, demandGW - demandGWPrev);\n    // Calculate build rate candidate (from anchors)\n    let buildRateCandidate = calculateBuildRateGWyr(year, params);\n    // NEW: If ground demand is falling (due to orbital substitution or price elasticity),\n    // buildout should slow down (no one builds capacity for declining market)\n    const demandGrowthRateActual = (prevState === null || prevState === void 0 ? void 0 : prevState.demandGW) ? (demandGW - prevState.demandGW) / Math.max(prevState.demandGW, 1) : 0;\n    if (demandGrowthRateActual < 0) {\n        // Demand is shrinking - reduce buildout\n        const contractionFactor = Math.max(0.5, 1 + demandGrowthRateActual * 2); // At most 50% reduction\n        buildRateCandidate = buildRateCandidate * contractionFactor; // Reassign to let variable\n    }\n    var _params_bottleneckMode;\n    // Apply bottleneck constraints if enabled\n    const bottleneckMode = (_params_bottleneckMode = params.bottleneckMode) !== null && _params_bottleneckMode !== void 0 ? _params_bottleneckMode : \"min_of_bottlenecks\";\n    let buildRateGWyr = buildRateCandidate;\n    let bottleneckRateGWyr;\n    let limitingBottleneck = \"candidate\";\n    if (bottleneckMode === \"min_of_bottlenecks\" && params.bottleneckAnchorsGWyr) {\n        const { transformers, substations, tx, generation } = params.bottleneckAnchorsGWyr;\n        const transformersRate = calculateBottleneckRateGWyr(year, transformers);\n        const substationsRate = calculateBottleneckRateGWyr(year, substations);\n        const txRate = calculateBottleneckRateGWyr(year, tx);\n        const generationRate = calculateBottleneckRateGWyr(year, generation);\n        // Find minimum bottleneck\n        bottleneckRateGWyr = Math.min(transformersRate, substationsRate, txRate, generationRate);\n        // Determine which bottleneck is limiting\n        if (bottleneckRateGWyr === transformersRate) {\n            limitingBottleneck = \"transformers\";\n        } else if (bottleneckRateGWyr === substationsRate) {\n            limitingBottleneck = \"substations\";\n        } else if (bottleneckRateGWyr === txRate) {\n            limitingBottleneck = \"tx\";\n        } else if (bottleneckRateGWyr === generationRate) {\n            limitingBottleneck = \"generation\";\n        }\n        // Effective build rate is minimum of candidate and bottleneck\n        buildRateGWyr = Math.min(buildRateCandidate, bottleneckRateGWyr);\n    } else {\n        limitingBottleneck = \"none\";\n    }\n    var _params_rampLimitFracPerYear;\n    // Apply ramp limiter (prevent sudden jumps)\n    const rampLimitFrac = (_params_rampLimitFracPerYear = params.rampLimitFracPerYear) !== null && _params_rampLimitFracPerYear !== void 0 ? _params_rampLimitFracPerYear : 0.25;\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.buildRateGWyr) !== undefined) {\n        const prevRate = prevState.buildRateGWyr;\n        const minRate = prevRate * (1 - rampLimitFrac);\n        const maxRate = prevRate * (1 + rampLimitFrac);\n        buildRateGWyr = Math.max(minRate, Math.min(maxRate, buildRateGWyr));\n    }\n    var _prevState_capacityGW;\n    // Calculate capacity evolution\n    // capacityGw(t) = capacityGw(t-1) + buildRateGwYear(t) - retirementsGw(t)\n    const capacityGWPrev = (_prevState_capacityGW = prevState === null || prevState === void 0 ? void 0 : prevState.capacityGW) !== null && _prevState_capacityGW !== void 0 ? _prevState_capacityGW : 0;\n    const capacityGW = capacityGWPrev + buildRateGWyr - retirementsGW;\n    // Calculate pipeline\n    // pipelineGw(t) = buildRateGwYear(t) * pipelineLeadTimeYears * pipelineFillFrac\n    const pipelineGW = buildRateGWyr * params.pipelineLeadTimeYears * params.pipelineFillFrac;\n    var _prevState_backlogGW;\n    // Calculate backlog\n    // backlogGw(t) = max(0, backlogGw(t-1) + demandNewGw(t) - buildableGw(t) - implicitBacklogDrain)\n    // NEW: Backlog can also be satisfied by demand shifting to orbital\n    // When demand shifts to orbital, \"implicit backlog drain\" occurs\n    // because customers who were waiting for ground now use orbital instead\n    const backlogGWPrev = (_prevState_backlogGW = prevState === null || prevState === void 0 ? void 0 : prevState.backlogGW) !== null && _prevState_backlogGW !== void 0 ? _prevState_backlogGW : 0;\n    const buildableGW = buildRateGWyr;\n    const implicitBacklogDrain = (orbitalSubstitutionGW !== null && orbitalSubstitutionGW !== void 0 ? orbitalSubstitutionGW : 0) * 0.5; // 50% of shifted demand was in backlog\n    const backlogGW = Math.max(0, backlogGWPrev + demandNewGW - buildableGW - implicitBacklogDrain);\n    // Hard assert: If demandNewGw(t) > buildRateGwYear(t), backlogGw must increase\n    if (true) {\n        if (demandNewGW > buildRateGWyr && backlogGW <= backlogGWPrev) {\n            throw new Error(\"[BUILDOUT INVARIANT] Year \".concat(year, \": demandNewGW=\").concat(demandNewGW.toFixed(2), \" > \") + \"buildRateGWyr=\".concat(buildRateGWyr.toFixed(2), \", but backlogGW=\").concat(backlogGW.toFixed(2), \" \") + \"<= prevBacklogGW=\".concat(backlogGWPrev.toFixed(2), \". Backlog must increase.\"));\n        }\n    }\n    // Calculate average wait time\n    // avgWaitYears(t) = backlogGw(t) / max(buildRateGwYear(t), 1e-9)\n    const EPS = 1e-9;\n    const avgWaitYears = backlogGW / Math.max(buildRateGWyr, EPS);\n    // Calculate growth rate (for debug)\n    let demandGrowthRate;\n    if (year <= 2040) {\n        demandGrowthRate = Math.log(params.demandAnchorsGW[2040] / params.demandAnchorsGW[2025]) / 15;\n    } else {\n        demandGrowthRate = Math.log(params.demandAnchorsGW[2060] / params.demandAnchorsGW[2040]) / 20;\n    }\n    return {\n        year,\n        demandGW,\n        demandNewGW,\n        buildRateGWyr,\n        capacityGW,\n        pipelineGW,\n        backlogGW,\n        avgWaitYears,\n        demandGrowthRate,\n        buildoutSmoothFactor: params.buildoutSmoothingYears,\n        bottleneckRateGWyr,\n        limitingBottleneck,\n        buildRateCandidate\n    };\n}\n/**\n * Default mobilization scenario parameters\n */ const DEFAULT_MOBILIZATION_PARAMS = {\n    demandAnchorsGW: {\n        2025: 120,\n        2040: 450,\n        2060: 3000\n    },\n    demandCurve: \"piecewise_exponential\",\n    demandIsFacilityLoad: true,\n    buildoutAnchorsGWyr: {\n        2025: 25,\n        2030: 60,\n        2040: 140,\n        2060: 220\n    },\n    buildoutSmoothingYears: 3,\n    pipelineLeadTimeYears: 3,\n    pipelineFillFrac: 1.5,\n    bottleneckMode: \"min_of_bottlenecks\",\n    bottleneckAnchorsGWyr: {\n        transformers: {\n            2025: 30,\n            2030: 50,\n            2040: 100,\n            2060: 180\n        },\n        substations: {\n            2025: 35,\n            2030: 55,\n            2040: 110,\n            2060: 200\n        },\n        tx: {\n            2025: 40,\n            2030: 65,\n            2040: 130,\n            2060: 250\n        },\n        generation: {\n            2025: 50,\n            2030: 80,\n            2040: 160,\n            2060: 300\n        }\n    },\n    rampLimitFracPerYear: 0.25\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX3JhbXBpbmdfbW9iaWxpemF0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Ozs7OztDQVFDLEdBbUVEOzs7OztDQUtDLEdBQ00sU0FBU0EsaUNBQ2RDLElBQVksRUFDWkMscUJBQTZCLEVBQzdCQyxzQkFBOEIsRUFDOUJDLFlBQW9CLEVBQ3BCQyxNQUFvQjtRQUNwQkMsTUFBQUEsaUVBQWM7SUFFZCxxRUFBcUU7SUFDckUsTUFBTUMsZ0JBQWdCTixPQUFPO0lBQzdCLE1BQU1PLGNBQWNDLEtBQUtDLElBQUksQ0FBQ0gsZ0JBQWdCLEtBQUsseUJBQXlCO0lBQzVFLE1BQU1JLGFBQWFOLE9BQU9PLGdCQUFnQixHQUFHSCxLQUFLSSxHQUFHLENBQUMsSUFBSVIsT0FBT1MsaUJBQWlCLEVBQUVQLGdCQUFnQkM7SUFFcEcsZ0RBQWdEO0lBQ2hELE1BQU1PLGdCQUFnQixNQUFNLG9CQUFvQjtJQUNoRCxNQUFNQyxhQUFhZCx3QkFBd0JhO0lBQzNDLE1BQU1FLGNBQWNSLEtBQUtJLEdBQUcsQ0FBQ0csWUFBWVgsT0FBT2EsZUFBZTtJQUUvRCw4Q0FBOEM7SUFDOUMsTUFBTUMsYUFBYVYsS0FBS1csR0FBRyxDQUFDLENBQUNoQixlQUFlQyxPQUFPZ0IsY0FBYyxHQUFHO0lBRXBFLDBEQUEwRDtJQUMxRCxNQUFNQyxtQkFBbUJwQix3QkFBd0JPLEtBQUtjLEdBQUcsQ0FBQ3BCLHdCQUF3QjtJQUNsRixNQUFNcUIscUJBQXFCRixtQkFBbUJqQixPQUFPb0IsNEJBQTRCLEdBQzdFLElBQUssS0FBSSxNQUFPSCxDQUFBQSxtQkFBbUJqQixPQUFPb0IsNEJBQTRCLEtBQ3RFO0lBRUosSUFBSUMsV0FBV2YsYUFBYU0sY0FBY0UsYUFBYUs7SUFFdkQscURBQXFEO0lBQ3JELDBFQUEwRTtJQUMxRSxrRkFBa0Y7SUFFbEYsT0FBT2YsS0FBS2MsR0FBRyxDQUFDLEdBQUdHO0FBQ3JCO0FBRUE7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Q0Y7QUFFQTs7Q0FFQyxHQUNNLE1BQU02Qiw4QkFBMEQ7SUFDckUxRyxpQkFBaUI7UUFDZixNQUFNO1FBQ04sTUFBTTtRQUNOLE1BQU07SUFDUjtJQUNBRSxhQUFhO0lBQ2JELHNCQUFzQjtJQUN0Qm1DLHFCQUFxQjtRQUNuQixNQUFNO1FBQ04sTUFBTTtRQUNOLE1BQU07UUFDTixNQUFNO0lBQ1I7SUFDQUMsd0JBQXdCO0lBQ3hCNkQsdUJBQXVCO0lBQ3ZCQyxrQkFBa0I7SUFDbEJuQixnQkFBZ0I7SUFDaEJJLHVCQUF1QjtRQUNyQkMsY0FBYztZQUFFLE1BQU07WUFBSSxNQUFNO1lBQUksTUFBTTtZQUFLLE1BQU07UUFBSTtRQUN6REMsYUFBYTtZQUFFLE1BQU07WUFBSSxNQUFNO1lBQUksTUFBTTtZQUFLLE1BQU07UUFBSTtRQUN4REMsSUFBSTtZQUFFLE1BQU07WUFBSSxNQUFNO1lBQUksTUFBTTtZQUFLLE1BQU07UUFBSTtRQUMvQ0MsWUFBWTtZQUFFLE1BQU07WUFBSSxNQUFNO1lBQUksTUFBTTtZQUFLLE1BQU07UUFBSTtJQUN6RDtJQUNBTSxzQkFBc0I7QUFDeEIsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvbGliL21vZGVsL2dyb3VuZF9yYW1waW5nX21vYmlsaXphdGlvbi50cz80NDU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR3JvdW5kIFJhbXBpbmcgTW9iaWxpemF0aW9uIE1vZGVsXG4gKiBcbiAqIE1vZGVscyBkZW1hbmQgZ3Jvd3RoIHdpdGggcHJpY2UtcmVzcG9uc2l2ZSBkZW1hbmQgYW5kIGJ1aWxkb3V0IGNhcGFjaXR5XG4gKiByYW1waW5nIHdpdGggaW52ZXN0bWVudCByZXNwb25zZS4gVHJhY2tzIGNhcGFjaXR5IGV2b2x1dGlvbiwgcGlwZWxpbmUsIGJhY2tsb2csXG4gKiBhbmQgd2FpdCB0aW1lcy5cbiAqIFxuICogTkVXOiBQcmljZS1yZXNwb25zaXZlIGRlbWFuZCBhbmQgaW52ZXN0bWVudC1yZXNwb25zaXZlIGJ1aWxkb3V0IChyZXBsYWNlcyBmaXhlZCBhbmNob3JzKVxuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVtYW5kUGFyYW1zIHtcbiAgYmFzZURlbWFuZDIwMjVHVzogbnVtYmVyOyAgICAgICAgLy8gMTIwIEdXXG4gIG9yZ2FuaWNHcm93dGhSYXRlOiBudW1iZXI7ICAgICAgIC8vIDAuMTAgKDEwJSBDQUdSIGJhc2UpXG4gIHByaWNlRWxhc3RpY2l0eTogbnVtYmVyOyAgICAgICAgIC8vIC0wLjMgKDMwJSBkZW1hbmQgZHJvcCBwZXIgMTAwJSBwcmljZSBpbmNyZWFzZSlcbiAgd2FpdEVsYXN0aWNpdHk6IG51bWJlcjsgICAgICAgICAgLy8gLTAuMiAoMjAlIGRlbWFuZCBkcm9wIHBlciA1eXIgd2FpdClcbiAgb3JiaXRhbFN1YnN0aXR1dGlvblRocmVzaG9sZDogbnVtYmVyOyAvLyBQcmljZSByYXRpbyBhdCB3aGljaCBkZW1hbmQgc2hpZnRzIHRvIG9yYml0YWwgKGRlZmF1bHQgMS4yID0gMjAlIGNoZWFwZXIpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnVpbGRvdXRQYXJhbXMge1xuICBiYXNlQnVpbGRSYXRlMjAyNUdXeXI6IG51bWJlcjsgICAvLyAyNSBHVy95clxuICBtYXhCdWlsZFJhdGVHV3lyOiBudW1iZXI7ICAgICAgICAvLyAxNTAgR1cveXIgcGh5c2ljYWwgbGltaXRcbiAgaW52ZXN0bWVudEVsYXN0aWNpdHk6IG51bWJlcjsgICAgIC8vIDAuNSAoNTAlIG1vcmUgaW52ZXN0bWVudCBwZXIgMTAwJSBtYXJnaW4gaW5jcmVhc2UpXG4gIHJhbXBMaW1pdFBlclllYXI6IG51bWJlcjsgICAgICAgICAvLyAwLjI1ICgyNSUgbWF4IGluY3JlYXNlIHBlciB5ZWFyKVxuICBiYWNrbG9nUmVzcG9uc2VLOiBudW1iZXI7ICAgICAgICAgLy8gMC4zIChob3cgZmFzdCBidWlsZG91dCByZXNwb25kcyB0byBiYWNrbG9nKVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vYmlsaXphdGlvblNjZW5hcmlvUGFyYW1zIHtcbiAgZGVtYW5kQW5jaG9yc0dXOiB7XG4gICAgMjAyNTogbnVtYmVyO1xuICAgIDIwNDA6IG51bWJlcjtcbiAgICAyMDYwOiBudW1iZXI7XG4gIH07XG4gIGRlbWFuZEN1cnZlOiAncGllY2V3aXNlX2V4cG9uZW50aWFsJzsgLy8gQ3VydmUgdHlwZSAob25seSBwaWVjZXdpc2VfZXhwb25lbnRpYWwgc3VwcG9ydGVkKVxuICBkZW1hbmRJc0ZhY2lsaXR5TG9hZDogYm9vbGVhbjsgLy8gSWYgdHJ1ZSwgaW5jbHVkZXMgUFVFOyBpZiBmYWxzZSwgbXVsdGlwbHkgYnkgUFVFIGxhdGVyXG4gIGJ1aWxkb3V0QW5jaG9yc0dXeXI6IHtcbiAgICAyMDI1OiBudW1iZXI7XG4gICAgMjAzMDogbnVtYmVyO1xuICAgIDIwNDA6IG51bWJlcjtcbiAgICAyMDYwOiBudW1iZXI7XG4gIH07XG4gIGJ1aWxkb3V0U21vb3RoaW5nWWVhcnM6IG51bWJlcjsgLy8gU21vb3RoaW5nIHdpbmRvdyBmb3IgYnVpbGRvdXQgaW50ZXJwb2xhdGlvblxuICBwaXBlbGluZUxlYWRUaW1lWWVhcnM6IG51bWJlcjsgLy8gTGVhZCB0aW1lIGZvciBwaXBlbGluZSBjYWxjdWxhdGlvblxuICBwaXBlbGluZUZpbGxGcmFjOiBudW1iZXI7IC8vIFBpcGVsaW5lIGZpbGwgZnJhY3Rpb24gKHBpcGVsaW5lR1cgPSBsZWFkVGltZSAqIGJ1aWxkUmF0ZSAqIGZpbGxGcmFjKVxuICAvLyBCb3R0bGVuZWNrIGNvbnN0cmFpbnRzXG4gIGJvdHRsZW5lY2tNb2RlPzogJ29mZicgfCAnbWluX29mX2JvdHRsZW5lY2tzJzsgLy8gRGVmYXVsdCAnbWluX29mX2JvdHRsZW5lY2tzJ1xuICBib3R0bGVuZWNrQW5jaG9yc0dXeXI/OiB7XG4gICAgdHJhbnNmb3JtZXJzOiB7IDIwMjU6IG51bWJlcjsgMjAzMDogbnVtYmVyOyAyMDQwOiBudW1iZXI7IDIwNjA6IG51bWJlciB9O1xuICAgIHN1YnN0YXRpb25zOiB7IDIwMjU6IG51bWJlcjsgMjAzMDogbnVtYmVyOyAyMDQwOiBudW1iZXI7IDIwNjA6IG51bWJlciB9O1xuICAgIHR4OiB7IDIwMjU6IG51bWJlcjsgMjAzMDogbnVtYmVyOyAyMDQwOiBudW1iZXI7IDIwNjA6IG51bWJlciB9O1xuICAgIGdlbmVyYXRpb246IHsgMjAyNTogbnVtYmVyOyAyMDMwOiBudW1iZXI7IDIwNDA6IG51bWJlcjsgMjA2MDogbnVtYmVyIH07XG4gIH07XG4gIHJhbXBMaW1pdEZyYWNQZXJZZWFyPzogbnVtYmVyOyAvLyBNYXggZnJhY3Rpb25hbCBjaGFuZ2UgcGVyIHllYXIgKGRlZmF1bHQgMC4yNSA9IDI1JSlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb2JpbGl6YXRpb25TdGF0ZSB7XG4gIHllYXI6IG51bWJlcjtcbiAgZGVtYW5kR1c6IG51bWJlcjsgLy8gVG90YWwgZGVtYW5kIChJVCBvciBmYWNpbGl0eSBsb2FkKVxuICBkZW1hbmROZXdHVzogbnVtYmVyOyAvLyBJbmNyZW1lbnRhbCBkZW1hbmQgdGhpcyB5ZWFyXG4gIGJ1aWxkUmF0ZUdXeXI6IG51bWJlcjsgLy8gQnVpbGQgcmF0ZSB0aGlzIHllYXIgKEdXL3llYXIpXG4gIGNhcGFjaXR5R1c6IG51bWJlcjsgLy8gQ3VtdWxhdGl2ZSBjYXBhY2l0eSBidWlsdFxuICBwaXBlbGluZUdXOiBudW1iZXI7IC8vIFBpcGVsaW5lIGNhcGFjaXR5ICh1bmRlciBjb25zdHJ1Y3Rpb24pXG4gIGJhY2tsb2dHVzogbnVtYmVyOyAvLyBCYWNrbG9nIHdhaXRpbmcgdG8gYmUgYnVpbHRcbiAgYXZnV2FpdFllYXJzOiBudW1iZXI7IC8vIEF2ZXJhZ2Ugd2FpdCB0aW1lIChiYWNrbG9nIC8gYnVpbGRSYXRlKVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vYmlsaXphdGlvblJlc3VsdCBleHRlbmRzIE1vYmlsaXphdGlvblN0YXRlIHtcbiAgLy8gQWRkaXRpb25hbCBkZWJ1ZyBmaWVsZHNcbiAgZGVtYW5kR3Jvd3RoUmF0ZTogbnVtYmVyOyAvLyBDdXJyZW50IGdyb3d0aCByYXRlIChyMSBvciByMilcbiAgYnVpbGRvdXRTbW9vdGhGYWN0b3I6IG51bWJlcjsgLy8gU21vb3RoaW5nIGZhY3RvciBhcHBsaWVkXG4gIC8vIEJvdHRsZW5lY2sgZGVidWcgZmllbGRzXG4gIGJvdHRsZW5lY2tSYXRlR1d5cj86IG51bWJlcjsgLy8gRWZmZWN0aXZlIGJvdHRsZW5lY2sgcmF0ZSAobWluIG9mIGFsbCBib3R0bGVuZWNrcylcbiAgbGltaXRpbmdCb3R0bGVuZWNrPzogJ3RyYW5zZm9ybWVycycgfCAnc3Vic3RhdGlvbnMnIHwgJ3R4JyB8ICdnZW5lcmF0aW9uJyB8ICdjYW5kaWRhdGUnIHwgJ25vbmUnOyAvLyBXaGljaCBib3R0bGVuZWNrIGlzIGxpbWl0aW5nXG4gIGJ1aWxkUmF0ZUNhbmRpZGF0ZT86IG51bWJlcjsgLy8gT3JpZ2luYWwgYnVpbGQgcmF0ZSBiZWZvcmUgYm90dGxlbmVjay9yYW1wIGxpbWl0c1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBwcmljZS1yZXNwb25zaXZlIGRlbWFuZCBHV1xuICogXG4gKiBORVc6IERlbWFuZCByZXNwb25kcyB0byBwcmljZXMsIHdhaXQgdGltZXMsIGFuZCBvcmJpdGFsIHN1YnN0aXR1dGlvblxuICogUmVwbGFjZXMgZml4ZWQgYW5jaG9ycyB3aXRoIGVjb25vbWljIGZlZWRiYWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVQcmljZVJlc3BvbnNpdmVEZW1hbmRHVyhcbiAgeWVhcjogbnVtYmVyLFxuICBncm91bmRQcmljZVBlckdwdUhvdXI6IG51bWJlcixcbiAgb3JiaXRhbFByaWNlUGVyR3B1SG91cjogbnVtYmVyLFxuICBhdmdXYWl0WWVhcnM6IG51bWJlcixcbiAgcGFyYW1zOiBEZW1hbmRQYXJhbXMsXG4gIHB1ZTogbnVtYmVyID0gMS4zXG4pOiBudW1iZXIge1xuICAvLyBCYXNlIGRlbWFuZCB3aXRoIG9yZ2FuaWMgZ3Jvd3RoICh0YXBlcmVkLCBub3QgZXhwb25lbnRpYWwgZm9yZXZlcilcbiAgY29uc3QgeWVhcnNGcm9tMjAyNSA9IHllYXIgLSAyMDI1O1xuICBjb25zdCBncm93dGhUYXBlciA9IE1hdGgudGFuaCh5ZWFyc0Zyb20yMDI1IC8gMzApOyAvLyBUYXBlcnMgYWZ0ZXIgfjMwIHllYXJzXG4gIGNvbnN0IGJhc2VEZW1hbmQgPSBwYXJhbXMuYmFzZURlbWFuZDIwMjVHVyAqIE1hdGgucG93KDEgKyBwYXJhbXMub3JnYW5pY0dyb3d0aFJhdGUsIHllYXJzRnJvbTIwMjUgKiBncm93dGhUYXBlcik7XG4gIFxuICAvLyBQcmljZSBlbGFzdGljaXR5OiBoaWdoZXIgcHJpY2VzIHJlZHVjZSBkZW1hbmRcbiAgY29uc3QgYmFzZWxpbmVQcmljZSA9IDMuNTA7IC8vICQvR1BVLWhyIGJhc2VsaW5lXG4gIGNvbnN0IHByaWNlUmF0aW8gPSBncm91bmRQcmljZVBlckdwdUhvdXIgLyBiYXNlbGluZVByaWNlO1xuICBjb25zdCBwcmljZUZhY3RvciA9IE1hdGgucG93KHByaWNlUmF0aW8sIHBhcmFtcy5wcmljZUVsYXN0aWNpdHkpO1xuICBcbiAgLy8gV2FpdCBlbGFzdGljaXR5OiBsb25nZXIgd2FpdHMgcmVkdWNlIGRlbWFuZFxuICBjb25zdCB3YWl0RmFjdG9yID0gTWF0aC5leHAoLWF2Z1dhaXRZZWFycyAqIHBhcmFtcy53YWl0RWxhc3RpY2l0eSAvIDUpO1xuICBcbiAgLy8gT3JiaXRhbCBzdWJzdGl0dXRpb246IGlmIG9yYml0YWwgY2hlYXBlciwgZGVtYW5kIHNoaWZ0c1xuICBjb25zdCBvcmJpdGFsQWR2YW50YWdlID0gZ3JvdW5kUHJpY2VQZXJHcHVIb3VyIC8gTWF0aC5tYXgob3JiaXRhbFByaWNlUGVyR3B1SG91ciwgMC4wMSk7XG4gIGNvbnN0IHN1YnN0aXR1dGlvbkZhY3RvciA9IG9yYml0YWxBZHZhbnRhZ2UgPiBwYXJhbXMub3JiaXRhbFN1YnN0aXR1dGlvblRocmVzaG9sZCBcbiAgICA/IDEgLyAoMSArIDAuNSAqIChvcmJpdGFsQWR2YW50YWdlIC0gcGFyYW1zLm9yYml0YWxTdWJzdGl0dXRpb25UaHJlc2hvbGQpKVxuICAgIDogMS4wO1xuICBcbiAgbGV0IGRlbWFuZEdXID0gYmFzZURlbWFuZCAqIHByaWNlRmFjdG9yICogd2FpdEZhY3RvciAqIHN1YnN0aXR1dGlvbkZhY3RvcjtcbiAgXG4gIC8vIEFwcGx5IFBVRSBpZiBkZW1hbmQgaXMgSVQgbG9hZCAobm90IGZhY2lsaXR5IGxvYWQpXG4gIC8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBmYWNpbGl0eSBsb2FkLCBzbyBtdWx0aXBseSBieSBQVUUgaWYgbmVlZGVkXG4gIC8vIEZvciBub3csIHJldHVybiBmYWNpbGl0eSBsb2FkIChkZW1hbmQgYWxyZWFkeSBpbmNsdWRlcyBQVUUgaW4gYmFzZURlbWFuZDIwMjVHVylcbiAgXG4gIHJldHVybiBNYXRoLm1heCgwLCBkZW1hbmRHVyk7XG59XG5cbi8qKlxuICogTGVnYWN5IGZ1bmN0aW9uOiBDYWxjdWxhdGUgZGVtYW5kIEdXIHVzaW5nIHBpZWNld2lzZSBleHBvbmVudGlhbCB0byBoaXQgYW5jaG9yc1xuICogXG4gKiBERVBSRUNBVEVEOiBVc2UgY2FsY3VsYXRlUHJpY2VSZXNwb25zaXZlRGVtYW5kR1cgaW5zdGVhZFxuICogS2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRGVtYW5kR1coXG4gIHllYXI6IG51bWJlcixcbiAgcGFyYW1zOiBNb2JpbGl6YXRpb25TY2VuYXJpb1BhcmFtcyxcbiAgcHVlOiBudW1iZXIgPSAxLjNcbik6IG51bWJlciB7XG4gIGNvbnN0IHsgZGVtYW5kQW5jaG9yc0dXLCBkZW1hbmRJc0ZhY2lsaXR5TG9hZCwgZGVtYW5kQ3VydmUgfSA9IHBhcmFtcztcbiAgY29uc3QgZGVtYW5kMjAyNSA9IGRlbWFuZEFuY2hvcnNHV1syMDI1XTtcbiAgY29uc3QgZGVtYW5kMjA0MCA9IGRlbWFuZEFuY2hvcnNHV1syMDQwXTtcbiAgY29uc3QgZGVtYW5kMjA2MCA9IGRlbWFuZEFuY2hvcnNHV1syMDYwXTtcbiAgXG4gIGlmIChkZW1hbmRDdXJ2ZSAhPT0gJ3BpZWNld2lzZV9leHBvbmVudGlhbCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlbWFuZEN1cnZlOiAke2RlbWFuZEN1cnZlfS4gT25seSAncGllY2V3aXNlX2V4cG9uZW50aWFsJyBpcyBzdXBwb3J0ZWQuYCk7XG4gIH1cbiAgXG4gIGlmICh5ZWFyIDwgMjAyNSkge1xuICAgIHJldHVybiBkZW1hbmQyMDI1O1xuICB9XG4gIFxuICBsZXQgZGVtYW5kR1c6IG51bWJlcjtcbiAgXG4gIGlmICh5ZWFyIDw9IDIwNDApIHtcbiAgICAvLyBQaGFzZSAxOiAyMDI1LTIwNDBcbiAgICAvLyByMSA9IGxuKGRlbWFuZDIwNDAgLyBkZW1hbmQyMDI1KSAvICgyMDQwLTIwMjUpXG4gICAgY29uc3QgcjEgPSBNYXRoLmxvZyhkZW1hbmQyMDQwIC8gZGVtYW5kMjAyNSkgLyAoMjA0MCAtIDIwMjUpO1xuICAgIGNvbnN0IHllYXJzRnJvbTIwMjUgPSB5ZWFyIC0gMjAyNTtcbiAgICBkZW1hbmRHVyA9IGRlbWFuZDIwMjUgKiBNYXRoLmV4cChyMSAqIHllYXJzRnJvbTIwMjUpO1xuICB9IGVsc2Uge1xuICAgIC8vIFBoYXNlIDI6IDIwNDAtMjA2MFxuICAgIC8vIHIyID0gbG4oZGVtYW5kMjA2MCAvIGRlbWFuZDIwNDApIC8gKDIwNjAtMjA0MClcbiAgICBjb25zdCByMiA9IE1hdGgubG9nKGRlbWFuZDIwNjAgLyBkZW1hbmQyMDQwKSAvICgyMDYwIC0gMjA0MCk7XG4gICAgY29uc3QgeWVhcnNGcm9tMjA0MCA9IHllYXIgLSAyMDQwO1xuICAgIGRlbWFuZEdXID0gZGVtYW5kMjA0MCAqIE1hdGguZXhwKHIyICogeWVhcnNGcm9tMjA0MCk7XG4gIH1cbiAgXG4gIC8vIEFwcGx5IFBVRSBpZiBkZW1hbmQgaXMgSVQgbG9hZCAobm90IGZhY2lsaXR5IGxvYWQpXG4gIGlmICghZGVtYW5kSXNGYWNpbGl0eUxvYWQpIHtcbiAgICBkZW1hbmRHVyA9IGRlbWFuZEdXICogcHVlO1xuICB9XG4gIFxuICAvLyBIYXJkIGFzc2VydHMgaW4gZGV2IG1vZGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgaWYgKHllYXIgPT09IDIwNDApIHtcbiAgICAgIGNvbnN0IGFjdHVhbDIwNDAgPSBkZW1hbmRHVztcbiAgICAgIGNvbnN0IGVycm9yMjA0MCA9IE1hdGguYWJzKGFjdHVhbDIwNDAgLSBkZW1hbmQyMDQwKSAvIGRlbWFuZDIwNDA7XG4gICAgICBpZiAoZXJyb3IyMDQwID49IDAuMDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBbREVNQU5EIEFOQ0hPUiBGQUlMXSBkZW1hbmRHdygyMDQwKT0ke2FjdHVhbDIwNDAudG9GaXhlZCgyKX0gR1csIGAgK1xuICAgICAgICAgIGBleHBlY3RlZD0ke2RlbWFuZDIwNDB9IEdXLCBlcnJvcj0keyhlcnJvcjIwNDAgKiAxMDApLnRvRml4ZWQoMil9JSA+PSAzJWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKHllYXIgPT09IDIwNjApIHtcbiAgICAgIGlmIChkZW1hbmRHVyA8IDIwMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBbREVNQU5EIEFOQ0hPUiBGQUlMXSBkZW1hbmRHdygyMDYwKT0ke2RlbWFuZEdXLnRvRml4ZWQoMil9IEdXIDwgMjAwMCBHVy4gYCArXG4gICAgICAgICAgYE11c3QgYmUgPj0gMjAwMCBHVyAobXVsdGktVFcgdGFyZ2V0KS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gZGVtYW5kR1c7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHByaWNlLXJlc3BvbnNpdmUgYnVpbGRvdXQgcmF0ZVxuICogXG4gKiBORVc6IEJ1aWxkb3V0IHJlc3BvbmRzIHRvIG1hcmdpbnMgYW5kIGJhY2tsb2dcbiAqIFJlcGxhY2VzIGZpeGVkIGFuY2hvcnMgd2l0aCBpbnZlc3RtZW50IGZlZWRiYWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVQcmljZVJlc3BvbnNpdmVCdWlsZFJhdGVHV3lyKFxuICB5ZWFyOiBudW1iZXIsXG4gIHByZXZCdWlsZFJhdGU6IG51bWJlcixcbiAgZ3JvdW5kTWFyZ2luOiBudW1iZXIsICAvLyBDdXJyZW50IHByb2ZpdCBtYXJnaW4gKHByaWNlIC0gY29zdCkgLyBjb3N0XG4gIGJhY2tsb2dHVzogbnVtYmVyLFxuICBwYXJhbXM6IEJ1aWxkb3V0UGFyYW1zXG4pOiBudW1iZXIge1xuICAvLyBCYXNlIGdyb3d0aCAoc3VwcGx5IGNoYWluIGltcHJvdmVtZW50KVxuICBjb25zdCB5ZWFyc0Zyb20yMDI1ID0geWVhciAtIDIwMjU7XG4gIGNvbnN0IGJhc2VHcm93dGggPSBNYXRoLnBvdygxLjAzLCB5ZWFyc0Zyb20yMDI1KTsgLy8gMyUgb3JnYW5pYyBpbXByb3ZlbWVudFxuICBjb25zdCBiYXNlQnVpbGRSYXRlID0gcGFyYW1zLmJhc2VCdWlsZFJhdGUyMDI1R1d5ciAqIGJhc2VHcm93dGg7XG4gIFxuICAvLyBJbnZlc3RtZW50IHJlc3BvbnNlOiBoaWdoZXIgbWFyZ2lucyBhdHRyYWN0IG1vcmUgY2FwaXRhbFxuICBjb25zdCBiYXNlbGluZU1hcmdpbiA9IDAuMjA7IC8vIDIwJSBiYXNlbGluZSBtYXJnaW5cbiAgY29uc3QgbWFyZ2luUmF0aW8gPSBncm91bmRNYXJnaW4gLyBiYXNlbGluZU1hcmdpbjtcbiAgY29uc3QgaW52ZXN0bWVudE11bHRpcGxpZXIgPSAxICsgcGFyYW1zLmludmVzdG1lbnRFbGFzdGljaXR5ICogTWF0aC5tYXgoMCwgbWFyZ2luUmF0aW8gLSAxKTtcbiAgXG4gIC8vIEJhY2tsb2cgcmVzcG9uc2U6IGhpZ2hlciBiYWNrbG9nIGF0dHJhY3RzIG1vcmUgaW52ZXN0bWVudFxuICBjb25zdCBiYWNrbG9nTXVsdGlwbGllciA9IDEgKyBwYXJhbXMuYmFja2xvZ1Jlc3BvbnNlSyAqIE1hdGgubWluKDEsIGJhY2tsb2dHVyAvIDEwMCk7XG4gIFxuICAvLyBUYXJnZXQgYnVpbGQgcmF0ZVxuICBsZXQgdGFyZ2V0UmF0ZSA9IGJhc2VCdWlsZFJhdGUgKiBpbnZlc3RtZW50TXVsdGlwbGllciAqIGJhY2tsb2dNdWx0aXBsaWVyO1xuICBcbiAgLy8gUGh5c2ljYWwgY2VpbGluZ1xuICB0YXJnZXRSYXRlID0gTWF0aC5taW4odGFyZ2V0UmF0ZSwgcGFyYW1zLm1heEJ1aWxkUmF0ZUdXeXIpO1xuICBcbiAgLy8gUmFtcCBsaW1pdCAoY2FuJ3QgaW5jcmVhc2UgZmFzdGVyIHRoYW4gMjUlL3llYXIpXG4gIGNvbnN0IG1heFJhdGUgPSBwcmV2QnVpbGRSYXRlICogKDEgKyBwYXJhbXMucmFtcExpbWl0UGVyWWVhcik7XG4gIGNvbnN0IG1pblJhdGUgPSBwcmV2QnVpbGRSYXRlICogKDEgLSBwYXJhbXMucmFtcExpbWl0UGVyWWVhciAqIDAuNSk7IC8vIFNsb3dlciB0byBkZWNyZWFzZVxuICB0YXJnZXRSYXRlID0gTWF0aC5tYXgobWluUmF0ZSwgTWF0aC5taW4obWF4UmF0ZSwgdGFyZ2V0UmF0ZSkpO1xuICBcbiAgcmV0dXJuIE1hdGgubWF4KDAsIHRhcmdldFJhdGUpO1xufVxuXG4vKipcbiAqIExlZ2FjeSBmdW5jdGlvbjogU21vb3RoIGludGVycG9sYXRpb24gZm9yIGJ1aWxkb3V0IGFuY2hvcnNcbiAqIFxuICogREVQUkVDQVRFRDogVXNlIGNhbGN1bGF0ZVByaWNlUmVzcG9uc2l2ZUJ1aWxkUmF0ZUdXeXIgaW5zdGVhZFxuICogS2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQnVpbGRSYXRlR1d5cihcbiAgeWVhcjogbnVtYmVyLFxuICBwYXJhbXM6IE1vYmlsaXphdGlvblNjZW5hcmlvUGFyYW1zXG4pOiBudW1iZXIge1xuICBjb25zdCB7IGJ1aWxkb3V0QW5jaG9yc0dXeXIsIGJ1aWxkb3V0U21vb3RoaW5nWWVhcnMgfSA9IHBhcmFtcztcbiAgY29uc3QgYW5jaG9ycyA9IGJ1aWxkb3V0QW5jaG9yc0dXeXI7XG4gIFxuICAvLyBGaW5kIHN1cnJvdW5kaW5nIGFuY2hvcnNcbiAgY29uc3QgYW5jaG9yWWVhcnMgPSBPYmplY3Qua2V5cyhhbmNob3JzKS5tYXAoTnVtYmVyKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIFxuICAvLyBCZWZvcmUgZmlyc3QgYW5jaG9yOiB1c2UgZmlyc3QgYW5jaG9yIHZhbHVlXG4gIGlmICh5ZWFyIDw9IGFuY2hvclllYXJzWzBdKSB7XG4gICAgcmV0dXJuIGFuY2hvcnNbYW5jaG9yWWVhcnNbMF0gYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICB9XG4gIFxuICAvLyBBZnRlciBsYXN0IGFuY2hvcjogdXNlIGxhc3QgYW5jaG9yIHZhbHVlXG4gIGlmICh5ZWFyID49IGFuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdKSB7XG4gICAgcmV0dXJuIGFuY2hvcnNbYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV0gYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICB9XG4gIFxuICAvLyBGaW5kIHN1cnJvdW5kaW5nIGFuY2hvcnNcbiAgbGV0IGxvd2VyWWVhciA9IGFuY2hvclllYXJzWzBdO1xuICBsZXQgdXBwZXJZZWFyID0gYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV07XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFuY2hvclllYXJzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmICh5ZWFyID49IGFuY2hvclllYXJzW2ldICYmIHllYXIgPD0gYW5jaG9yWWVhcnNbaSArIDFdKSB7XG4gICAgICBsb3dlclllYXIgPSBhbmNob3JZZWFyc1tpXTtcbiAgICAgIHVwcGVyWWVhciA9IGFuY2hvclllYXJzW2kgKyAxXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBcbiAgY29uc3QgbG93ZXJSYXRlID0gYW5jaG9yc1tsb3dlclllYXIgYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICBjb25zdCB1cHBlclJhdGUgPSBhbmNob3JzW3VwcGVyWWVhciBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gIFxuICAvLyBFeHBvbmVudGlhbCBpbnRlcnBvbGF0aW9uIGZvciBidWlsZG91dCByYW1wXG4gIGNvbnN0IHQgPSAoeWVhciAtIGxvd2VyWWVhcikgLyAodXBwZXJZZWFyIC0gbG93ZXJZZWFyKTtcbiAgY29uc3QgYnVpbGRSYXRlID0gbG93ZXJSYXRlICogTWF0aC5wb3codXBwZXJSYXRlIC8gbG93ZXJSYXRlLCB0KTtcbiAgXG4gIC8vIEFwcGx5IHNtb290aGluZzogbW92aW5nIGF2ZXJhZ2Ugb3ZlciBzbW9vdGhpbmcgd2luZG93XG4gIGlmIChidWlsZG91dFNtb290aGluZ1llYXJzID4gMCkge1xuICAgIGNvbnN0IHNtb290aGluZ1dpbmRvdyA9IGJ1aWxkb3V0U21vb3RoaW5nWWVhcnM7XG4gICAgbGV0IHNtb290aGVkU3VtID0gYnVpbGRSYXRlO1xuICAgIGxldCBjb3VudCA9IDE7XG4gICAgXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSB1bnNtb290aGVkIHJhdGVcbiAgICBjb25zdCBnZXRVbnNtb290aGVkUmF0ZSA9ICh5OiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgICAgaWYgKHkgPD0gYW5jaG9yWWVhcnNbMF0pIHJldHVybiBhbmNob3JzW2FuY2hvclllYXJzWzBdIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgICAgIGlmICh5ID49IGFuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdKSByZXR1cm4gYW5jaG9yc1thbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXSBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gICAgICBcbiAgICAgIGxldCBsb3dlciA9IGFuY2hvclllYXJzWzBdO1xuICAgICAgbGV0IHVwcGVyID0gYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFuY2hvclllYXJzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoeSA+PSBhbmNob3JZZWFyc1tpXSAmJiB5IDw9IGFuY2hvclllYXJzW2kgKyAxXSkge1xuICAgICAgICAgIGxvd2VyID0gYW5jaG9yWWVhcnNbaV07XG4gICAgICAgICAgdXBwZXIgPSBhbmNob3JZZWFyc1tpICsgMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgbG93ZXJSYXRlID0gYW5jaG9yc1tsb3dlciBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gICAgICBjb25zdCB1cHBlclJhdGUgPSBhbmNob3JzW3VwcGVyIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgICAgIGNvbnN0IHQgPSAoeSAtIGxvd2VyKSAvICh1cHBlciAtIGxvd2VyKTtcbiAgICAgIHJldHVybiBsb3dlclJhdGUgKiBNYXRoLnBvdyh1cHBlclJhdGUgLyBsb3dlclJhdGUsIHQpO1xuICAgIH07XG4gICAgXG4gICAgZm9yIChsZXQgb2Zmc2V0ID0gMTsgb2Zmc2V0IDw9IE1hdGguZmxvb3Ioc21vb3RoaW5nV2luZG93IC8gMik7IG9mZnNldCsrKSB7XG4gICAgICBjb25zdCBwcmV2WWVhciA9IHllYXIgLSBvZmZzZXQ7XG4gICAgICBjb25zdCBuZXh0WWVhciA9IHllYXIgKyBvZmZzZXQ7XG4gICAgICBcbiAgICAgIGlmIChwcmV2WWVhciA+PSBhbmNob3JZZWFyc1swXSkge1xuICAgICAgICBjb25zdCBwcmV2UmF0ZSA9IGdldFVuc21vb3RoZWRSYXRlKHByZXZZZWFyKTtcbiAgICAgICAgc21vb3RoZWRTdW0gKz0gcHJldlJhdGU7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChuZXh0WWVhciA8PSBhbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXSkge1xuICAgICAgICBjb25zdCBuZXh0UmF0ZSA9IGdldFVuc21vb3RoZWRSYXRlKG5leHRZZWFyKTtcbiAgICAgICAgc21vb3RoZWRTdW0gKz0gbmV4dFJhdGU7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBzbW9vdGhlZFN1bSAvIGNvdW50O1xuICB9XG4gIFxuICByZXR1cm4gYnVpbGRSYXRlO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBib3R0bGVuZWNrIHJhdGUgZnJvbSBhbmNob3JzIChzYW1lIGludGVycG9sYXRpb24gYXMgYnVpbGRvdXQpXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUJvdHRsZW5lY2tSYXRlR1d5cihcbiAgeWVhcjogbnVtYmVyLFxuICBhbmNob3JzOiB7IDIwMjU6IG51bWJlcjsgMjAzMDogbnVtYmVyOyAyMDQwOiBudW1iZXI7IDIwNjA6IG51bWJlciB9XG4pOiBudW1iZXIge1xuICBjb25zdCBhbmNob3JZZWFycyA9IFsyMDI1LCAyMDMwLCAyMDQwLCAyMDYwXSBhcyBjb25zdDtcbiAgXG4gIC8vIEJlZm9yZSBmaXJzdCBhbmNob3I6IHVzZSBmaXJzdCBhbmNob3IgdmFsdWVcbiAgaWYgKHllYXIgPD0gYW5jaG9yWWVhcnNbMF0pIHtcbiAgICByZXR1cm4gYW5jaG9yc1syMDI1XTtcbiAgfVxuICBcbiAgLy8gQWZ0ZXIgbGFzdCBhbmNob3I6IHVzZSBsYXN0IGFuY2hvciB2YWx1ZVxuICBpZiAoeWVhciA+PSBhbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXSkge1xuICAgIHJldHVybiBhbmNob3JzWzIwNjBdO1xuICB9XG4gIFxuICAvLyBGaW5kIHN1cnJvdW5kaW5nIGFuY2hvcnNcbiAgbGV0IGxvd2VyWWVhciA9IGFuY2hvclllYXJzWzBdO1xuICBsZXQgdXBwZXJZZWFyID0gYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV07XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFuY2hvclllYXJzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmICh5ZWFyID49IGFuY2hvclllYXJzW2ldICYmIHllYXIgPD0gYW5jaG9yWWVhcnNbaSArIDFdKSB7XG4gICAgICBsb3dlclllYXIgPSBhbmNob3JZZWFyc1tpXTtcbiAgICAgIHVwcGVyWWVhciA9IGFuY2hvclllYXJzW2kgKyAxXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBcbiAgY29uc3QgbG93ZXJSYXRlID0gYW5jaG9yc1tsb3dlclllYXIgYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICBjb25zdCB1cHBlclJhdGUgPSBhbmNob3JzW3VwcGVyWWVhciBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gIFxuICAvLyBFeHBvbmVudGlhbCBpbnRlcnBvbGF0aW9uXG4gIGNvbnN0IHQgPSAoeWVhciAtIGxvd2VyWWVhcikgLyAodXBwZXJZZWFyIC0gbG93ZXJZZWFyKTtcbiAgcmV0dXJuIGxvd2VyUmF0ZSAqIE1hdGgucG93KHVwcGVyUmF0ZSAvIGxvd2VyUmF0ZSwgdCk7XG59XG5cbi8qKlxuICogU3RlcCBtb2JpbGl6YXRpb24gc3RhdGUgZm9yd2FyZCBvbmUgeWVhclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RlcE1vYmlsaXphdGlvblN0YXRlKFxuICBwcmV2U3RhdGU6IE1vYmlsaXphdGlvblN0YXRlIHwgbnVsbCxcbiAgcGFyYW1zOiBNb2JpbGl6YXRpb25TY2VuYXJpb1BhcmFtcyxcbiAgeWVhcjogbnVtYmVyLFxuICBwdWU6IG51bWJlciA9IDEuMyxcbiAgcmV0aXJlbWVudHNHVzogbnVtYmVyID0gMCwgLy8gT3B0aW9uYWwgcmV0aXJlbWVudHMgKGRlZmF1bHQgMClcbiAgb3JiaXRhbFN1YnN0aXR1dGlvbkdXPzogbnVtYmVyLCAvLyBPcHRpb25hbDogZGVtYW5kIHNoaWZ0ZWQgdG8gb3JiaXRhbCAoZm9yIGJhY2tsb2cgZHJhaW4pXG4gIHJlc3BvbnNpdmVEZW1hbmRHVz86IG51bWJlciAvLyBPcHRpb25hbDogcmVzcG9uc2l2ZSBkZW1hbmQgKG92ZXJyaWRlcyBoYXJkY29kZWQgY2FsY3VsYXRlRGVtYW5kR1cpXG4pOiBNb2JpbGl6YXRpb25SZXN1bHQge1xuICAvLyBDYWxjdWxhdGUgZGVtYW5kOiB1c2UgcmVzcG9uc2l2ZSBkZW1hbmQgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSB1c2UgaGFyZGNvZGVkXG4gIGNvbnN0IGRlbWFuZEdXID0gcmVzcG9uc2l2ZURlbWFuZEdXICE9PSB1bmRlZmluZWQgXG4gICAgPyByZXNwb25zaXZlRGVtYW5kR1cgKiBwdWUgLy8gQ29udmVydCBJVCBsb2FkIHRvIGZhY2lsaXR5IGxvYWRcbiAgICA6IGNhbGN1bGF0ZURlbWFuZEdXKHllYXIsIHBhcmFtcywgcHVlKTtcbiAgY29uc3QgZGVtYW5kR1dQcmV2ID0gcHJldlN0YXRlPy5kZW1hbmRHVyA/PyAocmVzcG9uc2l2ZURlbWFuZEdXICE9PSB1bmRlZmluZWQgXG4gICAgPyByZXNwb25zaXZlRGVtYW5kR1cgKiBwdWUgXG4gICAgOiBjYWxjdWxhdGVEZW1hbmRHVyh5ZWFyIC0gMSwgcGFyYW1zLCBwdWUpKTtcbiAgY29uc3QgZGVtYW5kTmV3R1cgPSBNYXRoLm1heCgwLCBkZW1hbmRHVyAtIGRlbWFuZEdXUHJldik7XG4gIFxuICAvLyBDYWxjdWxhdGUgYnVpbGQgcmF0ZSBjYW5kaWRhdGUgKGZyb20gYW5jaG9ycylcbiAgbGV0IGJ1aWxkUmF0ZUNhbmRpZGF0ZSA9IGNhbGN1bGF0ZUJ1aWxkUmF0ZUdXeXIoeWVhciwgcGFyYW1zKTtcbiAgXG4gIC8vIE5FVzogSWYgZ3JvdW5kIGRlbWFuZCBpcyBmYWxsaW5nIChkdWUgdG8gb3JiaXRhbCBzdWJzdGl0dXRpb24gb3IgcHJpY2UgZWxhc3RpY2l0eSksXG4gIC8vIGJ1aWxkb3V0IHNob3VsZCBzbG93IGRvd24gKG5vIG9uZSBidWlsZHMgY2FwYWNpdHkgZm9yIGRlY2xpbmluZyBtYXJrZXQpXG4gIGNvbnN0IGRlbWFuZEdyb3d0aFJhdGVBY3R1YWwgPSBwcmV2U3RhdGU/LmRlbWFuZEdXID8gKGRlbWFuZEdXIC0gcHJldlN0YXRlLmRlbWFuZEdXKSAvIE1hdGgubWF4KHByZXZTdGF0ZS5kZW1hbmRHVywgMSkgOiAwO1xuICBpZiAoZGVtYW5kR3Jvd3RoUmF0ZUFjdHVhbCA8IDApIHtcbiAgICAvLyBEZW1hbmQgaXMgc2hyaW5raW5nIC0gcmVkdWNlIGJ1aWxkb3V0XG4gICAgY29uc3QgY29udHJhY3Rpb25GYWN0b3IgPSBNYXRoLm1heCgwLjUsIDEgKyBkZW1hbmRHcm93dGhSYXRlQWN0dWFsICogMik7IC8vIEF0IG1vc3QgNTAlIHJlZHVjdGlvblxuICAgIGJ1aWxkUmF0ZUNhbmRpZGF0ZSA9IGJ1aWxkUmF0ZUNhbmRpZGF0ZSAqIGNvbnRyYWN0aW9uRmFjdG9yOyAvLyBSZWFzc2lnbiB0byBsZXQgdmFyaWFibGVcbiAgfVxuICBcbiAgLy8gQXBwbHkgYm90dGxlbmVjayBjb25zdHJhaW50cyBpZiBlbmFibGVkXG4gIGNvbnN0IGJvdHRsZW5lY2tNb2RlID0gcGFyYW1zLmJvdHRsZW5lY2tNb2RlID8/ICdtaW5fb2ZfYm90dGxlbmVja3MnO1xuICBsZXQgYnVpbGRSYXRlR1d5ciA9IGJ1aWxkUmF0ZUNhbmRpZGF0ZTtcbiAgbGV0IGJvdHRsZW5lY2tSYXRlR1d5cjogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICBsZXQgbGltaXRpbmdCb3R0bGVuZWNrOiAndHJhbnNmb3JtZXJzJyB8ICdzdWJzdGF0aW9ucycgfCAndHgnIHwgJ2dlbmVyYXRpb24nIHwgJ2NhbmRpZGF0ZScgfCAnbm9uZScgPSAnY2FuZGlkYXRlJztcbiAgXG4gIGlmIChib3R0bGVuZWNrTW9kZSA9PT0gJ21pbl9vZl9ib3R0bGVuZWNrcycgJiYgcGFyYW1zLmJvdHRsZW5lY2tBbmNob3JzR1d5cikge1xuICAgIGNvbnN0IHsgdHJhbnNmb3JtZXJzLCBzdWJzdGF0aW9ucywgdHgsIGdlbmVyYXRpb24gfSA9IHBhcmFtcy5ib3R0bGVuZWNrQW5jaG9yc0dXeXI7XG4gICAgXG4gICAgY29uc3QgdHJhbnNmb3JtZXJzUmF0ZSA9IGNhbGN1bGF0ZUJvdHRsZW5lY2tSYXRlR1d5cih5ZWFyLCB0cmFuc2Zvcm1lcnMpO1xuICAgIGNvbnN0IHN1YnN0YXRpb25zUmF0ZSA9IGNhbGN1bGF0ZUJvdHRsZW5lY2tSYXRlR1d5cih5ZWFyLCBzdWJzdGF0aW9ucyk7XG4gICAgY29uc3QgdHhSYXRlID0gY2FsY3VsYXRlQm90dGxlbmVja1JhdGVHV3lyKHllYXIsIHR4KTtcbiAgICBjb25zdCBnZW5lcmF0aW9uUmF0ZSA9IGNhbGN1bGF0ZUJvdHRsZW5lY2tSYXRlR1d5cih5ZWFyLCBnZW5lcmF0aW9uKTtcbiAgICBcbiAgICAvLyBGaW5kIG1pbmltdW0gYm90dGxlbmVja1xuICAgIGJvdHRsZW5lY2tSYXRlR1d5ciA9IE1hdGgubWluKHRyYW5zZm9ybWVyc1JhdGUsIHN1YnN0YXRpb25zUmF0ZSwgdHhSYXRlLCBnZW5lcmF0aW9uUmF0ZSk7XG4gICAgXG4gICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGJvdHRsZW5lY2sgaXMgbGltaXRpbmdcbiAgICBpZiAoYm90dGxlbmVja1JhdGVHV3lyID09PSB0cmFuc2Zvcm1lcnNSYXRlKSB7XG4gICAgICBsaW1pdGluZ0JvdHRsZW5lY2sgPSAndHJhbnNmb3JtZXJzJztcbiAgICB9IGVsc2UgaWYgKGJvdHRsZW5lY2tSYXRlR1d5ciA9PT0gc3Vic3RhdGlvbnNSYXRlKSB7XG4gICAgICBsaW1pdGluZ0JvdHRsZW5lY2sgPSAnc3Vic3RhdGlvbnMnO1xuICAgIH0gZWxzZSBpZiAoYm90dGxlbmVja1JhdGVHV3lyID09PSB0eFJhdGUpIHtcbiAgICAgIGxpbWl0aW5nQm90dGxlbmVjayA9ICd0eCc7XG4gICAgfSBlbHNlIGlmIChib3R0bGVuZWNrUmF0ZUdXeXIgPT09IGdlbmVyYXRpb25SYXRlKSB7XG4gICAgICBsaW1pdGluZ0JvdHRsZW5lY2sgPSAnZ2VuZXJhdGlvbic7XG4gICAgfVxuICAgIFxuICAgIC8vIEVmZmVjdGl2ZSBidWlsZCByYXRlIGlzIG1pbmltdW0gb2YgY2FuZGlkYXRlIGFuZCBib3R0bGVuZWNrXG4gICAgYnVpbGRSYXRlR1d5ciA9IE1hdGgubWluKGJ1aWxkUmF0ZUNhbmRpZGF0ZSwgYm90dGxlbmVja1JhdGVHV3lyKTtcbiAgfSBlbHNlIHtcbiAgICBsaW1pdGluZ0JvdHRsZW5lY2sgPSAnbm9uZSc7XG4gIH1cbiAgXG4gIC8vIEFwcGx5IHJhbXAgbGltaXRlciAocHJldmVudCBzdWRkZW4ganVtcHMpXG4gIGNvbnN0IHJhbXBMaW1pdEZyYWMgPSBwYXJhbXMucmFtcExpbWl0RnJhY1BlclllYXIgPz8gMC4yNTtcbiAgaWYgKHByZXZTdGF0ZT8uYnVpbGRSYXRlR1d5ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgcHJldlJhdGUgPSBwcmV2U3RhdGUuYnVpbGRSYXRlR1d5cjtcbiAgICBjb25zdCBtaW5SYXRlID0gcHJldlJhdGUgKiAoMSAtIHJhbXBMaW1pdEZyYWMpO1xuICAgIGNvbnN0IG1heFJhdGUgPSBwcmV2UmF0ZSAqICgxICsgcmFtcExpbWl0RnJhYyk7XG4gICAgYnVpbGRSYXRlR1d5ciA9IE1hdGgubWF4KG1pblJhdGUsIE1hdGgubWluKG1heFJhdGUsIGJ1aWxkUmF0ZUdXeXIpKTtcbiAgfVxuICBcbiAgLy8gQ2FsY3VsYXRlIGNhcGFjaXR5IGV2b2x1dGlvblxuICAvLyBjYXBhY2l0eUd3KHQpID0gY2FwYWNpdHlHdyh0LTEpICsgYnVpbGRSYXRlR3dZZWFyKHQpIC0gcmV0aXJlbWVudHNHdyh0KVxuICBjb25zdCBjYXBhY2l0eUdXUHJldiA9IHByZXZTdGF0ZT8uY2FwYWNpdHlHVyA/PyAwO1xuICBjb25zdCBjYXBhY2l0eUdXID0gY2FwYWNpdHlHV1ByZXYgKyBidWlsZFJhdGVHV3lyIC0gcmV0aXJlbWVudHNHVztcbiAgXG4gIC8vIENhbGN1bGF0ZSBwaXBlbGluZVxuICAvLyBwaXBlbGluZUd3KHQpID0gYnVpbGRSYXRlR3dZZWFyKHQpICogcGlwZWxpbmVMZWFkVGltZVllYXJzICogcGlwZWxpbmVGaWxsRnJhY1xuICBjb25zdCBwaXBlbGluZUdXID0gYnVpbGRSYXRlR1d5ciAqIHBhcmFtcy5waXBlbGluZUxlYWRUaW1lWWVhcnMgKiBwYXJhbXMucGlwZWxpbmVGaWxsRnJhYztcbiAgXG4gIC8vIENhbGN1bGF0ZSBiYWNrbG9nXG4gIC8vIGJhY2tsb2dHdyh0KSA9IG1heCgwLCBiYWNrbG9nR3codC0xKSArIGRlbWFuZE5ld0d3KHQpIC0gYnVpbGRhYmxlR3codCkgLSBpbXBsaWNpdEJhY2tsb2dEcmFpbilcbiAgLy8gTkVXOiBCYWNrbG9nIGNhbiBhbHNvIGJlIHNhdGlzZmllZCBieSBkZW1hbmQgc2hpZnRpbmcgdG8gb3JiaXRhbFxuICAvLyBXaGVuIGRlbWFuZCBzaGlmdHMgdG8gb3JiaXRhbCwgXCJpbXBsaWNpdCBiYWNrbG9nIGRyYWluXCIgb2NjdXJzXG4gIC8vIGJlY2F1c2UgY3VzdG9tZXJzIHdobyB3ZXJlIHdhaXRpbmcgZm9yIGdyb3VuZCBub3cgdXNlIG9yYml0YWwgaW5zdGVhZFxuICBjb25zdCBiYWNrbG9nR1dQcmV2ID0gcHJldlN0YXRlPy5iYWNrbG9nR1cgPz8gMDtcbiAgY29uc3QgYnVpbGRhYmxlR1cgPSBidWlsZFJhdGVHV3lyO1xuICBjb25zdCBpbXBsaWNpdEJhY2tsb2dEcmFpbiA9IChvcmJpdGFsU3Vic3RpdHV0aW9uR1cgPz8gMCkgKiAwLjU7IC8vIDUwJSBvZiBzaGlmdGVkIGRlbWFuZCB3YXMgaW4gYmFja2xvZ1xuICBjb25zdCBiYWNrbG9nR1cgPSBNYXRoLm1heCgwLCBiYWNrbG9nR1dQcmV2ICsgZGVtYW5kTmV3R1cgLSBidWlsZGFibGVHVyAtIGltcGxpY2l0QmFja2xvZ0RyYWluKTtcbiAgXG4gIC8vIEhhcmQgYXNzZXJ0OiBJZiBkZW1hbmROZXdHdyh0KSA+IGJ1aWxkUmF0ZUd3WWVhcih0KSwgYmFja2xvZ0d3IG11c3QgaW5jcmVhc2VcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgaWYgKGRlbWFuZE5ld0dXID4gYnVpbGRSYXRlR1d5ciAmJiBiYWNrbG9nR1cgPD0gYmFja2xvZ0dXUHJldikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgW0JVSUxET1VUIElOVkFSSUFOVF0gWWVhciAke3llYXJ9OiBkZW1hbmROZXdHVz0ke2RlbWFuZE5ld0dXLnRvRml4ZWQoMil9ID4gYCArXG4gICAgICAgIGBidWlsZFJhdGVHV3lyPSR7YnVpbGRSYXRlR1d5ci50b0ZpeGVkKDIpfSwgYnV0IGJhY2tsb2dHVz0ke2JhY2tsb2dHVy50b0ZpeGVkKDIpfSBgICtcbiAgICAgICAgYDw9IHByZXZCYWNrbG9nR1c9JHtiYWNrbG9nR1dQcmV2LnRvRml4ZWQoMil9LiBCYWNrbG9nIG11c3QgaW5jcmVhc2UuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIENhbGN1bGF0ZSBhdmVyYWdlIHdhaXQgdGltZVxuICAvLyBhdmdXYWl0WWVhcnModCkgPSBiYWNrbG9nR3codCkgLyBtYXgoYnVpbGRSYXRlR3dZZWFyKHQpLCAxZS05KVxuICBjb25zdCBFUFMgPSAxZS05O1xuICBjb25zdCBhdmdXYWl0WWVhcnMgPSBiYWNrbG9nR1cgLyBNYXRoLm1heChidWlsZFJhdGVHV3lyLCBFUFMpO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGdyb3d0aCByYXRlIChmb3IgZGVidWcpXG4gIGxldCBkZW1hbmRHcm93dGhSYXRlOiBudW1iZXI7XG4gIGlmICh5ZWFyIDw9IDIwNDApIHtcbiAgICBkZW1hbmRHcm93dGhSYXRlID0gTWF0aC5sb2cocGFyYW1zLmRlbWFuZEFuY2hvcnNHV1syMDQwXSAvIHBhcmFtcy5kZW1hbmRBbmNob3JzR1dbMjAyNV0pIC8gMTU7XG4gIH0gZWxzZSB7XG4gICAgZGVtYW5kR3Jvd3RoUmF0ZSA9IE1hdGgubG9nKHBhcmFtcy5kZW1hbmRBbmNob3JzR1dbMjA2MF0gLyBwYXJhbXMuZGVtYW5kQW5jaG9yc0dXWzIwNDBdKSAvIDIwO1xuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIHllYXIsXG4gICAgZGVtYW5kR1csXG4gICAgZGVtYW5kTmV3R1csXG4gICAgYnVpbGRSYXRlR1d5cixcbiAgICBjYXBhY2l0eUdXLFxuICAgIHBpcGVsaW5lR1csXG4gICAgYmFja2xvZ0dXLFxuICAgIGF2Z1dhaXRZZWFycyxcbiAgICBkZW1hbmRHcm93dGhSYXRlLFxuICAgIGJ1aWxkb3V0U21vb3RoRmFjdG9yOiBwYXJhbXMuYnVpbGRvdXRTbW9vdGhpbmdZZWFycyxcbiAgICBib3R0bGVuZWNrUmF0ZUdXeXIsXG4gICAgbGltaXRpbmdCb3R0bGVuZWNrLFxuICAgIGJ1aWxkUmF0ZUNhbmRpZGF0ZSxcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWZhdWx0IG1vYmlsaXphdGlvbiBzY2VuYXJpbyBwYXJhbWV0ZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX01PQklMSVpBVElPTl9QQVJBTVM6IE1vYmlsaXphdGlvblNjZW5hcmlvUGFyYW1zID0ge1xuICBkZW1hbmRBbmNob3JzR1c6IHtcbiAgICAyMDI1OiAxMjAsIC8vIEZhY2lsaXR5IGxvYWQgYmFzZWxpbmUgKElUIGxvYWQgKiBQVUUpXG4gICAgMjA0MDogNDUwLCAvLyBUYXJnZXRcbiAgICAyMDYwOiAzMDAwLCAvLyBNdWx0aS1UVyB0YXJnZXRcbiAgfSxcbiAgZGVtYW5kQ3VydmU6ICdwaWVjZXdpc2VfZXhwb25lbnRpYWwnLFxuICBkZW1hbmRJc0ZhY2lsaXR5TG9hZDogdHJ1ZSwgLy8gRGVtYW5kIGlzIGZhY2lsaXR5IGxvYWQgKGluY2x1ZGVzIFBVRSlcbiAgYnVpbGRvdXRBbmNob3JzR1d5cjoge1xuICAgIDIwMjU6IDI1LCAvLyBXYXJ0aW1lIG1vYmlsaXphdGlvbiBleGFtcGxlXG4gICAgMjAzMDogNjAsXG4gICAgMjA0MDogMTQwLFxuICAgIDIwNjA6IDIyMCxcbiAgfSxcbiAgYnVpbGRvdXRTbW9vdGhpbmdZZWFyczogMyxcbiAgcGlwZWxpbmVMZWFkVGltZVllYXJzOiAzLFxuICBwaXBlbGluZUZpbGxGcmFjOiAxLjUsXG4gIGJvdHRsZW5lY2tNb2RlOiAnbWluX29mX2JvdHRsZW5lY2tzJyxcbiAgYm90dGxlbmVja0FuY2hvcnNHV3lyOiB7XG4gICAgdHJhbnNmb3JtZXJzOiB7IDIwMjU6IDMwLCAyMDMwOiA1MCwgMjA0MDogMTAwLCAyMDYwOiAxODAgfSxcbiAgICBzdWJzdGF0aW9uczogeyAyMDI1OiAzNSwgMjAzMDogNTUsIDIwNDA6IDExMCwgMjA2MDogMjAwIH0sXG4gICAgdHg6IHsgMjAyNTogNDAsIDIwMzA6IDY1LCAyMDQwOiAxMzAsIDIwNjA6IDI1MCB9LFxuICAgIGdlbmVyYXRpb246IHsgMjAyNTogNTAsIDIwMzA6IDgwLCAyMDQwOiAxNjAsIDIwNjA6IDMwMCB9LFxuICB9LFxuICByYW1wTGltaXRGcmFjUGVyWWVhcjogMC4yNSwgLy8gMjUlIG1heCBjaGFuZ2UgcGVyIHllYXJcbn07XG5cbiJdLCJuYW1lcyI6WyJjYWxjdWxhdGVQcmljZVJlc3BvbnNpdmVEZW1hbmRHVyIsInllYXIiLCJncm91bmRQcmljZVBlckdwdUhvdXIiLCJvcmJpdGFsUHJpY2VQZXJHcHVIb3VyIiwiYXZnV2FpdFllYXJzIiwicGFyYW1zIiwicHVlIiwieWVhcnNGcm9tMjAyNSIsImdyb3d0aFRhcGVyIiwiTWF0aCIsInRhbmgiLCJiYXNlRGVtYW5kIiwiYmFzZURlbWFuZDIwMjVHVyIsInBvdyIsIm9yZ2FuaWNHcm93dGhSYXRlIiwiYmFzZWxpbmVQcmljZSIsInByaWNlUmF0aW8iLCJwcmljZUZhY3RvciIsInByaWNlRWxhc3RpY2l0eSIsIndhaXRGYWN0b3IiLCJleHAiLCJ3YWl0RWxhc3RpY2l0eSIsIm9yYml0YWxBZHZhbnRhZ2UiLCJtYXgiLCJzdWJzdGl0dXRpb25GYWN0b3IiLCJvcmJpdGFsU3Vic3RpdHV0aW9uVGhyZXNob2xkIiwiZGVtYW5kR1ciLCJjYWxjdWxhdGVEZW1hbmRHVyIsImRlbWFuZEFuY2hvcnNHVyIsImRlbWFuZElzRmFjaWxpdHlMb2FkIiwiZGVtYW5kQ3VydmUiLCJkZW1hbmQyMDI1IiwiZGVtYW5kMjA0MCIsImRlbWFuZDIwNjAiLCJFcnJvciIsInIxIiwibG9nIiwicjIiLCJ5ZWFyc0Zyb20yMDQwIiwicHJvY2VzcyIsImFjdHVhbDIwNDAiLCJlcnJvcjIwNDAiLCJhYnMiLCJ0b0ZpeGVkIiwiY2FsY3VsYXRlUHJpY2VSZXNwb25zaXZlQnVpbGRSYXRlR1d5ciIsInByZXZCdWlsZFJhdGUiLCJncm91bmRNYXJnaW4iLCJiYWNrbG9nR1ciLCJiYXNlR3Jvd3RoIiwiYmFzZUJ1aWxkUmF0ZSIsImJhc2VCdWlsZFJhdGUyMDI1R1d5ciIsImJhc2VsaW5lTWFyZ2luIiwibWFyZ2luUmF0aW8iLCJpbnZlc3RtZW50TXVsdGlwbGllciIsImludmVzdG1lbnRFbGFzdGljaXR5IiwiYmFja2xvZ011bHRpcGxpZXIiLCJiYWNrbG9nUmVzcG9uc2VLIiwibWluIiwidGFyZ2V0UmF0ZSIsIm1heEJ1aWxkUmF0ZUdXeXIiLCJtYXhSYXRlIiwicmFtcExpbWl0UGVyWWVhciIsIm1pblJhdGUiLCJjYWxjdWxhdGVCdWlsZFJhdGVHV3lyIiwiYnVpbGRvdXRBbmNob3JzR1d5ciIsImJ1aWxkb3V0U21vb3RoaW5nWWVhcnMiLCJhbmNob3JzIiwiYW5jaG9yWWVhcnMiLCJPYmplY3QiLCJrZXlzIiwibWFwIiwiTnVtYmVyIiwic29ydCIsImEiLCJiIiwibGVuZ3RoIiwibG93ZXJZZWFyIiwidXBwZXJZZWFyIiwiaSIsImxvd2VyUmF0ZSIsInVwcGVyUmF0ZSIsInQiLCJidWlsZFJhdGUiLCJzbW9vdGhpbmdXaW5kb3ciLCJzbW9vdGhlZFN1bSIsImNvdW50IiwiZ2V0VW5zbW9vdGhlZFJhdGUiLCJ5IiwibG93ZXIiLCJ1cHBlciIsIm9mZnNldCIsImZsb29yIiwicHJldlllYXIiLCJuZXh0WWVhciIsInByZXZSYXRlIiwibmV4dFJhdGUiLCJjYWxjdWxhdGVCb3R0bGVuZWNrUmF0ZUdXeXIiLCJzdGVwTW9iaWxpemF0aW9uU3RhdGUiLCJwcmV2U3RhdGUiLCJyZXRpcmVtZW50c0dXIiwib3JiaXRhbFN1YnN0aXR1dGlvbkdXIiwicmVzcG9uc2l2ZURlbWFuZEdXIiwidW5kZWZpbmVkIiwiZGVtYW5kR1dQcmV2IiwiZGVtYW5kTmV3R1ciLCJidWlsZFJhdGVDYW5kaWRhdGUiLCJkZW1hbmRHcm93dGhSYXRlQWN0dWFsIiwiY29udHJhY3Rpb25GYWN0b3IiLCJib3R0bGVuZWNrTW9kZSIsImJ1aWxkUmF0ZUdXeXIiLCJib3R0bGVuZWNrUmF0ZUdXeXIiLCJsaW1pdGluZ0JvdHRsZW5lY2siLCJib3R0bGVuZWNrQW5jaG9yc0dXeXIiLCJ0cmFuc2Zvcm1lcnMiLCJzdWJzdGF0aW9ucyIsInR4IiwiZ2VuZXJhdGlvbiIsInRyYW5zZm9ybWVyc1JhdGUiLCJzdWJzdGF0aW9uc1JhdGUiLCJ0eFJhdGUiLCJnZW5lcmF0aW9uUmF0ZSIsInJhbXBMaW1pdEZyYWMiLCJyYW1wTGltaXRGcmFjUGVyWWVhciIsImNhcGFjaXR5R1dQcmV2IiwiY2FwYWNpdHlHVyIsInBpcGVsaW5lR1ciLCJwaXBlbGluZUxlYWRUaW1lWWVhcnMiLCJwaXBlbGluZUZpbGxGcmFjIiwiYmFja2xvZ0dXUHJldiIsImJ1aWxkYWJsZUdXIiwiaW1wbGljaXRCYWNrbG9nRHJhaW4iLCJFUFMiLCJkZW1hbmRHcm93dGhSYXRlIiwiYnVpbGRvdXRTbW9vdGhGYWN0b3IiLCJERUZBVUxUX01PQklMSVpBVElPTl9QQVJBTVMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/ground_ramping_mobilization.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/model/physicsCost.ts":
/*!**************************************!*\
  !*** ./app/lib/model/physicsCost.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_SMR_PARAMS: function() { return /* binding */ DEFAULT_SMR_PARAMS; },\n/* harmony export */   GROUND_SCENARIOS: function() { return /* binding */ GROUND_SCENARIOS; },\n/* harmony export */   MODEL_UNITS: function() { return /* binding */ MODEL_UNITS; },\n/* harmony export */   computePhysicsCost: function() { return /* binding */ computePhysicsCost; },\n/* harmony export */   getLaunchCostPerKg: function() { return /* binding */ getLaunchCostPerKg; }\n/* harmony export */ });\n/* harmony import */ var _congestion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./congestion */ \"(app-pages-browser)/./app/lib/model/congestion.ts\");\n/* harmony import */ var _edgeInference__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./edgeInference */ \"(app-pages-browser)/./app/lib/model/edgeInference.ts\");\n/* harmony import */ var _orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./orbitalPhysics */ \"(app-pages-browser)/./app/lib/model/orbitalPhysics.ts\");\n/* harmony import */ var _ground_supply_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ground_supply_model */ \"(app-pages-browser)/./app/lib/model/ground_supply_model.ts\");\n/* harmony import */ var _ground_queue_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ground_queue_model */ \"(app-pages-browser)/./app/lib/model/ground_queue_model.ts\");\n/* harmony import */ var _ground_constraint_penalties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ground_constraint_penalties */ \"(app-pages-browser)/./app/lib/model/ground_constraint_penalties.ts\");\n/* harmony import */ var _ground_buildout__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ground_buildout */ \"(app-pages-browser)/./app/lib/model/ground_buildout.ts\");\n/* harmony import */ var _ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ground_ramping_mobilization */ \"(app-pages-browser)/./app/lib/model/ground_ramping_mobilization.ts\");\n/* harmony import */ var _compute_efficiency__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./compute_efficiency */ \"(app-pages-browser)/./app/lib/model/compute_efficiency.ts\");\n/* harmony import */ var _cost_accounting__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./cost_accounting */ \"(app-pages-browser)/./app/lib/model/cost_accounting.ts\");\n/* harmony import */ var _units__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./units */ \"(app-pages-browser)/./app/lib/model/units.ts\");\n/* harmony import */ var _constellation_sizing__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./constellation_sizing */ \"(app-pages-browser)/./app/lib/model/constellation_sizing.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst CONSTANTS = {\n    HOURS_PER_YEAR: 8760,\n    GROUND_HARDWARE_COST_PFLOP_2025: 15000,\n    GROUND_HARDWARE_LIFETIME: 3,\n    MIN_DELIVERED_GFLOPS_PER_W: 20\n};\nconst DEFAULT_SMR_PARAMS = {\n    enabled: false,\n    smrDeploymentStartYear: 2030,\n    smrRampUpYears: 5,\n    electricityCostWithSMR: 50,\n    gridConstraintRelief: 0.90,\n    coolingConstraintRelief: 0.50,\n    waterConstraintRelief: 0.30,\n    landConstraintRelief: 0.60,\n    smrCapexPremium: 1.15\n};\nconst GROUND_SCENARIOS = {\n    unconstrained: {\n        name: \"Unconstrained\",\n        description: \"SMRs + geographic arbitrage solve power/water constraints\",\n        constraintCap: 1.5,\n        gridGrowthRate: 0.02,\n        coolingGrowthRate: 0.01,\n        waterGrowthRate: 0.01,\n        landGrowthRate: 0.01\n    },\n    moderate: {\n        name: \"Moderate\",\n        description: \"Partial adaptation, some persistent friction\",\n        constraintCap: 3.0,\n        gridGrowthRate: 0.03,\n        coolingGrowthRate: 0.02,\n        waterGrowthRate: 0.015,\n        landGrowthRate: 0.015\n    },\n    constrained: {\n        name: \"Constrained (Aggressive Baseline)\",\n        description: \"Accelerated AI demand pressure on infrastructure\",\n        constraintCap: null,\n        gridGrowthRate: 0.07,\n        coolingGrowthRate: 0.04,\n        waterGrowthRate: 0.03,\n        landGrowthRate: 0.03\n    },\n    severe: {\n        name: \"Severe\",\n        description: \"Constrained + carbon tax + water scarcity crisis\",\n        constraintCap: null,\n        gridGrowthRate: 0.09,\n        coolingGrowthRate: 0.06,\n        waterGrowthRate: 0.05,\n        landGrowthRate: 0.04\n    }\n};\nfunction calculateGroundConstraint(year, scenarioKey, enabled) {\n    if (!enabled) return {\n        multiplier: 1.0,\n        breakdown: {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0\n        }\n    };\n    const scenario = GROUND_SCENARIOS[scenarioKey];\n    const yearsFromBase = Math.max(0, year - 2025);\n    const grid = Math.pow(1 + scenario.gridGrowthRate, yearsFromBase);\n    const cooling = Math.pow(1 + scenario.coolingGrowthRate, yearsFromBase);\n    const water = Math.pow(1 + scenario.waterGrowthRate, yearsFromBase);\n    const land = Math.pow(1 + scenario.landGrowthRate, yearsFromBase);\n    let multiplier = grid * cooling * water * land;\n    if (scenario.constraintCap !== null) {\n        multiplier = Math.min(multiplier, scenario.constraintCap);\n    }\n    return {\n        multiplier,\n        breakdown: {\n            grid,\n            cooling,\n            water,\n            land\n        }\n    };\n}\nfunction validateComputeEfficiency(gflopsPerWatt) {\n    let level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"system\";\n    const ranges = {\n        chip: {\n            min: 100,\n            max: 10000\n        },\n        system: {\n            min: 30,\n            max: 5000\n        },\n        datacenter: {\n            min: 10,\n            max: 1000\n        }\n    };\n    const range = ranges[level];\n    if (gflopsPerWatt < range.min || gflopsPerWatt > range.max) {\n        return {\n            valid: false,\n            warning: \"gflopsPerWatt=\".concat(gflopsPerWatt.toFixed(0), \" outside expected range for \").concat(level, \" level (\").concat(range.min, \"-\").concat(range.max, \")\")\n        };\n    }\n    return {\n        valid: true\n    };\n}\nconst SLA_TIERS = {\n    \"basic\": {\n        availabilityTarget: 0.99,\n        maxLatencyToGroundMs: 100,\n        minBandwidthGbps: 1,\n        maxRecoveryTimeMinutes: 60,\n        creditPerViolationPct: 10\n    },\n    \"standard\": {\n        availabilityTarget: 0.999,\n        maxLatencyToGroundMs: 50,\n        minBandwidthGbps: 10,\n        maxRecoveryTimeMinutes: 15,\n        creditPerViolationPct: 25\n    },\n    \"premium\": {\n        availabilityTarget: 0.9999,\n        maxLatencyToGroundMs: 20,\n        minBandwidthGbps: 100,\n        maxRecoveryTimeMinutes: 5,\n        creditPerViolationPct: 50\n    }\n};\nfunction applyStaticFreeze(params) {\n    if (!params.isStaticMode) return params;\n    return {\n        ...params,\n        launchCostKg: 1500,\n        specificPowerWKg: 36.5,\n        groundEffectiveGflopsPerW_2025: 30,\n        orbitEffectiveGflopsPerW_2025: 25,\n        groundConstraintsEnabled: true,\n        powerGridMultiplier: 1.0,\n        coolingMultiplier: 1.0,\n        waterScarcityEnabled: false,\n        landScarcityEnabled: false,\n        deployableArea2025M2: 75,\n        deployableArea2040M2: 75\n    };\n}\n// Cache for monotonicity check\nlet prevLaunchCostCache = new Map();\nfunction getLaunchCostPerKg(year, base2025) {\n    if (year <= 2025) {\n        prevLaunchCostCache.set(year, base2025);\n        return base2025;\n    }\n    const COMMERCIAL_MARKUP = 2.5;\n    const INSURANCE_PCT = 0.05;\n    const INTEGRATION_COST_PER_LAUNCH = 500000; // $500k per launch\n    const ASSUMED_PAYLOAD_KG = 100000; // 100t payload for integration cost amortization\n    // Internal SpaceX cost trajectory (marginal cost)\n    // Normalize base2025 to internal cost scale\n    const internalBase2025 = base2025 / (COMMERCIAL_MARKUP * (1 + INSURANCE_PCT)) - INTEGRATION_COST_PER_LAUNCH / ASSUMED_PAYLOAD_KG;\n    const normalizedBase = Math.max(internalBase2025, 600); // Ensure reasonable internal cost\n    const internalWaypoints = [\n        [\n            2025,\n            normalizedBase\n        ],\n        [\n            2026,\n            800\n        ],\n        [\n            2027,\n            400\n        ],\n        [\n            2028,\n            200\n        ],\n        [\n            2030,\n            75\n        ],\n        [\n            2035,\n            30\n        ],\n        [\n            2040,\n            20\n        ],\n        [\n            2045,\n            15\n        ],\n        [\n            2050,\n            10\n        ] // Internal cost floor\n    ];\n    // Find internal cost\n    let internalCostPerKg = normalizedBase;\n    for(let i = 0; i < internalWaypoints.length - 1; i++){\n        const [y1, c1] = internalWaypoints[i];\n        const [y2, c2] = internalWaypoints[i + 1];\n        if (year >= y1 && year <= y2) {\n            const t = (year - y1) / (y2 - y1);\n            internalCostPerKg = c1 * Math.pow(c2 / c1, t);\n            break;\n        }\n    }\n    if (year > internalWaypoints[internalWaypoints.length - 1][0]) {\n        internalCostPerKg = internalWaypoints[internalWaypoints.length - 1][1];\n    }\n    // Apply commercial markup\n    const withMarkup = internalCostPerKg * COMMERCIAL_MARKUP;\n    const withInsurance = withMarkup * (1 + INSURANCE_PCT);\n    const integrationPerKg = INTEGRATION_COST_PER_LAUNCH / ASSUMED_PAYLOAD_KG;\n    const commercialCostPerKg = withInsurance + integrationPerKg;\n    // Floor: commercial cost never below $30/kg (realistic minimum)\n    let result = Math.max(commercialCostPerKg, 30);\n    // Enforce monotonicity: never increase from previous year\n    const prevYear = year - 1;\n    const prevCost = prevLaunchCostCache.get(prevYear);\n    if (prevCost !== undefined && result > prevCost) {\n        result = prevCost; // Clamp to previous year's cost\n    }\n    prevLaunchCostCache.set(year, result);\n    return result;\n}\nfunction calculateTokenPricing(costPerPflopYear, modelConfig) {\n    const baseFLOPS = modelConfig.params * 2;\n    const precisionMultiplier = {\n        \"fp16\": 1.0,\n        \"fp8\": 0.5,\n        \"int8\": 0.5\n    }[modelConfig.precision];\n    const flopsPerToken = baseFLOPS * precisionMultiplier;\n    const secondsPerYear = 8760 * 3600;\n    const flopsPerPflopYear = 1e15 * secondsPerYear;\n    const tokensPerPflopYear = flopsPerPflopYear / flopsPerToken;\n    const costPerToken = costPerPflopYear / tokensPerPflopYear;\n    return {\n        modelParams: modelConfig.params,\n        precision: modelConfig.precision,\n        flopsPerToken,\n        tokensPerPflopYear,\n        costPerToken,\n        costPer1kTokens: costPerToken * 1000,\n        costPer1mTokens: costPerToken * 1e6\n    };\n}\nfunction calculateGpuHourPricing(costPerPflopYear, params, costBreakdown) {\n    const hoursPerYear = 8760;\n    const costPerGpuYear = costPerPflopYear * params.pflopsPerGpu;\n    const effectiveHours = hoursPerYear * params.utilizationTarget;\n    const basePerHour = costPerGpuYear / effectiveHours;\n    // DEFENSIVE CHECK: GPU-hour price should be in reasonable range ($0.01 to $100)\n    // If costPerPflopYear is insane (e.g., billions), this will catch it\n    if ( true && basePerHour > 1000) {\n        console.error(\"[GPU-HOUR PRICING] Year calculation: basePerHour=\".concat(basePerHour, \" > 1000. \") + \"costPerPflopYear=\".concat(costPerPflopYear, \", pflopsPerGpu=\").concat(params.pflopsPerGpu, \", \") + \"effectiveHours=\".concat(effectiveHours));\n        // Clamp to prevent chart explosion\n        const clampedCostPerPflopYear = Math.min(costPerPflopYear, 10000); // Cap at $10k/PFLOP-year\n        const clampedCostPerGpuYear = clampedCostPerPflopYear * params.pflopsPerGpu;\n        const clampedBasePerHour = clampedCostPerGpuYear / effectiveHours;\n        if (clampedBasePerHour > 100) {\n            throw new Error(\"[GPU-HOUR PRICING] Even after clamping, basePerHour=\".concat(clampedBasePerHour, \" > 100. \") + \"This indicates a unit error or calculation bug. Check costPerPflopYear input.\");\n        }\n    }\n    // Derive breakdown from cost components if provided\n    let powerPerHour = 0;\n    let coolingPerHour = 0;\n    let interconnectPerHour = 0;\n    let opsPerHour = 0;\n    let computePerHour = basePerHour;\n    if (costBreakdown) {\n        const totalBase = (costBreakdown.power || 0) + (costBreakdown.thermal || 0) + (costBreakdown.interconnect || 0) + (costBreakdown.ops || 0) + (costBreakdown.compute || 0);\n        if (totalBase > 0) {\n            // Scale breakdown components to GPU-hour\n            const scale = costPerGpuYear / (totalBase * params.pflopsPerGpu) / effectiveHours;\n            powerPerHour = (costBreakdown.power || 0) * params.pflopsPerGpu * scale;\n            coolingPerHour = (costBreakdown.thermal || 0) * params.pflopsPerGpu * scale;\n            interconnectPerHour = (costBreakdown.interconnect || 0) * params.pflopsPerGpu * scale;\n            opsPerHour = (costBreakdown.ops || 0) * params.pflopsPerGpu * scale;\n            computePerHour = (costBreakdown.compute || 0) * params.pflopsPerGpu * scale;\n        }\n    } else {\n        // Fallback: estimate ops as 5% of base\n        opsPerHour = basePerHour * 0.05;\n    }\n    const nines = -Math.log10(1 - params.sla.availabilityTarget);\n    const sparesRatio = 1 + 0.05 * nines;\n    const sparesPerHour = computePerHour * (sparesRatio - 1);\n    const violationProb = 1 - params.sla.availabilityTarget;\n    const expectedCreditPerHour = violationProb * params.sla.creditPerViolationPct / 100;\n    const slaRiskBuffer = basePerHour * expectedCreditPerHour * 2;\n    const totalCostPerHour = computePerHour + powerPerHour + coolingPerHour + interconnectPerHour + opsPerHour + sparesPerHour + slaRiskBuffer;\n    const margin = totalCostPerHour * params.operatorMarginPct;\n    let pricePerGpuHour = totalCostPerHour + margin;\n    // FINAL CLAMP: GPU-hour price must be in reasonable range ($0.01 to $100)\n    // This prevents chart explosion from unit errors or calculation bugs\n    const MAX_REASONABLE_GPU_HOUR_PRICE = 100;\n    const MIN_REASONABLE_GPU_HOUR_PRICE = 0.01;\n    if (pricePerGpuHour > MAX_REASONABLE_GPU_HOUR_PRICE) {\n        if (true) {\n            console.error(\"[GPU-HOUR PRICING] pricePerGpuHour=\".concat(pricePerGpuHour, \" > \").concat(MAX_REASONABLE_GPU_HOUR_PRICE, \". \") + \"Clamping to \".concat(MAX_REASONABLE_GPU_HOUR_PRICE, \". \") + \"costPerPflopYear=\".concat(costPerPflopYear, \", basePerHour=\").concat(basePerHour, \", totalCostPerHour=\").concat(totalCostPerHour));\n        }\n        pricePerGpuHour = MAX_REASONABLE_GPU_HOUR_PRICE;\n    }\n    if (pricePerGpuHour < MIN_REASONABLE_GPU_HOUR_PRICE && pricePerGpuHour > 0) {\n        pricePerGpuHour = MIN_REASONABLE_GPU_HOUR_PRICE;\n    }\n    return {\n        gpuType: \"H100-equivalent\",\n        location: params.location,\n        sla: params.sla,\n        pricePerGpuHour,\n        costBreakdown: {\n            hardwareAmortization: computePerHour,\n            power: powerPerHour,\n            cooling: coolingPerHour,\n            interconnect: interconnectPerHour,\n            operations: opsPerHour,\n            spares: sparesPerHour,\n            slaRiskBuffer,\n            margin\n        },\n        effectiveUtilization: params.utilizationTarget,\n        sparesRatio\n    };\n}\nconst MODEL_UNITS = {\n    pflopDefinition: \"fp16\",\n    sustainedVsPeak: \"sustained\",\n    gflopsPerWattLevel: \"system\",\n    includesNetworkingOverhead: false\n};\nfunction assertComputePowerConsistency(gflopsPerWatt, computePowerKw, effectivePflops) {\n    let units = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : MODEL_UNITS;\n    // 1 PFLOP = 1e6 GFLOPS\n    // Power (W) = GFLOPS / (GFLOPS/W) = (effectivePflops * 1e6) / gflopsPerWatt\n    // Power (kW) = Power (W) / 1000\n    // gflopsPerWatt is at system level (includes power conversion, cooling)\n    const expectedKw = effectivePflops * 1e6 / gflopsPerWatt / 1000;\n    const discrepancy = computePowerKw / expectedKw;\n    return {\n        valid: discrepancy > 0.5 && discrepancy < 2.0,\n        ratio: discrepancy,\n        expectedKw,\n        discrepancy\n    };\n}\nconst BASE_SITE_2025 = 1500; // Base site cost in 2025 ($/PFLOP-year)\nfunction calculateGroundTotal(year, params, energyCostBase, hardwareCostBase, isStaticMode, effectiveScenario) {\n    let latencyPenalty = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1.0, smrParams = arguments.length > 7 ? arguments[7] : void 0, firstCapYear = arguments.length > 8 ? arguments[8] : void 0, actualEnergyCostPerPflopYear = arguments.length > 9 ? arguments[9] : void 0, actualElectricityPricePerMwh = arguments.length > 10 ? arguments[10] : void 0;\n    const yearsFromBase = Math.max(0, year - 2025);\n    let siteCostBase = BASE_SITE_2025;\n    const enabled = params.groundConstraintsEnabled && !params.isStaticMode;\n    // SMR Toggle logic\n    const smrEnabled = (smrParams === null || smrParams === void 0 ? void 0 : smrParams.enabled) && year >= (smrParams.smrDeploymentStartYear || 2030);\n    let smrRampFactor = 0;\n    let constraintRelief = {\n        grid: 0,\n        cooling: 0,\n        water: 0,\n        land: 0\n    };\n    if (smrEnabled && smrParams) {\n        const yearsActive = year - smrParams.smrDeploymentStartYear;\n        smrRampFactor = Math.min(1, yearsActive / smrParams.smrRampUpYears);\n        // Apply constraint relief\n        constraintRelief = {\n            grid: smrParams.gridConstraintRelief * smrRampFactor,\n            cooling: smrParams.coolingConstraintRelief * smrRampFactor,\n            water: smrParams.waterConstraintRelief * smrRampFactor,\n            land: smrParams.landConstraintRelief * smrRampFactor\n        };\n        siteCostBase = BASE_SITE_2025 * (1 + (smrParams.smrCapexPremium - 1) * smrRampFactor);\n    }\n    // REFACTORED: Split energy (no multiplier) vs capacity/delivery premium (with multiplier)\n    // \n    // Energy cost: Raw electricity price * kWh (NO constraint multiplier)\n    // - Represents actual market electricity price\n    // - Grows with electricity price trajectory, not infrastructure scarcity\n    const energyCost = actualEnergyCostPerPflopYear !== null && actualEnergyCostPerPflopYear !== void 0 ? actualEnergyCostPerPflopYear : energyCostBase;\n    const effectiveElectricityPrice = actualElectricityPricePerMwh !== null && actualElectricityPricePerMwh !== void 0 ? actualElectricityPricePerMwh : 120;\n    if (!enabled) {\n        // No constraints: all costs at base, no premium\n        const total = (energyCost + siteCostBase + hardwareCostBase) * latencyPenalty;\n        return {\n            energyCost: energyCost * latencyPenalty,\n            siteCost: siteCostBase * latencyPenalty,\n            hardwareCost: hardwareCostBase * latencyPenalty,\n            capacityDeliveryPremium: 0,\n            timeToEnergizePenalty: 0,\n            totalCostPerPflopYear: total,\n            constraintMultiplier: 1.0,\n            breakdown: {\n                grid: 1.0,\n                cooling: 1.0,\n                water: 1.0,\n                land: 1.0,\n                energyMultiplier: 1.0,\n                siteMultiplier: 1.0,\n                capacityDeliveryMultiplier: 1.0\n            },\n            smrEnabled,\n            smrRampFactor,\n            effectiveElectricityCost: effectiveElectricityPrice,\n            constraintRelief\n        };\n    }\n    // CRITICAL FIX: Use queue-derived constraints, NOT time-based exponential\n    // This function is only used when NOT using buildout/queue models (legacy path)\n    // For consistency, use minimal constraints here (base costs only)\n    // Real constraint pricing should come from buildout/queue models\n    // GROUND COST ACCOUNTING: Explicit separation of components (ADDITIVE ONLY)\n    // \n    // 1. siteCapexAmortPerPflopYear: Pure amortized capex\n    //    - Buildings + power delivery inside site + cooling plant\n    //    - Base cost, NOT affected by constraint\n    const siteCapexAmortPerPflopYear = siteCostBase;\n    // 2. capacityDeliveryPremiumPerPflopYear: Scarcity price for firm MW at right place/time\n    //    - Set to zero in legacy path (constraints should come from buildout/queue models)\n    //    - This path is only for backward compatibility\n    const capacityDeliveryPremiumPerPflopYear = 0;\n    // 3. timeToEnergizePenaltyPerPflopYear: Financing cost of waiting (WACC + delay years)\n    //    - Set to zero in legacy path (delay penalties should come from buildout/queue models)\n    //    - This path is only for backward compatibility\n    const timeToEnergizePenaltyPerPflopYear = 0;\n    // CRITICAL: Remove double counting\n    // Do NOT include timeToEnergizePenalty in headline cost used for crossover\n    // (capacity gating in market share already accounts for backlog)\n    // Compute both base and effective costs:\n    const siteCostPerPflopYear_base = siteCapexAmortPerPflopYear + capacityDeliveryPremiumPerPflopYear;\n    const siteCostPerPflopYear_effective = siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + capacityDeliveryPremiumPerPflopYear;\n    // Validation: siteCost_effective must equal sum of components\n    const siteCostCheck = Math.abs(siteCostPerPflopYear_effective - (siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + capacityDeliveryPremiumPerPflopYear));\n    if (siteCostCheck > 0.01) {\n        throw new Error(\"Site cost accounting error: siteCost_effective=\".concat(siteCostPerPflopYear_effective, \" != sum(components)=\").concat(siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + capacityDeliveryPremiumPerPflopYear, \", diff=\").concat(siteCostCheck));\n    }\n    const hardware = hardwareCostBase;\n    // Headline cost for crossover: base only (excludes delay penalty, which is handled via capacity gating)\n    const total = (energyCost + siteCostPerPflopYear_base + hardware) * latencyPenalty;\n    // Effective/all-in cost: includes delay penalty (for reference/debug)\n    const totalEffective = (energyCost + siteCostPerPflopYear_effective + hardware) * latencyPenalty;\n    return {\n        energyCost: energyCost * latencyPenalty,\n        siteCost: siteCostPerPflopYear_base * latencyPenalty,\n        hardwareCost: hardware * latencyPenalty,\n        siteCapexAmortPerPflopYear: siteCapexAmortPerPflopYear * latencyPenalty,\n        capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear * latencyPenalty,\n        timeToEnergizePenalty: timeToEnergizePenaltyPerPflopYear * latencyPenalty,\n        totalCostPerPflopYear: total,\n        totalCostPerPflopYearEffective: totalEffective,\n        constraintMultiplier: 1.0,\n        breakdown: {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        },\n        constraints: {\n            method: \"adders\",\n            capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear * latencyPenalty,\n            delayPenalty: timeToEnergizePenaltyPerPflopYear * latencyPenalty,\n            appliedMultipliers: {\n                constraintMultiplierUsed: false,\n                energyMultiplierUsed: false,\n                siteMultiplierUsed: false\n            },\n            debug: {\n                doubleCountCheck: {\n                    mode: \"adders\",\n                    multiplierApplied: false,\n                    addersApplied: capacityDeliveryPremiumPerPflopYear > 0 || timeToEnergizePenaltyPerPflopYear > 0,\n                    invariantOk: true,\n                    notes: \"calculateGroundTotal uses adders only (capacityDeliveryPremium + timeToEnergizePenalty)\"\n                }\n            }\n        },\n        smrEnabled,\n        smrRampFactor,\n        effectiveElectricityCost: effectiveElectricityPrice,\n        constraintRelief\n    };\n}\nfunction computePhysicsCost(rawParams) {\n    let firstCapYear = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n    var _hybridResult_regulatory, _groundResult_constraints, _groundResult_constraints1, _params_edgeInference, _hybridResult_specificPowerMultipliers, _hybridResult_computePayload, _hybridResult_specificPowerMultipliers1, _groundResult_buildoutDebug, _groundResult_supplyMetrics, _groundResult_supplyMetrics1, _groundResult_supplyMetrics2, _groundResult_buildoutDebug1, _groundResult_supplyMetrics3, _groundResult_buildoutDebug2, _groundResult_buildoutDebug3;\n    const params = applyStaticFreeze(rawParams);\n    const { year, isStaticMode, launchCostKg: baseLaunchCost, specificPowerWKg: trajSpecificPower, groundEffectiveGflopsPerW_2025: rawGroundEffectiveGflopsPerW_2025, orbitEffectiveGflopsPerW_2025: rawOrbitEffectiveGflopsPerW_2025, pueGround, pueOrbital, capacityFactorGround, targetGW, satellitePowerKW, groundConstraintsEnabled, powerGridMultiplier, coolingMultiplier, waterScarcityEnabled, landScarcityEnabled, spaceTrafficEnabled, orbitalAltitude, useRadHardChips, sunFraction, groundScenario, smrMitigationEnabled, workloadType, elonScenarioEnabled, globalLatencyRequirementEnabled, spaceManufacturingEnabled, aiWinterEnabled } = params;\n    var _ref;\n    // CRITICAL FIX: Handle parameter name migration\n    // Old names: flopsPerWattGround, flopsPerWattOrbital (DEPRECATED - delete conversion logic)\n    // New names: groundEffectiveGflopsPerW_2025, orbitEffectiveGflopsPerW_2025\n    // Parameters are ALREADY in GFLOPS/W (not FLOPS/W) - no conversion needed\n    const actualGroundInput = (_ref = rawGroundEffectiveGflopsPerW_2025 !== null && rawGroundEffectiveGflopsPerW_2025 !== void 0 ? rawGroundEffectiveGflopsPerW_2025 : params.gflopsPerWattGround2025) !== null && _ref !== void 0 ? _ref : params.flopsPerWattGround;\n    var _ref1;\n    const actualOrbitInput = (_ref1 = rawOrbitEffectiveGflopsPerW_2025 !== null && rawOrbitEffectiveGflopsPerW_2025 !== void 0 ? rawOrbitEffectiveGflopsPerW_2025 : params.gflopsPerWattOrbital2025) !== null && _ref1 !== void 0 ? _ref1 : params.flopsPerWattOrbital;\n    // CANONICAL COMPUTE EFFICIENCY: Single source of truth for GFLOPS/W\n    // Parameter is interpreted as GFLOPS/W (not FLOPS/W) - no 1e9/1e12 conversions\n    let groundEfficiencyResult;\n    let orbitalEfficiencyResult;\n    // Ground: Use canonical ComputeEfficiency function\n    // CRITICAL FIX: Parameter is ALREADY in GFLOPS/W (not FLOPS/W)\n    // No unit conversion - treat input as effective GFLOPS/W directly\n    if (!actualGroundInput || !isFinite(actualGroundInput) || actualGroundInput <= 0) {\n        // Invalid input - use default\n        groundEfficiencyResult = (0,_compute_efficiency__WEBPACK_IMPORTED_MODULE_8__.getDefaultComputeEfficiency)(\"NVIDIA H100 SXM\", year, \"FP16\");\n    } else {\n        // Input is effective GFLOPS/W - derive chip peak assuming standard factors\n        // effective = chipPeak * utilization / systemOverhead\n        // So: chipPeak = effective * systemOverhead / utilization\n        const systemOverheadFactor = 1.18; // PUE 1.18 equivalent\n        const utilizationFactor = 0.70;\n        const chipPeakGflopsPerW = actualGroundInput * systemOverheadFactor / utilizationFactor;\n        // FAIL-FAST INVARIANT: Chip peak must be in realistic range [1, 20000] GFLOPS/W\n        if (chipPeakGflopsPerW < 1 || chipPeakGflopsPerW > 20000) {\n            throw new Error(\"GROUND COMPUTE EFFICIENCY UNIT MISMATCH: \" + \"chipPeakGflopsPerW=\".concat(chipPeakGflopsPerW.toFixed(2), \" is outside valid range [1, 20000] GFLOPS/W. \") + \"Input: actualGroundInput=\".concat(actualGroundInput, \", \") + \"This suggests a units error. Expected range: 30-5000 GFLOPS/W for system-level efficiency.\");\n        }\n        groundEfficiencyResult = (0,_compute_efficiency__WEBPACK_IMPORTED_MODULE_8__.ComputeEfficiency)({\n            chipPeakGflopsPerW,\n            utilizationFactor,\n            systemOverheadFactor\n        });\n        // FAIL-FAST INVARIANT: Effective GFLOPS/W must be in realistic range [1, 5000] GFLOPS/W\n        if (groundEfficiencyResult.effectiveGflopsPerW < 1 || groundEfficiencyResult.effectiveGflopsPerW > 5000) {\n            throw new Error(\"GROUND COMPUTE EFFICIENCY OUT OF RANGE: \" + \"effectiveGflopsPerW=\".concat(groundEfficiencyResult.effectiveGflopsPerW.toFixed(2), \" is outside valid range [1, 5000] GFLOPS/W. \") + \"Input: actualGroundInput=\".concat(actualGroundInput, \", \") + \"chipPeakGflopsPerW=\".concat(chipPeakGflopsPerW.toFixed(2), \". \") + \"This suggests a units error or invalid input.\");\n        }\n    }\n    // Orbital: Same logic - parameter is ALREADY in GFLOPS/W (not FLOPS/W)\n    // No unit conversion - treat input as effective GFLOPS/W directly\n    if (!actualOrbitInput || !isFinite(actualOrbitInput) || actualOrbitInput <= 0) {\n        // Invalid input - use default\n        orbitalEfficiencyResult = (0,_compute_efficiency__WEBPACK_IMPORTED_MODULE_8__.getDefaultComputeEfficiency)(\"H100-equivalent (rad-tolerant)\", year, \"FP16\");\n    } else {\n        // Input is effective GFLOPS/W - derive chip peak\n        const systemOverheadFactor = 1.18;\n        const utilizationFactor = 0.65;\n        const chipPeakGflopsPerW = actualOrbitInput * systemOverheadFactor / utilizationFactor;\n        // FAIL-FAST INVARIANT: Chip peak must be in realistic range [1, 20000] GFLOPS/W\n        if (chipPeakGflopsPerW < 1 || chipPeakGflopsPerW > 20000) {\n            throw new Error(\"ORBITAL COMPUTE EFFICIENCY UNIT MISMATCH: \" + \"chipPeakGflopsPerW=\".concat(chipPeakGflopsPerW.toFixed(2), \" is outside valid range [1, 20000] GFLOPS/W. \") + \"Input: actualOrbitInput=\".concat(actualOrbitInput, \", \") + \"This suggests a units error. Expected range: 25-4000 GFLOPS/W for system-level efficiency.\");\n        }\n        orbitalEfficiencyResult = (0,_compute_efficiency__WEBPACK_IMPORTED_MODULE_8__.ComputeEfficiency)({\n            chipPeakGflopsPerW,\n            utilizationFactor,\n            systemOverheadFactor\n        });\n        // FAIL-FAST INVARIANT: Effective GFLOPS/W must be in realistic range [1, 5000] GFLOPS/W\n        if (orbitalEfficiencyResult.effectiveGflopsPerW < 1 || orbitalEfficiencyResult.effectiveGflopsPerW > 5000) {\n            throw new Error(\"ORBITAL COMPUTE EFFICIENCY OUT OF RANGE: \" + \"effectiveGflopsPerW=\".concat(orbitalEfficiencyResult.effectiveGflopsPerW.toFixed(2), \" is outside valid range [1, 5000] GFLOPS/W. \") + \"Input: actualOrbitInput=\".concat(actualOrbitInput, \", \") + \"chipPeakGflopsPerW=\".concat(chipPeakGflopsPerW.toFixed(2), \". \") + \"This suggests a units error or invalid input.\");\n        }\n    }\n    // HARD ASSERT: Ground efficiency must always be populated and finite\n    if (!groundEfficiencyResult || !isFinite(groundEfficiencyResult.effectiveGflopsPerW) || groundEfficiencyResult.effectiveGflopsPerW <= 0) {\n        throw new Error(\"CRITICAL: Ground compute efficiency is invalid. \" + \"actualGroundInput=\".concat(actualGroundInput, \", \") + \"rawGroundEffectiveGflopsPerW_2025=\".concat(rawGroundEffectiveGflopsPerW_2025, \", \") + \"gflopsPerWattGround2025=\".concat(params.gflopsPerWattGround2025, \", \") + \"groundEfficiencyResult=\".concat(JSON.stringify(groundEfficiencyResult)));\n    }\n    // CRITICAL FIX: Standardize compute-efficiency level definitions\n    // Standard definitions:\n    // - peakGflopsPerWatt: chip peak (no utilization, no overhead, no derates)\n    // - systemEffectiveGflopsPerWatt: peak * utilization / systemOverheadFactor (SYSTEM-LEVEL EFFECTIVE)\n    // - deliveredGflopsPerWatt: systemEffective * thermalCapFactor * radiationDerate * availability\n    // Ground: systemEffective only (no delivery derates)\n    const groundEffectiveGflopsPerW = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(groundEfficiencyResult.effectiveGflopsPerW, \"ground efficiency calculation\");\n    // Orbital: Track all three levels\n    const orbitPeakGflopsPerWatt = orbitalEfficiencyResult.debug.chipPeakGflopsPerW;\n    const orbitSystemEffectiveGflopsPerWatt = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(orbitalEfficiencyResult.effectiveGflopsPerW, \"orbital systemEffective efficiency calculation\");\n    // NOTE: deliveredGflopsPerWatt will be calculated after thermal system is computed\n    // It will be: systemEffective * thermalCapFactor * radiationDerate * availability\n    // AI Winter: Constraints grow 50% slower\n    const effectiveGroundScenario = aiWinterEnabled && year >= 2028 ? {\n        ...GROUND_SCENARIOS[groundScenario],\n        gridGrowthRate: GROUND_SCENARIOS[groundScenario].gridGrowthRate * 0.5,\n        coolingGrowthRate: GROUND_SCENARIOS[groundScenario].coolingGrowthRate * 0.5,\n        waterGrowthRate: GROUND_SCENARIOS[groundScenario].waterGrowthRate * 0.5,\n        landGrowthRate: GROUND_SCENARIOS[groundScenario].landGrowthRate * 0.5\n    } : GROUND_SCENARIOS[groundScenario];\n    // Elon Scenario: Discounts\n    const launchDiscount = elonScenarioEnabled ? 0.50 : 1.0;\n    const powerDiscount = elonScenarioEnabled ? 0.70 : 1.0;\n    const networkingDiscount = elonScenarioEnabled ? 0.10 : 1.0;\n    const operatorMargin = elonScenarioEnabled ? 0.05 : 0.20;\n    // Global Latency: 3x ground overprovisioning penalty\n    const groundLatencyPenalty = globalLatencyRequirementEnabled && year >= 2028 ? 3.0 : 1.0;\n    // Space Manufacturing: Mass reduction\n    let massMultiplier = 1.0;\n    if (spaceManufacturingEnabled && year >= 2032) {\n        const yearsSinceStart = year - 2032;\n        const ramp = Math.min(1.0, yearsSinceStart / 5);\n        massMultiplier = 1.0 - 0.60 * ramp;\n    }\n    // EMERGENCY FIX: Use simple fixed 2025 base values\n    // These are the known-correct values from the emergency fix\n    // Don't try to calculate from flopsPerWatt - just use these constants\n    const BASE_ENERGY_2025 = 581; // $/PFLOP-year (fixed 2025 base)\n    const BASE_SITE_2025 = 1500; // $/PFLOP-year (fixed 2025 base)\n    const ENERGY_COST_BASE_2025 = BASE_ENERGY_2025; // Use fixed base, not calculated\n    // For reference/display (not used in constraint calculation)\n    const BASE_ELECTRICITY_PRICE_2025 = 120; // $/MWh (2025 baseline)\n    let groundElectricityPricePerMwh = BASE_ELECTRICITY_PRICE_2025;\n    if (!params.isStaticMode) {\n        groundElectricityPricePerMwh *= Math.pow(1.02, year - 2025);\n    }\n    const effectivePueGround = pueGround + (year - 2025) * 0.01;\n    // Convert GFLOPS/W to power: 1 PFLOP = 1e6 GFLOPS, so power (W) = (1e6 GFLOPS) / (GFLOPS/W)\n    const groundEnergyMWhPerPflopYear = 8760 * 1e6 / groundEffectiveGflopsPerW * effectivePueGround / 1e6;\n    const groundEnergyCostPerPflopYear = groundEnergyMWhPerPflopYear * groundElectricityPricePerMwh * capacityFactorGround;\n    const computeGroundHardwareCost = (y, baseCost)=>{\n        const yearIndex = y - 2025;\n        let cost = baseCost;\n        for(let i = 0; i < yearIndex; i++){\n            let annualDecline;\n            if (i < 3) annualDecline = 0.10;\n            else if (i < 6) annualDecline = 0.05;\n            else if (i < 10) annualDecline = 0.02;\n            else annualDecline = 0.005;\n            cost *= 1 - annualDecline;\n        }\n        return cost;\n    };\n    var _params_groundHardwareLifetimeYears;\n    const groundLifetime = (_params_groundHardwareLifetimeYears = params.groundHardwareLifetimeYears) !== null && _params_groundHardwareLifetimeYears !== void 0 ? _params_groundHardwareLifetimeYears : CONSTANTS.GROUND_HARDWARE_LIFETIME;\n    const groundHardwareCapexPerPflopYear = computeGroundHardwareCost(year, CONSTANTS.GROUND_HARDWARE_COST_PFLOP_2025) / groundLifetime;\n    const smrParams = params.smrToggleEnabled ? params.smrToggleParams || DEFAULT_SMR_PARAMS : undefined;\n    let groundResult;\n    let groundTotalCost;\n    let groundComparatorCostPerPflopYear; // Comparator cost for crossover (uses effective when queue exists)\n    let groundHasQueue = false; // Track if ground has queue/backlog (for debug and comparator cost)\n    let energyConstraintMultiplier;\n    let constraintBreakdown;\n    const useRegionalModel = params.useRegionalGroundModel === true && params.groundConstraintsEnabled && !params.isStaticMode;\n    const useBuildoutModel = params.useBuildoutModel === true && params.groundConstraintsEnabled && !params.isStaticMode && !useRegionalModel;\n    const useQueueModel = params.useQueueBasedConstraint !== false && params.groundConstraintsEnabled && !params.isStaticMode && !useRegionalModel && !useBuildoutModel;\n    if (useQueueModel) {\n        const supplyTrajectory = (0,_ground_queue_model__WEBPACK_IMPORTED_MODULE_4__.generateGroundSupplyTrajectory)(2025, year);\n        const currentSupplyState = supplyTrajectory[supplyTrajectory.length - 1];\n        var _params_wacc, _params_waccBacklogK, _params_waccBacklogExponent, _params_criticalBacklogGW;\n        // Calculate WACC-based penalties and multipliers\n        // Pass WACC parameters for capital rationing (WACC rises with backlog)\n        const waccParams = {\n            baseWacc: (_params_wacc = params.wacc) !== null && _params_wacc !== void 0 ? _params_wacc : 0.10,\n            waccBacklogK: (_params_waccBacklogK = params.waccBacklogK) !== null && _params_waccBacklogK !== void 0 ? _params_waccBacklogK : 0.5,\n            waccBacklogExponent: (_params_waccBacklogExponent = params.waccBacklogExponent) !== null && _params_waccBacklogExponent !== void 0 ? _params_waccBacklogExponent : 1.2,\n            criticalBacklogGW: (_params_criticalBacklogGW = params.criticalBacklogGW) !== null && _params_criticalBacklogGW !== void 0 ? _params_criticalBacklogGW : 50\n        };\n        const penalties = (0,_ground_constraint_penalties__WEBPACK_IMPORTED_MODULE_5__.calculateGroundConstraintPenalties)(currentSupplyState, groundEffectiveGflopsPerW, effectivePueGround, capacityFactorGround, waccParams);\n        const BASE_SITE_2025 = 1500;\n        // Energy cost: Use actual calculated value (NOT multiplied by constraint)\n        // CRITICAL FIX: Do NOT apply PUE multiplier - energy cost is base only\n        // PUE stress should be reflected in capacityDeliveryPremium, not energy multiplier\n        const energyCostBase = groundEnergyCostPerPflopYear;\n        const energyCost = energyCostBase; // Base energy cost only - no multiplier\n        // GROUND COST ACCOUNTING: Explicit separation of components (queue model)\n        const siteCostBase = BASE_SITE_2025;\n        // 1. siteCapexAmortPerPflopYear: Pure amortized capex (NOT affected by constraint)\n        const siteCapexAmortPerPflopYear = siteCostBase;\n        // CHOICE: Use delayPenalty + scarcityRent (Hill-based), NOT capacityDeliveryPremium\n        // Set capacityDeliveryPremium to 0 to avoid triple-charging\n        const capacityDeliveryPremiumPerPflopYear = 0; // NOT USED - using delayPenalty + scarcityRent instead\n        // 1. timeToEnergizePenaltyPerPflopYear: Bounded linear WACC carry (NOT exponential)\n        const timeToEnergizePenaltyPerPflopYear = penalties.timeToEnergizePenaltyPerPflopYear;\n        // 2. scarcityRentPerPflopYear: Hill function of avgWaitYears (w50=2.0, n=2.0, rentMax=0.65)\n        // Base cost for scarcity rent = hardware + site (no capacityDeliveryPremium)\n        const capexAnnualBasePerPflopYear = groundHardwareCapexPerPflopYear + siteCapexAmortPerPflopYear;\n        // Calculate scarcity multiplier using LOG-BASED function (never fully saturates)\n        // Returns multiplier (1.0 = no scarcity, 2.0 = 2x price) - MULTIPLICATIVE, not additive\n        const scarcityRentResult = (0,_ground_constraint_penalties__WEBPACK_IMPORTED_MODULE_5__.calculateScarcityRent)(currentSupplyState.avgWaitYears, currentSupplyState.utilizationPct, {\n            waitThresholdYears: 1.0,\n            rentMaxMultiplier: 2.0,\n            utilizationThreshold: 0.85\n        });\n        const scarcityMultiplier = scarcityRentResult.scarcityMultiplier;\n        // For backward compatibility: scarcityRentPerPflopYear = 0 (scarcity is now multiplicative)\n        const scarcityRentPerPflopYear = 0;\n        // Debug: verify queue model consistency\n        if (true) {\n            var _currentSupplyState_unservedGw;\n            const unservedGw = (_currentSupplyState_unservedGw = currentSupplyState.unservedGw) !== null && _currentSupplyState_unservedGw !== void 0 ? _currentSupplyState_unservedGw : currentSupplyState.demandGw - currentSupplyState.capacityGw;\n            if (currentSupplyState.demandGw < currentSupplyState.capacityGw && currentSupplyState.backlogGw > 50) {\n                console.warn(\"[QUEUE MODEL] Year \".concat(year, \": demandGw=\").concat(currentSupplyState.demandGw.toFixed(1), \" < capacityGw=\").concat(currentSupplyState.capacityGw.toFixed(1), \" \") + \"but backlogGw=\".concat(currentSupplyState.backlogGw.toFixed(1), \" > 50. This may indicate queue model issue.\"));\n            }\n        }\n        // CRITICAL: Remove double counting\n        // Do NOT include timeToEnergizePenalty + scarcityRent in headline cost used for crossover\n        // (capacity gating in market share already accounts for backlog)\n        // Compute both base and effective costs:\n        const siteCostPerPflopYear_base = siteCapexAmortPerPflopYear; // No capacityDeliveryPremium\n        const siteCostPerPflopYear_effective = siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + scarcityRentPerPflopYear;\n        // Validation\n        const expectedEffective = siteCapexAmortPerPflopYear + capacityDeliveryPremiumPerPflopYear + timeToEnergizePenaltyPerPflopYear + scarcityRentPerPflopYear;\n        const siteCostCheck = Math.abs(siteCostPerPflopYear_effective - expectedEffective);\n        if (siteCostCheck > 0.01) {\n            throw new Error(\"Site cost accounting error (queue model): siteCost_effective=\".concat(siteCostPerPflopYear_effective, \" != sum(components)=\").concat(expectedEffective, \" (siteCapex=\").concat(siteCapexAmortPerPflopYear, \", premium=\").concat(capacityDeliveryPremiumPerPflopYear, \", delay=\").concat(timeToEnergizePenaltyPerPflopYear, \", scarcity=\").concat(scarcityRentPerPflopYear, \"), diff=\").concat(siteCostCheck));\n        }\n        const hardwareCost = groundHardwareCapexPerPflopYear;\n        // UNIFIED SCARCITY ACCOUNTING: Keep totalCostPerPflopYear physical-only\n        // Scarcity (delayPenalty + scarcityRent) is treated purely in GPU-hour pricing, not in PFLOP-year cost\n        groundTotalCost = (energyCost + siteCostPerPflopYear_base + hardwareCost) * groundLatencyPenalty;\n        // For crossover: use base cost (scarcity is already reflected in GPU-hour pricing)\n        // This ensures we don't double-count scarcity\n        groundHasQueue = timeToEnergizePenaltyPerPflopYear > 0.01;\n        groundComparatorCostPerPflopYear = groundTotalCost; // Base cost only (scarcity in GPU-hour)\n        // CRITICAL FIX: Remove all multipliers - use additive terms only\n        // Multipliers are NOT applied to any dollar amounts\n        // All constraint effects are captured in capacityDeliveryPremium and timeToEnergizePenalty\n        energyConstraintMultiplier = 1.0; // Never applied - for backward compat only\n        // Constraint breakdown: all multipliers set to 1.0 (not applied)\n        // These are kept for debug/decomposition but never multiplied into costs\n        constraintBreakdown = {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        };\n        var _currentSupplyState_avgWaitYearsRaw, _currentSupplyState_unservedGw1, _currentSupplyState_deliveredFromBacklogGw, _currentSupplyState_unservedGw2, _currentSupplyState_deliveredFromBacklogGw1, _currentSupplyState_avgWaitYearsRaw1;\n        groundResult = {\n            energyCost: energyCost * groundLatencyPenalty,\n            siteCost: siteCostPerPflopYear_base * groundLatencyPenalty,\n            hardwareCost: hardwareCost * groundLatencyPenalty,\n            siteCapexAmortPerPflopYear: siteCapexAmortPerPflopYear * groundLatencyPenalty,\n            capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear * groundLatencyPenalty,\n            timeToEnergizePenalty: timeToEnergizePenaltyPerPflopYear * groundLatencyPenalty,\n            totalCostPerPflopYear: groundTotalCost,\n            totalCostPerPflopYearEffective: groundTotalCost,\n            totalCostPerPflopYearAllIn: groundTotalCost,\n            constraintMultiplier: 1.0,\n            breakdown: constraintBreakdown,\n            constraints: {\n                method: \"adders\",\n                capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear * groundLatencyPenalty,\n                delayPenalty: timeToEnergizePenaltyPerPflopYear * groundLatencyPenalty,\n                scarcityRentPerPflopYear: scarcityRentPerPflopYear * groundLatencyPenalty,\n                scarcityMultiplier: scarcityMultiplier,\n                appliedMultipliers: {\n                    constraintMultiplierUsed: false,\n                    energyMultiplierUsed: false,\n                    siteMultiplierUsed: false\n                },\n                // Debug fields for Hill-based scarcity rent (wait-time based)\n                scarcityHill: scarcityRentResult.scarcityHill,\n                avgWaitYearsRaw: (_currentSupplyState_avgWaitYearsRaw = currentSupplyState.avgWaitYearsRaw) !== null && _currentSupplyState_avgWaitYearsRaw !== void 0 ? _currentSupplyState_avgWaitYearsRaw : currentSupplyState.avgWaitYears,\n                avgWaitYearsClamped: scarcityRentResult.avgWaitYearsClamped,\n                rentFrac: scarcityRentResult.rentFrac,\n                // Additional debug fields for verification\n                backlogGw: currentSupplyState.backlogGw,\n                unservedGw: (_currentSupplyState_unservedGw1 = currentSupplyState.unservedGw) !== null && _currentSupplyState_unservedGw1 !== void 0 ? _currentSupplyState_unservedGw1 : 0,\n                deliveredFromBacklogGw: (_currentSupplyState_deliveredFromBacklogGw = currentSupplyState.deliveredFromBacklogGw) !== null && _currentSupplyState_deliveredFromBacklogGw !== void 0 ? _currentSupplyState_deliveredFromBacklogGw : 0,\n                baseCostPerPflopYear: capexAnnualBasePerPflopYear * groundLatencyPenalty,\n                totalCostPerPflopYear: groundTotalCost\n            },\n            supplyMetrics: {\n                demandGw: currentSupplyState.demandGw,\n                capacityGw: currentSupplyState.capacityGw,\n                pipelineGw: currentSupplyState.pipelineGw,\n                maxBuildRateGwYear: currentSupplyState.maxBuildRateGwYear,\n                avgWaitYears: currentSupplyState.avgWaitYears,\n                utilizationPct: currentSupplyState.utilizationPct,\n                // Debug fields for queue model verification\n                backlogGw: currentSupplyState.backlogGw,\n                unservedGw: (_currentSupplyState_unservedGw2 = currentSupplyState.unservedGw) !== null && _currentSupplyState_unservedGw2 !== void 0 ? _currentSupplyState_unservedGw2 : 0,\n                deliveredFromBacklogGw: (_currentSupplyState_deliveredFromBacklogGw1 = currentSupplyState.deliveredFromBacklogGw) !== null && _currentSupplyState_deliveredFromBacklogGw1 !== void 0 ? _currentSupplyState_deliveredFromBacklogGw1 : 0,\n                avgWaitYearsRaw: (_currentSupplyState_avgWaitYearsRaw1 = currentSupplyState.avgWaitYearsRaw) !== null && _currentSupplyState_avgWaitYearsRaw1 !== void 0 ? _currentSupplyState_avgWaitYearsRaw1 : currentSupplyState.avgWaitYears\n            },\n            constraintComponents: {\n                queuePressure: currentSupplyState.avgWaitYears > 0 ? 1 + currentSupplyState.avgWaitYears / 2 : 1,\n                utilizationPressure: currentSupplyState.utilizationPct > 0.85 ? 1 + (currentSupplyState.utilizationPct - 0.85) * 5 : 1,\n                scarcityPremium: penalties.siteMultiplier\n            },\n            // Debug fields for WACC penalties\n            backlogGw: penalties.backlogGw,\n            avgWaitYears: penalties.avgWaitYears,\n            capexAtRiskPerMW: penalties.capexAtRiskPerMW,\n            carryCostPerMW: penalties.carryCostPerMW,\n            lostMarginPerMW: penalties.lostMarginPerMW,\n            timeToEnergizePenaltyPerPflopYear: penalties.timeToEnergizePenaltyPerPflopYear,\n            pueMultiplier: penalties.pueMultiplier,\n            smrEnabled: false,\n            smrRampFactor: 0,\n            effectiveElectricityCost: groundElectricityPricePerMwh,\n            constraintRelief: {\n                grid: 0,\n                cooling: 0,\n                water: 0,\n                land: 0\n            }\n        };\n    } else if (useBuildoutModel) {\n        var _groundResult_buildoutDebug4;\n        // NEW: Ramping Mobilization Model\n        // Replaces constraint multiplier with explicit buildout capex premium and delay penalties\n        // Uses ramping buildout capacity with smooth interpolation\n        // Get mobilization parameters (use defaults if not provided)\n        const mobilizationParams = params.mobilizationParams ? {\n            ..._ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_MOBILIZATION_PARAMS,\n            ...params.mobilizationParams,\n            demandCurve: params.mobilizationParams.demandCurve || _ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_MOBILIZATION_PARAMS.demandCurve\n        } : _ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_MOBILIZATION_PARAMS;\n        var _params_prevMobilizationState;\n        // Get previous mobilization state from params (passed from trajectory)\n        // If not provided, calculate from previous year's demand\n        const prevMobilizationState = (_params_prevMobilizationState = params.prevMobilizationState) !== null && _params_prevMobilizationState !== void 0 ? _params_prevMobilizationState : null;\n        // Step mobilization state forward\n        // Pass responsive demand and orbital substitution if available (from trajectory.ts)\n        const responsiveDemandGW = params.responsiveDemandGW;\n        const orbitalSubstitutionGW = params.orbitalSubstitutionGW;\n        const mobilizationResult = (0,_ground_ramping_mobilization__WEBPACK_IMPORTED_MODULE_7__.stepMobilizationState)(prevMobilizationState, mobilizationParams, year, effectivePueGround, 0, orbitalSubstitutionGW, responsiveDemandGW // Pass responsive demand (overrides hardcoded)\n        );\n        // Extract values from mobilization model\n        const demandNewGW = mobilizationResult.demandNewGW;\n        const buildRateGWyr = mobilizationResult.buildRateGWyr;\n        const buildableGW = buildRateGWyr; // buildable = build rate\n        const capacityGW = mobilizationResult.capacityGW;\n        const pipelineGW = mobilizationResult.pipelineGW;\n        const backlogGW = mobilizationResult.backlogGW;\n        const avgWaitYears = mobilizationResult.avgWaitYears;\n        var _params_wacc1;\n        // Default buildout parameters\n        const baseWacc = (_params_wacc1 = params.wacc) !== null && _params_wacc1 !== void 0 ? _params_wacc1 : 0.10; // 10% base WACC\n        const PROJECT_LIFETIME = 20; // 20 years\n        const BUILDOUT_CAPEX_BASE = 2000; // $2k/kW base buildout capex (reduced from 3k)\n        const DEFAULT_SCARCITY_CURVE = {\n            k: 2.0,\n            exponent: 1.7,\n            thresholdUtil: 0.0\n        };\n        const PANIC_EXPONENT = 1.3; // Exponent for delay penalty panic regime\n        var _params_waccBacklogK1;\n        // Compute effective WACC (rises with backlog - capital rationing)\n        const waccBacklogK = (_params_waccBacklogK1 = params.waccBacklogK) !== null && _params_waccBacklogK1 !== void 0 ? _params_waccBacklogK1 : 0.5;\n        var _params_waccBacklogExponent1;\n        const waccBacklogExponent = (_params_waccBacklogExponent1 = params.waccBacklogExponent) !== null && _params_waccBacklogExponent1 !== void 0 ? _params_waccBacklogExponent1 : 1.2;\n        var _params_criticalBacklogGW1;\n        const criticalBacklogGW = (_params_criticalBacklogGW1 = params.criticalBacklogGW) !== null && _params_criticalBacklogGW1 !== void 0 ? _params_criticalBacklogGW1 : 50;\n        const backlogRatio = Math.max(0, backlogGW / criticalBacklogGW);\n        const waccMultiplier = 1 + waccBacklogK * Math.pow(backlogRatio, waccBacklogExponent);\n        const waccEffective = baseWacc * waccMultiplier;\n        var _params_buildoutProjectLifetimeYears, _params_valueOfTimeMode, _params_buildoutCapexBase_$PerkW, _params_buildoutCapexScarcityCurve, _params_buildoutPanicExponent, _params_buildoutHybridWeights;\n        // Calculate buildout constraints\n        const buildoutParams = {\n            demandNewGWByYear: demandNewGW,\n            buildableGWByYear: buildableGW,\n            backlogGW: backlogGW,\n            avgWaitYears: avgWaitYears,\n            baseEnergyPricePerMwhByYear: groundElectricityPricePerMwh,\n            pueGroundByYear: effectivePueGround,\n            wacc: waccEffective,\n            projectLifetimeYears: (_params_buildoutProjectLifetimeYears = params.buildoutProjectLifetimeYears) !== null && _params_buildoutProjectLifetimeYears !== void 0 ? _params_buildoutProjectLifetimeYears : PROJECT_LIFETIME,\n            valueOfTimeMode: (_params_valueOfTimeMode = params.valueOfTimeMode) !== null && _params_valueOfTimeMode !== void 0 ? _params_valueOfTimeMode : \"wacc_on_capex\",\n            buildoutCapexBase_$PerkW: (_params_buildoutCapexBase_$PerkW = params.buildoutCapexBase_$PerkW) !== null && _params_buildoutCapexBase_$PerkW !== void 0 ? _params_buildoutCapexBase_$PerkW : BUILDOUT_CAPEX_BASE,\n            buildoutCapexScarcityCurve: (_params_buildoutCapexScarcityCurve = params.buildoutCapexScarcityCurve) !== null && _params_buildoutCapexScarcityCurve !== void 0 ? _params_buildoutCapexScarcityCurve : DEFAULT_SCARCITY_CURVE,\n            panicExponent: (_params_buildoutPanicExponent = params.buildoutPanicExponent) !== null && _params_buildoutPanicExponent !== void 0 ? _params_buildoutPanicExponent : PANIC_EXPONENT,\n            hardwareCapexPerPflopYear: groundHardwareCapexPerPflopYear,\n            siteCapexAmortPerPflopYear: BASE_SITE_2025,\n            // Legacy fields (kept for backward compat, but not used in new calculation)\n            computeHardwareCapex: groundHardwareCapexPerPflopYear * (groundEffectiveGflopsPerW * capacityFactorGround / effectivePueGround / 1e6),\n            siteCapex: BASE_SITE_2025 * (groundEffectiveGflopsPerW * capacityFactorGround / effectivePueGround / 1e6),\n            marginPerGpuHour: 0.5,\n            annualGpuHoursDelivered: 8760 * capacityFactorGround,\n            hybridWeights: (_params_buildoutHybridWeights = params.buildoutHybridWeights) !== null && _params_buildoutHybridWeights !== void 0 ? _params_buildoutHybridWeights : {\n                waccWeight: 0.5,\n                marginWeight: 0.5\n            }\n        };\n        const buildoutResult = (0,_ground_buildout__WEBPACK_IMPORTED_MODULE_6__.calculateBuildoutConstraints)(null, buildoutParams, year, groundEffectiveGflopsPerW, effectivePueGround, capacityFactorGround);\n        // Energy cost: base energy only (NOT affected by buildout constraints)\n        const energyCost = groundEnergyCostPerPflopYear;\n        // Site cost: base capex + buildout premium (engineering cost only, not scarcity pricing)\n        const siteCapexAmortPerPflopYear = BASE_SITE_2025;\n        const buildoutPremiumPerPflopYear = buildoutResult.buildoutPremiumPerPflopYear; // Base engineering cost only\n        const delayPenaltyPerPflopYear = buildoutResult.delayPenaltyPerPflopYear; // Linear: WACC * capex * waitYears\n        // CRITICAL: Wait-time-based scarcity rent (EARLY, SATURATING)\n        // Define annualized capex base for scarcity rent calculation\n        const capexAnnualBasePerPflopYear = groundHardwareCapexPerPflopYear + siteCapexAmortPerPflopYear + buildoutPremiumPerPflopYear; // Include buildout premium as true engineering capex\n        // Calculate scarcity multiplier using LOG-BASED function (never fully saturates)\n        // Returns multiplier (1.0 = no scarcity, 2.0 = 2x price) - MULTIPLICATIVE, not additive\n        const utilizationPct = capacityGW > 0 ? Math.min(1.0, demandNewGW / capacityGW) : 1.0;\n        var _params_scarcityRentWaitThresholdYears, _params_scarcityRentMaxMultiplier;\n        const scarcityRentResult = (0,_ground_constraint_penalties__WEBPACK_IMPORTED_MODULE_5__.calculateScarcityRent)(avgWaitYears, utilizationPct, {\n            waitThresholdYears: (_params_scarcityRentWaitThresholdYears = params.scarcityRentWaitThresholdYears) !== null && _params_scarcityRentWaitThresholdYears !== void 0 ? _params_scarcityRentWaitThresholdYears : 1.0,\n            rentMaxMultiplier: (_params_scarcityRentMaxMultiplier = params.scarcityRentMaxMultiplier) !== null && _params_scarcityRentMaxMultiplier !== void 0 ? _params_scarcityRentMaxMultiplier : 2.0,\n            utilizationThreshold: 0.85\n        });\n        const scarcityMultiplier = scarcityRentResult.scarcityMultiplier;\n        // For backward compatibility: scarcityRentPerPflopYear = 0 (scarcity is now multiplicative)\n        const scarcityRentPerPflopYear = 0;\n        // Define three totals:\n        // 1. base: energy + siteCapexAmort + buildoutPremium + hardware (no scarcity pricing)\n        // 2. effective: includes delayPenalty + scarcityRent (used for crossover)\n        // 3. headline: same as base (for backward compatibility)\n        const siteCostPerPflopYear_base = siteCapexAmortPerPflopYear + buildoutPremiumPerPflopYear;\n        const siteCostPerPflopYear_effective = siteCapexAmortPerPflopYear + buildoutPremiumPerPflopYear + delayPenaltyPerPflopYear + scarcityRentPerPflopYear;\n        // Validation: ensure no double counting\n        if (params.useQueueBasedConstraint !== false) {\n            console.warn(\"[BUILDOUT] useQueueBasedConstraint should be false when useBuildoutModel is true to avoid double counting\");\n        }\n        // Double counting guardrails: ensure constraintMultiplier is 1.0 when useBuildoutModel is true\n        if (true) {\n            if ((groundResult === null || groundResult === void 0 ? void 0 : groundResult.constraintMultiplier) !== undefined && groundResult.constraintMultiplier !== 1.0) {\n                throw new Error(\"[DOUBLE COUNTING] useBuildoutModel=true but constraintMultiplier=\".concat(groundResult.constraintMultiplier, \" != 1.0 (year=\").concat(year, \")\"));\n            }\n        }\n        const hardwareCost = groundHardwareCapexPerPflopYear;\n        // Add replacement/ops costs to hardware cost\n        const hardwareCostWithReplacement = hardwareCost + replacementCostPerPflopYear + sparesCarryCostPerPflopYear + groundOpsCostPerPflopYear;\n        // Compute totals (include replacement/ops in all)\n        const groundTotalCost_base = (energyCost + siteCostPerPflopYear_base + hardwareCostWithReplacement) * groundLatencyPenalty;\n        const groundTotalCost_effective = (energyCost + siteCostPerPflopYear_effective + hardwareCostWithReplacement) * groundLatencyPenalty; // Includes delayPenalty + scarcityRent\n        // UNIFIED SCARCITY ACCOUNTING: Keep totalCostPerPflopYear physical-only\n        // Scarcity (delayPenalty + scarcityRent) is treated purely in GPU-hour pricing, not in PFLOP-year cost\n        groundTotalCost = groundTotalCost_base; // Physical costs only (scarcity in GPU-hour)\n        var _groundResult_buildoutDebug_backlogGW;\n        // Detect if ground has queue/backlog (constraints are active) - for diagnostics only\n        groundHasQueue = avgWaitYears > 0.05 || backlogGW > 0.05 || ((_groundResult_buildoutDebug_backlogGW = groundResult === null || groundResult === void 0 ? void 0 : (_groundResult_buildoutDebug4 = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug4 === void 0 ? void 0 : _groundResult_buildoutDebug4.backlogGW) !== null && _groundResult_buildoutDebug_backlogGW !== void 0 ? _groundResult_buildoutDebug_backlogGW : 0) > 0.05;\n        // For crossover: use base cost (scarcity is already reflected in GPU-hour pricing)\n        // This ensures we don't double-count scarcity\n        groundComparatorCostPerPflopYear = groundTotalCost; // Base cost only (scarcity in GPU-hour)\n        energyConstraintMultiplier = 1.0; // Energy NOT affected by buildout constraints\n        // Constraint breakdown: all 1.0 (no multipliers, use buildout terms instead)\n        constraintBreakdown = {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        };\n        groundResult = {\n            energyCost: energyCost * groundLatencyPenalty,\n            siteCost: siteCostPerPflopYear_base * groundLatencyPenalty,\n            hardwareCost: hardwareCostWithReplacement * groundLatencyPenalty,\n            // Replacement/ops breakdown\n            replacementCost: replacementCostPerPflopYear * groundLatencyPenalty,\n            sparesCarryCost: sparesCarryCostPerPflopYear * groundLatencyPenalty,\n            opsCost: groundOpsCostPerPflopYear * groundLatencyPenalty,\n            siteCapexAmortPerPflopYear: siteCapexAmortPerPflopYear * groundLatencyPenalty,\n            capacityDeliveryPremium: buildoutPremiumPerPflopYear * groundLatencyPenalty,\n            timeToEnergizePenalty: delayPenaltyPerPflopYear * groundLatencyPenalty,\n            totalCostPerPflopYear: groundTotalCost,\n            totalCostPerPflopYearBase: groundTotalCost_base,\n            totalCostPerPflopYearEffective: groundTotalCost,\n            totalCostPerPflopYearAllIn: groundTotalCost,\n            // Debug: show pricing components\n            pricingComponents: {\n                delayPenaltyWeighted: delayPenaltyWeighted * groundLatencyPenalty,\n                scarcityRentPerPflopYear: scarcityRentPerPflopYear * groundLatencyPenalty,\n                pricingMode,\n                delayPenaltyWeight,\n                rentFrac: scarcityRentResult.rentFrac,\n                waitEffYears: scarcityRentResult.waitEffYears,\n                // Debug fields for scarcity rent calculation\n                scarcityHill: scarcityRentResult.scarcityHill,\n                avgWaitYearsRaw: scarcityRentResult.avgWaitYearsRaw,\n                avgWaitYearsClamped: scarcityRentResult.avgWaitYearsClamped\n            },\n            constraintMultiplier: 1.0,\n            breakdown: constraintBreakdown,\n            supplyMetrics: {\n                demandGw: mobilizationResult.demandGW,\n                capacityGw: capacityGW,\n                pipelineGw: pipelineGW,\n                maxBuildRateGwYear: buildRateGWyr,\n                avgWaitYears: avgWaitYears,\n                utilizationPct: capacityGW > 0 ? mobilizationResult.demandGW / capacityGW : 0\n            },\n            // Buildout debug fields (from ramping mobilization model)\n            backlogGw: backlogGW,\n            avgWaitYears: avgWaitYears,\n            buildoutDebug: {\n                demandNewGW: demandNewGW,\n                buildableGW: buildableGW,\n                buildRateGWyr: buildRateGWyr,\n                capacityGW: capacityGW,\n                pipelineGW: pipelineGW,\n                scarcityIndex: buildoutResult.factors.scarcityIndex,\n                buildoutCapex_$PerkW: buildoutResult.factors.buildoutCapex_$PerkW,\n                annualizedBuildoutPremium_$PerkWyr: buildoutResult.factors.annualizedBuildoutPremium_$PerkWyr,\n                timeToPowerYears: avgWaitYears,\n                valueOfTime_$PerYear: buildoutResult.factors.valueOfTime_$PerYear,\n                delayPenalty_$PerYear: buildoutResult.factors.delayPenalty_$PerYear,\n                buildoutPremiumPerPflopYear: buildoutPremiumPerPflopYear,\n                delayPenaltyPerPflopYear: delayPenaltyPerPflopYear,\n                // Additional mobilization debug fields\n                demandGW: mobilizationResult.demandGW,\n                demandGrowthRate: mobilizationResult.demandGrowthRate,\n                backlogGW: mobilizationResult.backlogGW,\n                avgWaitYears: mobilizationResult.avgWaitYears\n            },\n            smrEnabled: false,\n            smrRampFactor: 0,\n            effectiveElectricityCost: groundElectricityPricePerMwh,\n            constraintRelief: {\n                grid: 0,\n                cooling: 0,\n                water: 0,\n                land: 0\n            },\n            constraints: {\n                method: \"adders\",\n                capacityDeliveryPremium: buildoutPremiumPerPflopYear * groundLatencyPenalty,\n                delayPenalty: delayPenaltyPerPflopYear * groundLatencyPenalty,\n                scarcityRentPerPflopYear: scarcityRentPerPflopYear * groundLatencyPenalty,\n                scarcityMultiplier: scarcityMultiplier,\n                appliedMultipliers: {\n                    constraintMultiplierUsed: false,\n                    energyMultiplierUsed: false,\n                    siteMultiplierUsed: false\n                },\n                waccBase: baseWacc,\n                waccEffective: waccEffective,\n                rentFrac: scarcityRentResult.rentFrac,\n                waitYearsUsed: scarcityRentResult.waitEffYears,\n                waitEffYears: scarcityRentResult.waitEffYears,\n                // Debug fields for scarcity rent calculation\n                scarcityHill: scarcityRentResult.scarcityHill,\n                avgWaitYearsRaw: scarcityRentResult.avgWaitYearsRaw,\n                avgWaitYearsClamped: scarcityRentResult.avgWaitYearsClamped,\n                debug: {\n                    doubleCountCheck: {\n                        mode: \"adders\",\n                        multiplierApplied: false,\n                        addersApplied: true,\n                        invariantOk: true,\n                        notes: \"Buildout model uses adders only (capacityDeliveryPremium + delayPenalty + scarcityRent)\"\n                    }\n                }\n            }\n        };\n        // Invariant: If using adders, multipliers must not be applied\n        if (true) {\n            const hasMultiplier = groundResult.constraintMultiplier !== 1.0;\n            const hasAdder = groundResult.capacityDeliveryPremium > 0 || groundResult.timeToEnergizePenalty > 0;\n            if (hasMultiplier && hasAdder) {\n                throw new Error(\"[DOUBLE COUNTING DETECTED] Year \".concat(year, \": constraintMultiplier=\").concat(groundResult.constraintMultiplier, \" != 1.0 \") + \"AND adders > 0 (capacityDeliveryPremium=\".concat(groundResult.capacityDeliveryPremium, \", \") + \"delayPenalty=\".concat(groundResult.timeToEnergizePenalty, \"). Both cannot be applied simultaneously.\"));\n            }\n        }\n    } else if (useRegionalModel) {\n        var _regionalResult_supplyMetrics, _regionalResult_supplyMetrics1;\n        const demandPflops = (0,_ground_supply_model__WEBPACK_IMPORTED_MODULE_3__.getGlobalDemandPflops)(year, groundEffectiveGflopsPerW);\n        const regionalResult = (0,_ground_supply_model__WEBPACK_IMPORTED_MODULE_3__.calculateRegionalGroundCost)(year, demandPflops, groundEffectiveGflopsPerW, effectivePueGround, capacityFactorGround, groundHardwareCapexPerPflopYear, undefined // Use default regions\n        );\n        // REFACTORED: Regional model - energy cost should NOT have constraint multiplier\n        // Regional model already separates energy (raw) from site (with constraint)\n        const energyCost = regionalResult.energyCostPerPflopYear; // Raw electricity (NO constraint multiplier)\n        const siteCost = regionalResult.siteCostPerPflopYear; // Site costs WITH constraint multiplier\n        // GROUND COST ACCOUNTING: Explicit separation for regional model\n        const siteCostBase = BASE_SITE_2025;\n        // 1. siteCapexAmortPerPflopYear: Base site capex (NOT affected by constraint)\n        const siteCapexAmortPerPflopYear = siteCostBase;\n        // 2. capacityDeliveryPremiumPerPflopYear: Premium above base (from constraint multiplier)\n        const capacityDeliveryPremiumPerPflopYear = Math.max(0, siteCost - siteCostBase);\n        // 3. timeToEnergizePenaltyPerPflopYear: Regional model doesn't model queue delay separately (0 for now)\n        const timeToEnergizePenaltyPerPflopYear = 0;\n        // INVARIANT: siteCostPerPflopYear = siteCapexAmort + timeToEnergizePenalty + capacityDeliveryPremium\n        const siteCostPerPflopYear = siteCapexAmortPerPflopYear + timeToEnergizePenaltyPerPflopYear + capacityDeliveryPremiumPerPflopYear;\n        // Validation (allow small tolerance for regional model approximation)\n        const siteCostCheck = Math.abs(siteCost - siteCostPerPflopYear);\n        if (siteCostCheck > 1.0) {\n            throw new Error(\"Site cost accounting error (regional model): siteCost=\".concat(siteCost, \" != sum(components)=\").concat(siteCostPerPflopYear, \", diff=\").concat(siteCostCheck));\n        }\n        // CRITICAL FIX: Regional model already separates energy (no multiplier) from site (with premium)\n        // Do NOT apply constraintMultiplier - it's already reflected in siteCostPerPflopYear\n        const constraintMultiplier = 1.0; // Not applied - kept for backward compat only\n        groundTotalCost = regionalResult.totalCostPerPflopYear;\n        groundHasQueue = false; // Regional model doesn't model queue delay separately\n        groundComparatorCostPerPflopYear = groundTotalCost; // Use base cost for regional model\n        energyConstraintMultiplier = 1.0; // Never applied\n        constraintBreakdown = {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        };\n        var _regionalResult_supplyMetrics_pipelineGw, _regionalResult_supplyMetrics_avgWaitYears, _regionalResult_supplyMetrics2;\n        groundResult = {\n            energyCost: energyCost,\n            siteCost: siteCostPerPflopYear,\n            siteCapexAmortPerPflopYear: siteCapexAmortPerPflopYear,\n            capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear,\n            timeToEnergizePenalty: timeToEnergizePenaltyPerPflopYear,\n            hardwareCost: regionalResult.hardwareCapexPerPflopYear,\n            totalCostPerPflopYear: groundTotalCost,\n            constraintMultiplier: 1.0,\n            constraints: {\n                method: \"adders\",\n                capacityDeliveryPremium: capacityDeliveryPremiumPerPflopYear,\n                delayPenalty: 0,\n                appliedMultipliers: {\n                    constraintMultiplierUsed: false,\n                    energyMultiplierUsed: false,\n                    siteMultiplierUsed: false\n                },\n                debug: {\n                    doubleCountCheck: {\n                        mode: \"adders\",\n                        multiplierApplied: false,\n                        addersApplied: capacityDeliveryPremiumPerPflopYear > 0,\n                        invariantOk: true,\n                        notes: \"Regional model uses adders only (capacityDeliveryPremium from siteCost - siteCostBase)\"\n                    }\n                }\n            },\n            breakdown: constraintBreakdown,\n            smrEnabled: false,\n            smrRampFactor: 0,\n            effectiveElectricityCost: regionalResult.averageEnergyCostMwh,\n            constraintRelief: {\n                grid: 0,\n                cooling: 0,\n                water: 0,\n                land: 0\n            },\n            // Ensure backlogGw and avgWaitYears are always set (use supplyMetrics as fallback)\n            backlogGw: (_regionalResult_supplyMetrics_pipelineGw = (_regionalResult_supplyMetrics = regionalResult.supplyMetrics) === null || _regionalResult_supplyMetrics === void 0 ? void 0 : _regionalResult_supplyMetrics.pipelineGw) !== null && _regionalResult_supplyMetrics_pipelineGw !== void 0 ? _regionalResult_supplyMetrics_pipelineGw : 0,\n            avgWaitYears: (_regionalResult_supplyMetrics_avgWaitYears = (_regionalResult_supplyMetrics1 = regionalResult.supplyMetrics) === null || _regionalResult_supplyMetrics1 === void 0 ? void 0 : _regionalResult_supplyMetrics1.avgWaitYears) !== null && _regionalResult_supplyMetrics_avgWaitYears !== void 0 ? _regionalResult_supplyMetrics_avgWaitYears : 0,\n            supplyMetrics: (_regionalResult_supplyMetrics2 = regionalResult.supplyMetrics) !== null && _regionalResult_supplyMetrics2 !== void 0 ? _regionalResult_supplyMetrics2 : {\n                demandGw: 0,\n                capacityGw: 0,\n                pipelineGw: 0,\n                maxBuildRateGwYear: 0,\n                avgWaitYears: 0,\n                utilizationPct: 0\n            }\n        };\n    } else {\n        groundResult = calculateGroundTotal(year, params, ENERGY_COST_BASE_2025, groundHardwareCapexPerPflopYear, params.isStaticMode, effectiveGroundScenario, groundLatencyPenalty, smrParams, firstCapYear !== null && firstCapYear !== void 0 ? firstCapYear : null, groundEnergyCostPerPflopYear, groundElectricityPricePerMwh);\n        // CRITICAL FIX: Ensure backlogGw and avgWaitYears are always set (even if calculateGroundTotal doesn't provide them)\n        // Use supplyMetrics as fallback if available, otherwise 0\n        // Type assertion needed because calculateGroundTotal may not include these fields\n        const groundResultWithBacklog = groundResult;\n        if (!(\"backlogGw\" in groundResultWithBacklog) || groundResultWithBacklog.backlogGw === undefined) {\n            var _groundResultWithBacklog_supplyMetrics;\n            var _groundResultWithBacklog_supplyMetrics_pipelineGw;\n            groundResultWithBacklog.backlogGw = (_groundResultWithBacklog_supplyMetrics_pipelineGw = (_groundResultWithBacklog_supplyMetrics = groundResultWithBacklog.supplyMetrics) === null || _groundResultWithBacklog_supplyMetrics === void 0 ? void 0 : _groundResultWithBacklog_supplyMetrics.pipelineGw) !== null && _groundResultWithBacklog_supplyMetrics_pipelineGw !== void 0 ? _groundResultWithBacklog_supplyMetrics_pipelineGw : 0; // TEMP proxy\n        }\n        if (!(\"avgWaitYears\" in groundResultWithBacklog) || groundResultWithBacklog.avgWaitYears === undefined) {\n            var _groundResultWithBacklog_supplyMetrics1;\n            var _groundResultWithBacklog_supplyMetrics_avgWaitYears;\n            groundResultWithBacklog.avgWaitYears = (_groundResultWithBacklog_supplyMetrics_avgWaitYears = (_groundResultWithBacklog_supplyMetrics1 = groundResultWithBacklog.supplyMetrics) === null || _groundResultWithBacklog_supplyMetrics1 === void 0 ? void 0 : _groundResultWithBacklog_supplyMetrics1.avgWaitYears) !== null && _groundResultWithBacklog_supplyMetrics_avgWaitYears !== void 0 ? _groundResultWithBacklog_supplyMetrics_avgWaitYears : 0;\n        }\n        // Ensure supplyMetrics exists\n        if (!groundResultWithBacklog.supplyMetrics) {\n            var _groundResultWithBacklog_backlogGw, _groundResultWithBacklog_avgWaitYears;\n            groundResultWithBacklog.supplyMetrics = {\n                demandGw: 0,\n                capacityGw: 0,\n                pipelineGw: (_groundResultWithBacklog_backlogGw = groundResultWithBacklog.backlogGw) !== null && _groundResultWithBacklog_backlogGw !== void 0 ? _groundResultWithBacklog_backlogGw : 0,\n                maxBuildRateGwYear: 0,\n                avgWaitYears: (_groundResultWithBacklog_avgWaitYears = groundResultWithBacklog.avgWaitYears) !== null && _groundResultWithBacklog_avgWaitYears !== void 0 ? _groundResultWithBacklog_avgWaitYears : 0,\n                utilizationPct: 0\n            };\n        }\n        groundResult = groundResultWithBacklog;\n        groundTotalCost = groundResult.totalCostPerPflopYear;\n        var _groundResult_timeToEnergizePenalty;\n        groundHasQueue = ((_groundResult_timeToEnergizePenalty = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty !== void 0 ? _groundResult_timeToEnergizePenalty : 0) > 0.01; // Check if delay penalty exists\n        var _groundResult_totalCostPerPflopYearEffective;\n        groundComparatorCostPerPflopYear = groundHasQueue ? (_groundResult_totalCostPerPflopYearEffective = groundResult.totalCostPerPflopYearEffective) !== null && _groundResult_totalCostPerPflopYearEffective !== void 0 ? _groundResult_totalCostPerPflopYearEffective : groundResult.totalCostPerPflopYear : groundTotalCost;\n        // CRITICAL FIX: Never apply multipliers - all set to 1.0\n        energyConstraintMultiplier = 1.0; // Never applied\n        // Invariant: If using adders, multipliers must not be applied\n        if ( true && groundResult.constraints) {\n            const hasMultiplier = groundResult.constraintMultiplier !== 1.0;\n            const hasAdder = groundResult.constraints.capacityDeliveryPremium > 0 || groundResult.constraints.delayPenalty > 0;\n            if (hasMultiplier && hasAdder) {\n                throw new Error(\"[DOUBLE COUNTING DETECTED] Year \".concat(year, \": constraintMultiplier=\").concat(groundResult.constraintMultiplier, \" != 1.0 \") + \"AND adders > 0 (capacityDeliveryPremium=\".concat(groundResult.constraints.capacityDeliveryPremium, \", \") + \"delayPenalty=\".concat(groundResult.constraints.delayPenalty, \"). Both cannot be applied simultaneously.\"));\n            }\n        }\n        constraintBreakdown = {\n            grid: 1.0,\n            cooling: 1.0,\n            water: 1.0,\n            land: 1.0,\n            energyMultiplier: 1.0,\n            siteMultiplier: 1.0,\n            capacityDeliveryMultiplier: 1.0\n        };\n        // Invariant: Check for double counting\n        if (true) {\n            const hasMultiplier = groundResult.constraintMultiplier !== 1.0 || groundResult.breakdown.energyMultiplier !== 1.0 || groundResult.breakdown.siteMultiplier !== 1.0;\n            const hasPremium = (groundResult.capacityDeliveryPremium || 0) > 0 || (groundResult.timeToEnergizePenalty || 0) > 0;\n            if (hasMultiplier && hasPremium) {\n                console.warn(\"[DOUBLE COUNTING DETECTED] Year \".concat(year, \": \") + \"Multipliers (constraint=\".concat(groundResult.constraintMultiplier, \", \") + \"energy=\".concat(groundResult.breakdown.energyMultiplier, \", \") + \"site=\".concat(groundResult.breakdown.siteMultiplier, \") AND \") + \"premiums (capacity=\".concat(groundResult.capacityDeliveryPremium, \", \") + \"delay=\".concat(groundResult.timeToEnergizePenalty, \") are both present. \") + \"This indicates double counting.\");\n            }\n        }\n    }\n    const launchCostPerKg = getLaunchCostPerKg(year, baseLaunchCost) * launchDiscount;\n    const lifetimeYears = 6;\n    // Fusion toggle params\n    const fusionParams = params.fusionToggleEnabled ? params.fusionToggleParams || {\n        ..._orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_FUSION_PARAMS,\n        enabled: true\n    } : undefined;\n    // CONSTELLATION SIZING: Design constellation to meet compute requirements\n    // Convert target compute (GW) to power (kW) for constellation sizing\n    const targetComputeKw = satellitePowerKW;\n    let constellation = (0,_constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.designConstellation)(targetComputeKw, _constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.SATELLITE_CONSTRAINTS, 100000, trajSpecificPower);\n    // Use per-satellite compute power for cost calculation\n    let computePowerPerSatKw = constellation.computePerSatKw;\n    let hybridResult = (0,_orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.computeSatelliteHybridCost)(year, launchCostPerKg, {\n        ..._orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_CONFIG,\n        computePowerKw: computePowerPerSatKw,\n        altitudeKm: orbitalAltitude,\n        lifetimeYears: lifetimeYears,\n        specificPowerWKg: trajSpecificPower,\n        useRadHardChips: useRadHardChips,\n        sunFraction: sunFraction,\n        workloadType: workloadType || \"inference\"\n    }, fusionParams, params.useCorrectedSpecificPower, params.useCorrectedThermal);\n    // CRITICAL FIX: Calculate delivered efficiency with ALL delivery derates\n    // delivered = systemEffective * thermalCapFactor * radiationDerate * availability\n    // Single source of truth for all three factors:\n    const thermalCapFactor = hybridResult.thermalSystem.thermalCapFactor;\n    const radiationDerate = hybridResult.degradationFactor || 1.0; // Hardware degradation from radiation (chip failures, ECC overhead)\n    const availability = hybridResult.capacityFactor || 1.0; // Capacity factor is uptime-inclusive (includes eclipse, degradation, radiation downtime, uptime)\n    // Calculate delivered efficiency (all derates applied multiplicatively)\n    // This is the true \"delivered\" efficiency that accounts for all operational constraints\n    let orbitDeliveredGflopsPerWatt = orbitSystemEffectiveGflopsPerWatt * thermalCapFactor * radiationDerate * availability;\n    // CRITICAL: If thermal constraint causes delivered efficiency to drop below minimum (20 GFLOPS/W),\n    // this indicates a severe thermal constraint that should be handled by expanding radiator or reducing compute\n    // For now, we clamp to minimum to prevent validation errors, but log a warning (only once per year)\n    if (orbitDeliveredGflopsPerWatt < CONSTANTS.MIN_DELIVERED_GFLOPS_PER_W) {\n        const originalDelivered = orbitDeliveredGflopsPerWatt;\n        orbitDeliveredGflopsPerWatt = CONSTANTS.MIN_DELIVERED_GFLOPS_PER_W;\n    // Log warning about severe thermal constraint (only in dev, and only once per year to reduce spam)\n    // The actual clamped value is available in orbit.computeEfficiency.validation metadata\n    // Thermal constraint warnings removed for cleaner console output\n    }\n    // Use delivered efficiency for all cost calculations\n    let orbitEffectiveGflopsPerW = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(orbitDeliveredGflopsPerWatt, \"orbital delivered efficiency calculation\");\n    // Power scaling calculation\n    const powerScalingParams = params.powerScalingParams || _orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_POWER_SCALING;\n    const scalingResult = (0,_orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.calculateScaledMass)(computePowerPerSatKw, powerScalingParams);\n    // CONSTELLATION SCALING: Apply constellation multiplier to mass and costs\n    // Per-satellite mass (already calculated for one satellite)\n    let massPerSatKg = hybridResult.totalMassKg * massMultiplier;\n    // CRITICAL FIX: Check if actual mass exceeds limit and re-split constellation if needed\n    // The simplified mass model in designConstellation may underestimate actual mass\n    // If actual mass exceeds limit, we need to split into smaller satellites\n    const MAX_SATELLITE_MASS_KG = _constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.SATELLITE_CONSTRAINTS.maxMassKg; // 10,000 kg from constraints\n    if (massPerSatKg > MAX_SATELLITE_MASS_KG) {\n        // Calculate required compute per satellite to stay under mass limit\n        // Mass scales roughly with compute power, so: massPerSatKg / computePowerPerSatKw = massPerKw\n        const massPerKw = massPerSatKg / computePowerPerSatKw;\n        const maxComputePerSatKw = MAX_SATELLITE_MASS_KG / massPerKw;\n        // Recalculate constellation with smaller satellites\n        const adjustedConstellation = (0,_constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.designConstellation)(targetComputeKw, {\n            ..._constellation_sizing__WEBPACK_IMPORTED_MODULE_11__.SATELLITE_CONSTRAINTS,\n            maxComputeKw: maxComputePerSatKw * 0.9\n        }, 100000, trajSpecificPower);\n        // Recalculate hybrid cost with adjusted compute per satellite\n        const adjustedHybridResult = (0,_orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.computeSatelliteHybridCost)(year, launchCostPerKg, {\n            ..._orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_CONFIG,\n            computePowerKw: adjustedConstellation.computePerSatKw,\n            altitudeKm: orbitalAltitude,\n            lifetimeYears: lifetimeYears,\n            specificPowerWKg: trajSpecificPower,\n            useRadHardChips: useRadHardChips,\n            sunFraction: sunFraction,\n            workloadType: workloadType || \"inference\"\n        }, fusionParams, params.useCorrectedSpecificPower, params.useCorrectedThermal);\n        // Update with adjusted values\n        const adjustedMassPerSatKg = adjustedHybridResult.totalMassKg * massMultiplier;\n        if (adjustedMassPerSatKg > MAX_SATELLITE_MASS_KG) {\n            // Still too heavy - this shouldn't happen, but log a warning\n            console.warn(\"Satellite mass \".concat(adjustedMassPerSatKg.toFixed(0), \"kg still exceeds limit \").concat(MAX_SATELLITE_MASS_KG, \"kg \") + \"even after splitting to \".concat(adjustedConstellation.computePerSatKw.toFixed(1), \"kW per satellite. \") + \"Consider further reducing compute per satellite or improving specific power.\");\n        }\n        // Use adjusted constellation and hybrid result\n        constellation = adjustedConstellation;\n        hybridResult = adjustedHybridResult;\n        computePowerPerSatKw = adjustedConstellation.computePerSatKw;\n        massPerSatKg = adjustedMassPerSatKg;\n        // Recalculate delivered efficiency with adjusted thermal cap (all derates applied)\n        const adjustedThermalCapFactor = hybridResult.thermalSystem.thermalCapFactor;\n        const adjustedRadiationDerate = hybridResult.degradationFactor || 1.0;\n        const adjustedAvailability = hybridResult.capacityFactor || 1.0;\n        let adjustedDeliveredGflopsPerWatt = orbitSystemEffectiveGflopsPerWatt * adjustedThermalCapFactor * adjustedRadiationDerate * adjustedAvailability;\n        // Clamp to minimum if thermal constraint is too severe\n        if (adjustedDeliveredGflopsPerWatt < CONSTANTS.MIN_DELIVERED_GFLOPS_PER_W) {\n            adjustedDeliveredGflopsPerWatt = CONSTANTS.MIN_DELIVERED_GFLOPS_PER_W;\n        }\n        orbitEffectiveGflopsPerW = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(adjustedDeliveredGflopsPerWatt, \"orbital delivered efficiency (after constellation split)\");\n    }\n    // Scale costs by number of satellites and apply constellation overhead\n    // Calculate AFTER mass check so we use the adjusted constellation if it was split\n    const constellationMultiplier = constellation.numSatellites;\n    const constellationOverheadMultiplier = constellation.constellationOverhead;\n    // Total constellation mass\n    const effectiveTotalMassKg = massPerSatKg * constellation.numSatellites;\n    const effectiveTotalLaunchCost = effectiveTotalMassKg * launchCostPerKg;\n    // Apply Elon Scenario: Discounts\n    const effectivePowerFabCost = hybridResult.powerSystem.fabCostUsd * powerDiscount;\n    const effectiveNetworkingFabCost = hybridResult.networking.fabCostUsd * networkingDiscount;\n    const effectiveNetworkingOpEx = (hybridResult.networking.annualOpExUsd || 0) * networkingDiscount;\n    // Effective PFLOPs: per-satellite PFLOPs  number of satellites\n    const effectivePflopsPerSat = hybridResult.effectivePflops;\n    const totalEffectivePflops = effectivePflopsPerSat * constellation.numSatellites;\n    // Launch cost: total constellation launch cost / total PFLOPs\n    const launchCostPerPflopYear = effectiveTotalLaunchCost / totalEffectivePflops / lifetimeYears;\n    // CRITICAL FIX 1: Cost Accounting - ensure breakdown sums to total\n    // Calculate each component explicitly, scaled by constellation\n    // Per-satellite costs  number of satellites  constellation overhead\n    const constellationCostMultiplier = constellation.numSatellites * constellationOverheadMultiplier;\n    const powerCost = effectivePowerFabCost * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const computeCost = (hybridResult.computePayload.chipCostUsd + hybridResult.computePayload.qualificationCostUsd) * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const thermalCost = hybridResult.thermalSystem.fabCostUsd * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const radiationCost = hybridResult.radiationProtection.fabCostUsd * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const busCost = hybridResult.bus.fabCostUsd * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const networkingCost = effectiveNetworkingFabCost * constellationCostMultiplier / totalEffectivePflops / lifetimeYears;\n    const interconnectCost = hybridResult.interconnect.totalAnnualCost * constellationCostMultiplier / totalEffectivePflops;\n    const regulatoryCost = (((_hybridResult_regulatory = hybridResult.regulatory) === null || _hybridResult_regulatory === void 0 ? void 0 : _hybridResult_regulatory.annualCostUsd) || 0) * constellationCostMultiplier / totalEffectivePflops;\n    // Ops cost scales with constellation overhead (more satellites = more ops complexity)\n    const baseOpsCostPerSat = hybridResult.opsPerPflopYear * effectivePflopsPerSat; // Total ops cost per satellite\n    const networkingOpsCostPerSat = (hybridResult.networking.annualOpExUsd || 0) - effectiveNetworkingOpEx; // Already per-sat\n    const adjustedNetworkingOpsCostPerSat = effectiveNetworkingOpEx; // Already per-sat\n    const opsCostPerSat = baseOpsCostPerSat - networkingOpsCostPerSat + adjustedNetworkingOpsCostPerSat;\n    // Scale ops cost by constellation (with overhead for coordination)\n    const opsCostMultiplier = constellation.numSatellites * (1 + 0.1 * Math.log10(constellation.numSatellites));\n    const opsCost = opsCostPerSat * opsCostMultiplier / totalEffectivePflops;\n    const orbitalBreakdown = {\n        power: powerCost,\n        compute: computeCost,\n        thermal: thermalCost,\n        radiation: radiationCost,\n        bus: busCost,\n        ops: opsCost,\n        congestion: 0,\n        networking: networkingCost,\n        interconnect: interconnectCost,\n        regulatory: regulatoryCost,\n        launch: launchCostPerPflopYear\n    };\n    const totalSatelliteCost = hybridResult.totalSatelliteCost * constellationCostMultiplier;\n    const satelliteCount = constellation.numSatellites; // Use actual constellation size\n    const congestion = (0,_congestion__WEBPACK_IMPORTED_MODULE_0__.calculateCongestion)(satelliteCount, totalSatelliteCost, year, 10000 + satelliteCount, spaceTrafficEnabled);\n    // Total fleet PFLOPS: use constellation total PFLOPs\n    // Already calculated as totalEffectivePflops above\n    orbitalBreakdown.congestion = spaceTrafficEnabled ? congestion.congestionCostPerPflopYear / totalEffectivePflops : 0;\n    // PATCH G: Cost Accounting Invariants\n    // Use assertCostAccounting to ensure breakdown sums to total exactly\n    const orbitalComponents = [\n        {\n            name: \"power\",\n            value: orbitalBreakdown.power\n        },\n        {\n            name: \"compute\",\n            value: orbitalBreakdown.compute\n        },\n        {\n            name: \"thermal\",\n            value: orbitalBreakdown.thermal\n        },\n        {\n            name: \"radiation\",\n            value: orbitalBreakdown.radiation\n        },\n        {\n            name: \"bus\",\n            value: orbitalBreakdown.bus\n        },\n        {\n            name: \"ops\",\n            value: orbitalBreakdown.ops\n        },\n        {\n            name: \"networking\",\n            value: orbitalBreakdown.networking\n        },\n        {\n            name: \"interconnect\",\n            value: orbitalBreakdown.interconnect\n        },\n        {\n            name: \"regulatory\",\n            value: orbitalBreakdown.regulatory\n        },\n        {\n            name: \"launch\",\n            value: orbitalBreakdown.launch\n        },\n        {\n            name: \"congestion\",\n            value: orbitalBreakdown.congestion\n        }\n    ];\n    const breakdownSum = Object.values(orbitalBreakdown).reduce((a, b)=>a + b, 0);\n    const realisticCostPerPflop = breakdownSum;\n    // Track applied multipliers for debugging\n    const appliedMultipliers = [\n        {\n            name: \"launchDiscount\",\n            value: launchDiscount,\n            appliedTo: \"launch cost\"\n        },\n        {\n            name: \"powerDiscount\",\n            value: powerDiscount,\n            appliedTo: \"power fab cost\"\n        },\n        {\n            name: \"networkingDiscount\",\n            value: networkingDiscount,\n            appliedTo: \"networking cost\"\n        },\n        {\n            name: \"massMultiplier\",\n            value: massMultiplier,\n            appliedTo: \"total mass\"\n        }\n    ];\n    // Assert cost accounting (throws if invalid)\n    const orbitalAccounting = (0,_cost_accounting__WEBPACK_IMPORTED_MODULE_9__.assertCostAccounting)(realisticCostPerPflop, orbitalComponents, appliedMultipliers);\n    const costAccountingValid = orbitalAccounting.valid;\n    const costAccountingErrorPct = orbitalAccounting.errorPct;\n    // FIX 5: GPU-hour breakdown must derive from annual cost breakdown\n    // GPU-hour pricing: Apply scarcity as MULTIPLICATIVE multiplier (not additive)\n    // delayPenalty remains additive (WACC carry cost), but scarcity rent is now multiplicative\n    const delayPenaltyPerPflopYear = ((_groundResult_constraints = groundResult.constraints) === null || _groundResult_constraints === void 0 ? void 0 : _groundResult_constraints.delayPenalty) || 0;\n    var _groundResult_constraints_scarcityMultiplier;\n    const scarcityMultiplier = (_groundResult_constraints_scarcityMultiplier = (_groundResult_constraints1 = groundResult.constraints) === null || _groundResult_constraints1 === void 0 ? void 0 : _groundResult_constraints1.scarcityMultiplier) !== null && _groundResult_constraints_scarcityMultiplier !== void 0 ? _groundResult_constraints_scarcityMultiplier : 1.0; // Multiplier from log-based function\n    // Convert delayPenalty to $/GPU-hour (still additive)\n    const pflopsPerGpu = 2.0;\n    const utilizationTarget = 0.85;\n    const hoursPerYear = 8760;\n    const annualGpuHoursPerPFLOP = hoursPerYear * utilizationTarget / pflopsPerGpu;\n    const delayPenaltyAdderPerGpuHour = delayPenaltyPerPflopYear / annualGpuHoursPerPFLOP;\n    // Note: Scarcity is now MULTIPLICATIVE (not additive), so no conversion check needed\n    // Scarcity multiplier is applied directly to base cost in GPU-hour pricing\n    // Use BASE cost (without scarcity) for GPU-hour pricing, then apply scarcity as multiplier\n    // This prevents double-counting: scarcity is multiplicative in GPU-hour pricing, not additive\n    // We want: baseCost (no scarcity) * scarcityMultiplier = total with scarcity\n    // Use groundResult.totalCostPerPflopYearBase if available (from buildout model), otherwise construct from components\n    const groundCostBaseForPricing = useBuildoutModel && (groundResult === null || groundResult === void 0 ? void 0 : groundResult.totalCostPerPflopYearBase) !== undefined ? groundResult.totalCostPerPflopYearBase : (groundResult.energyCost + groundResult.siteCost + groundResult.hardwareCost) * groundLatencyPenalty;\n    const groundGpuHour = (sla)=>{\n        const basePricing = calculateGpuHourPricing(groundCostBaseForPricing, {\n            pflopsPerGpu,\n            utilizationTarget,\n            operatorMarginPct: operatorMargin,\n            sla,\n            location: \"ground\"\n        }, {\n            compute: groundResult.hardwareCost,\n            power: groundResult.energyCost,\n            site: useBuildoutModel ? groundResult.siteCapexAmortPerPflopYear : groundResult.siteCost\n        });\n        // UNIFIED SCARCITY ACCOUNTING: Scarcity is MULTIPLICATIVE (not additive)\n        // CRITICAL FIX: Apply scarcity as premium on FIXED reference base, not declining base\n        // This prevents Moore's Law from eroding scarcity dollar amounts\n        // Extract base cost before margin (this declines with Moore's Law)\n        const preMarginBase = basePricing.pricePerGpuHour - (basePricing.costBreakdown.margin || 0);\n        // Scarcity premium based on FIXED reference, not declining base\n        // This ensures scarcity doesn't get eroded by Moore's Law\n        const SCARCITY_REFERENCE_BASE = 3.50; // Fixed 2025 market reference ($/GPU-hr)\n        const scarcityPremium = (scarcityMultiplier - 1) * SCARCITY_REFERENCE_BASE;\n        // Total cost = base (declining with Moore's Law) + scarcity (fixed) + delay\n        const costWithScarcity = preMarginBase + scarcityPremium;\n        const costWithScarcityAndDelay = costWithScarcity + delayPenaltyAdderPerGpuHour;\n        // Then add margin\n        const margin = costWithScarcityAndDelay * operatorMargin;\n        const pricePerGpuHour = costWithScarcityAndDelay + margin;\n        return {\n            ...basePricing,\n            pricePerGpuHour,\n            costBreakdown: {\n                ...basePricing.costBreakdown,\n                scarcity: scarcityPremium,\n                delayPenalty: delayPenaltyAdderPerGpuHour,\n                margin\n            }\n        };\n    };\n    const orbitalGpuHour = (sla)=>calculateGpuHourPricing(realisticCostPerPflop, {\n            pflopsPerGpu: 2.0,\n            utilizationTarget: 0.85,\n            operatorMarginPct: operatorMargin,\n            sla,\n            location: \"orbital\"\n        }, orbitalBreakdown); // Use full orbital breakdown\n    const groundTokens = {\n        llama70B: calculateTokenPricing(groundTotalCost, {\n            params: 70e9,\n            precision: \"fp16\"\n        }),\n        llama405B: calculateTokenPricing(groundTotalCost, {\n            params: 405e9,\n            precision: \"fp16\"\n        })\n    };\n    const orbitalTokens = {\n        llama70B: calculateTokenPricing(realisticCostPerPflop, {\n            params: 70e9,\n            precision: \"fp16\"\n        }),\n        llama405B: calculateTokenPricing(realisticCostPerPflop, {\n            params: 405e9,\n            precision: \"fp16\"\n        })\n    };\n    const edgeInference = ((_params_edgeInference = params.edgeInference) === null || _params_edgeInference === void 0 ? void 0 : _params_edgeInference.enabled) ? (0,_edgeInference__WEBPACK_IMPORTED_MODULE_1__.computeEdgeInferenceCosts)(year, params.edgeInference, launchCostPerKg, totalEffectivePflops / effectiveTotalMassKg) : undefined;\n    const gpuHourCrossover = orbitalGpuHour(SLA_TIERS.standard).pricePerGpuHour < groundGpuHour(SLA_TIERS.standard).pricePerGpuHour;\n    // ============================================================================\n    // DEBUG INVARIANTS (development mode only)\n    // ============================================================================\n    if (true) {\n        var _groundResult_supplyMetrics4, _groundResult_constraints2, _groundResult_constraints3;\n        var _groundResult_supplyMetrics_avgWaitYears;\n        // Invariant 1: If avgWaitYears > 0 then scarcity multiplier should be > 1.0 (scarcity is multiplicative in GPU-hour pricing)\n        const avgWaitYears = (_groundResult_supplyMetrics_avgWaitYears = (_groundResult_supplyMetrics4 = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics4 === void 0 ? void 0 : _groundResult_supplyMetrics4.avgWaitYears) !== null && _groundResult_supplyMetrics_avgWaitYears !== void 0 ? _groundResult_supplyMetrics_avgWaitYears : 0;\n        var _groundResult_constraints_scarcityMultiplier1;\n        const scarcityMultiplier = (_groundResult_constraints_scarcityMultiplier1 = (_groundResult_constraints2 = groundResult.constraints) === null || _groundResult_constraints2 === void 0 ? void 0 : _groundResult_constraints2.scarcityMultiplier) !== null && _groundResult_constraints_scarcityMultiplier1 !== void 0 ? _groundResult_constraints_scarcityMultiplier1 : 1.0;\n        if (avgWaitYears > 1.0 && scarcityMultiplier <= 1.0) {\n            console.warn(\"[INVARIANT VIOLATION] Year \".concat(year, \": avgWaitYears=\").concat(avgWaitYears, \" > 1.0 but scarcityMultiplier=\").concat(scarcityMultiplier, \" <= 1.0. \") + \"Scarcity multiplier should be > 1.0 when wait time exists (scarcity is multiplicative in GPU-hour pricing).\");\n        }\n        var _groundResult_totalCostPerPflopYearEffective1;\n        // Invariant 2: supplyMetrics.capacityGw is the effective capacity (bottleneck)\n        // Queue model uses coherent backlog based on unmet demand\n        // Invariant 3: GPU-hour chart yMax guard (prevented by explicit series extraction in chart component)\n        // This is handled in the chart component with explicit series extraction\n        // Invariant 4: Crossover uses effective ground cost\n        const groundEffective = (_groundResult_totalCostPerPflopYearEffective1 = groundResult.totalCostPerPflopYearEffective) !== null && _groundResult_totalCostPerPflopYearEffective1 !== void 0 ? _groundResult_totalCostPerPflopYearEffective1 : groundResult.totalCostPerPflopYear;\n        const groundHeadline = groundResult.totalCostPerPflopYear;\n        var _groundResult_constraints_delayPenalty;\n        const delayPenalty = (_groundResult_constraints_delayPenalty = (_groundResult_constraints3 = groundResult.constraints) === null || _groundResult_constraints3 === void 0 ? void 0 : _groundResult_constraints3.delayPenalty) !== null && _groundResult_constraints_delayPenalty !== void 0 ? _groundResult_constraints_delayPenalty : 0;\n        // Scarcity is now multiplicative (not additive), so don't add it to effective cost\n        const expectedEffective = groundHeadline + delayPenalty; // Scarcity applied in GPU-hour pricing, not PFLOP-year\n        const effectiveError = Math.abs(groundEffective - expectedEffective);\n        // Reuse scarcityMultiplier from Invariant 1 above\n        if (effectiveError > 0.01 && (delayPenalty > 0 || scarcityMultiplier > 1.0)) {\n            console.warn(\"[INVARIANT VIOLATION] Year \".concat(year, \": groundEffective=\").concat(groundEffective, \" != expected=\").concat(expectedEffective, \" \") + \"(headline=\".concat(groundHeadline, \", delayPenalty=\").concat(delayPenalty, \", scarcityMultiplier=\").concat(scarcityMultiplier, \"). \") + \"Crossover should use effective cost. Note: scarcity is multiplicative in GPU-hour pricing, not additive in PFLOP-year.\");\n        }\n    }\n    // CRITICAL FIX: Validate delivered efficiency by comparing like-for-like only\n    // expectedDelivered = systemEffectiveGflopsPerWatt * thermalCapFactor * radiationDerate * availability\n    // ratio = deliveredGflopsPerWatt / expectedDelivered\n    // If ratio is finite and |1 - ratio| <= tolerance (0.02), then valid=true, warning=null\n    // Else valid=false, warning describes the mismatch\n    // Remove any other comparisons (e.g., delivered vs systemEffective, delivered vs peak*utilization without overhead, etc.)\n    const expectedDelivered = orbitSystemEffectiveGflopsPerWatt * thermalCapFactor * radiationDerate * availability;\n    const ratio = orbitDeliveredGflopsPerWatt / Math.max(expectedDelivered, 1e-6);\n    const TOLERANCE = 0.02; // 2% tolerance\n    const ratioError = Math.abs(1 - ratio);\n    // CRITICAL: Fix validator logic - if ratio is finite and |1 - ratio| <= tolerance, then valid=true\n    const isRatioValid = isFinite(ratio) && ratioError <= TOLERANCE;\n    // Escalate: if mismatch > 5%, mark as invalid (don't just warn)\n    const ESCALATE_THRESHOLD = 0.05; // 5%\n    const isInvalid = !isRatioValid && ratioError > ESCALATE_THRESHOLD;\n    // Debug invariants: assert delivered <= systemEffective + eps\n    const deliveredVsSystemError = orbitDeliveredGflopsPerWatt - orbitSystemEffectiveGflopsPerWatt;\n    if (deliveredVsSystemError > 1e-6) {\n        console.warn(\"[INVARIANT VIOLATION] Delivered efficiency (\".concat(orbitDeliveredGflopsPerWatt.toFixed(2), \") > systemEffective (\").concat(orbitSystemEffectiveGflopsPerWatt.toFixed(2), \"). \") + \"Delivered must be <= systemEffective.\");\n    }\n    // Efficiency debug logging removed for cleaner console output\n    // Validation results are available in orbit.computeEfficiency.validation metadata\n    // CRITICAL: Validate delivered efficiency - compare delivered vs expectedDelivered only\n    // Make validator debug explicit with all factors\n    // If mismatch > 5%, mark run invalid and stop chart rendering (escalate, don't silently warn)\n    const deliveredValidation = {\n        valid: isRatioValid,\n        warning: isRatioValid ? undefined // Empty/null when valid\n         : \"Power/Efficiency mismatch: \".concat(ratio.toFixed(2), \"x discrepancy (expected=\").concat(expectedDelivered.toFixed(2), \", delivered=\").concat(orbitDeliveredGflopsPerWatt.toFixed(2), \")\"),\n        expectedDelivered,\n        delivered: orbitDeliveredGflopsPerWatt,\n        ratio,\n        factorsUsed: {\n            thermalCapFactor,\n            radiationDerate,\n            availability,\n            utilization: orbitalEfficiencyResult.debug.utilizationFactor,\n            systemOverheadFactor: orbitalEfficiencyResult.debug.systemOverheadFactor\n        },\n        // Escalate: if ratio is way off (> 5%), mark as invalid\n        invalid: !isRatioValid && Math.abs(1 - ratio) > 0.05\n    };\n    const efficiencyValidation = validateComputeEfficiency(orbitEffectiveGflopsPerW, params.efficiencyLevel);\n    const consistencyCheck = assertComputePowerConsistency(orbitEffectiveGflopsPerW, targetComputeKw, totalEffectivePflops, MODEL_UNITS);\n    var _groundResult_capacityDeliveryPremium, _groundResult_timeToEnergizePenalty1, _groundResult_siteCapexAmortPerPflopYear, _groundResult_timeToEnergizePenalty2, _groundResult_capacityDeliveryPremium1, _hybridResult_specificPowerMultipliers_massMultiplier, _hybridResult_thermalSystem_wasteHeatW, _hybridResult_thermalSystem_qPerM2_W, _hybridResult_thermalSystem_areaAvailableM2;\n    // SANITY PANEL: Comprehensive debug block per year\n    const sanityPanel = {\n        ground: {\n            effectiveGflopsPerW: groundEffectiveGflopsPerW,\n            energyCostPerPflopYear: groundResult.energyCost,\n            siteCapexAmort: (_groundResult_siteCapexAmortPerPflopYear = groundResult.siteCapexAmortPerPflopYear) !== null && _groundResult_siteCapexAmortPerPflopYear !== void 0 ? _groundResult_siteCapexAmortPerPflopYear : groundResult.siteCost - ((_groundResult_capacityDeliveryPremium = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium !== void 0 ? _groundResult_capacityDeliveryPremium : 0) - ((_groundResult_timeToEnergizePenalty1 = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty1 !== void 0 ? _groundResult_timeToEnergizePenalty1 : 0),\n            delayPenalty: (_groundResult_timeToEnergizePenalty2 = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty2 !== void 0 ? _groundResult_timeToEnergizePenalty2 : 0,\n            capacityPremium: (_groundResult_capacityDeliveryPremium1 = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium1 !== void 0 ? _groundResult_capacityDeliveryPremium1 : 0,\n            constraintMultiplier: groundResult.constraintMultiplier,\n            total: groundTotalCost\n        },\n        orbit: {\n            // REMOVED: effectiveSpecificPower (duplicate of specificPower_effective_WPerKg)\n            // Use specificPower_effective_WPerKg instead (canonical field)\n            massMultiplier: (_hybridResult_specificPowerMultipliers_massMultiplier = (_hybridResult_specificPowerMultipliers = hybridResult.specificPowerMultipliers) === null || _hybridResult_specificPowerMultipliers === void 0 ? void 0 : _hybridResult_specificPowerMultipliers.massMultiplier) !== null && _hybridResult_specificPowerMultipliers_massMultiplier !== void 0 ? _hybridResult_specificPowerMultipliers_massMultiplier : 1.0,\n            requiredAreaM2: hybridResult.thermalSystem.qPerM2_W ? ((_hybridResult_thermalSystem_wasteHeatW = hybridResult.thermalSystem.wasteHeatW) !== null && _hybridResult_thermalSystem_wasteHeatW !== void 0 ? _hybridResult_thermalSystem_wasteHeatW : hybridResult.thermalSystem.wasteHeatKw * 1000) / ((_hybridResult_thermalSystem_qPerM2_W = hybridResult.thermalSystem.qPerM2_W) !== null && _hybridResult_thermalSystem_qPerM2_W !== void 0 ? _hybridResult_thermalSystem_qPerM2_W : 1) : hybridResult.thermalSystem.physicalAreaM2,\n            areaAvailableM2: (_hybridResult_thermalSystem_areaAvailableM2 = hybridResult.thermalSystem.areaAvailableM2) !== null && _hybridResult_thermalSystem_areaAvailableM2 !== void 0 ? _hybridResult_thermalSystem_areaAvailableM2 : hybridResult.thermalSystem.physicalAreaM2,\n            thermalCapFactor: hybridResult.thermalSystem.thermalCapFactor,\n            total: realisticCostPerPflop\n        },\n        allInvariantsPassed: (()=>{\n            var _groundResult_siteCapexAmortPerPflopYear, _groundResult_timeToEnergizePenalty, _groundResult_capacityDeliveryPremium;\n            // Check key invariants\n            const siteCostCheck = Math.abs(groundResult.siteCost - (((_groundResult_siteCapexAmortPerPflopYear = groundResult.siteCapexAmortPerPflopYear) !== null && _groundResult_siteCapexAmortPerPflopYear !== void 0 ? _groundResult_siteCapexAmortPerPflopYear : 0) + ((_groundResult_timeToEnergizePenalty = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty !== void 0 ? _groundResult_timeToEnergizePenalty : 0) + ((_groundResult_capacityDeliveryPremium = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium !== void 0 ? _groundResult_capacityDeliveryPremium : 0))) < 0.01;\n            const thermalAreaCheck = hybridResult.thermalSystem.areaAvailableM2 ? Math.abs(hybridResult.thermalSystem.areaAvailableM2 - hybridResult.thermalSystem.physicalAreaM2) / hybridResult.thermalSystem.physicalAreaM2 < 0.01 : true;\n            const specificPowerCheck = hybridResult.specificPowerMultipliers ? hybridResult.specificPowerMultipliers.effective <= hybridResult.specificPowerMultipliers.baseSpecificPower * 1.01 : true;\n            const thermalCapCheck = hybridResult.thermalSystem.thermalCapFactor >= 0 && hybridResult.thermalSystem.thermalCapFactor <= 1;\n            return siteCostCheck && thermalAreaCheck && specificPowerCheck && thermalCapCheck;\n        })()\n    };\n    var _groundResult_capacityDeliveryPremium2, _groundResult_timeToEnergizePenalty3, _groundResult_siteCapexAmortPerPflopYear1, _groundResult_capacityDeliveryPremium3, _groundResult_timeToEnergizePenalty4, _hybridResult_specificPowerMultipliers_effective, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _ref10, _ref11;\n    return {\n        year,\n        mode: params.isStaticMode ? \"STATIC\" : \"DYNAMIC\",\n        sanityPanel,\n        ground: {\n            electricityPricePerMwh: groundElectricityPricePerMwh,\n            pue: effectivePueGround,\n            capacityFactor: capacityFactorGround,\n            // HARD ASSERT: All ground efficiency fields must be populated and finite\n            gflopsPerWatt: (()=>{\n                const value = groundEffectiveGflopsPerW;\n                if (!isFinite(value) || value <= 0) {\n                    throw new Error(\"ground.gflopsPerWatt is invalid: \".concat(value, \". actualGroundInput=\").concat(actualGroundInput));\n                }\n                return value;\n            })(),\n            computeDefinition: (()=>{\n                // CRITICAL FIX: Validate all computeDefinition fields to catch unit corruption\n                const peak = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(groundEfficiencyResult.debug.chipPeakGflopsPerW, \"ground.computeDefinition.peakGflopsPerWatt\");\n                const effective = (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(groundEfficiencyResult.debug.effectiveGflopsPerW, \"ground.computeDefinition.effectiveGflopsPerWatt\");\n                const utilization = groundEfficiencyResult.debug.utilizationFactor;\n                if (!isFinite(utilization) || utilization <= 0 || utilization > 1) {\n                    throw new Error(\"ground.computeDefinition.utilizationFactor is invalid: \".concat(utilization));\n                }\n                return {\n                    chipName: \"NVIDIA H100 SXM\",\n                    precision: \"FP16\",\n                    peakGflopsPerWatt: peak,\n                    utilizationFactor: utilization,\n                    effectiveGflopsPerWatt: effective,\n                    notes: \"Datacenter deployment, system-level efficiency\"\n                };\n            })(),\n            energyCostPerPflopYear: (()=>{\n                const value = groundResult.energyCost;\n                if (!isFinite(value) || value < 0) {\n                    throw new Error(\"ground.energyCostPerPflopYear is invalid: \".concat(value, \". \") + \"Check: groundEffectiveGflopsPerW=\".concat(groundEffectiveGflopsPerW, \", \") + \"groundElectricityPricePerMwh=\".concat(groundElectricityPricePerMwh, \", \") + \"effectivePueGround=\".concat(effectivePueGround));\n                }\n                return value;\n            })(),\n            siteCostPerPflopYear: (()=>{\n                const value = groundResult.siteCost;\n                if (!isFinite(value) || value < 0) {\n                    throw new Error(\"ground.siteCostPerPflopYear is invalid: \".concat(value));\n                }\n                return value;\n            })(),\n            siteCapexAmortPerPflopYear: (_groundResult_siteCapexAmortPerPflopYear1 = groundResult.siteCapexAmortPerPflopYear) !== null && _groundResult_siteCapexAmortPerPflopYear1 !== void 0 ? _groundResult_siteCapexAmortPerPflopYear1 : groundResult.siteCost - ((_groundResult_capacityDeliveryPremium2 = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium2 !== void 0 ? _groundResult_capacityDeliveryPremium2 : 0) - ((_groundResult_timeToEnergizePenalty3 = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty3 !== void 0 ? _groundResult_timeToEnergizePenalty3 : 0),\n            capacityDeliveryPremium: (_groundResult_capacityDeliveryPremium3 = groundResult.capacityDeliveryPremium) !== null && _groundResult_capacityDeliveryPremium3 !== void 0 ? _groundResult_capacityDeliveryPremium3 : 0,\n            timeToEnergizePenalty: (_groundResult_timeToEnergizePenalty4 = groundResult.timeToEnergizePenalty) !== null && _groundResult_timeToEnergizePenalty4 !== void 0 ? _groundResult_timeToEnergizePenalty4 : 0,\n            hardwareCapexPerPflopYear: groundResult.hardwareCost,\n            constraintMultiplier: 1.0,\n            constraintBreakdown: {\n                ...constraintBreakdown,\n                capacityDeliveryMultiplier: 1.0\n            },\n            constraints: groundResult.constraints ? {\n                ...groundResult.constraints,\n                method: \"adders\"\n            } : {\n                method: \"adders\",\n                capacityDeliveryPremium: groundResult.capacityDeliveryPremium || 0,\n                delayPenalty: groundResult.timeToEnergizePenalty || 0,\n                appliedMultipliers: {\n                    constraintMultiplierUsed: false,\n                    energyMultiplierUsed: false,\n                    siteMultiplierUsed: false\n                }\n            },\n            supplyMetrics: groundResult.supplyMetrics,\n            constraintComponents: groundResult.constraintComponents,\n            totalCostPerPflopYear: (()=>{\n                const value = groundTotalCost;\n                if (!isFinite(value) || value <= 0) {\n                    throw new Error(\"ground.totalCostPerPflopYear is invalid: \".concat(value, \". \") + \"Components: energy=\".concat(groundResult.energyCost, \", site=\").concat(groundResult.siteCost, \", hardware=\").concat(groundResult.hardwareCost, \", \") + \"groundEffectiveGflopsPerW=\".concat(groundEffectiveGflopsPerW, \", actualGroundInput=\").concat(actualGroundInput));\n                }\n                return value;\n            })(),\n            gpuHourPricing: {\n                basic: groundGpuHour(SLA_TIERS.basic),\n                standard: groundGpuHour(SLA_TIERS.standard),\n                premium: groundGpuHour(SLA_TIERS.premium)\n            },\n            tokenPricing: groundTokens,\n            smrEnabled: groundResult.smrEnabled,\n            smrRampFactor: groundResult.smrRampFactor,\n            effectiveElectricityCost: groundResult.effectiveElectricityCost,\n            constraintRelief: groundResult.constraintRelief\n        },\n        orbit: {\n            lcoePerMwh: hybridResult.powerSystem.totalCostUsd / (satellitePowerKW * _orbitalPhysics__WEBPACK_IMPORTED_MODULE_2__.PHYSICS_CONSTANTS.HOURS_PER_YEAR * lifetimeYears * hybridResult.capacityFactor / 1000),\n            pue: pueOrbital,\n            capacityFactor: hybridResult.capacityFactor,\n            capacityFactorProvenance: (_hybridResult_computePayload = hybridResult.computePayload) === null || _hybridResult_computePayload === void 0 ? void 0 : _hybridResult_computePayload.capacityFactorProvenance,\n            gflopsPerWatt: orbitEffectiveGflopsPerW,\n            computeDefinition: {\n                chipName: \"H100-equivalent (rad-tolerant)\",\n                precision: \"FP16\",\n                peakGflopsPerWatt: (0,_units__WEBPACK_IMPORTED_MODULE_10__.validateGflopsPerWatt)(orbitPeakGflopsPerWatt, \"orbit.computeDefinition.peakGflopsPerWatt\"),\n                utilizationFactor: orbitalEfficiencyResult.debug.utilizationFactor,\n                effectiveGflopsPerWatt: orbitSystemEffectiveGflopsPerWatt,\n                // deliveredGflopsPerWatt is stored in orbit.computeEfficiency.gflopsPerWatt, not here\n                notes: \"Commercial rad-tolerant variant. peakGflopsPerWatt = chip peak. effectiveGflopsPerWatt = peak * utilization / systemOverheadFactor (system-level effective). deliveredGflopsPerWatt = systemEffective \\xd7 thermalCapFactor \\xd7 radiationDerate \\xd7 availability\"\n            },\n            computeEfficiencyProvenance: {\n                peakGflopsPerWatt: orbitalEfficiencyResult.debug.chipPeakGflopsPerW,\n                utilizationFactor: orbitalEfficiencyResult.debug.utilizationFactor,\n                systemOverheadFactor: orbitalEfficiencyResult.debug.systemOverheadFactor,\n                effectiveGflopsPerWatt: orbitalEfficiencyResult.debug.effectiveGflopsPerW\n            },\n            launchCostPerKg: launchCostPerKg,\n            specificPowerWPerKg: hybridResult.specificPowerWPerKg,\n            specificPower_subsystem_WPerKg: hybridResult.specificPowerWPerKg,\n            specificPower_effective_WPerKg: (_hybridResult_specificPowerMultipliers_effective = (_hybridResult_specificPowerMultipliers1 = hybridResult.specificPowerMultipliers) === null || _hybridResult_specificPowerMultipliers1 === void 0 ? void 0 : _hybridResult_specificPowerMultipliers1.effective) !== null && _hybridResult_specificPowerMultipliers_effective !== void 0 ? _hybridResult_specificPowerMultipliers_effective : scalingResult.effectiveSpecificPower,\n            // Use specificPowerMultipliers from hybridResult (calculated in orbitalPhysics.ts with correct mass fraction accounting)\n            specificPowerMultipliers: hybridResult.specificPowerMultipliers,\n            energyCostPerPflopYear: orbitalBreakdown.power,\n            hardwareCostPerPflopYear: orbitalBreakdown.compute,\n            launchCostPerPflopYear: orbitalBreakdown.launch,\n            radiationMultiplier: 1.0,\n            thermalCapFactor: hybridResult.thermalSystem.thermalCapFactor,\n            congestionCostPerPflopYear: orbitalBreakdown.congestion,\n            totalCostPerPflopYear: realisticCostPerPflop,\n            thermalCapped: hybridResult.thermalSystem.thermalCapped,\n            computePowerKw: targetComputeKw,\n            maxRejectableKw: hybridResult.thermalSystem.maxRejectableKw || hybridResult.thermalSystem.wasteHeatKw * 1.25,\n            collisionRisk: congestion.collisionRisk,\n            bodyMountedAreaM2: 0,\n            deployableAreaM2: hybridResult.thermalSystem.physicalAreaM2,\n            totalRadiatorAreaM2: hybridResult.thermalSystem.physicalAreaM2,\n            radiatorCostPerPflopYear: hybridResult.thermalSystem.totalCostUsd * constellationCostMultiplier / totalEffectivePflops / lifetimeYears,\n            radiatorMassKg: hybridResult.thermalSystem.totalMassKg,\n            optimisticCostPerPflop: orbitalBreakdown.power + orbitalBreakdown.compute + orbitalBreakdown.bus,\n            radiationShieldingCost: orbitalBreakdown.radiation,\n            thermalSystemCost: orbitalBreakdown.thermal,\n            replacementRateCost: orbitalBreakdown.ops,\n            eccOverheadCost: 0,\n            redundancyCost: 0,\n            realisticCostPerPflop,\n            hybridBreakdown: orbitalBreakdown,\n            gpuHourPricing: {\n                basic: orbitalGpuHour(SLA_TIERS.basic),\n                standard: orbitalGpuHour(SLA_TIERS.standard),\n                premium: orbitalGpuHour(SLA_TIERS.premium)\n            },\n            tokenPricing: orbitalTokens,\n            radiationDegradation: {\n                annualFailureRate: useRadHardChips ? 0.09 : 0.15,\n                effectiveComputePercent: hybridResult.degradationFactor,\n                eccOverheadPct: 0.05,\n                applied: true\n            },\n            powerSystemType: hybridResult.powerSystemType,\n            scalingPenalty: scalingResult.scalingPenalty,\n            // REMOVED: effectiveSpecificPower (duplicate of specificPower_effective_WPerKg)\n            // Use specificPower_effective_WPerKg instead (canonical field)\n            fusionDetails: hybridResult.fusionDetails,\n            // Constellation sizing\n            constellation: {\n                design: {\n                    numSatellites: constellation.numSatellites,\n                    computePerSatKw: constellation.computePerSatKw,\n                    massPerSatKg: massPerSatKg,\n                    radiatorAreaPerSatM2: constellation.radiatorAreaPerSatM2\n                },\n                launch: {\n                    satsPerLaunch: constellation.satsPerLaunch,\n                    launchesRequired: constellation.launchesRequired,\n                    totalMassKg: effectiveTotalMassKg\n                },\n                scaling: {\n                    constellationOverhead: constellation.constellationOverhead,\n                    scalingEfficiency: constellation.scalingEfficiency\n                },\n                warnings: constellation.warnings\n            },\n            // Debug blocks for analysis - explicitly track all efficiency levels\n            // Single source of truth: define orbit.computeEfficiencyLevels each year\n            // Note: computeEfficiencyLevels is stored in metadata, not directly on orbit\n            effectiveComputeMultipliers: {\n                thermalCapFactor: hybridResult.thermalSystem.thermalCapFactor,\n                radiationDerate: hybridResult.degradationFactor || 1.0,\n                availability: hybridResult.capacityFactor || 1.0,\n                utilization: orbitalEfficiencyResult.debug.utilizationFactor\n            },\n            costShares: (()=>{\n                const total = realisticCostPerPflop;\n                return {\n                    launch: orbitalBreakdown.launch / total * 100,\n                    power: orbitalBreakdown.power / total * 100,\n                    compute: orbitalBreakdown.compute / total * 100,\n                    thermal: orbitalBreakdown.thermal / total * 100,\n                    bus: orbitalBreakdown.bus / total * 100,\n                    ops: orbitalBreakdown.ops / total * 100,\n                    networking: orbitalBreakdown.networking / total * 100,\n                    groundSegment: orbitalBreakdown.regulatory / total * 100\n                };\n            })(),\n            localSensitivity: (()=>{\n                // Calculate local sensitivity: dCost/dParameter (approximate derivatives)\n                // dCost_dLaunch: launch cost scales linearly with launchCostPerKg\n                const dCost_dLaunch = orbitalBreakdown.launch / launchCostPerKg;\n                // dCost_dSpecificPower: power cost scales inversely with specific power (negative)\n                const dCost_dSpecificPower = -(orbitalBreakdown.power / trajSpecificPower);\n                // dCost_dGflopsPerW: power cost scales inversely with GFLOPS/W (negative)\n                const dCost_dGflopsPerW = -(orbitalBreakdown.power / orbitEffectiveGflopsPerW);\n                // dCost_dFailureRate: ops cost scales with failure rate\n                const baseFailureRate = useRadHardChips ? 0.09 : 0.15;\n                const dCost_dFailureRate = orbitalBreakdown.ops / baseFailureRate;\n                // dCost_dPue: power cost scales linearly with PUE\n                const dCost_dPue = orbitalBreakdown.power / pueOrbital;\n                return {\n                    dCost_dLaunch,\n                    dCost_dSpecificPower,\n                    dCost_dGflopsPerW,\n                    dCost_dFailureRate,\n                    dCost_dPue\n                };\n            })()\n        },\n        edgeInference,\n        crossover: realisticCostPerPflop < groundComparatorCostPerPflopYear,\n        crossoverDetails: {\n            gpuHourCrossover,\n            tokenCrossover: orbitalTokens.llama70B.costPer1kTokens < groundTokens.llama70B.costPer1kTokens,\n            marketPosition: gpuHourCrossover ? \"Orbital \".concat(((1 - orbitalGpuHour(SLA_TIERS.standard).pricePerGpuHour / groundGpuHour(SLA_TIERS.standard).pricePerGpuHour) * 100).toFixed(1), \"% cheaper\") : \"Ground \".concat(((1 - groundGpuHour(SLA_TIERS.standard).pricePerGpuHour / orbitalGpuHour(SLA_TIERS.standard).pricePerGpuHour) * 100).toFixed(1), \"% cheaper\")\n        },\n        costAccountingValid,\n        costAccountingErrorPct,\n        metadata: {\n            groundUnits: [\n                {\n                    metric: \"gflopsPerWatt\",\n                    unit: \"GFLOPS/W\",\n                    level: \"system\",\n                    notes: \"Ground system-level efficiency including memory, network, power delivery overhead\"\n                }\n            ],\n            orbitUnits: [\n                {\n                    metric: \"gflopsPerWatt\",\n                    unit: \"GFLOPS/W\",\n                    level: \"delivered\",\n                    notes: \"Orbital delivered efficiency: systemEffective \\xd7 thermalCapFactor \\xd7 radiationDerate \\xd7 availability\"\n                }\n            ],\n            units: [\n                {\n                    metric: \"gflopsPerWatt\",\n                    unit: \"GFLOPS/W\",\n                    level: \"system\",\n                    notes: \"System-level efficiency including memory, network, power delivery overhead\"\n                },\n                {\n                    metric: \"costPerPflopYear\",\n                    unit: \"USD/PFLOP-year\",\n                    level: \"infrastructure\",\n                    notes: \"Total cost to operate 1 PFLOP of sustained compute for one year\"\n                },\n                {\n                    metric: \"pricePerGpuHour\",\n                    unit: \"USD/GPU-hour\",\n                    level: \"market\",\n                    notes: \"Market price with SLA, including margin and risk buffer\"\n                },\n                {\n                    metric: \"costPer1kTokens\",\n                    unit: \"USD/1K tokens\",\n                    level: \"application\",\n                    notes: \"Inference cost for specified model size (70B or 405B)\"\n                }\n            ],\n            debug: {\n                groundLifetime: groundLifetime,\n                gpuFailureRateAnnual: params.gpuFailureRateAnnual,\n                totalCostExcludesDelayPenalty: true,\n                totalCostEffectiveIncludesDelayPenalty: groundResult.totalCostPerPflopYearEffective !== undefined,\n                groundHasQueue,\n                groundComparatorCostPerPflopYear\n            },\n            computeEfficiency: {\n                gflopsPerWatt: orbitEffectiveGflopsPerW,\n                efficiencyLevel: \"delivered\",\n                validation: {\n                    // CRITICAL: Use deliveredValidation as primary - it compares like-for-like\n                    // Only fail if deliveredValidation fails (ratio mismatch) OR efficiencyValidation fails (range check)\n                    // consistencyCheck is for power/compute consistency, not efficiency validation\n                    valid: efficiencyValidation.valid && deliveredValidation.valid,\n                    warning: efficiencyValidation.warning || deliveredValidation.warning || undefined,\n                    expectedDelivered: deliveredValidation.expectedDelivered,\n                    delivered: deliveredValidation.delivered,\n                    ratio: deliveredValidation.ratio,\n                    factorsUsed: deliveredValidation.factorsUsed\n                }\n            },\n            // Chart inputs for power buildout constraints (replaces energyCostComparison)\n            chartInputs: {\n                powerBuildout: {\n                    demandGw: (_ref3 = (_ref2 = \"buildoutDebug\" in groundResult ? (_groundResult_buildoutDebug = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug === void 0 ? void 0 : _groundResult_buildoutDebug.demandGW : undefined) !== null && _ref2 !== void 0 ? _ref2 : \"supplyMetrics\" in groundResult ? (_groundResult_supplyMetrics = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics === void 0 ? void 0 : _groundResult_supplyMetrics.demandGw : undefined) !== null && _ref3 !== void 0 ? _ref3 : 0,\n                    supplyGw: (_ref4 = \"supplyMetrics\" in groundResult ? (_groundResult_supplyMetrics1 = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics1 === void 0 ? void 0 : _groundResult_supplyMetrics1.capacityGw : undefined) !== null && _ref4 !== void 0 ? _ref4 : 0,\n                    maxBuildRateGwYear: (_ref6 = (_ref5 = \"supplyMetrics\" in groundResult ? (_groundResult_supplyMetrics2 = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics2 === void 0 ? void 0 : _groundResult_supplyMetrics2.maxBuildRateGwYear : undefined) !== null && _ref5 !== void 0 ? _ref5 : \"buildoutDebug\" in groundResult ? (_groundResult_buildoutDebug1 = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug1 === void 0 ? void 0 : _groundResult_buildoutDebug1.buildRateGWyr : undefined) !== null && _ref6 !== void 0 ? _ref6 : 0,\n                    pipelineGw: (_ref7 = \"supplyMetrics\" in groundResult ? (_groundResult_supplyMetrics3 = groundResult.supplyMetrics) === null || _groundResult_supplyMetrics3 === void 0 ? void 0 : _groundResult_supplyMetrics3.pipelineGw : undefined) !== null && _ref7 !== void 0 ? _ref7 : 0,\n                    backlogGw: (_ref9 = (_ref8 = \"backlogGw\" in groundResult ? groundResult.backlogGw : undefined) !== null && _ref8 !== void 0 ? _ref8 : \"buildoutDebug\" in groundResult ? (_groundResult_buildoutDebug2 = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug2 === void 0 ? void 0 : _groundResult_buildoutDebug2.backlogGW : undefined) !== null && _ref9 !== void 0 ? _ref9 : 0,\n                    avgWaitYears: (_ref11 = (_ref10 = \"avgWaitYears\" in groundResult ? groundResult.avgWaitYears : undefined) !== null && _ref10 !== void 0 ? _ref10 : \"buildoutDebug\" in groundResult ? (_groundResult_buildoutDebug3 = groundResult.buildoutDebug) === null || _groundResult_buildoutDebug3 === void 0 ? void 0 : _groundResult_buildoutDebug3.timeToPowerYears : undefined) !== null && _ref11 !== void 0 ? _ref11 : 0\n                }\n            }\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvcGh5c2ljc0Nvc3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXbUQ7QUFDUztBQVlsQztBQUNtRjtBQUNtRDtBQUN0RDtBQUNWO0FBQ2tEO0FBQzVEO0FBQ0s7QUFDNUI7QUFNcUI7QUFJcEYsTUFBTXNCLFlBQVk7SUFDaEJDLGdCQUFnQjtJQUNoQkMsaUNBQWlDO0lBQ2pDQywwQkFBMEI7SUFDMUJDLDRCQUE0QjtBQUM5QjtBQUVPLE1BQU1DLHFCQUFzQztJQUNqREMsU0FBUztJQUNUQyx3QkFBd0I7SUFDeEJDLGdCQUFnQjtJQUNoQkMsd0JBQXdCO0lBQ3hCQyxzQkFBc0I7SUFDdEJDLHlCQUF5QjtJQUN6QkMsdUJBQXVCO0lBQ3ZCQyxzQkFBc0I7SUFDdEJDLGlCQUFpQjtBQUNuQixFQUFFO0FBRUssTUFBTUMsbUJBQWlFO0lBQzVFQyxlQUFlO1FBQ2JDLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGdCQUFnQjtJQUNsQjtJQUNBQyxVQUFVO1FBQ1JQLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGdCQUFnQjtJQUNsQjtJQUNBRSxhQUFhO1FBQ1hSLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGdCQUFnQjtJQUNsQjtJQUNBRyxRQUFRO1FBQ05ULE1BQU07UUFDTkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGdCQUFnQjtJQUNsQjtBQUNGLEVBQUU7QUFFRixTQUFTSSwwQkFDUEMsSUFBWSxFQUNaQyxXQUEyQixFQUMzQnZCLE9B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QkFBdkQsMkJBQ0EsbUJBQW1CaUksZ0JBQWVBLCtCQUFBQSxhQUFhNEssYUFBYSxjQUExQjVLLG1EQUFBQSw2QkFBNEJpSSxTQUFTLEdBQUdsUSx1QkFEM0UsMkJBQ3lGO29CQUNwR3dOLGNBQWMsV0FBQywyQkFBa0J2RixlQUFlQSxhQUFhdUYsWUFBWSxHQUFHeE4sdUJBQTdELDZCQUNBLG1CQUFtQmlJLGdCQUFlQSwrQkFBQUEsYUFBYTRLLGFBQWEsY0FBMUI1SyxtREFBQUEsNkJBQTRCMkwsZ0JBQWdCLEdBQUc1VCx1QkFEbEYsNkJBQ2dHO2dCQUNoSDtZQUNGO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvbW9kZWwvcGh5c2ljc0Nvc3QudHM/M2ZkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBcbiAgWWVhclBhcmFtcywgXG4gIFllYXJseUJyZWFrZG93biwgXG4gIFNMQUNvbmZpZywgXG4gIEdwdUhvdXJQcmljaW5nLCBcbiAgVG9rZW5QcmljaW5nLCBcbiAgV29ya2xvYWRUeXBlLFxuICBHcm91bmRTY2VuYXJpbyxcbiAgR3JvdW5kU2NlbmFyaW9Db25maWcsXG4gIFNNUlRvZ2dsZVBhcmFtc1xufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGNhbGN1bGF0ZUNvbmdlc3Rpb24gfSBmcm9tICcuL2Nvbmdlc3Rpb24nO1xuaW1wb3J0IHsgY29tcHV0ZUVkZ2VJbmZlcmVuY2VDb3N0cyB9IGZyb20gJy4vZWRnZUluZmVyZW5jZSc7XG5pbXBvcnQgeyBcbiAgY29tcHV0ZVNhdGVsbGl0ZUh5YnJpZENvc3QsXG4gIERFRkFVTFRfQ09ORklHLFxuICBQSFlTSUNTX0NPTlNUQU5UUyxcbiAgU1RBUkxJTktfRU1QSVJJQ0FMLFxuICBXT1JLTE9BRF9QUk9GSUxFUyxcbiAgREVGQVVMVF9JTlRFUkNPTk5FQ1QsXG4gIERFRkFVTFRfRlVTSU9OX1BBUkFNUyxcbiAgREVGQVVMVF9QT1dFUl9TQ0FMSU5HLFxuICBjYWxjdWxhdGVTY2FsZWRNYXNzLFxuICBTcGFjZUZ1c2lvblBhcmFtc1xufSBmcm9tICcuL29yYml0YWxQaHlzaWNzJztcbmltcG9ydCB7IGNhbGN1bGF0ZVJlZ2lvbmFsR3JvdW5kQ29zdCwgR3JvdW5kQ29zdFJlc3VsdCwgZ2V0R2xvYmFsRGVtYW5kUGZsb3BzIH0gZnJvbSAnLi9ncm91bmRfc3VwcGx5X21vZGVsJztcbmltcG9ydCB7IGdlbmVyYXRlR3JvdW5kU3VwcGx5VHJhamVjdG9yeSwgY2FsY3VsYXRlQ29uc3RyYWludEZyb21TdXBwbHksIHN0ZXBHcm91bmRTdXBwbHksIElOSVRJQUxfU1VQUExZX1NUQVRFLCBHcm91bmRTdXBwbHlTdGF0ZSB9IGZyb20gJy4vZ3JvdW5kX3F1ZXVlX21vZGVsJztcbmltcG9ydCB7IGNhbGN1bGF0ZUdyb3VuZENvbnN0cmFpbnRQZW5hbHRpZXMsIGNhbGN1bGF0ZVNjYXJjaXR5UmVudCB9IGZyb20gJy4vZ3JvdW5kX2NvbnN0cmFpbnRfcGVuYWx0aWVzJztcbmltcG9ydCB7IGNhbGN1bGF0ZUJ1aWxkb3V0Q29uc3RyYWludHMsIEJ1aWxkb3V0U3RhdGUsIEJ1aWxkb3V0UmVzdWx0IH0gZnJvbSAnLi9ncm91bmRfYnVpbGRvdXQnO1xuaW1wb3J0IHsgc3RlcE1vYmlsaXphdGlvblN0YXRlLCBERUZBVUxUX01PQklMSVpBVElPTl9QQVJBTVMsIE1vYmlsaXphdGlvblNjZW5hcmlvUGFyYW1zLCBNb2JpbGl6YXRpb25TdGF0ZSB9IGZyb20gJy4vZ3JvdW5kX3JhbXBpbmdfbW9iaWxpemF0aW9uJztcbmltcG9ydCB7IENvbXB1dGVFZmZpY2llbmN5LCBnZXREZWZhdWx0Q29tcHV0ZUVmZmljaWVuY3kgfSBmcm9tICcuL2NvbXB1dGVfZWZmaWNpZW5jeSc7XG5pbXBvcnQgeyBhc3NlcnRDb3N0QWNjb3VudGluZywgdmFsaWRhdGVUcmFqZWN0b3J5Q29zdEFjY291bnRpbmcgfSBmcm9tICcuL2Nvc3RfYWNjb3VudGluZyc7XG5pbXBvcnQgeyB2YWxpZGF0ZUdmbG9wc1BlcldhdHQsIENPTVBVVEVfVU5JVFMgfSBmcm9tICcuL3VuaXRzJztcbmltcG9ydCB7IHNhbml0aXplRmluaXRlLCBzYW5pdGl6ZVNlcmllcyB9IGZyb20gJy4uL3V0aWxzL3Nhbml0aXplJztcbmltcG9ydCB7IGNhbGN1bGF0ZU5ldHdvcmtpbmdTY2FsaW5nIH0gZnJvbSAnLi9uZXR3b3JraW5nX3NjYWxpbmcnO1xuaW1wb3J0IHsgc3RlcExhdW5jaExlYXJuaW5nLCBMYXVuY2hMZWFybmluZ1N0YXRlIH0gZnJvbSAnLi9sYXVuY2hfbGVhcm5pbmcnO1xuaW1wb3J0IHsgY2FsY3VsYXRlU3lzdGVtU3BlY2lmaWNQb3dlciB9IGZyb20gJy4vc3BlY2lmaWNfcG93ZXInO1xuaW1wb3J0IHsgY2FsY3VsYXRlVGhlcm1hbFN5c3RlbSwgREVGQVVMVF9USEVSTUFMX1BBUkFNUyB9IGZyb20gJy4vdGhlcm1hbF9waHlzaWNzJztcbmltcG9ydCB7IGRlc2lnbkNvbnN0ZWxsYXRpb24sIFNBVEVMTElURV9DT05TVFJBSU5UUyB9IGZyb20gJy4vY29uc3RlbGxhdGlvbl9zaXppbmcnO1xuaW1wb3J0IHsgZ2V0U3RhdGljUGFyYW1zIH0gZnJvbSAnLi9tb2Rlcy9zdGF0aWMnO1xuaW1wb3J0IHsgZ2V0RGVtYW5kUHJvamVjdGlvbiwgZ2V0RmFjaWxpdHlMb2FkR1csIGdldERlbWFuZE5ld0dXLCBnZXRJVExvYWRHVyB9IGZyb20gJy4vdHJhamVjdG9yeSc7XG5cbmNvbnN0IENPTlNUQU5UUyA9IHtcbiAgSE9VUlNfUEVSX1lFQVI6IDg3NjAsXG4gIEdST1VORF9IQVJEV0FSRV9DT1NUX1BGTE9QXzIwMjU6IDE1MDAwLCBcbiAgR1JPVU5EX0hBUkRXQVJFX0xJRkVUSU1FOiAzLFxuICBNSU5fREVMSVZFUkVEX0dGTE9QU19QRVJfVzogMjAsIC8vIE1pbmltdW0gZGVsaXZlcmVkIGVmZmljaWVuY3kgdG8gcHJldmVudCB2YWxpZGF0aW9uIGVycm9ycyBmcm9tIHNldmVyZSB0aGVybWFsIGNvbnN0cmFpbnRzXG59O1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9TTVJfUEFSQU1TOiBTTVJUb2dnbGVQYXJhbXMgPSB7XG4gIGVuYWJsZWQ6IGZhbHNlLFxuICBzbXJEZXBsb3ltZW50U3RhcnRZZWFyOiAyMDMwLFxuICBzbXJSYW1wVXBZZWFyczogNSxcbiAgZWxlY3RyaWNpdHlDb3N0V2l0aFNNUjogNTAsXG4gIGdyaWRDb25zdHJhaW50UmVsaWVmOiAwLjkwLFxuICBjb29saW5nQ29uc3RyYWludFJlbGllZjogMC41MCxcbiAgd2F0ZXJDb25zdHJhaW50UmVsaWVmOiAwLjMwLFxuICBsYW5kQ29uc3RyYWludFJlbGllZjogMC42MCxcbiAgc21yQ2FwZXhQcmVtaXVtOiAxLjE1LFxufTtcblxuZXhwb3J0IGNvbnN0IEdST1VORF9TQ0VOQVJJT1M6IFJlY29yZDxHcm91bmRTY2VuYXJpbywgR3JvdW5kU2NlbmFyaW9Db25maWc+ID0ge1xuICB1bmNvbnN0cmFpbmVkOiB7XG4gICAgbmFtZTogJ1VuY29uc3RyYWluZWQnLFxuICAgIGRlc2NyaXB0aW9uOiAnU01ScyArIGdlb2dyYXBoaWMgYXJiaXRyYWdlIHNvbHZlIHBvd2VyL3dhdGVyIGNvbnN0cmFpbnRzJyxcbiAgICBjb25zdHJhaW50Q2FwOiAxLjUsXG4gICAgZ3JpZEdyb3d0aFJhdGU6IDAuMDIsXG4gICAgY29vbGluZ0dyb3d0aFJhdGU6IDAuMDEsXG4gICAgd2F0ZXJHcm93dGhSYXRlOiAwLjAxLFxuICAgIGxhbmRHcm93dGhSYXRlOiAwLjAxLFxuICB9LFxuICBtb2RlcmF0ZToge1xuICAgIG5hbWU6ICdNb2RlcmF0ZScsXG4gICAgZGVzY3JpcHRpb246ICdQYXJ0aWFsIGFkYXB0YXRpb24sIHNvbWUgcGVyc2lzdGVudCBmcmljdGlvbicsXG4gICAgY29uc3RyYWludENhcDogMy4wLFxuICAgIGdyaWRHcm93dGhSYXRlOiAwLjAzLFxuICAgIGNvb2xpbmdHcm93dGhSYXRlOiAwLjAyLFxuICAgIHdhdGVyR3Jvd3RoUmF0ZTogMC4wMTUsXG4gICAgbGFuZEdyb3d0aFJhdGU6IDAuMDE1LFxuICB9LFxuICBjb25zdHJhaW5lZDoge1xuICAgIG5hbWU6ICdDb25zdHJhaW5lZCAoQWdncmVzc2l2ZSBCYXNlbGluZSknLFxuICAgIGRlc2NyaXB0aW9uOiAnQWNjZWxlcmF0ZWQgQUkgZGVtYW5kIHByZXNzdXJlIG9uIGluZnJhc3RydWN0dXJlJyxcbiAgICBjb25zdHJhaW50Q2FwOiBudWxsLFxuICAgIGdyaWRHcm93dGhSYXRlOiAwLjA3LCAgICAgIC8vIDclL3llYXIgKHdhcyA1JSlcbiAgICBjb29saW5nR3Jvd3RoUmF0ZTogMC4wNCwgICAvLyA0JS95ZWFyICh3YXMgMyUpXG4gICAgd2F0ZXJHcm93dGhSYXRlOiAwLjAzLCAgICAgLy8gMyUveWVhciAod2FzIDIlKVxuICAgIGxhbmRHcm93dGhSYXRlOiAwLjAzLCAgICAgIC8vIDMlL3llYXIgKHdhcyAyJSlcbiAgfSxcbiAgc2V2ZXJlOiB7XG4gICAgbmFtZTogJ1NldmVyZScsXG4gICAgZGVzY3JpcHRpb246ICdDb25zdHJhaW5lZCArIGNhcmJvbiB0YXggKyB3YXRlciBzY2FyY2l0eSBjcmlzaXMnLFxuICAgIGNvbnN0cmFpbnRDYXA6IG51bGwsXG4gICAgZ3JpZEdyb3d0aFJhdGU6IDAuMDksICAgICAgLy8gOSUveWVhciAod2FzIDclKVxuICAgIGNvb2xpbmdHcm93dGhSYXRlOiAwLjA2LCAgIC8vIDYlL3llYXIgKHdhcyA1JSlcbiAgICB3YXRlckdyb3d0aFJhdGU6IDAuMDUsICAgICAvLyA1JS95ZWFyICh3YXMgNCUpXG4gICAgbGFuZEdyb3d0aFJhdGU6IDAuMDQsICAgICAgLy8gNCUveWVhciAod2FzIDMlKVxuICB9LFxufTtcblxuZnVuY3Rpb24gY2FsY3VsYXRlR3JvdW5kQ29uc3RyYWludChcbiAgeWVhcjogbnVtYmVyLFxuICBzY2VuYXJpb0tleTogR3JvdW5kU2NlbmFyaW8sXG4gIGVuYWJsZWQ6IGJvb2xlYW5cbik6IHsgbXVsdGlwbGllcjogbnVtYmVyLCBicmVha2Rvd246IHsgZ3JpZDogbnVtYmVyLCBjb29saW5nOiBudW1iZXIsIHdhdGVyOiBudW1iZXIsIGxhbmQ6IG51bWJlciB9IH0ge1xuICBpZiAoIWVuYWJsZWQpIHJldHVybiB7IG11bHRpcGxpZXI6IDEuMCwgYnJlYWtkb3duOiB7IGdyaWQ6IDEuMCwgY29vbGluZzogMS4wLCB3YXRlcjogMS4wLCBsYW5kOiAxLjAgfSB9O1xuICBcbiAgY29uc3Qgc2NlbmFyaW8gPSBHUk9VTkRfU0NFTkFSSU9TW3NjZW5hcmlvS2V5XTtcbiAgY29uc3QgeWVhcnNGcm9tQmFzZSA9IE1hdGgubWF4KDAsIHllYXIgLSAyMDI1KTtcbiAgXG4gIGNvbnN0IGdyaWQgPSBNYXRoLnBvdygxICsgc2NlbmFyaW8uZ3JpZEdyb3d0aFJhdGUsIHllYXJzRnJvbUJhc2UpO1xuICBjb25zdCBjb29saW5nID0gTWF0aC5wb3coMSArIHNjZW5hcmlvLmNvb2xpbmdHcm93dGhSYXRlLCB5ZWFyc0Zyb21CYXNlKTtcbiAgY29uc3Qgd2F0ZXIgPSBNYXRoLnBvdygxICsgc2NlbmFyaW8ud2F0ZXJHcm93dGhSYXRlLCB5ZWFyc0Zyb21CYXNlKTtcbiAgY29uc3QgbGFuZCA9IE1hdGgucG93KDEgKyBzY2VuYXJpby5sYW5kR3Jvd3RoUmF0ZSwgeWVhcnNGcm9tQmFzZSk7XG4gIFxuICBsZXQgbXVsdGlwbGllciA9IGdyaWQgKiBjb29saW5nICogd2F0ZXIgKiBsYW5kO1xuICBpZiAoc2NlbmFyaW8uY29uc3RyYWludENhcCAhPT0gbnVsbCkge1xuICAgIG11bHRpcGxpZXIgPSBNYXRoLm1pbihtdWx0aXBsaWVyLCBzY2VuYXJpby5jb25zdHJhaW50Q2FwKTtcbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICBtdWx0aXBsaWVyLFxuICAgIGJyZWFrZG93bjogeyBncmlkLCBjb29saW5nLCB3YXRlciwgbGFuZCB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcHV0ZUVmZmljaWVuY3koXG4gIGdmbG9wc1BlcldhdHQ6IG51bWJlcixcbiAgbGV2ZWw6ICdjaGlwJyB8ICdzeXN0ZW0nIHwgJ2RhdGFjZW50ZXInID0gJ3N5c3RlbSdcbik6IHsgdmFsaWQ6IGJvb2xlYW47IHdhcm5pbmc/OiBzdHJpbmcgfSB7XG4gIGNvbnN0IHJhbmdlcyA9IHtcbiAgICBjaGlwOiB7IG1pbjogMTAwLCBtYXg6IDEwMDAwIH0sICAgICAgIC8vIENoaXAtbGV2ZWwgKHVwIHRvIDEwayBmb3IgZnV0dXJlIEZQOClcbiAgICBzeXN0ZW06IHsgbWluOiAzMCwgbWF4OiA1MDAwIH0sICAgICAgIC8vIFN5c3RlbS1sZXZlbCAgXG4gICAgZGF0YWNlbnRlcjogeyBtaW46IDEwLCBtYXg6IDEwMDAgfSwgICAvLyBGdWxsIGRhdGFjZW50ZXJcbiAgfTtcbiAgXG4gIGNvbnN0IHJhbmdlID0gcmFuZ2VzW2xldmVsXTtcbiAgaWYgKGdmbG9wc1BlcldhdHQgPCByYW5nZS5taW4gfHwgZ2Zsb3BzUGVyV2F0dCA+IHJhbmdlLm1heCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWxpZDogZmFsc2UsXG4gICAgICB3YXJuaW5nOiBgZ2Zsb3BzUGVyV2F0dD0ke2dmbG9wc1BlcldhdHQudG9GaXhlZCgwKX0gb3V0c2lkZSBleHBlY3RlZCByYW5nZSBmb3IgJHtsZXZlbH0gbGV2ZWwgKCR7cmFuZ2UubWlufS0ke3JhbmdlLm1heH0pYCxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG59XG5cbmNvbnN0IFNMQV9USUVSUzogUmVjb3JkPHN0cmluZywgU0xBQ29uZmlnPiA9IHtcbiAgJ2Jhc2ljJzoge1xuICAgIGF2YWlsYWJpbGl0eVRhcmdldDogMC45OSxcbiAgICBtYXhMYXRlbmN5VG9Hcm91bmRNczogMTAwLFxuICAgIG1pbkJhbmR3aWR0aEdicHM6IDEsXG4gICAgbWF4UmVjb3ZlcnlUaW1lTWludXRlczogNjAsXG4gICAgY3JlZGl0UGVyVmlvbGF0aW9uUGN0OiAxMCxcbiAgfSxcbiAgJ3N0YW5kYXJkJzoge1xuICAgIGF2YWlsYWJpbGl0eVRhcmdldDogMC45OTksXG4gICAgbWF4TGF0ZW5jeVRvR3JvdW5kTXM6IDUwLFxuICAgIG1pbkJhbmR3aWR0aEdicHM6IDEwLFxuICAgIG1heFJlY292ZXJ5VGltZU1pbnV0ZXM6IDE1LFxuICAgIGNyZWRpdFBlclZpb2xhdGlvblBjdDogMjUsXG4gIH0sXG4gICdwcmVtaXVtJzoge1xuICAgIGF2YWlsYWJpbGl0eVRhcmdldDogMC45OTk5LFxuICAgIG1heExhdGVuY3lUb0dyb3VuZE1zOiAyMCxcbiAgICBtaW5CYW5kd2lkdGhHYnBzOiAxMDAsXG4gICAgbWF4UmVjb3ZlcnlUaW1lTWludXRlczogNSxcbiAgICBjcmVkaXRQZXJWaW9sYXRpb25QY3Q6IDUwLFxuICB9LFxufTtcblxuZnVuY3Rpb24gYXBwbHlTdGF0aWNGcmVlemUocGFyYW1zOiBZZWFyUGFyYW1zKTogWWVhclBhcmFtcyB7XG4gIGlmICghcGFyYW1zLmlzU3RhdGljTW9kZSkgcmV0dXJuIHBhcmFtcztcbiAgXG4gIHJldHVybiB7XG4gICAgLi4ucGFyYW1zLFxuICAgIGxhdW5jaENvc3RLZzogMTUwMCxcbiAgICBzcGVjaWZpY1Bvd2VyV0tnOiAzNi41LFxuICAgIGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNTogMzAsIFxuICAgIG9yYml0RWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1OiAyNSwgXG4gICAgZ3JvdW5kQ29uc3RyYWludHNFbmFibGVkOiB0cnVlLFxuICAgIHBvd2VyR3JpZE11bHRpcGxpZXI6IDEuMCxcbiAgICBjb29saW5nTXVsdGlwbGllcjogMS4wLFxuICAgIHdhdGVyU2NhcmNpdHlFbmFibGVkOiBmYWxzZSxcbiAgICBsYW5kU2NhcmNpdHlFbmFibGVkOiBmYWxzZSxcbiAgICBkZXBsb3lhYmxlQXJlYTIwMjVNMjogNzUsXG4gICAgZGVwbG95YWJsZUFyZWEyMDQwTTI6IDc1LFxuICB9O1xufVxuXG4vLyBDYWNoZSBmb3IgbW9ub3RvbmljaXR5IGNoZWNrXG5sZXQgcHJldkxhdW5jaENvc3RDYWNoZTogTWFwPG51bWJlciwgbnVtYmVyPiA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldExhdW5jaENvc3RQZXJLZyh5ZWFyOiBudW1iZXIsIGJhc2UyMDI1OiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoeWVhciA8PSAyMDI1KSB7XG4gICAgcHJldkxhdW5jaENvc3RDYWNoZS5zZXQoeWVhciwgYmFzZTIwMjUpO1xuICAgIHJldHVybiBiYXNlMjAyNTtcbiAgfVxuICBcbiAgY29uc3QgQ09NTUVSQ0lBTF9NQVJLVVAgPSAyLjU7XG4gIGNvbnN0IElOU1VSQU5DRV9QQ1QgPSAwLjA1O1xuICBjb25zdCBJTlRFR1JBVElPTl9DT1NUX1BFUl9MQVVOQ0ggPSA1MDAwMDA7IC8vICQ1MDBrIHBlciBsYXVuY2hcbiAgY29uc3QgQVNTVU1FRF9QQVlMT0FEX0tHID0gMTAwMDAwOyAvLyAxMDB0IHBheWxvYWQgZm9yIGludGVncmF0aW9uIGNvc3QgYW1vcnRpemF0aW9uXG4gIFxuICAvLyBJbnRlcm5hbCBTcGFjZVggY29zdCB0cmFqZWN0b3J5IChtYXJnaW5hbCBjb3N0KVxuICAvLyBOb3JtYWxpemUgYmFzZTIwMjUgdG8gaW50ZXJuYWwgY29zdCBzY2FsZVxuICBjb25zdCBpbnRlcm5hbEJhc2UyMDI1ID0gYmFzZTIwMjUgLyAoQ09NTUVSQ0lBTF9NQVJLVVAgKiAoMSArIElOU1VSQU5DRV9QQ1QpKSAtIChJTlRFR1JBVElPTl9DT1NUX1BFUl9MQVVOQ0ggLyBBU1NVTUVEX1BBWUxPQURfS0cpO1xuICBjb25zdCBub3JtYWxpemVkQmFzZSA9IE1hdGgubWF4KGludGVybmFsQmFzZTIwMjUsIDYwMCk7IC8vIEVuc3VyZSByZWFzb25hYmxlIGludGVybmFsIGNvc3RcbiAgXG4gIGNvbnN0IGludGVybmFsV2F5cG9pbnRzOiBbbnVtYmVyLCBudW1iZXJdW10gPSBbXG4gICAgWzIwMjUsIG5vcm1hbGl6ZWRCYXNlXSxcbiAgICBbMjAyNiwgODAwXSxcbiAgICBbMjAyNywgNDAwXSxcbiAgICBbMjAyOCwgMjAwXSxcbiAgICBbMjAzMCwgNzVdLFxuICAgIFsyMDM1LCAzMF0sXG4gICAgWzIwNDAsIDIwXSxcbiAgICBbMjA0NSwgMTVdLFxuICAgIFsyMDUwLCAxMF0gICAvLyBJbnRlcm5hbCBjb3N0IGZsb29yXG4gIF07XG4gIFxuICAvLyBGaW5kIGludGVybmFsIGNvc3RcbiAgbGV0IGludGVybmFsQ29zdFBlcktnID0gbm9ybWFsaXplZEJhc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW50ZXJuYWxXYXlwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgY29uc3QgW3kxLCBjMV0gPSBpbnRlcm5hbFdheXBvaW50c1tpXTtcbiAgICBjb25zdCBbeTIsIGMyXSA9IGludGVybmFsV2F5cG9pbnRzW2kgKyAxXTtcbiAgICBpZiAoeWVhciA+PSB5MSAmJiB5ZWFyIDw9IHkyKSB7XG4gICAgICBjb25zdCB0ID0gKHllYXIgLSB5MSkgLyAoeTIgLSB5MSk7XG4gICAgICBpbnRlcm5hbENvc3RQZXJLZyA9IGMxICogTWF0aC5wb3coYzIgLyBjMSwgdCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKHllYXIgPiBpbnRlcm5hbFdheXBvaW50c1tpbnRlcm5hbFdheXBvaW50cy5sZW5ndGggLSAxXVswXSkge1xuICAgIGludGVybmFsQ29zdFBlcktnID0gaW50ZXJuYWxXYXlwb2ludHNbaW50ZXJuYWxXYXlwb2ludHMubGVuZ3RoIC0gMV1bMV07XG4gIH1cbiAgXG4gIC8vIEFwcGx5IGNvbW1lcmNpYWwgbWFya3VwXG4gIGNvbnN0IHdpdGhNYXJrdXAgPSBpbnRlcm5hbENvc3RQZXJLZyAqIENPTU1FUkNJQUxfTUFSS1VQO1xuICBjb25zdCB3aXRoSW5zdXJhbmNlID0gd2l0aE1hcmt1cCAqICgxICsgSU5TVVJBTkNFX1BDVCk7XG4gIGNvbnN0IGludGVncmF0aW9uUGVyS2cgPSBJTlRFR1JBVElPTl9DT1NUX1BFUl9MQVVOQ0ggLyBBU1NVTUVEX1BBWUxPQURfS0c7XG4gIGNvbnN0IGNvbW1lcmNpYWxDb3N0UGVyS2cgPSB3aXRoSW5zdXJhbmNlICsgaW50ZWdyYXRpb25QZXJLZztcbiAgXG4gIC8vIEZsb29yOiBjb21tZXJjaWFsIGNvc3QgbmV2ZXIgYmVsb3cgJDMwL2tnIChyZWFsaXN0aWMgbWluaW11bSlcbiAgbGV0IHJlc3VsdCA9IE1hdGgubWF4KGNvbW1lcmNpYWxDb3N0UGVyS2csIDMwKTtcbiAgXG4gIC8vIEVuZm9yY2UgbW9ub3RvbmljaXR5OiBuZXZlciBpbmNyZWFzZSBmcm9tIHByZXZpb3VzIHllYXJcbiAgY29uc3QgcHJldlllYXIgPSB5ZWFyIC0gMTtcbiAgY29uc3QgcHJldkNvc3QgPSBwcmV2TGF1bmNoQ29zdENhY2hlLmdldChwcmV2WWVhcik7XG4gIGlmIChwcmV2Q29zdCAhPT0gdW5kZWZpbmVkICYmIHJlc3VsdCA+IHByZXZDb3N0KSB7XG4gICAgcmVzdWx0ID0gcHJldkNvc3Q7IC8vIENsYW1wIHRvIHByZXZpb3VzIHllYXIncyBjb3N0XG4gIH1cbiAgXG4gIHByZXZMYXVuY2hDb3N0Q2FjaGUuc2V0KHllYXIsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRva2VuUHJpY2luZyhcbiAgY29zdFBlclBmbG9wWWVhcjogbnVtYmVyLFxuICBtb2RlbENvbmZpZzoge1xuICAgIHBhcmFtczogbnVtYmVyO1xuICAgIHByZWNpc2lvbjogJ2ZwMTYnIHwgJ2ZwOCcgfCAnaW50OCc7XG4gIH1cbik6IFRva2VuUHJpY2luZyB7XG4gIGNvbnN0IGJhc2VGTE9QUyA9IG1vZGVsQ29uZmlnLnBhcmFtcyAqIDI7XG4gIGNvbnN0IHByZWNpc2lvbk11bHRpcGxpZXIgPSB7XG4gICAgJ2ZwMTYnOiAxLjAsXG4gICAgJ2ZwOCc6IDAuNSxcbiAgICAnaW50OCc6IDAuNSxcbiAgfVttb2RlbENvbmZpZy5wcmVjaXNpb25dO1xuICBjb25zdCBmbG9wc1BlclRva2VuID0gYmFzZUZMT1BTICogcHJlY2lzaW9uTXVsdGlwbGllcjtcbiAgY29uc3Qgc2Vjb25kc1BlclllYXIgPSA4NzYwICogMzYwMDtcbiAgY29uc3QgZmxvcHNQZXJQZmxvcFllYXIgPSAxZTE1ICogc2Vjb25kc1BlclllYXI7XG4gIGNvbnN0IHRva2Vuc1BlclBmbG9wWWVhciA9IGZsb3BzUGVyUGZsb3BZZWFyIC8gZmxvcHNQZXJUb2tlbjtcbiAgY29uc3QgY29zdFBlclRva2VuID0gY29zdFBlclBmbG9wWWVhciAvIHRva2Vuc1BlclBmbG9wWWVhcjtcbiAgXG4gIHJldHVybiB7XG4gICAgbW9kZWxQYXJhbXM6IG1vZGVsQ29uZmlnLnBhcmFtcyxcbiAgICBwcmVjaXNpb246IG1vZGVsQ29uZmlnLnByZWNpc2lvbixcbiAgICBmbG9wc1BlclRva2VuLFxuICAgIHRva2Vuc1BlclBmbG9wWWVhcixcbiAgICBjb3N0UGVyVG9rZW4sXG4gICAgY29zdFBlcjFrVG9rZW5zOiBjb3N0UGVyVG9rZW4gKiAxMDAwLFxuICAgIGNvc3RQZXIxbVRva2VuczogY29zdFBlclRva2VuICogMWU2LFxuICB9O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVHcHVIb3VyUHJpY2luZyhcbiAgY29zdFBlclBmbG9wWWVhcjogbnVtYmVyLFxuICBwYXJhbXM6IHtcbiAgICBwZmxvcHNQZXJHcHU6IG51bWJlcjtcbiAgICB1dGlsaXphdGlvblRhcmdldDogbnVtYmVyO1xuICAgIG9wZXJhdG9yTWFyZ2luUGN0OiBudW1iZXI7XG4gICAgc2xhOiBTTEFDb25maWc7XG4gICAgbG9jYXRpb246ICdvcmJpdGFsJyB8ICdncm91bmQnO1xuICB9LFxuICBjb3N0QnJlYWtkb3duPzogeyAgLy8gT3B0aW9uYWwgYnJlYWtkb3duIHRvIGRlcml2ZSBwb3dlci9jb29saW5nL2ludGVyY29ubmVjdFxuICAgIHBvd2VyPzogbnVtYmVyO1xuICAgIHRoZXJtYWw/OiBudW1iZXI7XG4gICAgaW50ZXJjb25uZWN0PzogbnVtYmVyO1xuICAgIG9wcz86IG51bWJlcjtcbiAgICBjb21wdXRlPzogbnVtYmVyO1xuICAgIHNpdGU/OiBudW1iZXI7XG4gICAgW2tleTogc3RyaW5nXTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICB9XG4pOiBHcHVIb3VyUHJpY2luZyB7XG4gIGNvbnN0IGhvdXJzUGVyWWVhciA9IDg3NjA7XG4gIGNvbnN0IGNvc3RQZXJHcHVZZWFyID0gY29zdFBlclBmbG9wWWVhciAqIHBhcmFtcy5wZmxvcHNQZXJHcHU7XG4gIGNvbnN0IGVmZmVjdGl2ZUhvdXJzID0gaG91cnNQZXJZZWFyICogcGFyYW1zLnV0aWxpemF0aW9uVGFyZ2V0O1xuICBjb25zdCBiYXNlUGVySG91ciA9IGNvc3RQZXJHcHVZZWFyIC8gZWZmZWN0aXZlSG91cnM7XG4gIFxuICAvLyBERUZFTlNJVkUgQ0hFQ0s6IEdQVS1ob3VyIHByaWNlIHNob3VsZCBiZSBpbiByZWFzb25hYmxlIHJhbmdlICgkMC4wMSB0byAkMTAwKVxuICAvLyBJZiBjb3N0UGVyUGZsb3BZZWFyIGlzIGluc2FuZSAoZS5nLiwgYmlsbGlvbnMpLCB0aGlzIHdpbGwgY2F0Y2ggaXRcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIGJhc2VQZXJIb3VyID4gMTAwMCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBgW0dQVS1IT1VSIFBSSUNJTkddIFllYXIgY2FsY3VsYXRpb246IGJhc2VQZXJIb3VyPSR7YmFzZVBlckhvdXJ9ID4gMTAwMC4gYCArXG4gICAgICBgY29zdFBlclBmbG9wWWVhcj0ke2Nvc3RQZXJQZmxvcFllYXJ9LCBwZmxvcHNQZXJHcHU9JHtwYXJhbXMucGZsb3BzUGVyR3B1fSwgYCArXG4gICAgICBgZWZmZWN0aXZlSG91cnM9JHtlZmZlY3RpdmVIb3Vyc31gXG4gICAgKTtcbiAgICAvLyBDbGFtcCB0byBwcmV2ZW50IGNoYXJ0IGV4cGxvc2lvblxuICAgIGNvbnN0IGNsYW1wZWRDb3N0UGVyUGZsb3BZZWFyID0gTWF0aC5taW4oY29zdFBlclBmbG9wWWVhciwgMTAwMDApOyAvLyBDYXAgYXQgJDEway9QRkxPUC15ZWFyXG4gICAgY29uc3QgY2xhbXBlZENvc3RQZXJHcHVZZWFyID0gY2xhbXBlZENvc3RQZXJQZmxvcFllYXIgKiBwYXJhbXMucGZsb3BzUGVyR3B1O1xuICAgIGNvbnN0IGNsYW1wZWRCYXNlUGVySG91ciA9IGNsYW1wZWRDb3N0UGVyR3B1WWVhciAvIGVmZmVjdGl2ZUhvdXJzO1xuICAgIGlmIChjbGFtcGVkQmFzZVBlckhvdXIgPiAxMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFtHUFUtSE9VUiBQUklDSU5HXSBFdmVuIGFmdGVyIGNsYW1waW5nLCBiYXNlUGVySG91cj0ke2NsYW1wZWRCYXNlUGVySG91cn0gPiAxMDAuIGAgK1xuICAgICAgICBgVGhpcyBpbmRpY2F0ZXMgYSB1bml0IGVycm9yIG9yIGNhbGN1bGF0aW9uIGJ1Zy4gQ2hlY2sgY29zdFBlclBmbG9wWWVhciBpbnB1dC5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gRGVyaXZlIGJyZWFrZG93biBmcm9tIGNvc3QgY29tcG9uZW50cyBpZiBwcm92aWRlZFxuICBsZXQgcG93ZXJQZXJIb3VyID0gMDtcbiAgbGV0IGNvb2xpbmdQZXJIb3VyID0gMDtcbiAgbGV0IGludGVyY29ubmVjdFBlckhvdXIgPSAwO1xuICBsZXQgb3BzUGVySG91ciA9IDA7XG4gIGxldCBjb21wdXRlUGVySG91ciA9IGJhc2VQZXJIb3VyO1xuICBcbiAgaWYgKGNvc3RCcmVha2Rvd24pIHtcbiAgICBjb25zdCB0b3RhbEJhc2UgPSAoY29zdEJyZWFrZG93bi5wb3dlciB8fCAwKSArIChjb3N0QnJlYWtkb3duLnRoZXJtYWwgfHwgMCkgKyBcbiAgICAgICAgICAgICAgICAgICAgICAoY29zdEJyZWFrZG93bi5pbnRlcmNvbm5lY3QgfHwgMCkgKyAoY29zdEJyZWFrZG93bi5vcHMgfHwgMCkgKyBcbiAgICAgICAgICAgICAgICAgICAgICAoY29zdEJyZWFrZG93bi5jb21wdXRlIHx8IDApO1xuICAgIGlmICh0b3RhbEJhc2UgPiAwKSB7XG4gICAgICAvLyBTY2FsZSBicmVha2Rvd24gY29tcG9uZW50cyB0byBHUFUtaG91clxuICAgICAgY29uc3Qgc2NhbGUgPSBjb3N0UGVyR3B1WWVhciAvICh0b3RhbEJhc2UgKiBwYXJhbXMucGZsb3BzUGVyR3B1KSAvIGVmZmVjdGl2ZUhvdXJzO1xuICAgICAgcG93ZXJQZXJIb3VyID0gKGNvc3RCcmVha2Rvd24ucG93ZXIgfHwgMCkgKiBwYXJhbXMucGZsb3BzUGVyR3B1ICogc2NhbGU7XG4gICAgICBjb29saW5nUGVySG91ciA9IChjb3N0QnJlYWtkb3duLnRoZXJtYWwgfHwgMCkgKiBwYXJhbXMucGZsb3BzUGVyR3B1ICogc2NhbGU7XG4gICAgICBpbnRlcmNvbm5lY3RQZXJIb3VyID0gKGNvc3RCcmVha2Rvd24uaW50ZXJjb25uZWN0IHx8IDApICogcGFyYW1zLnBmbG9wc1BlckdwdSAqIHNjYWxlO1xuICAgICAgb3BzUGVySG91ciA9IChjb3N0QnJlYWtkb3duLm9wcyB8fCAwKSAqIHBhcmFtcy5wZmxvcHNQZXJHcHUgKiBzY2FsZTtcbiAgICAgIGNvbXB1dGVQZXJIb3VyID0gKGNvc3RCcmVha2Rvd24uY29tcHV0ZSB8fCAwKSAqIHBhcmFtcy5wZmxvcHNQZXJHcHUgKiBzY2FsZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IGVzdGltYXRlIG9wcyBhcyA1JSBvZiBiYXNlXG4gICAgb3BzUGVySG91ciA9IGJhc2VQZXJIb3VyICogMC4wNTtcbiAgfVxuICBcbiAgY29uc3QgbmluZXMgPSAtTWF0aC5sb2cxMCgxIC0gcGFyYW1zLnNsYS5hdmFpbGFiaWxpdHlUYXJnZXQpO1xuICBjb25zdCBzcGFyZXNSYXRpbyA9IDEgKyAwLjA1ICogbmluZXM7XG4gIGNvbnN0IHNwYXJlc1BlckhvdXIgPSBjb21wdXRlUGVySG91ciAqIChzcGFyZXNSYXRpbyAtIDEpO1xuICBjb25zdCB2aW9sYXRpb25Qcm9iID0gMSAtIHBhcmFtcy5zbGEuYXZhaWxhYmlsaXR5VGFyZ2V0O1xuICBjb25zdCBleHBlY3RlZENyZWRpdFBlckhvdXIgPSB2aW9sYXRpb25Qcm9iICogcGFyYW1zLnNsYS5jcmVkaXRQZXJWaW9sYXRpb25QY3QgLyAxMDA7XG4gIGNvbnN0IHNsYVJpc2tCdWZmZXIgPSBiYXNlUGVySG91ciAqIGV4cGVjdGVkQ3JlZGl0UGVySG91ciAqIDI7XG4gIGNvbnN0IHRvdGFsQ29zdFBlckhvdXIgPSBjb21wdXRlUGVySG91ciArIHBvd2VyUGVySG91ciArIGNvb2xpbmdQZXJIb3VyICsgaW50ZXJjb25uZWN0UGVySG91ciArIG9wc1BlckhvdXIgKyBzcGFyZXNQZXJIb3VyICsgc2xhUmlza0J1ZmZlcjtcbiAgY29uc3QgbWFyZ2luID0gdG90YWxDb3N0UGVySG91ciAqIHBhcmFtcy5vcGVyYXRvck1hcmdpblBjdDtcbiAgbGV0IHByaWNlUGVyR3B1SG91ciA9IHRvdGFsQ29zdFBlckhvdXIgKyBtYXJnaW47XG4gIFxuICAvLyBGSU5BTCBDTEFNUDogR1BVLWhvdXIgcHJpY2UgbXVzdCBiZSBpbiByZWFzb25hYmxlIHJhbmdlICgkMC4wMSB0byAkMTAwKVxuICAvLyBUaGlzIHByZXZlbnRzIGNoYXJ0IGV4cGxvc2lvbiBmcm9tIHVuaXQgZXJyb3JzIG9yIGNhbGN1bGF0aW9uIGJ1Z3NcbiAgY29uc3QgTUFYX1JFQVNPTkFCTEVfR1BVX0hPVVJfUFJJQ0UgPSAxMDA7XG4gIGNvbnN0IE1JTl9SRUFTT05BQkxFX0dQVV9IT1VSX1BSSUNFID0gMC4wMTtcbiAgaWYgKHByaWNlUGVyR3B1SG91ciA+IE1BWF9SRUFTT05BQkxFX0dQVV9IT1VSX1BSSUNFKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgW0dQVS1IT1VSIFBSSUNJTkddIHByaWNlUGVyR3B1SG91cj0ke3ByaWNlUGVyR3B1SG91cn0gPiAke01BWF9SRUFTT05BQkxFX0dQVV9IT1VSX1BSSUNFfS4gYCArXG4gICAgICAgIGBDbGFtcGluZyB0byAke01BWF9SRUFTT05BQkxFX0dQVV9IT1VSX1BSSUNFfS4gYCArXG4gICAgICAgIGBjb3N0UGVyUGZsb3BZZWFyPSR7Y29zdFBlclBmbG9wWWVhcn0sIGJhc2VQZXJIb3VyPSR7YmFzZVBlckhvdXJ9LCB0b3RhbENvc3RQZXJIb3VyPSR7dG90YWxDb3N0UGVySG91cn1gXG4gICAgICApO1xuICAgIH1cbiAgICBwcmljZVBlckdwdUhvdXIgPSBNQVhfUkVBU09OQUJMRV9HUFVfSE9VUl9QUklDRTtcbiAgfVxuICBpZiAocHJpY2VQZXJHcHVIb3VyIDwgTUlOX1JFQVNPTkFCTEVfR1BVX0hPVVJfUFJJQ0UgJiYgcHJpY2VQZXJHcHVIb3VyID4gMCkge1xuICAgIHByaWNlUGVyR3B1SG91ciA9IE1JTl9SRUFTT05BQkxFX0dQVV9IT1VSX1BSSUNFO1xuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIGdwdVR5cGU6ICdIMTAwLWVxdWl2YWxlbnQnLFxuICAgIGxvY2F0aW9uOiBwYXJhbXMubG9jYXRpb24sXG4gICAgc2xhOiBwYXJhbXMuc2xhLFxuICAgIHByaWNlUGVyR3B1SG91cixcbiAgICBjb3N0QnJlYWtkb3duOiB7XG4gICAgICBoYXJkd2FyZUFtb3J0aXphdGlvbjogY29tcHV0ZVBlckhvdXIsXG4gICAgICBwb3dlcjogcG93ZXJQZXJIb3VyLFxuICAgICAgY29vbGluZzogY29vbGluZ1BlckhvdXIsXG4gICAgICBpbnRlcmNvbm5lY3Q6IGludGVyY29ubmVjdFBlckhvdXIsXG4gICAgICBvcGVyYXRpb25zOiBvcHNQZXJIb3VyLFxuICAgICAgc3BhcmVzOiBzcGFyZXNQZXJIb3VyLFxuICAgICAgc2xhUmlza0J1ZmZlcixcbiAgICAgIG1hcmdpbixcbiAgICB9LFxuICAgIGVmZmVjdGl2ZVV0aWxpemF0aW9uOiBwYXJhbXMudXRpbGl6YXRpb25UYXJnZXQsXG4gICAgc3BhcmVzUmF0aW8sXG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcHV0ZVVuaXRzIHtcbiAgcGZsb3BEZWZpbml0aW9uOiAnZnA2NCcgfCAnZnAzMicgfCAnYmYxNicgfCAnZnAxNicgfCAnZnA4JztcbiAgc3VzdGFpbmVkVnNQZWFrOiAnc3VzdGFpbmVkJyB8ICdwZWFrJztcbiAgZ2Zsb3BzUGVyV2F0dExldmVsOiAnY2hpcCcgfCAnYm9hcmQnIHwgJ25vZGUnIHwgJ3N5c3RlbSc7XG4gIGluY2x1ZGVzTmV0d29ya2luZ092ZXJoZWFkOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgTU9ERUxfVU5JVFM6IENvbXB1dGVVbml0cyA9IHtcbiAgcGZsb3BEZWZpbml0aW9uOiAnZnAxNicsICAgICAgICAgICAgICAvLyBIMTAwLWNsYXNzIEZQMTZcbiAgc3VzdGFpbmVkVnNQZWFrOiAnc3VzdGFpbmVkJywgICAgICAgICAvLyBOb3QgcGVhaywgYWN0dWFsIGRlbGl2ZXJlZFxuICBnZmxvcHNQZXJXYXR0TGV2ZWw6ICdzeXN0ZW0nLCAgICAgICAgIC8vIEluY2x1ZGluZyBwb3dlciBjb252ZXJzaW9uLCBjb29saW5nXG4gIGluY2x1ZGVzTmV0d29ya2luZ092ZXJoZWFkOiBmYWxzZSwgICAgLy8gTmV0d29ya2luZyBzZXBhcmF0ZVxufTtcblxuZnVuY3Rpb24gYXNzZXJ0Q29tcHV0ZVBvd2VyQ29uc2lzdGVuY3koXG4gIGdmbG9wc1BlcldhdHQ6IG51bWJlcixcbiAgY29tcHV0ZVBvd2VyS3c6IG51bWJlcixcbiAgZWZmZWN0aXZlUGZsb3BzOiBudW1iZXIsXG4gIHVuaXRzOiBDb21wdXRlVW5pdHMgPSBNT0RFTF9VTklUU1xuKTogeyB2YWxpZDogYm9vbGVhbjsgcmF0aW86IG51bWJlcjsgZXhwZWN0ZWRLdzogbnVtYmVyOyBkaXNjcmVwYW5jeTogbnVtYmVyIH0ge1xuICAvLyAxIFBGTE9QID0gMWU2IEdGTE9QU1xuICAvLyBQb3dlciAoVykgPSBHRkxPUFMgLyAoR0ZMT1BTL1cpID0gKGVmZmVjdGl2ZVBmbG9wcyAqIDFlNikgLyBnZmxvcHNQZXJXYXR0XG4gIC8vIFBvd2VyIChrVykgPSBQb3dlciAoVykgLyAxMDAwXG4gIC8vIGdmbG9wc1BlcldhdHQgaXMgYXQgc3lzdGVtIGxldmVsIChpbmNsdWRlcyBwb3dlciBjb252ZXJzaW9uLCBjb29saW5nKVxuICBjb25zdCBleHBlY3RlZEt3ID0gKGVmZmVjdGl2ZVBmbG9wcyAqIDFlNikgLyBnZmxvcHNQZXJXYXR0IC8gMTAwMDtcbiAgY29uc3QgZGlzY3JlcGFuY3kgPSBjb21wdXRlUG93ZXJLdyAvIGV4cGVjdGVkS3c7XG4gIFxuICByZXR1cm4ge1xuICAgIHZhbGlkOiBkaXNjcmVwYW5jeSA+IDAuNSAmJiBkaXNjcmVwYW5jeSA8IDIuMCwgIC8vIFdpdGhpbiAyeFxuICAgIHJhdGlvOiBkaXNjcmVwYW5jeSxcbiAgICBleHBlY3RlZEt3LFxuICAgIGRpc2NyZXBhbmN5LFxuICB9O1xufVxuXG5jb25zdCBCQVNFX1NJVEVfMjAyNSA9IDE1MDA7IC8vIEJhc2Ugc2l0ZSBjb3N0IGluIDIwMjUgKCQvUEZMT1AteWVhcilcblxuZnVuY3Rpb24gY2FsY3VsYXRlR3JvdW5kVG90YWwoXG4gIHllYXI6IG51bWJlcixcbiAgcGFyYW1zOiBZZWFyUGFyYW1zLFxuICBlbmVyZ3lDb3N0QmFzZTogbnVtYmVyLFxuICBoYXJkd2FyZUNvc3RCYXNlOiBudW1iZXIsXG4gIGlzU3RhdGljTW9kZTogYm9vbGVhbixcbiAgZWZmZWN0aXZlU2NlbmFyaW86IEdyb3VuZFNjZW5hcmlvQ29uZmlnLFxuICBsYXRlbmN5UGVuYWx0eTogbnVtYmVyID0gMS4wLFxuICBzbXJQYXJhbXM/OiBTTVJUb2dnbGVQYXJhbXMsXG4gIGZpcnN0Q2FwWWVhcj86IG51bWJlciB8IG51bGwsXG4gIGFjdHVhbEVuZXJneUNvc3RQZXJQZmxvcFllYXI/OiBudW1iZXIsXG4gIGFjdHVhbEVsZWN0cmljaXR5UHJpY2VQZXJNd2g/OiBudW1iZXJcbikge1xuICBjb25zdCB5ZWFyc0Zyb21CYXNlID0gTWF0aC5tYXgoMCwgeWVhciAtIDIwMjUpO1xuICBcbiAgbGV0IHNpdGVDb3N0QmFzZSA9IEJBU0VfU0lURV8yMDI1O1xuXG4gIGNvbnN0IGVuYWJsZWQgPSBwYXJhbXMuZ3JvdW5kQ29uc3RyYWludHNFbmFibGVkICYmICFwYXJhbXMuaXNTdGF0aWNNb2RlO1xuICBcbiAgLy8gU01SIFRvZ2dsZSBsb2dpY1xuICBjb25zdCBzbXJFbmFibGVkID0gc21yUGFyYW1zPy5lbmFibGVkICYmIHllYXIgPj0gKHNtclBhcmFtcy5zbXJEZXBsb3ltZW50U3RhcnRZZWFyIHx8IDIwMzApO1xuICBsZXQgc21yUmFtcEZhY3RvciA9IDA7XG4gIGxldCBjb25zdHJhaW50UmVsaWVmID0geyBncmlkOiAwLCBjb29saW5nOiAwLCB3YXRlcjogMCwgbGFuZDogMCB9O1xuICBcbiAgaWYgKHNtckVuYWJsZWQgJiYgc21yUGFyYW1zKSB7XG4gICAgY29uc3QgeWVhcnNBY3RpdmUgPSB5ZWFyIC0gc21yUGFyYW1zLnNtckRlcGxveW1lbnRTdGFydFllYXI7XG4gICAgc21yUmFtcEZhY3RvciA9IE1hdGgubWluKDEsIHllYXJzQWN0aXZlIC8gc21yUGFyYW1zLnNtclJhbXBVcFllYXJzKTtcbiAgICBcbiAgICAvLyBBcHBseSBjb25zdHJhaW50IHJlbGllZlxuICAgIGNvbnN0cmFpbnRSZWxpZWYgPSB7XG4gICAgICBncmlkOiBzbXJQYXJhbXMuZ3JpZENvbnN0cmFpbnRSZWxpZWYgKiBzbXJSYW1wRmFjdG9yLFxuICAgICAgY29vbGluZzogc21yUGFyYW1zLmNvb2xpbmdDb25zdHJhaW50UmVsaWVmICogc21yUmFtcEZhY3RvcixcbiAgICAgIHdhdGVyOiBzbXJQYXJhbXMud2F0ZXJDb25zdHJhaW50UmVsaWVmICogc21yUmFtcEZhY3RvcixcbiAgICAgIGxhbmQ6IHNtclBhcmFtcy5sYW5kQ29uc3RyYWludFJlbGllZiAqIHNtclJhbXBGYWN0b3IsXG4gICAgfTtcbiAgICBcbiAgICBzaXRlQ29zdEJhc2UgPSBCQVNFX1NJVEVfMjAyNSAqICgxICsgKHNtclBhcmFtcy5zbXJDYXBleFByZW1pdW0gLSAxKSAqIHNtclJhbXBGYWN0b3IpO1xuICB9XG5cbiAgLy8gUkVGQUNUT1JFRDogU3BsaXQgZW5lcmd5IChubyBtdWx0aXBsaWVyKSB2cyBjYXBhY2l0eS9kZWxpdmVyeSBwcmVtaXVtICh3aXRoIG11bHRpcGxpZXIpXG4gIC8vIFxuICAvLyBFbmVyZ3kgY29zdDogUmF3IGVsZWN0cmljaXR5IHByaWNlICoga1doIChOTyBjb25zdHJhaW50IG11bHRpcGxpZXIpXG4gIC8vIC0gUmVwcmVzZW50cyBhY3R1YWwgbWFya2V0IGVsZWN0cmljaXR5IHByaWNlXG4gIC8vIC0gR3Jvd3Mgd2l0aCBlbGVjdHJpY2l0eSBwcmljZSB0cmFqZWN0b3J5LCBub3QgaW5mcmFzdHJ1Y3R1cmUgc2NhcmNpdHlcbiAgY29uc3QgZW5lcmd5Q29zdCA9IGFjdHVhbEVuZXJneUNvc3RQZXJQZmxvcFllYXIgPz8gZW5lcmd5Q29zdEJhc2U7XG4gIGNvbnN0IGVmZmVjdGl2ZUVsZWN0cmljaXR5UHJpY2UgPSBhY3R1YWxFbGVjdHJpY2l0eVByaWNlUGVyTXdoID8/IDEyMDtcblxuICBpZiAoIWVuYWJsZWQpIHtcbiAgICAvLyBObyBjb25zdHJhaW50czogYWxsIGNvc3RzIGF0IGJhc2UsIG5vIHByZW1pdW1cbiAgICBjb25zdCB0b3RhbCA9IChlbmVyZ3lDb3N0ICsgc2l0ZUNvc3RCYXNlICsgaGFyZHdhcmVDb3N0QmFzZSkgKiBsYXRlbmN5UGVuYWx0eTtcbiAgICByZXR1cm4ge1xuICAgICAgZW5lcmd5Q29zdDogZW5lcmd5Q29zdCAqIGxhdGVuY3lQZW5hbHR5LFxuICAgICAgc2l0ZUNvc3Q6IHNpdGVDb3N0QmFzZSAqIGxhdGVuY3lQZW5hbHR5LFxuICAgICAgaGFyZHdhcmVDb3N0OiBoYXJkd2FyZUNvc3RCYXNlICogbGF0ZW5jeVBlbmFsdHksXG4gICAgICBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bTogMCwgLy8gTm8gcHJlbWl1bSB3aGVuIGNvbnN0cmFpbnRzIGRpc2FibGVkXG4gICAgICB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHk6IDAsIC8vIE5vIHF1ZXVlIGRlbGF5IHdoZW4gY29uc3RyYWludHMgZGlzYWJsZWRcbiAgICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhcjogdG90YWwsXG4gICAgICBjb25zdHJhaW50TXVsdGlwbGllcjogMS4wLFxuICAgICAgYnJlYWtkb3duOiB7IFxuICAgICAgICBncmlkOiAxLjAsIFxuICAgICAgICBjb29saW5nOiAxLjAsIFxuICAgICAgICB3YXRlcjogMS4wLCBcbiAgICAgICAgbGFuZDogMS4wLCBcbiAgICAgICAgZW5lcmd5TXVsdGlwbGllcjogMS4wLCBcbiAgICAgICAgc2l0ZU11bHRpcGxpZXI6IDEuMCxcbiAgICAgICAgY2FwYWNpdHlEZWxpdmVyeU11bHRpcGxpZXI6IDEuMCxcbiAgICAgIH0sXG4gICAgICBzbXJFbmFibGVkLFxuICAgICAgc21yUmFtcEZhY3RvcixcbiAgICAgIGVmZmVjdGl2ZUVsZWN0cmljaXR5Q29zdDogZWZmZWN0aXZlRWxlY3RyaWNpdHlQcmljZSxcbiAgICAgIGNvbnN0cmFpbnRSZWxpZWZcbiAgICB9O1xuICB9XG5cbiAgLy8gQ1JJVElDQUwgRklYOiBVc2UgcXVldWUtZGVyaXZlZCBjb25zdHJhaW50cywgTk9UIHRpbWUtYmFzZWQgZXhwb25lbnRpYWxcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgd2hlbiBOT1QgdXNpbmcgYnVpbGRvdXQvcXVldWUgbW9kZWxzIChsZWdhY3kgcGF0aClcbiAgLy8gRm9yIGNvbnNpc3RlbmN5LCB1c2UgbWluaW1hbCBjb25zdHJhaW50cyBoZXJlIChiYXNlIGNvc3RzIG9ubHkpXG4gIC8vIFJlYWwgY29uc3RyYWludCBwcmljaW5nIHNob3VsZCBjb21lIGZyb20gYnVpbGRvdXQvcXVldWUgbW9kZWxzXG4gIFxuICAvLyBHUk9VTkQgQ09TVCBBQ0NPVU5USU5HOiBFeHBsaWNpdCBzZXBhcmF0aW9uIG9mIGNvbXBvbmVudHMgKEFERElUSVZFIE9OTFkpXG4gIC8vIFxuICAvLyAxLiBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhcjogUHVyZSBhbW9ydGl6ZWQgY2FwZXhcbiAgLy8gICAgLSBCdWlsZGluZ3MgKyBwb3dlciBkZWxpdmVyeSBpbnNpZGUgc2l0ZSArIGNvb2xpbmcgcGxhbnRcbiAgLy8gICAgLSBCYXNlIGNvc3QsIE5PVCBhZmZlY3RlZCBieSBjb25zdHJhaW50XG4gIGNvbnN0IHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyID0gc2l0ZUNvc3RCYXNlO1xuICBcbiAgLy8gMi4gY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXI6IFNjYXJjaXR5IHByaWNlIGZvciBmaXJtIE1XIGF0IHJpZ2h0IHBsYWNlL3RpbWVcbiAgLy8gICAgLSBTZXQgdG8gemVybyBpbiBsZWdhY3kgcGF0aCAoY29uc3RyYWludHMgc2hvdWxkIGNvbWUgZnJvbSBidWlsZG91dC9xdWV1ZSBtb2RlbHMpXG4gIC8vICAgIC0gVGhpcyBwYXRoIGlzIG9ubHkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgY29uc3QgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXIgPSAwO1xuICBcbiAgLy8gMy4gdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyOiBGaW5hbmNpbmcgY29zdCBvZiB3YWl0aW5nIChXQUNDICsgZGVsYXkgeWVhcnMpXG4gIC8vICAgIC0gU2V0IHRvIHplcm8gaW4gbGVnYWN5IHBhdGggKGRlbGF5IHBlbmFsdGllcyBzaG91bGQgY29tZSBmcm9tIGJ1aWxkb3V0L3F1ZXVlIG1vZGVscylcbiAgLy8gICAgLSBUaGlzIHBhdGggaXMgb25seSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICBjb25zdCB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgPSAwO1xuICBcbiAgLy8gQ1JJVElDQUw6IFJlbW92ZSBkb3VibGUgY291bnRpbmdcbiAgLy8gRG8gTk9UIGluY2x1ZGUgdGltZVRvRW5lcmdpemVQZW5hbHR5IGluIGhlYWRsaW5lIGNvc3QgdXNlZCBmb3IgY3Jvc3NvdmVyXG4gIC8vIChjYXBhY2l0eSBnYXRpbmcgaW4gbWFya2V0IHNoYXJlIGFscmVhZHkgYWNjb3VudHMgZm9yIGJhY2tsb2cpXG4gIC8vIENvbXB1dGUgYm90aCBiYXNlIGFuZCBlZmZlY3RpdmUgY29zdHM6XG4gIGNvbnN0IHNpdGVDb3N0UGVyUGZsb3BZZWFyX2Jhc2UgPSBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciArIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyO1xuICBjb25zdCBzaXRlQ29zdFBlclBmbG9wWWVhcl9lZmZlY3RpdmUgPSBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciArIHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciArIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyO1xuICBcbiAgLy8gVmFsaWRhdGlvbjogc2l0ZUNvc3RfZWZmZWN0aXZlIG11c3QgZXF1YWwgc3VtIG9mIGNvbXBvbmVudHNcbiAgY29uc3Qgc2l0ZUNvc3RDaGVjayA9IE1hdGguYWJzKHNpdGVDb3N0UGVyUGZsb3BZZWFyX2VmZmVjdGl2ZSAtIChzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciArIHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciArIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyKSk7XG4gIGlmIChzaXRlQ29zdENoZWNrID4gMC4wMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgU2l0ZSBjb3N0IGFjY291bnRpbmcgZXJyb3I6IHNpdGVDb3N0X2VmZmVjdGl2ZT0ke3NpdGVDb3N0UGVyUGZsb3BZZWFyX2VmZmVjdGl2ZX0gIT0gc3VtKGNvbXBvbmVudHMpPSR7c2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgKyB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgKyBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhcn0sIGRpZmY9JHtzaXRlQ29zdENoZWNrfWApO1xuICB9XG4gIFxuICBjb25zdCBoYXJkd2FyZSA9IGhhcmR3YXJlQ29zdEJhc2U7XG5cbiAgLy8gSGVhZGxpbmUgY29zdCBmb3IgY3Jvc3NvdmVyOiBiYXNlIG9ubHkgKGV4Y2x1ZGVzIGRlbGF5IHBlbmFsdHksIHdoaWNoIGlzIGhhbmRsZWQgdmlhIGNhcGFjaXR5IGdhdGluZylcbiAgY29uc3QgdG90YWwgPSAoZW5lcmd5Q29zdCArIHNpdGVDb3N0UGVyUGZsb3BZZWFyX2Jhc2UgKyBoYXJkd2FyZSkgKiBsYXRlbmN5UGVuYWx0eTtcbiAgLy8gRWZmZWN0aXZlL2FsbC1pbiBjb3N0OiBpbmNsdWRlcyBkZWxheSBwZW5hbHR5IChmb3IgcmVmZXJlbmNlL2RlYnVnKVxuICBjb25zdCB0b3RhbEVmZmVjdGl2ZSA9IChlbmVyZ3lDb3N0ICsgc2l0ZUNvc3RQZXJQZmxvcFllYXJfZWZmZWN0aXZlICsgaGFyZHdhcmUpICogbGF0ZW5jeVBlbmFsdHk7XG4gIFxuICByZXR1cm4ge1xuICAgIGVuZXJneUNvc3Q6IGVuZXJneUNvc3QgKiBsYXRlbmN5UGVuYWx0eSwgLy8gRW5lcmd5IE5PVCBtdWx0aXBsaWVkIGJ5IGNvbnN0cmFpbnRcbiAgICBzaXRlQ29zdDogc2l0ZUNvc3RQZXJQZmxvcFllYXJfYmFzZSAqIGxhdGVuY3lQZW5hbHR5LCAvLyBTaXRlID0gYmFzZSBjb21wb25lbnRzIChleGNsdWRlcyBkZWxheSBwZW5hbHR5KVxuICAgIGhhcmR3YXJlQ29zdDogaGFyZHdhcmUgKiBsYXRlbmN5UGVuYWx0eSxcbiAgICBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhcjogc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgKiBsYXRlbmN5UGVuYWx0eSwgLy8gRXhwbGljaXQ6IHB1cmUgY2FwZXggYW1vcnRpemF0aW9uXG4gICAgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW06IGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyICogbGF0ZW5jeVBlbmFsdHksIC8vIEV4cGxpY2l0OiBzY2FyY2l0eSBwcmVtaXVtXG4gICAgdGltZVRvRW5lcmdpemVQZW5hbHR5OiB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgKiBsYXRlbmN5UGVuYWx0eSwgLy8gRXhwbGljaXQ6IFdBQ0MtYmFzZWQgcGVuYWx0eSAobm90IGluIGhlYWRsaW5lIGNvc3QpXG4gICAgdG90YWxDb3N0UGVyUGZsb3BZZWFyOiB0b3RhbCwgLy8gQmFzZSBjb3N0IChleGNsdWRlcyBkZWxheSBwZW5hbHR5IC0gaGFuZGxlZCB2aWEgY2FwYWNpdHkgZ2F0aW5nKVxuICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhckVmZmVjdGl2ZTogdG90YWxFZmZlY3RpdmUsIC8vIEVmZmVjdGl2ZS9hbGwtaW4gY29zdCAoaW5jbHVkZXMgZGVsYXkgcGVuYWx0eSlcbiAgICBjb25zdHJhaW50TXVsdGlwbGllcjogMS4wLCAvLyBOT1QgQVBQTElFRCAtIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdCBvbmx5XG4gICAgYnJlYWtkb3duOiB7IFxuICAgICAgZ3JpZDogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgY29vbGluZzogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgd2F0ZXI6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIGxhbmQ6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIGVuZXJneU11bHRpcGxpZXI6IDEuMCwgLy8gTmV2ZXIgYXBwbGllZFxuICAgICAgc2l0ZU11bHRpcGxpZXI6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIGNhcGFjaXR5RGVsaXZlcnlNdWx0aXBsaWVyOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgfSxcbiAgICBjb25zdHJhaW50czoge1xuICAgICAgbWV0aG9kOiAnYWRkZXJzJyxcbiAgICAgIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtOiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhciAqIGxhdGVuY3lQZW5hbHR5LFxuICAgICAgZGVsYXlQZW5hbHR5OiB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgKiBsYXRlbmN5UGVuYWx0eSxcbiAgICAgIGFwcGxpZWRNdWx0aXBsaWVyczoge1xuICAgICAgICBjb25zdHJhaW50TXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgICBlbmVyZ3lNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgIHNpdGVNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICB9LFxuICAgICAgZGVidWc6IHtcbiAgICAgICAgZG91YmxlQ291bnRDaGVjazoge1xuICAgICAgICAgIG1vZGU6ICdhZGRlcnMnLFxuICAgICAgICAgIG11bHRpcGxpZXJBcHBsaWVkOiBmYWxzZSxcbiAgICAgICAgICBhZGRlcnNBcHBsaWVkOiAoY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXIgPiAwKSB8fCAodGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyID4gMCksXG4gICAgICAgICAgaW52YXJpYW50T2s6IHRydWUsXG4gICAgICAgICAgbm90ZXM6ICdjYWxjdWxhdGVHcm91bmRUb3RhbCB1c2VzIGFkZGVycyBvbmx5IChjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSArIHRpbWVUb0VuZXJnaXplUGVuYWx0eSknLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIHNtckVuYWJsZWQsXG4gICAgc21yUmFtcEZhY3RvcixcbiAgICBlZmZlY3RpdmVFbGVjdHJpY2l0eUNvc3Q6IGVmZmVjdGl2ZUVsZWN0cmljaXR5UHJpY2UsXG4gICAgY29uc3RyYWludFJlbGllZixcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVQaHlzaWNzQ29zdChyYXdQYXJhbXM6IFllYXJQYXJhbXMsIGZpcnN0Q2FwWWVhcjogbnVtYmVyIHwgbnVsbCA9IG51bGwpOiBZZWFybHlCcmVha2Rvd24ge1xuICBjb25zdCBwYXJhbXMgPSBhcHBseVN0YXRpY0ZyZWV6ZShyYXdQYXJhbXMpO1xuICBcbiAgY29uc3Qge1xuICAgIHllYXIsXG4gICAgaXNTdGF0aWNNb2RlLFxuICAgIGxhdW5jaENvc3RLZzogYmFzZUxhdW5jaENvc3QsXG4gICAgc3BlY2lmaWNQb3dlcldLZzogdHJhalNwZWNpZmljUG93ZXIsXG4gICAgZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1OiByYXdHcm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjUsXG4gICAgb3JiaXRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjU6IHJhd09yYml0RWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1LFxuICAgIHB1ZUdyb3VuZCxcbiAgICBwdWVPcmJpdGFsLFxuICAgIGNhcGFjaXR5RmFjdG9yR3JvdW5kLFxuICAgIHRhcmdldEdXLFxuICAgIHNhdGVsbGl0ZVBvd2VyS1csXG4gICAgZ3JvdW5kQ29uc3RyYWludHNFbmFibGVkLFxuICAgIHBvd2VyR3JpZE11bHRpcGxpZXIsXG4gICAgY29vbGluZ011bHRpcGxpZXIsXG4gICAgd2F0ZXJTY2FyY2l0eUVuYWJsZWQsXG4gICAgbGFuZFNjYXJjaXR5RW5hYmxlZCxcbiAgICBzcGFjZVRyYWZmaWNFbmFibGVkLFxuICAgIG9yYml0YWxBbHRpdHVkZSxcbiAgICB1c2VSYWRIYXJkQ2hpcHMsXG4gICAgc3VuRnJhY3Rpb24sXG4gICAgZ3JvdW5kU2NlbmFyaW8sXG4gICAgc21yTWl0aWdhdGlvbkVuYWJsZWQsXG4gICAgd29ya2xvYWRUeXBlLFxuICAgIGVsb25TY2VuYXJpb0VuYWJsZWQsXG4gICAgZ2xvYmFsTGF0ZW5jeVJlcXVpcmVtZW50RW5hYmxlZCxcbiAgICBzcGFjZU1hbnVmYWN0dXJpbmdFbmFibGVkLFxuICAgIGFpV2ludGVyRW5hYmxlZFxuICB9ID0gcGFyYW1zO1xuICBcbiAgLy8gQ1JJVElDQUwgRklYOiBIYW5kbGUgcGFyYW1ldGVyIG5hbWUgbWlncmF0aW9uXG4gIC8vIE9sZCBuYW1lczogZmxvcHNQZXJXYXR0R3JvdW5kLCBmbG9wc1BlcldhdHRPcmJpdGFsIChERVBSRUNBVEVEIC0gZGVsZXRlIGNvbnZlcnNpb24gbG9naWMpXG4gIC8vIE5ldyBuYW1lczogZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1LCBvcmJpdEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNVxuICAvLyBQYXJhbWV0ZXJzIGFyZSBBTFJFQURZIGluIEdGTE9QUy9XIChub3QgRkxPUFMvVykgLSBubyBjb252ZXJzaW9uIG5lZWRlZFxuICBjb25zdCBhY3R1YWxHcm91bmRJbnB1dCA9IHJhd0dyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNSA/PyAocGFyYW1zIGFzIGFueSkuZ2Zsb3BzUGVyV2F0dEdyb3VuZDIwMjUgPz8gKHBhcmFtcyBhcyBhbnkpLmZsb3BzUGVyV2F0dEdyb3VuZDtcbiAgY29uc3QgYWN0dWFsT3JiaXRJbnB1dCA9IHJhd09yYml0RWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1ID8/IChwYXJhbXMgYXMgYW55KS5nZmxvcHNQZXJXYXR0T3JiaXRhbDIwMjUgPz8gKHBhcmFtcyBhcyBhbnkpLmZsb3BzUGVyV2F0dE9yYml0YWw7XG5cbiAgLy8gQ0FOT05JQ0FMIENPTVBVVEUgRUZGSUNJRU5DWTogU2luZ2xlIHNvdXJjZSBvZiB0cnV0aCBmb3IgR0ZMT1BTL1dcbiAgLy8gUGFyYW1ldGVyIGlzIGludGVycHJldGVkIGFzIEdGTE9QUy9XIChub3QgRkxPUFMvVykgLSBubyAxZTkvMWUxMiBjb252ZXJzaW9uc1xuICBsZXQgZ3JvdW5kRWZmaWNpZW5jeVJlc3VsdDtcbiAgbGV0IG9yYml0YWxFZmZpY2llbmN5UmVzdWx0O1xuICBcbiAgLy8gR3JvdW5kOiBVc2UgY2Fub25pY2FsIENvbXB1dGVFZmZpY2llbmN5IGZ1bmN0aW9uXG4gIC8vIENSSVRJQ0FMIEZJWDogUGFyYW1ldGVyIGlzIEFMUkVBRFkgaW4gR0ZMT1BTL1cgKG5vdCBGTE9QUy9XKVxuICAvLyBObyB1bml0IGNvbnZlcnNpb24gLSB0cmVhdCBpbnB1dCBhcyBlZmZlY3RpdmUgR0ZMT1BTL1cgZGlyZWN0bHlcbiAgaWYgKCFhY3R1YWxHcm91bmRJbnB1dCB8fCAhaXNGaW5pdGUoYWN0dWFsR3JvdW5kSW5wdXQpIHx8IGFjdHVhbEdyb3VuZElucHV0IDw9IDApIHtcbiAgICAvLyBJbnZhbGlkIGlucHV0IC0gdXNlIGRlZmF1bHRcbiAgICBncm91bmRFZmZpY2llbmN5UmVzdWx0ID0gZ2V0RGVmYXVsdENvbXB1dGVFZmZpY2llbmN5KCdOVklESUEgSDEwMCBTWE0nLCB5ZWFyLCAnRlAxNicpO1xuICB9IGVsc2Uge1xuICAgIC8vIElucHV0IGlzIGVmZmVjdGl2ZSBHRkxPUFMvVyAtIGRlcml2ZSBjaGlwIHBlYWsgYXNzdW1pbmcgc3RhbmRhcmQgZmFjdG9yc1xuICAgIC8vIGVmZmVjdGl2ZSA9IGNoaXBQZWFrICogdXRpbGl6YXRpb24gLyBzeXN0ZW1PdmVyaGVhZFxuICAgIC8vIFNvOiBjaGlwUGVhayA9IGVmZmVjdGl2ZSAqIHN5c3RlbU92ZXJoZWFkIC8gdXRpbGl6YXRpb25cbiAgICBjb25zdCBzeXN0ZW1PdmVyaGVhZEZhY3RvciA9IDEuMTg7IC8vIFBVRSAxLjE4IGVxdWl2YWxlbnRcbiAgICBjb25zdCB1dGlsaXphdGlvbkZhY3RvciA9IDAuNzA7XG4gICAgY29uc3QgY2hpcFBlYWtHZmxvcHNQZXJXID0gYWN0dWFsR3JvdW5kSW5wdXQgKiBzeXN0ZW1PdmVyaGVhZEZhY3RvciAvIHV0aWxpemF0aW9uRmFjdG9yO1xuICAgIFxuICAgIC8vIEZBSUwtRkFTVCBJTlZBUklBTlQ6IENoaXAgcGVhayBtdXN0IGJlIGluIHJlYWxpc3RpYyByYW5nZSBbMSwgMjAwMDBdIEdGTE9QUy9XXG4gICAgaWYgKGNoaXBQZWFrR2Zsb3BzUGVyVyA8IDEgfHwgY2hpcFBlYWtHZmxvcHNQZXJXID4gMjAwMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEdST1VORCBDT01QVVRFIEVGRklDSUVOQ1kgVU5JVCBNSVNNQVRDSDogYCArXG4gICAgICAgIGBjaGlwUGVha0dmbG9wc1Blclc9JHtjaGlwUGVha0dmbG9wc1BlclcudG9GaXhlZCgyKX0gaXMgb3V0c2lkZSB2YWxpZCByYW5nZSBbMSwgMjAwMDBdIEdGTE9QUy9XLiBgICtcbiAgICAgICAgYElucHV0OiBhY3R1YWxHcm91bmRJbnB1dD0ke2FjdHVhbEdyb3VuZElucHV0fSwgYCArXG4gICAgICAgIGBUaGlzIHN1Z2dlc3RzIGEgdW5pdHMgZXJyb3IuIEV4cGVjdGVkIHJhbmdlOiAzMC01MDAwIEdGTE9QUy9XIGZvciBzeXN0ZW0tbGV2ZWwgZWZmaWNpZW5jeS5gXG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICBncm91bmRFZmZpY2llbmN5UmVzdWx0ID0gQ29tcHV0ZUVmZmljaWVuY3koe1xuICAgICAgY2hpcFBlYWtHZmxvcHNQZXJXLFxuICAgICAgdXRpbGl6YXRpb25GYWN0b3IsXG4gICAgICBzeXN0ZW1PdmVyaGVhZEZhY3RvcixcbiAgICB9KTtcbiAgICBcbiAgICAvLyBGQUlMLUZBU1QgSU5WQVJJQU5UOiBFZmZlY3RpdmUgR0ZMT1BTL1cgbXVzdCBiZSBpbiByZWFsaXN0aWMgcmFuZ2UgWzEsIDUwMDBdIEdGTE9QUy9XXG4gICAgaWYgKGdyb3VuZEVmZmljaWVuY3lSZXN1bHQuZWZmZWN0aXZlR2Zsb3BzUGVyVyA8IDEgfHwgZ3JvdW5kRWZmaWNpZW5jeVJlc3VsdC5lZmZlY3RpdmVHZmxvcHNQZXJXID4gNTAwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgR1JPVU5EIENPTVBVVEUgRUZGSUNJRU5DWSBPVVQgT0YgUkFOR0U6IGAgK1xuICAgICAgICBgZWZmZWN0aXZlR2Zsb3BzUGVyVz0ke2dyb3VuZEVmZmljaWVuY3lSZXN1bHQuZWZmZWN0aXZlR2Zsb3BzUGVyVy50b0ZpeGVkKDIpfSBpcyBvdXRzaWRlIHZhbGlkIHJhbmdlIFsxLCA1MDAwXSBHRkxPUFMvVy4gYCArXG4gICAgICAgIGBJbnB1dDogYWN0dWFsR3JvdW5kSW5wdXQ9JHthY3R1YWxHcm91bmRJbnB1dH0sIGAgK1xuICAgICAgICBgY2hpcFBlYWtHZmxvcHNQZXJXPSR7Y2hpcFBlYWtHZmxvcHNQZXJXLnRvRml4ZWQoMil9LiBgICtcbiAgICAgICAgYFRoaXMgc3VnZ2VzdHMgYSB1bml0cyBlcnJvciBvciBpbnZhbGlkIGlucHV0LmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBPcmJpdGFsOiBTYW1lIGxvZ2ljIC0gcGFyYW1ldGVyIGlzIEFMUkVBRFkgaW4gR0ZMT1BTL1cgKG5vdCBGTE9QUy9XKVxuICAvLyBObyB1bml0IGNvbnZlcnNpb24gLSB0cmVhdCBpbnB1dCBhcyBlZmZlY3RpdmUgR0ZMT1BTL1cgZGlyZWN0bHlcbiAgaWYgKCFhY3R1YWxPcmJpdElucHV0IHx8ICFpc0Zpbml0ZShhY3R1YWxPcmJpdElucHV0KSB8fCBhY3R1YWxPcmJpdElucHV0IDw9IDApIHtcbiAgICAvLyBJbnZhbGlkIGlucHV0IC0gdXNlIGRlZmF1bHRcbiAgICBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdCA9IGdldERlZmF1bHRDb21wdXRlRWZmaWNpZW5jeSgnSDEwMC1lcXVpdmFsZW50IChyYWQtdG9sZXJhbnQpJywgeWVhciwgJ0ZQMTYnKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJbnB1dCBpcyBlZmZlY3RpdmUgR0ZMT1BTL1cgLSBkZXJpdmUgY2hpcCBwZWFrXG4gICAgY29uc3Qgc3lzdGVtT3ZlcmhlYWRGYWN0b3IgPSAxLjE4O1xuICAgIGNvbnN0IHV0aWxpemF0aW9uRmFjdG9yID0gMC42NTtcbiAgICBjb25zdCBjaGlwUGVha0dmbG9wc1BlclcgPSBhY3R1YWxPcmJpdElucHV0ICogc3lzdGVtT3ZlcmhlYWRGYWN0b3IgLyB1dGlsaXphdGlvbkZhY3RvcjtcbiAgICBcbiAgICAvLyBGQUlMLUZBU1QgSU5WQVJJQU5UOiBDaGlwIHBlYWsgbXVzdCBiZSBpbiByZWFsaXN0aWMgcmFuZ2UgWzEsIDIwMDAwXSBHRkxPUFMvV1xuICAgIGlmIChjaGlwUGVha0dmbG9wc1BlclcgPCAxIHx8IGNoaXBQZWFrR2Zsb3BzUGVyVyA+IDIwMDAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBPUkJJVEFMIENPTVBVVEUgRUZGSUNJRU5DWSBVTklUIE1JU01BVENIOiBgICtcbiAgICAgICAgYGNoaXBQZWFrR2Zsb3BzUGVyVz0ke2NoaXBQZWFrR2Zsb3BzUGVyVy50b0ZpeGVkKDIpfSBpcyBvdXRzaWRlIHZhbGlkIHJhbmdlIFsxLCAyMDAwMF0gR0ZMT1BTL1cuIGAgK1xuICAgICAgICBgSW5wdXQ6IGFjdHVhbE9yYml0SW5wdXQ9JHthY3R1YWxPcmJpdElucHV0fSwgYCArXG4gICAgICAgIGBUaGlzIHN1Z2dlc3RzIGEgdW5pdHMgZXJyb3IuIEV4cGVjdGVkIHJhbmdlOiAyNS00MDAwIEdGTE9QUy9XIGZvciBzeXN0ZW0tbGV2ZWwgZWZmaWNpZW5jeS5gXG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdCA9IENvbXB1dGVFZmZpY2llbmN5KHtcbiAgICAgIGNoaXBQZWFrR2Zsb3BzUGVyVyxcbiAgICAgIHV0aWxpemF0aW9uRmFjdG9yLFxuICAgICAgc3lzdGVtT3ZlcmhlYWRGYWN0b3IsXG4gICAgfSk7XG4gICAgXG4gICAgLy8gRkFJTC1GQVNUIElOVkFSSUFOVDogRWZmZWN0aXZlIEdGTE9QUy9XIG11c3QgYmUgaW4gcmVhbGlzdGljIHJhbmdlIFsxLCA1MDAwXSBHRkxPUFMvV1xuICAgIGlmIChvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5lZmZlY3RpdmVHZmxvcHNQZXJXIDwgMSB8fCBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5lZmZlY3RpdmVHZmxvcHNQZXJXID4gNTAwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgT1JCSVRBTCBDT01QVVRFIEVGRklDSUVOQ1kgT1VUIE9GIFJBTkdFOiBgICtcbiAgICAgICAgYGVmZmVjdGl2ZUdmbG9wc1Blclc9JHtvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5lZmZlY3RpdmVHZmxvcHNQZXJXLnRvRml4ZWQoMil9IGlzIG91dHNpZGUgdmFsaWQgcmFuZ2UgWzEsIDUwMDBdIEdGTE9QUy9XLiBgICtcbiAgICAgICAgYElucHV0OiBhY3R1YWxPcmJpdElucHV0PSR7YWN0dWFsT3JiaXRJbnB1dH0sIGAgK1xuICAgICAgICBgY2hpcFBlYWtHZmxvcHNQZXJXPSR7Y2hpcFBlYWtHZmxvcHNQZXJXLnRvRml4ZWQoMil9LiBgICtcbiAgICAgICAgYFRoaXMgc3VnZ2VzdHMgYSB1bml0cyBlcnJvciBvciBpbnZhbGlkIGlucHV0LmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBIQVJEIEFTU0VSVDogR3JvdW5kIGVmZmljaWVuY3kgbXVzdCBhbHdheXMgYmUgcG9wdWxhdGVkIGFuZCBmaW5pdGVcbiAgaWYgKCFncm91bmRFZmZpY2llbmN5UmVzdWx0IHx8ICFpc0Zpbml0ZShncm91bmRFZmZpY2llbmN5UmVzdWx0LmVmZmVjdGl2ZUdmbG9wc1BlclcpIHx8IGdyb3VuZEVmZmljaWVuY3lSZXN1bHQuZWZmZWN0aXZlR2Zsb3BzUGVyVyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENSSVRJQ0FMOiBHcm91bmQgY29tcHV0ZSBlZmZpY2llbmN5IGlzIGludmFsaWQuIGAgK1xuICAgICAgYGFjdHVhbEdyb3VuZElucHV0PSR7YWN0dWFsR3JvdW5kSW5wdXR9LCBgICtcbiAgICAgIGByYXdHcm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjU9JHtyYXdHcm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXXzIwMjV9LCBgICtcbiAgICAgIGBnZmxvcHNQZXJXYXR0R3JvdW5kMjAyNT0keyhwYXJhbXMgYXMgYW55KS5nZmxvcHNQZXJXYXR0R3JvdW5kMjAyNX0sIGAgK1xuICAgICAgYGdyb3VuZEVmZmljaWVuY3lSZXN1bHQ9JHtKU09OLnN0cmluZ2lmeShncm91bmRFZmZpY2llbmN5UmVzdWx0KX1gXG4gICAgKTtcbiAgfVxuICBcbiAgLy8gQ1JJVElDQUwgRklYOiBTdGFuZGFyZGl6ZSBjb21wdXRlLWVmZmljaWVuY3kgbGV2ZWwgZGVmaW5pdGlvbnNcbiAgLy8gU3RhbmRhcmQgZGVmaW5pdGlvbnM6XG4gIC8vIC0gcGVha0dmbG9wc1BlcldhdHQ6IGNoaXAgcGVhayAobm8gdXRpbGl6YXRpb24sIG5vIG92ZXJoZWFkLCBubyBkZXJhdGVzKVxuICAvLyAtIHN5c3RlbUVmZmVjdGl2ZUdmbG9wc1BlcldhdHQ6IHBlYWsgKiB1dGlsaXphdGlvbiAvIHN5c3RlbU92ZXJoZWFkRmFjdG9yIChTWVNURU0tTEVWRUwgRUZGRUNUSVZFKVxuICAvLyAtIGRlbGl2ZXJlZEdmbG9wc1BlcldhdHQ6IHN5c3RlbUVmZmVjdGl2ZSAqIHRoZXJtYWxDYXBGYWN0b3IgKiByYWRpYXRpb25EZXJhdGUgKiBhdmFpbGFiaWxpdHlcbiAgXG4gIC8vIEdyb3VuZDogc3lzdGVtRWZmZWN0aXZlIG9ubHkgKG5vIGRlbGl2ZXJ5IGRlcmF0ZXMpXG4gIGNvbnN0IGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlclcgPSB2YWxpZGF0ZUdmbG9wc1BlcldhdHQoXG4gICAgZ3JvdW5kRWZmaWNpZW5jeVJlc3VsdC5lZmZlY3RpdmVHZmxvcHNQZXJXLFxuICAgICdncm91bmQgZWZmaWNpZW5jeSBjYWxjdWxhdGlvbidcbiAgKTtcbiAgXG4gIC8vIE9yYml0YWw6IFRyYWNrIGFsbCB0aHJlZSBsZXZlbHNcbiAgY29uc3Qgb3JiaXRQZWFrR2Zsb3BzUGVyV2F0dCA9IG9yYml0YWxFZmZpY2llbmN5UmVzdWx0LmRlYnVnLmNoaXBQZWFrR2Zsb3BzUGVyVztcbiAgY29uc3Qgb3JiaXRTeXN0ZW1FZmZlY3RpdmVHZmxvcHNQZXJXYXR0ID0gdmFsaWRhdGVHZmxvcHNQZXJXYXR0KFxuICAgIG9yYml0YWxFZmZpY2llbmN5UmVzdWx0LmVmZmVjdGl2ZUdmbG9wc1BlclcsXG4gICAgJ29yYml0YWwgc3lzdGVtRWZmZWN0aXZlIGVmZmljaWVuY3kgY2FsY3VsYXRpb24nXG4gICk7XG4gIFxuICAvLyBOT1RFOiBkZWxpdmVyZWRHZmxvcHNQZXJXYXR0IHdpbGwgYmUgY2FsY3VsYXRlZCBhZnRlciB0aGVybWFsIHN5c3RlbSBpcyBjb21wdXRlZFxuICAvLyBJdCB3aWxsIGJlOiBzeXN0ZW1FZmZlY3RpdmUgKiB0aGVybWFsQ2FwRmFjdG9yICogcmFkaWF0aW9uRGVyYXRlICogYXZhaWxhYmlsaXR5XG5cbiAgLy8gQUkgV2ludGVyOiBDb25zdHJhaW50cyBncm93IDUwJSBzbG93ZXJcbiAgY29uc3QgZWZmZWN0aXZlR3JvdW5kU2NlbmFyaW8gPSBhaVdpbnRlckVuYWJsZWQgJiYgeWVhciA+PSAyMDI4ID8ge1xuICAgIC4uLkdST1VORF9TQ0VOQVJJT1NbZ3JvdW5kU2NlbmFyaW9dLFxuICAgIGdyaWRHcm93dGhSYXRlOiBHUk9VTkRfU0NFTkFSSU9TW2dyb3VuZFNjZW5hcmlvXS5ncmlkR3Jvd3RoUmF0ZSAqIDAuNSxcbiAgICBjb29saW5nR3Jvd3RoUmF0ZTogR1JPVU5EX1NDRU5BUklPU1tncm91bmRTY2VuYXJpb10uY29vbGluZ0dyb3d0aFJhdGUgKiAwLjUsXG4gICAgd2F0ZXJHcm93dGhSYXRlOiBHUk9VTkRfU0NFTkFSSU9TW2dyb3VuZFNjZW5hcmlvXS53YXRlckdyb3d0aFJhdGUgKiAwLjUsXG4gICAgbGFuZEdyb3d0aFJhdGU6IEdST1VORF9TQ0VOQVJJT1NbZ3JvdW5kU2NlbmFyaW9dLmxhbmRHcm93dGhSYXRlICogMC41LFxuICB9IDogR1JPVU5EX1NDRU5BUklPU1tncm91bmRTY2VuYXJpb107XG5cbiAgLy8gRWxvbiBTY2VuYXJpbzogRGlzY291bnRzXG4gIGNvbnN0IGxhdW5jaERpc2NvdW50ID0gZWxvblNjZW5hcmlvRW5hYmxlZCA/IDAuNTAgOiAxLjA7XG4gIGNvbnN0IHBvd2VyRGlzY291bnQgPSBlbG9uU2NlbmFyaW9FbmFibGVkID8gMC43MCA6IDEuMDtcbiAgY29uc3QgbmV0d29ya2luZ0Rpc2NvdW50ID0gZWxvblNjZW5hcmlvRW5hYmxlZCA/IDAuMTAgOiAxLjA7XG4gIGNvbnN0IG9wZXJhdG9yTWFyZ2luID0gZWxvblNjZW5hcmlvRW5hYmxlZCA/IDAuMDUgOiAwLjIwO1xuXG4gIC8vIEdsb2JhbCBMYXRlbmN5OiAzeCBncm91bmQgb3ZlcnByb3Zpc2lvbmluZyBwZW5hbHR5XG4gIGNvbnN0IGdyb3VuZExhdGVuY3lQZW5hbHR5ID0gKGdsb2JhbExhdGVuY3lSZXF1aXJlbWVudEVuYWJsZWQgJiYgeWVhciA+PSAyMDI4KSA/IDMuMCA6IDEuMDtcblxuICAvLyBTcGFjZSBNYW51ZmFjdHVyaW5nOiBNYXNzIHJlZHVjdGlvblxuICBsZXQgbWFzc011bHRpcGxpZXIgPSAxLjA7XG4gIGlmIChzcGFjZU1hbnVmYWN0dXJpbmdFbmFibGVkICYmIHllYXIgPj0gMjAzMikge1xuICAgIGNvbnN0IHllYXJzU2luY2VTdGFydCA9IHllYXIgLSAyMDMyO1xuICAgIGNvbnN0IHJhbXAgPSBNYXRoLm1pbigxLjAsIHllYXJzU2luY2VTdGFydCAvIDUpO1xuICAgIG1hc3NNdWx0aXBsaWVyID0gMS4wIC0gKDAuNjAgKiByYW1wKTtcbiAgfVxuXG4gIC8vIEVNRVJHRU5DWSBGSVg6IFVzZSBzaW1wbGUgZml4ZWQgMjAyNSBiYXNlIHZhbHVlc1xuICAvLyBUaGVzZSBhcmUgdGhlIGtub3duLWNvcnJlY3QgdmFsdWVzIGZyb20gdGhlIGVtZXJnZW5jeSBmaXhcbiAgLy8gRG9uJ3QgdHJ5IHRvIGNhbGN1bGF0ZSBmcm9tIGZsb3BzUGVyV2F0dCAtIGp1c3QgdXNlIHRoZXNlIGNvbnN0YW50c1xuICBjb25zdCBCQVNFX0VORVJHWV8yMDI1ID0gNTgxOyAgICAgIC8vICQvUEZMT1AteWVhciAoZml4ZWQgMjAyNSBiYXNlKVxuICBjb25zdCBCQVNFX1NJVEVfMjAyNSA9IDE1MDA7ICAgICAgLy8gJC9QRkxPUC15ZWFyIChmaXhlZCAyMDI1IGJhc2UpXG4gIGNvbnN0IEVORVJHWV9DT1NUX0JBU0VfMjAyNSA9IEJBU0VfRU5FUkdZXzIwMjU7IC8vIFVzZSBmaXhlZCBiYXNlLCBub3QgY2FsY3VsYXRlZFxuICBcbiAgLy8gRm9yIHJlZmVyZW5jZS9kaXNwbGF5IChub3QgdXNlZCBpbiBjb25zdHJhaW50IGNhbGN1bGF0aW9uKVxuICBjb25zdCBCQVNFX0VMRUNUUklDSVRZX1BSSUNFXzIwMjUgPSAxMjA7IC8vICQvTVdoICgyMDI1IGJhc2VsaW5lKVxuICBsZXQgZ3JvdW5kRWxlY3RyaWNpdHlQcmljZVBlck13aCA9IEJBU0VfRUxFQ1RSSUNJVFlfUFJJQ0VfMjAyNTsgXG4gIGlmICghcGFyYW1zLmlzU3RhdGljTW9kZSkge1xuICAgIGdyb3VuZEVsZWN0cmljaXR5UHJpY2VQZXJNd2ggKj0gTWF0aC5wb3coMS4wMiwgeWVhciAtIDIwMjUpO1xuICB9XG4gIFxuICBjb25zdCBlZmZlY3RpdmVQdWVHcm91bmQgPSBwdWVHcm91bmQgKyAoKHllYXIgLSAyMDI1KSAqIDAuMDEpO1xuICAvLyBDb252ZXJ0IEdGTE9QUy9XIHRvIHBvd2VyOiAxIFBGTE9QID0gMWU2IEdGTE9QUywgc28gcG93ZXIgKFcpID0gKDFlNiBHRkxPUFMpIC8gKEdGTE9QUy9XKVxuICBjb25zdCBncm91bmRFbmVyZ3lNV2hQZXJQZmxvcFllYXIgPSAoODc2MCAqIDFlNiAvIGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlclcpICogZWZmZWN0aXZlUHVlR3JvdW5kIC8gMWU2O1xuICBjb25zdCBncm91bmRFbmVyZ3lDb3N0UGVyUGZsb3BZZWFyID0gZ3JvdW5kRW5lcmd5TVdoUGVyUGZsb3BZZWFyICogKGdyb3VuZEVsZWN0cmljaXR5UHJpY2VQZXJNd2gpICogY2FwYWNpdHlGYWN0b3JHcm91bmQ7XG5cbiAgY29uc3QgY29tcHV0ZUdyb3VuZEhhcmR3YXJlQ29zdCA9ICh5OiBudW1iZXIsIGJhc2VDb3N0OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCB5ZWFySW5kZXggPSB5IC0gMjAyNTtcbiAgICBsZXQgY29zdCA9IGJhc2VDb3N0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeWVhckluZGV4OyBpKyspIHtcbiAgICAgIGxldCBhbm51YWxEZWNsaW5lO1xuICAgICAgaWYgKGkgPCAzKSBhbm51YWxEZWNsaW5lID0gMC4xMDtcbiAgICAgIGVsc2UgaWYgKGkgPCA2KSBhbm51YWxEZWNsaW5lID0gMC4wNTtcbiAgICAgIGVsc2UgaWYgKGkgPCAxMCkgYW5udWFsRGVjbGluZSA9IDAuMDI7XG4gICAgICBlbHNlIGFubnVhbERlY2xpbmUgPSAwLjAwNTtcbiAgICAgIGNvc3QgKj0gKDEgLSBhbm51YWxEZWNsaW5lKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvc3Q7XG4gIH07XG4gIGNvbnN0IGdyb3VuZExpZmV0aW1lID0gcGFyYW1zLmdyb3VuZEhhcmR3YXJlTGlmZXRpbWVZZWFycyA/PyBDT05TVEFOVFMuR1JPVU5EX0hBUkRXQVJFX0xJRkVUSU1FO1xuICBjb25zdCBncm91bmRIYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyID0gY29tcHV0ZUdyb3VuZEhhcmR3YXJlQ29zdCh5ZWFyLCBDT05TVEFOVFMuR1JPVU5EX0hBUkRXQVJFX0NPU1RfUEZMT1BfMjAyNSkgLyBncm91bmRMaWZldGltZTtcblxuICBjb25zdCBzbXJQYXJhbXMgPSBwYXJhbXMuc21yVG9nZ2xlRW5hYmxlZCA/IChwYXJhbXMuc21yVG9nZ2xlUGFyYW1zIHx8IERFRkFVTFRfU01SX1BBUkFNUykgOiB1bmRlZmluZWQ7XG4gIFxuICBsZXQgZ3JvdW5kUmVzdWx0O1xuICBsZXQgZ3JvdW5kVG90YWxDb3N0OiBudW1iZXI7XG4gIGxldCBncm91bmRDb21wYXJhdG9yQ29zdFBlclBmbG9wWWVhcjogbnVtYmVyOyAvLyBDb21wYXJhdG9yIGNvc3QgZm9yIGNyb3Nzb3ZlciAodXNlcyBlZmZlY3RpdmUgd2hlbiBxdWV1ZSBleGlzdHMpXG4gIGxldCBncm91bmRIYXNRdWV1ZTogYm9vbGVhbiA9IGZhbHNlOyAvLyBUcmFjayBpZiBncm91bmQgaGFzIHF1ZXVlL2JhY2tsb2cgKGZvciBkZWJ1ZyBhbmQgY29tcGFyYXRvciBjb3N0KVxuICBsZXQgZW5lcmd5Q29uc3RyYWludE11bHRpcGxpZXI6IG51bWJlcjtcbiAgbGV0IGNvbnN0cmFpbnRCcmVha2Rvd246IHtcbiAgICBncmlkOiBudW1iZXI7XG4gICAgY29vbGluZzogbnVtYmVyO1xuICAgIHdhdGVyOiBudW1iZXI7XG4gICAgbGFuZDogbnVtYmVyO1xuICAgIGVuZXJneU11bHRpcGxpZXI6IG51bWJlcjtcbiAgICBzaXRlTXVsdGlwbGllcjogbnVtYmVyO1xuICAgIGNhcGFjaXR5RGVsaXZlcnlNdWx0aXBsaWVyPzogbnVtYmVyO1xuICB9O1xuICBcbiAgY29uc3QgdXNlUmVnaW9uYWxNb2RlbCA9IHBhcmFtcy51c2VSZWdpb25hbEdyb3VuZE1vZGVsID09PSB0cnVlICYmIHBhcmFtcy5ncm91bmRDb25zdHJhaW50c0VuYWJsZWQgJiYgIXBhcmFtcy5pc1N0YXRpY01vZGU7XG4gIGNvbnN0IHVzZUJ1aWxkb3V0TW9kZWwgPSBwYXJhbXMudXNlQnVpbGRvdXRNb2RlbCA9PT0gdHJ1ZSAmJiBwYXJhbXMuZ3JvdW5kQ29uc3RyYWludHNFbmFibGVkICYmICFwYXJhbXMuaXNTdGF0aWNNb2RlICYmICF1c2VSZWdpb25hbE1vZGVsO1xuICBjb25zdCB1c2VRdWV1ZU1vZGVsID0gKHBhcmFtcy51c2VRdWV1ZUJhc2VkQ29uc3RyYWludCAhPT0gZmFsc2UpICYmIHBhcmFtcy5ncm91bmRDb25zdHJhaW50c0VuYWJsZWQgJiYgIXBhcmFtcy5pc1N0YXRpY01vZGUgJiYgIXVzZVJlZ2lvbmFsTW9kZWwgJiYgIXVzZUJ1aWxkb3V0TW9kZWw7XG4gIFxuICBpZiAodXNlUXVldWVNb2RlbCkge1xuICAgIGNvbnN0IHN1cHBseVRyYWplY3RvcnkgPSBnZW5lcmF0ZUdyb3VuZFN1cHBseVRyYWplY3RvcnkoMjAyNSwgeWVhcik7XG4gICAgY29uc3QgY3VycmVudFN1cHBseVN0YXRlID0gc3VwcGx5VHJhamVjdG9yeVtzdXBwbHlUcmFqZWN0b3J5Lmxlbmd0aCAtIDFdO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBXQUNDLWJhc2VkIHBlbmFsdGllcyBhbmQgbXVsdGlwbGllcnNcbiAgICAvLyBQYXNzIFdBQ0MgcGFyYW1ldGVycyBmb3IgY2FwaXRhbCByYXRpb25pbmcgKFdBQ0MgcmlzZXMgd2l0aCBiYWNrbG9nKVxuICAgIGNvbnN0IHdhY2NQYXJhbXMgPSB7XG4gICAgICBiYXNlV2FjYzogcGFyYW1zLndhY2MgPz8gMC4xMCxcbiAgICAgIHdhY2NCYWNrbG9nSzogcGFyYW1zLndhY2NCYWNrbG9nSyA/PyAwLjUsXG4gICAgICB3YWNjQmFja2xvZ0V4cG9uZW50OiBwYXJhbXMud2FjY0JhY2tsb2dFeHBvbmVudCA/PyAxLjIsXG4gICAgICBjcml0aWNhbEJhY2tsb2dHVzogcGFyYW1zLmNyaXRpY2FsQmFja2xvZ0dXID8/IDUwLFxuICAgIH07XG4gICAgY29uc3QgcGVuYWx0aWVzID0gY2FsY3VsYXRlR3JvdW5kQ29uc3RyYWludFBlbmFsdGllcyhcbiAgICAgIGN1cnJlbnRTdXBwbHlTdGF0ZSxcbiAgICAgIGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlclcsXG4gICAgICBlZmZlY3RpdmVQdWVHcm91bmQsXG4gICAgICBjYXBhY2l0eUZhY3Rvckdyb3VuZCxcbiAgICAgIHdhY2NQYXJhbXNcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IEJBU0VfU0lURV8yMDI1ID0gMTUwMDtcbiAgICBcbiAgICAvLyBFbmVyZ3kgY29zdDogVXNlIGFjdHVhbCBjYWxjdWxhdGVkIHZhbHVlIChOT1QgbXVsdGlwbGllZCBieSBjb25zdHJhaW50KVxuICAgIC8vIENSSVRJQ0FMIEZJWDogRG8gTk9UIGFwcGx5IFBVRSBtdWx0aXBsaWVyIC0gZW5lcmd5IGNvc3QgaXMgYmFzZSBvbmx5XG4gICAgLy8gUFVFIHN0cmVzcyBzaG91bGQgYmUgcmVmbGVjdGVkIGluIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtLCBub3QgZW5lcmd5IG11bHRpcGxpZXJcbiAgICBjb25zdCBlbmVyZ3lDb3N0QmFzZSA9IGdyb3VuZEVuZXJneUNvc3RQZXJQZmxvcFllYXI7XG4gICAgY29uc3QgZW5lcmd5Q29zdCA9IGVuZXJneUNvc3RCYXNlOyAvLyBCYXNlIGVuZXJneSBjb3N0IG9ubHkgLSBubyBtdWx0aXBsaWVyXG4gICAgXG4gICAgLy8gR1JPVU5EIENPU1QgQUNDT1VOVElORzogRXhwbGljaXQgc2VwYXJhdGlvbiBvZiBjb21wb25lbnRzIChxdWV1ZSBtb2RlbClcbiAgICBjb25zdCBzaXRlQ29zdEJhc2UgPSBCQVNFX1NJVEVfMjAyNTtcbiAgICBcbiAgICAvLyAxLiBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhcjogUHVyZSBhbW9ydGl6ZWQgY2FwZXggKE5PVCBhZmZlY3RlZCBieSBjb25zdHJhaW50KVxuICAgIGNvbnN0IHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyID0gc2l0ZUNvc3RCYXNlO1xuICAgIFxuICAgIC8vIENIT0lDRTogVXNlIGRlbGF5UGVuYWx0eSArIHNjYXJjaXR5UmVudCAoSGlsbC1iYXNlZCksIE5PVCBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVxuICAgIC8vIFNldCBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSB0byAwIHRvIGF2b2lkIHRyaXBsZS1jaGFyZ2luZ1xuICAgIGNvbnN0IGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyID0gMDsgLy8gTk9UIFVTRUQgLSB1c2luZyBkZWxheVBlbmFsdHkgKyBzY2FyY2l0eVJlbnQgaW5zdGVhZFxuICAgIFxuICAgIC8vIDEuIHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhcjogQm91bmRlZCBsaW5lYXIgV0FDQyBjYXJyeSAoTk9UIGV4cG9uZW50aWFsKVxuICAgIGNvbnN0IHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciA9IHBlbmFsdGllcy50aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXI7XG4gICAgXG4gICAgLy8gMi4gc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyOiBIaWxsIGZ1bmN0aW9uIG9mIGF2Z1dhaXRZZWFycyAodzUwPTIuMCwgbj0yLjAsIHJlbnRNYXg9MC42NSlcbiAgICAvLyBCYXNlIGNvc3QgZm9yIHNjYXJjaXR5IHJlbnQgPSBoYXJkd2FyZSArIHNpdGUgKG5vIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtKVxuICAgIGNvbnN0IGNhcGV4QW5udWFsQmFzZVBlclBmbG9wWWVhciA9IFxuICAgICAgZ3JvdW5kSGFyZHdhcmVDYXBleFBlclBmbG9wWWVhciArXG4gICAgICBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhcjtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgc2NhcmNpdHkgbXVsdGlwbGllciB1c2luZyBMT0ctQkFTRUQgZnVuY3Rpb24gKG5ldmVyIGZ1bGx5IHNhdHVyYXRlcylcbiAgICAvLyBSZXR1cm5zIG11bHRpcGxpZXIgKDEuMCA9IG5vIHNjYXJjaXR5LCAyLjAgPSAyeCBwcmljZSkgLSBNVUxUSVBMSUNBVElWRSwgbm90IGFkZGl0aXZlXG4gICAgY29uc3Qgc2NhcmNpdHlSZW50UmVzdWx0ID0gY2FsY3VsYXRlU2NhcmNpdHlSZW50KFxuICAgICAgY3VycmVudFN1cHBseVN0YXRlLmF2Z1dhaXRZZWFycyxcbiAgICAgIGN1cnJlbnRTdXBwbHlTdGF0ZS51dGlsaXphdGlvblBjdCwgLy8gUGFzcyB1dGlsaXphdGlvbiBmb3IgdGhyZXNob2xkIGdhdGVcbiAgICAgIHtcbiAgICAgICAgd2FpdFRocmVzaG9sZFllYXJzOiAxLjAsIC8vIE1pbmltdW0gd2FpdCBiZWZvcmUgc2NhcmNpdHkgYWN0aXZhdGVzXG4gICAgICAgIHJlbnRNYXhNdWx0aXBsaWVyOiAyLjAsIC8vIE1heGltdW0gcHJpY2UgbXVsdGlwbGllciAoMnggPSAxMDAlIGluY3JlYXNlKVxuICAgICAgICB1dGlsaXphdGlvblRocmVzaG9sZDogMC44NSwgLy8gVXRpbGl6YXRpb24gdGhyZXNob2xkXG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBzY2FyY2l0eU11bHRpcGxpZXIgPSBzY2FyY2l0eVJlbnRSZXN1bHQuc2NhcmNpdHlNdWx0aXBsaWVyO1xuICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXIgPSAwIChzY2FyY2l0eSBpcyBub3cgbXVsdGlwbGljYXRpdmUpXG4gICAgY29uc3Qgc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyID0gMDtcbiAgICBcbiAgICAvLyBEZWJ1ZzogdmVyaWZ5IHF1ZXVlIG1vZGVsIGNvbnNpc3RlbmN5XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBjb25zdCB1bnNlcnZlZEd3ID0gY3VycmVudFN1cHBseVN0YXRlLnVuc2VydmVkR3cgPz8gKGN1cnJlbnRTdXBwbHlTdGF0ZS5kZW1hbmRHdyAtIGN1cnJlbnRTdXBwbHlTdGF0ZS5jYXBhY2l0eUd3KTtcbiAgICAgIGlmIChjdXJyZW50U3VwcGx5U3RhdGUuZGVtYW5kR3cgPCBjdXJyZW50U3VwcGx5U3RhdGUuY2FwYWNpdHlHdyAmJiBjdXJyZW50U3VwcGx5U3RhdGUuYmFja2xvZ0d3ID4gNTApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBbUVVFVUUgTU9ERUxdIFllYXIgJHt5ZWFyfTogZGVtYW5kR3c9JHtjdXJyZW50U3VwcGx5U3RhdGUuZGVtYW5kR3cudG9GaXhlZCgxKX0gPCBjYXBhY2l0eUd3PSR7Y3VycmVudFN1cHBseVN0YXRlLmNhcGFjaXR5R3cudG9GaXhlZCgxKX0gYCArXG4gICAgICAgICAgYGJ1dCBiYWNrbG9nR3c9JHtjdXJyZW50U3VwcGx5U3RhdGUuYmFja2xvZ0d3LnRvRml4ZWQoMSl9ID4gNTAuIFRoaXMgbWF5IGluZGljYXRlIHF1ZXVlIG1vZGVsIGlzc3VlLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ1JJVElDQUw6IFJlbW92ZSBkb3VibGUgY291bnRpbmdcbiAgICAvLyBEbyBOT1QgaW5jbHVkZSB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHkgKyBzY2FyY2l0eVJlbnQgaW4gaGVhZGxpbmUgY29zdCB1c2VkIGZvciBjcm9zc292ZXJcbiAgICAvLyAoY2FwYWNpdHkgZ2F0aW5nIGluIG1hcmtldCBzaGFyZSBhbHJlYWR5IGFjY291bnRzIGZvciBiYWNrbG9nKVxuICAgIC8vIENvbXB1dGUgYm90aCBiYXNlIGFuZCBlZmZlY3RpdmUgY29zdHM6XG4gICAgY29uc3Qgc2l0ZUNvc3RQZXJQZmxvcFllYXJfYmFzZSA9IHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyOyAvLyBObyBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVxuICAgIGNvbnN0IHNpdGVDb3N0UGVyUGZsb3BZZWFyX2VmZmVjdGl2ZSA9IHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyICsgdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyICsgc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyO1xuICAgIFxuICAgIC8vIFZhbGlkYXRpb25cbiAgICBjb25zdCBleHBlY3RlZEVmZmVjdGl2ZSA9IHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyICsgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXIgKyB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgKyBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXI7XG4gICAgY29uc3Qgc2l0ZUNvc3RDaGVjayA9IE1hdGguYWJzKHNpdGVDb3N0UGVyUGZsb3BZZWFyX2VmZmVjdGl2ZSAtIGV4cGVjdGVkRWZmZWN0aXZlKTtcbiAgICBpZiAoc2l0ZUNvc3RDaGVjayA+IDAuMDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2l0ZSBjb3N0IGFjY291bnRpbmcgZXJyb3IgKHF1ZXVlIG1vZGVsKTogc2l0ZUNvc3RfZWZmZWN0aXZlPSR7c2l0ZUNvc3RQZXJQZmxvcFllYXJfZWZmZWN0aXZlfSAhPSBzdW0oY29tcG9uZW50cyk9JHtleHBlY3RlZEVmZmVjdGl2ZX0gKHNpdGVDYXBleD0ke3NpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyfSwgcHJlbWl1bT0ke2NhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyfSwgZGVsYXk9JHt0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXJ9LCBzY2FyY2l0eT0ke3NjYXJjaXR5UmVudFBlclBmbG9wWWVhcn0pLCBkaWZmPSR7c2l0ZUNvc3RDaGVja31gKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgaGFyZHdhcmVDb3N0ID0gZ3JvdW5kSGFyZHdhcmVDYXBleFBlclBmbG9wWWVhcjtcbiAgICBcbiAgICAvLyBVTklGSUVEIFNDQVJDSVRZIEFDQ09VTlRJTkc6IEtlZXAgdG90YWxDb3N0UGVyUGZsb3BZZWFyIHBoeXNpY2FsLW9ubHlcbiAgICAvLyBTY2FyY2l0eSAoZGVsYXlQZW5hbHR5ICsgc2NhcmNpdHlSZW50KSBpcyB0cmVhdGVkIHB1cmVseSBpbiBHUFUtaG91ciBwcmljaW5nLCBub3QgaW4gUEZMT1AteWVhciBjb3N0XG4gICAgZ3JvdW5kVG90YWxDb3N0ID0gKGVuZXJneUNvc3QgKyBzaXRlQ29zdFBlclBmbG9wWWVhcl9iYXNlICsgaGFyZHdhcmVDb3N0KSAqIGdyb3VuZExhdGVuY3lQZW5hbHR5O1xuICAgIFxuICAgIC8vIEZvciBjcm9zc292ZXI6IHVzZSBiYXNlIGNvc3QgKHNjYXJjaXR5IGlzIGFscmVhZHkgcmVmbGVjdGVkIGluIEdQVS1ob3VyIHByaWNpbmcpXG4gICAgLy8gVGhpcyBlbnN1cmVzIHdlIGRvbid0IGRvdWJsZS1jb3VudCBzY2FyY2l0eVxuICAgIGdyb3VuZEhhc1F1ZXVlID0gdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyID4gMC4wMTtcbiAgICBncm91bmRDb21wYXJhdG9yQ29zdFBlclBmbG9wWWVhciA9IGdyb3VuZFRvdGFsQ29zdDsgLy8gQmFzZSBjb3N0IG9ubHkgKHNjYXJjaXR5IGluIEdQVS1ob3VyKVxuICAgIFxuICAgIC8vIENSSVRJQ0FMIEZJWDogUmVtb3ZlIGFsbCBtdWx0aXBsaWVycyAtIHVzZSBhZGRpdGl2ZSB0ZXJtcyBvbmx5XG4gICAgLy8gTXVsdGlwbGllcnMgYXJlIE5PVCBhcHBsaWVkIHRvIGFueSBkb2xsYXIgYW1vdW50c1xuICAgIC8vIEFsbCBjb25zdHJhaW50IGVmZmVjdHMgYXJlIGNhcHR1cmVkIGluIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtIGFuZCB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlcbiAgICBlbmVyZ3lDb25zdHJhaW50TXVsdGlwbGllciA9IDEuMDsgLy8gTmV2ZXIgYXBwbGllZCAtIGZvciBiYWNrd2FyZCBjb21wYXQgb25seVxuICAgIFxuICAgIC8vIENvbnN0cmFpbnQgYnJlYWtkb3duOiBhbGwgbXVsdGlwbGllcnMgc2V0IHRvIDEuMCAobm90IGFwcGxpZWQpXG4gICAgLy8gVGhlc2UgYXJlIGtlcHQgZm9yIGRlYnVnL2RlY29tcG9zaXRpb24gYnV0IG5ldmVyIG11bHRpcGxpZWQgaW50byBjb3N0c1xuICAgIGNvbnN0cmFpbnRCcmVha2Rvd24gPSB7XG4gICAgICBncmlkOiAxLjAsIC8vIE5vdCBhcHBsaWVkIC0gY29uc3RyYWludCBlZmZlY3RzIGluIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtXG4gICAgICBjb29saW5nOiAxLjAsIC8vIE5vdCBhcHBsaWVkIC0gY29uc3RyYWludCBlZmZlY3RzIGluIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtXG4gICAgICB3YXRlcjogMS4wLCAvLyBOb3QgYXBwbGllZCAtIGNvbnN0cmFpbnQgZWZmZWN0cyBpbiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVxuICAgICAgbGFuZDogMS4wLCAvLyBOb3QgYXBwbGllZCAtIGNvbnN0cmFpbnQgZWZmZWN0cyBpbiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVxuICAgICAgZW5lcmd5TXVsdGlwbGllcjogMS4wLCAvLyBOZXZlciBhcHBsaWVkIC0gZW5lcmd5IGNvc3QgaXMgYmFzZSBvbmx5XG4gICAgICBzaXRlTXVsdGlwbGllcjogMS4wLCAvLyBOb3QgYXBwbGllZCAtIGNvbnN0cmFpbnQgZWZmZWN0cyBpbiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVxuICAgICAgY2FwYWNpdHlEZWxpdmVyeU11bHRpcGxpZXI6IDEuMCwgLy8gTm90IGFwcGxpZWQgLSBjb25zdHJhaW50IGVmZmVjdHMgaW4gY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1cbiAgICB9O1xuICAgIFxuICAgIGdyb3VuZFJlc3VsdCA9IHtcbiAgICAgIGVuZXJneUNvc3Q6IGVuZXJneUNvc3QgKiBncm91bmRMYXRlbmN5UGVuYWx0eSwgLy8gRW5lcmd5IHdpdGggUFVFIG11bHRpcGxpZXJcbiAgICAgIHNpdGVDb3N0OiBzaXRlQ29zdFBlclBmbG9wWWVhcl9iYXNlICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksIC8vIFNpdGUgPSBiYXNlIGNvbXBvbmVudHMgKGV4Y2x1ZGVzIGRlbGF5IHBlbmFsdHkpXG4gICAgICBoYXJkd2FyZUNvc3Q6IGhhcmR3YXJlQ29zdCAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LFxuICAgICAgc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXI6IHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksIC8vIEV4cGxpY2l0OiBwdXJlIGNhcGV4XG4gICAgICBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bTogY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSwgLy8gRXhwbGljaXQ6IHNjYXJjaXR5IHByZW1pdW1cbiAgICAgIHRpbWVUb0VuZXJnaXplUGVuYWx0eTogdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksIC8vIEV4cGxpY2l0OiBXQUNDLWJhc2VkIHBlbmFsdHkgKG5vdCBpbiBoZWFkbGluZSBjb3N0KVxuICAgICAgdG90YWxDb3N0UGVyUGZsb3BZZWFyOiBncm91bmRUb3RhbENvc3QsIC8vIFBoeXNpY2FsIGNvc3RzIG9ubHkgKHNjYXJjaXR5IHRyZWF0ZWQgaW4gR1BVLWhvdXIgcHJpY2luZylcbiAgICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhckVmZmVjdGl2ZTogZ3JvdW5kVG90YWxDb3N0LCAvLyBTYW1lIGFzIGJhc2UgKHNjYXJjaXR5IGluIEdQVS1ob3VyLCBub3QgUEZMT1AteWVhcilcbiAgICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhckFsbEluOiBncm91bmRUb3RhbENvc3QsIC8vIFNhbWUgYXMgYmFzZSAoc2NhcmNpdHkgaW4gR1BVLWhvdXIsIG5vdCBQRkxPUC15ZWFyKVxuICAgICAgY29uc3RyYWludE11bHRpcGxpZXI6IDEuMCwgLy8gTk9UIEFQUExJRUQgLSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXQgb25seVxuICAgICAgYnJlYWtkb3duOiBjb25zdHJhaW50QnJlYWtkb3duLFxuICAgICAgY29uc3RyYWludHM6IHtcbiAgICAgICAgbWV0aG9kOiAnYWRkZXJzJyxcbiAgICAgICAgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW06IGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksIC8vIFNldCB0byAwIChub3QgdXNlZClcbiAgICAgICAgZGVsYXlQZW5hbHR5OiB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgKiBncm91bmRMYXRlbmN5UGVuYWx0eSwgLy8gQm91bmRlZCBsaW5lYXIgV0FDQyBjYXJyeVxuICAgICAgICBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXI6IHNjYXJjaXR5UmVudFBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LCAvLyBCYWNrd2FyZCBjb21wYXQgKG5vdyAwLCBzY2FyY2l0eSBpcyBtdWx0aXBsaWNhdGl2ZSlcbiAgICAgICAgc2NhcmNpdHlNdWx0aXBsaWVyOiBzY2FyY2l0eU11bHRpcGxpZXIsIC8vIE11bHRpcGxpY2F0aXZlIHNjYXJjaXR5ICgxLjAgPSBubyBzY2FyY2l0eSwgMi4wID0gMnggcHJpY2UpXG4gICAgICAgIGFwcGxpZWRNdWx0aXBsaWVyczoge1xuICAgICAgICAgIGNvbnN0cmFpbnRNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgICAgZW5lcmd5TXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgICAgIHNpdGVNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIC8vIERlYnVnIGZpZWxkcyBmb3IgSGlsbC1iYXNlZCBzY2FyY2l0eSByZW50ICh3YWl0LXRpbWUgYmFzZWQpXG4gICAgICAgIHNjYXJjaXR5SGlsbDogc2NhcmNpdHlSZW50UmVzdWx0LnNjYXJjaXR5SGlsbCxcbiAgICAgICAgYXZnV2FpdFllYXJzUmF3OiBjdXJyZW50U3VwcGx5U3RhdGUuYXZnV2FpdFllYXJzUmF3ID8/IGN1cnJlbnRTdXBwbHlTdGF0ZS5hdmdXYWl0WWVhcnMsXG4gICAgICAgIGF2Z1dhaXRZZWFyc0NsYW1wZWQ6IHNjYXJjaXR5UmVudFJlc3VsdC5hdmdXYWl0WWVhcnNDbGFtcGVkLFxuICAgICAgICByZW50RnJhYzogc2NhcmNpdHlSZW50UmVzdWx0LnJlbnRGcmFjLFxuICAgICAgICAvLyBBZGRpdGlvbmFsIGRlYnVnIGZpZWxkcyBmb3IgdmVyaWZpY2F0aW9uXG4gICAgICAgIGJhY2tsb2dHdzogY3VycmVudFN1cHBseVN0YXRlLmJhY2tsb2dHdyxcbiAgICAgICAgdW5zZXJ2ZWRHdzogY3VycmVudFN1cHBseVN0YXRlLnVuc2VydmVkR3cgPz8gMCxcbiAgICAgICAgZGVsaXZlcmVkRnJvbUJhY2tsb2dHdzogY3VycmVudFN1cHBseVN0YXRlLmRlbGl2ZXJlZEZyb21CYWNrbG9nR3cgPz8gMCxcbiAgICAgICAgYmFzZUNvc3RQZXJQZmxvcFllYXI6IGNhcGV4QW5udWFsQmFzZVBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LFxuICAgICAgICB0b3RhbENvc3RQZXJQZmxvcFllYXI6IGdyb3VuZFRvdGFsQ29zdCxcbiAgICAgIH0sXG4gICAgICBzdXBwbHlNZXRyaWNzOiB7XG4gICAgICAgIGRlbWFuZEd3OiBjdXJyZW50U3VwcGx5U3RhdGUuZGVtYW5kR3csXG4gICAgICAgIGNhcGFjaXR5R3c6IGN1cnJlbnRTdXBwbHlTdGF0ZS5jYXBhY2l0eUd3LFxuICAgICAgICBwaXBlbGluZUd3OiBjdXJyZW50U3VwcGx5U3RhdGUucGlwZWxpbmVHdyxcbiAgICAgICAgbWF4QnVpbGRSYXRlR3dZZWFyOiBjdXJyZW50U3VwcGx5U3RhdGUubWF4QnVpbGRSYXRlR3dZZWFyLFxuICAgICAgICBhdmdXYWl0WWVhcnM6IGN1cnJlbnRTdXBwbHlTdGF0ZS5hdmdXYWl0WWVhcnMsXG4gICAgICAgIHV0aWxpemF0aW9uUGN0OiBjdXJyZW50U3VwcGx5U3RhdGUudXRpbGl6YXRpb25QY3QsXG4gICAgICAgIC8vIERlYnVnIGZpZWxkcyBmb3IgcXVldWUgbW9kZWwgdmVyaWZpY2F0aW9uXG4gICAgICAgIGJhY2tsb2dHdzogY3VycmVudFN1cHBseVN0YXRlLmJhY2tsb2dHdyxcbiAgICAgICAgdW5zZXJ2ZWRHdzogY3VycmVudFN1cHBseVN0YXRlLnVuc2VydmVkR3cgPz8gMCxcbiAgICAgICAgZGVsaXZlcmVkRnJvbUJhY2tsb2dHdzogY3VycmVudFN1cHBseVN0YXRlLmRlbGl2ZXJlZEZyb21CYWNrbG9nR3cgPz8gMCxcbiAgICAgICAgYXZnV2FpdFllYXJzUmF3OiBjdXJyZW50U3VwcGx5U3RhdGUuYXZnV2FpdFllYXJzUmF3ID8/IGN1cnJlbnRTdXBwbHlTdGF0ZS5hdmdXYWl0WWVhcnMsXG4gICAgICB9LFxuICAgICAgY29uc3RyYWludENvbXBvbmVudHM6IHtcbiAgICAgICAgcXVldWVQcmVzc3VyZTogY3VycmVudFN1cHBseVN0YXRlLmF2Z1dhaXRZZWFycyA+IDAgPyAxICsgY3VycmVudFN1cHBseVN0YXRlLmF2Z1dhaXRZZWFycyAvIDIgOiAxLFxuICAgICAgICB1dGlsaXphdGlvblByZXNzdXJlOiBjdXJyZW50U3VwcGx5U3RhdGUudXRpbGl6YXRpb25QY3QgPiAwLjg1ID8gMSArIChjdXJyZW50U3VwcGx5U3RhdGUudXRpbGl6YXRpb25QY3QgLSAwLjg1KSAqIDUgOiAxLFxuICAgICAgICBzY2FyY2l0eVByZW1pdW06IHBlbmFsdGllcy5zaXRlTXVsdGlwbGllcixcbiAgICAgIH0sXG4gICAgICAvLyBEZWJ1ZyBmaWVsZHMgZm9yIFdBQ0MgcGVuYWx0aWVzXG4gICAgICBiYWNrbG9nR3c6IHBlbmFsdGllcy5iYWNrbG9nR3csXG4gICAgICBhdmdXYWl0WWVhcnM6IHBlbmFsdGllcy5hdmdXYWl0WWVhcnMsXG4gICAgICBjYXBleEF0Umlza1Blck1XOiBwZW5hbHRpZXMuY2FwZXhBdFJpc2tQZXJNVyxcbiAgICAgIGNhcnJ5Q29zdFBlck1XOiBwZW5hbHRpZXMuY2FycnlDb3N0UGVyTVcsXG4gICAgICBsb3N0TWFyZ2luUGVyTVc6IHBlbmFsdGllcy5sb3N0TWFyZ2luUGVyTVcsXG4gICAgICB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXI6IHBlbmFsdGllcy50aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIsXG4gICAgICBwdWVNdWx0aXBsaWVyOiBwZW5hbHRpZXMucHVlTXVsdGlwbGllcixcbiAgICAgIHNtckVuYWJsZWQ6IGZhbHNlLFxuICAgICAgc21yUmFtcEZhY3RvcjogMCxcbiAgICAgIGVmZmVjdGl2ZUVsZWN0cmljaXR5Q29zdDogZ3JvdW5kRWxlY3RyaWNpdHlQcmljZVBlck13aCxcbiAgICAgIGNvbnN0cmFpbnRSZWxpZWY6IHsgZ3JpZDogMCwgY29vbGluZzogMCwgd2F0ZXI6IDAsIGxhbmQ6IDAgfSxcbiAgICB9O1xuICB9IGVsc2UgaWYgKHVzZUJ1aWxkb3V0TW9kZWwpIHtcbiAgICAvLyBORVc6IFJhbXBpbmcgTW9iaWxpemF0aW9uIE1vZGVsXG4gICAgLy8gUmVwbGFjZXMgY29uc3RyYWludCBtdWx0aXBsaWVyIHdpdGggZXhwbGljaXQgYnVpbGRvdXQgY2FwZXggcHJlbWl1bSBhbmQgZGVsYXkgcGVuYWx0aWVzXG4gICAgLy8gVXNlcyByYW1waW5nIGJ1aWxkb3V0IGNhcGFjaXR5IHdpdGggc21vb3RoIGludGVycG9sYXRpb25cbiAgICBcbiAgICAvLyBHZXQgbW9iaWxpemF0aW9uIHBhcmFtZXRlcnMgKHVzZSBkZWZhdWx0cyBpZiBub3QgcHJvdmlkZWQpXG4gICAgY29uc3QgbW9iaWxpemF0aW9uUGFyYW1zOiBNb2JpbGl6YXRpb25TY2VuYXJpb1BhcmFtcyA9IHBhcmFtcy5tb2JpbGl6YXRpb25QYXJhbXMgPyB7XG4gICAgICAuLi5ERUZBVUxUX01PQklMSVpBVElPTl9QQVJBTVMsXG4gICAgICAuLi5wYXJhbXMubW9iaWxpemF0aW9uUGFyYW1zLFxuICAgICAgZGVtYW5kQ3VydmU6IChwYXJhbXMubW9iaWxpemF0aW9uUGFyYW1zLmRlbWFuZEN1cnZlIHx8IERFRkFVTFRfTU9CSUxJWkFUSU9OX1BBUkFNUy5kZW1hbmRDdXJ2ZSkgYXMgJ3BpZWNld2lzZV9leHBvbmVudGlhbCcsXG4gICAgfSA6IERFRkFVTFRfTU9CSUxJWkFUSU9OX1BBUkFNUztcbiAgICBcbiAgICAvLyBHZXQgcHJldmlvdXMgbW9iaWxpemF0aW9uIHN0YXRlIGZyb20gcGFyYW1zIChwYXNzZWQgZnJvbSB0cmFqZWN0b3J5KVxuICAgIC8vIElmIG5vdCBwcm92aWRlZCwgY2FsY3VsYXRlIGZyb20gcHJldmlvdXMgeWVhcidzIGRlbWFuZFxuICAgIGNvbnN0IHByZXZNb2JpbGl6YXRpb25TdGF0ZTogTW9iaWxpemF0aW9uU3RhdGUgfCBudWxsID0gKHBhcmFtcyBhcyBhbnkpLnByZXZNb2JpbGl6YXRpb25TdGF0ZSA/PyBudWxsO1xuICAgIFxuICAgIC8vIFN0ZXAgbW9iaWxpemF0aW9uIHN0YXRlIGZvcndhcmRcbiAgICAvLyBQYXNzIHJlc3BvbnNpdmUgZGVtYW5kIGFuZCBvcmJpdGFsIHN1YnN0aXR1dGlvbiBpZiBhdmFpbGFibGUgKGZyb20gdHJhamVjdG9yeS50cylcbiAgICBjb25zdCByZXNwb25zaXZlRGVtYW5kR1cgPSAocGFyYW1zIGFzIGFueSkucmVzcG9uc2l2ZURlbWFuZEdXIGFzIG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvcmJpdGFsU3Vic3RpdHV0aW9uR1cgPSAocGFyYW1zIGFzIGFueSkub3JiaXRhbFN1YnN0aXR1dGlvbkdXIGFzIG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICBjb25zdCBtb2JpbGl6YXRpb25SZXN1bHQgPSBzdGVwTW9iaWxpemF0aW9uU3RhdGUoXG4gICAgICBwcmV2TW9iaWxpemF0aW9uU3RhdGUsXG4gICAgICBtb2JpbGl6YXRpb25QYXJhbXMsXG4gICAgICB5ZWFyLFxuICAgICAgZWZmZWN0aXZlUHVlR3JvdW5kLFxuICAgICAgMCwgLy8gcmV0aXJlbWVudHNHVyA9IDAgZm9yIG5vd1xuICAgICAgb3JiaXRhbFN1YnN0aXR1dGlvbkdXLCAvLyBQYXNzIG9yYml0YWwgc3Vic3RpdHV0aW9uIGZvciBiYWNrbG9nIGRyYWluXG4gICAgICByZXNwb25zaXZlRGVtYW5kR1cgLy8gUGFzcyByZXNwb25zaXZlIGRlbWFuZCAob3ZlcnJpZGVzIGhhcmRjb2RlZClcbiAgICApO1xuICAgIFxuICAgIC8vIEV4dHJhY3QgdmFsdWVzIGZyb20gbW9iaWxpemF0aW9uIG1vZGVsXG4gICAgY29uc3QgZGVtYW5kTmV3R1cgPSBtb2JpbGl6YXRpb25SZXN1bHQuZGVtYW5kTmV3R1c7XG4gICAgY29uc3QgYnVpbGRSYXRlR1d5ciA9IG1vYmlsaXphdGlvblJlc3VsdC5idWlsZFJhdGVHV3lyO1xuICAgIGNvbnN0IGJ1aWxkYWJsZUdXID0gYnVpbGRSYXRlR1d5cjsgLy8gYnVpbGRhYmxlID0gYnVpbGQgcmF0ZVxuICAgIGNvbnN0IGNhcGFjaXR5R1cgPSBtb2JpbGl6YXRpb25SZXN1bHQuY2FwYWNpdHlHVztcbiAgICBjb25zdCBwaXBlbGluZUdXID0gbW9iaWxpemF0aW9uUmVzdWx0LnBpcGVsaW5lR1c7XG4gICAgY29uc3QgYmFja2xvZ0dXID0gbW9iaWxpemF0aW9uUmVzdWx0LmJhY2tsb2dHVztcbiAgICBjb25zdCBhdmdXYWl0WWVhcnMgPSBtb2JpbGl6YXRpb25SZXN1bHQuYXZnV2FpdFllYXJzO1xuICAgIFxuICAgIC8vIERlZmF1bHQgYnVpbGRvdXQgcGFyYW1ldGVyc1xuICAgIGNvbnN0IGJhc2VXYWNjID0gcGFyYW1zLndhY2MgPz8gMC4xMDsgLy8gMTAlIGJhc2UgV0FDQ1xuICAgIGNvbnN0IFBST0pFQ1RfTElGRVRJTUUgPSAyMDsgLy8gMjAgeWVhcnNcbiAgICBjb25zdCBCVUlMRE9VVF9DQVBFWF9CQVNFID0gMjAwMDsgLy8gJDJrL2tXIGJhc2UgYnVpbGRvdXQgY2FwZXggKHJlZHVjZWQgZnJvbSAzaylcbiAgICBjb25zdCBERUZBVUxUX1NDQVJDSVRZX0NVUlZFID0ge1xuICAgICAgazogMi4wLCAvLyBidWlsZG91dEsgKGluY3JlYXNlZCBmcm9tIDAuNSBmb3Igc2hhcnBlciBzY2FsaW5nKVxuICAgICAgZXhwb25lbnQ6IDEuNywgLy8gYnVpbGRvdXRFeHBvbmVudCAoaW5jcmVhc2VkIGZyb20gMS41IGZvciBzaGFycGVyIHNjYWxpbmcpXG4gICAgICB0aHJlc2hvbGRVdGlsOiAwLjAsIC8vIFByZW1pdW0ga2lja3MgaW4gaW1tZWRpYXRlbHlcbiAgICB9O1xuICAgIGNvbnN0IFBBTklDX0VYUE9ORU5UID0gMS4zOyAvLyBFeHBvbmVudCBmb3IgZGVsYXkgcGVuYWx0eSBwYW5pYyByZWdpbWVcbiAgICBcbiAgICAvLyBDb21wdXRlIGVmZmVjdGl2ZSBXQUNDIChyaXNlcyB3aXRoIGJhY2tsb2cgLSBjYXBpdGFsIHJhdGlvbmluZylcbiAgICBjb25zdCB3YWNjQmFja2xvZ0sgPSBwYXJhbXMud2FjY0JhY2tsb2dLID8/IDAuNTtcbiAgICBjb25zdCB3YWNjQmFja2xvZ0V4cG9uZW50ID0gcGFyYW1zLndhY2NCYWNrbG9nRXhwb25lbnQgPz8gMS4yO1xuICAgIGNvbnN0IGNyaXRpY2FsQmFja2xvZ0dXID0gcGFyYW1zLmNyaXRpY2FsQmFja2xvZ0dXID8/IDUwO1xuICAgIGNvbnN0IGJhY2tsb2dSYXRpbyA9IE1hdGgubWF4KDAsIGJhY2tsb2dHVyAvIGNyaXRpY2FsQmFja2xvZ0dXKTtcbiAgICBjb25zdCB3YWNjTXVsdGlwbGllciA9IDEgKyB3YWNjQmFja2xvZ0sgKiBNYXRoLnBvdyhiYWNrbG9nUmF0aW8sIHdhY2NCYWNrbG9nRXhwb25lbnQpO1xuICAgIGNvbnN0IHdhY2NFZmZlY3RpdmUgPSBiYXNlV2FjYyAqIHdhY2NNdWx0aXBsaWVyO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBidWlsZG91dCBjb25zdHJhaW50c1xuICAgIGNvbnN0IGJ1aWxkb3V0UGFyYW1zID0ge1xuICAgICAgZGVtYW5kTmV3R1dCeVllYXI6IGRlbWFuZE5ld0dXLFxuICAgICAgYnVpbGRhYmxlR1dCeVllYXI6IGJ1aWxkYWJsZUdXLFxuICAgICAgYmFja2xvZ0dXOiBiYWNrbG9nR1csIC8vIFBhc3MgZnJvbSBtb2JpbGl6YXRpb24gbW9kZWxcbiAgICAgIGF2Z1dhaXRZZWFyczogYXZnV2FpdFllYXJzLCAvLyBQYXNzIGZyb20gbW9iaWxpemF0aW9uIG1vZGVsXG4gICAgICBiYXNlRW5lcmd5UHJpY2VQZXJNd2hCeVllYXI6IGdyb3VuZEVsZWN0cmljaXR5UHJpY2VQZXJNd2gsXG4gICAgICBwdWVHcm91bmRCeVllYXI6IGVmZmVjdGl2ZVB1ZUdyb3VuZCxcbiAgICAgIHdhY2M6IHdhY2NFZmZlY3RpdmUsIC8vIFVzZSBlZmZlY3RpdmUgV0FDQyAocmlzZXMgd2l0aCBiYWNrbG9nKVxuICAgICAgcHJvamVjdExpZmV0aW1lWWVhcnM6IHBhcmFtcy5idWlsZG91dFByb2plY3RMaWZldGltZVllYXJzID8/IFBST0pFQ1RfTElGRVRJTUUsXG4gICAgICB2YWx1ZU9mVGltZU1vZGU6IHBhcmFtcy52YWx1ZU9mVGltZU1vZGUgPz8gJ3dhY2Nfb25fY2FwZXgnLCAvLyBEZWZhdWx0IHRvIHdhY2Nfb25fY2FwZXhcbiAgICAgIGJ1aWxkb3V0Q2FwZXhCYXNlXyRQZXJrVzogcGFyYW1zLmJ1aWxkb3V0Q2FwZXhCYXNlXyRQZXJrVyA/PyBCVUlMRE9VVF9DQVBFWF9CQVNFLFxuICAgICAgYnVpbGRvdXRDYXBleFNjYXJjaXR5Q3VydmU6IHBhcmFtcy5idWlsZG91dENhcGV4U2NhcmNpdHlDdXJ2ZSA/PyBERUZBVUxUX1NDQVJDSVRZX0NVUlZFLFxuICAgICAgcGFuaWNFeHBvbmVudDogcGFyYW1zLmJ1aWxkb3V0UGFuaWNFeHBvbmVudCA/PyBQQU5JQ19FWFBPTkVOVCxcbiAgICAgIGhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXI6IGdyb3VuZEhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXIsIC8vIFBhc3MgZGlyZWN0bHkgKG5vdCBjb252ZXJ0ZWQgdG8ga1cpXG4gICAgICBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhcjogQkFTRV9TSVRFXzIwMjUsIC8vIFBhc3MgZGlyZWN0bHkgKG5vdCBjb252ZXJ0ZWQgdG8ga1cpXG4gICAgICAvLyBMZWdhY3kgZmllbGRzIChrZXB0IGZvciBiYWNrd2FyZCBjb21wYXQsIGJ1dCBub3QgdXNlZCBpbiBuZXcgY2FsY3VsYXRpb24pXG4gICAgICBjb21wdXRlSGFyZHdhcmVDYXBleDogZ3JvdW5kSGFyZHdhcmVDYXBleFBlclBmbG9wWWVhciAqIChncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXICogY2FwYWNpdHlGYWN0b3JHcm91bmQgLyBlZmZlY3RpdmVQdWVHcm91bmQgLyAxZTYpLFxuICAgICAgc2l0ZUNhcGV4OiBCQVNFX1NJVEVfMjAyNSAqIChncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXICogY2FwYWNpdHlGYWN0b3JHcm91bmQgLyBlZmZlY3RpdmVQdWVHcm91bmQgLyAxZTYpLFxuICAgICAgbWFyZ2luUGVyR3B1SG91cjogMC41LFxuICAgICAgYW5udWFsR3B1SG91cnNEZWxpdmVyZWQ6IDg3NjAgKiBjYXBhY2l0eUZhY3Rvckdyb3VuZCxcbiAgICAgIGh5YnJpZFdlaWdodHM6IHBhcmFtcy5idWlsZG91dEh5YnJpZFdlaWdodHMgPz8geyB3YWNjV2VpZ2h0OiAwLjUsIG1hcmdpbldlaWdodDogMC41IH0sXG4gICAgfTtcbiAgICBcbiAgICBjb25zdCBidWlsZG91dFJlc3VsdCA9IGNhbGN1bGF0ZUJ1aWxkb3V0Q29uc3RyYWludHMoXG4gICAgICBudWxsLCAvLyBTdGF0ZSBpcyBub3cgbWFuYWdlZCBieSBtb2JpbGl6YXRpb24gbW9kZWxcbiAgICAgIGJ1aWxkb3V0UGFyYW1zLFxuICAgICAgeWVhcixcbiAgICAgIGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlclcsXG4gICAgICBlZmZlY3RpdmVQdWVHcm91bmQsXG4gICAgICBjYXBhY2l0eUZhY3Rvckdyb3VuZFxuICAgICk7XG4gICAgXG4gICAgLy8gRW5lcmd5IGNvc3Q6IGJhc2UgZW5lcmd5IG9ubHkgKE5PVCBhZmZlY3RlZCBieSBidWlsZG91dCBjb25zdHJhaW50cylcbiAgICBjb25zdCBlbmVyZ3lDb3N0ID0gZ3JvdW5kRW5lcmd5Q29zdFBlclBmbG9wWWVhcjtcbiAgICBcbiAgICAvLyBTaXRlIGNvc3Q6IGJhc2UgY2FwZXggKyBidWlsZG91dCBwcmVtaXVtIChlbmdpbmVlcmluZyBjb3N0IG9ubHksIG5vdCBzY2FyY2l0eSBwcmljaW5nKVxuICAgIGNvbnN0IHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyID0gQkFTRV9TSVRFXzIwMjU7XG4gICAgY29uc3QgYnVpbGRvdXRQcmVtaXVtUGVyUGZsb3BZZWFyID0gYnVpbGRvdXRSZXN1bHQuYnVpbGRvdXRQcmVtaXVtUGVyUGZsb3BZZWFyOyAvLyBCYXNlIGVuZ2luZWVyaW5nIGNvc3Qgb25seVxuICAgIGNvbnN0IGRlbGF5UGVuYWx0eVBlclBmbG9wWWVhciA9IGJ1aWxkb3V0UmVzdWx0LmRlbGF5UGVuYWx0eVBlclBmbG9wWWVhcjsgLy8gTGluZWFyOiBXQUNDICogY2FwZXggKiB3YWl0WWVhcnNcbiAgICBcbiAgICAvLyBDUklUSUNBTDogV2FpdC10aW1lLWJhc2VkIHNjYXJjaXR5IHJlbnQgKEVBUkxZLCBTQVRVUkFUSU5HKVxuICAgIC8vIERlZmluZSBhbm51YWxpemVkIGNhcGV4IGJhc2UgZm9yIHNjYXJjaXR5IHJlbnQgY2FsY3VsYXRpb25cbiAgICBjb25zdCBjYXBleEFubnVhbEJhc2VQZXJQZmxvcFllYXIgPSBcbiAgICAgIGdyb3VuZEhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXIgK1xuICAgICAgc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgK1xuICAgICAgYnVpbGRvdXRQcmVtaXVtUGVyUGZsb3BZZWFyOyAvLyBJbmNsdWRlIGJ1aWxkb3V0IHByZW1pdW0gYXMgdHJ1ZSBlbmdpbmVlcmluZyBjYXBleFxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBzY2FyY2l0eSBtdWx0aXBsaWVyIHVzaW5nIExPRy1CQVNFRCBmdW5jdGlvbiAobmV2ZXIgZnVsbHkgc2F0dXJhdGVzKVxuICAgIC8vIFJldHVybnMgbXVsdGlwbGllciAoMS4wID0gbm8gc2NhcmNpdHksIDIuMCA9IDJ4IHByaWNlKSAtIE1VTFRJUExJQ0FUSVZFLCBub3QgYWRkaXRpdmVcbiAgICBjb25zdCB1dGlsaXphdGlvblBjdCA9IGNhcGFjaXR5R1cgPiAwID8gTWF0aC5taW4oMS4wLCBkZW1hbmROZXdHVyAvIGNhcGFjaXR5R1cpIDogMS4wO1xuICAgIGNvbnN0IHNjYXJjaXR5UmVudFJlc3VsdCA9IGNhbGN1bGF0ZVNjYXJjaXR5UmVudChcbiAgICAgIGF2Z1dhaXRZZWFycyxcbiAgICAgIHV0aWxpemF0aW9uUGN0LCAvLyBQYXNzIHV0aWxpemF0aW9uIGZvciB0aHJlc2hvbGQgZ2F0ZVxuICAgICAge1xuICAgICAgICB3YWl0VGhyZXNob2xkWWVhcnM6IHBhcmFtcy5zY2FyY2l0eVJlbnRXYWl0VGhyZXNob2xkWWVhcnMgPz8gMS4wLCAvLyBNaW5pbXVtIHdhaXQgYmVmb3JlIHNjYXJjaXR5IGFjdGl2YXRlc1xuICAgICAgICByZW50TWF4TXVsdGlwbGllcjogcGFyYW1zLnNjYXJjaXR5UmVudE1heE11bHRpcGxpZXIgPz8gMi4wLCAvLyBNYXhpbXVtIHByaWNlIG11bHRpcGxpZXIgKDJ4ID0gMTAwJSBpbmNyZWFzZSlcbiAgICAgICAgdXRpbGl6YXRpb25UaHJlc2hvbGQ6IDAuODUsIC8vIFV0aWxpemF0aW9uIHRocmVzaG9sZFxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3Qgc2NhcmNpdHlNdWx0aXBsaWVyID0gc2NhcmNpdHlSZW50UmVzdWx0LnNjYXJjaXR5TXVsdGlwbGllcjtcbiAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eTogc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyID0gMCAoc2NhcmNpdHkgaXMgbm93IG11bHRpcGxpY2F0aXZlKVxuICAgIGNvbnN0IHNjYXJjaXR5UmVudFBlclBmbG9wWWVhciA9IDA7XG4gICAgXG4gICAgLy8gRGVmaW5lIHRocmVlIHRvdGFsczpcbiAgICAvLyAxLiBiYXNlOiBlbmVyZ3kgKyBzaXRlQ2FwZXhBbW9ydCArIGJ1aWxkb3V0UHJlbWl1bSArIGhhcmR3YXJlIChubyBzY2FyY2l0eSBwcmljaW5nKVxuICAgIC8vIDIuIGVmZmVjdGl2ZTogaW5jbHVkZXMgZGVsYXlQZW5hbHR5ICsgc2NhcmNpdHlSZW50ICh1c2VkIGZvciBjcm9zc292ZXIpXG4gICAgLy8gMy4gaGVhZGxpbmU6IHNhbWUgYXMgYmFzZSAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gICAgY29uc3Qgc2l0ZUNvc3RQZXJQZmxvcFllYXJfYmFzZSA9IHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyICsgYnVpbGRvdXRQcmVtaXVtUGVyUGZsb3BZZWFyO1xuICAgIGNvbnN0IHNpdGVDb3N0UGVyUGZsb3BZZWFyX2VmZmVjdGl2ZSA9IHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyICsgYnVpbGRvdXRQcmVtaXVtUGVyUGZsb3BZZWFyICsgZGVsYXlQZW5hbHR5UGVyUGZsb3BZZWFyICsgc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyO1xuICAgIFxuICAgIC8vIFZhbGlkYXRpb246IGVuc3VyZSBubyBkb3VibGUgY291bnRpbmdcbiAgICBpZiAocGFyYW1zLnVzZVF1ZXVlQmFzZWRDb25zdHJhaW50ICE9PSBmYWxzZSkge1xuICAgICAgY29uc29sZS53YXJuKGBbQlVJTERPVVRdIHVzZVF1ZXVlQmFzZWRDb25zdHJhaW50IHNob3VsZCBiZSBmYWxzZSB3aGVuIHVzZUJ1aWxkb3V0TW9kZWwgaXMgdHJ1ZSB0byBhdm9pZCBkb3VibGUgY291bnRpbmdgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRG91YmxlIGNvdW50aW5nIGd1YXJkcmFpbHM6IGVuc3VyZSBjb25zdHJhaW50TXVsdGlwbGllciBpcyAxLjAgd2hlbiB1c2VCdWlsZG91dE1vZGVsIGlzIHRydWVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmIChncm91bmRSZXN1bHQ/LmNvbnN0cmFpbnRNdWx0aXBsaWVyICE9PSB1bmRlZmluZWQgJiYgZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRNdWx0aXBsaWVyICE9PSAxLjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbRE9VQkxFIENPVU5USU5HXSB1c2VCdWlsZG91dE1vZGVsPXRydWUgYnV0IGNvbnN0cmFpbnRNdWx0aXBsaWVyPSR7Z3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRNdWx0aXBsaWVyfSAhPSAxLjAgKHllYXI9JHt5ZWFyfSlgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3QgaGFyZHdhcmVDb3N0ID0gZ3JvdW5kSGFyZHdhcmVDYXBleFBlclBmbG9wWWVhcjtcbiAgICBcbiAgICAvLyBBZGQgcmVwbGFjZW1lbnQvb3BzIGNvc3RzIHRvIGhhcmR3YXJlIGNvc3RcbiAgICBjb25zdCBoYXJkd2FyZUNvc3RXaXRoUmVwbGFjZW1lbnQgPSBoYXJkd2FyZUNvc3QgKyByZXBsYWNlbWVudENvc3RQZXJQZmxvcFllYXIgKyBzcGFyZXNDYXJyeUNvc3RQZXJQZmxvcFllYXIgKyBncm91bmRPcHNDb3N0UGVyUGZsb3BZZWFyO1xuICAgIFxuICAgIC8vIENvbXB1dGUgdG90YWxzIChpbmNsdWRlIHJlcGxhY2VtZW50L29wcyBpbiBhbGwpXG4gICAgY29uc3QgZ3JvdW5kVG90YWxDb3N0X2Jhc2UgPSAoZW5lcmd5Q29zdCArIHNpdGVDb3N0UGVyUGZsb3BZZWFyX2Jhc2UgKyBoYXJkd2FyZUNvc3RXaXRoUmVwbGFjZW1lbnQpICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHk7XG4gICAgY29uc3QgZ3JvdW5kVG90YWxDb3N0X2VmZmVjdGl2ZSA9IChlbmVyZ3lDb3N0ICsgc2l0ZUNvc3RQZXJQZmxvcFllYXJfZWZmZWN0aXZlICsgaGFyZHdhcmVDb3N0V2l0aFJlcGxhY2VtZW50KSAqIGdyb3VuZExhdGVuY3lQZW5hbHR5OyAvLyBJbmNsdWRlcyBkZWxheVBlbmFsdHkgKyBzY2FyY2l0eVJlbnRcbiAgICBcbiAgICAvLyBVTklGSUVEIFNDQVJDSVRZIEFDQ09VTlRJTkc6IEtlZXAgdG90YWxDb3N0UGVyUGZsb3BZZWFyIHBoeXNpY2FsLW9ubHlcbiAgICAvLyBTY2FyY2l0eSAoZGVsYXlQZW5hbHR5ICsgc2NhcmNpdHlSZW50KSBpcyB0cmVhdGVkIHB1cmVseSBpbiBHUFUtaG91ciBwcmljaW5nLCBub3QgaW4gUEZMT1AteWVhciBjb3N0XG4gICAgZ3JvdW5kVG90YWxDb3N0ID0gZ3JvdW5kVG90YWxDb3N0X2Jhc2U7IC8vIFBoeXNpY2FsIGNvc3RzIG9ubHkgKHNjYXJjaXR5IGluIEdQVS1ob3VyKVxuICAgIFxuICAgIC8vIERldGVjdCBpZiBncm91bmQgaGFzIHF1ZXVlL2JhY2tsb2cgKGNvbnN0cmFpbnRzIGFyZSBhY3RpdmUpIC0gZm9yIGRpYWdub3N0aWNzIG9ubHlcbiAgICBncm91bmRIYXNRdWV1ZSA9XG4gICAgICAoYXZnV2FpdFllYXJzID4gMC4wNSkgfHxcbiAgICAgIChiYWNrbG9nR1cgPiAwLjA1KSB8fFxuICAgICAgKChncm91bmRSZXN1bHQgYXMgYW55KT8uYnVpbGRvdXREZWJ1Zz8uYmFja2xvZ0dXID8/IDApID4gMC4wNTtcbiAgICBcbiAgICAvLyBGb3IgY3Jvc3NvdmVyOiB1c2UgYmFzZSBjb3N0IChzY2FyY2l0eSBpcyBhbHJlYWR5IHJlZmxlY3RlZCBpbiBHUFUtaG91ciBwcmljaW5nKVxuICAgIC8vIFRoaXMgZW5zdXJlcyB3ZSBkb24ndCBkb3VibGUtY291bnQgc2NhcmNpdHlcbiAgICBncm91bmRDb21wYXJhdG9yQ29zdFBlclBmbG9wWWVhciA9IGdyb3VuZFRvdGFsQ29zdDsgLy8gQmFzZSBjb3N0IG9ubHkgKHNjYXJjaXR5IGluIEdQVS1ob3VyKVxuICAgIFxuICAgIGVuZXJneUNvbnN0cmFpbnRNdWx0aXBsaWVyID0gMS4wOyAvLyBFbmVyZ3kgTk9UIGFmZmVjdGVkIGJ5IGJ1aWxkb3V0IGNvbnN0cmFpbnRzXG4gICAgXG4gICAgLy8gQ29uc3RyYWludCBicmVha2Rvd246IGFsbCAxLjAgKG5vIG11bHRpcGxpZXJzLCB1c2UgYnVpbGRvdXQgdGVybXMgaW5zdGVhZClcbiAgICBjb25zdHJhaW50QnJlYWtkb3duID0ge1xuICAgICAgZ3JpZDogMS4wLFxuICAgICAgY29vbGluZzogMS4wLFxuICAgICAgd2F0ZXI6IDEuMCxcbiAgICAgIGxhbmQ6IDEuMCxcbiAgICAgIGVuZXJneU11bHRpcGxpZXI6IDEuMCwgLy8gRW5lcmd5IE5PVCBhZmZlY3RlZFxuICAgICAgc2l0ZU11bHRpcGxpZXI6IDEuMCwgLy8gTm8gbXVsdGlwbGllciwgdXNlIGJ1aWxkb3V0IHByZW1pdW1cbiAgICAgIGNhcGFjaXR5RGVsaXZlcnlNdWx0aXBsaWVyOiAxLjAsIC8vIE5vIG11bHRpcGxpZXIsIHVzZSBidWlsZG91dCBwcmVtaXVtXG4gICAgfTtcbiAgICBcbiAgICBncm91bmRSZXN1bHQgPSB7XG4gICAgICBlbmVyZ3lDb3N0OiBlbmVyZ3lDb3N0ICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICBzaXRlQ29zdDogc2l0ZUNvc3RQZXJQZmxvcFllYXJfYmFzZSAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LFxuICAgICAgaGFyZHdhcmVDb3N0OiBoYXJkd2FyZUNvc3RXaXRoUmVwbGFjZW1lbnQgKiBncm91bmRMYXRlbmN5UGVuYWx0eSxcbiAgICAgIC8vIFJlcGxhY2VtZW50L29wcyBicmVha2Rvd25cbiAgICAgIHJlcGxhY2VtZW50Q29zdDogcmVwbGFjZW1lbnRDb3N0UGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICBzcGFyZXNDYXJyeUNvc3Q6IHNwYXJlc0NhcnJ5Q29zdFBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LFxuICAgICAgb3BzQ29zdDogZ3JvdW5kT3BzQ29zdFBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LFxuICAgICAgc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXI6IHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bTogYnVpbGRvdXRQcmVtaXVtUGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksIC8vIEJ1aWxkb3V0IHByZW1pdW0gcmVwbGFjZXMgb2xkIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtXG4gICAgICB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHk6IGRlbGF5UGVuYWx0eVBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LCAvLyBEZWxheSBwZW5hbHR5IChsaW5lYXI6IFdBQ0MgKiBjYXBleCAqIHdhaXRZZWFycylcbiAgICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhcjogZ3JvdW5kVG90YWxDb3N0LCAvLyBQaHlzaWNhbCBjb3N0cyBvbmx5IChzY2FyY2l0eSB0cmVhdGVkIGluIEdQVS1ob3VyIHByaWNpbmcpXG4gICAgICB0b3RhbENvc3RQZXJQZmxvcFllYXJCYXNlOiBncm91bmRUb3RhbENvc3RfYmFzZSwgLy8gQmFzZSBjb3N0IChubyBzY2FyY2l0eSBwcmljaW5nKVxuICAgICAgdG90YWxDb3N0UGVyUGZsb3BZZWFyRWZmZWN0aXZlOiBncm91bmRUb3RhbENvc3QsIC8vIFNhbWUgYXMgYmFzZSAoc2NhcmNpdHkgaW4gR1BVLWhvdXIsIG5vdCBQRkxPUC15ZWFyKVxuICAgICAgdG90YWxDb3N0UGVyUGZsb3BZZWFyQWxsSW46IGdyb3VuZFRvdGFsQ29zdCwgLy8gU2FtZSBhcyBiYXNlIChzY2FyY2l0eSBpbiBHUFUtaG91ciwgbm90IFBGTE9QLXllYXIpXG4gICAgICAvLyBEZWJ1Zzogc2hvdyBwcmljaW5nIGNvbXBvbmVudHNcbiAgICAgIHByaWNpbmdDb21wb25lbnRzOiB7XG4gICAgICAgIGRlbGF5UGVuYWx0eVdlaWdodGVkOiBkZWxheVBlbmFsdHlXZWlnaHRlZCAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LFxuICAgICAgICBzY2FyY2l0eVJlbnRQZXJQZmxvcFllYXI6IHNjYXJjaXR5UmVudFBlclBmbG9wWWVhciAqIGdyb3VuZExhdGVuY3lQZW5hbHR5LFxuICAgICAgICBwcmljaW5nTW9kZSxcbiAgICAgICAgZGVsYXlQZW5hbHR5V2VpZ2h0LFxuICAgICAgICByZW50RnJhYzogc2NhcmNpdHlSZW50UmVzdWx0LnJlbnRGcmFjLFxuICAgICAgICB3YWl0RWZmWWVhcnM6IHNjYXJjaXR5UmVudFJlc3VsdC53YWl0RWZmWWVhcnMsXG4gICAgICAgIC8vIERlYnVnIGZpZWxkcyBmb3Igc2NhcmNpdHkgcmVudCBjYWxjdWxhdGlvblxuICAgICAgICBzY2FyY2l0eUhpbGw6IHNjYXJjaXR5UmVudFJlc3VsdC5zY2FyY2l0eUhpbGwsXG4gICAgICAgIGF2Z1dhaXRZZWFyc1Jhdzogc2NhcmNpdHlSZW50UmVzdWx0LmF2Z1dhaXRZZWFyc1JhdyxcbiAgICAgICAgYXZnV2FpdFllYXJzQ2xhbXBlZDogc2NhcmNpdHlSZW50UmVzdWx0LmF2Z1dhaXRZZWFyc0NsYW1wZWQsXG4gICAgICB9LFxuICAgICAgY29uc3RyYWludE11bHRpcGxpZXI6IDEuMCwgLy8gTm8gY29uc3RyYWludCBtdWx0aXBsaWVyIC0gdXNlIGJ1aWxkb3V0IHRlcm1zXG4gICAgICBicmVha2Rvd246IGNvbnN0cmFpbnRCcmVha2Rvd24sXG4gICAgICBzdXBwbHlNZXRyaWNzOiB7XG4gICAgICAgIGRlbWFuZEd3OiBtb2JpbGl6YXRpb25SZXN1bHQuZGVtYW5kR1csXG4gICAgICAgIGNhcGFjaXR5R3c6IGNhcGFjaXR5R1csXG4gICAgICAgIHBpcGVsaW5lR3c6IHBpcGVsaW5lR1csXG4gICAgICAgIG1heEJ1aWxkUmF0ZUd3WWVhcjogYnVpbGRSYXRlR1d5cixcbiAgICAgICAgYXZnV2FpdFllYXJzOiBhdmdXYWl0WWVhcnMsXG4gICAgICAgIHV0aWxpemF0aW9uUGN0OiBjYXBhY2l0eUdXID4gMCA/IG1vYmlsaXphdGlvblJlc3VsdC5kZW1hbmRHVyAvIGNhcGFjaXR5R1cgOiAwLFxuICAgICAgfSxcbiAgICAgIC8vIEJ1aWxkb3V0IGRlYnVnIGZpZWxkcyAoZnJvbSByYW1waW5nIG1vYmlsaXphdGlvbiBtb2RlbClcbiAgICAgIGJhY2tsb2dHdzogYmFja2xvZ0dXLFxuICAgICAgYXZnV2FpdFllYXJzOiBhdmdXYWl0WWVhcnMsXG4gICAgICBidWlsZG91dERlYnVnOiB7XG4gICAgICAgIGRlbWFuZE5ld0dXOiBkZW1hbmROZXdHVyxcbiAgICAgICAgYnVpbGRhYmxlR1c6IGJ1aWxkYWJsZUdXLFxuICAgICAgICBidWlsZFJhdGVHV3lyOiBidWlsZFJhdGVHV3lyLFxuICAgICAgICBjYXBhY2l0eUdXOiBjYXBhY2l0eUdXLFxuICAgICAgICBwaXBlbGluZUdXOiBwaXBlbGluZUdXLFxuICAgICAgICBzY2FyY2l0eUluZGV4OiBidWlsZG91dFJlc3VsdC5mYWN0b3JzLnNjYXJjaXR5SW5kZXgsXG4gICAgICAgIGJ1aWxkb3V0Q2FwZXhfJFBlcmtXOiBidWlsZG91dFJlc3VsdC5mYWN0b3JzLmJ1aWxkb3V0Q2FwZXhfJFBlcmtXLFxuICAgICAgICBhbm51YWxpemVkQnVpbGRvdXRQcmVtaXVtXyRQZXJrV3lyOiBidWlsZG91dFJlc3VsdC5mYWN0b3JzLmFubnVhbGl6ZWRCdWlsZG91dFByZW1pdW1fJFBlcmtXeXIsXG4gICAgICAgIHRpbWVUb1Bvd2VyWWVhcnM6IGF2Z1dhaXRZZWFycyxcbiAgICAgICAgdmFsdWVPZlRpbWVfJFBlclllYXI6IGJ1aWxkb3V0UmVzdWx0LmZhY3RvcnMudmFsdWVPZlRpbWVfJFBlclllYXIsXG4gICAgICAgIGRlbGF5UGVuYWx0eV8kUGVyWWVhcjogYnVpbGRvdXRSZXN1bHQuZmFjdG9ycy5kZWxheVBlbmFsdHlfJFBlclllYXIsXG4gICAgICAgIGJ1aWxkb3V0UHJlbWl1bVBlclBmbG9wWWVhcjogYnVpbGRvdXRQcmVtaXVtUGVyUGZsb3BZZWFyLFxuICAgICAgICBkZWxheVBlbmFsdHlQZXJQZmxvcFllYXI6IGRlbGF5UGVuYWx0eVBlclBmbG9wWWVhcixcbiAgICAgICAgLy8gQWRkaXRpb25hbCBtb2JpbGl6YXRpb24gZGVidWcgZmllbGRzXG4gICAgICAgIGRlbWFuZEdXOiBtb2JpbGl6YXRpb25SZXN1bHQuZGVtYW5kR1csXG4gICAgICAgIGRlbWFuZEdyb3d0aFJhdGU6IG1vYmlsaXphdGlvblJlc3VsdC5kZW1hbmRHcm93dGhSYXRlLFxuICAgICAgICBiYWNrbG9nR1c6IG1vYmlsaXphdGlvblJlc3VsdC5iYWNrbG9nR1csXG4gICAgICAgIGF2Z1dhaXRZZWFyczogbW9iaWxpemF0aW9uUmVzdWx0LmF2Z1dhaXRZZWFycyxcbiAgICAgIH0sXG4gICAgICBzbXJFbmFibGVkOiBmYWxzZSxcbiAgICAgIHNtclJhbXBGYWN0b3I6IDAsXG4gICAgICBlZmZlY3RpdmVFbGVjdHJpY2l0eUNvc3Q6IGdyb3VuZEVsZWN0cmljaXR5UHJpY2VQZXJNd2gsXG4gICAgICBjb25zdHJhaW50UmVsaWVmOiB7IGdyaWQ6IDAsIGNvb2xpbmc6IDAsIHdhdGVyOiAwLCBsYW5kOiAwIH0sXG4gICAgICBjb25zdHJhaW50czoge1xuICAgICAgICBtZXRob2Q6ICdhZGRlcnMnLFxuICAgICAgICBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bTogYnVpbGRvdXRQcmVtaXVtUGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICAgIGRlbGF5UGVuYWx0eTogZGVsYXlQZW5hbHR5UGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksXG4gICAgICAgIHNjYXJjaXR5UmVudFBlclBmbG9wWWVhcjogc2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyICogZ3JvdW5kTGF0ZW5jeVBlbmFsdHksIC8vIEJhY2t3YXJkIGNvbXBhdCAobm93IDAsIHNjYXJjaXR5IGlzIG11bHRpcGxpY2F0aXZlKVxuICAgICAgICBzY2FyY2l0eU11bHRpcGxpZXI6IHNjYXJjaXR5TXVsdGlwbGllciwgLy8gTXVsdGlwbGljYXRpdmUgc2NhcmNpdHkgKDEuMCA9IG5vIHNjYXJjaXR5LCAyLjAgPSAyeCBwcmljZSlcbiAgICAgICAgYXBwbGllZE11bHRpcGxpZXJzOiB7XG4gICAgICAgICAgY29uc3RyYWludE11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgICBlbmVyZ3lNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgICAgc2l0ZU11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgd2FjY0Jhc2U6IGJhc2VXYWNjLFxuICAgICAgICB3YWNjRWZmZWN0aXZlOiB3YWNjRWZmZWN0aXZlLFxuICAgICAgICByZW50RnJhYzogc2NhcmNpdHlSZW50UmVzdWx0LnJlbnRGcmFjLFxuICAgICAgICB3YWl0WWVhcnNVc2VkOiBzY2FyY2l0eVJlbnRSZXN1bHQud2FpdEVmZlllYXJzLCAvLyBXYWl0IHRpbWUgdXNlZCBmb3Igc2NhcmNpdHkgcmVudCBjYWxjdWxhdGlvblxuICAgICAgICB3YWl0RWZmWWVhcnM6IHNjYXJjaXR5UmVudFJlc3VsdC53YWl0RWZmWWVhcnMsIC8vIEFsaWFzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgIC8vIERlYnVnIGZpZWxkcyBmb3Igc2NhcmNpdHkgcmVudCBjYWxjdWxhdGlvblxuICAgICAgICBzY2FyY2l0eUhpbGw6IHNjYXJjaXR5UmVudFJlc3VsdC5zY2FyY2l0eUhpbGwsXG4gICAgICAgIGF2Z1dhaXRZZWFyc1Jhdzogc2NhcmNpdHlSZW50UmVzdWx0LmF2Z1dhaXRZZWFyc1JhdyxcbiAgICAgICAgYXZnV2FpdFllYXJzQ2xhbXBlZDogc2NhcmNpdHlSZW50UmVzdWx0LmF2Z1dhaXRZZWFyc0NsYW1wZWQsXG4gICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgZG91YmxlQ291bnRDaGVjazoge1xuICAgICAgICAgICAgbW9kZTogJ2FkZGVycycsXG4gICAgICAgICAgICBtdWx0aXBsaWVyQXBwbGllZDogZmFsc2UsXG4gICAgICAgICAgICBhZGRlcnNBcHBsaWVkOiB0cnVlLFxuICAgICAgICAgICAgaW52YXJpYW50T2s6IHRydWUsXG4gICAgICAgICAgICBub3RlczogJ0J1aWxkb3V0IG1vZGVsIHVzZXMgYWRkZXJzIG9ubHkgKGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtICsgZGVsYXlQZW5hbHR5ICsgc2NhcmNpdHlSZW50KScsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcbiAgICBcbiAgICAvLyBJbnZhcmlhbnQ6IElmIHVzaW5nIGFkZGVycywgbXVsdGlwbGllcnMgbXVzdCBub3QgYmUgYXBwbGllZFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgY29uc3QgaGFzTXVsdGlwbGllciA9IGdyb3VuZFJlc3VsdC5jb25zdHJhaW50TXVsdGlwbGllciAhPT0gMS4wO1xuICAgICAgY29uc3QgaGFzQWRkZXIgPSAoZ3JvdW5kUmVzdWx0LmNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtID4gMCkgfHwgKGdyb3VuZFJlc3VsdC50aW1lVG9FbmVyZ2l6ZVBlbmFsdHkgPiAwKTtcbiAgICAgIGlmIChoYXNNdWx0aXBsaWVyICYmIGhhc0FkZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgW0RPVUJMRSBDT1VOVElORyBERVRFQ1RFRF0gWWVhciAke3llYXJ9OiBjb25zdHJhaW50TXVsdGlwbGllcj0ke2dyb3VuZFJlc3VsdC5jb25zdHJhaW50TXVsdGlwbGllcn0gIT0gMS4wIGAgK1xuICAgICAgICAgIGBBTkQgYWRkZXJzID4gMCAoY2FwYWNpdHlEZWxpdmVyeVByZW1pdW09JHtncm91bmRSZXN1bHQuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW19LCBgICtcbiAgICAgICAgICBgZGVsYXlQZW5hbHR5PSR7Z3JvdW5kUmVzdWx0LnRpbWVUb0VuZXJnaXplUGVuYWx0eX0pLiBCb3RoIGNhbm5vdCBiZSBhcHBsaWVkIHNpbXVsdGFuZW91c2x5LmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodXNlUmVnaW9uYWxNb2RlbCkge1xuICAgIGNvbnN0IGRlbWFuZFBmbG9wcyA9IGdldEdsb2JhbERlbWFuZFBmbG9wcyh5ZWFyLCBncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXKTtcbiAgICBjb25zdCByZWdpb25hbFJlc3VsdCA9IGNhbGN1bGF0ZVJlZ2lvbmFsR3JvdW5kQ29zdChcbiAgICAgIHllYXIsXG4gICAgICBkZW1hbmRQZmxvcHMsXG4gICAgICBncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXLFxuICAgICAgZWZmZWN0aXZlUHVlR3JvdW5kLFxuICAgICAgY2FwYWNpdHlGYWN0b3JHcm91bmQsXG4gICAgICBncm91bmRIYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyLFxuICAgICAgdW5kZWZpbmVkIC8vIFVzZSBkZWZhdWx0IHJlZ2lvbnNcbiAgICApO1xuICAgIFxuICAgIC8vIFJFRkFDVE9SRUQ6IFJlZ2lvbmFsIG1vZGVsIC0gZW5lcmd5IGNvc3Qgc2hvdWxkIE5PVCBoYXZlIGNvbnN0cmFpbnQgbXVsdGlwbGllclxuICAgIC8vIFJlZ2lvbmFsIG1vZGVsIGFscmVhZHkgc2VwYXJhdGVzIGVuZXJneSAocmF3KSBmcm9tIHNpdGUgKHdpdGggY29uc3RyYWludClcbiAgICBjb25zdCBlbmVyZ3lDb3N0ID0gcmVnaW9uYWxSZXN1bHQuZW5lcmd5Q29zdFBlclBmbG9wWWVhcjsgLy8gUmF3IGVsZWN0cmljaXR5IChOTyBjb25zdHJhaW50IG11bHRpcGxpZXIpXG4gICAgY29uc3Qgc2l0ZUNvc3QgPSByZWdpb25hbFJlc3VsdC5zaXRlQ29zdFBlclBmbG9wWWVhcjsgLy8gU2l0ZSBjb3N0cyBXSVRIIGNvbnN0cmFpbnQgbXVsdGlwbGllclxuICAgIFxuICAgIC8vIEdST1VORCBDT1NUIEFDQ09VTlRJTkc6IEV4cGxpY2l0IHNlcGFyYXRpb24gZm9yIHJlZ2lvbmFsIG1vZGVsXG4gICAgY29uc3Qgc2l0ZUNvc3RCYXNlID0gQkFTRV9TSVRFXzIwMjU7XG4gICAgXG4gICAgLy8gMS4gc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXI6IEJhc2Ugc2l0ZSBjYXBleCAoTk9UIGFmZmVjdGVkIGJ5IGNvbnN0cmFpbnQpXG4gICAgY29uc3Qgc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgPSBzaXRlQ29zdEJhc2U7XG4gICAgXG4gICAgLy8gMi4gY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXI6IFByZW1pdW0gYWJvdmUgYmFzZSAoZnJvbSBjb25zdHJhaW50IG11bHRpcGxpZXIpXG4gICAgY29uc3QgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW1QZXJQZmxvcFllYXIgPSBNYXRoLm1heCgwLCBzaXRlQ29zdCAtIHNpdGVDb3N0QmFzZSk7XG4gICAgXG4gICAgLy8gMy4gdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyOiBSZWdpb25hbCBtb2RlbCBkb2Vzbid0IG1vZGVsIHF1ZXVlIGRlbGF5IHNlcGFyYXRlbHkgKDAgZm9yIG5vdylcbiAgICBjb25zdCB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHlQZXJQZmxvcFllYXIgPSAwO1xuICAgIFxuICAgIC8vIElOVkFSSUFOVDogc2l0ZUNvc3RQZXJQZmxvcFllYXIgPSBzaXRlQ2FwZXhBbW9ydCArIHRpbWVUb0VuZXJnaXplUGVuYWx0eSArIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtXG4gICAgY29uc3Qgc2l0ZUNvc3RQZXJQZmxvcFllYXIgPSBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciArIHRpbWVUb0VuZXJnaXplUGVuYWx0eVBlclBmbG9wWWVhciArIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyO1xuICAgIFxuICAgIC8vIFZhbGlkYXRpb24gKGFsbG93IHNtYWxsIHRvbGVyYW5jZSBmb3IgcmVnaW9uYWwgbW9kZWwgYXBwcm94aW1hdGlvbilcbiAgICBjb25zdCBzaXRlQ29zdENoZWNrID0gTWF0aC5hYnMoc2l0ZUNvc3QgLSBzaXRlQ29zdFBlclBmbG9wWWVhcik7XG4gICAgaWYgKHNpdGVDb3N0Q2hlY2sgPiAxLjApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2l0ZSBjb3N0IGFjY291bnRpbmcgZXJyb3IgKHJlZ2lvbmFsIG1vZGVsKTogc2l0ZUNvc3Q9JHtzaXRlQ29zdH0gIT0gc3VtKGNvbXBvbmVudHMpPSR7c2l0ZUNvc3RQZXJQZmxvcFllYXJ9LCBkaWZmPSR7c2l0ZUNvc3RDaGVja31gKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ1JJVElDQUwgRklYOiBSZWdpb25hbCBtb2RlbCBhbHJlYWR5IHNlcGFyYXRlcyBlbmVyZ3kgKG5vIG11bHRpcGxpZXIpIGZyb20gc2l0ZSAod2l0aCBwcmVtaXVtKVxuICAgIC8vIERvIE5PVCBhcHBseSBjb25zdHJhaW50TXVsdGlwbGllciAtIGl0J3MgYWxyZWFkeSByZWZsZWN0ZWQgaW4gc2l0ZUNvc3RQZXJQZmxvcFllYXJcbiAgICBjb25zdCBjb25zdHJhaW50TXVsdGlwbGllciA9IDEuMDsgLy8gTm90IGFwcGxpZWQgLSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXQgb25seVxuICAgIFxuICAgIGdyb3VuZFRvdGFsQ29zdCA9IHJlZ2lvbmFsUmVzdWx0LnRvdGFsQ29zdFBlclBmbG9wWWVhcjtcbiAgICBncm91bmRIYXNRdWV1ZSA9IGZhbHNlOyAvLyBSZWdpb25hbCBtb2RlbCBkb2Vzbid0IG1vZGVsIHF1ZXVlIGRlbGF5IHNlcGFyYXRlbHlcbiAgICBncm91bmRDb21wYXJhdG9yQ29zdFBlclBmbG9wWWVhciA9IGdyb3VuZFRvdGFsQ29zdDsgLy8gVXNlIGJhc2UgY29zdCBmb3IgcmVnaW9uYWwgbW9kZWxcbiAgICBlbmVyZ3lDb25zdHJhaW50TXVsdGlwbGllciA9IDEuMDsgLy8gTmV2ZXIgYXBwbGllZFxuICAgIGNvbnN0cmFpbnRCcmVha2Rvd24gPSB7XG4gICAgICBncmlkOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICBjb29saW5nOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICB3YXRlcjogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgbGFuZDogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgZW5lcmd5TXVsdGlwbGllcjogMS4wLCAvLyBOZXZlciBhcHBsaWVkXG4gICAgICBzaXRlTXVsdGlwbGllcjogMS4wLCAvLyBOb3QgYXBwbGllZCAtIGNvbnN0cmFpbnQgZWZmZWN0cyBhbHJlYWR5IGluIHNpdGVDb3N0XG4gICAgICBjYXBhY2l0eURlbGl2ZXJ5TXVsdGlwbGllcjogMS4wLCAvLyBOb3QgYXBwbGllZCAtIGNvbnN0cmFpbnQgZWZmZWN0cyBhbHJlYWR5IGluIHNpdGVDb3N0XG4gICAgfTtcbiAgICBcbiAgICBncm91bmRSZXN1bHQgPSB7XG4gICAgICBlbmVyZ3lDb3N0OiBlbmVyZ3lDb3N0LCAvLyBSYXcgZWxlY3RyaWNpdHkgY29zdCAoTk8gY29uc3RyYWludCBtdWx0aXBsaWVyKVxuICAgICAgc2l0ZUNvc3Q6IHNpdGVDb3N0UGVyUGZsb3BZZWFyLCAvLyBTaXRlID0gc3VtIG9mIGNvbXBvbmVudHMgKElOVkFSSUFOVClcbiAgICAgIHNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyOiBzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciwgLy8gRXhwbGljaXQ6IHB1cmUgY2FwZXhcbiAgICAgIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtOiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhciwgLy8gRXhwbGljaXQ6IHNjYXJjaXR5IHByZW1pdW1cbiAgICAgIHRpbWVUb0VuZXJnaXplUGVuYWx0eTogdGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyLCAvLyBSZWdpb25hbCBtb2RlbDogMCAobm90IG1vZGVsZWQgc2VwYXJhdGVseSlcbiAgICAgIGhhcmR3YXJlQ29zdDogcmVnaW9uYWxSZXN1bHQuaGFyZHdhcmVDYXBleFBlclBmbG9wWWVhcixcbiAgICAgIHRvdGFsQ29zdFBlclBmbG9wWWVhcjogZ3JvdW5kVG90YWxDb3N0LFxuICAgICAgY29uc3RyYWludE11bHRpcGxpZXI6IDEuMCwgLy8gTk9UIEFQUExJRUQgLSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXQgb25seVxuICAgICAgY29uc3RyYWludHM6IHtcbiAgICAgICAgbWV0aG9kOiAnYWRkZXJzJyxcbiAgICAgICAgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW06IGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyLCAvLyBGcm9tIHJlZ2lvbmFsIG1vZGVsIHNpdGVDb3N0IC0gc2l0ZUNvc3RCYXNlXG4gICAgICAgIGRlbGF5UGVuYWx0eTogMCwgLy8gUmVnaW9uYWwgbW9kZWwgZG9lc24ndCBtb2RlbCBkZWxheSBzZXBhcmF0ZWx5XG4gICAgICAgIGFwcGxpZWRNdWx0aXBsaWVyczoge1xuICAgICAgICAgIGNvbnN0cmFpbnRNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgICAgZW5lcmd5TXVsdGlwbGllclVzZWQ6IGZhbHNlLFxuICAgICAgICAgIHNpdGVNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgZG91YmxlQ291bnRDaGVjazoge1xuICAgICAgICAgICAgbW9kZTogJ2FkZGVycycsXG4gICAgICAgICAgICBtdWx0aXBsaWVyQXBwbGllZDogZmFsc2UsXG4gICAgICAgICAgICBhZGRlcnNBcHBsaWVkOiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bVBlclBmbG9wWWVhciA+IDAsXG4gICAgICAgICAgICBpbnZhcmlhbnRPazogdHJ1ZSxcbiAgICAgICAgICAgIG5vdGVzOiAnUmVnaW9uYWwgbW9kZWwgdXNlcyBhZGRlcnMgb25seSAoY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gZnJvbSBzaXRlQ29zdCAtIHNpdGVDb3N0QmFzZSknLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgYnJlYWtkb3duOiBjb25zdHJhaW50QnJlYWtkb3duLFxuICAgICAgc21yRW5hYmxlZDogZmFsc2UsXG4gICAgICBzbXJSYW1wRmFjdG9yOiAwLFxuICAgICAgZWZmZWN0aXZlRWxlY3RyaWNpdHlDb3N0OiByZWdpb25hbFJlc3VsdC5hdmVyYWdlRW5lcmd5Q29zdE13aCxcbiAgICAgIGNvbnN0cmFpbnRSZWxpZWY6IHsgZ3JpZDogMCwgY29vbGluZzogMCwgd2F0ZXI6IDAsIGxhbmQ6IDAgfSxcbiAgICAgIC8vIEVuc3VyZSBiYWNrbG9nR3cgYW5kIGF2Z1dhaXRZZWFycyBhcmUgYWx3YXlzIHNldCAodXNlIHN1cHBseU1ldHJpY3MgYXMgZmFsbGJhY2spXG4gICAgICBiYWNrbG9nR3c6IHJlZ2lvbmFsUmVzdWx0LnN1cHBseU1ldHJpY3M/LnBpcGVsaW5lR3cgPz8gMCwgLy8gVEVNUCBwcm94eTogdXNlIHBpcGVsaW5lIGFzIHBsYWNlaG9sZGVyXG4gICAgICBhdmdXYWl0WWVhcnM6IHJlZ2lvbmFsUmVzdWx0LnN1cHBseU1ldHJpY3M/LmF2Z1dhaXRZZWFycyA/PyAwLFxuICAgICAgc3VwcGx5TWV0cmljczogcmVnaW9uYWxSZXN1bHQuc3VwcGx5TWV0cmljcyA/PyB7XG4gICAgICAgIGRlbWFuZEd3OiAwLFxuICAgICAgICBjYXBhY2l0eUd3OiAwLFxuICAgICAgICBwaXBlbGluZUd3OiAwLFxuICAgICAgICBtYXhCdWlsZFJhdGVHd1llYXI6IDAsXG4gICAgICAgIGF2Z1dhaXRZZWFyczogMCxcbiAgICAgICAgdXRpbGl6YXRpb25QY3Q6IDAsXG4gICAgICB9LFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZ3JvdW5kUmVzdWx0ID0gY2FsY3VsYXRlR3JvdW5kVG90YWwoXG4gICAgICB5ZWFyLFxuICAgICAgcGFyYW1zLFxuICAgICAgRU5FUkdZX0NPU1RfQkFTRV8yMDI1LFxuICAgICAgZ3JvdW5kSGFyZHdhcmVDYXBleFBlclBmbG9wWWVhcixcbiAgICAgIHBhcmFtcy5pc1N0YXRpY01vZGUsXG4gICAgICBlZmZlY3RpdmVHcm91bmRTY2VuYXJpbyxcbiAgICAgIGdyb3VuZExhdGVuY3lQZW5hbHR5LFxuICAgICAgc21yUGFyYW1zLFxuICAgICAgZmlyc3RDYXBZZWFyID8/IG51bGwsXG4gICAgICBncm91bmRFbmVyZ3lDb3N0UGVyUGZsb3BZZWFyLFxuICAgICAgZ3JvdW5kRWxlY3RyaWNpdHlQcmljZVBlck13aFxuICAgICk7XG5cbiAgICAvLyBDUklUSUNBTCBGSVg6IEVuc3VyZSBiYWNrbG9nR3cgYW5kIGF2Z1dhaXRZZWFycyBhcmUgYWx3YXlzIHNldCAoZXZlbiBpZiBjYWxjdWxhdGVHcm91bmRUb3RhbCBkb2Vzbid0IHByb3ZpZGUgdGhlbSlcbiAgICAvLyBVc2Ugc3VwcGx5TWV0cmljcyBhcyBmYWxsYmFjayBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSAwXG4gICAgLy8gVHlwZSBhc3NlcnRpb24gbmVlZGVkIGJlY2F1c2UgY2FsY3VsYXRlR3JvdW5kVG90YWwgbWF5IG5vdCBpbmNsdWRlIHRoZXNlIGZpZWxkc1xuICAgIGNvbnN0IGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nID0gZ3JvdW5kUmVzdWx0IGFzIGFueTtcbiAgICBpZiAoISgnYmFja2xvZ0d3JyBpbiBncm91bmRSZXN1bHRXaXRoQmFja2xvZykgfHwgZ3JvdW5kUmVzdWx0V2l0aEJhY2tsb2cuYmFja2xvZ0d3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nLmJhY2tsb2dHdyA9IGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nLnN1cHBseU1ldHJpY3M/LnBpcGVsaW5lR3cgPz8gMDsgLy8gVEVNUCBwcm94eVxuICAgIH1cbiAgICBpZiAoISgnYXZnV2FpdFllYXJzJyBpbiBncm91bmRSZXN1bHRXaXRoQmFja2xvZykgfHwgZ3JvdW5kUmVzdWx0V2l0aEJhY2tsb2cuYXZnV2FpdFllYXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nLmF2Z1dhaXRZZWFycyA9IGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nLnN1cHBseU1ldHJpY3M/LmF2Z1dhaXRZZWFycyA/PyAwO1xuICAgIH1cbiAgICAvLyBFbnN1cmUgc3VwcGx5TWV0cmljcyBleGlzdHNcbiAgICBpZiAoIWdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nLnN1cHBseU1ldHJpY3MpIHtcbiAgICAgIGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nLnN1cHBseU1ldHJpY3MgPSB7XG4gICAgICAgIGRlbWFuZEd3OiAwLFxuICAgICAgICBjYXBhY2l0eUd3OiAwLFxuICAgICAgICBwaXBlbGluZUd3OiBncm91bmRSZXN1bHRXaXRoQmFja2xvZy5iYWNrbG9nR3cgPz8gMCxcbiAgICAgICAgbWF4QnVpbGRSYXRlR3dZZWFyOiAwLFxuICAgICAgICBhdmdXYWl0WWVhcnM6IGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nLmF2Z1dhaXRZZWFycyA/PyAwLFxuICAgICAgICB1dGlsaXphdGlvblBjdDogMCxcbiAgICAgIH07XG4gICAgfVxuICAgIGdyb3VuZFJlc3VsdCA9IGdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nO1xuXG4gICAgZ3JvdW5kVG90YWxDb3N0ID0gZ3JvdW5kUmVzdWx0LnRvdGFsQ29zdFBlclBmbG9wWWVhcjtcbiAgICBncm91bmRIYXNRdWV1ZSA9IChncm91bmRSZXN1bHQudGltZVRvRW5lcmdpemVQZW5hbHR5ID8/IDApID4gMC4wMTsgLy8gQ2hlY2sgaWYgZGVsYXkgcGVuYWx0eSBleGlzdHNcbiAgICBncm91bmRDb21wYXJhdG9yQ29zdFBlclBmbG9wWWVhciA9IGdyb3VuZEhhc1F1ZXVlXG4gICAgICA/IChncm91bmRSZXN1bHQudG90YWxDb3N0UGVyUGZsb3BZZWFyRWZmZWN0aXZlID8/IGdyb3VuZFJlc3VsdC50b3RhbENvc3RQZXJQZmxvcFllYXIpXG4gICAgICA6IGdyb3VuZFRvdGFsQ29zdDtcbiAgICAvLyBDUklUSUNBTCBGSVg6IE5ldmVyIGFwcGx5IG11bHRpcGxpZXJzIC0gYWxsIHNldCB0byAxLjBcbiAgICBlbmVyZ3lDb25zdHJhaW50TXVsdGlwbGllciA9IDEuMDsgLy8gTmV2ZXIgYXBwbGllZFxuICAgIFxuICAgIC8vIEludmFyaWFudDogSWYgdXNpbmcgYWRkZXJzLCBtdWx0aXBsaWVycyBtdXN0IG5vdCBiZSBhcHBsaWVkXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIGdyb3VuZFJlc3VsdC5jb25zdHJhaW50cykge1xuICAgICAgY29uc3QgaGFzTXVsdGlwbGllciA9IGdyb3VuZFJlc3VsdC5jb25zdHJhaW50TXVsdGlwbGllciAhPT0gMS4wO1xuICAgICAgY29uc3QgaGFzQWRkZXIgPSAoZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRzLmNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtID4gMCkgfHwgKGdyb3VuZFJlc3VsdC5jb25zdHJhaW50cy5kZWxheVBlbmFsdHkgPiAwKTtcbiAgICAgIGlmIChoYXNNdWx0aXBsaWVyICYmIGhhc0FkZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgW0RPVUJMRSBDT1VOVElORyBERVRFQ1RFRF0gWWVhciAke3llYXJ9OiBjb25zdHJhaW50TXVsdGlwbGllcj0ke2dyb3VuZFJlc3VsdC5jb25zdHJhaW50TXVsdGlwbGllcn0gIT0gMS4wIGAgK1xuICAgICAgICAgIGBBTkQgYWRkZXJzID4gMCAoY2FwYWNpdHlEZWxpdmVyeVByZW1pdW09JHtncm91bmRSZXN1bHQuY29uc3RyYWludHMuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW19LCBgICtcbiAgICAgICAgICBgZGVsYXlQZW5hbHR5PSR7Z3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRzLmRlbGF5UGVuYWx0eX0pLiBCb3RoIGNhbm5vdCBiZSBhcHBsaWVkIHNpbXVsdGFuZW91c2x5LmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3RyYWludEJyZWFrZG93biA9IHtcbiAgICAgIGdyaWQ6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIGNvb2xpbmc6IDEuMCwgLy8gTm90IGFwcGxpZWRcbiAgICAgIHdhdGVyOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICBsYW5kOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICBlbmVyZ3lNdWx0aXBsaWVyOiAxLjAsIC8vIE5ldmVyIGFwcGxpZWRcbiAgICAgIHNpdGVNdWx0aXBsaWVyOiAxLjAsIC8vIE5vdCBhcHBsaWVkXG4gICAgICBjYXBhY2l0eURlbGl2ZXJ5TXVsdGlwbGllcjogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgIH07XG4gICAgXG4gICAgLy8gSW52YXJpYW50OiBDaGVjayBmb3IgZG91YmxlIGNvdW50aW5nXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBjb25zdCBoYXNNdWx0aXBsaWVyID0gKGdyb3VuZFJlc3VsdC5jb25zdHJhaW50TXVsdGlwbGllciAhPT0gMS4wKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChncm91bmRSZXN1bHQuYnJlYWtkb3duLmVuZXJneU11bHRpcGxpZXIgIT09IDEuMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChncm91bmRSZXN1bHQuYnJlYWtkb3duLnNpdGVNdWx0aXBsaWVyICE9PSAxLjApO1xuICAgICAgY29uc3QgaGFzUHJlbWl1bSA9IChncm91bmRSZXN1bHQuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gfHwgMCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoZ3JvdW5kUmVzdWx0LnRpbWVUb0VuZXJnaXplUGVuYWx0eSB8fCAwKSA+IDA7XG4gICAgICBpZiAoaGFzTXVsdGlwbGllciAmJiBoYXNQcmVtaXVtKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgW0RPVUJMRSBDT1VOVElORyBERVRFQ1RFRF0gWWVhciAke3llYXJ9OiBgICtcbiAgICAgICAgICBgTXVsdGlwbGllcnMgKGNvbnN0cmFpbnQ9JHtncm91bmRSZXN1bHQuY29uc3RyYWludE11bHRpcGxpZXJ9LCBgICtcbiAgICAgICAgICBgZW5lcmd5PSR7Z3JvdW5kUmVzdWx0LmJyZWFrZG93bi5lbmVyZ3lNdWx0aXBsaWVyfSwgYCArXG4gICAgICAgICAgYHNpdGU9JHtncm91bmRSZXN1bHQuYnJlYWtkb3duLnNpdGVNdWx0aXBsaWVyfSkgQU5EIGAgK1xuICAgICAgICAgIGBwcmVtaXVtcyAoY2FwYWNpdHk9JHtncm91bmRSZXN1bHQuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW19LCBgICtcbiAgICAgICAgICBgZGVsYXk9JHtncm91bmRSZXN1bHQudGltZVRvRW5lcmdpemVQZW5hbHR5fSkgYXJlIGJvdGggcHJlc2VudC4gYCArXG4gICAgICAgICAgYFRoaXMgaW5kaWNhdGVzIGRvdWJsZSBjb3VudGluZy5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbGF1bmNoQ29zdFBlcktnID0gZ2V0TGF1bmNoQ29zdFBlcktnKHllYXIsIGJhc2VMYXVuY2hDb3N0KSAqIGxhdW5jaERpc2NvdW50O1xuICBjb25zdCBsaWZldGltZVllYXJzID0gNjtcbiAgXG4gIC8vIEZ1c2lvbiB0b2dnbGUgcGFyYW1zXG4gIGNvbnN0IGZ1c2lvblBhcmFtcyA9IHBhcmFtcy5mdXNpb25Ub2dnbGVFbmFibGVkIFxuICAgID8gKHBhcmFtcy5mdXNpb25Ub2dnbGVQYXJhbXMgfHwgeyAuLi5ERUZBVUxUX0ZVU0lPTl9QQVJBTVMsIGVuYWJsZWQ6IHRydWUgfSlcbiAgICA6IHVuZGVmaW5lZDtcblxuICAvLyBDT05TVEVMTEFUSU9OIFNJWklORzogRGVzaWduIGNvbnN0ZWxsYXRpb24gdG8gbWVldCBjb21wdXRlIHJlcXVpcmVtZW50c1xuICAvLyBDb252ZXJ0IHRhcmdldCBjb21wdXRlIChHVykgdG8gcG93ZXIgKGtXKSBmb3IgY29uc3RlbGxhdGlvbiBzaXppbmdcbiAgY29uc3QgdGFyZ2V0Q29tcHV0ZUt3ID0gc2F0ZWxsaXRlUG93ZXJLVztcbiAgbGV0IGNvbnN0ZWxsYXRpb24gPSBkZXNpZ25Db25zdGVsbGF0aW9uKFxuICAgIHRhcmdldENvbXB1dGVLdyxcbiAgICBTQVRFTExJVEVfQ09OU1RSQUlOVFMsXG4gICAgMTAwMDAwLCAvLyBTdGFyc2hpcDogMTAwdCB0byBMRU9cbiAgICB0cmFqU3BlY2lmaWNQb3dlclxuICApO1xuICBcbiAgLy8gVXNlIHBlci1zYXRlbGxpdGUgY29tcHV0ZSBwb3dlciBmb3IgY29zdCBjYWxjdWxhdGlvblxuICBsZXQgY29tcHV0ZVBvd2VyUGVyU2F0S3cgPSBjb25zdGVsbGF0aW9uLmNvbXB1dGVQZXJTYXRLdztcblxuICBsZXQgaHlicmlkUmVzdWx0ID0gY29tcHV0ZVNhdGVsbGl0ZUh5YnJpZENvc3QoXG4gICAgeWVhciwgXG4gICAgbGF1bmNoQ29zdFBlcktnLCBcbiAgICB7XG4gICAgICAuLi5ERUZBVUxUX0NPTkZJRyxcbiAgICAgIGNvbXB1dGVQb3dlckt3OiBjb21wdXRlUG93ZXJQZXJTYXRLdywgLy8gVXNlIHBlci1zYXRlbGxpdGUgcG93ZXJcbiAgICAgIGFsdGl0dWRlS206IG9yYml0YWxBbHRpdHVkZSxcbiAgICAgIGxpZmV0aW1lWWVhcnM6IGxpZmV0aW1lWWVhcnMsXG4gICAgICBzcGVjaWZpY1Bvd2VyV0tnOiB0cmFqU3BlY2lmaWNQb3dlcixcbiAgICAgIHVzZVJhZEhhcmRDaGlwczogdXNlUmFkSGFyZENoaXBzLFxuICAgICAgc3VuRnJhY3Rpb246IHN1bkZyYWN0aW9uLFxuICAgICAgd29ya2xvYWRUeXBlOiB3b3JrbG9hZFR5cGUgfHwgJ2luZmVyZW5jZSdcbiAgICB9LCBcbiAgICBmdXNpb25QYXJhbXMsXG4gICAgcGFyYW1zLnVzZUNvcnJlY3RlZFNwZWNpZmljUG93ZXIsXG4gICAgcGFyYW1zLnVzZUNvcnJlY3RlZFRoZXJtYWxcbiAgKTtcbiAgXG4gIC8vIENSSVRJQ0FMIEZJWDogQ2FsY3VsYXRlIGRlbGl2ZXJlZCBlZmZpY2llbmN5IHdpdGggQUxMIGRlbGl2ZXJ5IGRlcmF0ZXNcbiAgLy8gZGVsaXZlcmVkID0gc3lzdGVtRWZmZWN0aXZlICogdGhlcm1hbENhcEZhY3RvciAqIHJhZGlhdGlvbkRlcmF0ZSAqIGF2YWlsYWJpbGl0eVxuICAvLyBTaW5nbGUgc291cmNlIG9mIHRydXRoIGZvciBhbGwgdGhyZWUgZmFjdG9yczpcbiAgY29uc3QgdGhlcm1hbENhcEZhY3RvciA9IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnRoZXJtYWxDYXBGYWN0b3I7XG4gIGNvbnN0IHJhZGlhdGlvbkRlcmF0ZSA9IGh5YnJpZFJlc3VsdC5kZWdyYWRhdGlvbkZhY3RvciB8fCAxLjA7IC8vIEhhcmR3YXJlIGRlZ3JhZGF0aW9uIGZyb20gcmFkaWF0aW9uIChjaGlwIGZhaWx1cmVzLCBFQ0Mgb3ZlcmhlYWQpXG4gIGNvbnN0IGF2YWlsYWJpbGl0eSA9IGh5YnJpZFJlc3VsdC5jYXBhY2l0eUZhY3RvciB8fCAxLjA7IC8vIENhcGFjaXR5IGZhY3RvciBpcyB1cHRpbWUtaW5jbHVzaXZlIChpbmNsdWRlcyBlY2xpcHNlLCBkZWdyYWRhdGlvbiwgcmFkaWF0aW9uIGRvd250aW1lLCB1cHRpbWUpXG4gIFxuICAvLyBDYWxjdWxhdGUgZGVsaXZlcmVkIGVmZmljaWVuY3kgKGFsbCBkZXJhdGVzIGFwcGxpZWQgbXVsdGlwbGljYXRpdmVseSlcbiAgLy8gVGhpcyBpcyB0aGUgdHJ1ZSBcImRlbGl2ZXJlZFwiIGVmZmljaWVuY3kgdGhhdCBhY2NvdW50cyBmb3IgYWxsIG9wZXJhdGlvbmFsIGNvbnN0cmFpbnRzXG4gIGxldCBvcmJpdERlbGl2ZXJlZEdmbG9wc1BlcldhdHQgPSBvcmJpdFN5c3RlbUVmZmVjdGl2ZUdmbG9wc1BlcldhdHQgKiB0aGVybWFsQ2FwRmFjdG9yICogcmFkaWF0aW9uRGVyYXRlICogYXZhaWxhYmlsaXR5O1xuICBcbiAgLy8gQ1JJVElDQUw6IElmIHRoZXJtYWwgY29uc3RyYWludCBjYXVzZXMgZGVsaXZlcmVkIGVmZmljaWVuY3kgdG8gZHJvcCBiZWxvdyBtaW5pbXVtICgyMCBHRkxPUFMvVyksXG4gIC8vIHRoaXMgaW5kaWNhdGVzIGEgc2V2ZXJlIHRoZXJtYWwgY29uc3RyYWludCB0aGF0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IGV4cGFuZGluZyByYWRpYXRvciBvciByZWR1Y2luZyBjb21wdXRlXG4gIC8vIEZvciBub3csIHdlIGNsYW1wIHRvIG1pbmltdW0gdG8gcHJldmVudCB2YWxpZGF0aW9uIGVycm9ycywgYnV0IGxvZyBhIHdhcm5pbmcgKG9ubHkgb25jZSBwZXIgeWVhcilcbiAgaWYgKG9yYml0RGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCA8IENPTlNUQU5UUy5NSU5fREVMSVZFUkVEX0dGTE9QU19QRVJfVykge1xuICAgIGNvbnN0IG9yaWdpbmFsRGVsaXZlcmVkID0gb3JiaXREZWxpdmVyZWRHZmxvcHNQZXJXYXR0O1xuICAgIG9yYml0RGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCA9IENPTlNUQU5UUy5NSU5fREVMSVZFUkVEX0dGTE9QU19QRVJfVztcbiAgICBcbiAgICAvLyBMb2cgd2FybmluZyBhYm91dCBzZXZlcmUgdGhlcm1hbCBjb25zdHJhaW50IChvbmx5IGluIGRldiwgYW5kIG9ubHkgb25jZSBwZXIgeWVhciB0byByZWR1Y2Ugc3BhbSlcbiAgICAvLyBUaGUgYWN0dWFsIGNsYW1wZWQgdmFsdWUgaXMgYXZhaWxhYmxlIGluIG9yYml0LmNvbXB1dGVFZmZpY2llbmN5LnZhbGlkYXRpb24gbWV0YWRhdGFcbiAgICAvLyBUaGVybWFsIGNvbnN0cmFpbnQgd2FybmluZ3MgcmVtb3ZlZCBmb3IgY2xlYW5lciBjb25zb2xlIG91dHB1dFxuICB9XG4gIFxuICAvLyBVc2UgZGVsaXZlcmVkIGVmZmljaWVuY3kgZm9yIGFsbCBjb3N0IGNhbGN1bGF0aW9uc1xuICBsZXQgb3JiaXRFZmZlY3RpdmVHZmxvcHNQZXJXID0gdmFsaWRhdGVHZmxvcHNQZXJXYXR0KFxuICAgIG9yYml0RGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCxcbiAgICAnb3JiaXRhbCBkZWxpdmVyZWQgZWZmaWNpZW5jeSBjYWxjdWxhdGlvbidcbiAgKTtcbiAgXG4gIC8vIFBvd2VyIHNjYWxpbmcgY2FsY3VsYXRpb25cbiAgY29uc3QgcG93ZXJTY2FsaW5nUGFyYW1zID0gcGFyYW1zLnBvd2VyU2NhbGluZ1BhcmFtcyB8fCBERUZBVUxUX1BPV0VSX1NDQUxJTkc7XG4gIGNvbnN0IHNjYWxpbmdSZXN1bHQgPSBjYWxjdWxhdGVTY2FsZWRNYXNzKGNvbXB1dGVQb3dlclBlclNhdEt3LCBwb3dlclNjYWxpbmdQYXJhbXMpO1xuXG4gIC8vIENPTlNURUxMQVRJT04gU0NBTElORzogQXBwbHkgY29uc3RlbGxhdGlvbiBtdWx0aXBsaWVyIHRvIG1hc3MgYW5kIGNvc3RzXG4gIC8vIFBlci1zYXRlbGxpdGUgbWFzcyAoYWxyZWFkeSBjYWxjdWxhdGVkIGZvciBvbmUgc2F0ZWxsaXRlKVxuICBsZXQgbWFzc1BlclNhdEtnID0gaHlicmlkUmVzdWx0LnRvdGFsTWFzc0tnICogbWFzc011bHRpcGxpZXI7XG4gIFxuICAvLyBDUklUSUNBTCBGSVg6IENoZWNrIGlmIGFjdHVhbCBtYXNzIGV4Y2VlZHMgbGltaXQgYW5kIHJlLXNwbGl0IGNvbnN0ZWxsYXRpb24gaWYgbmVlZGVkXG4gIC8vIFRoZSBzaW1wbGlmaWVkIG1hc3MgbW9kZWwgaW4gZGVzaWduQ29uc3RlbGxhdGlvbiBtYXkgdW5kZXJlc3RpbWF0ZSBhY3R1YWwgbWFzc1xuICAvLyBJZiBhY3R1YWwgbWFzcyBleGNlZWRzIGxpbWl0LCB3ZSBuZWVkIHRvIHNwbGl0IGludG8gc21hbGxlciBzYXRlbGxpdGVzXG4gIGNvbnN0IE1BWF9TQVRFTExJVEVfTUFTU19LRyA9IFNBVEVMTElURV9DT05TVFJBSU5UUy5tYXhNYXNzS2c7IC8vIDEwLDAwMCBrZyBmcm9tIGNvbnN0cmFpbnRzXG4gIGlmIChtYXNzUGVyU2F0S2cgPiBNQVhfU0FURUxMSVRFX01BU1NfS0cpIHtcbiAgICAvLyBDYWxjdWxhdGUgcmVxdWlyZWQgY29tcHV0ZSBwZXIgc2F0ZWxsaXRlIHRvIHN0YXkgdW5kZXIgbWFzcyBsaW1pdFxuICAgIC8vIE1hc3Mgc2NhbGVzIHJvdWdobHkgd2l0aCBjb21wdXRlIHBvd2VyLCBzbzogbWFzc1BlclNhdEtnIC8gY29tcHV0ZVBvd2VyUGVyU2F0S3cgPSBtYXNzUGVyS3dcbiAgICBjb25zdCBtYXNzUGVyS3cgPSBtYXNzUGVyU2F0S2cgLyBjb21wdXRlUG93ZXJQZXJTYXRLdztcbiAgICBjb25zdCBtYXhDb21wdXRlUGVyU2F0S3cgPSBNQVhfU0FURUxMSVRFX01BU1NfS0cgLyBtYXNzUGVyS3c7XG4gICAgXG4gICAgLy8gUmVjYWxjdWxhdGUgY29uc3RlbGxhdGlvbiB3aXRoIHNtYWxsZXIgc2F0ZWxsaXRlc1xuICAgIGNvbnN0IGFkanVzdGVkQ29uc3RlbGxhdGlvbiA9IGRlc2lnbkNvbnN0ZWxsYXRpb24oXG4gICAgICB0YXJnZXRDb21wdXRlS3csXG4gICAgICB7XG4gICAgICAgIC4uLlNBVEVMTElURV9DT05TVFJBSU5UUyxcbiAgICAgICAgbWF4Q29tcHV0ZUt3OiBtYXhDb21wdXRlUGVyU2F0S3cgKiAwLjksIC8vIFVzZSA5MCUgb2YgbWF4IHRvIGxlYXZlIG1hcmdpblxuICAgICAgfSxcbiAgICAgIDEwMDAwMCwgLy8gU3RhcnNoaXA6IDEwMHQgdG8gTEVPXG4gICAgICB0cmFqU3BlY2lmaWNQb3dlclxuICAgICk7XG4gICAgXG4gICAgLy8gUmVjYWxjdWxhdGUgaHlicmlkIGNvc3Qgd2l0aCBhZGp1c3RlZCBjb21wdXRlIHBlciBzYXRlbGxpdGVcbiAgICBjb25zdCBhZGp1c3RlZEh5YnJpZFJlc3VsdCA9IGNvbXB1dGVTYXRlbGxpdGVIeWJyaWRDb3N0KFxuICAgICAgeWVhciwgXG4gICAgICBsYXVuY2hDb3N0UGVyS2csIFxuICAgICAge1xuICAgICAgICAuLi5ERUZBVUxUX0NPTkZJRyxcbiAgICAgICAgY29tcHV0ZVBvd2VyS3c6IGFkanVzdGVkQ29uc3RlbGxhdGlvbi5jb21wdXRlUGVyU2F0S3csXG4gICAgICAgIGFsdGl0dWRlS206IG9yYml0YWxBbHRpdHVkZSxcbiAgICAgICAgbGlmZXRpbWVZZWFyczogbGlmZXRpbWVZZWFycyxcbiAgICAgICAgc3BlY2lmaWNQb3dlcldLZzogdHJhalNwZWNpZmljUG93ZXIsXG4gICAgICAgIHVzZVJhZEhhcmRDaGlwczogdXNlUmFkSGFyZENoaXBzLFxuICAgICAgICBzdW5GcmFjdGlvbjogc3VuRnJhY3Rpb24sXG4gICAgICAgIHdvcmtsb2FkVHlwZTogd29ya2xvYWRUeXBlIHx8ICdpbmZlcmVuY2UnXG4gICAgICB9LCBcbiAgICAgIGZ1c2lvblBhcmFtcyxcbiAgICAgIHBhcmFtcy51c2VDb3JyZWN0ZWRTcGVjaWZpY1Bvd2VyLFxuICAgICAgcGFyYW1zLnVzZUNvcnJlY3RlZFRoZXJtYWxcbiAgICApO1xuICAgIFxuICAgIC8vIFVwZGF0ZSB3aXRoIGFkanVzdGVkIHZhbHVlc1xuICAgIGNvbnN0IGFkanVzdGVkTWFzc1BlclNhdEtnID0gYWRqdXN0ZWRIeWJyaWRSZXN1bHQudG90YWxNYXNzS2cgKiBtYXNzTXVsdGlwbGllcjtcbiAgICBpZiAoYWRqdXN0ZWRNYXNzUGVyU2F0S2cgPiBNQVhfU0FURUxMSVRFX01BU1NfS0cpIHtcbiAgICAgIC8vIFN0aWxsIHRvbyBoZWF2eSAtIHRoaXMgc2hvdWxkbid0IGhhcHBlbiwgYnV0IGxvZyBhIHdhcm5pbmdcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFNhdGVsbGl0ZSBtYXNzICR7YWRqdXN0ZWRNYXNzUGVyU2F0S2cudG9GaXhlZCgwKX1rZyBzdGlsbCBleGNlZWRzIGxpbWl0ICR7TUFYX1NBVEVMTElURV9NQVNTX0tHfWtnIGAgK1xuICAgICAgICBgZXZlbiBhZnRlciBzcGxpdHRpbmcgdG8gJHthZGp1c3RlZENvbnN0ZWxsYXRpb24uY29tcHV0ZVBlclNhdEt3LnRvRml4ZWQoMSl9a1cgcGVyIHNhdGVsbGl0ZS4gYCArXG4gICAgICAgIGBDb25zaWRlciBmdXJ0aGVyIHJlZHVjaW5nIGNvbXB1dGUgcGVyIHNhdGVsbGl0ZSBvciBpbXByb3Zpbmcgc3BlY2lmaWMgcG93ZXIuYFxuICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXNlIGFkanVzdGVkIGNvbnN0ZWxsYXRpb24gYW5kIGh5YnJpZCByZXN1bHRcbiAgICBjb25zdGVsbGF0aW9uID0gYWRqdXN0ZWRDb25zdGVsbGF0aW9uO1xuICAgIGh5YnJpZFJlc3VsdCA9IGFkanVzdGVkSHlicmlkUmVzdWx0O1xuICAgIGNvbXB1dGVQb3dlclBlclNhdEt3ID0gYWRqdXN0ZWRDb25zdGVsbGF0aW9uLmNvbXB1dGVQZXJTYXRLdztcbiAgICBtYXNzUGVyU2F0S2cgPSBhZGp1c3RlZE1hc3NQZXJTYXRLZztcbiAgICBcbiAgICAvLyBSZWNhbGN1bGF0ZSBkZWxpdmVyZWQgZWZmaWNpZW5jeSB3aXRoIGFkanVzdGVkIHRoZXJtYWwgY2FwIChhbGwgZGVyYXRlcyBhcHBsaWVkKVxuICAgIGNvbnN0IGFkanVzdGVkVGhlcm1hbENhcEZhY3RvciA9IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnRoZXJtYWxDYXBGYWN0b3I7XG4gICAgY29uc3QgYWRqdXN0ZWRSYWRpYXRpb25EZXJhdGUgPSBoeWJyaWRSZXN1bHQuZGVncmFkYXRpb25GYWN0b3IgfHwgMS4wO1xuICAgIGNvbnN0IGFkanVzdGVkQXZhaWxhYmlsaXR5ID0gaHlicmlkUmVzdWx0LmNhcGFjaXR5RmFjdG9yIHx8IDEuMDtcbiAgICBsZXQgYWRqdXN0ZWREZWxpdmVyZWRHZmxvcHNQZXJXYXR0ID0gb3JiaXRTeXN0ZW1FZmZlY3RpdmVHZmxvcHNQZXJXYXR0ICogYWRqdXN0ZWRUaGVybWFsQ2FwRmFjdG9yICogYWRqdXN0ZWRSYWRpYXRpb25EZXJhdGUgKiBhZGp1c3RlZEF2YWlsYWJpbGl0eTtcbiAgICBcbiAgICAvLyBDbGFtcCB0byBtaW5pbXVtIGlmIHRoZXJtYWwgY29uc3RyYWludCBpcyB0b28gc2V2ZXJlXG4gICAgaWYgKGFkanVzdGVkRGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCA8IENPTlNUQU5UUy5NSU5fREVMSVZFUkVEX0dGTE9QU19QRVJfVykge1xuICAgICAgYWRqdXN0ZWREZWxpdmVyZWRHZmxvcHNQZXJXYXR0ID0gQ09OU1RBTlRTLk1JTl9ERUxJVkVSRURfR0ZMT1BTX1BFUl9XO1xuICAgIH1cbiAgICBcbiAgICBvcmJpdEVmZmVjdGl2ZUdmbG9wc1BlclcgPSB2YWxpZGF0ZUdmbG9wc1BlcldhdHQoXG4gICAgICBhZGp1c3RlZERlbGl2ZXJlZEdmbG9wc1BlcldhdHQsXG4gICAgICAnb3JiaXRhbCBkZWxpdmVyZWQgZWZmaWNpZW5jeSAoYWZ0ZXIgY29uc3RlbGxhdGlvbiBzcGxpdCknXG4gICAgKTtcbiAgfVxuICBcbiAgLy8gU2NhbGUgY29zdHMgYnkgbnVtYmVyIG9mIHNhdGVsbGl0ZXMgYW5kIGFwcGx5IGNvbnN0ZWxsYXRpb24gb3ZlcmhlYWRcbiAgLy8gQ2FsY3VsYXRlIEFGVEVSIG1hc3MgY2hlY2sgc28gd2UgdXNlIHRoZSBhZGp1c3RlZCBjb25zdGVsbGF0aW9uIGlmIGl0IHdhcyBzcGxpdFxuICBjb25zdCBjb25zdGVsbGF0aW9uTXVsdGlwbGllciA9IGNvbnN0ZWxsYXRpb24ubnVtU2F0ZWxsaXRlcztcbiAgY29uc3QgY29uc3RlbGxhdGlvbk92ZXJoZWFkTXVsdGlwbGllciA9IGNvbnN0ZWxsYXRpb24uY29uc3RlbGxhdGlvbk92ZXJoZWFkO1xuICBcbiAgLy8gVG90YWwgY29uc3RlbGxhdGlvbiBtYXNzXG4gIGNvbnN0IGVmZmVjdGl2ZVRvdGFsTWFzc0tnID0gbWFzc1BlclNhdEtnICogY29uc3RlbGxhdGlvbi5udW1TYXRlbGxpdGVzO1xuICBjb25zdCBlZmZlY3RpdmVUb3RhbExhdW5jaENvc3QgPSBlZmZlY3RpdmVUb3RhbE1hc3NLZyAqIGxhdW5jaENvc3RQZXJLZztcblxuICAvLyBBcHBseSBFbG9uIFNjZW5hcmlvOiBEaXNjb3VudHNcbiAgY29uc3QgZWZmZWN0aXZlUG93ZXJGYWJDb3N0ID0gaHlicmlkUmVzdWx0LnBvd2VyU3lzdGVtLmZhYkNvc3RVc2QgKiBwb3dlckRpc2NvdW50O1xuICBjb25zdCBlZmZlY3RpdmVOZXR3b3JraW5nRmFiQ29zdCA9IGh5YnJpZFJlc3VsdC5uZXR3b3JraW5nLmZhYkNvc3RVc2QgKiBuZXR3b3JraW5nRGlzY291bnQ7XG4gIGNvbnN0IGVmZmVjdGl2ZU5ldHdvcmtpbmdPcEV4ID0gKGh5YnJpZFJlc3VsdC5uZXR3b3JraW5nLmFubnVhbE9wRXhVc2QgfHwgMCkgKiBuZXR3b3JraW5nRGlzY291bnQ7XG5cbiAgLy8gRWZmZWN0aXZlIFBGTE9QczogcGVyLXNhdGVsbGl0ZSBQRkxPUHMgw5cgbnVtYmVyIG9mIHNhdGVsbGl0ZXNcbiAgY29uc3QgZWZmZWN0aXZlUGZsb3BzUGVyU2F0ID0gaHlicmlkUmVzdWx0LmVmZmVjdGl2ZVBmbG9wcztcbiAgY29uc3QgdG90YWxFZmZlY3RpdmVQZmxvcHMgPSBlZmZlY3RpdmVQZmxvcHNQZXJTYXQgKiBjb25zdGVsbGF0aW9uLm51bVNhdGVsbGl0ZXM7XG4gIFxuICAvLyBMYXVuY2ggY29zdDogdG90YWwgY29uc3RlbGxhdGlvbiBsYXVuY2ggY29zdCAvIHRvdGFsIFBGTE9Qc1xuICBjb25zdCBsYXVuY2hDb3N0UGVyUGZsb3BZZWFyID0gZWZmZWN0aXZlVG90YWxMYXVuY2hDb3N0IC8gdG90YWxFZmZlY3RpdmVQZmxvcHMgLyBsaWZldGltZVllYXJzO1xuXG4gIC8vIENSSVRJQ0FMIEZJWCAxOiBDb3N0IEFjY291bnRpbmcgLSBlbnN1cmUgYnJlYWtkb3duIHN1bXMgdG8gdG90YWxcbiAgLy8gQ2FsY3VsYXRlIGVhY2ggY29tcG9uZW50IGV4cGxpY2l0bHksIHNjYWxlZCBieSBjb25zdGVsbGF0aW9uXG4gIC8vIFBlci1zYXRlbGxpdGUgY29zdHMgw5cgbnVtYmVyIG9mIHNhdGVsbGl0ZXMgw5cgY29uc3RlbGxhdGlvbiBvdmVyaGVhZFxuICBjb25zdCBjb25zdGVsbGF0aW9uQ29zdE11bHRpcGxpZXIgPSBjb25zdGVsbGF0aW9uLm51bVNhdGVsbGl0ZXMgKiBjb25zdGVsbGF0aW9uT3ZlcmhlYWRNdWx0aXBsaWVyO1xuICBcbiAgY29uc3QgcG93ZXJDb3N0ID0gKGVmZmVjdGl2ZVBvd2VyRmFiQ29zdCAqIGNvbnN0ZWxsYXRpb25Db3N0TXVsdGlwbGllcikgLyB0b3RhbEVmZmVjdGl2ZVBmbG9wcyAvIGxpZmV0aW1lWWVhcnM7XG4gIGNvbnN0IGNvbXB1dGVDb3N0ID0gKChoeWJyaWRSZXN1bHQuY29tcHV0ZVBheWxvYWQuY2hpcENvc3RVc2QgKyBoeWJyaWRSZXN1bHQuY29tcHV0ZVBheWxvYWQucXVhbGlmaWNhdGlvbkNvc3RVc2QpICogY29uc3RlbGxhdGlvbkNvc3RNdWx0aXBsaWVyKSAvIHRvdGFsRWZmZWN0aXZlUGZsb3BzIC8gbGlmZXRpbWVZZWFycztcbiAgY29uc3QgdGhlcm1hbENvc3QgPSAoaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0uZmFiQ29zdFVzZCAqIGNvbnN0ZWxsYXRpb25Db3N0TXVsdGlwbGllcikgLyB0b3RhbEVmZmVjdGl2ZVBmbG9wcyAvIGxpZmV0aW1lWWVhcnM7XG4gIGNvbnN0IHJhZGlhdGlvbkNvc3QgPSAoaHlicmlkUmVzdWx0LnJhZGlhdGlvblByb3RlY3Rpb24uZmFiQ29zdFVzZCAqIGNvbnN0ZWxsYXRpb25Db3N0TXVsdGlwbGllcikgLyB0b3RhbEVmZmVjdGl2ZVBmbG9wcyAvIGxpZmV0aW1lWWVhcnM7XG4gIGNvbnN0IGJ1c0Nvc3QgPSAoaHlicmlkUmVzdWx0LmJ1cy5mYWJDb3N0VXNkICogY29uc3RlbGxhdGlvbkNvc3RNdWx0aXBsaWVyKSAvIHRvdGFsRWZmZWN0aXZlUGZsb3BzIC8gbGlmZXRpbWVZZWFycztcbiAgY29uc3QgbmV0d29ya2luZ0Nvc3QgPSAoZWZmZWN0aXZlTmV0d29ya2luZ0ZhYkNvc3QgKiBjb25zdGVsbGF0aW9uQ29zdE11bHRpcGxpZXIpIC8gdG90YWxFZmZlY3RpdmVQZmxvcHMgLyBsaWZldGltZVllYXJzO1xuICBjb25zdCBpbnRlcmNvbm5lY3RDb3N0ID0gKGh5YnJpZFJlc3VsdC5pbnRlcmNvbm5lY3QudG90YWxBbm51YWxDb3N0ICogY29uc3RlbGxhdGlvbkNvc3RNdWx0aXBsaWVyKSAvIHRvdGFsRWZmZWN0aXZlUGZsb3BzO1xuICBjb25zdCByZWd1bGF0b3J5Q29zdCA9ICgoaHlicmlkUmVzdWx0LnJlZ3VsYXRvcnk/LmFubnVhbENvc3RVc2QgfHwgMCkgKiBjb25zdGVsbGF0aW9uQ29zdE11bHRpcGxpZXIpIC8gdG90YWxFZmZlY3RpdmVQZmxvcHM7XG4gIFxuICAvLyBPcHMgY29zdCBzY2FsZXMgd2l0aCBjb25zdGVsbGF0aW9uIG92ZXJoZWFkIChtb3JlIHNhdGVsbGl0ZXMgPSBtb3JlIG9wcyBjb21wbGV4aXR5KVxuICBjb25zdCBiYXNlT3BzQ29zdFBlclNhdCA9IGh5YnJpZFJlc3VsdC5vcHNQZXJQZmxvcFllYXIgKiBlZmZlY3RpdmVQZmxvcHNQZXJTYXQ7IC8vIFRvdGFsIG9wcyBjb3N0IHBlciBzYXRlbGxpdGVcbiAgY29uc3QgbmV0d29ya2luZ09wc0Nvc3RQZXJTYXQgPSAoaHlicmlkUmVzdWx0Lm5ldHdvcmtpbmcuYW5udWFsT3BFeFVzZCB8fCAwKSAtIGVmZmVjdGl2ZU5ldHdvcmtpbmdPcEV4OyAvLyBBbHJlYWR5IHBlci1zYXRcbiAgY29uc3QgYWRqdXN0ZWROZXR3b3JraW5nT3BzQ29zdFBlclNhdCA9IGVmZmVjdGl2ZU5ldHdvcmtpbmdPcEV4OyAvLyBBbHJlYWR5IHBlci1zYXRcbiAgY29uc3Qgb3BzQ29zdFBlclNhdCA9IGJhc2VPcHNDb3N0UGVyU2F0IC0gbmV0d29ya2luZ09wc0Nvc3RQZXJTYXQgKyBhZGp1c3RlZE5ldHdvcmtpbmdPcHNDb3N0UGVyU2F0O1xuICBcbiAgLy8gU2NhbGUgb3BzIGNvc3QgYnkgY29uc3RlbGxhdGlvbiAod2l0aCBvdmVyaGVhZCBmb3IgY29vcmRpbmF0aW9uKVxuICBjb25zdCBvcHNDb3N0TXVsdGlwbGllciA9IGNvbnN0ZWxsYXRpb24ubnVtU2F0ZWxsaXRlcyAqICgxICsgMC4xICogTWF0aC5sb2cxMChjb25zdGVsbGF0aW9uLm51bVNhdGVsbGl0ZXMpKTtcbiAgY29uc3Qgb3BzQ29zdCA9IChvcHNDb3N0UGVyU2F0ICogb3BzQ29zdE11bHRpcGxpZXIpIC8gdG90YWxFZmZlY3RpdmVQZmxvcHM7XG5cbiAgY29uc3Qgb3JiaXRhbEJyZWFrZG93biA9IHtcbiAgICBwb3dlcjogcG93ZXJDb3N0LFxuICAgIGNvbXB1dGU6IGNvbXB1dGVDb3N0LFxuICAgIHRoZXJtYWw6IHRoZXJtYWxDb3N0LFxuICAgIHJhZGlhdGlvbjogcmFkaWF0aW9uQ29zdCxcbiAgICBidXM6IGJ1c0Nvc3QsXG4gICAgb3BzOiBvcHNDb3N0LFxuICAgIGNvbmdlc3Rpb246IDAsIC8vIENhbGN1bGF0ZWQgYmVsb3dcbiAgICBuZXR3b3JraW5nOiBuZXR3b3JraW5nQ29zdCxcbiAgICBpbnRlcmNvbm5lY3Q6IGludGVyY29ubmVjdENvc3QsXG4gICAgcmVndWxhdG9yeTogcmVndWxhdG9yeUNvc3QsXG4gICAgbGF1bmNoOiBsYXVuY2hDb3N0UGVyUGZsb3BZZWFyXG4gIH07XG5cbiAgY29uc3QgdG90YWxTYXRlbGxpdGVDb3N0ID0gaHlicmlkUmVzdWx0LnRvdGFsU2F0ZWxsaXRlQ29zdCAqIGNvbnN0ZWxsYXRpb25Db3N0TXVsdGlwbGllcjtcbiAgY29uc3Qgc2F0ZWxsaXRlQ291bnQgPSBjb25zdGVsbGF0aW9uLm51bVNhdGVsbGl0ZXM7IC8vIFVzZSBhY3R1YWwgY29uc3RlbGxhdGlvbiBzaXplXG4gIGNvbnN0IGNvbmdlc3Rpb24gPSBjYWxjdWxhdGVDb25nZXN0aW9uKHNhdGVsbGl0ZUNvdW50LCB0b3RhbFNhdGVsbGl0ZUNvc3QsIHllYXIsIDEwMDAwICsgc2F0ZWxsaXRlQ291bnQsIHNwYWNlVHJhZmZpY0VuYWJsZWQpO1xuICBcbiAgLy8gVG90YWwgZmxlZXQgUEZMT1BTOiB1c2UgY29uc3RlbGxhdGlvbiB0b3RhbCBQRkxPUHNcbiAgLy8gQWxyZWFkeSBjYWxjdWxhdGVkIGFzIHRvdGFsRWZmZWN0aXZlUGZsb3BzIGFib3ZlXG4gIG9yYml0YWxCcmVha2Rvd24uY29uZ2VzdGlvbiA9IHNwYWNlVHJhZmZpY0VuYWJsZWQgPyAoY29uZ2VzdGlvbi5jb25nZXN0aW9uQ29zdFBlclBmbG9wWWVhciAvIHRvdGFsRWZmZWN0aXZlUGZsb3BzKSA6IDA7XG5cbiAgLy8gUEFUQ0ggRzogQ29zdCBBY2NvdW50aW5nIEludmFyaWFudHNcbiAgLy8gVXNlIGFzc2VydENvc3RBY2NvdW50aW5nIHRvIGVuc3VyZSBicmVha2Rvd24gc3VtcyB0byB0b3RhbCBleGFjdGx5XG4gIGNvbnN0IG9yYml0YWxDb21wb25lbnRzID0gW1xuICAgIHsgbmFtZTogJ3Bvd2VyJywgdmFsdWU6IG9yYml0YWxCcmVha2Rvd24ucG93ZXIgfSxcbiAgICB7IG5hbWU6ICdjb21wdXRlJywgdmFsdWU6IG9yYml0YWxCcmVha2Rvd24uY29tcHV0ZSB9LFxuICAgIHsgbmFtZTogJ3RoZXJtYWwnLCB2YWx1ZTogb3JiaXRhbEJyZWFrZG93bi50aGVybWFsIH0sXG4gICAgeyBuYW1lOiAncmFkaWF0aW9uJywgdmFsdWU6IG9yYml0YWxCcmVha2Rvd24ucmFkaWF0aW9uIH0sXG4gICAgeyBuYW1lOiAnYnVzJywgdmFsdWU6IG9yYml0YWxCcmVha2Rvd24uYnVzIH0sXG4gICAgeyBuYW1lOiAnb3BzJywgdmFsdWU6IG9yYml0YWxCcmVha2Rvd24ub3BzIH0sXG4gICAgeyBuYW1lOiAnbmV0d29ya2luZycsIHZhbHVlOiBvcmJpdGFsQnJlYWtkb3duLm5ldHdvcmtpbmcgfSxcbiAgICB7IG5hbWU6ICdpbnRlcmNvbm5lY3QnLCB2YWx1ZTogb3JiaXRhbEJyZWFrZG93bi5pbnRlcmNvbm5lY3QgfSxcbiAgICB7IG5hbWU6ICdyZWd1bGF0b3J5JywgdmFsdWU6IG9yYml0YWxCcmVha2Rvd24ucmVndWxhdG9yeSB9LFxuICAgIHsgbmFtZTogJ2xhdW5jaCcsIHZhbHVlOiBvcmJpdGFsQnJlYWtkb3duLmxhdW5jaCB9LFxuICAgIHsgbmFtZTogJ2Nvbmdlc3Rpb24nLCB2YWx1ZTogb3JiaXRhbEJyZWFrZG93bi5jb25nZXN0aW9uIH0sXG4gIF07XG4gIFxuICBjb25zdCBicmVha2Rvd25TdW0gPSBPYmplY3QudmFsdWVzKG9yYml0YWxCcmVha2Rvd24pLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICBjb25zdCByZWFsaXN0aWNDb3N0UGVyUGZsb3AgPSBicmVha2Rvd25TdW07XG4gIFxuICAvLyBUcmFjayBhcHBsaWVkIG11bHRpcGxpZXJzIGZvciBkZWJ1Z2dpbmdcbiAgY29uc3QgYXBwbGllZE11bHRpcGxpZXJzOiBBcnJheTx7IG5hbWU6IHN0cmluZzsgdmFsdWU6IG51bWJlcjsgYXBwbGllZFRvOiBzdHJpbmcgfT4gPSBbXG4gICAgeyBuYW1lOiAnbGF1bmNoRGlzY291bnQnLCB2YWx1ZTogbGF1bmNoRGlzY291bnQsIGFwcGxpZWRUbzogJ2xhdW5jaCBjb3N0JyB9LFxuICAgIHsgbmFtZTogJ3Bvd2VyRGlzY291bnQnLCB2YWx1ZTogcG93ZXJEaXNjb3VudCwgYXBwbGllZFRvOiAncG93ZXIgZmFiIGNvc3QnIH0sXG4gICAgeyBuYW1lOiAnbmV0d29ya2luZ0Rpc2NvdW50JywgdmFsdWU6IG5ldHdvcmtpbmdEaXNjb3VudCwgYXBwbGllZFRvOiAnbmV0d29ya2luZyBjb3N0JyB9LFxuICAgIHsgbmFtZTogJ21hc3NNdWx0aXBsaWVyJywgdmFsdWU6IG1hc3NNdWx0aXBsaWVyLCBhcHBsaWVkVG86ICd0b3RhbCBtYXNzJyB9LFxuICBdO1xuICBcbiAgLy8gQXNzZXJ0IGNvc3QgYWNjb3VudGluZyAodGhyb3dzIGlmIGludmFsaWQpXG4gIGNvbnN0IG9yYml0YWxBY2NvdW50aW5nID0gYXNzZXJ0Q29zdEFjY291bnRpbmcocmVhbGlzdGljQ29zdFBlclBmbG9wLCBvcmJpdGFsQ29tcG9uZW50cywgYXBwbGllZE11bHRpcGxpZXJzKTtcbiAgY29uc3QgY29zdEFjY291bnRpbmdWYWxpZCA9IG9yYml0YWxBY2NvdW50aW5nLnZhbGlkO1xuICBjb25zdCBjb3N0QWNjb3VudGluZ0Vycm9yUGN0ID0gb3JiaXRhbEFjY291bnRpbmcuZXJyb3JQY3Q7XG5cbiAgLy8gRklYIDU6IEdQVS1ob3VyIGJyZWFrZG93biBtdXN0IGRlcml2ZSBmcm9tIGFubnVhbCBjb3N0IGJyZWFrZG93blxuICAvLyBHUFUtaG91ciBwcmljaW5nOiBBcHBseSBzY2FyY2l0eSBhcyBNVUxUSVBMSUNBVElWRSBtdWx0aXBsaWVyIChub3QgYWRkaXRpdmUpXG4gIC8vIGRlbGF5UGVuYWx0eSByZW1haW5zIGFkZGl0aXZlIChXQUNDIGNhcnJ5IGNvc3QpLCBidXQgc2NhcmNpdHkgcmVudCBpcyBub3cgbXVsdGlwbGljYXRpdmVcbiAgY29uc3QgZGVsYXlQZW5hbHR5UGVyUGZsb3BZZWFyID0gZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRzPy5kZWxheVBlbmFsdHkgfHwgMDtcbiAgY29uc3Qgc2NhcmNpdHlNdWx0aXBsaWVyID0gZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRzPy5zY2FyY2l0eU11bHRpcGxpZXIgPz8gMS4wOyAvLyBNdWx0aXBsaWVyIGZyb20gbG9nLWJhc2VkIGZ1bmN0aW9uXG4gIFxuICAvLyBDb252ZXJ0IGRlbGF5UGVuYWx0eSB0byAkL0dQVS1ob3VyIChzdGlsbCBhZGRpdGl2ZSlcbiAgY29uc3QgcGZsb3BzUGVyR3B1ID0gMi4wO1xuICBjb25zdCB1dGlsaXphdGlvblRhcmdldCA9IDAuODU7XG4gIGNvbnN0IGhvdXJzUGVyWWVhciA9IDg3NjA7XG4gIGNvbnN0IGFubnVhbEdwdUhvdXJzUGVyUEZMT1AgPSBob3Vyc1BlclllYXIgKiB1dGlsaXphdGlvblRhcmdldCAvIHBmbG9wc1BlckdwdTtcbiAgY29uc3QgZGVsYXlQZW5hbHR5QWRkZXJQZXJHcHVIb3VyID0gZGVsYXlQZW5hbHR5UGVyUGZsb3BZZWFyIC8gYW5udWFsR3B1SG91cnNQZXJQRkxPUDtcbiAgXG4gIC8vIE5vdGU6IFNjYXJjaXR5IGlzIG5vdyBNVUxUSVBMSUNBVElWRSAobm90IGFkZGl0aXZlKSwgc28gbm8gY29udmVyc2lvbiBjaGVjayBuZWVkZWRcbiAgLy8gU2NhcmNpdHkgbXVsdGlwbGllciBpcyBhcHBsaWVkIGRpcmVjdGx5IHRvIGJhc2UgY29zdCBpbiBHUFUtaG91ciBwcmljaW5nXG4gIFxuICAvLyBVc2UgQkFTRSBjb3N0ICh3aXRob3V0IHNjYXJjaXR5KSBmb3IgR1BVLWhvdXIgcHJpY2luZywgdGhlbiBhcHBseSBzY2FyY2l0eSBhcyBtdWx0aXBsaWVyXG4gIC8vIFRoaXMgcHJldmVudHMgZG91YmxlLWNvdW50aW5nOiBzY2FyY2l0eSBpcyBtdWx0aXBsaWNhdGl2ZSBpbiBHUFUtaG91ciBwcmljaW5nLCBub3QgYWRkaXRpdmVcbiAgLy8gV2Ugd2FudDogYmFzZUNvc3QgKG5vIHNjYXJjaXR5KSAqIHNjYXJjaXR5TXVsdGlwbGllciA9IHRvdGFsIHdpdGggc2NhcmNpdHlcbiAgLy8gVXNlIGdyb3VuZFJlc3VsdC50b3RhbENvc3RQZXJQZmxvcFllYXJCYXNlIGlmIGF2YWlsYWJsZSAoZnJvbSBidWlsZG91dCBtb2RlbCksIG90aGVyd2lzZSBjb25zdHJ1Y3QgZnJvbSBjb21wb25lbnRzXG4gIGNvbnN0IGdyb3VuZENvc3RCYXNlRm9yUHJpY2luZyA9IHVzZUJ1aWxkb3V0TW9kZWwgJiYgZ3JvdW5kUmVzdWx0Py50b3RhbENvc3RQZXJQZmxvcFllYXJCYXNlICE9PSB1bmRlZmluZWRcbiAgICA/IGdyb3VuZFJlc3VsdC50b3RhbENvc3RQZXJQZmxvcFllYXJCYXNlXG4gICAgOiAoZ3JvdW5kUmVzdWx0LmVuZXJneUNvc3QgKyBncm91bmRSZXN1bHQuc2l0ZUNvc3QgKyBncm91bmRSZXN1bHQuaGFyZHdhcmVDb3N0KSAqIGdyb3VuZExhdGVuY3lQZW5hbHR5O1xuICBcbiAgY29uc3QgZ3JvdW5kR3B1SG91ciA9IChzbGE6IFNMQUNvbmZpZykgPT4ge1xuICAgIGNvbnN0IGJhc2VQcmljaW5nID0gY2FsY3VsYXRlR3B1SG91clByaWNpbmcoZ3JvdW5kQ29zdEJhc2VGb3JQcmljaW5nLCB7XG4gICAgICBwZmxvcHNQZXJHcHUsXG4gICAgICB1dGlsaXphdGlvblRhcmdldCxcbiAgICAgIG9wZXJhdG9yTWFyZ2luUGN0OiBvcGVyYXRvck1hcmdpbixcbiAgICAgIHNsYSxcbiAgICAgIGxvY2F0aW9uOiAnZ3JvdW5kJ1xuICAgIH0sIHtcbiAgICAgIGNvbXB1dGU6IGdyb3VuZFJlc3VsdC5oYXJkd2FyZUNvc3QsXG4gICAgICBwb3dlcjogZ3JvdW5kUmVzdWx0LmVuZXJneUNvc3QsXG4gICAgICBzaXRlOiB1c2VCdWlsZG91dE1vZGVsID8gZ3JvdW5kUmVzdWx0LnNpdGVDYXBleEFtb3J0UGVyUGZsb3BZZWFyIDogZ3JvdW5kUmVzdWx0LnNpdGVDb3N0LFxuICAgICAgLy8gR3JvdW5kIGNvb2xpbmcgaW5jbHVkZWQgaW4gZW5lcmd5LCBpbnRlcmNvbm5lY3QgbWluaW1hbFxuICAgIH0pO1xuICAgIFxuICAgIC8vIFVOSUZJRUQgU0NBUkNJVFkgQUNDT1VOVElORzogU2NhcmNpdHkgaXMgTVVMVElQTElDQVRJVkUgKG5vdCBhZGRpdGl2ZSlcbiAgICAvLyBDUklUSUNBTCBGSVg6IEFwcGx5IHNjYXJjaXR5IGFzIHByZW1pdW0gb24gRklYRUQgcmVmZXJlbmNlIGJhc2UsIG5vdCBkZWNsaW5pbmcgYmFzZVxuICAgIC8vIFRoaXMgcHJldmVudHMgTW9vcmUncyBMYXcgZnJvbSBlcm9kaW5nIHNjYXJjaXR5IGRvbGxhciBhbW91bnRzXG4gICAgXG4gICAgLy8gRXh0cmFjdCBiYXNlIGNvc3QgYmVmb3JlIG1hcmdpbiAodGhpcyBkZWNsaW5lcyB3aXRoIE1vb3JlJ3MgTGF3KVxuICAgIGNvbnN0IHByZU1hcmdpbkJhc2UgPSBiYXNlUHJpY2luZy5wcmljZVBlckdwdUhvdXIgLSAoYmFzZVByaWNpbmcuY29zdEJyZWFrZG93bi5tYXJnaW4gfHwgMCk7XG4gICAgXG4gICAgLy8gU2NhcmNpdHkgcHJlbWl1bSBiYXNlZCBvbiBGSVhFRCByZWZlcmVuY2UsIG5vdCBkZWNsaW5pbmcgYmFzZVxuICAgIC8vIFRoaXMgZW5zdXJlcyBzY2FyY2l0eSBkb2Vzbid0IGdldCBlcm9kZWQgYnkgTW9vcmUncyBMYXdcbiAgICBjb25zdCBTQ0FSQ0lUWV9SRUZFUkVOQ0VfQkFTRSA9IDMuNTA7IC8vIEZpeGVkIDIwMjUgbWFya2V0IHJlZmVyZW5jZSAoJC9HUFUtaHIpXG4gICAgY29uc3Qgc2NhcmNpdHlQcmVtaXVtID0gKHNjYXJjaXR5TXVsdGlwbGllciAtIDEpICogU0NBUkNJVFlfUkVGRVJFTkNFX0JBU0U7XG4gICAgXG4gICAgLy8gVG90YWwgY29zdCA9IGJhc2UgKGRlY2xpbmluZyB3aXRoIE1vb3JlJ3MgTGF3KSArIHNjYXJjaXR5IChmaXhlZCkgKyBkZWxheVxuICAgIGNvbnN0IGNvc3RXaXRoU2NhcmNpdHkgPSBwcmVNYXJnaW5CYXNlICsgc2NhcmNpdHlQcmVtaXVtO1xuICAgIGNvbnN0IGNvc3RXaXRoU2NhcmNpdHlBbmREZWxheSA9IGNvc3RXaXRoU2NhcmNpdHkgKyBkZWxheVBlbmFsdHlBZGRlclBlckdwdUhvdXI7XG4gICAgXG4gICAgLy8gVGhlbiBhZGQgbWFyZ2luXG4gICAgY29uc3QgbWFyZ2luID0gY29zdFdpdGhTY2FyY2l0eUFuZERlbGF5ICogb3BlcmF0b3JNYXJnaW47XG4gICAgY29uc3QgcHJpY2VQZXJHcHVIb3VyID0gY29zdFdpdGhTY2FyY2l0eUFuZERlbGF5ICsgbWFyZ2luO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAuLi5iYXNlUHJpY2luZyxcbiAgICAgIHByaWNlUGVyR3B1SG91cixcbiAgICAgIGNvc3RCcmVha2Rvd246IHtcbiAgICAgICAgLi4uYmFzZVByaWNpbmcuY29zdEJyZWFrZG93bixcbiAgICAgICAgc2NhcmNpdHk6IHNjYXJjaXR5UHJlbWl1bSwgLy8gRml4ZWQtYmFzZSBzY2FyY2l0eSBwcmVtaXVtIChkb2Vzbid0IGRlY2xpbmUgd2l0aCBNb29yZSdzIExhdylcbiAgICAgICAgZGVsYXlQZW5hbHR5OiBkZWxheVBlbmFsdHlBZGRlclBlckdwdUhvdXIsIC8vIERlbGF5IHBlbmFsdHkgKFdBQ0MgY2FycnkpXG4gICAgICAgIG1hcmdpbiwgLy8gb3ZlcndyaXRlIHdpdGggcmVjb21wdXRlZCBtYXJnaW5cbiAgICAgIH0sXG4gICAgfTtcbiAgfTtcblxuICBjb25zdCBvcmJpdGFsR3B1SG91ciA9IChzbGE6IFNMQUNvbmZpZykgPT4gY2FsY3VsYXRlR3B1SG91clByaWNpbmcocmVhbGlzdGljQ29zdFBlclBmbG9wLCB7XG4gICAgcGZsb3BzUGVyR3B1OiAyLjAsXG4gICAgdXRpbGl6YXRpb25UYXJnZXQ6IDAuODUsXG4gICAgb3BlcmF0b3JNYXJnaW5QY3Q6IG9wZXJhdG9yTWFyZ2luLFxuICAgIHNsYSxcbiAgICBsb2NhdGlvbjogJ29yYml0YWwnXG4gIH0sIG9yYml0YWxCcmVha2Rvd24pOyAvLyBVc2UgZnVsbCBvcmJpdGFsIGJyZWFrZG93blxuXG4gIGNvbnN0IGdyb3VuZFRva2VucyA9IHtcbiAgICBsbGFtYTcwQjogY2FsY3VsYXRlVG9rZW5QcmljaW5nKGdyb3VuZFRvdGFsQ29zdCwgeyBwYXJhbXM6IDcwZTksIHByZWNpc2lvbjogJ2ZwMTYnIH0pLFxuICAgIGxsYW1hNDA1QjogY2FsY3VsYXRlVG9rZW5QcmljaW5nKGdyb3VuZFRvdGFsQ29zdCwgeyBwYXJhbXM6IDQwNWU5LCBwcmVjaXNpb246ICdmcDE2JyB9KVxuICB9O1xuXG4gIGNvbnN0IG9yYml0YWxUb2tlbnMgPSB7XG4gICAgbGxhbWE3MEI6IGNhbGN1bGF0ZVRva2VuUHJpY2luZyhyZWFsaXN0aWNDb3N0UGVyUGZsb3AsIHsgcGFyYW1zOiA3MGU5LCBwcmVjaXNpb246ICdmcDE2JyB9KSxcbiAgICBsbGFtYTQwNUI6IGNhbGN1bGF0ZVRva2VuUHJpY2luZyhyZWFsaXN0aWNDb3N0UGVyUGZsb3AsIHsgcGFyYW1zOiA0MDVlOSwgcHJlY2lzaW9uOiAnZnAxNicgfSlcbiAgfTtcblxuICBjb25zdCBlZGdlSW5mZXJlbmNlID0gcGFyYW1zLmVkZ2VJbmZlcmVuY2U/LmVuYWJsZWQgXG4gICAgPyBjb21wdXRlRWRnZUluZmVyZW5jZUNvc3RzKHllYXIsIHBhcmFtcy5lZGdlSW5mZXJlbmNlLCBsYXVuY2hDb3N0UGVyS2csIHRvdGFsRWZmZWN0aXZlUGZsb3BzIC8gZWZmZWN0aXZlVG90YWxNYXNzS2cpXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3QgZ3B1SG91ckNyb3Nzb3ZlciA9IG9yYml0YWxHcHVIb3VyKFNMQV9USUVSUy5zdGFuZGFyZCkucHJpY2VQZXJHcHVIb3VyIDwgZ3JvdW5kR3B1SG91cihTTEFfVElFUlMuc3RhbmRhcmQpLnByaWNlUGVyR3B1SG91cjtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIERFQlVHIElOVkFSSUFOVFMgKGRldmVsb3BtZW50IG1vZGUgb25seSlcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAvLyBJbnZhcmlhbnQgMTogSWYgYXZnV2FpdFllYXJzID4gMCB0aGVuIHNjYXJjaXR5IG11bHRpcGxpZXIgc2hvdWxkIGJlID4gMS4wIChzY2FyY2l0eSBpcyBtdWx0aXBsaWNhdGl2ZSBpbiBHUFUtaG91ciBwcmljaW5nKVxuICAgIGNvbnN0IGF2Z1dhaXRZZWFycyA9IGdyb3VuZFJlc3VsdC5zdXBwbHlNZXRyaWNzPy5hdmdXYWl0WWVhcnMgPz8gMDtcbiAgICBjb25zdCBzY2FyY2l0eU11bHRpcGxpZXIgPSBncm91bmRSZXN1bHQuY29uc3RyYWludHM/LnNjYXJjaXR5TXVsdGlwbGllciA/PyAxLjA7XG4gICAgaWYgKGF2Z1dhaXRZZWFycyA+IDEuMCAmJiBzY2FyY2l0eU11bHRpcGxpZXIgPD0gMS4wKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbSU5WQVJJQU5UIFZJT0xBVElPTl0gWWVhciAke3llYXJ9OiBhdmdXYWl0WWVhcnM9JHthdmdXYWl0WWVhcnN9ID4gMS4wIGJ1dCBzY2FyY2l0eU11bHRpcGxpZXI9JHtzY2FyY2l0eU11bHRpcGxpZXJ9IDw9IDEuMC4gYCArXG4gICAgICAgIGBTY2FyY2l0eSBtdWx0aXBsaWVyIHNob3VsZCBiZSA+IDEuMCB3aGVuIHdhaXQgdGltZSBleGlzdHMgKHNjYXJjaXR5IGlzIG11bHRpcGxpY2F0aXZlIGluIEdQVS1ob3VyIHByaWNpbmcpLmBcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIC8vIEludmFyaWFudCAyOiBzdXBwbHlNZXRyaWNzLmNhcGFjaXR5R3cgaXMgdGhlIGVmZmVjdGl2ZSBjYXBhY2l0eSAoYm90dGxlbmVjaylcbiAgICAvLyBRdWV1ZSBtb2RlbCB1c2VzIGNvaGVyZW50IGJhY2tsb2cgYmFzZWQgb24gdW5tZXQgZGVtYW5kXG4gICAgXG4gICAgLy8gSW52YXJpYW50IDM6IEdQVS1ob3VyIGNoYXJ0IHlNYXggZ3VhcmQgKHByZXZlbnRlZCBieSBleHBsaWNpdCBzZXJpZXMgZXh0cmFjdGlvbiBpbiBjaGFydCBjb21wb25lbnQpXG4gICAgLy8gVGhpcyBpcyBoYW5kbGVkIGluIHRoZSBjaGFydCBjb21wb25lbnQgd2l0aCBleHBsaWNpdCBzZXJpZXMgZXh0cmFjdGlvblxuICAgIFxuICAgIC8vIEludmFyaWFudCA0OiBDcm9zc292ZXIgdXNlcyBlZmZlY3RpdmUgZ3JvdW5kIGNvc3RcbiAgICBjb25zdCBncm91bmRFZmZlY3RpdmUgPSBncm91bmRSZXN1bHQudG90YWxDb3N0UGVyUGZsb3BZZWFyRWZmZWN0aXZlID8/IGdyb3VuZFJlc3VsdC50b3RhbENvc3RQZXJQZmxvcFllYXI7XG4gICAgY29uc3QgZ3JvdW5kSGVhZGxpbmUgPSBncm91bmRSZXN1bHQudG90YWxDb3N0UGVyUGZsb3BZZWFyO1xuICAgIGNvbnN0IGRlbGF5UGVuYWx0eSA9IGdyb3VuZFJlc3VsdC5jb25zdHJhaW50cz8uZGVsYXlQZW5hbHR5ID8/IDA7XG4gICAgLy8gU2NhcmNpdHkgaXMgbm93IG11bHRpcGxpY2F0aXZlIChub3QgYWRkaXRpdmUpLCBzbyBkb24ndCBhZGQgaXQgdG8gZWZmZWN0aXZlIGNvc3RcbiAgICBjb25zdCBleHBlY3RlZEVmZmVjdGl2ZSA9IGdyb3VuZEhlYWRsaW5lICsgZGVsYXlQZW5hbHR5OyAvLyBTY2FyY2l0eSBhcHBsaWVkIGluIEdQVS1ob3VyIHByaWNpbmcsIG5vdCBQRkxPUC15ZWFyXG4gICAgY29uc3QgZWZmZWN0aXZlRXJyb3IgPSBNYXRoLmFicyhncm91bmRFZmZlY3RpdmUgLSBleHBlY3RlZEVmZmVjdGl2ZSk7XG4gICAgLy8gUmV1c2Ugc2NhcmNpdHlNdWx0aXBsaWVyIGZyb20gSW52YXJpYW50IDEgYWJvdmVcbiAgICBpZiAoZWZmZWN0aXZlRXJyb3IgPiAwLjAxICYmIChkZWxheVBlbmFsdHkgPiAwIHx8IHNjYXJjaXR5TXVsdGlwbGllciA+IDEuMCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFtJTlZBUklBTlQgVklPTEFUSU9OXSBZZWFyICR7eWVhcn06IGdyb3VuZEVmZmVjdGl2ZT0ke2dyb3VuZEVmZmVjdGl2ZX0gIT0gZXhwZWN0ZWQ9JHtleHBlY3RlZEVmZmVjdGl2ZX0gYCArXG4gICAgICAgIGAoaGVhZGxpbmU9JHtncm91bmRIZWFkbGluZX0sIGRlbGF5UGVuYWx0eT0ke2RlbGF5UGVuYWx0eX0sIHNjYXJjaXR5TXVsdGlwbGllcj0ke3NjYXJjaXR5TXVsdGlwbGllcn0pLiBgICtcbiAgICAgICAgYENyb3Nzb3ZlciBzaG91bGQgdXNlIGVmZmVjdGl2ZSBjb3N0LiBOb3RlOiBzY2FyY2l0eSBpcyBtdWx0aXBsaWNhdGl2ZSBpbiBHUFUtaG91ciBwcmljaW5nLCBub3QgYWRkaXRpdmUgaW4gUEZMT1AteWVhci5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8vIENSSVRJQ0FMIEZJWDogVmFsaWRhdGUgZGVsaXZlcmVkIGVmZmljaWVuY3kgYnkgY29tcGFyaW5nIGxpa2UtZm9yLWxpa2Ugb25seVxuICAvLyBleHBlY3RlZERlbGl2ZXJlZCA9IHN5c3RlbUVmZmVjdGl2ZUdmbG9wc1BlcldhdHQgKiB0aGVybWFsQ2FwRmFjdG9yICogcmFkaWF0aW9uRGVyYXRlICogYXZhaWxhYmlsaXR5XG4gIC8vIHJhdGlvID0gZGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCAvIGV4cGVjdGVkRGVsaXZlcmVkXG4gIC8vIElmIHJhdGlvIGlzIGZpbml0ZSBhbmQgfDEgLSByYXRpb3wgPD0gdG9sZXJhbmNlICgwLjAyKSwgdGhlbiB2YWxpZD10cnVlLCB3YXJuaW5nPW51bGxcbiAgLy8gRWxzZSB2YWxpZD1mYWxzZSwgd2FybmluZyBkZXNjcmliZXMgdGhlIG1pc21hdGNoXG4gIC8vIFJlbW92ZSBhbnkgb3RoZXIgY29tcGFyaXNvbnMgKGUuZy4sIGRlbGl2ZXJlZCB2cyBzeXN0ZW1FZmZlY3RpdmUsIGRlbGl2ZXJlZCB2cyBwZWFrKnV0aWxpemF0aW9uIHdpdGhvdXQgb3ZlcmhlYWQsIGV0Yy4pXG4gIGNvbnN0IGV4cGVjdGVkRGVsaXZlcmVkID0gb3JiaXRTeXN0ZW1FZmZlY3RpdmVHZmxvcHNQZXJXYXR0ICogdGhlcm1hbENhcEZhY3RvciAqIHJhZGlhdGlvbkRlcmF0ZSAqIGF2YWlsYWJpbGl0eTtcbiAgY29uc3QgcmF0aW8gPSBvcmJpdERlbGl2ZXJlZEdmbG9wc1BlcldhdHQgLyBNYXRoLm1heChleHBlY3RlZERlbGl2ZXJlZCwgMWUtNik7XG4gIGNvbnN0IFRPTEVSQU5DRSA9IDAuMDI7IC8vIDIlIHRvbGVyYW5jZVxuICBjb25zdCByYXRpb0Vycm9yID0gTWF0aC5hYnMoMSAtIHJhdGlvKTtcbiAgXG4gIC8vIENSSVRJQ0FMOiBGaXggdmFsaWRhdG9yIGxvZ2ljIC0gaWYgcmF0aW8gaXMgZmluaXRlIGFuZCB8MSAtIHJhdGlvfCA8PSB0b2xlcmFuY2UsIHRoZW4gdmFsaWQ9dHJ1ZVxuICBjb25zdCBpc1JhdGlvVmFsaWQgPSBpc0Zpbml0ZShyYXRpbykgJiYgcmF0aW9FcnJvciA8PSBUT0xFUkFOQ0U7XG4gIFxuICAvLyBFc2NhbGF0ZTogaWYgbWlzbWF0Y2ggPiA1JSwgbWFyayBhcyBpbnZhbGlkIChkb24ndCBqdXN0IHdhcm4pXG4gIGNvbnN0IEVTQ0FMQVRFX1RIUkVTSE9MRCA9IDAuMDU7IC8vIDUlXG4gIGNvbnN0IGlzSW52YWxpZCA9ICFpc1JhdGlvVmFsaWQgJiYgcmF0aW9FcnJvciA+IEVTQ0FMQVRFX1RIUkVTSE9MRDtcbiAgXG4gIC8vIERlYnVnIGludmFyaWFudHM6IGFzc2VydCBkZWxpdmVyZWQgPD0gc3lzdGVtRWZmZWN0aXZlICsgZXBzXG4gIGNvbnN0IGRlbGl2ZXJlZFZzU3lzdGVtRXJyb3IgPSBvcmJpdERlbGl2ZXJlZEdmbG9wc1BlcldhdHQgLSBvcmJpdFN5c3RlbUVmZmVjdGl2ZUdmbG9wc1BlcldhdHQ7XG4gIGlmIChkZWxpdmVyZWRWc1N5c3RlbUVycm9yID4gMWUtNikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBbSU5WQVJJQU5UIFZJT0xBVElPTl0gRGVsaXZlcmVkIGVmZmljaWVuY3kgKCR7b3JiaXREZWxpdmVyZWRHZmxvcHNQZXJXYXR0LnRvRml4ZWQoMil9KSA+IHN5c3RlbUVmZmVjdGl2ZSAoJHtvcmJpdFN5c3RlbUVmZmVjdGl2ZUdmbG9wc1BlcldhdHQudG9GaXhlZCgyKX0pLiBgICtcbiAgICAgIGBEZWxpdmVyZWQgbXVzdCBiZSA8PSBzeXN0ZW1FZmZlY3RpdmUuYFxuICAgICk7XG4gIH1cbiAgXG4gIC8vIEVmZmljaWVuY3kgZGVidWcgbG9nZ2luZyByZW1vdmVkIGZvciBjbGVhbmVyIGNvbnNvbGUgb3V0cHV0XG4gIC8vIFZhbGlkYXRpb24gcmVzdWx0cyBhcmUgYXZhaWxhYmxlIGluIG9yYml0LmNvbXB1dGVFZmZpY2llbmN5LnZhbGlkYXRpb24gbWV0YWRhdGFcbiAgXG4gIC8vIENSSVRJQ0FMOiBWYWxpZGF0ZSBkZWxpdmVyZWQgZWZmaWNpZW5jeSAtIGNvbXBhcmUgZGVsaXZlcmVkIHZzIGV4cGVjdGVkRGVsaXZlcmVkIG9ubHlcbiAgLy8gTWFrZSB2YWxpZGF0b3IgZGVidWcgZXhwbGljaXQgd2l0aCBhbGwgZmFjdG9yc1xuICAvLyBJZiBtaXNtYXRjaCA+IDUlLCBtYXJrIHJ1biBpbnZhbGlkIGFuZCBzdG9wIGNoYXJ0IHJlbmRlcmluZyAoZXNjYWxhdGUsIGRvbid0IHNpbGVudGx5IHdhcm4pXG4gIGNvbnN0IGRlbGl2ZXJlZFZhbGlkYXRpb24gPSB7XG4gICAgdmFsaWQ6IGlzUmF0aW9WYWxpZCxcbiAgICB3YXJuaW5nOiBpc1JhdGlvVmFsaWQgXG4gICAgICA/IHVuZGVmaW5lZCAvLyBFbXB0eS9udWxsIHdoZW4gdmFsaWRcbiAgICAgIDogYFBvd2VyL0VmZmljaWVuY3kgbWlzbWF0Y2g6ICR7cmF0aW8udG9GaXhlZCgyKX14IGRpc2NyZXBhbmN5IChleHBlY3RlZD0ke2V4cGVjdGVkRGVsaXZlcmVkLnRvRml4ZWQoMil9LCBkZWxpdmVyZWQ9JHtvcmJpdERlbGl2ZXJlZEdmbG9wc1BlcldhdHQudG9GaXhlZCgyKX0pYCxcbiAgICBleHBlY3RlZERlbGl2ZXJlZCxcbiAgICBkZWxpdmVyZWQ6IG9yYml0RGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCxcbiAgICByYXRpbyxcbiAgICBmYWN0b3JzVXNlZDoge1xuICAgICAgdGhlcm1hbENhcEZhY3RvcixcbiAgICAgIHJhZGlhdGlvbkRlcmF0ZSxcbiAgICAgIGF2YWlsYWJpbGl0eSxcbiAgICAgIHV0aWxpemF0aW9uOiBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5kZWJ1Zy51dGlsaXphdGlvbkZhY3RvcixcbiAgICAgIHN5c3RlbU92ZXJoZWFkRmFjdG9yOiBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5kZWJ1Zy5zeXN0ZW1PdmVyaGVhZEZhY3RvcixcbiAgICB9LFxuICAgIC8vIEVzY2FsYXRlOiBpZiByYXRpbyBpcyB3YXkgb2ZmICg+IDUlKSwgbWFyayBhcyBpbnZhbGlkXG4gICAgaW52YWxpZDogIWlzUmF0aW9WYWxpZCAmJiBNYXRoLmFicygxIC0gcmF0aW8pID4gMC4wNSxcbiAgfTtcbiAgXG4gIGNvbnN0IGVmZmljaWVuY3lWYWxpZGF0aW9uID0gdmFsaWRhdGVDb21wdXRlRWZmaWNpZW5jeShvcmJpdEVmZmVjdGl2ZUdmbG9wc1BlclcsIHBhcmFtcy5lZmZpY2llbmN5TGV2ZWwpO1xuICBjb25zdCBjb25zaXN0ZW5jeUNoZWNrID0gYXNzZXJ0Q29tcHV0ZVBvd2VyQ29uc2lzdGVuY3kob3JiaXRFZmZlY3RpdmVHZmxvcHNQZXJXLCB0YXJnZXRDb21wdXRlS3csIHRvdGFsRWZmZWN0aXZlUGZsb3BzLCBNT0RFTF9VTklUUyk7XG5cbiAgLy8gU0FOSVRZIFBBTkVMOiBDb21wcmVoZW5zaXZlIGRlYnVnIGJsb2NrIHBlciB5ZWFyXG4gIGNvbnN0IHNhbml0eVBhbmVsID0ge1xuICAgIGdyb3VuZDoge1xuICAgICAgZWZmZWN0aXZlR2Zsb3BzUGVyVzogZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyVyxcbiAgICAgIGVuZXJneUNvc3RQZXJQZmxvcFllYXI6IGdyb3VuZFJlc3VsdC5lbmVyZ3lDb3N0LFxuICAgICAgc2l0ZUNhcGV4QW1vcnQ6IGdyb3VuZFJlc3VsdC5zaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciA/PyAoZ3JvdW5kUmVzdWx0LnNpdGVDb3N0IC0gKGdyb3VuZFJlc3VsdC5jYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSA/PyAwKSAtIChncm91bmRSZXN1bHQudGltZVRvRW5lcmdpemVQZW5hbHR5ID8/IDApKSxcbiAgICAgIGRlbGF5UGVuYWx0eTogZ3JvdW5kUmVzdWx0LnRpbWVUb0VuZXJnaXplUGVuYWx0eSA/PyAwLFxuICAgICAgY2FwYWNpdHlQcmVtaXVtOiBncm91bmRSZXN1bHQuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gPz8gMCxcbiAgICAgIGNvbnN0cmFpbnRNdWx0aXBsaWVyOiBncm91bmRSZXN1bHQuY29uc3RyYWludE11bHRpcGxpZXIsXG4gICAgICB0b3RhbDogZ3JvdW5kVG90YWxDb3N0LFxuICAgIH0sXG4gICAgb3JiaXQ6IHtcbiAgICAgIC8vIFJFTU9WRUQ6IGVmZmVjdGl2ZVNwZWNpZmljUG93ZXIgKGR1cGxpY2F0ZSBvZiBzcGVjaWZpY1Bvd2VyX2VmZmVjdGl2ZV9XUGVyS2cpXG4gICAgICAvLyBVc2Ugc3BlY2lmaWNQb3dlcl9lZmZlY3RpdmVfV1BlcktnIGluc3RlYWQgKGNhbm9uaWNhbCBmaWVsZClcbiAgICAgIG1hc3NNdWx0aXBsaWVyOiBoeWJyaWRSZXN1bHQuc3BlY2lmaWNQb3dlck11bHRpcGxpZXJzPy5tYXNzTXVsdGlwbGllciA/PyAxLjAsXG4gICAgICByZXF1aXJlZEFyZWFNMjogaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0ucVBlck0yX1cgPyAoaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0ud2FzdGVIZWF0VyA/PyBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS53YXN0ZUhlYXRLdyAqIDEwMDApIC8gKGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnFQZXJNMl9XID8/IDEpIDogaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0ucGh5c2ljYWxBcmVhTTIsXG4gICAgICBhcmVhQXZhaWxhYmxlTTI6IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLmFyZWFBdmFpbGFibGVNMiA/PyBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS5waHlzaWNhbEFyZWFNMixcbiAgICAgIHRoZXJtYWxDYXBGYWN0b3I6IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnRoZXJtYWxDYXBGYWN0b3IsXG4gICAgICB0b3RhbDogcmVhbGlzdGljQ29zdFBlclBmbG9wLFxuICAgIH0sXG4gICAgYWxsSW52YXJpYW50c1Bhc3NlZDogKCgpID0+IHtcbiAgICAgIC8vIENoZWNrIGtleSBpbnZhcmlhbnRzXG4gICAgICBjb25zdCBzaXRlQ29zdENoZWNrID0gTWF0aC5hYnMoZ3JvdW5kUmVzdWx0LnNpdGVDb3N0IC0gKChncm91bmRSZXN1bHQuc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXIgPz8gMCkgKyAoZ3JvdW5kUmVzdWx0LnRpbWVUb0VuZXJnaXplUGVuYWx0eSA/PyAwKSArIChncm91bmRSZXN1bHQuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gPz8gMCkpKSA8IDAuMDE7XG4gICAgICBjb25zdCB0aGVybWFsQXJlYUNoZWNrID0gaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0uYXJlYUF2YWlsYWJsZU0yID8gTWF0aC5hYnMoaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0uYXJlYUF2YWlsYWJsZU0yIC0gaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0ucGh5c2ljYWxBcmVhTTIpIC8gaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0ucGh5c2ljYWxBcmVhTTIgPCAwLjAxIDogdHJ1ZTtcbiAgICAgIGNvbnN0IHNwZWNpZmljUG93ZXJDaGVjayA9IGh5YnJpZFJlc3VsdC5zcGVjaWZpY1Bvd2VyTXVsdGlwbGllcnMgPyBoeWJyaWRSZXN1bHQuc3BlY2lmaWNQb3dlck11bHRpcGxpZXJzLmVmZmVjdGl2ZSA8PSBoeWJyaWRSZXN1bHQuc3BlY2lmaWNQb3dlck11bHRpcGxpZXJzLmJhc2VTcGVjaWZpY1Bvd2VyICogMS4wMSA6IHRydWU7XG4gICAgICBjb25zdCB0aGVybWFsQ2FwQ2hlY2sgPSBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS50aGVybWFsQ2FwRmFjdG9yID49IDAgJiYgaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0udGhlcm1hbENhcEZhY3RvciA8PSAxO1xuICAgICAgcmV0dXJuIHNpdGVDb3N0Q2hlY2sgJiYgdGhlcm1hbEFyZWFDaGVjayAmJiBzcGVjaWZpY1Bvd2VyQ2hlY2sgJiYgdGhlcm1hbENhcENoZWNrO1xuICAgIH0pKCksXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICB5ZWFyLFxuICAgIG1vZGU6IHBhcmFtcy5pc1N0YXRpY01vZGUgPyAnU1RBVElDJyA6ICdEWU5BTUlDJyxcbiAgICBzYW5pdHlQYW5lbCxcbiAgICBncm91bmQ6IHtcbiAgICAgIGVsZWN0cmljaXR5UHJpY2VQZXJNd2g6IGdyb3VuZEVsZWN0cmljaXR5UHJpY2VQZXJNd2gsXG4gICAgICBwdWU6IGVmZmVjdGl2ZVB1ZUdyb3VuZCxcbiAgICAgIGNhcGFjaXR5RmFjdG9yOiBjYXBhY2l0eUZhY3Rvckdyb3VuZCxcbiAgICAgIC8vIEhBUkQgQVNTRVJUOiBBbGwgZ3JvdW5kIGVmZmljaWVuY3kgZmllbGRzIG11c3QgYmUgcG9wdWxhdGVkIGFuZCBmaW5pdGVcbiAgICAgIGdmbG9wc1BlcldhdHQ6ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyVztcbiAgICAgICAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkgfHwgdmFsdWUgPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZ3JvdW5kLmdmbG9wc1BlcldhdHQgaXMgaW52YWxpZDogJHt2YWx1ZX0uIGFjdHVhbEdyb3VuZElucHV0PSR7YWN0dWFsR3JvdW5kSW5wdXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSkoKSwgLy8gRWZmZWN0aXZlIChzeXN0ZW0pIEdGTE9QUy9XXG4gICAgICBjb21wdXRlRGVmaW5pdGlvbjogKCgpID0+IHtcbiAgICAgICAgLy8gQ1JJVElDQUwgRklYOiBWYWxpZGF0ZSBhbGwgY29tcHV0ZURlZmluaXRpb24gZmllbGRzIHRvIGNhdGNoIHVuaXQgY29ycnVwdGlvblxuICAgICAgICBjb25zdCBwZWFrID0gdmFsaWRhdGVHZmxvcHNQZXJXYXR0KFxuICAgICAgICAgIGdyb3VuZEVmZmljaWVuY3lSZXN1bHQuZGVidWcuY2hpcFBlYWtHZmxvcHNQZXJXLFxuICAgICAgICAgICdncm91bmQuY29tcHV0ZURlZmluaXRpb24ucGVha0dmbG9wc1BlcldhdHQnXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZSA9IHZhbGlkYXRlR2Zsb3BzUGVyV2F0dChcbiAgICAgICAgICBncm91bmRFZmZpY2llbmN5UmVzdWx0LmRlYnVnLmVmZmVjdGl2ZUdmbG9wc1BlclcsXG4gICAgICAgICAgJ2dyb3VuZC5jb21wdXRlRGVmaW5pdGlvbi5lZmZlY3RpdmVHZmxvcHNQZXJXYXR0J1xuICAgICAgICApO1xuICAgICAgICBjb25zdCB1dGlsaXphdGlvbiA9IGdyb3VuZEVmZmljaWVuY3lSZXN1bHQuZGVidWcudXRpbGl6YXRpb25GYWN0b3I7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWlzRmluaXRlKHV0aWxpemF0aW9uKSB8fCB1dGlsaXphdGlvbiA8PSAwIHx8IHV0aWxpemF0aW9uID4gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZ3JvdW5kLmNvbXB1dGVEZWZpbml0aW9uLnV0aWxpemF0aW9uRmFjdG9yIGlzIGludmFsaWQ6ICR7dXRpbGl6YXRpb259YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hpcE5hbWU6ICdOVklESUEgSDEwMCBTWE0nLFxuICAgICAgICAgIHByZWNpc2lvbjogJ0ZQMTYnLFxuICAgICAgICAgIHBlYWtHZmxvcHNQZXJXYXR0OiBwZWFrLFxuICAgICAgICAgIHV0aWxpemF0aW9uRmFjdG9yOiB1dGlsaXphdGlvbixcbiAgICAgICAgICBlZmZlY3RpdmVHZmxvcHNQZXJXYXR0OiBlZmZlY3RpdmUsXG4gICAgICAgICAgbm90ZXM6ICdEYXRhY2VudGVyIGRlcGxveW1lbnQsIHN5c3RlbS1sZXZlbCBlZmZpY2llbmN5JyxcbiAgICAgICAgfTtcbiAgICAgIH0pKCksXG4gICAgICBlbmVyZ3lDb3N0UGVyUGZsb3BZZWFyOiAoKCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdyb3VuZFJlc3VsdC5lbmVyZ3lDb3N0O1xuICAgICAgICBpZiAoIWlzRmluaXRlKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgZ3JvdW5kLmVuZXJneUNvc3RQZXJQZmxvcFllYXIgaXMgaW52YWxpZDogJHt2YWx1ZX0uIGAgK1xuICAgICAgICAgICAgYENoZWNrOiBncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXPSR7Z3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyV30sIGAgK1xuICAgICAgICAgICAgYGdyb3VuZEVsZWN0cmljaXR5UHJpY2VQZXJNd2g9JHtncm91bmRFbGVjdHJpY2l0eVByaWNlUGVyTXdofSwgYCArXG4gICAgICAgICAgICBgZWZmZWN0aXZlUHVlR3JvdW5kPSR7ZWZmZWN0aXZlUHVlR3JvdW5kfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pKCksIC8vIFJhdyBlbGVjdHJpY2l0eSAoTk8gY29uc3RyYWludCBtdWx0aXBsaWVyKVxuICAgICAgc2l0ZUNvc3RQZXJQZmxvcFllYXI6ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ3JvdW5kUmVzdWx0LnNpdGVDb3N0O1xuICAgICAgICBpZiAoIWlzRmluaXRlKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGdyb3VuZC5zaXRlQ29zdFBlclBmbG9wWWVhciBpcyBpbnZhbGlkOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pKCksIC8vIFNpdGUgY29zdHMgPSBzdW0gb2YgY29tcG9uZW50cyAoSU5WQVJJQU5UKVxuICAgICAgc2l0ZUNhcGV4QW1vcnRQZXJQZmxvcFllYXI6IGdyb3VuZFJlc3VsdC5zaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciA/PyAoZ3JvdW5kUmVzdWx0LnNpdGVDb3N0IC0gKGdyb3VuZFJlc3VsdC5jYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSA/PyAwKSAtIChncm91bmRSZXN1bHQudGltZVRvRW5lcmdpemVQZW5hbHR5ID8/IDApKSwgLy8gUHVyZSBjYXBleCBhbW9ydGl6YXRpb25cbiAgICAgIGNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtOiBncm91bmRSZXN1bHQuY2FwYWNpdHlEZWxpdmVyeVByZW1pdW0gPz8gMCwgLy8gRXhwbGljaXQgY2FwYWNpdHkvZGVsaXZlcnkgcHJlbWl1bSAoaW5kZXBlbmRlbnQpXG4gICAgICB0aW1lVG9FbmVyZ2l6ZVBlbmFsdHk6IGdyb3VuZFJlc3VsdC50aW1lVG9FbmVyZ2l6ZVBlbmFsdHkgPz8gMCwgLy8gUXVldWUgZGVsYXkgcGVuYWx0eSAoV0FDQy1iYXNlZCwgaW5kZXBlbmRlbnQpXG4gICAgICBoYXJkd2FyZUNhcGV4UGVyUGZsb3BZZWFyOiBncm91bmRSZXN1bHQuaGFyZHdhcmVDb3N0LFxuICAgICAgY29uc3RyYWludE11bHRpcGxpZXI6IDEuMCwgLy8gTk9UIEFQUExJRUQgLSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXQgb25seVxuICAgICAgY29uc3RyYWludEJyZWFrZG93bjoge1xuICAgICAgICAuLi5jb25zdHJhaW50QnJlYWtkb3duLFxuICAgICAgICBjYXBhY2l0eURlbGl2ZXJ5TXVsdGlwbGllcjogMS4wLCAvLyBOb3QgYXBwbGllZFxuICAgICAgfSxcbiAgICAgIGNvbnN0cmFpbnRzOiAoZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRzID8ge1xuICAgICAgICAuLi5ncm91bmRSZXN1bHQuY29uc3RyYWludHMsXG4gICAgICAgIG1ldGhvZDogJ2FkZGVycycgYXMgY29uc3QsXG4gICAgICB9IDoge1xuICAgICAgICBtZXRob2Q6ICdhZGRlcnMnIGFzIGNvbnN0LFxuICAgICAgICBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bTogKGdyb3VuZFJlc3VsdC5jYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSB8fCAwKSxcbiAgICAgICAgZGVsYXlQZW5hbHR5OiAoZ3JvdW5kUmVzdWx0LnRpbWVUb0VuZXJnaXplUGVuYWx0eSB8fCAwKSxcbiAgICAgICAgYXBwbGllZE11bHRpcGxpZXJzOiB7XG4gICAgICAgICAgY29uc3RyYWludE11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgICBlbmVyZ3lNdWx0aXBsaWVyVXNlZDogZmFsc2UsXG4gICAgICAgICAgc2l0ZU11bHRpcGxpZXJVc2VkOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgIH0pIGFzIHsgbWV0aG9kOiAnYWRkZXJzJzsgY2FwYWNpdHlEZWxpdmVyeVByZW1pdW06IG51bWJlcjsgZGVsYXlQZW5hbHR5OiBudW1iZXI7IGFwcGxpZWRNdWx0aXBsaWVyczogeyBjb25zdHJhaW50TXVsdGlwbGllclVzZWQ6IGJvb2xlYW47IGVuZXJneU11bHRpcGxpZXJVc2VkOiBib29sZWFuOyBzaXRlTXVsdGlwbGllclVzZWQ6IGJvb2xlYW47IH07IGRlYnVnPzogYW55IH0sXG4gICAgICBzdXBwbHlNZXRyaWNzOiAoZ3JvdW5kUmVzdWx0IGFzIGFueSkuc3VwcGx5TWV0cmljcyxcbiAgICAgIGNvbnN0cmFpbnRDb21wb25lbnRzOiAoZ3JvdW5kUmVzdWx0IGFzIGFueSkuY29uc3RyYWludENvbXBvbmVudHMsXG4gICAgICB0b3RhbENvc3RQZXJQZmxvcFllYXI6ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ3JvdW5kVG90YWxDb3N0O1xuICAgICAgICBpZiAoIWlzRmluaXRlKHZhbHVlKSB8fCB2YWx1ZSA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYGdyb3VuZC50b3RhbENvc3RQZXJQZmxvcFllYXIgaXMgaW52YWxpZDogJHt2YWx1ZX0uIGAgK1xuICAgICAgICAgICAgYENvbXBvbmVudHM6IGVuZXJneT0ke2dyb3VuZFJlc3VsdC5lbmVyZ3lDb3N0fSwgc2l0ZT0ke2dyb3VuZFJlc3VsdC5zaXRlQ29zdH0sIGhhcmR3YXJlPSR7Z3JvdW5kUmVzdWx0LmhhcmR3YXJlQ29zdH0sIGAgK1xuICAgICAgICAgICAgYGdyb3VuZEVmZmVjdGl2ZUdmbG9wc1Blclc9JHtncm91bmRFZmZlY3RpdmVHZmxvcHNQZXJXfSwgYWN0dWFsR3JvdW5kSW5wdXQ9JHthY3R1YWxHcm91bmRJbnB1dH1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KSgpLFxuICAgICAgZ3B1SG91clByaWNpbmc6IHtcbiAgICAgICAgYmFzaWM6IGdyb3VuZEdwdUhvdXIoU0xBX1RJRVJTLmJhc2ljKSxcbiAgICAgICAgc3RhbmRhcmQ6IGdyb3VuZEdwdUhvdXIoU0xBX1RJRVJTLnN0YW5kYXJkKSxcbiAgICAgICAgcHJlbWl1bTogZ3JvdW5kR3B1SG91cihTTEFfVElFUlMucHJlbWl1bSksXG4gICAgICB9LFxuICAgICAgdG9rZW5QcmljaW5nOiBncm91bmRUb2tlbnMsXG4gICAgICBzbXJFbmFibGVkOiBncm91bmRSZXN1bHQuc21yRW5hYmxlZCxcbiAgICAgIHNtclJhbXBGYWN0b3I6IGdyb3VuZFJlc3VsdC5zbXJSYW1wRmFjdG9yLFxuICAgICAgZWZmZWN0aXZlRWxlY3RyaWNpdHlDb3N0OiBncm91bmRSZXN1bHQuZWZmZWN0aXZlRWxlY3RyaWNpdHlDb3N0LFxuICAgICAgY29uc3RyYWludFJlbGllZjogZ3JvdW5kUmVzdWx0LmNvbnN0cmFpbnRSZWxpZWZcbiAgICB9LFxuICAgIG9yYml0OiB7XG4gICAgICBsY29lUGVyTXdoOiAoaHlicmlkUmVzdWx0LnBvd2VyU3lzdGVtLnRvdGFsQ29zdFVzZCkgLyAoc2F0ZWxsaXRlUG93ZXJLVyAqIFBIWVNJQ1NfQ09OU1RBTlRTLkhPVVJTX1BFUl9ZRUFSICogbGlmZXRpbWVZZWFycyAqIGh5YnJpZFJlc3VsdC5jYXBhY2l0eUZhY3RvciAvIDEwMDApLFxuICAgICAgcHVlOiBwdWVPcmJpdGFsLFxuICAgICAgY2FwYWNpdHlGYWN0b3I6IGh5YnJpZFJlc3VsdC5jYXBhY2l0eUZhY3RvcixcbiAgICAgIGNhcGFjaXR5RmFjdG9yUHJvdmVuYW5jZTogaHlicmlkUmVzdWx0LmNvbXB1dGVQYXlsb2FkPy5jYXBhY2l0eUZhY3RvclByb3ZlbmFuY2UsIC8vIERlYnVnOiBDRiBicmVha2Rvd25cbiAgICAgIGdmbG9wc1BlcldhdHQ6IG9yYml0RWZmZWN0aXZlR2Zsb3BzUGVyVywgLy8gRGVsaXZlcmVkIEdGTE9QUy9XIChzeXN0ZW1FZmZlY3RpdmUgw5cgdGhlcm1hbENhcCDDlyByYWRpYXRpb25EZXJhdGUgw5cgYXZhaWxhYmlsaXR5KVxuICAgICAgY29tcHV0ZURlZmluaXRpb246IHtcbiAgICAgICAgY2hpcE5hbWU6ICdIMTAwLWVxdWl2YWxlbnQgKHJhZC10b2xlcmFudCknLFxuICAgICAgICBwcmVjaXNpb246ICdGUDE2JyxcbiAgICAgICAgcGVha0dmbG9wc1BlcldhdHQ6IHZhbGlkYXRlR2Zsb3BzUGVyV2F0dChcbiAgICAgICAgICBvcmJpdFBlYWtHZmxvcHNQZXJXYXR0LFxuICAgICAgICAgICdvcmJpdC5jb21wdXRlRGVmaW5pdGlvbi5wZWFrR2Zsb3BzUGVyV2F0dCdcbiAgICAgICAgKSxcbiAgICAgICAgdXRpbGl6YXRpb25GYWN0b3I6IG9yYml0YWxFZmZpY2llbmN5UmVzdWx0LmRlYnVnLnV0aWxpemF0aW9uRmFjdG9yLFxuICAgICAgICBlZmZlY3RpdmVHZmxvcHNQZXJXYXR0OiBvcmJpdFN5c3RlbUVmZmVjdGl2ZUdmbG9wc1BlcldhdHQsIC8vIFN5c3RlbS1lZmZlY3RpdmUgPSBwZWFrICogdXRpbGl6YXRpb24gLyBzeXN0ZW1PdmVyaGVhZEZhY3RvciAoU1lTVEVNLUxFVkVMIEVGRkVDVElWRSlcbiAgICAgICAgLy8gZGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCBpcyBzdG9yZWQgaW4gb3JiaXQuY29tcHV0ZUVmZmljaWVuY3kuZ2Zsb3BzUGVyV2F0dCwgbm90IGhlcmVcbiAgICAgICAgbm90ZXM6ICdDb21tZXJjaWFsIHJhZC10b2xlcmFudCB2YXJpYW50LiBwZWFrR2Zsb3BzUGVyV2F0dCA9IGNoaXAgcGVhay4gZWZmZWN0aXZlR2Zsb3BzUGVyV2F0dCA9IHBlYWsgKiB1dGlsaXphdGlvbiAvIHN5c3RlbU92ZXJoZWFkRmFjdG9yIChzeXN0ZW0tbGV2ZWwgZWZmZWN0aXZlKS4gZGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCA9IHN5c3RlbUVmZmVjdGl2ZSDDlyB0aGVybWFsQ2FwRmFjdG9yIMOXIHJhZGlhdGlvbkRlcmF0ZSDDlyBhdmFpbGFiaWxpdHknLFxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVFZmZpY2llbmN5UHJvdmVuYW5jZToge1xuICAgICAgICBwZWFrR2Zsb3BzUGVyV2F0dDogb3JiaXRhbEVmZmljaWVuY3lSZXN1bHQuZGVidWcuY2hpcFBlYWtHZmxvcHNQZXJXLFxuICAgICAgICB1dGlsaXphdGlvbkZhY3Rvcjogb3JiaXRhbEVmZmljaWVuY3lSZXN1bHQuZGVidWcudXRpbGl6YXRpb25GYWN0b3IsXG4gICAgICAgIHN5c3RlbU92ZXJoZWFkRmFjdG9yOiBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5kZWJ1Zy5zeXN0ZW1PdmVyaGVhZEZhY3RvcixcbiAgICAgICAgZWZmZWN0aXZlR2Zsb3BzUGVyV2F0dDogb3JiaXRhbEVmZmljaWVuY3lSZXN1bHQuZGVidWcuZWZmZWN0aXZlR2Zsb3BzUGVyVyxcbiAgICAgIH0sIC8vIERlYnVnOiBHRkxPUFMvVyBicmVha2Rvd25cbiAgICAgIGxhdW5jaENvc3RQZXJLZzogbGF1bmNoQ29zdFBlcktnLFxuICAgICAgc3BlY2lmaWNQb3dlcldQZXJLZzogaHlicmlkUmVzdWx0LnNwZWNpZmljUG93ZXJXUGVyS2csIC8vIERlcHJlY2F0ZWQ6IHVzZSBzcGVjaWZpY1Bvd2VyX3N1YnN5c3RlbV9XUGVyS2dcbiAgICAgIHNwZWNpZmljUG93ZXJfc3Vic3lzdGVtX1dQZXJLZzogaHlicmlkUmVzdWx0LnNwZWNpZmljUG93ZXJXUGVyS2csIC8vIFN1YnN5c3RlbS1sZXZlbCAoc29sYXIgYXJyYXkgb25seSlcbiAgICAgIHNwZWNpZmljUG93ZXJfZWZmZWN0aXZlX1dQZXJLZzogaHlicmlkUmVzdWx0LnNwZWNpZmljUG93ZXJNdWx0aXBsaWVycz8uZWZmZWN0aXZlID8/IHNjYWxpbmdSZXN1bHQuZWZmZWN0aXZlU3BlY2lmaWNQb3dlciwgLy8gRWZmZWN0aXZlIHNwYWNlY3JhZnQtbGV2ZWwgKGZyb20gbXVsdGlwbGllcnMgY2FsY3VsYXRpb24pXG4gICAgICAvLyBVc2Ugc3BlY2lmaWNQb3dlck11bHRpcGxpZXJzIGZyb20gaHlicmlkUmVzdWx0IChjYWxjdWxhdGVkIGluIG9yYml0YWxQaHlzaWNzLnRzIHdpdGggY29ycmVjdCBtYXNzIGZyYWN0aW9uIGFjY291bnRpbmcpXG4gICAgICBzcGVjaWZpY1Bvd2VyTXVsdGlwbGllcnM6IGh5YnJpZFJlc3VsdC5zcGVjaWZpY1Bvd2VyTXVsdGlwbGllcnMsXG4gICAgICBlbmVyZ3lDb3N0UGVyUGZsb3BZZWFyOiBvcmJpdGFsQnJlYWtkb3duLnBvd2VyLFxuICAgICAgaGFyZHdhcmVDb3N0UGVyUGZsb3BZZWFyOiBvcmJpdGFsQnJlYWtkb3duLmNvbXB1dGUsXG4gICAgICBsYXVuY2hDb3N0UGVyUGZsb3BZZWFyOiBvcmJpdGFsQnJlYWtkb3duLmxhdW5jaCxcbiAgICAgIHJhZGlhdGlvbk11bHRpcGxpZXI6IDEuMCxcbiAgICAgIHRoZXJtYWxDYXBGYWN0b3I6IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnRoZXJtYWxDYXBGYWN0b3IsXG4gICAgICBjb25nZXN0aW9uQ29zdFBlclBmbG9wWWVhcjogb3JiaXRhbEJyZWFrZG93bi5jb25nZXN0aW9uLFxuICAgICAgdG90YWxDb3N0UGVyUGZsb3BZZWFyOiByZWFsaXN0aWNDb3N0UGVyUGZsb3AsIFxuICAgICAgdGhlcm1hbENhcHBlZDogaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0udGhlcm1hbENhcHBlZCxcbiAgICAgIGNvbXB1dGVQb3dlckt3OiB0YXJnZXRDb21wdXRlS3csIC8vIFRvdGFsIGNvbnN0ZWxsYXRpb24gY29tcHV0ZSBwb3dlclxuICAgICAgbWF4UmVqZWN0YWJsZUt3OiBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS5tYXhSZWplY3RhYmxlS3cgfHwgaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0ud2FzdGVIZWF0S3cgKiAxLjI1LFxuICAgICAgY29sbGlzaW9uUmlzazogY29uZ2VzdGlvbi5jb2xsaXNpb25SaXNrLFxuICAgICAgYm9keU1vdW50ZWRBcmVhTTI6IDAsXG4gICAgICBkZXBsb3lhYmxlQXJlYU0yOiBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS5waHlzaWNhbEFyZWFNMixcbiAgICAgIHRvdGFsUmFkaWF0b3JBcmVhTTI6IGh5YnJpZFJlc3VsdC50aGVybWFsU3lzdGVtLnBoeXNpY2FsQXJlYU0yLFxuICAgICAgcmFkaWF0b3JDb3N0UGVyUGZsb3BZZWFyOiAoaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0udG90YWxDb3N0VXNkICogY29uc3RlbGxhdGlvbkNvc3RNdWx0aXBsaWVyKSAvIHRvdGFsRWZmZWN0aXZlUGZsb3BzIC8gbGlmZXRpbWVZZWFycyxcbiAgICAgIHJhZGlhdG9yTWFzc0tnOiBoeWJyaWRSZXN1bHQudGhlcm1hbFN5c3RlbS50b3RhbE1hc3NLZyxcbiAgICAgIG9wdGltaXN0aWNDb3N0UGVyUGZsb3A6IG9yYml0YWxCcmVha2Rvd24ucG93ZXIgKyBvcmJpdGFsQnJlYWtkb3duLmNvbXB1dGUgKyBvcmJpdGFsQnJlYWtkb3duLmJ1cyxcbiAgICAgIHJhZGlhdGlvblNoaWVsZGluZ0Nvc3Q6IG9yYml0YWxCcmVha2Rvd24ucmFkaWF0aW9uLFxuICAgICAgdGhlcm1hbFN5c3RlbUNvc3Q6IG9yYml0YWxCcmVha2Rvd24udGhlcm1hbCxcbiAgICAgIHJlcGxhY2VtZW50UmF0ZUNvc3Q6IG9yYml0YWxCcmVha2Rvd24ub3BzLFxuICAgICAgZWNjT3ZlcmhlYWRDb3N0OiAwLFxuICAgICAgcmVkdW5kYW5jeUNvc3Q6IDAsXG4gICAgICByZWFsaXN0aWNDb3N0UGVyUGZsb3AsXG4gICAgICBoeWJyaWRCcmVha2Rvd246IG9yYml0YWxCcmVha2Rvd24sXG4gICAgICBncHVIb3VyUHJpY2luZzoge1xuICAgICAgICBiYXNpYzogb3JiaXRhbEdwdUhvdXIoU0xBX1RJRVJTLmJhc2ljKSxcbiAgICAgICAgc3RhbmRhcmQ6IG9yYml0YWxHcHVIb3VyKFNMQV9USUVSUy5zdGFuZGFyZCksXG4gICAgICAgIHByZW1pdW06IG9yYml0YWxHcHVIb3VyKFNMQV9USUVSUy5wcmVtaXVtKSxcbiAgICAgIH0sXG4gICAgICB0b2tlblByaWNpbmc6IG9yYml0YWxUb2tlbnMsXG4gICAgICByYWRpYXRpb25EZWdyYWRhdGlvbjoge1xuICAgICAgICBhbm51YWxGYWlsdXJlUmF0ZTogdXNlUmFkSGFyZENoaXBzID8gMC4wOSA6IDAuMTUsXG4gICAgICAgIGVmZmVjdGl2ZUNvbXB1dGVQZXJjZW50OiBoeWJyaWRSZXN1bHQuZGVncmFkYXRpb25GYWN0b3IsXG4gICAgICAgIGVjY092ZXJoZWFkUGN0OiAwLjA1LFxuICAgICAgICBhcHBsaWVkOiB0cnVlXG4gICAgICB9LFxuICAgICAgcG93ZXJTeXN0ZW1UeXBlOiBoeWJyaWRSZXN1bHQucG93ZXJTeXN0ZW1UeXBlLFxuICAgICAgc2NhbGluZ1BlbmFsdHk6IHNjYWxpbmdSZXN1bHQuc2NhbGluZ1BlbmFsdHksXG4gICAgICAvLyBSRU1PVkVEOiBlZmZlY3RpdmVTcGVjaWZpY1Bvd2VyIChkdXBsaWNhdGUgb2Ygc3BlY2lmaWNQb3dlcl9lZmZlY3RpdmVfV1BlcktnKVxuICAgICAgLy8gVXNlIHNwZWNpZmljUG93ZXJfZWZmZWN0aXZlX1dQZXJLZyBpbnN0ZWFkIChjYW5vbmljYWwgZmllbGQpXG4gICAgICBmdXNpb25EZXRhaWxzOiBoeWJyaWRSZXN1bHQuZnVzaW9uRGV0YWlscyxcbiAgICAgIFxuICAgICAgLy8gQ29uc3RlbGxhdGlvbiBzaXppbmdcbiAgICAgIGNvbnN0ZWxsYXRpb246IHtcbiAgICAgICAgZGVzaWduOiB7XG4gICAgICAgICAgbnVtU2F0ZWxsaXRlczogY29uc3RlbGxhdGlvbi5udW1TYXRlbGxpdGVzLFxuICAgICAgICAgIGNvbXB1dGVQZXJTYXRLdzogY29uc3RlbGxhdGlvbi5jb21wdXRlUGVyU2F0S3csXG4gICAgICAgICAgbWFzc1BlclNhdEtnOiBtYXNzUGVyU2F0S2csXG4gICAgICAgICAgcmFkaWF0b3JBcmVhUGVyU2F0TTI6IGNvbnN0ZWxsYXRpb24ucmFkaWF0b3JBcmVhUGVyU2F0TTIsXG4gICAgICAgIH0sXG4gICAgICAgIGxhdW5jaDoge1xuICAgICAgICAgIHNhdHNQZXJMYXVuY2g6IGNvbnN0ZWxsYXRpb24uc2F0c1BlckxhdW5jaCxcbiAgICAgICAgICBsYXVuY2hlc1JlcXVpcmVkOiBjb25zdGVsbGF0aW9uLmxhdW5jaGVzUmVxdWlyZWQsXG4gICAgICAgICAgdG90YWxNYXNzS2c6IGVmZmVjdGl2ZVRvdGFsTWFzc0tnLFxuICAgICAgICB9LFxuICAgICAgICBzY2FsaW5nOiB7XG4gICAgICAgICAgY29uc3RlbGxhdGlvbk92ZXJoZWFkOiBjb25zdGVsbGF0aW9uLmNvbnN0ZWxsYXRpb25PdmVyaGVhZCxcbiAgICAgICAgICBzY2FsaW5nRWZmaWNpZW5jeTogY29uc3RlbGxhdGlvbi5zY2FsaW5nRWZmaWNpZW5jeSxcbiAgICAgICAgfSxcbiAgICAgICAgd2FybmluZ3M6IGNvbnN0ZWxsYXRpb24ud2FybmluZ3MsXG4gICAgICB9LFxuICAgICAgXG4gICAgICAvLyBEZWJ1ZyBibG9ja3MgZm9yIGFuYWx5c2lzIC0gZXhwbGljaXRseSB0cmFjayBhbGwgZWZmaWNpZW5jeSBsZXZlbHNcbiAgICAgIC8vIFNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGg6IGRlZmluZSBvcmJpdC5jb21wdXRlRWZmaWNpZW5jeUxldmVscyBlYWNoIHllYXJcbiAgICAgIC8vIE5vdGU6IGNvbXB1dGVFZmZpY2llbmN5TGV2ZWxzIGlzIHN0b3JlZCBpbiBtZXRhZGF0YSwgbm90IGRpcmVjdGx5IG9uIG9yYml0XG4gICAgICBlZmZlY3RpdmVDb21wdXRlTXVsdGlwbGllcnM6IHtcbiAgICAgICAgdGhlcm1hbENhcEZhY3RvcjogaHlicmlkUmVzdWx0LnRoZXJtYWxTeXN0ZW0udGhlcm1hbENhcEZhY3RvcixcbiAgICAgICAgcmFkaWF0aW9uRGVyYXRlOiBoeWJyaWRSZXN1bHQuZGVncmFkYXRpb25GYWN0b3IgfHwgMS4wLFxuICAgICAgICBhdmFpbGFiaWxpdHk6IGh5YnJpZFJlc3VsdC5jYXBhY2l0eUZhY3RvciB8fCAxLjAsXG4gICAgICAgIHV0aWxpemF0aW9uOiBvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdC5kZWJ1Zy51dGlsaXphdGlvbkZhY3RvcixcbiAgICAgIH0sXG4gICAgICBjb3N0U2hhcmVzOiAoKCkgPT4ge1xuICAgICAgICBjb25zdCB0b3RhbCA9IHJlYWxpc3RpY0Nvc3RQZXJQZmxvcDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsYXVuY2g6IChvcmJpdGFsQnJlYWtkb3duLmxhdW5jaCAvIHRvdGFsKSAqIDEwMCxcbiAgICAgICAgICBwb3dlcjogKG9yYml0YWxCcmVha2Rvd24ucG93ZXIgLyB0b3RhbCkgKiAxMDAsXG4gICAgICAgICAgY29tcHV0ZTogKG9yYml0YWxCcmVha2Rvd24uY29tcHV0ZSAvIHRvdGFsKSAqIDEwMCxcbiAgICAgICAgICB0aGVybWFsOiAob3JiaXRhbEJyZWFrZG93bi50aGVybWFsIC8gdG90YWwpICogMTAwLFxuICAgICAgICAgIGJ1czogKG9yYml0YWxCcmVha2Rvd24uYnVzIC8gdG90YWwpICogMTAwLFxuICAgICAgICAgIG9wczogKG9yYml0YWxCcmVha2Rvd24ub3BzIC8gdG90YWwpICogMTAwLFxuICAgICAgICAgIG5ldHdvcmtpbmc6IChvcmJpdGFsQnJlYWtkb3duLm5ldHdvcmtpbmcgLyB0b3RhbCkgKiAxMDAsXG4gICAgICAgICAgZ3JvdW5kU2VnbWVudDogKG9yYml0YWxCcmVha2Rvd24ucmVndWxhdG9yeSAvIHRvdGFsKSAqIDEwMCwgLy8gUmVndWxhdG9yeSBpbmNsdWRlcyBncm91bmQgc2VnbWVudFxuICAgICAgICB9O1xuICAgICAgfSkoKSxcbiAgICAgIGxvY2FsU2Vuc2l0aXZpdHk6ICgoKSA9PiB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBsb2NhbCBzZW5zaXRpdml0eTogZENvc3QvZFBhcmFtZXRlciAoYXBwcm94aW1hdGUgZGVyaXZhdGl2ZXMpXG4gICAgICAgIFxuICAgICAgICAvLyBkQ29zdF9kTGF1bmNoOiBsYXVuY2ggY29zdCBzY2FsZXMgbGluZWFybHkgd2l0aCBsYXVuY2hDb3N0UGVyS2dcbiAgICAgICAgY29uc3QgZENvc3RfZExhdW5jaCA9IG9yYml0YWxCcmVha2Rvd24ubGF1bmNoIC8gbGF1bmNoQ29zdFBlcktnO1xuICAgICAgICBcbiAgICAgICAgLy8gZENvc3RfZFNwZWNpZmljUG93ZXI6IHBvd2VyIGNvc3Qgc2NhbGVzIGludmVyc2VseSB3aXRoIHNwZWNpZmljIHBvd2VyIChuZWdhdGl2ZSlcbiAgICAgICAgY29uc3QgZENvc3RfZFNwZWNpZmljUG93ZXIgPSAtKG9yYml0YWxCcmVha2Rvd24ucG93ZXIgLyB0cmFqU3BlY2lmaWNQb3dlcik7XG4gICAgICAgIFxuICAgICAgICAvLyBkQ29zdF9kR2Zsb3BzUGVyVzogcG93ZXIgY29zdCBzY2FsZXMgaW52ZXJzZWx5IHdpdGggR0ZMT1BTL1cgKG5lZ2F0aXZlKVxuICAgICAgICBjb25zdCBkQ29zdF9kR2Zsb3BzUGVyVyA9IC0ob3JiaXRhbEJyZWFrZG93bi5wb3dlciAvIG9yYml0RWZmZWN0aXZlR2Zsb3BzUGVyVyk7XG4gICAgICAgIFxuICAgICAgICAvLyBkQ29zdF9kRmFpbHVyZVJhdGU6IG9wcyBjb3N0IHNjYWxlcyB3aXRoIGZhaWx1cmUgcmF0ZVxuICAgICAgICBjb25zdCBiYXNlRmFpbHVyZVJhdGUgPSB1c2VSYWRIYXJkQ2hpcHMgPyAwLjA5IDogMC4xNTtcbiAgICAgICAgY29uc3QgZENvc3RfZEZhaWx1cmVSYXRlID0gb3JiaXRhbEJyZWFrZG93bi5vcHMgLyBiYXNlRmFpbHVyZVJhdGU7XG4gICAgICAgIFxuICAgICAgICAvLyBkQ29zdF9kUHVlOiBwb3dlciBjb3N0IHNjYWxlcyBsaW5lYXJseSB3aXRoIFBVRVxuICAgICAgICBjb25zdCBkQ29zdF9kUHVlID0gb3JiaXRhbEJyZWFrZG93bi5wb3dlciAvIHB1ZU9yYml0YWw7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRDb3N0X2RMYXVuY2gsXG4gICAgICAgICAgZENvc3RfZFNwZWNpZmljUG93ZXIsXG4gICAgICAgICAgZENvc3RfZEdmbG9wc1BlclcsXG4gICAgICAgICAgZENvc3RfZEZhaWx1cmVSYXRlLFxuICAgICAgICAgIGRDb3N0X2RQdWUsXG4gICAgICAgIH07XG4gICAgICB9KSgpLFxuICAgIH0sXG4gICAgZWRnZUluZmVyZW5jZSxcbiAgICBjcm9zc292ZXI6IHJlYWxpc3RpY0Nvc3RQZXJQZmxvcCA8IGdyb3VuZENvbXBhcmF0b3JDb3N0UGVyUGZsb3BZZWFyLFxuICAgIGNyb3Nzb3ZlckRldGFpbHM6IHtcbiAgICAgIGdwdUhvdXJDcm9zc292ZXIsXG4gICAgICB0b2tlbkNyb3Nzb3Zlcjogb3JiaXRhbFRva2Vucy5sbGFtYTcwQi5jb3N0UGVyMWtUb2tlbnMgPCBncm91bmRUb2tlbnMubGxhbWE3MEIuY29zdFBlcjFrVG9rZW5zLFxuICAgICAgbWFya2V0UG9zaXRpb246IGdwdUhvdXJDcm9zc292ZXIgXG4gICAgICAgID8gYE9yYml0YWwgJHsoKDEgLSBvcmJpdGFsR3B1SG91cihTTEFfVElFUlMuc3RhbmRhcmQpLnByaWNlUGVyR3B1SG91ciAvIGdyb3VuZEdwdUhvdXIoU0xBX1RJRVJTLnN0YW5kYXJkKS5wcmljZVBlckdwdUhvdXIpICogMTAwKS50b0ZpeGVkKDEpfSUgY2hlYXBlcmBcbiAgICAgICAgOiBgR3JvdW5kICR7KCgxIC0gZ3JvdW5kR3B1SG91cihTTEFfVElFUlMuc3RhbmRhcmQpLnByaWNlUGVyR3B1SG91ciAvIG9yYml0YWxHcHVIb3VyKFNMQV9USUVSUy5zdGFuZGFyZCkucHJpY2VQZXJHcHVIb3VyKSAqIDEwMCkudG9GaXhlZCgxKX0lIGNoZWFwZXJgLFxuICAgIH0sXG4gICAgY29zdEFjY291bnRpbmdWYWxpZCxcbiAgICBjb3N0QWNjb3VudGluZ0Vycm9yUGN0LFxuICAgIG1ldGFkYXRhOiB7XG4gICAgICBncm91bmRVbml0czogW1xuICAgICAgICB7XG4gICAgICAgICAgbWV0cmljOiAnZ2Zsb3BzUGVyV2F0dCcsXG4gICAgICAgICAgdW5pdDogJ0dGTE9QUy9XJyxcbiAgICAgICAgICBsZXZlbDogJ3N5c3RlbScsXG4gICAgICAgICAgbm90ZXM6ICdHcm91bmQgc3lzdGVtLWxldmVsIGVmZmljaWVuY3kgaW5jbHVkaW5nIG1lbW9yeSwgbmV0d29yaywgcG93ZXIgZGVsaXZlcnkgb3ZlcmhlYWQnLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIG9yYml0VW5pdHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG1ldHJpYzogJ2dmbG9wc1BlcldhdHQnLFxuICAgICAgICAgIHVuaXQ6ICdHRkxPUFMvVycsXG4gICAgICAgICAgbGV2ZWw6ICdkZWxpdmVyZWQnLFxuICAgICAgICAgIG5vdGVzOiAnT3JiaXRhbCBkZWxpdmVyZWQgZWZmaWNpZW5jeTogc3lzdGVtRWZmZWN0aXZlIMOXIHRoZXJtYWxDYXBGYWN0b3Igw5cgcmFkaWF0aW9uRGVyYXRlIMOXIGF2YWlsYWJpbGl0eScsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgdW5pdHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG1ldHJpYzogJ2dmbG9wc1BlcldhdHQnLFxuICAgICAgICAgIHVuaXQ6ICdHRkxPUFMvVycsXG4gICAgICAgICAgbGV2ZWw6ICdzeXN0ZW0nLFxuICAgICAgICAgIG5vdGVzOiAnU3lzdGVtLWxldmVsIGVmZmljaWVuY3kgaW5jbHVkaW5nIG1lbW9yeSwgbmV0d29yaywgcG93ZXIgZGVsaXZlcnkgb3ZlcmhlYWQnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbWV0cmljOiAnY29zdFBlclBmbG9wWWVhcicsXG4gICAgICAgICAgdW5pdDogJ1VTRC9QRkxPUC15ZWFyJyxcbiAgICAgICAgICBsZXZlbDogJ2luZnJhc3RydWN0dXJlJyxcbiAgICAgICAgICBub3RlczogJ1RvdGFsIGNvc3QgdG8gb3BlcmF0ZSAxIFBGTE9QIG9mIHN1c3RhaW5lZCBjb21wdXRlIGZvciBvbmUgeWVhcicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRyaWM6ICdwcmljZVBlckdwdUhvdXInLFxuICAgICAgICAgIHVuaXQ6ICdVU0QvR1BVLWhvdXInLFxuICAgICAgICAgIGxldmVsOiAnbWFya2V0JyxcbiAgICAgICAgICBub3RlczogJ01hcmtldCBwcmljZSB3aXRoIFNMQSwgaW5jbHVkaW5nIG1hcmdpbiBhbmQgcmlzayBidWZmZXInLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbWV0cmljOiAnY29zdFBlcjFrVG9rZW5zJyxcbiAgICAgICAgICB1bml0OiAnVVNELzFLIHRva2VucycsXG4gICAgICAgICAgbGV2ZWw6ICdhcHBsaWNhdGlvbicsXG4gICAgICAgICAgbm90ZXM6ICdJbmZlcmVuY2UgY29zdCBmb3Igc3BlY2lmaWVkIG1vZGVsIHNpemUgKDcwQiBvciA0MDVCKScsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGVidWc6IHtcbiAgICAgICAgZ3JvdW5kTGlmZXRpbWU6IGdyb3VuZExpZmV0aW1lLFxuICAgICAgICBncHVGYWlsdXJlUmF0ZUFubnVhbDogcGFyYW1zLmdwdUZhaWx1cmVSYXRlQW5udWFsLFxuICAgICAgICB0b3RhbENvc3RFeGNsdWRlc0RlbGF5UGVuYWx0eTogdHJ1ZSwgLy8gSGVhZGxpbmUgY29zdCBleGNsdWRlcyBkZWxheSBwZW5hbHR5IChoYW5kbGVkIHZpYSBjYXBhY2l0eSBnYXRpbmcpXG4gICAgICAgIHRvdGFsQ29zdEVmZmVjdGl2ZUluY2x1ZGVzRGVsYXlQZW5hbHR5OiBncm91bmRSZXN1bHQudG90YWxDb3N0UGVyUGZsb3BZZWFyRWZmZWN0aXZlICE9PSB1bmRlZmluZWQsXG4gICAgICAgIGdyb3VuZEhhc1F1ZXVlLFxuICAgICAgICBncm91bmRDb21wYXJhdG9yQ29zdFBlclBmbG9wWWVhcixcbiAgICAgIH0sXG4gICAgICBjb21wdXRlRWZmaWNpZW5jeToge1xuICAgICAgICBnZmxvcHNQZXJXYXR0OiBvcmJpdEVmZmVjdGl2ZUdmbG9wc1BlclcsIC8vIERlbGl2ZXJlZCBlZmZpY2llbmN5IChhbGlhcylcbiAgICAgICAgZWZmaWNpZW5jeUxldmVsOiAnZGVsaXZlcmVkJywgLy8gQ2hhbmdlZCBmcm9tICdzeXN0ZW0nIHRvICdkZWxpdmVyZWQnXG4gICAgICAgIHZhbGlkYXRpb246IHtcbiAgICAgICAgICAvLyBDUklUSUNBTDogVXNlIGRlbGl2ZXJlZFZhbGlkYXRpb24gYXMgcHJpbWFyeSAtIGl0IGNvbXBhcmVzIGxpa2UtZm9yLWxpa2VcbiAgICAgICAgICAvLyBPbmx5IGZhaWwgaWYgZGVsaXZlcmVkVmFsaWRhdGlvbiBmYWlscyAocmF0aW8gbWlzbWF0Y2gpIE9SIGVmZmljaWVuY3lWYWxpZGF0aW9uIGZhaWxzIChyYW5nZSBjaGVjaylcbiAgICAgICAgICAvLyBjb25zaXN0ZW5jeUNoZWNrIGlzIGZvciBwb3dlci9jb21wdXRlIGNvbnNpc3RlbmN5LCBub3QgZWZmaWNpZW5jeSB2YWxpZGF0aW9uXG4gICAgICAgICAgdmFsaWQ6IGVmZmljaWVuY3lWYWxpZGF0aW9uLnZhbGlkICYmIGRlbGl2ZXJlZFZhbGlkYXRpb24udmFsaWQsXG4gICAgICAgICAgd2FybmluZzogZWZmaWNpZW5jeVZhbGlkYXRpb24ud2FybmluZyB8fCBkZWxpdmVyZWRWYWxpZGF0aW9uLndhcm5pbmcgfHwgdW5kZWZpbmVkLCAvLyBPbmx5IGVmZmljaWVuY3kgb3IgZGVsaXZlcmVkIG1pc21hdGNoIHdhcm5pbmdzXG4gICAgICAgICAgZXhwZWN0ZWREZWxpdmVyZWQ6IGRlbGl2ZXJlZFZhbGlkYXRpb24uZXhwZWN0ZWREZWxpdmVyZWQsXG4gICAgICAgICAgZGVsaXZlcmVkOiBkZWxpdmVyZWRWYWxpZGF0aW9uLmRlbGl2ZXJlZCxcbiAgICAgICAgICByYXRpbzogZGVsaXZlcmVkVmFsaWRhdGlvbi5yYXRpbyxcbiAgICAgICAgICBmYWN0b3JzVXNlZDogZGVsaXZlcmVkVmFsaWRhdGlvbi5mYWN0b3JzVXNlZCxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIENoYXJ0IGlucHV0cyBmb3IgcG93ZXIgYnVpbGRvdXQgY29uc3RyYWludHMgKHJlcGxhY2VzIGVuZXJneUNvc3RDb21wYXJpc29uKVxuICAgICAgY2hhcnRJbnB1dHM6IHtcbiAgICAgICAgcG93ZXJCdWlsZG91dDoge1xuICAgICAgICAgIGRlbWFuZEd3OiAoJ2J1aWxkb3V0RGVidWcnIGluIGdyb3VuZFJlc3VsdCA/IGdyb3VuZFJlc3VsdC5idWlsZG91dERlYnVnPy5kZW1hbmRHVyA6IHVuZGVmaW5lZCkgPz8gXG4gICAgICAgICAgICAgICAgICAgICgnc3VwcGx5TWV0cmljcycgaW4gZ3JvdW5kUmVzdWx0ID8gZ3JvdW5kUmVzdWx0LnN1cHBseU1ldHJpY3M/LmRlbWFuZEd3IDogdW5kZWZpbmVkKSA/PyAwLFxuICAgICAgICAgIHN1cHBseUd3OiAoJ3N1cHBseU1ldHJpY3MnIGluIGdyb3VuZFJlc3VsdCA/IGdyb3VuZFJlc3VsdC5zdXBwbHlNZXRyaWNzPy5jYXBhY2l0eUd3IDogdW5kZWZpbmVkKSA/PyAwLFxuICAgICAgICAgIG1heEJ1aWxkUmF0ZUd3WWVhcjogKCdzdXBwbHlNZXRyaWNzJyBpbiBncm91bmRSZXN1bHQgPyBncm91bmRSZXN1bHQuc3VwcGx5TWV0cmljcz8ubWF4QnVpbGRSYXRlR3dZZWFyIDogdW5kZWZpbmVkKSA/PyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgnYnVpbGRvdXREZWJ1ZycgaW4gZ3JvdW5kUmVzdWx0ID8gZ3JvdW5kUmVzdWx0LmJ1aWxkb3V0RGVidWc/LmJ1aWxkUmF0ZUdXeXIgOiB1bmRlZmluZWQpID8/IDAsXG4gICAgICAgICAgcGlwZWxpbmVHdzogKCdzdXBwbHlNZXRyaWNzJyBpbiBncm91bmRSZXN1bHQgPyBncm91bmRSZXN1bHQuc3VwcGx5TWV0cmljcz8ucGlwZWxpbmVHdyA6IHVuZGVmaW5lZCkgPz8gMCxcbiAgICAgICAgICBiYWNrbG9nR3c6ICgnYmFja2xvZ0d3JyBpbiBncm91bmRSZXN1bHQgPyBncm91bmRSZXN1bHQuYmFja2xvZ0d3IDogdW5kZWZpbmVkKSA/PyBcbiAgICAgICAgICAgICAgICAgICAgICgnYnVpbGRvdXREZWJ1ZycgaW4gZ3JvdW5kUmVzdWx0ID8gZ3JvdW5kUmVzdWx0LmJ1aWxkb3V0RGVidWc/LmJhY2tsb2dHVyA6IHVuZGVmaW5lZCkgPz8gMCxcbiAgICAgICAgICBhdmdXYWl0WWVhcnM6ICgnYXZnV2FpdFllYXJzJyBpbiBncm91bmRSZXN1bHQgPyBncm91bmRSZXN1bHQuYXZnV2FpdFllYXJzIDogdW5kZWZpbmVkKSA/PyBcbiAgICAgICAgICAgICAgICAgICAgICAgICgnYnVpbGRvdXREZWJ1ZycgaW4gZ3JvdW5kUmVzdWx0ID8gZ3JvdW5kUmVzdWx0LmJ1aWxkb3V0RGVidWc/LnRpbWVUb1Bvd2VyWWVhcnMgOiB1bmRlZmluZWQpID8/IDAsXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuIl0sIm5hbWVzIjpbImNhbGN1bGF0ZUNvbmdlc3Rpb24iLCJjb21wdXRlRWRnZUluZmVyZW5jZUNvc3RzIiwiY29tcHV0ZVNhdGVsbGl0ZUh5YnJpZENvc3QiLCJERUZBVUxUX0NPTkZJRyIsIlBIWVNJQ1NfQ09OU1RBTlRTIiwiREVGQVVMVF9GVVNJT05fUEFSQU1TIiwiREVGQVVMVF9QT1dFUl9TQ0FMSU5HIiwiY2FsY3VsYXRlU2NhbGVkTWFzcyIsImNhbGN1bGF0ZVJlZ2lvbmFsR3JvdW5kQ29zdCIsImdldEdsb2JhbERlbWFuZFBmbG9wcyIsImdlbmVyYXRlR3JvdW5kU3VwcGx5VHJhamVjdG9yeSIsImNhbGN1bGF0ZUdyb3VuZENvbnN0cmFpbnRQZW5hbHRpZXMiLCJjYWxjdWxhdGVTY2FyY2l0eVJlbnQiLCJjYWxjdWxhdGVCdWlsZG91dENvbnN0cmFpbnRzIiwic3RlcE1vYmlsaXphdGlvblN0YXRlIiwiREVGQVVMVF9NT0JJTElaQVRJT05fUEFSQU1TIiwiQ29tcHV0ZUVmZmljaWVuY3kiLCJnZXREZWZhdWx0Q29tcHV0ZUVmZmljaWVuY3kiLCJhc3NlcnRDb3N0QWNjb3VudGluZyIsInZhbGlkYXRlR2Zsb3BzUGVyV2F0dCIsImRlc2lnbkNvbnN0ZWxsYXRpb24iLCJTQVRFTExJVEVfQ09OU1RSQUlOVFMiLCJDT05TVEFOVFMiLCJIT1VSU19QRVJfWUVBUiIsIkdST1VORF9IQVJEV0FSRV9DT1NUX1BGTE9QXzIwMjUiLCJHUk9VTkRfSEFSRFdBUkVfTElGRVRJTUUiLCJNSU5fREVMSVZFUkVEX0dGTE9QU19QRVJfVyIsIkRFRkFVTFRfU01SX1BBUkFNUyIsImVuYWJsZWQiLCJzbXJEZXBsb3ltZW50U3RhcnRZZWFyIiwic21yUmFtcFVwWWVhcnMiLCJlbGVjdHJpY2l0eUNvc3RXaXRoU01SIiwiZ3JpZENvbnN0cmFpbnRSZWxpZWYiLCJjb29saW5nQ29uc3RyYWludFJlbGllZiIsIndhdGVyQ29uc3RyYWludFJlbGllZiIsImxhbmRDb25zdHJhaW50UmVsaWVmIiwic21yQ2FwZXhQcmVtaXVtIiwiR1JPVU5EX1NDRU5BUklPUyIsInVuY29uc3RyYWluZWQiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJjb25zdHJhaW50Q2FwIiwiZ3JpZEdyb3d0aFJhdGUiLCJjb29saW5nR3Jvd3RoUmF0ZSIsIndhdGVyR3Jvd3RoUmF0ZSIsImxhbmRHcm93dGhSYXRlIiwibW9kZXJhdGUiLCJjb25zdHJhaW5lZCIsInNldmVyZSIsImNhbGN1bGF0ZUdyb3VuZENvbnN0cmFpbnQiLCJ5ZWFyIiwic2NlbmFyaW9LZXkiLCJtdWx0aXBsaWVyIiwiYnJlYWtkb3duIiwiZ3JpZCIsImNvb2xpbmciLCJ3YXRlciIsImxhbmQiLCJzY2VuYXJpbyIsInllYXJzRnJvbUJhc2UiLCJNYXRoIiwibWF4IiwicG93IiwibWluIiwidmFsaWRhdGVDb21wdXRlRWZmaWNpZW5jeSIsImdmbG9wc1BlcldhdHQiLCJsZXZlbCIsInJhbmdlcyIsImNoaXAiLCJzeXN0ZW0iLCJkYXRhY2VudGVyIiwicmFuZ2UiLCJ2YWxpZCIsIndhcm5pbmciLCJ0b0ZpeGVkIiwiU0xBX1RJRVJTIiwiYXZhaWxhYmlsaXR5VGFyZ2V0IiwibWF4TGF0ZW5jeVRvR3JvdW5kTXMiLCJtaW5CYW5kd2lkdGhHYnBzIiwibWF4UmVjb3ZlcnlUaW1lTWludXRlcyIsImNyZWRpdFBlclZpb2xhdGlvblBjdCIsImFwcGx5U3RhdGljRnJlZXplIiwicGFyYW1zIiwiaXNTdGF0aWNNb2RlIiwibGF1bmNoQ29zdEtnIiwic3BlY2lmaWNQb3dlcldLZyIsImdyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNSIsIm9yYml0RWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1IiwiZ3JvdW5kQ29uc3RyYWludHNFbmFibGVkIiwicG93ZXJHcmlkTXVsdGlwbGllciIsImNvb2xpbmdNdWx0aXBsaWVyIiwid2F0ZXJTY2FyY2l0eUVuYWJsZWQiLCJsYW5kU2NhcmNpdHlFbmFibGVkIiwiZGVwbG95YWJsZUFyZWEyMDI1TTIiLCJkZXBsb3lhYmxlQXJlYTIwNDBNMiIsInByZXZMYXVuY2hDb3N0Q2FjaGUiLCJNYXAiLCJnZXRMYXVuY2hDb3N0UGVyS2ciLCJiYXNlMjAyNSIsInNldCIsIkNPTU1FUkNJQUxfTUFSS1VQIiwiSU5TVVJBTkNFX1BDVCIsIklOVEVHUkFUSU9OX0NPU1RfUEVSX0xBVU5DSCIsIkFTU1VNRURfUEFZTE9BRF9LRyIsImludGVybmFsQmFzZTIwMjUiLCJub3JtYWxpemVkQmFzZSIsImludGVybmFsV2F5cG9pbnRzIiwiaW50ZXJuYWxDb3N0UGVyS2ciLCJpIiwibGVuZ3RoIiwieTEiLCJjMSIsInkyIiwiYzIiLCJ0Iiwid2l0aE1hcmt1cCIsIndpdGhJbnN1cmFuY2UiLCJpbnRlZ3JhdGlvblBlcktnIiwiY29tbWVyY2lhbENvc3RQZXJLZyIsInJlc3VsdCIsInByZXZZZWFyIiwicHJldkNvc3QiLCJnZXQiLCJ1bmRlZmluZWQiLCJjYWxjdWxhdGVUb2tlblByaWNpbmciLCJjb3N0UGVyUGZsb3BZZWFyIiwibW9kZWxDb25maWciLCJiYXNlRkxPUFMiLCJwcmVjaXNpb25NdWx0aXBsaWVyIiwicHJlY2lzaW9uIiwiZmxvcHNQZXJUb2tlbiIsInNlY29uZHNQZXJZZWFyIiwiZmxvcHNQZXJQZmxvcFllYXIiLCJ0b2tlbnNQZXJQZmxvcFllYXIiLCJjb3N0UGVyVG9rZW4iLCJtb2RlbFBhcmFtcyIsImNvc3RQZXIxa1Rva2VucyIsImNvc3RQZXIxbVRva2VucyIsImNhbGN1bGF0ZUdwdUhvdXJQcmljaW5nIiwiY29zdEJyZWFrZG93biIsImhvdXJzUGVyWWVhciIsImNvc3RQZXJHcHVZZWFyIiwicGZsb3BzUGVyR3B1IiwiZWZmZWN0aXZlSG91cnMiLCJ1dGlsaXphdGlvblRhcmdldCIsImJhc2VQZXJIb3VyIiwicHJvY2VzcyIsImNvbnNvbGUiLCJlcnJvciIsImNsYW1wZWRDb3N0UGVyUGZsb3BZZWFyIiwiY2xhbXBlZENvc3RQZXJHcHVZZWFyIiwiY2xhbXBlZEJhc2VQZXJIb3VyIiwiRXJyb3IiLCJwb3dlclBlckhvdXIiLCJjb29saW5nUGVySG91ciIsImludGVyY29ubmVjdFBlckhvdXIiLCJvcHNQZXJIb3VyIiwiY29tcHV0ZVBlckhvdXIiLCJ0b3RhbEJhc2UiLCJwb3dlciIsInRoZXJtYWwiLCJpbnRlcmNvbm5lY3QiLCJvcHMiLCJjb21wdXRlIiwic2NhbGUiLCJuaW5lcyIsImxvZzEwIiwic2xhIiwic3BhcmVzUmF0aW8iLCJzcGFyZXNQZXJIb3VyIiwidmlvbGF0aW9uUHJvYiIsImV4cGVjdGVkQ3JlZGl0UGVySG91ciIsInNsYVJpc2tCdWZmZXIiLCJ0b3RhbENvc3RQZXJIb3VyIiwibWFyZ2luIiwib3BlcmF0b3JNYXJnaW5QY3QiLCJwcmljZVBlckdwdUhvdXIiLCJNQVhfUkVBU09OQUJMRV9HUFVfSE9VUl9QUklDRSIsIk1JTl9SRUFTT05BQkxFX0dQVV9IT1VSX1BSSUNFIiwiZ3B1VHlwZSIsImxvY2F0aW9uIiwiaGFyZHdhcmVBbW9ydGl6YXRpb24iLCJvcGVyYXRpb25zIiwic3BhcmVzIiwiZWZmZWN0aXZlVXRpbGl6YXRpb24iLCJNT0RFTF9VTklUUyIsInBmbG9wRGVmaW5pdGlvbiIsInN1c3RhaW5lZFZzUGVhayIsImdmbG9wc1BlcldhdHRMZXZlbCIsImluY2x1ZGVzTmV0d29ya2luZ092ZXJoZWFkIiwiYXNzZXJ0Q29tcHV0ZVBvd2VyQ29uc2lzdGVuY3kiLCJjb21wdXRlUG93ZXJLdyIsImVmZmVjdGl2ZVBmbG9wcyIsInVuaXRzIiwiZXhwZWN0ZWRLdyIsImRpc2NyZXBhbmN5IiwicmF0aW8iLCJCQVNFX1NJVEVfMjAyNSIsImNhbGN1bGF0ZUdyb3VuZFRvdGFsIiwiZW5lcmd5Q29zdEJhc2UiLCJoYXJkd2FyZUNvc3RCYXNlIiwiZWZmZWN0aXZlU2NlbmFyaW8iLCJsYXRlbmN5UGVuYWx0eSIsInNtclBhcmFtcyIsImZpcnN0Q2FwWWVhciIsImFjdHVhbEVuZXJneUNvc3RQZXJQZmxvcFllYXIiLCJhY3R1YWxFbGVjdHJpY2l0eVByaWNlUGVyTXdoIiwic2l0ZUNvc3RCYXNlIiwic21yRW5hYmxlZCIsInNtclJhbXBGYWN0b3IiLCJjb25zdHJhaW50UmVsaWVmIiwieWVhcnNBY3RpdmUiLCJlbmVyZ3lDb3N0IiwiZWZmZWN0aXZlRWxlY3RyaWNpdHlQcmljZSIsInRvdGFsIiwic2l0ZUNvc3QiLCJoYXJkd2FyZUNvc3QiLCJjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSIsInRpbWVUb0VuZXJnaXplUGVuYWx0eSIsInRvdGFsQ29zdFBlclBmbG9wWWVhciIsImNvbnN0cmFpbnRNdWx0aXBsaWVyIiwiZW5lcmd5TXVsdGlwbGllciIsInNpdGVNdWx0aXBsaWVyIiwiY2FwYWNpdHlEZWxpdmVyeU11bHRpcGxpZXIiLCJlZmZlY3RpdmVFbGVjdHJpY2l0eUNvc3QiLCJzaXRlQ2FwZXhBbW9ydFBlclBmbG9wWWVhciIsImNhcGFjaXR5RGVsaXZlcnlQcmVtaXVtUGVyUGZsb3BZZWFyIiwidGltZVRvRW5lcmdpemVQZW5hbHR5UGVyUGZsb3BZZWFyIiwic2l0ZUNvc3RQZXJQZmxvcFllYXJfYmFzZSIsInNpdGVDb3N0UGVyUGZsb3BZZWFyX2VmZmVjdGl2ZSIsInNpdGVDb3N0Q2hlY2siLCJhYnMiLCJoYXJkd2FyZSIsInRvdGFsRWZmZWN0aXZlIiwidG90YWxDb3N0UGVyUGZsb3BZZWFyRWZmZWN0aXZlIiwiY29uc3RyYWludHMiLCJtZXRob2QiLCJkZWxheVBlbmFsdHkiLCJhcHBsaWVkTXVsdGlwbGllcnMiLCJjb25zdHJhaW50TXVsdGlwbGllclVzZWQiLCJlbmVyZ3lNdWx0aXBsaWVyVXNlZCIsInNpdGVNdWx0aXBsaWVyVXNlZCIsImRlYnVnIiwiZG91YmxlQ291bnRDaGVjayIsIm1vZGUiLCJtdWx0aXBsaWVyQXBwbGllZCIsImFkZGVyc0FwcGxpZWQiLCJpbnZhcmlhbnRPayIsIm5vdGVzIiwiY29tcHV0ZVBoeXNpY3NDb3N0IiwicmF3UGFyYW1zIiwiaHlicmlkUmVzdWx0IiwiZ3JvdW5kUmVzdWx0IiwiYmFzZUxhdW5jaENvc3QiLCJ0cmFqU3BlY2lmaWNQb3dlciIsInJhd0dyb3VuZEVmZmVjdGl2ZUdmbG9wc1BlcldfMjAyNSIsInJhd09yYml0RWZmZWN0aXZlR2Zsb3BzUGVyV18yMDI1IiwicHVlR3JvdW5kIiwicHVlT3JiaXRhbCIsImNhcGFjaXR5RmFjdG9yR3JvdW5kIiwidGFyZ2V0R1ciLCJzYXRlbGxpdGVQb3dlcktXIiwic3BhY2VUcmFmZmljRW5hYmxlZCIsIm9yYml0YWxBbHRpdHVkZSIsInVzZVJhZEhhcmRDaGlwcyIsInN1bkZyYWN0aW9uIiwiZ3JvdW5kU2NlbmFyaW8iLCJzbXJNaXRpZ2F0aW9uRW5hYmxlZCIsIndvcmtsb2FkVHlwZSIsImVsb25TY2VuYXJpb0VuYWJsZWQiLCJnbG9iYWxMYXRlbmN5UmVxdWlyZW1lbnRFbmFibGVkIiwic3BhY2VNYW51ZmFjdHVyaW5nRW5hYmxlZCIsImFpV2ludGVyRW5hYmxlZCIsImFjdHVhbEdyb3VuZElucHV0IiwiZ2Zsb3BzUGVyV2F0dEdyb3VuZDIwMjUiLCJmbG9wc1BlcldhdHRHcm91bmQiLCJhY3R1YWxPcmJpdElucHV0IiwiZ2Zsb3BzUGVyV2F0dE9yYml0YWwyMDI1IiwiZmxvcHNQZXJXYXR0T3JiaXRhbCIsImdyb3VuZEVmZmljaWVuY3lSZXN1bHQiLCJvcmJpdGFsRWZmaWNpZW5jeVJlc3VsdCIsImlzRmluaXRlIiwic3lzdGVtT3ZlcmhlYWRGYWN0b3IiLCJ1dGlsaXphdGlvbkZhY3RvciIsImNoaXBQZWFrR2Zsb3BzUGVyVyIsImVmZmVjdGl2ZUdmbG9wc1BlclciLCJKU09OIiwic3RyaW5naWZ5IiwiZ3JvdW5kRWZmZWN0aXZlR2Zsb3BzUGVyVyIsIm9yYml0UGVha0dmbG9wc1BlcldhdHQiLCJvcmJpdFN5c3RlbUVmZmVjdGl2ZUdmbG9wc1BlcldhdHQiLCJlZmZlY3RpdmVHcm91bmRTY2VuYXJpbyIsImxhdW5jaERpc2NvdW50IiwicG93ZXJEaXNjb3VudCIsIm5ldHdvcmtpbmdEaXNjb3VudCIsIm9wZXJhdG9yTWFyZ2luIiwiZ3JvdW5kTGF0ZW5jeVBlbmFsdHkiLCJtYXNzTXVsdGlwbGllciIsInllYXJzU2luY2VTdGFydCIsInJhbXAiLCJCQVNFX0VORVJHWV8yMDI1IiwiRU5FUkdZX0NPU1RfQkFTRV8yMDI1IiwiQkFTRV9FTEVDVFJJQ0lUWV9QUklDRV8yMDI1IiwiZ3JvdW5kRWxlY3RyaWNpdHlQcmljZVBlck13aCIsImVmZmVjdGl2ZVB1ZUdyb3VuZCIsImdyb3VuZEVuZXJneU1XaFBlclBmbG9wWWVhciIsImdyb3VuZEVuZXJneUNvc3RQZXJQZmxvcFllYXIiLCJjb21wdXRlR3JvdW5kSGFyZHdhcmVDb3N0IiwieSIsImJhc2VDb3N0IiwieWVhckluZGV4IiwiY29zdCIsImFubnVhbERlY2xpbmUiLCJncm91bmRMaWZldGltZSIsImdyb3VuZEhhcmR3YXJlTGlmZXRpbWVZZWFycyIsImdyb3VuZEhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXIiLCJzbXJUb2dnbGVFbmFibGVkIiwic21yVG9nZ2xlUGFyYW1zIiwiZ3JvdW5kVG90YWxDb3N0IiwiZ3JvdW5kQ29tcGFyYXRvckNvc3RQZXJQZmxvcFllYXIiLCJncm91bmRIYXNRdWV1ZSIsImVuZXJneUNvbnN0cmFpbnRNdWx0aXBsaWVyIiwiY29uc3RyYWludEJyZWFrZG93biIsInVzZVJlZ2lvbmFsTW9kZWwiLCJ1c2VSZWdpb25hbEdyb3VuZE1vZGVsIiwidXNlQnVpbGRvdXRNb2RlbCIsInVzZVF1ZXVlTW9kZWwiLCJ1c2VRdWV1ZUJhc2VkQ29uc3RyYWludCIsInN1cHBseVRyYWplY3RvcnkiLCJjdXJyZW50U3VwcGx5U3RhdGUiLCJ3YWNjUGFyYW1zIiwiYmFzZVdhY2MiLCJ3YWNjIiwid2FjY0JhY2tsb2dLIiwid2FjY0JhY2tsb2dFeHBvbmVudCIsImNyaXRpY2FsQmFja2xvZ0dXIiwicGVuYWx0aWVzIiwiY2FwZXhBbm51YWxCYXNlUGVyUGZsb3BZZWFyIiwic2NhcmNpdHlSZW50UmVzdWx0IiwiYXZnV2FpdFllYXJzIiwidXRpbGl6YXRpb25QY3QiLCJ3YWl0VGhyZXNob2xkWWVhcnMiLCJyZW50TWF4TXVsdGlwbGllciIsInV0aWxpemF0aW9uVGhyZXNob2xkIiwic2NhcmNpdHlNdWx0aXBsaWVyIiwic2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyIiwidW5zZXJ2ZWRHdyIsImRlbWFuZEd3IiwiY2FwYWNpdHlHdyIsImJhY2tsb2dHdyIsIndhcm4iLCJleHBlY3RlZEVmZmVjdGl2ZSIsInRvdGFsQ29zdFBlclBmbG9wWWVhckFsbEluIiwic2NhcmNpdHlIaWxsIiwiYXZnV2FpdFllYXJzUmF3IiwiYXZnV2FpdFllYXJzQ2xhbXBlZCIsInJlbnRGcmFjIiwiZGVsaXZlcmVkRnJvbUJhY2tsb2dHdyIsImJhc2VDb3N0UGVyUGZsb3BZZWFyIiwic3VwcGx5TWV0cmljcyIsInBpcGVsaW5lR3ciLCJtYXhCdWlsZFJhdGVHd1llYXIiLCJjb25zdHJhaW50Q29tcG9uZW50cyIsInF1ZXVlUHJlc3N1cmUiLCJ1dGlsaXphdGlvblByZXNzdXJlIiwic2NhcmNpdHlQcmVtaXVtIiwiY2FwZXhBdFJpc2tQZXJNVyIsImNhcnJ5Q29zdFBlck1XIiwibG9zdE1hcmdpblBlck1XIiwicHVlTXVsdGlwbGllciIsIm1vYmlsaXphdGlvblBhcmFtcyIsImRlbWFuZEN1cnZlIiwicHJldk1vYmlsaXphdGlvblN0YXRlIiwicmVzcG9uc2l2ZURlbWFuZEdXIiwib3JiaXRhbFN1YnN0aXR1dGlvbkdXIiwibW9iaWxpemF0aW9uUmVzdWx0IiwiZGVtYW5kTmV3R1ciLCJidWlsZFJhdGVHV3lyIiwiYnVpbGRhYmxlR1ciLCJjYXBhY2l0eUdXIiwicGlwZWxpbmVHVyIsImJhY2tsb2dHVyIsIlBST0pFQ1RfTElGRVRJTUUiLCJCVUlMRE9VVF9DQVBFWF9CQVNFIiwiREVGQVVMVF9TQ0FSQ0lUWV9DVVJWRSIsImsiLCJleHBvbmVudCIsInRocmVzaG9sZFV0aWwiLCJQQU5JQ19FWFBPTkVOVCIsImJhY2tsb2dSYXRpbyIsIndhY2NNdWx0aXBsaWVyIiwid2FjY0VmZmVjdGl2ZSIsImJ1aWxkb3V0UGFyYW1zIiwiZGVtYW5kTmV3R1dCeVllYXIiLCJidWlsZGFibGVHV0J5WWVhciIsImJhc2VFbmVyZ3lQcmljZVBlck13aEJ5WWVhciIsInB1ZUdyb3VuZEJ5WWVhciIsInByb2plY3RMaWZldGltZVllYXJzIiwiYnVpbGRvdXRQcm9qZWN0TGlmZXRpbWVZZWFycyIsInZhbHVlT2ZUaW1lTW9kZSIsImJ1aWxkb3V0Q2FwZXhCYXNlXyRQZXJrVyIsImJ1aWxkb3V0Q2FwZXhTY2FyY2l0eUN1cnZlIiwicGFuaWNFeHBvbmVudCIsImJ1aWxkb3V0UGFuaWNFeHBvbmVudCIsImhhcmR3YXJlQ2FwZXhQZXJQZmxvcFllYXIiLCJjb21wdXRlSGFyZHdhcmVDYXBleCIsInNpdGVDYXBleCIsIm1hcmdpblBlckdwdUhvdXIiLCJhbm51YWxHcHVIb3Vyc0RlbGl2ZXJlZCIsImh5YnJpZFdlaWdodHMiLCJidWlsZG91dEh5YnJpZFdlaWdodHMiLCJ3YWNjV2VpZ2h0IiwibWFyZ2luV2VpZ2h0IiwiYnVpbGRvdXRSZXN1bHQiLCJidWlsZG91dFByZW1pdW1QZXJQZmxvcFllYXIiLCJkZWxheVBlbmFsdHlQZXJQZmxvcFllYXIiLCJzY2FyY2l0eVJlbnRXYWl0VGhyZXNob2xkWWVhcnMiLCJzY2FyY2l0eVJlbnRNYXhNdWx0aXBsaWVyIiwiaGFyZHdhcmVDb3N0V2l0aFJlcGxhY2VtZW50IiwicmVwbGFjZW1lbnRDb3N0UGVyUGZsb3BZZWFyIiwic3BhcmVzQ2FycnlDb3N0UGVyUGZsb3BZZWFyIiwiZ3JvdW5kT3BzQ29zdFBlclBmbG9wWWVhciIsImdyb3VuZFRvdGFsQ29zdF9iYXNlIiwiZ3JvdW5kVG90YWxDb3N0X2VmZmVjdGl2ZSIsImJ1aWxkb3V0RGVidWciLCJyZXBsYWNlbWVudENvc3QiLCJzcGFyZXNDYXJyeUNvc3QiLCJvcHNDb3N0IiwidG90YWxDb3N0UGVyUGZsb3BZZWFyQmFzZSIsInByaWNpbmdDb21wb25lbnRzIiwiZGVsYXlQZW5hbHR5V2VpZ2h0ZWQiLCJwcmljaW5nTW9kZSIsImRlbGF5UGVuYWx0eVdlaWdodCIsIndhaXRFZmZZZWFycyIsImRlbWFuZEdXIiwic2NhcmNpdHlJbmRleCIsImZhY3RvcnMiLCJidWlsZG91dENhcGV4XyRQZXJrVyIsImFubnVhbGl6ZWRCdWlsZG91dFByZW1pdW1fJFBlcmtXeXIiLCJ0aW1lVG9Qb3dlclllYXJzIiwidmFsdWVPZlRpbWVfJFBlclllYXIiLCJkZWxheVBlbmFsdHlfJFBlclllYXIiLCJkZW1hbmRHcm93dGhSYXRlIiwid2FjY0Jhc2UiLCJ3YWl0WWVhcnNVc2VkIiwiaGFzTXVsdGlwbGllciIsImhhc0FkZGVyIiwicmVnaW9uYWxSZXN1bHQiLCJkZW1hbmRQZmxvcHMiLCJlbmVyZ3lDb3N0UGVyUGZsb3BZZWFyIiwic2l0ZUNvc3RQZXJQZmxvcFllYXIiLCJhdmVyYWdlRW5lcmd5Q29zdE13aCIsImdyb3VuZFJlc3VsdFdpdGhCYWNrbG9nIiwiaGFzUHJlbWl1bSIsImxhdW5jaENvc3RQZXJLZyIsImxpZmV0aW1lWWVhcnMiLCJmdXNpb25QYXJhbXMiLCJmdXNpb25Ub2dnbGVFbmFibGVkIiwiZnVzaW9uVG9nZ2xlUGFyYW1zIiwidGFyZ2V0Q29tcHV0ZUt3IiwiY29uc3RlbGxhdGlvbiIsImNvbXB1dGVQb3dlclBlclNhdEt3IiwiY29tcHV0ZVBlclNhdEt3IiwiYWx0aXR1ZGVLbSIsInVzZUNvcnJlY3RlZFNwZWNpZmljUG93ZXIiLCJ1c2VDb3JyZWN0ZWRUaGVybWFsIiwidGhlcm1hbENhcEZhY3RvciIsInRoZXJtYWxTeXN0ZW0iLCJyYWRpYXRpb25EZXJhdGUiLCJkZWdyYWRhdGlvbkZhY3RvciIsImF2YWlsYWJpbGl0eSIsImNhcGFjaXR5RmFjdG9yIiwib3JiaXREZWxpdmVyZWRHZmxvcHNQZXJXYXR0Iiwib3JpZ2luYWxEZWxpdmVyZWQiLCJvcmJpdEVmZmVjdGl2ZUdmbG9wc1BlclciLCJwb3dlclNjYWxpbmdQYXJhbXMiLCJzY2FsaW5nUmVzdWx0IiwibWFzc1BlclNhdEtnIiwidG90YWxNYXNzS2ciLCJNQVhfU0FURUxMSVRFX01BU1NfS0ciLCJtYXhNYXNzS2ciLCJtYXNzUGVyS3ciLCJtYXhDb21wdXRlUGVyU2F0S3ciLCJhZGp1c3RlZENvbnN0ZWxsYXRpb24iLCJtYXhDb21wdXRlS3ciLCJhZGp1c3RlZEh5YnJpZFJlc3VsdCIsImFkanVzdGVkTWFzc1BlclNhdEtnIiwiYWRqdXN0ZWRUaGVybWFsQ2FwRmFjdG9yIiwiYWRqdXN0ZWRSYWRpYXRpb25EZXJhdGUiLCJhZGp1c3RlZEF2YWlsYWJpbGl0eSIsImFkanVzdGVkRGVsaXZlcmVkR2Zsb3BzUGVyV2F0dCIsImNvbnN0ZWxsYXRpb25NdWx0aXBsaWVyIiwibnVtU2F0ZWxsaXRlcyIsImNvbnN0ZWxsYXRpb25PdmVyaGVhZE11bHRpcGxpZXIiLCJjb25zdGVsbGF0aW9uT3ZlcmhlYWQiLCJlZmZlY3RpdmVUb3RhbE1hc3NLZyIsImVmZmVjdGl2ZVRvdGFsTGF1bmNoQ29zdCIsImVmZmVjdGl2ZVBvd2VyRmFiQ29zdCIsInBvd2VyU3lzdGVtIiwiZmFiQ29zdFVzZCIsImVmZmVjdGl2ZU5ldHdvcmtpbmdGYWJDb3N0IiwibmV0d29ya2luZyIsImVmZmVjdGl2ZU5ldHdvcmtpbmdPcEV4IiwiYW5udWFsT3BFeFVzZCIsImVmZmVjdGl2ZVBmbG9wc1BlclNhdCIsInRvdGFsRWZmZWN0aXZlUGZsb3BzIiwibGF1bmNoQ29zdFBlclBmbG9wWWVhciIsImNvbnN0ZWxsYXRpb25Db3N0TXVsdGlwbGllciIsInBvd2VyQ29zdCIsImNvbXB1dGVDb3N0IiwiY29tcHV0ZVBheWxvYWQiLCJjaGlwQ29zdFVzZCIsInF1YWxpZmljYXRpb25Db3N0VXNkIiwidGhlcm1hbENvc3QiLCJyYWRpYXRpb25Db3N0IiwicmFkaWF0aW9uUHJvdGVjdGlvbiIsImJ1c0Nvc3QiLCJidXMiLCJuZXR3b3JraW5nQ29zdCIsImludGVyY29ubmVjdENvc3QiLCJ0b3RhbEFubnVhbENvc3QiLCJyZWd1bGF0b3J5Q29zdCIsInJlZ3VsYXRvcnkiLCJhbm51YWxDb3N0VXNkIiwiYmFzZU9wc0Nvc3RQZXJTYXQiLCJvcHNQZXJQZmxvcFllYXIiLCJuZXR3b3JraW5nT3BzQ29zdFBlclNhdCIsImFkanVzdGVkTmV0d29ya2luZ09wc0Nvc3RQZXJTYXQiLCJvcHNDb3N0UGVyU2F0Iiwib3BzQ29zdE11bHRpcGxpZXIiLCJvcmJpdGFsQnJlYWtkb3duIiwicmFkaWF0aW9uIiwiY29uZ2VzdGlvbiIsImxhdW5jaCIsInRvdGFsU2F0ZWxsaXRlQ29zdCIsInNhdGVsbGl0ZUNvdW50IiwiY29uZ2VzdGlvbkNvc3RQZXJQZmxvcFllYXIiLCJvcmJpdGFsQ29tcG9uZW50cyIsInZhbHVlIiwiYnJlYWtkb3duU3VtIiwiT2JqZWN0IiwidmFsdWVzIiwicmVkdWNlIiwiYSIsImIiLCJyZWFsaXN0aWNDb3N0UGVyUGZsb3AiLCJhcHBsaWVkVG8iLCJvcmJpdGFsQWNjb3VudGluZyIsImNvc3RBY2NvdW50aW5nVmFsaWQiLCJjb3N0QWNjb3VudGluZ0Vycm9yUGN0IiwiZXJyb3JQY3QiLCJhbm51YWxHcHVIb3Vyc1BlclBGTE9QIiwiZGVsYXlQZW5hbHR5QWRkZXJQZXJHcHVIb3VyIiwiZ3JvdW5kQ29zdEJhc2VGb3JQcmljaW5nIiwiZ3JvdW5kR3B1SG91ciIsImJhc2VQcmljaW5nIiwic2l0ZSIsInByZU1hcmdpbkJhc2UiLCJTQ0FSQ0lUWV9SRUZFUkVOQ0VfQkFTRSIsImNvc3RXaXRoU2NhcmNpdHkiLCJjb3N0V2l0aFNjYXJjaXR5QW5kRGVsYXkiLCJzY2FyY2l0eSIsIm9yYml0YWxHcHVIb3VyIiwiZ3JvdW5kVG9rZW5zIiwibGxhbWE3MEIiLCJsbGFtYTQwNUIiLCJvcmJpdGFsVG9rZW5zIiwiZWRnZUluZmVyZW5jZSIsImdwdUhvdXJDcm9zc292ZXIiLCJzdGFuZGFyZCIsImdyb3VuZEVmZmVjdGl2ZSIsImdyb3VuZEhlYWRsaW5lIiwiZWZmZWN0aXZlRXJyb3IiLCJleHBlY3RlZERlbGl2ZXJlZCIsIlRPTEVSQU5DRSIsInJhdGlvRXJyb3IiLCJpc1JhdGlvVmFsaWQiLCJFU0NBTEFURV9USFJFU0hPTEQiLCJpc0ludmFsaWQiLCJkZWxpdmVyZWRWc1N5c3RlbUVycm9yIiwiZGVsaXZlcmVkVmFsaWRhdGlvbiIsImRlbGl2ZXJlZCIsImZhY3RvcnNVc2VkIiwidXRpbGl6YXRpb24iLCJpbnZhbGlkIiwiZWZmaWNpZW5jeVZhbGlkYXRpb24iLCJlZmZpY2llbmN5TGV2ZWwiLCJjb25zaXN0ZW5jeUNoZWNrIiwic2FuaXR5UGFuZWwiLCJncm91bmQiLCJzaXRlQ2FwZXhBbW9ydCIsImNhcGFjaXR5UHJlbWl1bSIsIm9yYml0Iiwic3BlY2lmaWNQb3dlck11bHRpcGxpZXJzIiwicmVxdWlyZWRBcmVhTTIiLCJxUGVyTTJfVyIsIndhc3RlSGVhdFciLCJ3YXN0ZUhlYXRLdyIsInBoeXNpY2FsQXJlYU0yIiwiYXJlYUF2YWlsYWJsZU0yIiwiYWxsSW52YXJpYW50c1Bhc3NlZCIsInRoZXJtYWxBcmVhQ2hlY2siLCJzcGVjaWZpY1Bvd2VyQ2hlY2siLCJlZmZlY3RpdmUiLCJiYXNlU3BlY2lmaWNQb3dlciIsInRoZXJtYWxDYXBDaGVjayIsImVsZWN0cmljaXR5UHJpY2VQZXJNd2giLCJwdWUiLCJjb21wdXRlRGVmaW5pdGlvbiIsInBlYWsiLCJjaGlwTmFtZSIsInBlYWtHZmxvcHNQZXJXYXR0IiwiZWZmZWN0aXZlR2Zsb3BzUGVyV2F0dCIsImdwdUhvdXJQcmljaW5nIiwiYmFzaWMiLCJwcmVtaXVtIiwidG9rZW5QcmljaW5nIiwibGNvZVBlck13aCIsInRvdGFsQ29zdFVzZCIsImNhcGFjaXR5RmFjdG9yUHJvdmVuYW5jZSIsImNvbXB1dGVFZmZpY2llbmN5UHJvdmVuYW5jZSIsInNwZWNpZmljUG93ZXJXUGVyS2ciLCJzcGVjaWZpY1Bvd2VyX3N1YnN5c3RlbV9XUGVyS2ciLCJzcGVjaWZpY1Bvd2VyX2VmZmVjdGl2ZV9XUGVyS2ciLCJlZmZlY3RpdmVTcGVjaWZpY1Bvd2VyIiwiaGFyZHdhcmVDb3N0UGVyUGZsb3BZZWFyIiwicmFkaWF0aW9uTXVsdGlwbGllciIsInRoZXJtYWxDYXBwZWQiLCJtYXhSZWplY3RhYmxlS3ciLCJjb2xsaXNpb25SaXNrIiwiYm9keU1vdW50ZWRBcmVhTTIiLCJkZXBsb3lhYmxlQXJlYU0yIiwidG90YWxSYWRpYXRvckFyZWFNMiIsInJhZGlhdG9yQ29zdFBlclBmbG9wWWVhciIsInJhZGlhdG9yTWFzc0tnIiwib3B0aW1pc3RpY0Nvc3RQZXJQZmxvcCIsInJhZGlhdGlvblNoaWVsZGluZ0Nvc3QiLCJ0aGVybWFsU3lzdGVtQ29zdCIsInJlcGxhY2VtZW50UmF0ZUNvc3QiLCJlY2NPdmVyaGVhZENvc3QiLCJyZWR1bmRhbmN5Q29zdCIsImh5YnJpZEJyZWFrZG93biIsInJhZGlhdGlvbkRlZ3JhZGF0aW9uIiwiYW5udWFsRmFpbHVyZVJhdGUiLCJlZmZlY3RpdmVDb21wdXRlUGVyY2VudCIsImVjY092ZXJoZWFkUGN0IiwiYXBwbGllZCIsInBvd2VyU3lzdGVtVHlwZSIsInNjYWxpbmdQZW5hbHR5IiwiZnVzaW9uRGV0YWlscyIsImRlc2lnbiIsInJhZGlhdG9yQXJlYVBlclNhdE0yIiwic2F0c1BlckxhdW5jaCIsImxhdW5jaGVzUmVxdWlyZWQiLCJzY2FsaW5nIiwic2NhbGluZ0VmZmljaWVuY3kiLCJ3YXJuaW5ncyIsImVmZmVjdGl2ZUNvbXB1dGVNdWx0aXBsaWVycyIsImNvc3RTaGFyZXMiLCJncm91bmRTZWdtZW50IiwibG9jYWxTZW5zaXRpdml0eSIsImRDb3N0X2RMYXVuY2giLCJkQ29zdF9kU3BlY2lmaWNQb3dlciIsImRDb3N0X2RHZmxvcHNQZXJXIiwiYmFzZUZhaWx1cmVSYXRlIiwiZENvc3RfZEZhaWx1cmVSYXRlIiwiZENvc3RfZFB1ZSIsImNyb3Nzb3ZlciIsImNyb3Nzb3ZlckRldGFpbHMiLCJ0b2tlbkNyb3Nzb3ZlciIsIm1hcmtldFBvc2l0aW9uIiwibWV0YWRhdGEiLCJncm91bmRVbml0cyIsIm1ldHJpYyIsInVuaXQiLCJvcmJpdFVuaXRzIiwiZ3B1RmFpbHVyZVJhdGVBbm51YWwiLCJ0b3RhbENvc3RFeGNsdWRlc0RlbGF5UGVuYWx0eSIsInRvdGFsQ29zdEVmZmVjdGl2ZUluY2x1ZGVzRGVsYXlQZW5hbHR5IiwiY29tcHV0ZUVmZmljaWVuY3kiLCJ2YWxpZGF0aW9uIiwiY2hhcnRJbnB1dHMiLCJwb3dlckJ1aWxkb3V0Iiwic3VwcGx5R3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/physicsCost.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/model/trajectory.ts":
/*!*************************************!*\
  !*** ./app/lib/model/trajectory.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MARKET_PROVIDERS: function() { return /* binding */ MARKET_PROVIDERS; },\n/* harmony export */   calculateMarketShare: function() { return /* binding */ calculateMarketShare; },\n/* harmony export */   calculateResponsiveDemand: function() { return /* binding */ calculateResponsiveDemand; },\n/* harmony export */   computeTrajectory: function() { return /* binding */ computeTrajectory; },\n/* harmony export */   findCrossoverYear: function() { return /* binding */ findCrossoverYear; },\n/* harmony export */   findCrossoverYearEffectivePflop: function() { return /* binding */ findCrossoverYearEffectivePflop; },\n/* harmony export */   generateFinalAnalysis: function() { return /* binding */ generateFinalAnalysis; },\n/* harmony export */   getDemandNewGW: function() { return /* binding */ getDemandNewGW; },\n/* harmony export */   getDemandProjection: function() { return /* binding */ getDemandProjection; },\n/* harmony export */   getFacilityLoadGW: function() { return /* binding */ getFacilityLoadGW; },\n/* harmony export */   getITLoadGW: function() { return /* binding */ getITLoadGW; },\n/* harmony export */   projectMarketPrice: function() { return /* binding */ projectMarketPrice; }\n/* harmony export */ });\n/* harmony import */ var _physicsCost__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./physicsCost */ \"(app-pages-browser)/./app/lib/model/physicsCost.ts\");\n/* harmony import */ var _launch_learning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./launch_learning */ \"(app-pages-browser)/./app/lib/model/launch_learning.ts\");\n/* harmony import */ var _modes_static__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modes/static */ \"(app-pages-browser)/./app/lib/model/modes/static.ts\");\n/* harmony import */ var _monteCarloCrossover__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./monteCarloCrossover */ \"(app-pages-browser)/./app/lib/model/monteCarloCrossover.ts\");\n\n\n\n\n/**\n * Find crossover year using GPU-hour pricing (preferred, includes scarcity)\n * Uses scarcity-inclusive comparator consistently\n */ function findCrossoverYear(trajectory) {\n    const crossing = trajectory.find((d)=>{\n        var _d_ground_constraints, _d_ground_constraints1;\n        var _d_ground_totalCostPerPflopYearEffective;\n        // Use effective ground cost (includes delayPenalty + scarcityRent) for crossover\n        const groundEffectiveCost = (_d_ground_totalCostPerPflopYearEffective = d.ground.totalCostPerPflopYearEffective) !== null && _d_ground_totalCostPerPflopYearEffective !== void 0 ? _d_ground_totalCostPerPflopYearEffective : d.ground.totalCostPerPflopYear + (((_d_ground_constraints = d.ground.constraints) === null || _d_ground_constraints === void 0 ? void 0 : _d_ground_constraints.delayPenalty) || 0) + (((_d_ground_constraints1 = d.ground.constraints) === null || _d_ground_constraints1 === void 0 ? void 0 : _d_ground_constraints1.scarcityRentPerPflopYear) || 0);\n        var _d_orbit_totalCostPerPflopYearEffective;\n        const orbitCost = (_d_orbit_totalCostPerPflopYearEffective = d.orbit.totalCostPerPflopYearEffective) !== null && _d_orbit_totalCostPerPflopYearEffective !== void 0 ? _d_orbit_totalCostPerPflopYearEffective : d.orbit.totalCostPerPflopYear;\n        return Number.isFinite(orbitCost) && Number.isFinite(groundEffectiveCost) && orbitCost < groundEffectiveCost;\n    });\n    return crossing ? crossing.year : null;\n}\n/**\n * Find crossover year using effective PFLOP-year cost (includes scarcity adders)\n * Uses scarcity-inclusive comparator: delayPenalty + scarcityRent\n * capacityDeliveryPremium is engineering cost, not scarcity pricing\n */ function findCrossoverYearEffectivePflop(trajectory) {\n    const crossing = trajectory.find((d)=>{\n        var _d_ground_constraints, _d_ground_constraints1;\n        var _d_ground_totalCostPerPflopYearEffective;\n        // Ground effective cost includes: base + delayPenalty + scarcityRent\n        const groundEffectiveCost = (_d_ground_totalCostPerPflopYearEffective = d.ground.totalCostPerPflopYearEffective) !== null && _d_ground_totalCostPerPflopYearEffective !== void 0 ? _d_ground_totalCostPerPflopYearEffective : d.ground.totalCostPerPflopYear + (((_d_ground_constraints = d.ground.constraints) === null || _d_ground_constraints === void 0 ? void 0 : _d_ground_constraints.delayPenalty) || 0) + (((_d_ground_constraints1 = d.ground.constraints) === null || _d_ground_constraints1 === void 0 ? void 0 : _d_ground_constraints1.scarcityRentPerPflopYear) || 0);\n        var _d_orbit_totalCostPerPflopYearEffective;\n        const orbitCost = (_d_orbit_totalCostPerPflopYearEffective = d.orbit.totalCostPerPflopYearEffective) !== null && _d_orbit_totalCostPerPflopYearEffective !== void 0 ? _d_orbit_totalCostPerPflopYearEffective : d.orbit.totalCostPerPflopYear;\n        return orbitCost < groundEffectiveCost;\n    });\n    return crossing ? crossing.year : null;\n}\n// Calculate market share based on cost ratio\n// When orbital is 50% cheaper, it gets ~80% of NEW capacity\n// When orbital is 2x more expensive, it gets ~5% (niche applications)\nfunction calculateMarketShare(year, orbitalCostPerPflop, groundCostPerPflop, totalDemandGW) {\n    let orbitalFeasible = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true, groundFeasible = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true, orbitalCostAccountingValid = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : true, groundCostAccountingValid = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : true, // Additional parameters for served compute calculation\n    demandGW = arguments.length > 8 ? arguments[8] : void 0, backlogGW = arguments.length > 9 ? arguments[9] : void 0, buildRateGWyr = arguments.length > 10 ? arguments[10] : void 0, avgWaitYears = arguments.length > 11 ? arguments[11] : void 0, orbitMaxDeployableComputeGW // Maximum orbital capacity (from launch/manufacturing constraints)\n     = arguments.length > 12 ? arguments[12] : void 0;\n    // CRITICAL FIX: Feasibility gating\n    // Check if both systems are feasible before computing shares\n    const orbitalActuallyFeasible = orbitalFeasible && orbitalCostAccountingValid;\n    const groundActuallyFeasible = groundFeasible && groundCostAccountingValid;\n    // If neither is feasible, default to ground (conservative)\n    if (!orbitalActuallyFeasible && !groundActuallyFeasible) {\n        return {\n            year,\n            totalDemandGW,\n            orbitalShareFrac: 0,\n            orbitalCapacityGW: 0,\n            orbitalRevenue: 0,\n            groundShareFrac: 1.0,\n            groundCapacityGW: totalDemandGW,\n            debug: {\n                shareConvention: \"frac\",\n                orbitalFeasible: false,\n                groundFeasible: false,\n                orbitalShareFrac: 0,\n                groundShareFrac: 1.0,\n                orbitalCapacityGW: 0,\n                groundCapacityGW: totalDemandGW,\n                orbitalRevenue: 0,\n                groundRevenue: totalDemandGW * 2e9\n            }\n        };\n    }\n    // If only one is feasible, it gets 100%\n    if (!orbitalActuallyFeasible) {\n        return {\n            year,\n            totalDemandGW,\n            orbitalShareFrac: 0,\n            orbitalCapacityGW: 0,\n            orbitalRevenue: 0,\n            groundShareFrac: 1.0,\n            groundCapacityGW: totalDemandGW,\n            debug: {\n                shareConvention: \"frac\",\n                orbitalFeasible: false,\n                groundFeasible: true,\n                orbitalShareFrac: 0,\n                groundShareFrac: 1.0,\n                orbitalCapacityGW: 0,\n                groundCapacityGW: totalDemandGW,\n                orbitalRevenue: 0,\n                groundRevenue: totalDemandGW * 2e9\n            }\n        };\n    }\n    if (!groundActuallyFeasible) {\n        return {\n            year,\n            totalDemandGW,\n            orbitalShareFrac: 1.0,\n            orbitalCapacityGW: totalDemandGW,\n            orbitalRevenue: totalDemandGW * 2e9,\n            groundShareFrac: 0,\n            groundCapacityGW: 0,\n            debug: {\n                shareConvention: \"frac\",\n                orbitalFeasible: true,\n                groundFeasible: false,\n                orbitalShareFrac: 1.0,\n                groundShareFrac: 0,\n                orbitalCapacityGW: totalDemandGW,\n                groundCapacityGW: 0,\n                orbitalRevenue: totalDemandGW * 2e9,\n                groundRevenue: 0\n            }\n        };\n    }\n    // Hard rules: shares are always 0..1 fractions, served compute cannot exceed feasible compute\n    const demand = demandGW !== null && demandGW !== void 0 ? demandGW : totalDemandGW;\n    const backlogGWActual = backlogGW !== null && backlogGW !== void 0 ? backlogGW : 0;\n    const buildRateGWyrActual = buildRateGWyr !== null && buildRateGWyr !== void 0 ? buildRateGWyr : 0;\n    const avgWaitYearsActual = avgWaitYears !== null && avgWaitYears !== void 0 ? avgWaitYears : 0;\n    // HARD FEASIBILITY GATING: If avgWaitYears > 3 OR backlog > 25% of demand, ground cannot serve all marginal demand\n    // This forces spillover to orbital earlier, making crossover happen the right way (feasibility, not fake pricing)\n    const groundHasSevereQueue = avgWaitYearsActual > 3 || backlogGWActual > 0.25 * demand;\n    // Ground feasible capacity: reduced by queue pressure\n    const groundFeasibleGW = groundActuallyFeasible ? groundHasSevereQueue ? Math.max(0, demand * 0.5 - backlogGWActual) // Severe queue: ground can only serve 50% of demand\n     : Math.max(0, demand - backlogGWActual) // Normal: ground can serve demand minus backlog\n     : 0;\n    // Orbital feasible capacity: can serve remainder (up to max deployable)\n    const orbitFeasibleGW = orbitalActuallyFeasible ? Math.min(demand - groundFeasibleGW, orbitMaxDeployableComputeGW !== null && orbitMaxDeployableComputeGW !== void 0 ? orbitMaxDeployableComputeGW : demand) : 0;\n    const maxServable = Math.min(demand, groundFeasibleGW + orbitFeasibleGW);\n    // Compute desired shares (0..1) from cost ratios (logit model)\n    const costRatio = orbitalCostPerPflop / groundCostPerPflop;\n    const logitFactor = Math.exp(-5 * (costRatio - 1)); // When orbital is 50% cheaper, it gets ~80% of NEW capacity\n    const orbitalShareFracDesired = logitFactor / (1 + logitFactor);\n    const groundShareFracDesired = 1 - orbitalShareFracDesired;\n    // Convert to served, then clamp by feasibility\n    let orbitServed = orbitalShareFracDesired * maxServable;\n    let groundServed = groundShareFracDesired * maxServable;\n    orbitServed = Math.min(orbitServed, orbitFeasibleGW);\n    groundServed = Math.min(groundServed, groundFeasibleGW);\n    // If clamping reduced one side, reassign remainder if possible\n    const remainder = maxServable - (orbitServed + groundServed);\n    if (remainder > 0) {\n        const orbitRoom = orbitFeasibleGW - orbitServed;\n        const groundRoom = groundFeasibleGW - groundServed;\n        const addToOrbit = Math.min(remainder, Math.max(0, orbitRoom));\n        orbitServed += addToOrbit;\n        groundServed += Math.min(remainder - addToOrbit, Math.max(0, groundRoom));\n    }\n    // Recalculate shares from actual served (ensures shares are 0..1 and sum to 1)\n    const totalServedGW = orbitServed + groundServed;\n    const orbitalShareFrac = totalServedGW > 0 ? orbitServed / totalServedGW : 0;\n    const groundShareFrac = totalServedGW > 0 ? groundServed / totalServedGW : 0;\n    // Use served values for capacity\n    const groundServedComputeGW = groundServed;\n    const orbitServedComputeGW = orbitServed;\n    const groundFeasibleComputeGW = groundFeasibleGW;\n    const orbitFeasibleComputeGW = orbitFeasibleGW;\n    // Capacity served (GW)\n    const orbitalCapacityGW = orbitServedComputeGW;\n    const groundCapacityGW = groundServedComputeGW;\n    // Revenue per GW (assume $2B/GW/year for compute services)\n    const revenuePerGW = 2e9;\n    const orbitalRevenue = orbitalCapacityGW * revenuePerGW;\n    const groundRevenue = groundCapacityGW * revenuePerGW;\n    // Invariants\n    if (orbitalCapacityGW === 0 && orbitalRevenue !== 0) {\n        throw new Error(\"orbitalCapacityGW=0 but orbitalRevenue=\".concat(orbitalRevenue, \" > 0\"));\n    }\n    if (orbitalRevenue > 0 && orbitalCapacityGW <= 0) {\n        throw new Error(\"orbitalRevenue=\".concat(orbitalRevenue, \" > 0 but orbitalCapacityGW=\").concat(orbitalCapacityGW, \" <= 0\"));\n    }\n    if (orbitFeasibleComputeGW === 0 && orbitalShareFrac !== 0) {\n        throw new Error(\"orbitFeasibleComputeGW=0 but orbitalShareFrac=\".concat(orbitalShareFrac, \" > 0\"));\n    }\n    // Shares should sum to 1.0 when both feasible and totalServed > 0\n    if (totalServedGW > 0) {\n        const shareSum = orbitalShareFrac + groundShareFrac;\n        if (Math.abs(shareSum - 1.0) > 1e-6) {\n            throw new Error(\"Market share sum must equal 1.0, got \".concat(shareSum, \" (orbital=\").concat(orbitalShareFrac, \", ground=\").concat(groundShareFrac, \")\"));\n        }\n    }\n    return {\n        year,\n        totalDemandGW,\n        orbitalShareFrac,\n        orbitalCapacityGW,\n        orbitalRevenue,\n        groundShareFrac,\n        groundCapacityGW,\n        debug: {\n            shareConvention: \"frac\",\n            orbitalFeasible: true,\n            groundFeasible: true,\n            orbitalShareFrac,\n            groundShareFrac,\n            orbitalCapacityGW,\n            groundCapacityGW,\n            orbitalRevenue,\n            groundRevenue,\n            demandComputeGW: demand,\n            groundServedComputeGW,\n            orbitServedComputeGW,\n            groundFeasibleComputeGW,\n            orbitFeasibleComputeGW,\n            backlogGW: backlogGWActual,\n            buildRateGWyr: buildRateGWyrActual,\n            avgWaitYears: avgWaitYears !== null && avgWaitYears !== void 0 ? avgWaitYears : 0\n        }\n    };\n}\nfunction projectMarketPrice(basePrice, baseYear, targetYear) {\n    let annualDeclineRate = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.10;\n    const years = targetYear - baseYear;\n    return basePrice * Math.pow(1 - annualDeclineRate, years);\n}\nconst MARKET_PROVIDERS = [\n    {\n        name: \"AWS H100\",\n        price: 4.50,\n        decline: 0.10\n    },\n    {\n        name: \"Azure H100\",\n        price: 4.00,\n        decline: 0.10\n    },\n    {\n        name: \"CoreWeave\",\n        price: 2.23,\n        decline: 0.12\n    },\n    {\n        name: \"Lambda Labs\",\n        price: 2.49,\n        decline: 0.10\n    }\n];\n// ============================================================================\n// DEMAND MODEL: Installed IT Load (GW) with Piecewise Exponential Growth\n// ============================================================================\n// \n// Model: IT_GW(t) = installed IT load in GW\n// Targets:\n//   - IT_GW(2025) = IT0 (baseline)\n//   - IT_GW(2040) = 450 GW\n//   - IT_GW(2060) = 3000 GW (multi-TW by 2060)\n//\n// Piecewise exponential:\n//   - 2025-2040: IT_GW(t) = IT0 * exp(r1 * (t - 2025))\n//   - 2040-2060: IT_GW(t) = IT_GW(2040) * exp(r2 * (t - 2040))\n//\n// Then derive:\n//   - Facility_GW(t) = IT_GW(t) * PUE(t)  (hits transmission/substation constraints)\n//   - DemandNewGW(t) = max(0, Facility_GW(t) - Facility_GW(t-1))\n// LEGACY: Hardcoded demand anchors (kept for backward compatibility, but replaced by responsive demand)\nconst IT_GW_2025 = 120; // Baseline installed IT load in 2025 (GW)\nconst IT_GW_2040_TARGET = 450; // Target installed IT load in 2040 (GW)\nconst IT_GW_2060_TARGET = 3000; // Target installed IT load in 2060 (GW)\n// Calculate growth rates\nconst R1 = Math.log(IT_GW_2040_TARGET / IT_GW_2025) / 15; // Growth rate 2025-2040\nconst R2 = Math.log(IT_GW_2060_TARGET / IT_GW_2040_TARGET) / 20; // Growth rate 2040-2060\n/**\n * Calculate price-responsive demand that creates S-curve\n * \n * Demand responds to:\n * - Price elasticity: higher ground prices reduce demand\n * - Wait elasticity: longer waits reduce demand\n * - Orbital substitution: if orbital cheaper, demand shifts\n */ function calculateResponsiveDemand(year, groundPricePerGpuHour, orbitalPricePerGpuHour, avgWaitYears, prevDemandState) {\n    // Baseline demand: 10% CAGR from 120 GW, TAPERED after 20 years\n    const yearsFrom2025 = year - 2025;\n    const growthRate = 0.10; // 10% CAGR\n    const taper = 1 / (1 + Math.exp((yearsFrom2025 - 20) / 5)); // Tapers after 2045\n    const effectiveGrowth = growthRate * (0.5 + 0.5 * taper); // 10% -> 5% CAGR\n    const baselineGW = 120 * Math.pow(1 + effectiveGrowth, yearsFrom2025);\n    // Price elasticity: demand drops as ground price rises\n    const baselinePrice = 4.00; // $/GPU-hr reference\n    const priceRatio = groundPricePerGpuHour / baselinePrice;\n    const priceElasticity = -0.3; // 30% drop per 100% price increase\n    const priceFactor = Math.pow(priceRatio, priceElasticity);\n    // Wait elasticity: demand drops with longer waits\n    const waitElasticity = -0.15; // 15% drop per 5yr wait\n    const waitFactor = Math.exp(avgWaitYears * waitElasticity / 5);\n    // Effective total demand (may shift to orbital)\n    const effectiveGW = baselineGW * priceFactor * waitFactor;\n    // Orbital substitution: if orbital < ground, demand shifts\n    const groundOrbitalRatio = groundPricePerGpuHour / Math.max(orbitalPricePerGpuHour, 0.01);\n    let orbitalShare = 0;\n    if (groundOrbitalRatio > 1.0) {\n        // Orbital is cheaper - logistic shift\n        // At ratio 1.5 (ground 50% more): ~30% shifts to orbital\n        // At ratio 2.0 (ground 100% more): ~60% shifts to orbital\n        orbitalShare = 1 / (1 + Math.exp(-2 * (groundOrbitalRatio - 1.3)));\n    }\n    const orbitalDemandGW = effectiveGW * orbitalShare;\n    const groundDemandGW = effectiveGW * (1 - orbitalShare);\n    return {\n        year,\n        baselineGW,\n        effectiveGW,\n        groundDemandGW,\n        orbitalDemandGW\n    };\n}\n/**\n * Calculate installed IT load (GW) for a given year\n */ function getITLoadGW(year) {\n    if (year < 2025) {\n        return IT_GW_2025;\n    }\n    if (year <= 2040) {\n        // Phase 1: 2025-2040\n        const yearsFrom2025 = year - 2025;\n        return IT_GW_2025 * Math.exp(R1 * yearsFrom2025);\n    }\n    // Phase 2: 2040-2060\n    const yearsFrom2040 = year - 2040;\n    return IT_GW_2040_TARGET * Math.exp(R2 * yearsFrom2040);\n}\n/**\n * Calculate facility load (GW) = IT load * PUE\n */ function getFacilityLoadGW(year) {\n    let pue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1.3;\n    const itLoadGW = getITLoadGW(year);\n    return itLoadGW * pue;\n}\n/**\n * Calculate new demand (GW) = max(0, Facility_GW(t) - Facility_GW(t-1))\n */ function getDemandNewGW(year) {\n    let pue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1.3;\n    const facilityGW = getFacilityLoadGW(year, pue);\n    const facilityGWPrev = getFacilityLoadGW(year - 1, pue);\n    return Math.max(0, facilityGW - facilityGWPrev);\n}\n/**\n * Legacy function: returns IT load (not facility load)\n * Kept for backward compatibility\n */ function getDemandProjection(year) {\n    return getITLoadGW(year);\n}\nfunction computeTrajectory(options) {\n    // Re-export crossover analysis functions for convenience\n    // Users can import from trajectory.ts or crossoverAnalysis.ts\n    const years = Array.from({\n        length: 26\n    }, (_, i)=>2025 + i); // 2025-2050 (26 years)\n    const trajectory = [];\n    let firstCapYear = null; // Track when constraint cap was first hit\n    // Launch learning: Track cumulative mass to orbit\n    let launchLearningState = null;\n    const BASELINE_MASS_KG = 1000000; // 1M kg baseline for doublings calculation\n    const LAUNCH_COST_0_PER_KG = 1500; // Initial launch cost in 2025\n    // Responsive demand: Track demand state across years for S-curve behavior\n    let prevDemandState = null;\n    let prevYearBreakdown = null;\n    // Buildout state: Track across years for backlog calculation\n    let buildoutState = null;\n    // Mobilization state: Track across years for capacity/backlog evolution\n    let mobilizationState = null;\n    for (const year of years){\n        var _prevYearBreakdown_ground_gpuHourPricing_standard, _prevYearBreakdown_ground_gpuHourPricing, _prevYearBreakdown_ground, _prevYearBreakdown_orbit_gpuHourPricing_standard, _prevYearBreakdown_orbit_gpuHourPricing, _prevYearBreakdown_orbit, _prevYearBreakdown_ground_supplyMetrics, _prevYearBreakdown_ground1, _breakdown_ground, _breakdown_ground1, _breakdown_orbit_constellation, _breakdown_orbit, _breakdown_metadata_chartInputs, _breakdown_metadata, _breakdown_ground2, _breakdown_ground_buildoutDebug, _breakdown_ground3, _breakdown_ground_buildoutDebug1, _breakdown_ground4, _breakdown_ground_supplyMetrics, _breakdown_ground5, _breakdown_ground6, _breakdown_ground_buildoutDebug2, _breakdown_ground7, _breakdown_ground_supplyMetrics1, _breakdown_ground8, _params_orbitMaxDeployableComputeGWByYear, _breakdown_ground9;\n        const params = options.mode === \"STATIC\" ? (0,_modes_static__WEBPACK_IMPORTED_MODULE_2__.getStaticParams)(year) : options.paramsByYear(year);\n        // Apply launch learning if enabled\n        let launchCostPerKg = (0,_physicsCost__WEBPACK_IMPORTED_MODULE_0__.getLaunchCostPerKg)(year, params.launchCostKg);\n        let paramsWithLaunchCost = params;\n        if (options.useLaunchLearning) {\n            // Estimate mass demanded from compute power: ~1000 kg per MW compute\n            // Use targetGW as proxy for orbital compute demand\n            const computePowerMW = params.targetGW * 1000; // Convert GW to MW\n            const massPerMW = 1000; // Rough estimate: 1000 kg per MW\n            const massDemandedKg = computePowerMW * massPerMW;\n            const launchLearningResult = (0,_launch_learning__WEBPACK_IMPORTED_MODULE_1__.stepLaunchLearning)(launchLearningState, {\n                year,\n                massDemandedKg,\n                baselineMassKg: BASELINE_MASS_KG,\n                launchCost0PerKg: LAUNCH_COST_0_PER_KG,\n                learningRate: 0.15,\n                maxFlightsPerYear: 1000,\n                payloadPerFlightKg: 100000\n            });\n            launchCostPerKg = launchLearningResult.launchCostPerKg;\n            launchLearningState = launchLearningResult.state;\n            // Override launch cost in params for this year\n            paramsWithLaunchCost = {\n                ...params,\n                launchCostKg: launchCostPerKg\n            };\n        }\n        var _params_pueGround;\n        // SINGLE SOURCE OF TRUTH: compute demand in GW using RESPONSIVE demand\n        // Demand responds to prices, wait times, and orbital substitution (creates S-curve)\n        // NOTE: We use PREVIOUS year's prices to calculate current year's demand (avoids circular dependency)\n        const groundPue = (_params_pueGround = params.pueGround) !== null && _params_pueGround !== void 0 ? _params_pueGround : 1.3;\n        var _prevYearBreakdown_ground_gpuHourPricing_standard_pricePerGpuHour;\n        // Get prices from previous year (or estimates for first year)\n        const prevGroundPrice = (_prevYearBreakdown_ground_gpuHourPricing_standard_pricePerGpuHour = prevYearBreakdown === null || prevYearBreakdown === void 0 ? void 0 : (_prevYearBreakdown_ground = prevYearBreakdown.ground) === null || _prevYearBreakdown_ground === void 0 ? void 0 : (_prevYearBreakdown_ground_gpuHourPricing = _prevYearBreakdown_ground.gpuHourPricing) === null || _prevYearBreakdown_ground_gpuHourPricing === void 0 ? void 0 : (_prevYearBreakdown_ground_gpuHourPricing_standard = _prevYearBreakdown_ground_gpuHourPricing.standard) === null || _prevYearBreakdown_ground_gpuHourPricing_standard === void 0 ? void 0 : _prevYearBreakdown_ground_gpuHourPricing_standard.pricePerGpuHour) !== null && _prevYearBreakdown_ground_gpuHourPricing_standard_pricePerGpuHour !== void 0 ? _prevYearBreakdown_ground_gpuHourPricing_standard_pricePerGpuHour : 4.00;\n        var _prevYearBreakdown_orbit_gpuHourPricing_standard_pricePerGpuHour;\n        const prevOrbitalPrice = (_prevYearBreakdown_orbit_gpuHourPricing_standard_pricePerGpuHour = prevYearBreakdown === null || prevYearBreakdown === void 0 ? void 0 : (_prevYearBreakdown_orbit = prevYearBreakdown.orbit) === null || _prevYearBreakdown_orbit === void 0 ? void 0 : (_prevYearBreakdown_orbit_gpuHourPricing = _prevYearBreakdown_orbit.gpuHourPricing) === null || _prevYearBreakdown_orbit_gpuHourPricing === void 0 ? void 0 : (_prevYearBreakdown_orbit_gpuHourPricing_standard = _prevYearBreakdown_orbit_gpuHourPricing.standard) === null || _prevYearBreakdown_orbit_gpuHourPricing_standard === void 0 ? void 0 : _prevYearBreakdown_orbit_gpuHourPricing_standard.pricePerGpuHour) !== null && _prevYearBreakdown_orbit_gpuHourPricing_standard_pricePerGpuHour !== void 0 ? _prevYearBreakdown_orbit_gpuHourPricing_standard_pricePerGpuHour : 25.00;\n        var _prevYearBreakdown_ground_supplyMetrics_avgWaitYears;\n        const prevAvgWait = (_prevYearBreakdown_ground_supplyMetrics_avgWaitYears = prevYearBreakdown === null || prevYearBreakdown === void 0 ? void 0 : (_prevYearBreakdown_ground1 = prevYearBreakdown.ground) === null || _prevYearBreakdown_ground1 === void 0 ? void 0 : (_prevYearBreakdown_ground_supplyMetrics = _prevYearBreakdown_ground1.supplyMetrics) === null || _prevYearBreakdown_ground_supplyMetrics === void 0 ? void 0 : _prevYearBreakdown_ground_supplyMetrics.avgWaitYears) !== null && _prevYearBreakdown_ground_supplyMetrics_avgWaitYears !== void 0 ? _prevYearBreakdown_ground_supplyMetrics_avgWaitYears : 0;\n        // Calculate responsive demand (price/wait elastic, orbital substitution)\n        const demandState = calculateResponsiveDemand(year, prevGroundPrice, prevOrbitalPrice, prevAvgWait, prevDemandState);\n        prevDemandState = demandState;\n        // Pass firstCapYear, mobilizationState, and responsive demand to computePhysicsCost\n        // Add mobilization state and responsive demand to params so they can be used for backlog calculation\n        const paramsWithMobilization = {\n            ...paramsWithLaunchCost,\n            prevMobilizationState: mobilizationState,\n            responsiveDemandGW: demandState.groundDemandGW,\n            orbitalSubstitutionGW: demandState.orbitalDemandGW\n        }; // Type assertion needed since YearParams doesn't include these fields\n        const breakdown = (0,_physicsCost__WEBPACK_IMPORTED_MODULE_0__.computePhysicsCost)(paramsWithMobilization, firstCapYear);\n        // Update launch learning state with actual mass from breakdown (for next iteration)\n        if (options.useLaunchLearning && breakdown.orbit && breakdown.orbit.hybridBreakdown) {\n        // Use actual mass from hybrid breakdown if available\n        // Mass is not directly in orbital breakdown, but we can estimate from launch cost\n        // For now, use the mass demanded estimate (will be refined in next iteration)\n        }\n        const constraintBreakdown = breakdown.ground.constraintBreakdown;\n        if (constraintBreakdown && \"capYear\" in constraintBreakdown && constraintBreakdown.capYear !== null && constraintBreakdown.capYear !== undefined) {\n            const thisCapYear = constraintBreakdown.capYear;\n            if (firstCapYear === null || thisCapYear < firstCapYear) {\n                firstCapYear = thisCapYear;\n            }\n        }\n        var _breakdown_ground_pue;\n        // Use responsive ground demand (facility load = ground demand * PUE)\n        const actualGroundPue = (_breakdown_ground_pue = (_breakdown_ground = breakdown.ground) === null || _breakdown_ground === void 0 ? void 0 : _breakdown_ground.pue) !== null && _breakdown_ground_pue !== void 0 ? _breakdown_ground_pue : groundPue;\n        const demandComputeGW = demandState.groundDemandGW * actualGroundPue; // Convert IT load to facility load\n        const orbitalDemandGW = demandState.orbitalDemandGW * actualGroundPue; // For orbital capacity planning\n        // CRITICAL: Ensure ground.buildoutDebug.demandGW matches single source of truth\n        // Override any value from buildout model to ensure consistency\n        if ((_breakdown_ground1 = breakdown.ground) === null || _breakdown_ground1 === void 0 ? void 0 : _breakdown_ground1.buildoutDebug) {\n            breakdown.ground.buildoutDebug.demandGW = demandComputeGW;\n        }\n        // Use demandComputeGW for all market calculations (single source of truth)\n        const totalDemandGW = demandComputeGW;\n        const orbitalFeasible = breakdown.orbit && breakdown.orbit.totalCostPerPflopYear > 0 && breakdown.orbit.totalCostPerPflopYear < Infinity;\n        const groundFeasible = breakdown.ground && breakdown.ground.totalCostPerPflopYear > 0 && breakdown.ground.totalCostPerPflopYear < Infinity;\n        const orbitalCostAccountingValid = breakdown.costAccountingValid !== false;\n        const groundCostAccountingValid = breakdown.costAccountingValid !== false;\n        // Calculate orbital capacity GW from constellation: (numSatellites * computePerSatKw) / 1e6\n        // kW -> GW conversion: divide by 1,000,000 (1e6)\n        // CRITICAL: computePerSatKw is in kW, so divide by 1e6 to get GW (not 1e3 for MW)\n        let orbitalCapacityGW_fromSats = 0;\n        if ((_breakdown_orbit = breakdown.orbit) === null || _breakdown_orbit === void 0 ? void 0 : (_breakdown_orbit_constellation = _breakdown_orbit.constellation) === null || _breakdown_orbit_constellation === void 0 ? void 0 : _breakdown_orbit_constellation.design) {\n            const { numSatellites, computePerSatKw } = breakdown.orbit.constellation.design;\n            // kW -> GW: divide by 1,000,000 (1e6), NOT 1,000 (1e3)\n            orbitalCapacityGW_fromSats = numSatellites * computePerSatKw / 1000000;\n            // Invariant: 1 satellite at 111 kW should be 0.000111 GW, not 1.144 GW\n            if ( true && numSatellites === 1) {\n                const expectedGW = computePerSatKw / 1000000;\n                const error = Math.abs(orbitalCapacityGW_fromSats - expectedGW) / Math.max(expectedGW, 1e-9);\n                if (error > 0.01) {\n                    throw new Error(\"[ORBITAL CAPACITY BUG] Year \".concat(year, \": 1 satellite at \").concat(computePerSatKw, \" kW should be \").concat(expectedGW, \" GW, \") + \"but got \".concat(orbitalCapacityGW_fromSats, \" GW. Check kW->GW conversion (must divide by 1e6, not 1e3).\"));\n                }\n            }\n        }\n        const chartPB = (_breakdown_metadata = breakdown.metadata) === null || _breakdown_metadata === void 0 ? void 0 : (_breakdown_metadata_chartInputs = _breakdown_metadata.chartInputs) === null || _breakdown_metadata_chartInputs === void 0 ? void 0 : _breakdown_metadata_chartInputs.powerBuildout;\n        const chartBacklog = chartPB === null || chartPB === void 0 ? void 0 : chartPB.backlogGw;\n        const chartAvgWait = chartPB === null || chartPB === void 0 ? void 0 : chartPB.avgWaitYears;\n        const chartBuildRate = chartPB === null || chartPB === void 0 ? void 0 : chartPB.maxBuildRateGwYear;\n        // Prefer buildoutDebug when present.\n        // If ground/backlog fields exist but are 0 while chartInputs says >0, use chartInputs.\n        // Remove the pipelineGw proxy entirely (it's not backlog and causes silent unit/meaning corruption).\n        const backlogFromGround = (_breakdown_ground2 = breakdown.ground) === null || _breakdown_ground2 === void 0 ? void 0 : _breakdown_ground2.backlogGw;\n        const backlogFromBuildout = (_breakdown_ground3 = breakdown.ground) === null || _breakdown_ground3 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug = _breakdown_ground3.buildoutDebug) === null || _breakdown_ground_buildoutDebug === void 0 ? void 0 : _breakdown_ground_buildoutDebug.backlogGW;\n        var _ref, _ref1;\n        let backlogGW = (_ref1 = (_ref = backlogFromBuildout !== undefined ? backlogFromBuildout : undefined) !== null && _ref !== void 0 ? _ref : backlogFromGround !== undefined && backlogFromGround > 0 ? backlogFromGround : undefined) !== null && _ref1 !== void 0 ? _ref1 : chartBacklog !== undefined && chartBacklog > 0 ? chartBacklog : 0;\n        const buildRateFromBuildout = (_breakdown_ground4 = breakdown.ground) === null || _breakdown_ground4 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug1 = _breakdown_ground4.buildoutDebug) === null || _breakdown_ground_buildoutDebug1 === void 0 ? void 0 : _breakdown_ground_buildoutDebug1.buildRateGWyr;\n        const buildRateFromSupply = (_breakdown_ground5 = breakdown.ground) === null || _breakdown_ground5 === void 0 ? void 0 : (_breakdown_ground_supplyMetrics = _breakdown_ground5.supplyMetrics) === null || _breakdown_ground_supplyMetrics === void 0 ? void 0 : _breakdown_ground_supplyMetrics.maxBuildRateGwYear;\n        var _ref2, _ref3;\n        const buildRateGWyr = (_ref3 = (_ref2 = buildRateFromBuildout !== undefined ? buildRateFromBuildout : undefined) !== null && _ref2 !== void 0 ? _ref2 : buildRateFromSupply !== undefined ? buildRateFromSupply : undefined) !== null && _ref3 !== void 0 ? _ref3 : chartBuildRate !== undefined ? chartBuildRate : 0;\n        const avgWaitFromGround = (_breakdown_ground6 = breakdown.ground) === null || _breakdown_ground6 === void 0 ? void 0 : _breakdown_ground6.avgWaitYears;\n        const avgWaitFromBuildout = (_breakdown_ground7 = breakdown.ground) === null || _breakdown_ground7 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug2 = _breakdown_ground7.buildoutDebug) === null || _breakdown_ground_buildoutDebug2 === void 0 ? void 0 : _breakdown_ground_buildoutDebug2.timeToPowerYears;\n        const avgWaitFromSupply = (_breakdown_ground8 = breakdown.ground) === null || _breakdown_ground8 === void 0 ? void 0 : (_breakdown_ground_supplyMetrics1 = _breakdown_ground8.supplyMetrics) === null || _breakdown_ground_supplyMetrics1 === void 0 ? void 0 : _breakdown_ground_supplyMetrics1.avgWaitYears;\n        var _ref4, _ref5, _ref6;\n        let avgWaitYears = (_ref6 = (_ref5 = (_ref4 = avgWaitFromBuildout !== undefined ? avgWaitFromBuildout : undefined) !== null && _ref4 !== void 0 ? _ref4 : avgWaitFromGround !== undefined && avgWaitFromGround > 0 ? avgWaitFromGround : undefined) !== null && _ref5 !== void 0 ? _ref5 : avgWaitFromSupply !== undefined && avgWaitFromSupply > 0 ? avgWaitFromSupply : undefined) !== null && _ref6 !== void 0 ? _ref6 : chartAvgWait !== undefined && chartAvgWait > 0 ? chartAvgWait : 0;\n        // Self-heal plumbing mismatches: if chartInputs has positive value but chosen is 0, use chartInputs\n        // Log structured error but never throw (prevents chart from disappearing)\n        if ((chartBacklog !== null && chartBacklog !== void 0 ? chartBacklog : 0) > 0 && backlogGW === 0 && chartBacklog !== undefined) {\n            backlogGW = chartBacklog;\n            if (true) {\n                var _breakdown_ground10, _breakdown_ground_buildoutDebug3, _breakdown_ground11, _breakdown_ground_supplyMetrics2, _breakdown_ground12;\n                console.error(\"[BACKLOG PLUMBING] Year \".concat(year, \": chartInputs.backlogGw=\").concat(chartBacklog, \" but fallback chain returned 0. \") + \"Self-healed: using chartInputs. \" + \"Candidates: ground.backlogGw=\".concat((_breakdown_ground10 = breakdown.ground) === null || _breakdown_ground10 === void 0 ? void 0 : _breakdown_ground10.backlogGw, \", \") + \"buildoutDebug.backlogGW=\".concat((_breakdown_ground11 = breakdown.ground) === null || _breakdown_ground11 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug3 = _breakdown_ground11.buildoutDebug) === null || _breakdown_ground_buildoutDebug3 === void 0 ? void 0 : _breakdown_ground_buildoutDebug3.backlogGW, \", \") + \"supplyMetrics.pipelineGw=\".concat((_breakdown_ground12 = breakdown.ground) === null || _breakdown_ground12 === void 0 ? void 0 : (_breakdown_ground_supplyMetrics2 = _breakdown_ground12.supplyMetrics) === null || _breakdown_ground_supplyMetrics2 === void 0 ? void 0 : _breakdown_ground_supplyMetrics2.pipelineGw));\n            }\n        }\n        if ((chartAvgWait !== null && chartAvgWait !== void 0 ? chartAvgWait : 0) > 0 && avgWaitYears === 0 && chartAvgWait !== undefined) {\n            avgWaitYears = chartAvgWait;\n            if (true) {\n                var _breakdown_ground13, _breakdown_ground_buildoutDebug4, _breakdown_ground14, _breakdown_ground_supplyMetrics3, _breakdown_ground15;\n                console.error(\"[WAIT PLUMBING] Year \".concat(year, \": chartInputs.avgWaitYears=\").concat(chartAvgWait, \" but fallback chain returned 0. \") + \"Self-healed: using chartInputs. \" + \"Candidates: ground.avgWaitYears=\".concat((_breakdown_ground13 = breakdown.ground) === null || _breakdown_ground13 === void 0 ? void 0 : _breakdown_ground13.avgWaitYears, \", \") + \"buildoutDebug.timeToPowerYears=\".concat((_breakdown_ground14 = breakdown.ground) === null || _breakdown_ground14 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug4 = _breakdown_ground14.buildoutDebug) === null || _breakdown_ground_buildoutDebug4 === void 0 ? void 0 : _breakdown_ground_buildoutDebug4.timeToPowerYears, \", \") + \"supplyMetrics.avgWaitYears=\".concat((_breakdown_ground15 = breakdown.ground) === null || _breakdown_ground15 === void 0 ? void 0 : (_breakdown_ground_supplyMetrics3 = _breakdown_ground15.supplyMetrics) === null || _breakdown_ground_supplyMetrics3 === void 0 ? void 0 : _breakdown_ground_supplyMetrics3.avgWaitYears));\n            }\n        }\n        var _params_orbitMaxDeployableComputeGWByYear1;\n        // Calculate orbitMaxDeployableComputeGW from constellation capacity or scenario params\n        // Canonical orbital capacity from constellation: (numSatellites * computePerSatKw) / 1e6\n        const orbitMaxDeployableComputeGW = orbitalFeasible ? (_params_orbitMaxDeployableComputeGWByYear1 = (_params_orbitMaxDeployableComputeGWByYear = params.orbitMaxDeployableComputeGWByYear) === null || _params_orbitMaxDeployableComputeGWByYear === void 0 ? void 0 : _params_orbitMaxDeployableComputeGWByYear.call(params, year)) !== null && _params_orbitMaxDeployableComputeGWByYear1 !== void 0 ? _params_orbitMaxDeployableComputeGWByYear1 : orbitalCapacityGW_fromSats : 0;\n        // Fix orbit feasibility gating: use orbitMaxDeployableComputeGW, not orbitalCapacityGW placeholder\n        const orbitalFeasibleForShare = orbitalFeasible && orbitMaxDeployableComputeGW > 0;\n        const marketAnalysis = calculateMarketShare(year, breakdown.orbit.totalCostPerPflopYear, breakdown.ground.totalCostPerPflopYear, totalDemandGW, orbitalFeasibleForShare, groundFeasible, orbitalCostAccountingValid, groundCostAccountingValid, demandComputeGW, backlogGW, buildRateGWyr, avgWaitYears, orbitMaxDeployableComputeGW);\n        breakdown.market = {\n            totalDemandGW: demandComputeGW,\n            orbitalShareFrac: marketAnalysis.orbitalShareFrac,\n            orbitalCapacityGW: marketAnalysis.orbitalCapacityGW,\n            orbitalRevenue: marketAnalysis.orbitalRevenue,\n            groundShareFrac: marketAnalysis.groundShareFrac,\n            groundCapacityGW: marketAnalysis.groundCapacityGW,\n            debug: {\n                ...marketAnalysis.debug,\n                demandComputeGW: demandComputeGW,\n                orbitalCapacityGW_fromSats: orbitalCapacityGW_fromSats\n            }\n        };\n        // Invariant: demand scalar consistency\n        if ( true && breakdown.market) {\n            var _breakdown_market_debug, _breakdown_ground_buildoutDebug5, _breakdown_ground16;\n            const marketDemand = breakdown.market.totalDemandGW;\n            const marketDebugDemand = (_breakdown_market_debug = breakdown.market.debug) === null || _breakdown_market_debug === void 0 ? void 0 : _breakdown_market_debug.demandComputeGW;\n            const buildoutDemand = (_breakdown_ground16 = breakdown.ground) === null || _breakdown_ground16 === void 0 ? void 0 : (_breakdown_ground_buildoutDebug5 = _breakdown_ground16.buildoutDebug) === null || _breakdown_ground_buildoutDebug5 === void 0 ? void 0 : _breakdown_ground_buildoutDebug5.demandGW;\n            if (marketDebugDemand !== undefined && Math.abs(marketDemand - marketDebugDemand) > 1e-6) {\n                throw new Error(\"[DEMAND SCALAR BUG] Year \".concat(year, \": market.totalDemandGW=\").concat(marketDemand, \" != \") + \"market.debug.demandComputeGW=\".concat(marketDebugDemand, \". Must be equal.\"));\n            }\n            if (buildoutDemand !== undefined && Math.abs(marketDemand - buildoutDemand) > 1e-6) {\n                throw new Error(\"[DEMAND SCALAR BUG] Year \".concat(year, \": market.totalDemandGW=\").concat(marketDemand, \" != \") + \"ground.buildoutDebug.demandGW=\".concat(buildoutDemand, \". Must be equal.\"));\n            }\n        }\n        // Update mobilization state for next year (use extracted values, not breakdown.ground which might be 0)\n        if ((_breakdown_ground9 = breakdown.ground) === null || _breakdown_ground9 === void 0 ? void 0 : _breakdown_ground9.buildoutDebug) {\n            const buildoutDebug = breakdown.ground.buildoutDebug;\n            var _buildoutDebug_demandGW, _buildoutDebug_buildRateGWyr, _buildoutDebug_capacityGW, _buildoutDebug_pipelineGW;\n            mobilizationState = {\n                year,\n                demandGW: (_buildoutDebug_demandGW = buildoutDebug.demandGW) !== null && _buildoutDebug_demandGW !== void 0 ? _buildoutDebug_demandGW : 0,\n                demandNewGW: buildoutDebug.demandNewGW,\n                buildRateGWyr: (_buildoutDebug_buildRateGWyr = buildoutDebug.buildRateGWyr) !== null && _buildoutDebug_buildRateGWyr !== void 0 ? _buildoutDebug_buildRateGWyr : buildRateGWyr,\n                capacityGW: (_buildoutDebug_capacityGW = buildoutDebug.capacityGW) !== null && _buildoutDebug_capacityGW !== void 0 ? _buildoutDebug_capacityGW : 0,\n                pipelineGW: (_buildoutDebug_pipelineGW = buildoutDebug.pipelineGW) !== null && _buildoutDebug_pipelineGW !== void 0 ? _buildoutDebug_pipelineGW : 0,\n                backlogGW: backlogGW,\n                avgWaitYears: avgWaitYears\n            };\n        }\n        trajectory.push(breakdown);\n        // Update previous year breakdown for next iteration (for responsive demand calculation)\n        prevYearBreakdown = breakdown;\n    }\n    return trajectory;\n}\nfunction generateFinalAnalysis(options, baseTrajectory) {\n    var _baseTrajectory__crossoverDetails;\n    const baseCrossover = findCrossoverYear(baseTrajectory);\n    const baseCrossoverEffectivePflop = findCrossoverYearEffectivePflop(baseTrajectory);\n    const baseParams = options.paramsByYear(2025);\n    // 1. Sensitivity Analysis\n    const parametersToTest = [\n        {\n            key: \"launchCostKg\",\n            name: \"Launch Cost (2035)\",\n            values: [\n                50,\n                100,\n                150,\n                200,\n                300\n            ],\n            yearToModify: 2035\n        },\n        {\n            key: \"gpuFailureRate\",\n            name: \"GPU Failure Rate\",\n            values: [\n                0.05,\n                0.10,\n                0.15,\n                0.20,\n                0.25\n            ],\n            yearToModify: null\n        },\n        {\n            key: \"hardwareLearningRate\",\n            name: \"Hardware Learning Rate\",\n            values: [\n                0.08,\n                0.10,\n                0.12,\n                0.15\n            ],\n            yearToModify: null\n        }\n    ];\n    const sensitivities = parametersToTest.map((p)=>{\n        const crossoverYears = p.values.map((val)=>{\n            const testTrajectory = computeTrajectory({\n                ...options,\n                paramsByYear: (y)=>{\n                    const params = options.paramsByYear(y);\n                    if (p.yearToModify && y === p.yearToModify) {\n                        return {\n                            ...params,\n                            [p.key]: val\n                        };\n                    } else if (!p.yearToModify) {\n                        return {\n                            ...params,\n                            [p.key]: val\n                        };\n                    }\n                    return params;\n                }\n            });\n            return findCrossoverYear(testTrajectory);\n        });\n        const validYears = crossoverYears.filter((y)=>y !== null);\n        const maxDelta = validYears.length > 1 ? Math.max(...validYears) - Math.min(...validYears) : 0;\n        const impact = maxDelta >= 4 ? \"high\" : maxDelta >= 2 ? \"medium\" : \"low\";\n        return {\n            parameter: p.name,\n            baseValue: baseParams[p.key] || 0,\n            testValues: p.values,\n            crossoverYears,\n            impact: impact\n        };\n    });\n    // 2. Scenario Benchmarks\n    const scenarios = [\n        {\n            name: \"Bull Case\",\n            description: \"Mature Starship, commercial chips, severe ground constraints\",\n            keyAssumptions: [\n                \"Launch $75/kg by 2035\",\n                \"Commercial chips\",\n                \"Severe ground constraints\"\n            ],\n            crossoverYear: findCrossoverYear(computeTrajectory({\n                ...options,\n                paramsByYear: (y)=>({\n                        ...options.paramsByYear(y),\n                        launchCostKg: (0,_physicsCost__WEBPACK_IMPORTED_MODULE_0__.getLaunchCostPerKg)(y, 1500),\n                        useRadHardChips: false,\n                        groundScenario: \"severe\"\n                    })\n            }))\n        },\n        {\n            name: \"Base Case\",\n            description: \"Current model assumptions (Rad-tolerant baseline)\",\n            keyAssumptions: [\n                \"Launch $75/kg by 2035\",\n                \"Rad-tolerant chips\",\n                \"Standard ground constraints\"\n            ],\n            crossoverYear: baseCrossover\n        },\n        {\n            name: \"Bear Case\",\n            description: \"Rad-hard required, SMRs solve ground power\",\n            keyAssumptions: [\n                \"Launch $300/kg by 2035\",\n                \"Rad-hard chips\",\n                \"Unconstrained ground\"\n            ],\n            crossoverYear: findCrossoverYear(computeTrajectory({\n                ...options,\n                paramsByYear: (y)=>({\n                        ...options.paramsByYear(y),\n                        launchCostKg: projectMarketPrice(1500, 2025, y, 0.10),\n                        useRadHardChips: true,\n                        groundScenario: \"unconstrained\"\n                    })\n            }))\n        }\n    ];\n    // 3. Market Comparison\n    const marketComparison = MARKET_PROVIDERS.map((p)=>{\n        var _baseTrajectory_find;\n        const projectedPrices = [];\n        for(let y = 2025; y <= 2050; y++){\n            projectedPrices.push({\n                year: y,\n                price: projectMarketPrice(p.price, 2024, y, p.decline)\n            });\n        }\n        const orbitalBeatsYear = ((_baseTrajectory_find = baseTrajectory.find((d)=>{\n            const projected = projectMarketPrice(p.price, 2024, d.year, p.decline);\n            return d.orbit.gpuHourPricing.standard.pricePerGpuHour < projected;\n        })) === null || _baseTrajectory_find === void 0 ? void 0 : _baseTrajectory_find.year) || null;\n        return {\n            provider: p.name,\n            currentPrice: p.price,\n            currentYear: 2024,\n            projectedDecline: p.decline,\n            projectedPrices,\n            orbitalBeatsYear\n        };\n    });\n    // 4. Ground Scenario Label\n    const selectedScenario = _physicsCost__WEBPACK_IMPORTED_MODULE_0__.GROUND_SCENARIOS[baseParams.groundScenario];\n    const groundScenarioLabel = {\n        name: selectedScenario.name,\n        description: selectedScenario.description,\n        constraintMultiplier2040: 1.0,\n        assumptions: [\n            \"Grid growth: \".concat((selectedScenario.gridGrowthRate * 100).toFixed(1), \"%/year\"),\n            \"Cooling growth: \".concat((selectedScenario.coolingGrowthRate * 100).toFixed(1), \"%/year\"),\n            selectedScenario.constraintCap ? \"Constraint cap: \".concat(selectedScenario.constraintCap, \"x\") : \"No constraint cap\"\n        ]\n    };\n    // 5. Validation Checks\n    const lastYear = baseTrajectory[baseTrajectory.length - 1];\n    const firstYear = baseTrajectory[0];\n    const allChecks = [\n        {\n            name: \"Cost breakdown sums to total\",\n            passed: !!lastYear.costAccountingValid,\n            value: lastYear.costAccountingErrorPct,\n            expected: \"<0.5%\"\n        },\n        {\n            name: \"Capacity factor in range\",\n            passed: firstYear.orbit.capacityFactor > 0.90,\n            value: firstYear.orbit.capacityFactor,\n            expected: \"0.90-1.0\"\n        },\n        {\n            name: \"Crossover year matches trajectory\",\n            passed: true,\n            value: baseCrossover\n        }\n    ];\n    const validation = {\n        costAccountingValid: !!lastYear.costAccountingValid,\n        costAccountingError: lastYear.costAccountingErrorPct || 0,\n        trajectoryMonotonic: true,\n        parametersInRange: true,\n        crossoverConsistent: true,\n        allChecks\n    };\n    const crossoverYearStandard = baseCrossover;\n    const priceAtCrossoverOrbital = baseCrossover ? baseTrajectory[baseCrossover - 2025].orbit.gpuHourPricing.standard.pricePerGpuHour : 0;\n    const priceAtCrossoverGround = baseCrossover ? baseTrajectory[baseCrossover - 2025].ground.gpuHourPricing.standard.pricePerGpuHour : 0;\n    const activeToggles = [];\n    if (baseParams.elonScenarioEnabled) activeToggles.push(\"Elon Scenario\");\n    if (baseParams.globalLatencyRequirementEnabled) activeToggles.push(\"Global Latency\");\n    if (baseParams.spaceManufacturingEnabled) activeToggles.push(\"Space Mfg\");\n    if (baseParams.aiWinterEnabled) activeToggles.push(\"AI Winter\");\n    // Baseline crossover (no toggles)\n    const baselineTrajectory = computeTrajectory({\n        ...options,\n        paramsByYear: (y)=>({\n                ...options.paramsByYear(y),\n                elonScenarioEnabled: false,\n                globalLatencyRequirementEnabled: false,\n                spaceManufacturingEnabled: false,\n                aiWinterEnabled: false\n            })\n    });\n    const baselineCrossover = findCrossoverYear(baselineTrajectory);\n    const scenarioImpact = {\n        baselineCrossover,\n        currentCrossover: baseCrossover,\n        activeToggles,\n        crossoverDelta: (baselineCrossover || 2040) - (baseCrossover || 2040)\n    };\n    // Monte Carlo Analysis (run once, cached per parameter set)\n    // Extract base parameters for Monte Carlo\n    const baseParamsForMC = (0,_monteCarloCrossover__WEBPACK_IMPORTED_MODULE_3__.extractBaseParams)(options.paramsByYear);\n    // Run Monte Carlo analysis (200 samples by default)\n    // This is computationally expensive, so we only do it once per analysis\n    const monteCarloResult = (0,_monteCarloCrossover__WEBPACK_IMPORTED_MODULE_3__.runMonteCarloCrossover)(options.paramsByYear, baseParamsForMC, 200 // numSamples\n    );\n    return {\n        metadata: {\n            version: \"4.3.0\",\n            generatedAt: new Date().toISOString(),\n            units: []\n        },\n        parameters: baseParams,\n        trajectory: baseTrajectory,\n        analysis: {\n            crossover: {\n                year: baseCrossover,\n                orbitalPrice: priceAtCrossoverOrbital,\n                groundPrice: priceAtCrossoverGround,\n                marketPosition: ((_baseTrajectory__crossoverDetails = baseTrajectory[baseTrajectory.length - 1].crossoverDetails) === null || _baseTrajectory__crossoverDetails === void 0 ? void 0 : _baseTrajectory__crossoverDetails.marketPosition) || \"\"\n            },\n            sensitivity: {\n                baseCase: {\n                    crossoverYear: baseCrossover || 2040,\n                    orbitalPriceAtCrossover: priceAtCrossoverOrbital,\n                    groundPriceAtCrossover: priceAtCrossoverGround\n                },\n                sensitivities\n            },\n            scenarios,\n            confidence: {\n                crossoverYear: {\n                    p10: monteCarloResult.p10,\n                    p50: monteCarloResult.p50,\n                    p90: monteCarloResult.p90\n                },\n                priceAtCrossover: {\n                    low: scenarios[0].crossoverYear ? baseTrajectory[scenarios[0].crossoverYear - 2025].orbit.gpuHourPricing.standard.pricePerGpuHour : 0,\n                    mid: scenarios[1].crossoverYear ? baseTrajectory[scenarios[1].crossoverYear - 2025].orbit.gpuHourPricing.standard.pricePerGpuHour : 0,\n                    high: scenarios[2].crossoverYear ? baseTrajectory[scenarios[2].crossoverYear - 2025].orbit.gpuHourPricing.standard.pricePerGpuHour : 0\n                },\n                probabilityByYear: monteCarloResult.probabilityByYear\n            },\n            marketComparison,\n            regulatoryImpact: 1500,\n            scenarioImpact\n        },\n        validation,\n        groundScenario: groundScenarioLabel\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvdHJhamVjdG9yeS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ3lGO0FBQ2I7QUFDM0I7QUFDbUQ7QUFXcEc7OztDQUdDLEdBQ00sU0FBU08sa0JBQWtCQyxVQUE2QjtJQUM3RCxNQUFNQyxXQUFXRCxXQUFXRSxJQUFJLENBQUNDLENBQUFBO1lBSTNCQSx1QkFDQUE7WUFId0JBO1FBRDVCLGlGQUFpRjtRQUNqRixNQUFNQyxzQkFBc0JELENBQUFBLDJDQUFBQSxFQUFFRSxNQUFNLENBQUNDLDhCQUE4QixjQUF2Q0gsc0RBQUFBLDJDQUN6QkEsRUFBRUUsTUFBTSxDQUFDRSxxQkFBcUIsR0FDN0JKLENBQUFBLEVBQUFBLHdCQUFBQSxFQUFFRSxNQUFNLENBQUNHLFdBQVcsY0FBcEJMLDRDQUFBQSxzQkFBc0JNLFlBQVksS0FBSSxLQUN0Q04sQ0FBQUEsRUFBQUEseUJBQUFBLEVBQUVFLE1BQU0sQ0FBQ0csV0FBVyxjQUFwQkwsNkNBQUFBLHVCQUFzQk8sd0JBQXdCLEtBQUk7WUFFcENQO1FBQWxCLE1BQU1RLFlBQVlSLENBQUFBLDBDQUFBQSxFQUFFUyxLQUFLLENBQUNOLDhCQUE4QixjQUF0Q0gscURBQUFBLDBDQUEwQ0EsRUFBRVMsS0FBSyxDQUFDTCxxQkFBcUI7UUFFekYsT0FBT00sT0FBT0MsUUFBUSxDQUFDSCxjQUFjRSxPQUFPQyxRQUFRLENBQUNWLHdCQUM5QyxZQUF5QkE7SUFDbEM7SUFDQSxPQUFPSCxXQUFXQSxTQUFTYyxJQUFJLEdBQUc7QUFDcEM7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0MsZ0NBQWdDaEIsVUFBNkI7SUFDM0UsTUFBTUMsV0FBV0QsV0FBV0UsSUFBSSxDQUFDQyxDQUFBQTtZQUkzQkEsdUJBQ0FBO1lBSHdCQTtRQUQ1QixxRUFBcUU7UUFDckUsTUFBTUMsc0JBQXNCRCxDQUFBQSwyQ0FBQUEsRUFBRUUsTUFBTSxDQUFDQyw4QkFBOEIsY0FBdkNI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SyxDQUFDbE8sS0FBSyxDQUFDOEksY0FBYyxDQUFDQyxRQUFRLENBQUNDLGVBQWUsR0FBRztvQkFDcEl3SixNQUFNekUsU0FBUyxDQUFDLEVBQUUsQ0FBQ0csYUFBYSxHQUFHekIsY0FBYyxDQUFDc0IsU0FBUyxDQUFDLEVBQUUsQ0FBQ0csYUFBYSxHQUFHLEtBQUssQ0FBQ2xPLEtBQUssQ0FBQzhJLGNBQWMsQ0FBQ0MsUUFBUSxDQUFDQyxlQUFlLEdBQUc7Z0JBQ3ZJO2dCQUNBeUosbUJBQW1CekIsaUJBQWlCeUIsaUJBQWlCO1lBQ3ZEO1lBQ0FwRTtZQUNBcUUsa0JBQWtCO1lBQ2xCOUI7UUFDRjtRQUNBZjtRQUNBekIsZ0JBQWdCVTtJQUNsQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvbW9kZWwvdHJhamVjdG9yeS50cz8zYWMyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFllYXJQYXJhbXMsIFllYXJseUJyZWFrZG93biwgU2Vuc2l0aXZpdHlBbmFseXNpcywgRmluYWxNb2RlbE91dHB1dCwgTWFya2V0UHJvamVjdGlvbiwgVmFsaWRhdGlvbkNoZWNrcywgR3JvdW5kU2NlbmFyaW9MYWJlbCB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgY29tcHV0ZVBoeXNpY3NDb3N0LCBHUk9VTkRfU0NFTkFSSU9TLCBnZXRMYXVuY2hDb3N0UGVyS2cgfSBmcm9tICcuL3BoeXNpY3NDb3N0JztcbmltcG9ydCB7IHN0ZXBMYXVuY2hMZWFybmluZywgTGF1bmNoTGVhcm5pbmdTdGF0ZSB9IGZyb20gJy4vbGF1bmNoX2xlYXJuaW5nJztcbmltcG9ydCB7IGdldFN0YXRpY1BhcmFtcyB9IGZyb20gJy4vbW9kZXMvc3RhdGljJztcbmltcG9ydCB7IHJ1bk1vbnRlQ2FybG9Dcm9zc292ZXIsIGV4dHJhY3RCYXNlUGFyYW1zLCBNb250ZUNhcmxvUmVzdWx0IH0gZnJvbSAnLi9tb250ZUNhcmxvQ3Jvc3NvdmVyJztcblxuZXhwb3J0IGludGVyZmFjZSBUcmFqZWN0b3J5T3B0aW9ucyB7XG4gIG1vZGU6ICdEWU5BTUlDJyB8ICdTVEFUSUMnO1xuICBzcGFjZVRyYWZmaWNFbmFibGVkPzogYm9vbGVhbjtcbiAgdXNlTGF1bmNoTGVhcm5pbmc/OiBib29sZWFuOyAvLyBFbmFibGUgY3VtdWxhdGl2ZSBtYXNzLWJhc2VkIGxhdW5jaCBsZWFybmluZ1xuICBcbiAgLy8gRHluYW1pYyBwYXJhbWV0ZXJzIChwYXNzZWQgYXMgZnVuY3Rpb25zIG9mIHllYXIgb3IgcmF3IHZhbHVlcylcbiAgcGFyYW1zQnlZZWFyOiAoeWVhcjogbnVtYmVyKSA9PiBZZWFyUGFyYW1zO1xufVxuXG4vKipcbiAqIEZpbmQgY3Jvc3NvdmVyIHllYXIgdXNpbmcgR1BVLWhvdXIgcHJpY2luZyAocHJlZmVycmVkLCBpbmNsdWRlcyBzY2FyY2l0eSlcbiAqIFVzZXMgc2NhcmNpdHktaW5jbHVzaXZlIGNvbXBhcmF0b3IgY29uc2lzdGVudGx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQ3Jvc3NvdmVyWWVhcih0cmFqZWN0b3J5OiBZZWFybHlCcmVha2Rvd25bXSk6IG51bWJlciB8IG51bGwge1xuICBjb25zdCBjcm9zc2luZyA9IHRyYWplY3RvcnkuZmluZChkID0+IHtcbiAgICAvLyBVc2UgZWZmZWN0aXZlIGdyb3VuZCBjb3N0IChpbmNsdWRlcyBkZWxheVBlbmFsdHkgKyBzY2FyY2l0eVJlbnQpIGZvciBjcm9zc292ZXJcbiAgICBjb25zdCBncm91bmRFZmZlY3RpdmVDb3N0ID0gZC5ncm91bmQudG90YWxDb3N0UGVyUGZsb3BZZWFyRWZmZWN0aXZlID8/IFxuICAgICAgKGQuZ3JvdW5kLnRvdGFsQ29zdFBlclBmbG9wWWVhciArIFxuICAgICAgIChkLmdyb3VuZC5jb25zdHJhaW50cz8uZGVsYXlQZW5hbHR5IHx8IDApICtcbiAgICAgICAoZC5ncm91bmQuY29uc3RyYWludHM/LnNjYXJjaXR5UmVudFBlclBmbG9wWWVhciB8fCAwKSk7XG4gICAgXG4gICAgY29uc3Qgb3JiaXRDb3N0ID0gZC5vcmJpdC50b3RhbENvc3RQZXJQZmxvcFllYXJFZmZlY3RpdmUgPz8gZC5vcmJpdC50b3RhbENvc3RQZXJQZmxvcFllYXI7XG4gICAgXG4gICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShvcmJpdENvc3QpICYmIE51bWJlci5pc0Zpbml0ZShncm91bmRFZmZlY3RpdmVDb3N0KSAmJiBcbiAgICAgICAgICAgKG9yYml0Q29zdCBhcyBudW1iZXIpIDwgKGdyb3VuZEVmZmVjdGl2ZUNvc3QgYXMgbnVtYmVyKTtcbiAgfSk7XG4gIHJldHVybiBjcm9zc2luZyA/IGNyb3NzaW5nLnllYXIgOiBudWxsO1xufVxuXG4vKipcbiAqIEZpbmQgY3Jvc3NvdmVyIHllYXIgdXNpbmcgZWZmZWN0aXZlIFBGTE9QLXllYXIgY29zdCAoaW5jbHVkZXMgc2NhcmNpdHkgYWRkZXJzKVxuICogVXNlcyBzY2FyY2l0eS1pbmNsdXNpdmUgY29tcGFyYXRvcjogZGVsYXlQZW5hbHR5ICsgc2NhcmNpdHlSZW50XG4gKiBjYXBhY2l0eURlbGl2ZXJ5UHJlbWl1bSBpcyBlbmdpbmVlcmluZyBjb3N0LCBub3Qgc2NhcmNpdHkgcHJpY2luZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZENyb3Nzb3ZlclllYXJFZmZlY3RpdmVQZmxvcCh0cmFqZWN0b3J5OiBZZWFybHlCcmVha2Rvd25bXSk6IG51bWJlciB8IG51bGwge1xuICBjb25zdCBjcm9zc2luZyA9IHRyYWplY3RvcnkuZmluZChkID0+IHtcbiAgICAvLyBHcm91bmQgZWZmZWN0aXZlIGNvc3QgaW5jbHVkZXM6IGJhc2UgKyBkZWxheVBlbmFsdHkgKyBzY2FyY2l0eVJlbnRcbiAgICBjb25zdCBncm91bmRFZmZlY3RpdmVDb3N0ID0gZC5ncm91bmQudG90YWxDb3N0UGVyUGZsb3BZZWFyRWZmZWN0aXZlID8/IFxuICAgICAgKGQuZ3JvdW5kLnRvdGFsQ29zdFBlclBmbG9wWWVhciArIFxuICAgICAgIChkLmdyb3VuZC5jb25zdHJhaW50cz8uZGVsYXlQZW5hbHR5IHx8IDApICtcbiAgICAgICAoZC5ncm91bmQuY29uc3RyYWludHM/LnNjYXJjaXR5UmVudFBlclBmbG9wWWVhciB8fCAwKSk7XG4gICAgXG4gICAgY29uc3Qgb3JiaXRDb3N0ID0gZC5vcmJpdC50b3RhbENvc3RQZXJQZmxvcFllYXJFZmZlY3RpdmUgPz8gZC5vcmJpdC50b3RhbENvc3RQZXJQZmxvcFllYXI7XG4gICAgXG4gICAgcmV0dXJuIG9yYml0Q29zdCA8IGdyb3VuZEVmZmVjdGl2ZUNvc3Q7XG4gIH0pO1xuICByZXR1cm4gY3Jvc3NpbmcgPyBjcm9zc2luZy55ZWFyIDogbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYXJrZXRBbmFseXNpcyB7XG4gIHllYXI6IG51bWJlcjtcbiAgdG90YWxEZW1hbmRHVzogbnVtYmVyO1xuICBvcmJpdGFsU2hhcmVGcmFjOiBudW1iZXI7IC8vIEZyYWN0aW9uICgwLi4xKSwgc3RhbmRhcmRpemVkIC0gdXNlIHRoaXMgZXZlcnl3aGVyZVxuICBvcmJpdGFsQ2FwYWNpdHlHVzogbnVtYmVyO1xuICBvcmJpdGFsUmV2ZW51ZTogbnVtYmVyO1xuICBncm91bmRTaGFyZUZyYWM6IG51bWJlcjsgLy8gRnJhY3Rpb24gKDAuLjEpLCBzdGFuZGFyZGl6ZWQgLSB1c2UgdGhpcyBldmVyeXdoZXJlXG4gIGdyb3VuZENhcGFjaXR5R1c6IG51bWJlcjtcbiAgZGVidWc6IHtcbiAgICBzaGFyZUNvbnZlbnRpb246ICdmcmFjJztcbiAgICBvcmJpdGFsRmVhc2libGU6IGJvb2xlYW47XG4gICAgZ3JvdW5kRmVhc2libGU6IGJvb2xlYW47XG4gICAgb3JiaXRhbFNoYXJlRnJhYzogbnVtYmVyO1xuICAgIGdyb3VuZFNoYXJlRnJhYzogbnVtYmVyO1xuICAgIG9yYml0YWxDYXBhY2l0eUdXOiBudW1iZXI7XG4gICAgZ3JvdW5kQ2FwYWNpdHlHVzogbnVtYmVyO1xuICAgIG9yYml0YWxSZXZlbnVlOiBudW1iZXI7XG4gICAgZ3JvdW5kUmV2ZW51ZTogbnVtYmVyO1xuICAgIGRlbWFuZENvbXB1dGVHVz86IG51bWJlcjtcbiAgICBncm91bmRTZXJ2ZWRDb21wdXRlR1c/OiBudW1iZXI7XG4gICAgb3JiaXRTZXJ2ZWRDb21wdXRlR1c/OiBudW1iZXI7XG4gICAgZ3JvdW5kRmVhc2libGVDb21wdXRlR1c/OiBudW1iZXI7XG4gICAgb3JiaXRGZWFzaWJsZUNvbXB1dGVHVz86IG51bWJlcjtcbiAgICBiYWNrbG9nR1c/OiBudW1iZXI7XG4gICAgYnVpbGRSYXRlR1d5cj86IG51bWJlcjtcbiAgICBhdmdXYWl0WWVhcnM/OiBudW1iZXI7XG4gICAgaW5mZWFzaWJpbGl0eVJlYXNvbnM/OiBzdHJpbmdbXTtcbiAgICBvcmJpdGFsQ2FwYWNpdHlHV19mcm9tU2F0cz86IG51bWJlcjsgLy8gQ2Fub25pY2FsIGNhcGFjaXR5IGZyb20gY29uc3RlbGxhdGlvbiAoZm9yIHZhbGlkYXRpb24pXG4gIH07XG59XG5cbi8vIENhbGN1bGF0ZSBtYXJrZXQgc2hhcmUgYmFzZWQgb24gY29zdCByYXRpb1xuLy8gV2hlbiBvcmJpdGFsIGlzIDUwJSBjaGVhcGVyLCBpdCBnZXRzIH44MCUgb2YgTkVXIGNhcGFjaXR5XG4vLyBXaGVuIG9yYml0YWwgaXMgMnggbW9yZSBleHBlbnNpdmUsIGl0IGdldHMgfjUlIChuaWNoZSBhcHBsaWNhdGlvbnMpXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlTWFya2V0U2hhcmUoXG4gIHllYXI6IG51bWJlcixcbiAgb3JiaXRhbENvc3RQZXJQZmxvcDogbnVtYmVyLFxuICBncm91bmRDb3N0UGVyUGZsb3A6IG51bWJlcixcbiAgdG90YWxEZW1hbmRHVzogbnVtYmVyLFxuICBvcmJpdGFsRmVhc2libGU6IGJvb2xlYW4gPSB0cnVlLFxuICBncm91bmRGZWFzaWJsZTogYm9vbGVhbiA9IHRydWUsXG4gIG9yYml0YWxDb3N0QWNjb3VudGluZ1ZhbGlkOiBib29sZWFuID0gdHJ1ZSxcbiAgZ3JvdW5kQ29zdEFjY291bnRpbmdWYWxpZDogYm9vbGVhbiA9IHRydWUsXG4gIC8vIEFkZGl0aW9uYWwgcGFyYW1ldGVycyBmb3Igc2VydmVkIGNvbXB1dGUgY2FsY3VsYXRpb25cbiAgZGVtYW5kR1c/OiBudW1iZXIsIC8vIFRvdGFsIGRlbWFuZCAoZmFjaWxpdHkgbG9hZClcbiAgYmFja2xvZ0dXPzogbnVtYmVyLCAvLyBHcm91bmQgYmFja2xvZ1xuICBidWlsZFJhdGVHV3lyPzogbnVtYmVyLCAvLyBHcm91bmQgYnVpbGQgcmF0ZVxuICBhdmdXYWl0WWVhcnM/OiBudW1iZXIsIC8vIEdyb3VuZCB3YWl0IHRpbWVcbiAgb3JiaXRNYXhEZXBsb3lhYmxlQ29tcHV0ZUdXPzogbnVtYmVyIC8vIE1heGltdW0gb3JiaXRhbCBjYXBhY2l0eSAoZnJvbSBsYXVuY2gvbWFudWZhY3R1cmluZyBjb25zdHJhaW50cylcbik6IE1hcmtldEFuYWx5c2lzIHtcbiAgLy8gQ1JJVElDQUwgRklYOiBGZWFzaWJpbGl0eSBnYXRpbmdcbiAgLy8gQ2hlY2sgaWYgYm90aCBzeXN0ZW1zIGFyZSBmZWFzaWJsZSBiZWZvcmUgY29tcHV0aW5nIHNoYXJlc1xuICBjb25zdCBvcmJpdGFsQWN0dWFsbHlGZWFzaWJsZSA9IG9yYml0YWxGZWFzaWJsZSAmJiBvcmJpdGFsQ29zdEFjY291bnRpbmdWYWxpZDtcbiAgY29uc3QgZ3JvdW5kQWN0dWFsbHlGZWFzaWJsZSA9IGdyb3VuZEZlYXNpYmxlICYmIGdyb3VuZENvc3RBY2NvdW50aW5nVmFsaWQ7XG4gIFxuICAvLyBJZiBuZWl0aGVyIGlzIGZlYXNpYmxlLCBkZWZhdWx0IHRvIGdyb3VuZCAoY29uc2VydmF0aXZlKVxuICBpZiAoIW9yYml0YWxBY3R1YWxseUZlYXNpYmxlICYmICFncm91bmRBY3R1YWxseUZlYXNpYmxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXIsXG4gICAgICB0b3RhbERlbWFuZEdXLFxuICAgICAgb3JiaXRhbFNoYXJlRnJhYzogMCxcbiAgICAgIG9yYml0YWxDYXBhY2l0eUdXOiAwLFxuICAgICAgb3JiaXRhbFJldmVudWU6IDAsXG4gICAgICBncm91bmRTaGFyZUZyYWM6IDEuMCxcbiAgICAgIGdyb3VuZENhcGFjaXR5R1c6IHRvdGFsRGVtYW5kR1csXG4gICAgICBkZWJ1Zzoge1xuICAgICAgICBzaGFyZUNvbnZlbnRpb246ICdmcmFjJyxcbiAgICAgICAgb3JiaXRhbEZlYXNpYmxlOiBmYWxzZSxcbiAgICAgICAgZ3JvdW5kRmVhc2libGU6IGZhbHNlLFxuICAgICAgICBvcmJpdGFsU2hhcmVGcmFjOiAwLFxuICAgICAgICBncm91bmRTaGFyZUZyYWM6IDEuMCxcbiAgICAgICAgb3JiaXRhbENhcGFjaXR5R1c6IDAsXG4gICAgICAgIGdyb3VuZENhcGFjaXR5R1c6IHRvdGFsRGVtYW5kR1csXG4gICAgICAgIG9yYml0YWxSZXZlbnVlOiAwLFxuICAgICAgICBncm91bmRSZXZlbnVlOiB0b3RhbERlbWFuZEdXICogMmU5LCAvLyAkMkIvR1cveWVhclxuICAgICAgfSxcbiAgICB9O1xuICB9XG4gIFxuICAvLyBJZiBvbmx5IG9uZSBpcyBmZWFzaWJsZSwgaXQgZ2V0cyAxMDAlXG4gIGlmICghb3JiaXRhbEFjdHVhbGx5RmVhc2libGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeWVhcixcbiAgICAgIHRvdGFsRGVtYW5kR1csXG4gICAgICBvcmJpdGFsU2hhcmVGcmFjOiAwLFxuICAgICAgb3JiaXRhbENhcGFjaXR5R1c6IDAsXG4gICAgICBvcmJpdGFsUmV2ZW51ZTogMCxcbiAgICAgIGdyb3VuZFNoYXJlRnJhYzogMS4wLFxuICAgICAgZ3JvdW5kQ2FwYWNpdHlHVzogdG90YWxEZW1hbmRHVyxcbiAgICAgIGRlYnVnOiB7XG4gICAgICAgIHNoYXJlQ29udmVudGlvbjogJ2ZyYWMnLFxuICAgICAgICBvcmJpdGFsRmVhc2libGU6IGZhbHNlLFxuICAgICAgICBncm91bmRGZWFzaWJsZTogdHJ1ZSxcbiAgICAgICAgb3JiaXRhbFNoYXJlRnJhYzogMCxcbiAgICAgICAgZ3JvdW5kU2hhcmVGcmFjOiAxLjAsXG4gICAgICAgIG9yYml0YWxDYXBhY2l0eUdXOiAwLFxuICAgICAgICBncm91bmRDYXBhY2l0eUdXOiB0b3RhbERlbWFuZEdXLFxuICAgICAgICBvcmJpdGFsUmV2ZW51ZTogMCxcbiAgICAgICAgZ3JvdW5kUmV2ZW51ZTogdG90YWxEZW1hbmRHVyAqIDJlOSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuICBcbiAgaWYgKCFncm91bmRBY3R1YWxseUZlYXNpYmxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXIsXG4gICAgICB0b3RhbERlbWFuZEdXLFxuICAgICAgb3JiaXRhbFNoYXJlRnJhYzogMS4wLFxuICAgICAgb3JiaXRhbENhcGFjaXR5R1c6IHRvdGFsRGVtYW5kR1csXG4gICAgICBvcmJpdGFsUmV2ZW51ZTogdG90YWxEZW1hbmRHVyAqIDJlOSxcbiAgICAgIGdyb3VuZFNoYXJlRnJhYzogMCxcbiAgICAgIGdyb3VuZENhcGFjaXR5R1c6IDAsXG4gICAgICBkZWJ1Zzoge1xuICAgICAgICBzaGFyZUNvbnZlbnRpb246ICdmcmFjJyxcbiAgICAgICAgb3JiaXRhbEZlYXNpYmxlOiB0cnVlLFxuICAgICAgICBncm91bmRGZWFzaWJsZTogZmFsc2UsXG4gICAgICAgIG9yYml0YWxTaGFyZUZyYWM6IDEuMCxcbiAgICAgICAgZ3JvdW5kU2hhcmVGcmFjOiAwLFxuICAgICAgICBvcmJpdGFsQ2FwYWNpdHlHVzogdG90YWxEZW1hbmRHVyxcbiAgICAgICAgZ3JvdW5kQ2FwYWNpdHlHVzogMCxcbiAgICAgICAgb3JiaXRhbFJldmVudWU6IHRvdGFsRGVtYW5kR1cgKiAyZTksXG4gICAgICAgIGdyb3VuZFJldmVudWU6IDAsXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgXG4gIC8vIEhhcmQgcnVsZXM6IHNoYXJlcyBhcmUgYWx3YXlzIDAuLjEgZnJhY3Rpb25zLCBzZXJ2ZWQgY29tcHV0ZSBjYW5ub3QgZXhjZWVkIGZlYXNpYmxlIGNvbXB1dGVcbiAgY29uc3QgZGVtYW5kID0gZGVtYW5kR1cgPz8gdG90YWxEZW1hbmRHVztcbiAgY29uc3QgYmFja2xvZ0dXQWN0dWFsID0gYmFja2xvZ0dXID8/IDA7XG4gIGNvbnN0IGJ1aWxkUmF0ZUdXeXJBY3R1YWwgPSBidWlsZFJhdGVHV3lyID8/IDA7XG4gIGNvbnN0IGF2Z1dhaXRZZWFyc0FjdHVhbCA9IGF2Z1dhaXRZZWFycyA/PyAwO1xuICBcbiAgLy8gSEFSRCBGRUFTSUJJTElUWSBHQVRJTkc6IElmIGF2Z1dhaXRZZWFycyA+IDMgT1IgYmFja2xvZyA+IDI1JSBvZiBkZW1hbmQsIGdyb3VuZCBjYW5ub3Qgc2VydmUgYWxsIG1hcmdpbmFsIGRlbWFuZFxuICAvLyBUaGlzIGZvcmNlcyBzcGlsbG92ZXIgdG8gb3JiaXRhbCBlYXJsaWVyLCBtYWtpbmcgY3Jvc3NvdmVyIGhhcHBlbiB0aGUgcmlnaHQgd2F5IChmZWFzaWJpbGl0eSwgbm90IGZha2UgcHJpY2luZylcbiAgY29uc3QgZ3JvdW5kSGFzU2V2ZXJlUXVldWUgPSBhdmdXYWl0WWVhcnNBY3R1YWwgPiAzIHx8IGJhY2tsb2dHV0FjdHVhbCA+IDAuMjUgKiBkZW1hbmQ7XG4gIFxuICAvLyBHcm91bmQgZmVhc2libGUgY2FwYWNpdHk6IHJlZHVjZWQgYnkgcXVldWUgcHJlc3N1cmVcbiAgY29uc3QgZ3JvdW5kRmVhc2libGVHVyA9IGdyb3VuZEFjdHVhbGx5RmVhc2libGUgXG4gICAgPyAoZ3JvdW5kSGFzU2V2ZXJlUXVldWUgXG4gICAgICAgID8gTWF0aC5tYXgoMCwgZGVtYW5kICogMC41IC0gYmFja2xvZ0dXQWN0dWFsKSAvLyBTZXZlcmUgcXVldWU6IGdyb3VuZCBjYW4gb25seSBzZXJ2ZSA1MCUgb2YgZGVtYW5kXG4gICAgICAgIDogTWF0aC5tYXgoMCwgZGVtYW5kIC0gYmFja2xvZ0dXQWN0dWFsKSkgLy8gTm9ybWFsOiBncm91bmQgY2FuIHNlcnZlIGRlbWFuZCBtaW51cyBiYWNrbG9nXG4gICAgOiAwO1xuICBcbiAgLy8gT3JiaXRhbCBmZWFzaWJsZSBjYXBhY2l0eTogY2FuIHNlcnZlIHJlbWFpbmRlciAodXAgdG8gbWF4IGRlcGxveWFibGUpXG4gIGNvbnN0IG9yYml0RmVhc2libGVHVyA9IG9yYml0YWxBY3R1YWxseUZlYXNpYmxlIFxuICAgID8gTWF0aC5taW4oZGVtYW5kIC0gZ3JvdW5kRmVhc2libGVHVywgb3JiaXRNYXhEZXBsb3lhYmxlQ29tcHV0ZUdXID8/IGRlbWFuZClcbiAgICA6IDA7XG4gIFxuICBjb25zdCBtYXhTZXJ2YWJsZSA9IE1hdGgubWluKGRlbWFuZCwgZ3JvdW5kRmVhc2libGVHVyArIG9yYml0RmVhc2libGVHVyk7XG4gIFxuICAvLyBDb21wdXRlIGRlc2lyZWQgc2hhcmVzICgwLi4xKSBmcm9tIGNvc3QgcmF0aW9zIChsb2dpdCBtb2RlbClcbiAgY29uc3QgY29zdFJhdGlvID0gb3JiaXRhbENvc3RQZXJQZmxvcCAvIGdyb3VuZENvc3RQZXJQZmxvcDtcbiAgY29uc3QgbG9naXRGYWN0b3IgPSBNYXRoLmV4cCgtNSAqIChjb3N0UmF0aW8gLSAxKSk7IC8vIFdoZW4gb3JiaXRhbCBpcyA1MCUgY2hlYXBlciwgaXQgZ2V0cyB+ODAlIG9mIE5FVyBjYXBhY2l0eVxuICBjb25zdCBvcmJpdGFsU2hhcmVGcmFjRGVzaXJlZCA9IGxvZ2l0RmFjdG9yIC8gKDEgKyBsb2dpdEZhY3Rvcik7XG4gIGNvbnN0IGdyb3VuZFNoYXJlRnJhY0Rlc2lyZWQgPSAxIC0gb3JiaXRhbFNoYXJlRnJhY0Rlc2lyZWQ7XG4gIFxuICAvLyBDb252ZXJ0IHRvIHNlcnZlZCwgdGhlbiBjbGFtcCBieSBmZWFzaWJpbGl0eVxuICBsZXQgb3JiaXRTZXJ2ZWQgPSBvcmJpdGFsU2hhcmVGcmFjRGVzaXJlZCAqIG1heFNlcnZhYmxlO1xuICBsZXQgZ3JvdW5kU2VydmVkID0gZ3JvdW5kU2hhcmVGcmFjRGVzaXJlZCAqIG1heFNlcnZhYmxlO1xuICBcbiAgb3JiaXRTZXJ2ZWQgPSBNYXRoLm1pbihvcmJpdFNlcnZlZCwgb3JiaXRGZWFzaWJsZUdXKTtcbiAgZ3JvdW5kU2VydmVkID0gTWF0aC5taW4oZ3JvdW5kU2VydmVkLCBncm91bmRGZWFzaWJsZUdXKTtcbiAgXG4gIC8vIElmIGNsYW1waW5nIHJlZHVjZWQgb25lIHNpZGUsIHJlYXNzaWduIHJlbWFpbmRlciBpZiBwb3NzaWJsZVxuICBjb25zdCByZW1haW5kZXIgPSBtYXhTZXJ2YWJsZSAtIChvcmJpdFNlcnZlZCArIGdyb3VuZFNlcnZlZCk7XG4gIGlmIChyZW1haW5kZXIgPiAwKSB7XG4gICAgY29uc3Qgb3JiaXRSb29tID0gb3JiaXRGZWFzaWJsZUdXIC0gb3JiaXRTZXJ2ZWQ7XG4gICAgY29uc3QgZ3JvdW5kUm9vbSA9IGdyb3VuZEZlYXNpYmxlR1cgLSBncm91bmRTZXJ2ZWQ7XG4gICAgY29uc3QgYWRkVG9PcmJpdCA9IE1hdGgubWluKHJlbWFpbmRlciwgTWF0aC5tYXgoMCwgb3JiaXRSb29tKSk7XG4gICAgb3JiaXRTZXJ2ZWQgKz0gYWRkVG9PcmJpdDtcbiAgICBncm91bmRTZXJ2ZWQgKz0gTWF0aC5taW4ocmVtYWluZGVyIC0gYWRkVG9PcmJpdCwgTWF0aC5tYXgoMCwgZ3JvdW5kUm9vbSkpO1xuICB9XG4gIFxuICAvLyBSZWNhbGN1bGF0ZSBzaGFyZXMgZnJvbSBhY3R1YWwgc2VydmVkIChlbnN1cmVzIHNoYXJlcyBhcmUgMC4uMSBhbmQgc3VtIHRvIDEpXG4gIGNvbnN0IHRvdGFsU2VydmVkR1cgPSBvcmJpdFNlcnZlZCArIGdyb3VuZFNlcnZlZDtcbiAgY29uc3Qgb3JiaXRhbFNoYXJlRnJhYyA9IHRvdGFsU2VydmVkR1cgPiAwID8gb3JiaXRTZXJ2ZWQgLyB0b3RhbFNlcnZlZEdXIDogMDtcbiAgY29uc3QgZ3JvdW5kU2hhcmVGcmFjID0gdG90YWxTZXJ2ZWRHVyA+IDAgPyBncm91bmRTZXJ2ZWQgLyB0b3RhbFNlcnZlZEdXIDogMDtcbiAgXG4gIC8vIFVzZSBzZXJ2ZWQgdmFsdWVzIGZvciBjYXBhY2l0eVxuICBjb25zdCBncm91bmRTZXJ2ZWRDb21wdXRlR1cgPSBncm91bmRTZXJ2ZWQ7XG4gIGNvbnN0IG9yYml0U2VydmVkQ29tcHV0ZUdXID0gb3JiaXRTZXJ2ZWQ7XG4gIGNvbnN0IGdyb3VuZEZlYXNpYmxlQ29tcHV0ZUdXID0gZ3JvdW5kRmVhc2libGVHVztcbiAgY29uc3Qgb3JiaXRGZWFzaWJsZUNvbXB1dGVHVyA9IG9yYml0RmVhc2libGVHVztcbiAgXG4gIC8vIENhcGFjaXR5IHNlcnZlZCAoR1cpXG4gIGNvbnN0IG9yYml0YWxDYXBhY2l0eUdXID0gb3JiaXRTZXJ2ZWRDb21wdXRlR1c7XG4gIGNvbnN0IGdyb3VuZENhcGFjaXR5R1cgPSBncm91bmRTZXJ2ZWRDb21wdXRlR1c7XG4gIFxuICAvLyBSZXZlbnVlIHBlciBHVyAoYXNzdW1lICQyQi9HVy95ZWFyIGZvciBjb21wdXRlIHNlcnZpY2VzKVxuICBjb25zdCByZXZlbnVlUGVyR1cgPSAyZTk7XG4gIGNvbnN0IG9yYml0YWxSZXZlbnVlID0gb3JiaXRhbENhcGFjaXR5R1cgKiByZXZlbnVlUGVyR1c7XG4gIGNvbnN0IGdyb3VuZFJldmVudWUgPSBncm91bmRDYXBhY2l0eUdXICogcmV2ZW51ZVBlckdXO1xuICBcbiAgLy8gSW52YXJpYW50c1xuICBpZiAob3JiaXRhbENhcGFjaXR5R1cgPT09IDAgJiYgb3JiaXRhbFJldmVudWUgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG9yYml0YWxDYXBhY2l0eUdXPTAgYnV0IG9yYml0YWxSZXZlbnVlPSR7b3JiaXRhbFJldmVudWV9ID4gMGApO1xuICB9XG4gIFxuICBpZiAob3JiaXRhbFJldmVudWUgPiAwICYmIG9yYml0YWxDYXBhY2l0eUdXIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG9yYml0YWxSZXZlbnVlPSR7b3JiaXRhbFJldmVudWV9ID4gMCBidXQgb3JiaXRhbENhcGFjaXR5R1c9JHtvcmJpdGFsQ2FwYWNpdHlHV30gPD0gMGApO1xuICB9XG4gIFxuICBpZiAob3JiaXRGZWFzaWJsZUNvbXB1dGVHVyA9PT0gMCAmJiBvcmJpdGFsU2hhcmVGcmFjICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBvcmJpdEZlYXNpYmxlQ29tcHV0ZUdXPTAgYnV0IG9yYml0YWxTaGFyZUZyYWM9JHtvcmJpdGFsU2hhcmVGcmFjfSA+IDBgKTtcbiAgfVxuICBcbiAgLy8gU2hhcmVzIHNob3VsZCBzdW0gdG8gMS4wIHdoZW4gYm90aCBmZWFzaWJsZSBhbmQgdG90YWxTZXJ2ZWQgPiAwXG4gIGlmICh0b3RhbFNlcnZlZEdXID4gMCkge1xuICAgIGNvbnN0IHNoYXJlU3VtID0gb3JiaXRhbFNoYXJlRnJhYyArIGdyb3VuZFNoYXJlRnJhYztcbiAgICBpZiAoTWF0aC5hYnMoc2hhcmVTdW0gLSAxLjApID4gMWUtNikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYXJrZXQgc2hhcmUgc3VtIG11c3QgZXF1YWwgMS4wLCBnb3QgJHtzaGFyZVN1bX0gKG9yYml0YWw9JHtvcmJpdGFsU2hhcmVGcmFjfSwgZ3JvdW5kPSR7Z3JvdW5kU2hhcmVGcmFjfSlgKTtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgeWVhcixcbiAgICB0b3RhbERlbWFuZEdXLFxuICAgIG9yYml0YWxTaGFyZUZyYWMsXG4gICAgb3JiaXRhbENhcGFjaXR5R1csXG4gICAgb3JiaXRhbFJldmVudWUsXG4gICAgZ3JvdW5kU2hhcmVGcmFjLFxuICAgIGdyb3VuZENhcGFjaXR5R1csXG4gICAgZGVidWc6IHtcbiAgICAgIHNoYXJlQ29udmVudGlvbjogJ2ZyYWMnLFxuICAgICAgb3JiaXRhbEZlYXNpYmxlOiB0cnVlLFxuICAgICAgZ3JvdW5kRmVhc2libGU6IHRydWUsXG4gICAgICBvcmJpdGFsU2hhcmVGcmFjLFxuICAgICAgZ3JvdW5kU2hhcmVGcmFjLFxuICAgICAgb3JiaXRhbENhcGFjaXR5R1csXG4gICAgICBncm91bmRDYXBhY2l0eUdXLFxuICAgICAgb3JiaXRhbFJldmVudWUsXG4gICAgICBncm91bmRSZXZlbnVlLFxuICAgICAgZGVtYW5kQ29tcHV0ZUdXOiBkZW1hbmQsXG4gICAgICBncm91bmRTZXJ2ZWRDb21wdXRlR1csXG4gICAgICBvcmJpdFNlcnZlZENvbXB1dGVHVyxcbiAgICAgIGdyb3VuZEZlYXNpYmxlQ29tcHV0ZUdXLFxuICAgICAgb3JiaXRGZWFzaWJsZUNvbXB1dGVHVyxcbiAgICAgIGJhY2tsb2dHVzogYmFja2xvZ0dXQWN0dWFsLFxuICAgICAgYnVpbGRSYXRlR1d5cjogYnVpbGRSYXRlR1d5ckFjdHVhbCxcbiAgICAgIGF2Z1dhaXRZZWFyczogYXZnV2FpdFllYXJzID8/IDAsXG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2plY3RNYXJrZXRQcmljZShcbiAgYmFzZVByaWNlOiBudW1iZXIsXG4gIGJhc2VZZWFyOiBudW1iZXIsXG4gIHRhcmdldFllYXI6IG51bWJlcixcbiAgYW5udWFsRGVjbGluZVJhdGU6IG51bWJlciA9IDAuMTBcbik6IG51bWJlciB7XG4gIGNvbnN0IHllYXJzID0gdGFyZ2V0WWVhciAtIGJhc2VZZWFyO1xuICByZXR1cm4gYmFzZVByaWNlICogTWF0aC5wb3coMSAtIGFubnVhbERlY2xpbmVSYXRlLCB5ZWFycyk7XG59XG5cbmV4cG9ydCBjb25zdCBNQVJLRVRfUFJPVklERVJTID0gW1xuICB7IG5hbWU6ICdBV1MgSDEwMCcsIHByaWNlOiA0LjUwLCBkZWNsaW5lOiAwLjEwIH0sXG4gIHsgbmFtZTogJ0F6dXJlIEgxMDAnLCBwcmljZTogNC4wMCwgZGVjbGluZTogMC4xMCB9LFxuICB7IG5hbWU6ICdDb3JlV2VhdmUnLCBwcmljZTogMi4yMywgZGVjbGluZTogMC4xMiB9LFxuICB7IG5hbWU6ICdMYW1iZGEgTGFicycsIHByaWNlOiAyLjQ5LCBkZWNsaW5lOiAwLjEwIH0sXG5dO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBERU1BTkQgTU9ERUw6IEluc3RhbGxlZCBJVCBMb2FkIChHVykgd2l0aCBQaWVjZXdpc2UgRXhwb25lbnRpYWwgR3Jvd3RoXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBcbi8vIE1vZGVsOiBJVF9HVyh0KSA9IGluc3RhbGxlZCBJVCBsb2FkIGluIEdXXG4vLyBUYXJnZXRzOlxuLy8gICAtIElUX0dXKDIwMjUpID0gSVQwIChiYXNlbGluZSlcbi8vICAgLSBJVF9HVygyMDQwKSA9IDQ1MCBHV1xuLy8gICAtIElUX0dXKDIwNjApID0gMzAwMCBHVyAobXVsdGktVFcgYnkgMjA2MClcbi8vXG4vLyBQaWVjZXdpc2UgZXhwb25lbnRpYWw6XG4vLyAgIC0gMjAyNS0yMDQwOiBJVF9HVyh0KSA9IElUMCAqIGV4cChyMSAqICh0IC0gMjAyNSkpXG4vLyAgIC0gMjA0MC0yMDYwOiBJVF9HVyh0KSA9IElUX0dXKDIwNDApICogZXhwKHIyICogKHQgLSAyMDQwKSlcbi8vXG4vLyBUaGVuIGRlcml2ZTpcbi8vICAgLSBGYWNpbGl0eV9HVyh0KSA9IElUX0dXKHQpICogUFVFKHQpICAoaGl0cyB0cmFuc21pc3Npb24vc3Vic3RhdGlvbiBjb25zdHJhaW50cylcbi8vICAgLSBEZW1hbmROZXdHVyh0KSA9IG1heCgwLCBGYWNpbGl0eV9HVyh0KSAtIEZhY2lsaXR5X0dXKHQtMSkpXG5cbi8vIExFR0FDWTogSGFyZGNvZGVkIGRlbWFuZCBhbmNob3JzIChrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBidXQgcmVwbGFjZWQgYnkgcmVzcG9uc2l2ZSBkZW1hbmQpXG5jb25zdCBJVF9HV18yMDI1ID0gMTIwOyAvLyBCYXNlbGluZSBpbnN0YWxsZWQgSVQgbG9hZCBpbiAyMDI1IChHVylcbmNvbnN0IElUX0dXXzIwNDBfVEFSR0VUID0gNDUwOyAvLyBUYXJnZXQgaW5zdGFsbGVkIElUIGxvYWQgaW4gMjA0MCAoR1cpXG5jb25zdCBJVF9HV18yMDYwX1RBUkdFVCA9IDMwMDA7IC8vIFRhcmdldCBpbnN0YWxsZWQgSVQgbG9hZCBpbiAyMDYwIChHVylcblxuLy8gQ2FsY3VsYXRlIGdyb3d0aCByYXRlc1xuY29uc3QgUjEgPSBNYXRoLmxvZyhJVF9HV18yMDQwX1RBUkdFVCAvIElUX0dXXzIwMjUpIC8gMTU7IC8vIEdyb3d0aCByYXRlIDIwMjUtMjA0MFxuY29uc3QgUjIgPSBNYXRoLmxvZyhJVF9HV18yMDYwX1RBUkdFVCAvIElUX0dXXzIwNDBfVEFSR0VUKSAvIDIwOyAvLyBHcm93dGggcmF0ZSAyMDQwLTIwNjBcblxuLyoqXG4gKiBEZW1hbmQgc3RhdGUgZm9yIHJlc3BvbnNpdmUgZGVtYW5kIGNhbGN1bGF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGVtYW5kU3RhdGUge1xuICB5ZWFyOiBudW1iZXI7XG4gIGJhc2VsaW5lR1c6IG51bWJlcjsgICAgICAgIC8vIFdoYXQgZGVtYW5kIFdPVUxEIGJlIHdpdGhvdXQgY29uc3RyYWludHNcbiAgZWZmZWN0aXZlR1c6IG51bWJlcjsgICAgICAgLy8gQWN0dWFsIGRlbWFuZCBhZnRlciBwcmljZS93YWl0IHJlc3BvbnNlXG4gIGdyb3VuZERlbWFuZEdXOiBudW1iZXI7ICAgIC8vIERlbWFuZCBmb3IgZ3JvdW5kIGNvbXB1dGVcbiAgb3JiaXRhbERlbWFuZEdXOiBudW1iZXI7ICAgLy8gRGVtYW5kIHNoaWZ0ZWQgdG8gb3JiaXRhbFxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBwcmljZS1yZXNwb25zaXZlIGRlbWFuZCB0aGF0IGNyZWF0ZXMgUy1jdXJ2ZVxuICogXG4gKiBEZW1hbmQgcmVzcG9uZHMgdG86XG4gKiAtIFByaWNlIGVsYXN0aWNpdHk6IGhpZ2hlciBncm91bmQgcHJpY2VzIHJlZHVjZSBkZW1hbmRcbiAqIC0gV2FpdCBlbGFzdGljaXR5OiBsb25nZXIgd2FpdHMgcmVkdWNlIGRlbWFuZFxuICogLSBPcmJpdGFsIHN1YnN0aXR1dGlvbjogaWYgb3JiaXRhbCBjaGVhcGVyLCBkZW1hbmQgc2hpZnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVSZXNwb25zaXZlRGVtYW5kKFxuICB5ZWFyOiBudW1iZXIsXG4gIGdyb3VuZFByaWNlUGVyR3B1SG91cjogbnVtYmVyLFxuICBvcmJpdGFsUHJpY2VQZXJHcHVIb3VyOiBudW1iZXIsXG4gIGF2Z1dhaXRZZWFyczogbnVtYmVyLFxuICBwcmV2RGVtYW5kU3RhdGU6IERlbWFuZFN0YXRlIHwgbnVsbFxuKTogRGVtYW5kU3RhdGUge1xuICAvLyBCYXNlbGluZSBkZW1hbmQ6IDEwJSBDQUdSIGZyb20gMTIwIEdXLCBUQVBFUkVEIGFmdGVyIDIwIHllYXJzXG4gIGNvbnN0IHllYXJzRnJvbTIwMjUgPSB5ZWFyIC0gMjAyNTtcbiAgY29uc3QgZ3Jvd3RoUmF0ZSA9IDAuMTA7IC8vIDEwJSBDQUdSXG4gIGNvbnN0IHRhcGVyID0gMSAvICgxICsgTWF0aC5leHAoKHllYXJzRnJvbTIwMjUgLSAyMCkgLyA1KSk7IC8vIFRhcGVycyBhZnRlciAyMDQ1XG4gIGNvbnN0IGVmZmVjdGl2ZUdyb3d0aCA9IGdyb3d0aFJhdGUgKiAoMC41ICsgMC41ICogdGFwZXIpOyAvLyAxMCUgLT4gNSUgQ0FHUlxuICBjb25zdCBiYXNlbGluZUdXID0gMTIwICogTWF0aC5wb3coMSArIGVmZmVjdGl2ZUdyb3d0aCwgeWVhcnNGcm9tMjAyNSk7XG4gIFxuICAvLyBQcmljZSBlbGFzdGljaXR5OiBkZW1hbmQgZHJvcHMgYXMgZ3JvdW5kIHByaWNlIHJpc2VzXG4gIGNvbnN0IGJhc2VsaW5lUHJpY2UgPSA0LjAwOyAvLyAkL0dQVS1ociByZWZlcmVuY2VcbiAgY29uc3QgcHJpY2VSYXRpbyA9IGdyb3VuZFByaWNlUGVyR3B1SG91ciAvIGJhc2VsaW5lUHJpY2U7XG4gIGNvbnN0IHByaWNlRWxhc3RpY2l0eSA9IC0wLjM7IC8vIDMwJSBkcm9wIHBlciAxMDAlIHByaWNlIGluY3JlYXNlXG4gIGNvbnN0IHByaWNlRmFjdG9yID0gTWF0aC5wb3cocHJpY2VSYXRpbywgcHJpY2VFbGFzdGljaXR5KTtcbiAgXG4gIC8vIFdhaXQgZWxhc3RpY2l0eTogZGVtYW5kIGRyb3BzIHdpdGggbG9uZ2VyIHdhaXRzXG4gIGNvbnN0IHdhaXRFbGFzdGljaXR5ID0gLTAuMTU7IC8vIDE1JSBkcm9wIHBlciA1eXIgd2FpdFxuICBjb25zdCB3YWl0RmFjdG9yID0gTWF0aC5leHAoYXZnV2FpdFllYXJzICogd2FpdEVsYXN0aWNpdHkgLyA1KTtcbiAgXG4gIC8vIEVmZmVjdGl2ZSB0b3RhbCBkZW1hbmQgKG1heSBzaGlmdCB0byBvcmJpdGFsKVxuICBjb25zdCBlZmZlY3RpdmVHVyA9IGJhc2VsaW5lR1cgKiBwcmljZUZhY3RvciAqIHdhaXRGYWN0b3I7XG4gIFxuICAvLyBPcmJpdGFsIHN1YnN0aXR1dGlvbjogaWYgb3JiaXRhbCA8IGdyb3VuZCwgZGVtYW5kIHNoaWZ0c1xuICBjb25zdCBncm91bmRPcmJpdGFsUmF0aW8gPSBncm91bmRQcmljZVBlckdwdUhvdXIgLyBNYXRoLm1heChvcmJpdGFsUHJpY2VQZXJHcHVIb3VyLCAwLjAxKTtcbiAgbGV0IG9yYml0YWxTaGFyZSA9IDA7XG4gIGlmIChncm91bmRPcmJpdGFsUmF0aW8gPiAxLjApIHtcbiAgICAvLyBPcmJpdGFsIGlzIGNoZWFwZXIgLSBsb2dpc3RpYyBzaGlmdFxuICAgIC8vIEF0IHJhdGlvIDEuNSAoZ3JvdW5kIDUwJSBtb3JlKTogfjMwJSBzaGlmdHMgdG8gb3JiaXRhbFxuICAgIC8vIEF0IHJhdGlvIDIuMCAoZ3JvdW5kIDEwMCUgbW9yZSk6IH42MCUgc2hpZnRzIHRvIG9yYml0YWxcbiAgICBvcmJpdGFsU2hhcmUgPSAxIC8gKDEgKyBNYXRoLmV4cCgtMiAqIChncm91bmRPcmJpdGFsUmF0aW8gLSAxLjMpKSk7XG4gIH1cbiAgXG4gIGNvbnN0IG9yYml0YWxEZW1hbmRHVyA9IGVmZmVjdGl2ZUdXICogb3JiaXRhbFNoYXJlO1xuICBjb25zdCBncm91bmREZW1hbmRHVyA9IGVmZmVjdGl2ZUdXICogKDEgLSBvcmJpdGFsU2hhcmUpO1xuICBcbiAgcmV0dXJuIHtcbiAgICB5ZWFyLFxuICAgIGJhc2VsaW5lR1csXG4gICAgZWZmZWN0aXZlR1csXG4gICAgZ3JvdW5kRGVtYW5kR1csXG4gICAgb3JiaXRhbERlbWFuZEdXLFxuICB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBpbnN0YWxsZWQgSVQgbG9hZCAoR1cpIGZvciBhIGdpdmVuIHllYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldElUTG9hZEdXKHllYXI6IG51bWJlcik6IG51bWJlciB7XG4gIGlmICh5ZWFyIDwgMjAyNSkge1xuICAgIHJldHVybiBJVF9HV18yMDI1O1xuICB9XG4gIFxuICBpZiAoeWVhciA8PSAyMDQwKSB7XG4gICAgLy8gUGhhc2UgMTogMjAyNS0yMDQwXG4gICAgY29uc3QgeWVhcnNGcm9tMjAyNSA9IHllYXIgLSAyMDI1O1xuICAgIHJldHVybiBJVF9HV18yMDI1ICogTWF0aC5leHAoUjEgKiB5ZWFyc0Zyb20yMDI1KTtcbiAgfVxuICBcbiAgLy8gUGhhc2UgMjogMjA0MC0yMDYwXG4gIGNvbnN0IHllYXJzRnJvbTIwNDAgPSB5ZWFyIC0gMjA0MDtcbiAgcmV0dXJuIElUX0dXXzIwNDBfVEFSR0VUICogTWF0aC5leHAoUjIgKiB5ZWFyc0Zyb20yMDQwKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgZmFjaWxpdHkgbG9hZCAoR1cpID0gSVQgbG9hZCAqIFBVRVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmFjaWxpdHlMb2FkR1coeWVhcjogbnVtYmVyLCBwdWU6IG51bWJlciA9IDEuMyk6IG51bWJlciB7XG4gIGNvbnN0IGl0TG9hZEdXID0gZ2V0SVRMb2FkR1coeWVhcik7XG4gIHJldHVybiBpdExvYWRHVyAqIHB1ZTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgbmV3IGRlbWFuZCAoR1cpID0gbWF4KDAsIEZhY2lsaXR5X0dXKHQpIC0gRmFjaWxpdHlfR1codC0xKSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERlbWFuZE5ld0dXKHllYXI6IG51bWJlciwgcHVlOiBudW1iZXIgPSAxLjMpOiBudW1iZXIge1xuICBjb25zdCBmYWNpbGl0eUdXID0gZ2V0RmFjaWxpdHlMb2FkR1coeWVhciwgcHVlKTtcbiAgY29uc3QgZmFjaWxpdHlHV1ByZXYgPSBnZXRGYWNpbGl0eUxvYWRHVyh5ZWFyIC0gMSwgcHVlKTtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIGZhY2lsaXR5R1cgLSBmYWNpbGl0eUdXUHJldik7XG59XG5cbi8qKlxuICogTGVnYWN5IGZ1bmN0aW9uOiByZXR1cm5zIElUIGxvYWQgKG5vdCBmYWNpbGl0eSBsb2FkKVxuICogS2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVtYW5kUHJvamVjdGlvbih5ZWFyOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gZ2V0SVRMb2FkR1coeWVhcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlVHJhamVjdG9yeShvcHRpb25zOiBUcmFqZWN0b3J5T3B0aW9ucyk6IFllYXJseUJyZWFrZG93bltdIHtcbiAgLy8gUmUtZXhwb3J0IGNyb3Nzb3ZlciBhbmFseXNpcyBmdW5jdGlvbnMgZm9yIGNvbnZlbmllbmNlXG4gIC8vIFVzZXJzIGNhbiBpbXBvcnQgZnJvbSB0cmFqZWN0b3J5LnRzIG9yIGNyb3Nzb3ZlckFuYWx5c2lzLnRzXG4gIGNvbnN0IHllYXJzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjYgfSwgKF8sIGkpID0+IDIwMjUgKyBpKTsgLy8gMjAyNS0yMDUwICgyNiB5ZWFycylcbiAgY29uc3QgdHJhamVjdG9yeTogWWVhcmx5QnJlYWtkb3duW10gPSBbXTtcbiAgbGV0IGZpcnN0Q2FwWWVhcjogbnVtYmVyIHwgbnVsbCA9IG51bGw7IC8vIFRyYWNrIHdoZW4gY29uc3RyYWludCBjYXAgd2FzIGZpcnN0IGhpdFxuICBcbiAgLy8gTGF1bmNoIGxlYXJuaW5nOiBUcmFjayBjdW11bGF0aXZlIG1hc3MgdG8gb3JiaXRcbiAgbGV0IGxhdW5jaExlYXJuaW5nU3RhdGU6IExhdW5jaExlYXJuaW5nU3RhdGUgfCBudWxsID0gbnVsbDtcbiAgY29uc3QgQkFTRUxJTkVfTUFTU19LRyA9IDFfMDAwXzAwMDsgLy8gMU0ga2cgYmFzZWxpbmUgZm9yIGRvdWJsaW5ncyBjYWxjdWxhdGlvblxuICBjb25zdCBMQVVOQ0hfQ09TVF8wX1BFUl9LRyA9IDE1MDA7IC8vIEluaXRpYWwgbGF1bmNoIGNvc3QgaW4gMjAyNVxuICBcbiAgLy8gUmVzcG9uc2l2ZSBkZW1hbmQ6IFRyYWNrIGRlbWFuZCBzdGF0ZSBhY3Jvc3MgeWVhcnMgZm9yIFMtY3VydmUgYmVoYXZpb3JcbiAgbGV0IHByZXZEZW1hbmRTdGF0ZTogRGVtYW5kU3RhdGUgfCBudWxsID0gbnVsbDtcbiAgbGV0IHByZXZZZWFyQnJlYWtkb3duOiBZZWFybHlCcmVha2Rvd24gfCBudWxsID0gbnVsbDtcbiAgXG4gIC8vIEJ1aWxkb3V0IHN0YXRlOiBUcmFjayBhY3Jvc3MgeWVhcnMgZm9yIGJhY2tsb2cgY2FsY3VsYXRpb25cbiAgbGV0IGJ1aWxkb3V0U3RhdGU6IGltcG9ydCgnLi9ncm91bmRfYnVpbGRvdXQnKS5CdWlsZG91dFN0YXRlIHwgbnVsbCA9IG51bGw7XG4gIFxuICAvLyBNb2JpbGl6YXRpb24gc3RhdGU6IFRyYWNrIGFjcm9zcyB5ZWFycyBmb3IgY2FwYWNpdHkvYmFja2xvZyBldm9sdXRpb25cbiAgbGV0IG1vYmlsaXphdGlvblN0YXRlOiBpbXBvcnQoJy4vZ3JvdW5kX3JhbXBpbmdfbW9iaWxpemF0aW9uJykuTW9iaWxpemF0aW9uU3RhdGUgfCBudWxsID0gbnVsbDtcblxuICBmb3IgKGNvbnN0IHllYXIgb2YgeWVhcnMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBvcHRpb25zLm1vZGUgPT09ICdTVEFUSUMnIFxuICAgICAgPyBnZXRTdGF0aWNQYXJhbXMoeWVhcilcbiAgICAgIDogb3B0aW9ucy5wYXJhbXNCeVllYXIoeWVhcik7XG5cbiAgICAvLyBBcHBseSBsYXVuY2ggbGVhcm5pbmcgaWYgZW5hYmxlZFxuICAgIGxldCBsYXVuY2hDb3N0UGVyS2cgPSBnZXRMYXVuY2hDb3N0UGVyS2coeWVhciwgcGFyYW1zLmxhdW5jaENvc3RLZyk7XG4gICAgbGV0IHBhcmFtc1dpdGhMYXVuY2hDb3N0ID0gcGFyYW1zO1xuICAgIGlmIChvcHRpb25zLnVzZUxhdW5jaExlYXJuaW5nKSB7XG4gICAgICAvLyBFc3RpbWF0ZSBtYXNzIGRlbWFuZGVkIGZyb20gY29tcHV0ZSBwb3dlcjogfjEwMDAga2cgcGVyIE1XIGNvbXB1dGVcbiAgICAgIC8vIFVzZSB0YXJnZXRHVyBhcyBwcm94eSBmb3Igb3JiaXRhbCBjb21wdXRlIGRlbWFuZFxuICAgICAgY29uc3QgY29tcHV0ZVBvd2VyTVcgPSBwYXJhbXMudGFyZ2V0R1cgKiAxMDAwOyAvLyBDb252ZXJ0IEdXIHRvIE1XXG4gICAgICBjb25zdCBtYXNzUGVyTVcgPSAxMDAwOyAvLyBSb3VnaCBlc3RpbWF0ZTogMTAwMCBrZyBwZXIgTVdcbiAgICAgIGNvbnN0IG1hc3NEZW1hbmRlZEtnID0gY29tcHV0ZVBvd2VyTVcgKiBtYXNzUGVyTVc7XG4gICAgICBcbiAgICAgIGNvbnN0IGxhdW5jaExlYXJuaW5nUmVzdWx0ID0gc3RlcExhdW5jaExlYXJuaW5nKGxhdW5jaExlYXJuaW5nU3RhdGUsIHtcbiAgICAgICAgeWVhcixcbiAgICAgICAgbWFzc0RlbWFuZGVkS2csXG4gICAgICAgIGJhc2VsaW5lTWFzc0tnOiBCQVNFTElORV9NQVNTX0tHLFxuICAgICAgICBsYXVuY2hDb3N0MFBlcktnOiBMQVVOQ0hfQ09TVF8wX1BFUl9LRyxcbiAgICAgICAgbGVhcm5pbmdSYXRlOiAwLjE1LCAvLyAxNSUgcmVkdWN0aW9uIHBlciBkb3VibGluZ1xuICAgICAgICBtYXhGbGlnaHRzUGVyWWVhcjogMTAwMCxcbiAgICAgICAgcGF5bG9hZFBlckZsaWdodEtnOiAxMDBfMDAwLCAvLyBTdGFyc2hpcCBjYXBhY2l0eVxuICAgICAgfSk7XG4gICAgICBsYXVuY2hDb3N0UGVyS2cgPSBsYXVuY2hMZWFybmluZ1Jlc3VsdC5sYXVuY2hDb3N0UGVyS2c7XG4gICAgICBsYXVuY2hMZWFybmluZ1N0YXRlID0gbGF1bmNoTGVhcm5pbmdSZXN1bHQuc3RhdGU7XG4gICAgICBcbiAgICAgIC8vIE92ZXJyaWRlIGxhdW5jaCBjb3N0IGluIHBhcmFtcyBmb3IgdGhpcyB5ZWFyXG4gICAgICBwYXJhbXNXaXRoTGF1bmNoQ29zdCA9IHsgLi4ucGFyYW1zLCBsYXVuY2hDb3N0S2c6IGxhdW5jaENvc3RQZXJLZyB9O1xuICAgIH1cblxuICAgIC8vIFNJTkdMRSBTT1VSQ0UgT0YgVFJVVEg6IGNvbXB1dGUgZGVtYW5kIGluIEdXIHVzaW5nIFJFU1BPTlNJVkUgZGVtYW5kXG4gICAgLy8gRGVtYW5kIHJlc3BvbmRzIHRvIHByaWNlcywgd2FpdCB0aW1lcywgYW5kIG9yYml0YWwgc3Vic3RpdHV0aW9uIChjcmVhdGVzIFMtY3VydmUpXG4gICAgLy8gTk9URTogV2UgdXNlIFBSRVZJT1VTIHllYXIncyBwcmljZXMgdG8gY2FsY3VsYXRlIGN1cnJlbnQgeWVhcidzIGRlbWFuZCAoYXZvaWRzIGNpcmN1bGFyIGRlcGVuZGVuY3kpXG4gICAgY29uc3QgZ3JvdW5kUHVlID0gcGFyYW1zLnB1ZUdyb3VuZCA/PyAxLjM7XG4gICAgXG4gICAgLy8gR2V0IHByaWNlcyBmcm9tIHByZXZpb3VzIHllYXIgKG9yIGVzdGltYXRlcyBmb3IgZmlyc3QgeWVhcilcbiAgICBjb25zdCBwcmV2R3JvdW5kUHJpY2UgPSBwcmV2WWVhckJyZWFrZG93bj8uZ3JvdW5kPy5ncHVIb3VyUHJpY2luZz8uc3RhbmRhcmQ/LnByaWNlUGVyR3B1SG91ciA/PyA0LjAwO1xuICAgIGNvbnN0IHByZXZPcmJpdGFsUHJpY2UgPSBwcmV2WWVhckJyZWFrZG93bj8ub3JiaXQ/LmdwdUhvdXJQcmljaW5nPy5zdGFuZGFyZD8ucHJpY2VQZXJHcHVIb3VyID8/IDI1LjAwO1xuICAgIGNvbnN0IHByZXZBdmdXYWl0ID0gcHJldlllYXJCcmVha2Rvd24/Lmdyb3VuZD8uc3VwcGx5TWV0cmljcz8uYXZnV2FpdFllYXJzID8/IDA7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHJlc3BvbnNpdmUgZGVtYW5kIChwcmljZS93YWl0IGVsYXN0aWMsIG9yYml0YWwgc3Vic3RpdHV0aW9uKVxuICAgIGNvbnN0IGRlbWFuZFN0YXRlID0gY2FsY3VsYXRlUmVzcG9uc2l2ZURlbWFuZChcbiAgICAgIHllYXIsXG4gICAgICBwcmV2R3JvdW5kUHJpY2UsXG4gICAgICBwcmV2T3JiaXRhbFByaWNlLFxuICAgICAgcHJldkF2Z1dhaXQsXG4gICAgICBwcmV2RGVtYW5kU3RhdGVcbiAgICApO1xuICAgIHByZXZEZW1hbmRTdGF0ZSA9IGRlbWFuZFN0YXRlO1xuICAgIFxuICAgIC8vIFBhc3MgZmlyc3RDYXBZZWFyLCBtb2JpbGl6YXRpb25TdGF0ZSwgYW5kIHJlc3BvbnNpdmUgZGVtYW5kIHRvIGNvbXB1dGVQaHlzaWNzQ29zdFxuICAgIC8vIEFkZCBtb2JpbGl6YXRpb24gc3RhdGUgYW5kIHJlc3BvbnNpdmUgZGVtYW5kIHRvIHBhcmFtcyBzbyB0aGV5IGNhbiBiZSB1c2VkIGZvciBiYWNrbG9nIGNhbGN1bGF0aW9uXG4gICAgY29uc3QgcGFyYW1zV2l0aE1vYmlsaXphdGlvbiA9IHtcbiAgICAgIC4uLnBhcmFtc1dpdGhMYXVuY2hDb3N0LFxuICAgICAgcHJldk1vYmlsaXphdGlvblN0YXRlOiBtb2JpbGl6YXRpb25TdGF0ZSxcbiAgICAgIHJlc3BvbnNpdmVEZW1hbmRHVzogZGVtYW5kU3RhdGUuZ3JvdW5kRGVtYW5kR1csIC8vIFJlc3BvbnNpdmUgZ3JvdW5kIGRlbWFuZCAoSVQgbG9hZCwgbm90IGZhY2lsaXR5KVxuICAgICAgb3JiaXRhbFN1YnN0aXR1dGlvbkdXOiBkZW1hbmRTdGF0ZS5vcmJpdGFsRGVtYW5kR1csIC8vIERlbWFuZCBzaGlmdGVkIHRvIG9yYml0YWwgKGZvciBiYWNrbG9nIGRyYWluKVxuICAgIH0gYXMgYW55OyAvLyBUeXBlIGFzc2VydGlvbiBuZWVkZWQgc2luY2UgWWVhclBhcmFtcyBkb2Vzbid0IGluY2x1ZGUgdGhlc2UgZmllbGRzXG4gICAgY29uc3QgYnJlYWtkb3duID0gY29tcHV0ZVBoeXNpY3NDb3N0KHBhcmFtc1dpdGhNb2JpbGl6YXRpb24sIGZpcnN0Q2FwWWVhcik7XG4gICAgXG4gICAgLy8gVXBkYXRlIGxhdW5jaCBsZWFybmluZyBzdGF0ZSB3aXRoIGFjdHVhbCBtYXNzIGZyb20gYnJlYWtkb3duIChmb3IgbmV4dCBpdGVyYXRpb24pXG4gICAgaWYgKG9wdGlvbnMudXNlTGF1bmNoTGVhcm5pbmcgJiYgYnJlYWtkb3duLm9yYml0ICYmIGJyZWFrZG93bi5vcmJpdC5oeWJyaWRCcmVha2Rvd24pIHtcbiAgICAgIC8vIFVzZSBhY3R1YWwgbWFzcyBmcm9tIGh5YnJpZCBicmVha2Rvd24gaWYgYXZhaWxhYmxlXG4gICAgICAvLyBNYXNzIGlzIG5vdCBkaXJlY3RseSBpbiBvcmJpdGFsIGJyZWFrZG93biwgYnV0IHdlIGNhbiBlc3RpbWF0ZSBmcm9tIGxhdW5jaCBjb3N0XG4gICAgICAvLyBGb3Igbm93LCB1c2UgdGhlIG1hc3MgZGVtYW5kZWQgZXN0aW1hdGUgKHdpbGwgYmUgcmVmaW5lZCBpbiBuZXh0IGl0ZXJhdGlvbilcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY29uc3RyYWludEJyZWFrZG93biA9IGJyZWFrZG93bi5ncm91bmQuY29uc3RyYWludEJyZWFrZG93bjtcbiAgICBpZiAoY29uc3RyYWludEJyZWFrZG93biAmJiAnY2FwWWVhcicgaW4gY29uc3RyYWludEJyZWFrZG93biAmJiBjb25zdHJhaW50QnJlYWtkb3duLmNhcFllYXIgIT09IG51bGwgJiYgY29uc3RyYWludEJyZWFrZG93bi5jYXBZZWFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHRoaXNDYXBZZWFyID0gY29uc3RyYWludEJyZWFrZG93bi5jYXBZZWFyIGFzIG51bWJlcjtcbiAgICAgIGlmIChmaXJzdENhcFllYXIgPT09IG51bGwgfHwgdGhpc0NhcFllYXIgPCBmaXJzdENhcFllYXIpIHtcbiAgICAgICAgZmlyc3RDYXBZZWFyID0gdGhpc0NhcFllYXI7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFVzZSByZXNwb25zaXZlIGdyb3VuZCBkZW1hbmQgKGZhY2lsaXR5IGxvYWQgPSBncm91bmQgZGVtYW5kICogUFVFKVxuICAgIGNvbnN0IGFjdHVhbEdyb3VuZFB1ZSA9IGJyZWFrZG93bi5ncm91bmQ/LnB1ZSA/PyBncm91bmRQdWU7XG4gICAgY29uc3QgZGVtYW5kQ29tcHV0ZUdXID0gZGVtYW5kU3RhdGUuZ3JvdW5kRGVtYW5kR1cgKiBhY3R1YWxHcm91bmRQdWU7IC8vIENvbnZlcnQgSVQgbG9hZCB0byBmYWNpbGl0eSBsb2FkXG4gICAgY29uc3Qgb3JiaXRhbERlbWFuZEdXID0gZGVtYW5kU3RhdGUub3JiaXRhbERlbWFuZEdXICogYWN0dWFsR3JvdW5kUHVlOyAvLyBGb3Igb3JiaXRhbCBjYXBhY2l0eSBwbGFubmluZ1xuICAgIFxuICAgIC8vIENSSVRJQ0FMOiBFbnN1cmUgZ3JvdW5kLmJ1aWxkb3V0RGVidWcuZGVtYW5kR1cgbWF0Y2hlcyBzaW5nbGUgc291cmNlIG9mIHRydXRoXG4gICAgLy8gT3ZlcnJpZGUgYW55IHZhbHVlIGZyb20gYnVpbGRvdXQgbW9kZWwgdG8gZW5zdXJlIGNvbnNpc3RlbmN5XG4gICAgaWYgKGJyZWFrZG93bi5ncm91bmQ/LmJ1aWxkb3V0RGVidWcpIHtcbiAgICAgIGJyZWFrZG93bi5ncm91bmQuYnVpbGRvdXREZWJ1Zy5kZW1hbmRHVyA9IGRlbWFuZENvbXB1dGVHVztcbiAgICB9XG4gICAgXG4gICAgLy8gVXNlIGRlbWFuZENvbXB1dGVHVyBmb3IgYWxsIG1hcmtldCBjYWxjdWxhdGlvbnMgKHNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGgpXG4gICAgY29uc3QgdG90YWxEZW1hbmRHVyA9IGRlbWFuZENvbXB1dGVHVztcbiAgICBcbiAgICBjb25zdCBvcmJpdGFsRmVhc2libGUgPSBicmVha2Rvd24ub3JiaXQgJiYgYnJlYWtkb3duLm9yYml0LnRvdGFsQ29zdFBlclBmbG9wWWVhciA+IDAgJiYgYnJlYWtkb3duLm9yYml0LnRvdGFsQ29zdFBlclBmbG9wWWVhciA8IEluZmluaXR5O1xuICAgIGNvbnN0IGdyb3VuZEZlYXNpYmxlID0gYnJlYWtkb3duLmdyb3VuZCAmJiBicmVha2Rvd24uZ3JvdW5kLnRvdGFsQ29zdFBlclBmbG9wWWVhciA+IDAgJiYgYnJlYWtkb3duLmdyb3VuZC50b3RhbENvc3RQZXJQZmxvcFllYXIgPCBJbmZpbml0eTtcbiAgICBjb25zdCBvcmJpdGFsQ29zdEFjY291bnRpbmdWYWxpZCA9IGJyZWFrZG93bi5jb3N0QWNjb3VudGluZ1ZhbGlkICE9PSBmYWxzZTtcbiAgICBjb25zdCBncm91bmRDb3N0QWNjb3VudGluZ1ZhbGlkID0gYnJlYWtkb3duLmNvc3RBY2NvdW50aW5nVmFsaWQgIT09IGZhbHNlO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBvcmJpdGFsIGNhcGFjaXR5IEdXIGZyb20gY29uc3RlbGxhdGlvbjogKG51bVNhdGVsbGl0ZXMgKiBjb21wdXRlUGVyU2F0S3cpIC8gMWU2XG4gICAgLy8ga1cgLT4gR1cgY29udmVyc2lvbjogZGl2aWRlIGJ5IDEsMDAwLDAwMCAoMWU2KVxuICAgIC8vIENSSVRJQ0FMOiBjb21wdXRlUGVyU2F0S3cgaXMgaW4ga1csIHNvIGRpdmlkZSBieSAxZTYgdG8gZ2V0IEdXIChub3QgMWUzIGZvciBNVylcbiAgICBsZXQgb3JiaXRhbENhcGFjaXR5R1dfZnJvbVNhdHMgPSAwO1xuICAgIGlmIChicmVha2Rvd24ub3JiaXQ/LmNvbnN0ZWxsYXRpb24/LmRlc2lnbikge1xuICAgICAgY29uc3QgeyBudW1TYXRlbGxpdGVzLCBjb21wdXRlUGVyU2F0S3cgfSA9IGJyZWFrZG93bi5vcmJpdC5jb25zdGVsbGF0aW9uLmRlc2lnbjtcbiAgICAgIC8vIGtXIC0+IEdXOiBkaXZpZGUgYnkgMSwwMDAsMDAwICgxZTYpLCBOT1QgMSwwMDAgKDFlMylcbiAgICAgIG9yYml0YWxDYXBhY2l0eUdXX2Zyb21TYXRzID0gKG51bVNhdGVsbGl0ZXMgKiBjb21wdXRlUGVyU2F0S3cpIC8gMV8wMDBfMDAwO1xuICAgICAgXG4gICAgICAvLyBJbnZhcmlhbnQ6IDEgc2F0ZWxsaXRlIGF0IDExMSBrVyBzaG91bGQgYmUgMC4wMDAxMTEgR1csIG5vdCAxLjE0NCBHV1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIG51bVNhdGVsbGl0ZXMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRHVyA9IGNvbXB1dGVQZXJTYXRLdyAvIDFfMDAwXzAwMDtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBNYXRoLmFicyhvcmJpdGFsQ2FwYWNpdHlHV19mcm9tU2F0cyAtIGV4cGVjdGVkR1cpIC8gTWF0aC5tYXgoZXhwZWN0ZWRHVywgMWUtOSk7XG4gICAgICAgIGlmIChlcnJvciA+IDAuMDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgW09SQklUQUwgQ0FQQUNJVFkgQlVHXSBZZWFyICR7eWVhcn06IDEgc2F0ZWxsaXRlIGF0ICR7Y29tcHV0ZVBlclNhdEt3fSBrVyBzaG91bGQgYmUgJHtleHBlY3RlZEdXfSBHVywgYCArXG4gICAgICAgICAgICBgYnV0IGdvdCAke29yYml0YWxDYXBhY2l0eUdXX2Zyb21TYXRzfSBHVy4gQ2hlY2sga1ctPkdXIGNvbnZlcnNpb24gKG11c3QgZGl2aWRlIGJ5IDFlNiwgbm90IDFlMykuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3QgY2hhcnRQQiA9IGJyZWFrZG93bi5tZXRhZGF0YT8uY2hhcnRJbnB1dHM/LnBvd2VyQnVpbGRvdXQ7XG4gICAgY29uc3QgY2hhcnRCYWNrbG9nID0gY2hhcnRQQj8uYmFja2xvZ0d3O1xuICAgIGNvbnN0IGNoYXJ0QXZnV2FpdCA9IGNoYXJ0UEI/LmF2Z1dhaXRZZWFycztcbiAgICBjb25zdCBjaGFydEJ1aWxkUmF0ZSA9IGNoYXJ0UEI/Lm1heEJ1aWxkUmF0ZUd3WWVhcjtcbiAgICBcbiAgICAvLyBQcmVmZXIgYnVpbGRvdXREZWJ1ZyB3aGVuIHByZXNlbnQuXG4gICAgLy8gSWYgZ3JvdW5kL2JhY2tsb2cgZmllbGRzIGV4aXN0IGJ1dCBhcmUgMCB3aGlsZSBjaGFydElucHV0cyBzYXlzID4wLCB1c2UgY2hhcnRJbnB1dHMuXG4gICAgLy8gUmVtb3ZlIHRoZSBwaXBlbGluZUd3IHByb3h5IGVudGlyZWx5IChpdCdzIG5vdCBiYWNrbG9nIGFuZCBjYXVzZXMgc2lsZW50IHVuaXQvbWVhbmluZyBjb3JydXB0aW9uKS5cbiAgICBjb25zdCBiYWNrbG9nRnJvbUdyb3VuZCA9IGJyZWFrZG93bi5ncm91bmQ/LmJhY2tsb2dHdztcbiAgICBjb25zdCBiYWNrbG9nRnJvbUJ1aWxkb3V0ID0gYnJlYWtkb3duLmdyb3VuZD8uYnVpbGRvdXREZWJ1Zz8uYmFja2xvZ0dXO1xuICAgIGxldCBiYWNrbG9nR1cgPVxuICAgICAgKGJhY2tsb2dGcm9tQnVpbGRvdXQgIT09IHVuZGVmaW5lZCA/IGJhY2tsb2dGcm9tQnVpbGRvdXQgOiB1bmRlZmluZWQpID8/XG4gICAgICAoKGJhY2tsb2dGcm9tR3JvdW5kICE9PSB1bmRlZmluZWQgJiYgYmFja2xvZ0Zyb21Hcm91bmQgPiAwKSA/IGJhY2tsb2dGcm9tR3JvdW5kIDogdW5kZWZpbmVkKSA/P1xuICAgICAgKChjaGFydEJhY2tsb2cgIT09IHVuZGVmaW5lZCAmJiBjaGFydEJhY2tsb2cgPiAwKSA/IGNoYXJ0QmFja2xvZyA6IDApO1xuICAgIFxuICAgIGNvbnN0IGJ1aWxkUmF0ZUZyb21CdWlsZG91dCA9IGJyZWFrZG93bi5ncm91bmQ/LmJ1aWxkb3V0RGVidWc/LmJ1aWxkUmF0ZUdXeXI7XG4gICAgY29uc3QgYnVpbGRSYXRlRnJvbVN1cHBseSA9IGJyZWFrZG93bi5ncm91bmQ/LnN1cHBseU1ldHJpY3M/Lm1heEJ1aWxkUmF0ZUd3WWVhcjtcbiAgICBjb25zdCBidWlsZFJhdGVHV3lyID1cbiAgICAgIChidWlsZFJhdGVGcm9tQnVpbGRvdXQgIT09IHVuZGVmaW5lZCA/IGJ1aWxkUmF0ZUZyb21CdWlsZG91dCA6IHVuZGVmaW5lZCkgPz9cbiAgICAgIChidWlsZFJhdGVGcm9tU3VwcGx5ICE9PSB1bmRlZmluZWQgPyBidWlsZFJhdGVGcm9tU3VwcGx5IDogdW5kZWZpbmVkKSA/P1xuICAgICAgKGNoYXJ0QnVpbGRSYXRlICE9PSB1bmRlZmluZWQgPyBjaGFydEJ1aWxkUmF0ZSA6IDApO1xuICAgIFxuICAgIGNvbnN0IGF2Z1dhaXRGcm9tR3JvdW5kID0gYnJlYWtkb3duLmdyb3VuZD8uYXZnV2FpdFllYXJzO1xuICAgIGNvbnN0IGF2Z1dhaXRGcm9tQnVpbGRvdXQgPSBicmVha2Rvd24uZ3JvdW5kPy5idWlsZG91dERlYnVnPy50aW1lVG9Qb3dlclllYXJzO1xuICAgIGNvbnN0IGF2Z1dhaXRGcm9tU3VwcGx5ID0gYnJlYWtkb3duLmdyb3VuZD8uc3VwcGx5TWV0cmljcz8uYXZnV2FpdFllYXJzO1xuICAgIGxldCBhdmdXYWl0WWVhcnMgPVxuICAgICAgKGF2Z1dhaXRGcm9tQnVpbGRvdXQgIT09IHVuZGVmaW5lZCA/IGF2Z1dhaXRGcm9tQnVpbGRvdXQgOiB1bmRlZmluZWQpID8/XG4gICAgICAoKGF2Z1dhaXRGcm9tR3JvdW5kICE9PSB1bmRlZmluZWQgJiYgYXZnV2FpdEZyb21Hcm91bmQgPiAwKSA/IGF2Z1dhaXRGcm9tR3JvdW5kIDogdW5kZWZpbmVkKSA/P1xuICAgICAgKChhdmdXYWl0RnJvbVN1cHBseSAhPT0gdW5kZWZpbmVkICYmIGF2Z1dhaXRGcm9tU3VwcGx5ID4gMCkgPyBhdmdXYWl0RnJvbVN1cHBseSA6IHVuZGVmaW5lZCkgPz9cbiAgICAgICgoY2hhcnRBdmdXYWl0ICE9PSB1bmRlZmluZWQgJiYgY2hhcnRBdmdXYWl0ID4gMCkgPyBjaGFydEF2Z1dhaXQgOiAwKTtcbiAgICBcbiAgICAvLyBTZWxmLWhlYWwgcGx1bWJpbmcgbWlzbWF0Y2hlczogaWYgY2hhcnRJbnB1dHMgaGFzIHBvc2l0aXZlIHZhbHVlIGJ1dCBjaG9zZW4gaXMgMCwgdXNlIGNoYXJ0SW5wdXRzXG4gICAgLy8gTG9nIHN0cnVjdHVyZWQgZXJyb3IgYnV0IG5ldmVyIHRocm93IChwcmV2ZW50cyBjaGFydCBmcm9tIGRpc2FwcGVhcmluZylcbiAgICBpZiAoKGNoYXJ0QmFja2xvZyA/PyAwKSA+IDAgJiYgYmFja2xvZ0dXID09PSAwICYmIGNoYXJ0QmFja2xvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiYWNrbG9nR1cgPSBjaGFydEJhY2tsb2c7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGBbQkFDS0xPRyBQTFVNQklOR10gWWVhciAke3llYXJ9OiBjaGFydElucHV0cy5iYWNrbG9nR3c9JHtjaGFydEJhY2tsb2d9IGJ1dCBmYWxsYmFjayBjaGFpbiByZXR1cm5lZCAwLiBgICtcbiAgICAgICAgICBgU2VsZi1oZWFsZWQ6IHVzaW5nIGNoYXJ0SW5wdXRzLiBgICtcbiAgICAgICAgICBgQ2FuZGlkYXRlczogZ3JvdW5kLmJhY2tsb2dHdz0ke2JyZWFrZG93bi5ncm91bmQ/LmJhY2tsb2dHd30sIGAgK1xuICAgICAgICAgIGBidWlsZG91dERlYnVnLmJhY2tsb2dHVz0ke2JyZWFrZG93bi5ncm91bmQ/LmJ1aWxkb3V0RGVidWc/LmJhY2tsb2dHV30sIGAgK1xuICAgICAgICAgIGBzdXBwbHlNZXRyaWNzLnBpcGVsaW5lR3c9JHticmVha2Rvd24uZ3JvdW5kPy5zdXBwbHlNZXRyaWNzPy5waXBlbGluZUd3fWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKChjaGFydEF2Z1dhaXQgPz8gMCkgPiAwICYmIGF2Z1dhaXRZZWFycyA9PT0gMCAmJiBjaGFydEF2Z1dhaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXZnV2FpdFllYXJzID0gY2hhcnRBdmdXYWl0O1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgW1dBSVQgUExVTUJJTkddIFllYXIgJHt5ZWFyfTogY2hhcnRJbnB1dHMuYXZnV2FpdFllYXJzPSR7Y2hhcnRBdmdXYWl0fSBidXQgZmFsbGJhY2sgY2hhaW4gcmV0dXJuZWQgMC4gYCArXG4gICAgICAgICAgYFNlbGYtaGVhbGVkOiB1c2luZyBjaGFydElucHV0cy4gYCArXG4gICAgICAgICAgYENhbmRpZGF0ZXM6IGdyb3VuZC5hdmdXYWl0WWVhcnM9JHticmVha2Rvd24uZ3JvdW5kPy5hdmdXYWl0WWVhcnN9LCBgICtcbiAgICAgICAgICBgYnVpbGRvdXREZWJ1Zy50aW1lVG9Qb3dlclllYXJzPSR7YnJlYWtkb3duLmdyb3VuZD8uYnVpbGRvdXREZWJ1Zz8udGltZVRvUG93ZXJZZWFyc30sIGAgK1xuICAgICAgICAgIGBzdXBwbHlNZXRyaWNzLmF2Z1dhaXRZZWFycz0ke2JyZWFrZG93bi5ncm91bmQ/LnN1cHBseU1ldHJpY3M/LmF2Z1dhaXRZZWFyc31gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBvcmJpdE1heERlcGxveWFibGVDb21wdXRlR1cgZnJvbSBjb25zdGVsbGF0aW9uIGNhcGFjaXR5IG9yIHNjZW5hcmlvIHBhcmFtc1xuICAgIC8vIENhbm9uaWNhbCBvcmJpdGFsIGNhcGFjaXR5IGZyb20gY29uc3RlbGxhdGlvbjogKG51bVNhdGVsbGl0ZXMgKiBjb21wdXRlUGVyU2F0S3cpIC8gMWU2XG4gICAgY29uc3Qgb3JiaXRNYXhEZXBsb3lhYmxlQ29tcHV0ZUdXID0gb3JiaXRhbEZlYXNpYmxlIFxuICAgICAgPyAocGFyYW1zLm9yYml0TWF4RGVwbG95YWJsZUNvbXB1dGVHV0J5WWVhcj8uKHllYXIpID8/IG9yYml0YWxDYXBhY2l0eUdXX2Zyb21TYXRzKVxuICAgICAgOiAwO1xuICAgIFxuICAgIC8vIEZpeCBvcmJpdCBmZWFzaWJpbGl0eSBnYXRpbmc6IHVzZSBvcmJpdE1heERlcGxveWFibGVDb21wdXRlR1csIG5vdCBvcmJpdGFsQ2FwYWNpdHlHVyBwbGFjZWhvbGRlclxuICAgIGNvbnN0IG9yYml0YWxGZWFzaWJsZUZvclNoYXJlID0gb3JiaXRhbEZlYXNpYmxlICYmIChvcmJpdE1heERlcGxveWFibGVDb21wdXRlR1cgPiAwKTtcbiAgICBcbiAgICBjb25zdCBtYXJrZXRBbmFseXNpcyA9IGNhbGN1bGF0ZU1hcmtldFNoYXJlKFxuICAgICAgeWVhcixcbiAgICAgIGJyZWFrZG93bi5vcmJpdC50b3RhbENvc3RQZXJQZmxvcFllYXIsXG4gICAgICBicmVha2Rvd24uZ3JvdW5kLnRvdGFsQ29zdFBlclBmbG9wWWVhcixcbiAgICAgIHRvdGFsRGVtYW5kR1csXG4gICAgICBvcmJpdGFsRmVhc2libGVGb3JTaGFyZSxcbiAgICAgIGdyb3VuZEZlYXNpYmxlLFxuICAgICAgb3JiaXRhbENvc3RBY2NvdW50aW5nVmFsaWQsXG4gICAgICBncm91bmRDb3N0QWNjb3VudGluZ1ZhbGlkLFxuICAgICAgZGVtYW5kQ29tcHV0ZUdXLCAvLyBVc2Ugc2luZ2xlIHNvdXJjZSBvZiB0cnV0aCwgbm90IGdyb3VuZCBtb2RlbCBkZW1hbmRcbiAgICAgIGJhY2tsb2dHVyxcbiAgICAgIGJ1aWxkUmF0ZUdXeXIsXG4gICAgICBhdmdXYWl0WWVhcnMsXG4gICAgICBvcmJpdE1heERlcGxveWFibGVDb21wdXRlR1dcbiAgICApO1xuICAgIFxuICAgIGJyZWFrZG93bi5tYXJrZXQgPSB7XG4gICAgICB0b3RhbERlbWFuZEdXOiBkZW1hbmRDb21wdXRlR1csIC8vIFVzZSBzaW5nbGUgc291cmNlIG9mIHRydXRoIChub3QgbWFya2V0QW5hbHlzaXMudG90YWxEZW1hbmRHVyB3aGljaCBtYXkgZGlmZmVyKVxuICAgICAgb3JiaXRhbFNoYXJlRnJhYzogbWFya2V0QW5hbHlzaXMub3JiaXRhbFNoYXJlRnJhYyxcbiAgICAgIG9yYml0YWxDYXBhY2l0eUdXOiBtYXJrZXRBbmFseXNpcy5vcmJpdGFsQ2FwYWNpdHlHVyxcbiAgICAgIG9yYml0YWxSZXZlbnVlOiBtYXJrZXRBbmFseXNpcy5vcmJpdGFsUmV2ZW51ZSxcbiAgICAgIGdyb3VuZFNoYXJlRnJhYzogbWFya2V0QW5hbHlzaXMuZ3JvdW5kU2hhcmVGcmFjLFxuICAgICAgZ3JvdW5kQ2FwYWNpdHlHVzogbWFya2V0QW5hbHlzaXMuZ3JvdW5kQ2FwYWNpdHlHVyxcbiAgICAgIGRlYnVnOiB7XG4gICAgICAgIC4uLm1hcmtldEFuYWx5c2lzLmRlYnVnLFxuICAgICAgICBkZW1hbmRDb21wdXRlR1c6IGRlbWFuZENvbXB1dGVHVywgLy8gU2luZ2xlIHNvdXJjZSBvZiB0cnV0aFxuICAgICAgICBvcmJpdGFsQ2FwYWNpdHlHV19mcm9tU2F0czogb3JiaXRhbENhcGFjaXR5R1dfZnJvbVNhdHMsIC8vIENhbm9uaWNhbCBjYXBhY2l0eSBmcm9tIGNvbnN0ZWxsYXRpb24gKGZvciB2YWxpZGF0aW9uKVxuICAgICAgfSBhcyBNYXJrZXRBbmFseXNpc1snZGVidWcnXSwgLy8gVHlwZSBhc3NlcnRpb24gdG8gYWxsb3cgb3JiaXRhbENhcGFjaXR5R1dfZnJvbVNhdHNcbiAgICB9O1xuICAgIFxuICAgIC8vIEludmFyaWFudDogZGVtYW5kIHNjYWxhciBjb25zaXN0ZW5jeVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBicmVha2Rvd24ubWFya2V0KSB7XG4gICAgICBjb25zdCBtYXJrZXREZW1hbmQgPSBicmVha2Rvd24ubWFya2V0LnRvdGFsRGVtYW5kR1c7XG4gICAgICBjb25zdCBtYXJrZXREZWJ1Z0RlbWFuZCA9IGJyZWFrZG93bi5tYXJrZXQuZGVidWc/LmRlbWFuZENvbXB1dGVHVztcbiAgICAgIGNvbnN0IGJ1aWxkb3V0RGVtYW5kID0gYnJlYWtkb3duLmdyb3VuZD8uYnVpbGRvdXREZWJ1Zz8uZGVtYW5kR1c7XG4gICAgICBcbiAgICAgIGlmIChtYXJrZXREZWJ1Z0RlbWFuZCAhPT0gdW5kZWZpbmVkICYmIE1hdGguYWJzKG1hcmtldERlbWFuZCAtIG1hcmtldERlYnVnRGVtYW5kKSA+IDFlLTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBbREVNQU5EIFNDQUxBUiBCVUddIFllYXIgJHt5ZWFyfTogbWFya2V0LnRvdGFsRGVtYW5kR1c9JHttYXJrZXREZW1hbmR9ICE9IGAgK1xuICAgICAgICAgIGBtYXJrZXQuZGVidWcuZGVtYW5kQ29tcHV0ZUdXPSR7bWFya2V0RGVidWdEZW1hbmR9LiBNdXN0IGJlIGVxdWFsLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGJ1aWxkb3V0RGVtYW5kICE9PSB1bmRlZmluZWQgJiYgTWF0aC5hYnMobWFya2V0RGVtYW5kIC0gYnVpbGRvdXREZW1hbmQpID4gMWUtNikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFtERU1BTkQgU0NBTEFSIEJVR10gWWVhciAke3llYXJ9OiBtYXJrZXQudG90YWxEZW1hbmRHVz0ke21hcmtldERlbWFuZH0gIT0gYCArXG4gICAgICAgICAgYGdyb3VuZC5idWlsZG91dERlYnVnLmRlbWFuZEdXPSR7YnVpbGRvdXREZW1hbmR9LiBNdXN0IGJlIGVxdWFsLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIG1vYmlsaXphdGlvbiBzdGF0ZSBmb3IgbmV4dCB5ZWFyICh1c2UgZXh0cmFjdGVkIHZhbHVlcywgbm90IGJyZWFrZG93bi5ncm91bmQgd2hpY2ggbWlnaHQgYmUgMClcbiAgICBpZiAoYnJlYWtkb3duLmdyb3VuZD8uYnVpbGRvdXREZWJ1Zykge1xuICAgICAgY29uc3QgYnVpbGRvdXREZWJ1ZyA9IGJyZWFrZG93bi5ncm91bmQuYnVpbGRvdXREZWJ1ZztcbiAgICAgIG1vYmlsaXphdGlvblN0YXRlID0ge1xuICAgICAgICB5ZWFyLFxuICAgICAgICBkZW1hbmRHVzogYnVpbGRvdXREZWJ1Zy5kZW1hbmRHVyA/PyAwLFxuICAgICAgICBkZW1hbmROZXdHVzogYnVpbGRvdXREZWJ1Zy5kZW1hbmROZXdHVyxcbiAgICAgICAgYnVpbGRSYXRlR1d5cjogYnVpbGRvdXREZWJ1Zy5idWlsZFJhdGVHV3lyID8/IGJ1aWxkUmF0ZUdXeXIsXG4gICAgICAgIGNhcGFjaXR5R1c6IGJ1aWxkb3V0RGVidWcuY2FwYWNpdHlHVyA/PyAwLFxuICAgICAgICBwaXBlbGluZUdXOiBidWlsZG91dERlYnVnLnBpcGVsaW5lR1cgPz8gMCxcbiAgICAgICAgYmFja2xvZ0dXOiBiYWNrbG9nR1csIC8vIFVzZSBleHRyYWN0ZWQgdmFsdWUsIG5vdCBicmVha2Rvd24uZ3JvdW5kLmJhY2tsb2dHdyB3aGljaCBtaWdodCBiZSAwXG4gICAgICAgIGF2Z1dhaXRZZWFyczogYXZnV2FpdFllYXJzLCAvLyBVc2UgZXh0cmFjdGVkIHZhbHVlLCBub3QgYnJlYWtkb3duLmdyb3VuZC5hdmdXYWl0WWVhcnMgd2hpY2ggbWlnaHQgYmUgMFxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgdHJhamVjdG9yeS5wdXNoKGJyZWFrZG93bik7XG4gICAgXG4gICAgLy8gVXBkYXRlIHByZXZpb3VzIHllYXIgYnJlYWtkb3duIGZvciBuZXh0IGl0ZXJhdGlvbiAoZm9yIHJlc3BvbnNpdmUgZGVtYW5kIGNhbGN1bGF0aW9uKVxuICAgIHByZXZZZWFyQnJlYWtkb3duID0gYnJlYWtkb3duO1xuICB9XG5cbiAgcmV0dXJuIHRyYWplY3Rvcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUZpbmFsQW5hbHlzaXMoXG4gIG9wdGlvbnM6IFRyYWplY3RvcnlPcHRpb25zLFxuICBiYXNlVHJhamVjdG9yeTogWWVhcmx5QnJlYWtkb3duW11cbik6IEZpbmFsTW9kZWxPdXRwdXQge1xuICBjb25zdCBiYXNlQ3Jvc3NvdmVyID0gZmluZENyb3Nzb3ZlclllYXIoYmFzZVRyYWplY3RvcnkpO1xuICBjb25zdCBiYXNlQ3Jvc3NvdmVyRWZmZWN0aXZlUGZsb3AgPSBmaW5kQ3Jvc3NvdmVyWWVhckVmZmVjdGl2ZVBmbG9wKGJhc2VUcmFqZWN0b3J5KTtcbiAgY29uc3QgYmFzZVBhcmFtcyA9IG9wdGlvbnMucGFyYW1zQnlZZWFyKDIwMjUpO1xuICBcbiAgLy8gMS4gU2Vuc2l0aXZpdHkgQW5hbHlzaXNcbiAgY29uc3QgcGFyYW1ldGVyc1RvVGVzdCA9IFtcbiAgICB7IGtleTogJ2xhdW5jaENvc3RLZycsIG5hbWU6ICdMYXVuY2ggQ29zdCAoMjAzNSknLCB2YWx1ZXM6IFs1MCwgMTAwLCAxNTAsIDIwMCwgMzAwXSwgeWVhclRvTW9kaWZ5OiAyMDM1IH0sXG4gICAgeyBrZXk6ICdncHVGYWlsdXJlUmF0ZScsIG5hbWU6ICdHUFUgRmFpbHVyZSBSYXRlJywgdmFsdWVzOiBbMC4wNSwgMC4xMCwgMC4xNSwgMC4yMCwgMC4yNV0sIHllYXJUb01vZGlmeTogbnVsbCB9LFxuICAgIHsga2V5OiAnaGFyZHdhcmVMZWFybmluZ1JhdGUnLCBuYW1lOiAnSGFyZHdhcmUgTGVhcm5pbmcgUmF0ZScsIHZhbHVlczogWzAuMDgsIDAuMTAsIDAuMTIsIDAuMTVdLCB5ZWFyVG9Nb2RpZnk6IG51bGwgfSxcbiAgXTtcblxuICBjb25zdCBzZW5zaXRpdml0aWVzID0gcGFyYW1ldGVyc1RvVGVzdC5tYXAocCA9PiB7XG4gICAgY29uc3QgY3Jvc3NvdmVyWWVhcnMgPSBwLnZhbHVlcy5tYXAodmFsID0+IHtcbiAgICAgIGNvbnN0IHRlc3RUcmFqZWN0b3J5ID0gY29tcHV0ZVRyYWplY3Rvcnkoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBwYXJhbXNCeVllYXI6ICh5KSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gb3B0aW9ucy5wYXJhbXNCeVllYXIoeSk7XG4gICAgICAgICAgaWYgKHAueWVhclRvTW9kaWZ5ICYmIHkgPT09IHAueWVhclRvTW9kaWZ5KSB7XG4gICAgICAgICAgICAgcmV0dXJuIHsgLi4ucGFyYW1zLCBbcC5rZXldOiB2YWwgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFwLnllYXJUb01vZGlmeSkge1xuICAgICAgICAgICAgIHJldHVybiB7IC4uLnBhcmFtcywgW3Aua2V5XTogdmFsIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZpbmRDcm9zc292ZXJZZWFyKHRlc3RUcmFqZWN0b3J5KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHZhbGlkWWVhcnMgPSBjcm9zc292ZXJZZWFycy5maWx0ZXIoeSA9PiB5ICE9PSBudWxsKSBhcyBudW1iZXJbXTtcbiAgICBjb25zdCBtYXhEZWx0YSA9IHZhbGlkWWVhcnMubGVuZ3RoID4gMSA/IE1hdGgubWF4KC4uLnZhbGlkWWVhcnMpIC0gTWF0aC5taW4oLi4udmFsaWRZZWFycykgOiAwO1xuICAgIGNvbnN0IGltcGFjdCA9IG1heERlbHRhID49IDQgPyAnaGlnaCcgOiBtYXhEZWx0YSA+PSAyID8gJ21lZGl1bScgOiAnbG93JztcblxuICAgIHJldHVybiB7XG4gICAgICBwYXJhbWV0ZXI6IHAubmFtZSxcbiAgICAgIGJhc2VWYWx1ZTogKGJhc2VQYXJhbXNbcC5rZXkgYXMga2V5b2YgWWVhclBhcmFtc10gYXMgbnVtYmVyKSB8fCAwLFxuICAgICAgdGVzdFZhbHVlczogcC52YWx1ZXMsXG4gICAgICBjcm9zc292ZXJZZWFycyxcbiAgICAgIGltcGFjdDogaW1wYWN0IGFzICdoaWdoJyB8ICdtZWRpdW0nIHwgJ2xvdydcbiAgICB9O1xuICB9KTtcblxuICAvLyAyLiBTY2VuYXJpbyBCZW5jaG1hcmtzXG4gIGNvbnN0IHNjZW5hcmlvcyA9IFtcbiAgICB7XG4gICAgICBuYW1lOiAnQnVsbCBDYXNlJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnTWF0dXJlIFN0YXJzaGlwLCBjb21tZXJjaWFsIGNoaXBzLCBzZXZlcmUgZ3JvdW5kIGNvbnN0cmFpbnRzJyxcbiAgICAgIGtleUFzc3VtcHRpb25zOiBbJ0xhdW5jaCAkNzUva2cgYnkgMjAzNScsICdDb21tZXJjaWFsIGNoaXBzJywgJ1NldmVyZSBncm91bmQgY29uc3RyYWludHMnXSxcbiAgICAgIGNyb3Nzb3ZlclllYXI6IGZpbmRDcm9zc292ZXJZZWFyKGNvbXB1dGVUcmFqZWN0b3J5KHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgcGFyYW1zQnlZZWFyOiAoeSkgPT4gKHtcbiAgICAgICAgICAuLi5vcHRpb25zLnBhcmFtc0J5WWVhcih5KSxcbiAgICAgICAgICBsYXVuY2hDb3N0S2c6IGdldExhdW5jaENvc3RQZXJLZyh5LCAxNTAwKSxcbiAgICAgICAgICB1c2VSYWRIYXJkQ2hpcHM6IGZhbHNlLFxuICAgICAgICAgIGdyb3VuZFNjZW5hcmlvOiAnc2V2ZXJlJ1xuICAgICAgICB9KVxuICAgICAgfSkpXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnQmFzZSBDYXNlJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ3VycmVudCBtb2RlbCBhc3N1bXB0aW9ucyAoUmFkLXRvbGVyYW50IGJhc2VsaW5lKScsXG4gICAgICBrZXlBc3N1bXB0aW9uczogWydMYXVuY2ggJDc1L2tnIGJ5IDIwMzUnLCAnUmFkLXRvbGVyYW50IGNoaXBzJywgJ1N0YW5kYXJkIGdyb3VuZCBjb25zdHJhaW50cyddLFxuICAgICAgY3Jvc3NvdmVyWWVhcjogYmFzZUNyb3Nzb3ZlclxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ0JlYXIgQ2FzZScsXG4gICAgICBkZXNjcmlwdGlvbjogJ1JhZC1oYXJkIHJlcXVpcmVkLCBTTVJzIHNvbHZlIGdyb3VuZCBwb3dlcicsXG4gICAgICBrZXlBc3N1bXB0aW9uczogWydMYXVuY2ggJDMwMC9rZyBieSAyMDM1JywgJ1JhZC1oYXJkIGNoaXBzJywgJ1VuY29uc3RyYWluZWQgZ3JvdW5kJ10sXG4gICAgICBjcm9zc292ZXJZZWFyOiBmaW5kQ3Jvc3NvdmVyWWVhcihjb21wdXRlVHJhamVjdG9yeSh7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHBhcmFtc0J5WWVhcjogKHkpID0+ICh7XG4gICAgICAgICAgLi4ub3B0aW9ucy5wYXJhbXNCeVllYXIoeSksXG4gICAgICAgICAgbGF1bmNoQ29zdEtnOiBwcm9qZWN0TWFya2V0UHJpY2UoMTUwMCwgMjAyNSwgeSwgMC4xMCksXG4gICAgICAgICAgdXNlUmFkSGFyZENoaXBzOiB0cnVlLFxuICAgICAgICAgIGdyb3VuZFNjZW5hcmlvOiAndW5jb25zdHJhaW5lZCdcbiAgICAgICAgfSlcbiAgICAgIH0pKVxuICAgIH1cbiAgXTtcblxuICAvLyAzLiBNYXJrZXQgQ29tcGFyaXNvblxuICBjb25zdCBtYXJrZXRDb21wYXJpc29uOiBNYXJrZXRQcm9qZWN0aW9uW10gPSBNQVJLRVRfUFJPVklERVJTLm1hcChwID0+IHtcbiAgICBjb25zdCBwcm9qZWN0ZWRQcmljZXMgPSBbXTtcbiAgICBmb3IgKGxldCB5ID0gMjAyNTsgeSA8PSAyMDUwOyB5KyspIHtcbiAgICAgIHByb2plY3RlZFByaWNlcy5wdXNoKHsgeWVhcjogeSwgcHJpY2U6IHByb2plY3RNYXJrZXRQcmljZShwLnByaWNlLCAyMDI0LCB5LCBwLmRlY2xpbmUpIH0pO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBvcmJpdGFsQmVhdHNZZWFyID0gYmFzZVRyYWplY3RvcnkuZmluZChkID0+IHtcbiAgICAgIGNvbnN0IHByb2plY3RlZCA9IHByb2plY3RNYXJrZXRQcmljZShwLnByaWNlLCAyMDI0LCBkLnllYXIsIHAuZGVjbGluZSk7XG4gICAgICByZXR1cm4gZC5vcmJpdC5ncHVIb3VyUHJpY2luZy5zdGFuZGFyZC5wcmljZVBlckdwdUhvdXIgPCBwcm9qZWN0ZWQ7XG4gICAgfSk/LnllYXIgfHwgbnVsbDtcblxuICAgIHJldHVybiB7XG4gICAgICBwcm92aWRlcjogcC5uYW1lLFxuICAgICAgY3VycmVudFByaWNlOiBwLnByaWNlLFxuICAgICAgY3VycmVudFllYXI6IDIwMjQsXG4gICAgICBwcm9qZWN0ZWREZWNsaW5lOiBwLmRlY2xpbmUsXG4gICAgICBwcm9qZWN0ZWRQcmljZXMsXG4gICAgICBvcmJpdGFsQmVhdHNZZWFyXG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gNC4gR3JvdW5kIFNjZW5hcmlvIExhYmVsXG4gIGNvbnN0IHNlbGVjdGVkU2NlbmFyaW8gPSBHUk9VTkRfU0NFTkFSSU9TW2Jhc2VQYXJhbXMuZ3JvdW5kU2NlbmFyaW9dO1xuICBjb25zdCBncm91bmRTY2VuYXJpb0xhYmVsOiBHcm91bmRTY2VuYXJpb0xhYmVsID0ge1xuICAgIG5hbWU6IHNlbGVjdGVkU2NlbmFyaW8ubmFtZSxcbiAgICBkZXNjcmlwdGlvbjogc2VsZWN0ZWRTY2VuYXJpby5kZXNjcmlwdGlvbixcbiAgICBjb25zdHJhaW50TXVsdGlwbGllcjIwNDA6IDEuMCwgLy8gTm90IHVzZWQgLSBjb25zdHJhaW50cyBub3cgdXNlIGFkZGVycyBvbmx5XG4gICAgYXNzdW1wdGlvbnM6IFtcbiAgICAgIGBHcmlkIGdyb3d0aDogJHsoc2VsZWN0ZWRTY2VuYXJpby5ncmlkR3Jvd3RoUmF0ZSAqIDEwMCkudG9GaXhlZCgxKX0lL3llYXJgLFxuICAgICAgYENvb2xpbmcgZ3Jvd3RoOiAkeyhzZWxlY3RlZFNjZW5hcmlvLmNvb2xpbmdHcm93dGhSYXRlICogMTAwKS50b0ZpeGVkKDEpfSUveWVhcmAsXG4gICAgICBzZWxlY3RlZFNjZW5hcmlvLmNvbnN0cmFpbnRDYXAgPyBgQ29uc3RyYWludCBjYXA6ICR7c2VsZWN0ZWRTY2VuYXJpby5jb25zdHJhaW50Q2FwfXhgIDogJ05vIGNvbnN0cmFpbnQgY2FwJ1xuICAgIF1cbiAgfTtcblxuICAvLyA1LiBWYWxpZGF0aW9uIENoZWNrc1xuICBjb25zdCBsYXN0WWVhciA9IGJhc2VUcmFqZWN0b3J5W2Jhc2VUcmFqZWN0b3J5Lmxlbmd0aCAtIDFdO1xuICBjb25zdCBmaXJzdFllYXIgPSBiYXNlVHJhamVjdG9yeVswXTtcbiAgY29uc3QgYWxsQ2hlY2tzID0gW1xuICAgIHsgbmFtZTogJ0Nvc3QgYnJlYWtkb3duIHN1bXMgdG8gdG90YWwnLCBwYXNzZWQ6ICEhbGFzdFllYXIuY29zdEFjY291bnRpbmdWYWxpZCwgdmFsdWU6IGxhc3RZZWFyLmNvc3RBY2NvdW50aW5nRXJyb3JQY3QsIGV4cGVjdGVkOiAnPDAuNSUnIH0sXG4gICAgeyBuYW1lOiAnQ2FwYWNpdHkgZmFjdG9yIGluIHJhbmdlJywgcGFzc2VkOiBmaXJzdFllYXIub3JiaXQuY2FwYWNpdHlGYWN0b3IgPiAwLjkwLCB2YWx1ZTogZmlyc3RZZWFyLm9yYml0LmNhcGFjaXR5RmFjdG9yLCBleHBlY3RlZDogJzAuOTAtMS4wJyB9LFxuICAgIHsgbmFtZTogJ0Nyb3Nzb3ZlciB5ZWFyIG1hdGNoZXMgdHJhamVjdG9yeScsIHBhc3NlZDogdHJ1ZSwgdmFsdWU6IGJhc2VDcm9zc292ZXIgfSxcbiAgXTtcblxuICBjb25zdCB2YWxpZGF0aW9uOiBWYWxpZGF0aW9uQ2hlY2tzID0ge1xuICAgIGNvc3RBY2NvdW50aW5nVmFsaWQ6ICEhbGFzdFllYXIuY29zdEFjY291bnRpbmdWYWxpZCxcbiAgICBjb3N0QWNjb3VudGluZ0Vycm9yOiBsYXN0WWVhci5jb3N0QWNjb3VudGluZ0Vycm9yUGN0IHx8IDAsXG4gICAgdHJhamVjdG9yeU1vbm90b25pYzogdHJ1ZSwgLy8gU2ltcGxpZmllZFxuICAgIHBhcmFtZXRlcnNJblJhbmdlOiB0cnVlLFxuICAgIGNyb3Nzb3ZlckNvbnNpc3RlbnQ6IHRydWUsXG4gICAgYWxsQ2hlY2tzXG4gIH07XG5cbiAgY29uc3QgY3Jvc3NvdmVyWWVhclN0YW5kYXJkID0gYmFzZUNyb3Nzb3ZlcjtcbiAgY29uc3QgcHJpY2VBdENyb3Nzb3Zlck9yYml0YWwgPSBiYXNlQ3Jvc3NvdmVyID8gYmFzZVRyYWplY3RvcnlbYmFzZUNyb3Nzb3ZlciAtIDIwMjVdLm9yYml0LmdwdUhvdXJQcmljaW5nLnN0YW5kYXJkLnByaWNlUGVyR3B1SG91ciA6IDA7XG4gIGNvbnN0IHByaWNlQXRDcm9zc292ZXJHcm91bmQgPSBiYXNlQ3Jvc3NvdmVyID8gYmFzZVRyYWplY3RvcnlbYmFzZUNyb3Nzb3ZlciAtIDIwMjVdLmdyb3VuZC5ncHVIb3VyUHJpY2luZy5zdGFuZGFyZC5wcmljZVBlckdwdUhvdXIgOiAwO1xuXG4gIGNvbnN0IGFjdGl2ZVRvZ2dsZXMgPSBbXTtcbiAgaWYgKGJhc2VQYXJhbXMuZWxvblNjZW5hcmlvRW5hYmxlZCkgYWN0aXZlVG9nZ2xlcy5wdXNoKCdFbG9uIFNjZW5hcmlvJyk7XG4gIGlmIChiYXNlUGFyYW1zLmdsb2JhbExhdGVuY3lSZXF1aXJlbWVudEVuYWJsZWQpIGFjdGl2ZVRvZ2dsZXMucHVzaCgnR2xvYmFsIExhdGVuY3knKTtcbiAgaWYgKGJhc2VQYXJhbXMuc3BhY2VNYW51ZmFjdHVyaW5nRW5hYmxlZCkgYWN0aXZlVG9nZ2xlcy5wdXNoKCdTcGFjZSBNZmcnKTtcbiAgaWYgKGJhc2VQYXJhbXMuYWlXaW50ZXJFbmFibGVkKSBhY3RpdmVUb2dnbGVzLnB1c2goJ0FJIFdpbnRlcicpO1xuXG4gIC8vIEJhc2VsaW5lIGNyb3Nzb3ZlciAobm8gdG9nZ2xlcylcbiAgY29uc3QgYmFzZWxpbmVUcmFqZWN0b3J5ID0gY29tcHV0ZVRyYWplY3Rvcnkoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgcGFyYW1zQnlZZWFyOiAoeSkgPT4gKHtcbiAgICAgIC4uLm9wdGlvbnMucGFyYW1zQnlZZWFyKHkpLFxuICAgICAgZWxvblNjZW5hcmlvRW5hYmxlZDogZmFsc2UsXG4gICAgICBnbG9iYWxMYXRlbmN5UmVxdWlyZW1lbnRFbmFibGVkOiBmYWxzZSxcbiAgICAgIHNwYWNlTWFudWZhY3R1cmluZ0VuYWJsZWQ6IGZhbHNlLFxuICAgICAgYWlXaW50ZXJFbmFibGVkOiBmYWxzZVxuICAgIH0pXG4gIH0pO1xuICBjb25zdCBiYXNlbGluZUNyb3Nzb3ZlciA9IGZpbmRDcm9zc292ZXJZZWFyKGJhc2VsaW5lVHJhamVjdG9yeSk7XG5cbiAgY29uc3Qgc2NlbmFyaW9JbXBhY3QgPSB7XG4gICAgYmFzZWxpbmVDcm9zc292ZXIsXG4gICAgY3VycmVudENyb3Nzb3ZlcjogYmFzZUNyb3Nzb3ZlcixcbiAgICBhY3RpdmVUb2dnbGVzLFxuICAgIGNyb3Nzb3ZlckRlbHRhOiAoYmFzZWxpbmVDcm9zc292ZXIgfHwgMjA0MCkgLSAoYmFzZUNyb3Nzb3ZlciB8fCAyMDQwKVxuICB9O1xuXG4gIC8vIE1vbnRlIENhcmxvIEFuYWx5c2lzIChydW4gb25jZSwgY2FjaGVkIHBlciBwYXJhbWV0ZXIgc2V0KVxuICAvLyBFeHRyYWN0IGJhc2UgcGFyYW1ldGVycyBmb3IgTW9udGUgQ2FybG9cbiAgY29uc3QgYmFzZVBhcmFtc0Zvck1DID0gZXh0cmFjdEJhc2VQYXJhbXMob3B0aW9ucy5wYXJhbXNCeVllYXIpO1xuICBcbiAgLy8gUnVuIE1vbnRlIENhcmxvIGFuYWx5c2lzICgyMDAgc2FtcGxlcyBieSBkZWZhdWx0KVxuICAvLyBUaGlzIGlzIGNvbXB1dGF0aW9uYWxseSBleHBlbnNpdmUsIHNvIHdlIG9ubHkgZG8gaXQgb25jZSBwZXIgYW5hbHlzaXNcbiAgY29uc3QgbW9udGVDYXJsb1Jlc3VsdCA9IHJ1bk1vbnRlQ2FybG9Dcm9zc292ZXIoXG4gICAgb3B0aW9ucy5wYXJhbXNCeVllYXIsXG4gICAgYmFzZVBhcmFtc0Zvck1DLFxuICAgIDIwMCAvLyBudW1TYW1wbGVzXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBtZXRhZGF0YToge1xuICAgICAgdmVyc2lvbjogJzQuMy4wJyxcbiAgICAgIGdlbmVyYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB1bml0czogW10gXG4gICAgfSxcbiAgICBwYXJhbWV0ZXJzOiBiYXNlUGFyYW1zLFxuICAgIHRyYWplY3Rvcnk6IGJhc2VUcmFqZWN0b3J5LFxuICAgIGFuYWx5c2lzOiB7XG4gICAgICBjcm9zc292ZXI6IHtcbiAgICAgICAgeWVhcjogYmFzZUNyb3Nzb3ZlcixcbiAgICAgICAgb3JiaXRhbFByaWNlOiBwcmljZUF0Q3Jvc3NvdmVyT3JiaXRhbCxcbiAgICAgICAgZ3JvdW5kUHJpY2U6IHByaWNlQXRDcm9zc292ZXJHcm91bmQsXG4gICAgICAgIG1hcmtldFBvc2l0aW9uOiBiYXNlVHJhamVjdG9yeVtiYXNlVHJhamVjdG9yeS5sZW5ndGggLSAxXS5jcm9zc292ZXJEZXRhaWxzPy5tYXJrZXRQb3NpdGlvbiB8fCAnJ1xuICAgICAgfSxcbiAgICAgIHNlbnNpdGl2aXR5OiB7XG4gICAgICAgIGJhc2VDYXNlOiB7XG4gICAgICAgICAgY3Jvc3NvdmVyWWVhcjogYmFzZUNyb3Nzb3ZlciB8fCAyMDQwLFxuICAgICAgICAgIG9yYml0YWxQcmljZUF0Q3Jvc3NvdmVyOiBwcmljZUF0Q3Jvc3NvdmVyT3JiaXRhbCxcbiAgICAgICAgICBncm91bmRQcmljZUF0Q3Jvc3NvdmVyOiBwcmljZUF0Q3Jvc3NvdmVyR3JvdW5kLFxuICAgICAgICB9LFxuICAgICAgICBzZW5zaXRpdml0aWVzXG4gICAgICB9LFxuICAgICAgc2NlbmFyaW9zLFxuICAgICAgY29uZmlkZW5jZToge1xuICAgICAgICBjcm9zc292ZXJZZWFyOiB7XG4gICAgICAgICAgcDEwOiBtb250ZUNhcmxvUmVzdWx0LnAxMCwgLy8gRnJvbSBNb250ZSBDYXJsbyBhbmFseXNpc1xuICAgICAgICAgIHA1MDogbW9udGVDYXJsb1Jlc3VsdC5wNTAsIC8vIEZyb20gTW9udGUgQ2FybG8gYW5hbHlzaXNcbiAgICAgICAgICBwOTA6IG1vbnRlQ2FybG9SZXN1bHQucDkwLCAvLyBGcm9tIE1vbnRlIENhcmxvIGFuYWx5c2lzXG4gICAgICAgIH0sXG4gICAgICAgIHByaWNlQXRDcm9zc292ZXI6IHtcbiAgICAgICAgICBsb3c6IHNjZW5hcmlvc1swXS5jcm9zc292ZXJZZWFyID8gYmFzZVRyYWplY3Rvcnlbc2NlbmFyaW9zWzBdLmNyb3Nzb3ZlclllYXIgLSAyMDI1XS5vcmJpdC5ncHVIb3VyUHJpY2luZy5zdGFuZGFyZC5wcmljZVBlckdwdUhvdXIgOiAwLFxuICAgICAgICAgIG1pZDogc2NlbmFyaW9zWzFdLmNyb3Nzb3ZlclllYXIgPyBiYXNlVHJhamVjdG9yeVtzY2VuYXJpb3NbMV0uY3Jvc3NvdmVyWWVhciAtIDIwMjVdLm9yYml0LmdwdUhvdXJQcmljaW5nLnN0YW5kYXJkLnByaWNlUGVyR3B1SG91ciA6IDAsXG4gICAgICAgICAgaGlnaDogc2NlbmFyaW9zWzJdLmNyb3Nzb3ZlclllYXIgPyBiYXNlVHJhamVjdG9yeVtzY2VuYXJpb3NbMl0uY3Jvc3NvdmVyWWVhciAtIDIwMjVdLm9yYml0LmdwdUhvdXJQcmljaW5nLnN0YW5kYXJkLnByaWNlUGVyR3B1SG91ciA6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIHByb2JhYmlsaXR5QnlZZWFyOiBtb250ZUNhcmxvUmVzdWx0LnByb2JhYmlsaXR5QnlZZWFyLCAvLyBQcm9iYWJpbGl0eSBvcmJpdGFsIGNoZWFwZXIgYnkgeWVhciBYXG4gICAgICB9LFxuICAgICAgbWFya2V0Q29tcGFyaXNvbixcbiAgICAgIHJlZ3VsYXRvcnlJbXBhY3Q6IDE1MDAsXG4gICAgICBzY2VuYXJpb0ltcGFjdFxuICAgIH0sXG4gICAgdmFsaWRhdGlvbixcbiAgICBncm91bmRTY2VuYXJpbzogZ3JvdW5kU2NlbmFyaW9MYWJlbFxuICB9O1xufVxuIl0sIm5hbWVzIjpbImNvbXB1dGVQaHlzaWNzQ29zdCIsIkdST1VORF9TQ0VOQVJJT1MiLCJnZXRMYXVuY2hDb3N0UGVyS2ciLCJzdGVwTGF1bmNoTGVhcm5pbmciLCJnZXRTdGF0aWNQYXJhbXMiLCJydW5Nb250ZUNhcmxvQ3Jvc3NvdmVyIiwiZXh0cmFjdEJhc2VQYXJhbXMiLCJmaW5kQ3Jvc3NvdmVyWWVhciIsInRyYWplY3RvcnkiLCJjcm9zc2luZyIsImZpbmQiLCJkIiwiZ3JvdW5kRWZmZWN0aXZlQ29zdCIsImdyb3VuZCIsInRvdGFsQ29zdFBlclBmbG9wWWVhckVmZmVjdGl2ZSIsInRvdGFsQ29zdFBlclBmbG9wWWVhciIsImNvbnN0cmFpbnRzIiwiZGVsYXlQZW5hbHR5Iiwic2NhcmNpdHlSZW50UGVyUGZsb3BZZWFyIiwib3JiaXRDb3N0Iiwib3JiaXQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInllYXIiLCJmaW5kQ3Jvc3NvdmVyWWVhckVmZmVjdGl2ZVBmbG9wIiwiY2FsY3VsYXRlTWFya2V0U2hhcmUiLCJvcmJpdGFsQ29zdFBlclBmbG9wIiwiZ3JvdW5kQ29zdFBlclBmbG9wIiwidG90YWxEZW1hbmRHVyIsIm9yYml0YWxGZWFzaWJsZSIsImdyb3VuZEZlYXNpYmxlIiwib3JiaXRhbENvc3RBY2NvdW50aW5nVmFsaWQiLCJncm91bmRDb3N0QWNjb3VudGluZ1ZhbGlkIiwiZGVtYW5kR1ciLCJiYWNrbG9nR1ciLCJidWlsZFJhdGVHV3lyIiwiYXZnV2FpdFllYXJzIiwib3JiaXRNYXhEZXBsb3lhYmxlQ29tcHV0ZUdXIiwib3JiaXRhbEFjdHVhbGx5RmVhc2libGUiLCJncm91bmRBY3R1YWxseUZlYXNpYmxlIiwib3JiaXRhbFNoYXJlRnJhYyIsIm9yYml0YWxDYXBhY2l0eUdXIiwib3JiaXRhbFJldmVudWUiLCJncm91bmRTaGFyZUZyYWMiLCJncm91bmRDYXBhY2l0eUdXIiwiZGVidWciLCJzaGFyZUNvbnZlbnRpb24iLCJncm91bmRSZXZlbnVlIiwiZGVtYW5kIiwiYmFja2xvZ0dXQWN0dWFsIiwiYnVpbGRSYXRlR1d5ckFjdHVhbCIsImF2Z1dhaXRZZWFyc0FjdHVhbCIsImdyb3VuZEhhc1NldmVyZVF1ZXVlIiwiZ3JvdW5kRmVhc2libGVHVyIsIk1hdGgiLCJtYXgiLCJvcmJpdEZlYXNpYmxlR1ciLCJtaW4iLCJtYXhTZXJ2YWJsZSIsImNvc3RSYXRpbyIsImxvZ2l0RmFjdG9yIiwiZXhwIiwib3JiaXRhbFNoYXJlRnJhY0Rlc2lyZWQiLCJncm91bmRTaGFyZUZyYWNEZXNpcmVkIiwib3JiaXRTZXJ2ZWQiLCJncm91bmRTZXJ2ZWQiLCJyZW1haW5kZXIiLCJvcmJpdFJvb20iLCJncm91bmRSb29tIiwiYWRkVG9PcmJpdCIsInRvdGFsU2VydmVkR1ciLCJncm91bmRTZXJ2ZWRDb21wdXRlR1ciLCJvcmJpdFNlcnZlZENvbXB1dGVHVyIsImdyb3VuZEZlYXNpYmxlQ29tcHV0ZUdXIiwib3JiaXRGZWFzaWJsZUNvbXB1dGVHVyIsInJldmVudWVQZXJHVyIsIkVycm9yIiwic2hhcmVTdW0iLCJhYnMiLCJkZW1hbmRDb21wdXRlR1ciLCJwcm9qZWN0TWFya2V0UHJpY2UiLCJiYXNlUHJpY2UiLCJiYXNlWWVhciIsInRhcmdldFllYXIiLCJhbm51YWxEZWNsaW5lUmF0ZSIsInllYXJzIiwicG93IiwiTUFSS0VUX1BST1ZJREVSUyIsIm5hbWUiLCJwcmljZSIsImRlY2xpbmUiLCJJVF9HV18yMDI1IiwiSVRfR1dfMjA0MF9UQVJHRVQiLCJJVF9HV18yMDYwX1RBUkdFVCIsIlIxIiwibG9nIiwiUjIiLCJjYWxjdWxhdGVSZXNwb25zaXZlRGVtYW5kIiwiZ3JvdW5kUHJpY2VQZXJHcHVIb3VyIiwib3JiaXRhbFByaWNlUGVyR3B1SG91ciIsInByZXZEZW1hbmRTdGF0ZSIsInllYXJzRnJvbTIwMjUiLCJncm93dGhSYXRlIiwidGFwZXIiLCJlZmZlY3RpdmVHcm93dGgiLCJiYXNlbGluZUdXIiwiYmFzZWxpbmVQcmljZSIsInByaWNlUmF0aW8iLCJwcmljZUVsYXN0aWNpdHkiLCJwcmljZUZhY3RvciIsIndhaXRFbGFzdGljaXR5Iiwid2FpdEZhY3RvciIsImVmZmVjdGl2ZUdXIiwiZ3JvdW5kT3JiaXRhbFJhdGlvIiwib3JiaXRhbFNoYXJlIiwib3JiaXRhbERlbWFuZEdXIiwiZ3JvdW5kRGVtYW5kR1ciLCJnZXRJVExvYWRHVyIsInllYXJzRnJvbTIwNDAiLCJnZXRGYWNpbGl0eUxvYWRHVyIsInB1ZSIsIml0TG9hZEdXIiwiZ2V0RGVtYW5kTmV3R1ciLCJmYWNpbGl0eUdXIiwiZmFjaWxpdHlHV1ByZXYiLCJnZXREZW1hbmRQcm9qZWN0aW9uIiwiY29tcHV0ZVRyYWplY3RvcnkiLCJvcHRpb25zIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJmaXJzdENhcFllYXIiLCJsYXVuY2hMZWFybmluZ1N0YXRlIiwiQkFTRUxJTkVfTUFTU19LRyIsIkxBVU5DSF9DT1NUXzBfUEVSX0tHIiwicHJldlllYXJCcmVha2Rvd24iLCJidWlsZG91dFN0YXRlIiwibW9iaWxpemF0aW9uU3RhdGUiLCJicmVha2Rvd24iLCJwYXJhbXMiLCJtb2RlIiwicGFyYW1zQnlZZWFyIiwibGF1bmNoQ29zdFBlcktnIiwibGF1bmNoQ29zdEtnIiwicGFyYW1zV2l0aExhdW5jaENvc3QiLCJ1c2VMYXVuY2hMZWFybmluZyIsImNvbXB1dGVQb3dlck1XIiwidGFyZ2V0R1ciLCJtYXNzUGVyTVciLCJtYXNzRGVtYW5kZWRLZyIsImxhdW5jaExlYXJuaW5nUmVzdWx0IiwiYmFzZWxpbmVNYXNzS2ciLCJsYXVuY2hDb3N0MFBlcktnIiwibGVhcm5pbmdSYXRlIiwibWF4RmxpZ2h0c1BlclllYXIiLCJwYXlsb2FkUGVyRmxpZ2h0S2ciLCJzdGF0ZSIsImdyb3VuZFB1ZSIsInB1ZUdyb3VuZCIsInByZXZHcm91bmRQcmljZSIsImdwdUhvdXJQcmljaW5nIiwic3RhbmRhcmQiLCJwcmljZVBlckdwdUhvdXIiLCJwcmV2T3JiaXRhbFByaWNlIiwicHJldkF2Z1dhaXQiLCJzdXBwbHlNZXRyaWNzIiwiZGVtYW5kU3RhdGUiLCJwYXJhbXNXaXRoTW9iaWxpemF0aW9uIiwicHJldk1vYmlsaXphdGlvblN0YXRlIiwicmVzcG9uc2l2ZURlbWFuZEdXIiwib3JiaXRhbFN1YnN0aXR1dGlvbkdXIiwiaHlicmlkQnJlYWtkb3duIiwiY29uc3RyYWludEJyZWFrZG93biIsImNhcFllYXIiLCJ1bmRlZmluZWQiLCJ0aGlzQ2FwWWVhciIsImFjdHVhbEdyb3VuZFB1ZSIsImJ1aWxkb3V0RGVidWciLCJJbmZpbml0eSIsImNvc3RBY2NvdW50aW5nVmFsaWQiLCJvcmJpdGFsQ2FwYWNpdHlHV19mcm9tU2F0cyIsImNvbnN0ZWxsYXRpb24iLCJkZXNpZ24iLCJudW1TYXRlbGxpdGVzIiwiY29tcHV0ZVBlclNhdEt3IiwicHJvY2VzcyIsImV4cGVjdGVkR1ciLCJlcnJvciIsImNoYXJ0UEIiLCJtZXRhZGF0YSIsImNoYXJ0SW5wdXRzIiwicG93ZXJCdWlsZG91dCIsImNoYXJ0QmFja2xvZyIsImJhY2tsb2dHdyIsImNoYXJ0QXZnV2FpdCIsImNoYXJ0QnVpbGRSYXRlIiwibWF4QnVpbGRSYXRlR3dZZWFyIiwiYmFja2xvZ0Zyb21Hcm91bmQiLCJiYWNrbG9nRnJvbUJ1aWxkb3V0IiwiYnVpbGRSYXRlRnJvbUJ1aWxkb3V0IiwiYnVpbGRSYXRlRnJvbVN1cHBseSIsImF2Z1dhaXRGcm9tR3JvdW5kIiwiYXZnV2FpdEZyb21CdWlsZG91dCIsInRpbWVUb1Bvd2VyWWVhcnMiLCJhdmdXYWl0RnJvbVN1cHBseSIsImNvbnNvbGUiLCJwaXBlbGluZUd3Iiwib3JiaXRNYXhEZXBsb3lhYmxlQ29tcHV0ZUdXQnlZZWFyIiwib3JiaXRhbEZlYXNpYmxlRm9yU2hhcmUiLCJtYXJrZXRBbmFseXNpcyIsIm1hcmtldCIsIm1hcmtldERlbWFuZCIsIm1hcmtldERlYnVnRGVtYW5kIiwiYnVpbGRvdXREZW1hbmQiLCJkZW1hbmROZXdHVyIsImNhcGFjaXR5R1ciLCJwaXBlbGluZUdXIiwicHVzaCIsImdlbmVyYXRlRmluYWxBbmFseXNpcyIsImJhc2VUcmFqZWN0b3J5IiwiYmFzZUNyb3Nzb3ZlciIsImJhc2VDcm9zc292ZXJFZmZlY3RpdmVQZmxvcCIsImJhc2VQYXJhbXMiLCJwYXJhbWV0ZXJzVG9UZXN0Iiwia2V5IiwidmFsdWVzIiwieWVhclRvTW9kaWZ5Iiwic2Vuc2l0aXZpdGllcyIsIm1hcCIsInAiLCJjcm9zc292ZXJZZWFycyIsInZhbCIsInRlc3RUcmFqZWN0b3J5IiwieSIsInZhbGlkWWVhcnMiLCJmaWx0ZXIiLCJtYXhEZWx0YSIsImltcGFjdCIsInBhcmFtZXRlciIsImJhc2VWYWx1ZSIsInRlc3RWYWx1ZXMiLCJzY2VuYXJpb3MiLCJkZXNjcmlwdGlvbiIsImtleUFzc3VtcHRpb25zIiwiY3Jvc3NvdmVyWWVhciIsInVzZVJhZEhhcmRDaGlwcyIsImdyb3VuZFNjZW5hcmlvIiwibWFya2V0Q29tcGFyaXNvbiIsInByb2plY3RlZFByaWNlcyIsIm9yYml0YWxCZWF0c1llYXIiLCJwcm9qZWN0ZWQiLCJwcm92aWRlciIsImN1cnJlbnRQcmljZSIsImN1cnJlbnRZZWFyIiwicHJvamVjdGVkRGVjbGluZSIsInNlbGVjdGVkU2NlbmFyaW8iLCJncm91bmRTY2VuYXJpb0xhYmVsIiwiY29uc3RyYWludE11bHRpcGxpZXIyMDQwIiwiYXNzdW1wdGlvbnMiLCJncmlkR3Jvd3RoUmF0ZSIsInRvRml4ZWQiLCJjb29saW5nR3Jvd3RoUmF0ZSIsImNvbnN0cmFpbnRDYXAiLCJsYXN0WWVhciIsImZpcnN0WWVhciIsImFsbENoZWNrcyIsInBhc3NlZCIsInZhbHVlIiwiY29zdEFjY291bnRpbmdFcnJvclBjdCIsImV4cGVjdGVkIiwiY2FwYWNpdHlGYWN0b3IiLCJ2YWxpZGF0aW9uIiwiY29zdEFjY291bnRpbmdFcnJvciIsInRyYWplY3RvcnlNb25vdG9uaWMiLCJwYXJhbWV0ZXJzSW5SYW5nZSIsImNyb3Nzb3ZlckNvbnNpc3RlbnQiLCJjcm9zc292ZXJZZWFyU3RhbmRhcmQiLCJwcmljZUF0Q3Jvc3NvdmVyT3JiaXRhbCIsInByaWNlQXRDcm9zc292ZXJHcm91bmQiLCJhY3RpdmVUb2dnbGVzIiwiZWxvblNjZW5hcmlvRW5hYmxlZCIsImdsb2JhbExhdGVuY3lSZXF1aXJlbWVudEVuYWJsZWQiLCJzcGFjZU1hbnVmYWN0dXJpbmdFbmFibGVkIiwiYWlXaW50ZXJFbmFibGVkIiwiYmFzZWxpbmVUcmFqZWN0b3J5IiwiYmFzZWxpbmVDcm9zc292ZXIiLCJzY2VuYXJpb0ltcGFjdCIsImN1cnJlbnRDcm9zc292ZXIiLCJjcm9zc292ZXJEZWx0YSIsImJhc2VQYXJhbXNGb3JNQyIsIm1vbnRlQ2FybG9SZXN1bHQiLCJ2ZXJzaW9uIiwiZ2VuZXJhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1bml0cyIsInBhcmFtZXRlcnMiLCJhbmFseXNpcyIsImNyb3Nzb3ZlciIsIm9yYml0YWxQcmljZSIsImdyb3VuZFByaWNlIiwibWFya2V0UG9zaXRpb24iLCJjcm9zc292ZXJEZXRhaWxzIiwic2Vuc2l0aXZpdHkiLCJiYXNlQ2FzZSIsIm9yYml0YWxQcmljZUF0Q3Jvc3NvdmVyIiwiZ3JvdW5kUHJpY2VBdENyb3Nzb3ZlciIsImNvbmZpZGVuY2UiLCJwMTAiLCJwNTAiLCJwOTAiLCJwcmljZUF0Q3Jvc3NvdmVyIiwibG93IiwibWlkIiwiaGlnaCIsInByb2JhYmlsaXR5QnlZZWFyIiwicmVndWxhdG9yeUltcGFjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/trajectory.ts\n"));

/***/ })

});