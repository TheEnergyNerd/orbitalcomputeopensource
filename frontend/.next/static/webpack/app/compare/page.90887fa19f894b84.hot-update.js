"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/compare/page",{

/***/ "(app-pages-browser)/./app/lib/model/ground_ramping_mobilization.ts":
/*!******************************************************!*\
  !*** ./app/lib/model/ground_ramping_mobilization.ts ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_MOBILIZATION_PARAMS: function() { return /* binding */ DEFAULT_MOBILIZATION_PARAMS; },\n/* harmony export */   calculateBuildRateGWyr: function() { return /* binding */ calculateBuildRateGWyr; },\n/* harmony export */   calculateDemandGW: function() { return /* binding */ calculateDemandGW; },\n/* harmony export */   calculatePriceResponsiveBuildRateGWyr: function() { return /* binding */ calculatePriceResponsiveBuildRateGWyr; },\n/* harmony export */   calculatePriceResponsiveDemandGW: function() { return /* binding */ calculatePriceResponsiveDemandGW; },\n/* harmony export */   stepMobilizationState: function() { return /* binding */ stepMobilizationState; }\n/* harmony export */ });\n/**\n * Ground Ramping Mobilization Model\n * \n * Models demand growth with price-responsive demand and buildout capacity\n * ramping with investment response. Tracks capacity evolution, pipeline, backlog,\n * and wait times.\n * \n * NEW: Price-responsive demand and investment-responsive buildout (replaces fixed anchors)\n */ /**\n * Calculate price-responsive demand GW\n * \n * NEW: Demand responds to prices, wait times, and orbital substitution\n * Replaces fixed anchors with economic feedback\n */ function calculatePriceResponsiveDemandGW(year, groundPricePerGpuHour, orbitalPricePerGpuHour, avgWaitYears, params) {\n    let pue = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1.3;\n    // Base demand with organic growth (tapered, not exponential forever)\n    const yearsFrom2025 = year - 2025;\n    const growthTaper = Math.tanh(yearsFrom2025 / 30); // Tapers after ~30 years\n    const baseDemand = params.baseDemand2025GW * Math.pow(1 + params.organicGrowthRate, yearsFrom2025 * growthTaper);\n    // Price elasticity: higher prices reduce demand\n    const baselinePrice = 3.50; // $/GPU-hr baseline\n    const priceRatio = groundPricePerGpuHour / baselinePrice;\n    const priceFactor = Math.pow(priceRatio, params.priceElasticity);\n    // Wait elasticity: longer waits reduce demand\n    const waitFactor = Math.exp(-avgWaitYears * params.waitElasticity / 5);\n    // Orbital substitution: if orbital cheaper, demand shifts\n    const orbitalAdvantage = groundPricePerGpuHour / Math.max(orbitalPricePerGpuHour, 0.01);\n    const substitutionFactor = orbitalAdvantage > params.orbitalSubstitutionThreshold ? 1 / (1 + 0.5 * (orbitalAdvantage - params.orbitalSubstitutionThreshold)) : 1.0;\n    let demandGW = baseDemand * priceFactor * waitFactor * substitutionFactor;\n    // Apply PUE if demand is IT load (not facility load)\n    // Note: This function assumes facility load, so multiply by PUE if needed\n    // For now, return facility load (demand already includes PUE in baseDemand2025GW)\n    return Math.max(0, demandGW);\n}\n/**\n * Legacy function: Calculate demand GW using piecewise exponential to hit anchors\n * \n * DEPRECATED: Use calculatePriceResponsiveDemandGW instead\n * Kept for backward compatibility\n */ function calculateDemandGW(year, params) {\n    let pue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1.3;\n    const { demandAnchorsGW, demandIsFacilityLoad, demandCurve } = params;\n    const demand2025 = demandAnchorsGW[2025];\n    const demand2040 = demandAnchorsGW[2040];\n    const demand2060 = demandAnchorsGW[2060];\n    if (demandCurve !== \"piecewise_exponential\") {\n        throw new Error(\"Unsupported demandCurve: \".concat(demandCurve, \". Only 'piecewise_exponential' is supported.\"));\n    }\n    if (year < 2025) {\n        return demand2025;\n    }\n    let demandGW;\n    if (year <= 2040) {\n        // Phase 1: 2025-2040\n        // r1 = ln(demand2040 / demand2025) / (2040-2025)\n        const r1 = Math.log(demand2040 / demand2025) / (2040 - 2025);\n        const yearsFrom2025 = year - 2025;\n        demandGW = demand2025 * Math.exp(r1 * yearsFrom2025);\n    } else {\n        // Phase 2: 2040-2060\n        // r2 = ln(demand2060 / demand2040) / (2060-2040)\n        const r2 = Math.log(demand2060 / demand2040) / (2060 - 2040);\n        const yearsFrom2040 = year - 2040;\n        demandGW = demand2040 * Math.exp(r2 * yearsFrom2040);\n    }\n    // Apply PUE if demand is IT load (not facility load)\n    if (!demandIsFacilityLoad) {\n        demandGW = demandGW * pue;\n    }\n    // Hard asserts in dev mode\n    if (true) {\n        if (year === 2040) {\n            const actual2040 = demandGW;\n            const error2040 = Math.abs(actual2040 - demand2040) / demand2040;\n            if (error2040 >= 0.03) {\n                throw new Error(\"[DEMAND ANCHOR FAIL] demandGw(2040)=\".concat(actual2040.toFixed(2), \" GW, \") + \"expected=\".concat(demand2040, \" GW, error=\").concat((error2040 * 100).toFixed(2), \"% >= 3%\"));\n            }\n        }\n        if (year === 2060) {\n            if (demandGW < 2000) {\n                throw new Error(\"[DEMAND ANCHOR FAIL] demandGw(2060)=\".concat(demandGW.toFixed(2), \" GW < 2000 GW. \") + \"Must be >= 2000 GW (multi-TW target).\");\n            }\n        }\n    }\n    return demandGW;\n}\n/**\n * Calculate price-responsive buildout rate\n * \n * NEW: Buildout responds to margins and backlog\n * Replaces fixed anchors with investment feedback\n */ function calculatePriceResponsiveBuildRateGWyr(year, prevBuildRate, groundMargin, backlogGW, params) {\n    // Base growth (supply chain improvement)\n    const yearsFrom2025 = year - 2025;\n    const baseGrowth = Math.pow(1.03, yearsFrom2025); // 3% organic improvement\n    const baseBuildRate = params.baseBuildRate2025GWyr * baseGrowth;\n    // Investment response: higher margins attract more capital\n    const baselineMargin = 0.20; // 20% baseline margin\n    const marginRatio = groundMargin / baselineMargin;\n    const investmentMultiplier = 1 + params.investmentElasticity * Math.max(0, marginRatio - 1);\n    // Backlog response: higher backlog attracts more investment\n    const backlogMultiplier = 1 + params.backlogResponseK * Math.min(1, backlogGW / 100);\n    // Target build rate\n    let targetRate = baseBuildRate * investmentMultiplier * backlogMultiplier;\n    // Physical ceiling\n    targetRate = Math.min(targetRate, params.maxBuildRateGWyr);\n    // Ramp limit (can't increase faster than 25%/year)\n    const maxRate = prevBuildRate * (1 + params.rampLimitPerYear);\n    const minRate = prevBuildRate * (1 - params.rampLimitPerYear * 0.5); // Slower to decrease\n    targetRate = Math.max(minRate, Math.min(maxRate, targetRate));\n    return Math.max(0, targetRate);\n}\n/**\n * Legacy function: Smooth interpolation for buildout anchors\n * \n * DEPRECATED: Use calculatePriceResponsiveBuildRateGWyr instead\n * Kept for backward compatibility\n */ function calculateBuildRateGWyr(year, params) {\n    const { buildoutAnchorsGWyr, buildoutSmoothingYears } = params;\n    const anchors = buildoutAnchorsGWyr;\n    // Find surrounding anchors\n    const anchorYears = Object.keys(anchors).map(Number).sort((a, b)=>a - b);\n    // Before first anchor: use first anchor value\n    if (year <= anchorYears[0]) {\n        return anchors[anchorYears[0]];\n    }\n    // After last anchor: use last anchor value\n    if (year >= anchorYears[anchorYears.length - 1]) {\n        return anchors[anchorYears[anchorYears.length - 1]];\n    }\n    // Find surrounding anchors\n    let lowerYear = anchorYears[0];\n    let upperYear = anchorYears[anchorYears.length - 1];\n    for(let i = 0; i < anchorYears.length - 1; i++){\n        if (year >= anchorYears[i] && year <= anchorYears[i + 1]) {\n            lowerYear = anchorYears[i];\n            upperYear = anchorYears[i + 1];\n            break;\n        }\n    }\n    const lowerRate = anchors[lowerYear];\n    const upperRate = anchors[upperYear];\n    // Exponential interpolation for buildout ramp\n    const t = (year - lowerYear) / (upperYear - lowerYear);\n    const buildRate = lowerRate * Math.pow(upperRate / lowerRate, t);\n    // Apply smoothing: moving average over smoothing window\n    if (buildoutSmoothingYears > 0) {\n        const smoothingWindow = buildoutSmoothingYears;\n        let smoothedSum = buildRate;\n        let count = 1;\n        // Helper function to calculate unsmoothed rate\n        const getUnsmoothedRate = (y)=>{\n            if (y <= anchorYears[0]) return anchors[anchorYears[0]];\n            if (y >= anchorYears[anchorYears.length - 1]) return anchors[anchorYears[anchorYears.length - 1]];\n            let lower = anchorYears[0];\n            let upper = anchorYears[anchorYears.length - 1];\n            for(let i = 0; i < anchorYears.length - 1; i++){\n                if (y >= anchorYears[i] && y <= anchorYears[i + 1]) {\n                    lower = anchorYears[i];\n                    upper = anchorYears[i + 1];\n                    break;\n                }\n            }\n            const lowerRate = anchors[lower];\n            const upperRate = anchors[upper];\n            const t = (y - lower) / (upper - lower);\n            return lowerRate * Math.pow(upperRate / lowerRate, t);\n        };\n        for(let offset = 1; offset <= Math.floor(smoothingWindow / 2); offset++){\n            const prevYear = year - offset;\n            const nextYear = year + offset;\n            if (prevYear >= anchorYears[0]) {\n                const prevRate = getUnsmoothedRate(prevYear);\n                smoothedSum += prevRate;\n                count++;\n            }\n            if (nextYear <= anchorYears[anchorYears.length - 1]) {\n                const nextRate = getUnsmoothedRate(nextYear);\n                smoothedSum += nextRate;\n                count++;\n            }\n        }\n        return smoothedSum / count;\n    }\n    return buildRate;\n}\n/**\n * Calculate bottleneck rate from anchors (same interpolation as buildout)\n */ function calculateBottleneckRateGWyr(year, anchors) {\n    const anchorYears = [\n        2025,\n        2030,\n        2040,\n        2060\n    ];\n    // Before first anchor: use first anchor value\n    if (year <= anchorYears[0]) {\n        return anchors[2025];\n    }\n    // After last anchor: use last anchor value\n    if (year >= anchorYears[anchorYears.length - 1]) {\n        return anchors[2060];\n    }\n    // Find surrounding anchors\n    let lowerYear = anchorYears[0];\n    let upperYear = anchorYears[anchorYears.length - 1];\n    for(let i = 0; i < anchorYears.length - 1; i++){\n        if (year >= anchorYears[i] && year <= anchorYears[i + 1]) {\n            lowerYear = anchorYears[i];\n            upperYear = anchorYears[i + 1];\n            break;\n        }\n    }\n    const lowerRate = anchors[lowerYear];\n    const upperRate = anchors[upperYear];\n    // Exponential interpolation\n    const t = (year - lowerYear) / (upperYear - lowerYear);\n    return lowerRate * Math.pow(upperRate / lowerRate, t);\n}\n/**\n * Step mobilization state forward one year\n */ function stepMobilizationState(prevState, params, year) {\n    let pue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1.3, retirementsGW = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, orbitalSubstitutionGW = arguments.length > 5 ? arguments[5] : void 0, responsiveDemandGW // Optional: responsive demand (overrides hardcoded calculateDemandGW)\n     = arguments.length > 6 ? arguments[6] : void 0;\n    // Calculate demand: use responsive demand if provided, otherwise use hardcoded\n    const demandGW = responsiveDemandGW !== undefined ? responsiveDemandGW * pue // Convert IT load to facility load\n     : calculateDemandGW(year, params, pue);\n    // Fix 2: Calculate demandGWPrev correctly (don't use same responsiveDemandGW for both years)\n    let demandGWPrev;\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.demandGW) !== undefined) {\n        demandGWPrev = prevState.demandGW;\n    } else if (responsiveDemandGW !== undefined) {\n        // For first year, estimate previous year's demand using hardcoded calculation\n        // Don't use same responsiveDemandGW for both current and previous year\n        demandGWPrev = calculateDemandGW(year - 1, params, pue);\n    } else {\n        demandGWPrev = calculateDemandGW(year - 1, params, pue);\n    }\n    const demandNewGW = Math.max(0, demandGW - demandGWPrev);\n    // Calculate build rate candidate (from anchors)\n    let buildRateCandidate = calculateBuildRateGWyr(year, params);\n    // NEW: If ground demand is falling (due to orbital substitution or price elasticity),\n    // buildout should slow down (no one builds capacity for declining market)\n    const demandGrowthRateActual = (prevState === null || prevState === void 0 ? void 0 : prevState.demandGW) ? (demandGW - prevState.demandGW) / Math.max(prevState.demandGW, 1) : 0;\n    if (demandGrowthRateActual < 0) {\n        // Demand is shrinking - reduce buildout\n        const contractionFactor = Math.max(0.5, 1 + demandGrowthRateActual * 2); // At most 50% reduction\n        buildRateCandidate = buildRateCandidate * contractionFactor; // Reassign to let variable\n    }\n    var _params_bottleneckMode;\n    // Apply bottleneck constraints if enabled\n    const bottleneckMode = (_params_bottleneckMode = params.bottleneckMode) !== null && _params_bottleneckMode !== void 0 ? _params_bottleneckMode : \"min_of_bottlenecks\";\n    let buildRateGWyr = buildRateCandidate;\n    let bottleneckRateGWyr;\n    let limitingBottleneck = \"candidate\";\n    if (bottleneckMode === \"min_of_bottlenecks\" && params.bottleneckAnchorsGWyr) {\n        const { transformers, substations, tx, generation } = params.bottleneckAnchorsGWyr;\n        const transformersRate = calculateBottleneckRateGWyr(year, transformers);\n        const substationsRate = calculateBottleneckRateGWyr(year, substations);\n        const txRate = calculateBottleneckRateGWyr(year, tx);\n        const generationRate = calculateBottleneckRateGWyr(year, generation);\n        // Find minimum bottleneck\n        bottleneckRateGWyr = Math.min(transformersRate, substationsRate, txRate, generationRate);\n        // Determine which bottleneck is limiting\n        if (bottleneckRateGWyr === transformersRate) {\n            limitingBottleneck = \"transformers\";\n        } else if (bottleneckRateGWyr === substationsRate) {\n            limitingBottleneck = \"substations\";\n        } else if (bottleneckRateGWyr === txRate) {\n            limitingBottleneck = \"tx\";\n        } else if (bottleneckRateGWyr === generationRate) {\n            limitingBottleneck = \"generation\";\n        }\n        // Effective build rate is minimum of candidate and bottleneck\n        buildRateGWyr = Math.min(buildRateCandidate, bottleneckRateGWyr);\n    } else {\n        limitingBottleneck = \"none\";\n    }\n    var _params_rampLimitFracPerYear;\n    // Apply ramp limiter (prevent sudden jumps)\n    const rampLimitFrac = (_params_rampLimitFracPerYear = params.rampLimitFracPerYear) !== null && _params_rampLimitFracPerYear !== void 0 ? _params_rampLimitFracPerYear : 0.25;\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.buildRateGWyr) !== undefined) {\n        const prevRate = prevState.buildRateGWyr;\n        const minRate = prevRate * (1 - rampLimitFrac);\n        const maxRate = prevRate * (1 + rampLimitFrac);\n        buildRateGWyr = Math.max(minRate, Math.min(maxRate, buildRateGWyr));\n    }\n    var _prevState_capacityGW;\n    // Calculate capacity evolution\n    // capacityGw(t) = capacityGw(t-1) + buildRateGwYear(t) - retirementsGw(t)\n    const capacityGWPrev = (_prevState_capacityGW = prevState === null || prevState === void 0 ? void 0 : prevState.capacityGW) !== null && _prevState_capacityGW !== void 0 ? _prevState_capacityGW : 0;\n    const capacityGW = capacityGWPrev + buildRateGWyr - retirementsGW;\n    // Calculate pipeline\n    // pipelineGw(t) = buildRateGwYear(t) * pipelineLeadTimeYears * pipelineFillFrac\n    const pipelineGW = buildRateGWyr * params.pipelineLeadTimeYears * params.pipelineFillFrac;\n    // Calculate backlog\n    // backlogGw(t) = max(0, backlogGw(t-1) + demandNewGw(t) - buildableGw(t) - implicitBacklogDrain)\n    // NEW: Backlog can also be satisfied by demand shifting to orbital\n    // When demand shifts to orbital, \"implicit backlog drain\" occurs\n    // because customers who were waiting for ground now use orbital instead\n    // Fix 1: Initialize with baseline backlog if no previous state\n    const INITIAL_BACKLOG_GW = 50; // Same as queue model\n    var _prevState_backlogGW;\n    const backlogGWPrev = (_prevState_backlogGW = prevState === null || prevState === void 0 ? void 0 : prevState.backlogGW) !== null && _prevState_backlogGW !== void 0 ? _prevState_backlogGW : INITIAL_BACKLOG_GW;\n    const buildableGW = buildRateGWyr;\n    const implicitBacklogDrain = (orbitalSubstitutionGW !== null && orbitalSubstitutionGW !== void 0 ? orbitalSubstitutionGW : 0) * 0.5; // 50% of shifted demand was in backlog\n    // NEW: Backlog can drain when demand falls below buildout\n    const netDemandChange = demandNewGW - buildableGW;\n    var _prevState_demandGW;\n    // If orbital substitution caused demand to drop, backlog drains faster\n    const demandDropFromPrev = Math.max(0, ((_prevState_demandGW = prevState === null || prevState === void 0 ? void 0 : prevState.demandGW) !== null && _prevState_demandGW !== void 0 ? _prevState_demandGW : demandGW) - demandGW);\n    const substitutionDrain = demandDropFromPrev * 0.3; // 30% of demand drop was from backlog\n    const backlogGW = Math.max(0, backlogGWPrev + netDemandChange - substitutionDrain - implicitBacklogDrain);\n    // Hard assert: If demandNewGw(t) > buildRateGwYear(t), backlogGw must increase\n    if (true) {\n        if (demandNewGW > buildRateGWyr && backlogGW <= backlogGWPrev) {\n            throw new Error(\"[BUILDOUT INVARIANT] Year \".concat(year, \": demandNewGW=\").concat(demandNewGW.toFixed(2), \" > \") + \"buildRateGWyr=\".concat(buildRateGWyr.toFixed(2), \", but backlogGW=\").concat(backlogGW.toFixed(2), \" \") + \"<= prevBacklogGW=\".concat(backlogGWPrev.toFixed(2), \". Backlog must increase.\"));\n        }\n    }\n    // Calculate average wait time\n    // avgWaitYears(t) = backlogGw(t) / max(buildRateGwYear(t), 1e-9)\n    const EPS = 1e-9;\n    const avgWaitYears = backlogGW / Math.max(buildRateGWyr, EPS);\n    // Calculate growth rate (for debug)\n    let demandGrowthRate;\n    if (year <= 2040) {\n        demandGrowthRate = Math.log(params.demandAnchorsGW[2040] / params.demandAnchorsGW[2025]) / 15;\n    } else {\n        demandGrowthRate = Math.log(params.demandAnchorsGW[2060] / params.demandAnchorsGW[2040]) / 20;\n    }\n    return {\n        year,\n        demandGW,\n        demandNewGW,\n        buildRateGWyr,\n        capacityGW,\n        pipelineGW,\n        backlogGW,\n        avgWaitYears,\n        demandGrowthRate,\n        buildoutSmoothFactor: params.buildoutSmoothingYears,\n        bottleneckRateGWyr,\n        limitingBottleneck,\n        buildRateCandidate\n    };\n}\n/**\n * Default mobilization scenario parameters\n */ const DEFAULT_MOBILIZATION_PARAMS = {\n    demandAnchorsGW: {\n        2025: 120,\n        2040: 450,\n        2060: 3000\n    },\n    demandCurve: \"piecewise_exponential\",\n    demandIsFacilityLoad: true,\n    buildoutAnchorsGWyr: {\n        2025: 25,\n        2030: 60,\n        2040: 140,\n        2060: 220\n    },\n    buildoutSmoothingYears: 3,\n    pipelineLeadTimeYears: 3,\n    pipelineFillFrac: 1.5,\n    bottleneckMode: \"min_of_bottlenecks\",\n    bottleneckAnchorsGWyr: {\n        transformers: {\n            2025: 30,\n            2030: 50,\n            2040: 100,\n            2060: 180\n        },\n        substations: {\n            2025: 35,\n            2030: 55,\n            2040: 110,\n            2060: 200\n        },\n        tx: {\n            2025: 40,\n            2030: 65,\n            2040: 130,\n            2060: 250\n        },\n        generation: {\n            2025: 50,\n            2030: 80,\n            2040: 160,\n            2060: 300\n        }\n    },\n    rampLimitFracPerYear: 0.25\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX3JhbXBpbmdfbW9iaWxpemF0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Ozs7OztDQVFDLEdBbUVEOzs7OztDQUtDLEdBQ00sU0FBU0EsaUNBQ2RDLElBQVksRUFDWkMscUJBQTZCLEVBQzdCQyxzQkFBOEIsRUFDOUJDLFlBQW9CLEVBQ3BCQyxNQUFvQjtRQUNwQkMsTUFBQUEsaUVBQWM7SUFFZCxxRUFBcUU7SUFDckUsTUFBTUMsZ0JBQWdCTixPQUFPO0lBQzdCLE1BQU1PLGNBQWNDLEtBQUtDLElBQUksQ0FBQ0gsZ0JBQWdCLEtBQUsseUJBQXlCO0lBQzVFLE1BQU1JLGFBQWFOLE9BQU9PLGdCQUFnQixHQUFHSCxLQUFLSSxHQUFHLENBQUMsSUFBSVIsT0FBT1MsaUJBQWlCLEVBQUVQLGdCQUFnQkM7SUFFcEcsZ0RBQWdEO0lBQ2hELE1BQU1PLGdCQUFnQixNQUFNLG9CQUFvQjtJQUNoRCxNQUFNQyxhQUFhZCx3QkFBd0JhO0lBQzNDLE1BQU1FLGNBQWNSLEtBQUtJLEdBQUcsQ0FBQ0csWUFBWVgsT0FBT2EsZUFBZTtJQUUvRCw4Q0FBOEM7SUFDOUMsTUFBTUMsYUFBYVYsS0FBS1csR0FBRyxDQUFDLENBQUNoQixlQUFlQyxPQUFPZ0IsY0FBYyxHQUFHO0lBRXBFLDBEQUEwRDtJQUMxRCxNQUFNQyxtQkFBbUJwQix3QkFBd0JPLEtBQUtjLEdBQUcsQ0FBQ3BCLHdCQUF3QjtJQUNsRixNQUFNcUIscUJBQXFCRixtQkFBbUJqQixPQUFPb0IsNEJBQTRCLEdBQzdFLElBQUssS0FBSSxNQUFPSCxDQUFBQSxtQkFBbUJqQixPQUFPb0IsNEJBQTRCLEtBQ3RFO0lBRUosSUFBSUMsV0FBV2YsYUFBYU0sY0FBY0UsYUFBYUs7SUFFdkQscURBQXFEO0lBQ3JELDBFQUEwRTtJQUMxRSxrRkFBa0Y7SUFFbEYsT0FBT2YsS0FBS2MsR0FBRyxDQUFDLEdBQUdHO0FBQ3JCO0FBRUE7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cGFjazovL19OX0UvLi9hcHAvbGliL21vZGVsL2dyb3VuZF9yYW1waW5nX21vYmlsaXphdGlvbi50cz80NDU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR3JvdW5kIFJhbXBpbmcgTW9iaWxpemF0aW9uIE1vZGVsXG4gKiBcbiAqIE1vZGVscyBkZW1hbmQgZ3Jvd3RoIHdpdGggcHJpY2UtcmVzcG9uc2l2ZSBkZW1hbmQgYW5kIGJ1aWxkb3V0IGNhcGFjaXR5XG4gKiByYW1waW5nIHdpdGggaW52ZXN0bWVudCByZXNwb25zZS4gVHJhY2tzIGNhcGFjaXR5IGV2b2x1dGlvbiwgcGlwZWxpbmUsIGJhY2tsb2csXG4gKiBhbmQgd2FpdCB0aW1lcy5cbiAqIFxuICogTkVXOiBQcmljZS1yZXNwb25zaXZlIGRlbWFuZCBhbmQgaW52ZXN0bWVudC1yZXNwb25zaXZlIGJ1aWxkb3V0IChyZXBsYWNlcyBmaXhlZCBhbmNob3JzKVxuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVtYW5kUGFyYW1zIHtcbiAgYmFzZURlbWFuZDIwMjVHVzogbnVtYmVyOyAgICAgICAgLy8gMTIwIEdXXG4gIG9yZ2FuaWNHcm93dGhSYXRlOiBudW1iZXI7ICAgICAgIC8vIDAuMTAgKDEwJSBDQUdSIGJhc2UpXG4gIHByaWNlRWxhc3RpY2l0eTogbnVtYmVyOyAgICAgICAgIC8vIC0wLjMgKDMwJSBkZW1hbmQgZHJvcCBwZXIgMTAwJSBwcmljZSBpbmNyZWFzZSlcbiAgd2FpdEVsYXN0aWNpdHk6IG51bWJlcjsgICAgICAgICAgLy8gLTAuMiAoMjAlIGRlbWFuZCBkcm9wIHBlciA1eXIgd2FpdClcbiAgb3JiaXRhbFN1YnN0aXR1dGlvblRocmVzaG9sZDogbnVtYmVyOyAvLyBQcmljZSByYXRpbyBhdCB3aGljaCBkZW1hbmQgc2hpZnRzIHRvIG9yYml0YWwgKGRlZmF1bHQgMS4yID0gMjAlIGNoZWFwZXIpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnVpbGRvdXRQYXJhbXMge1xuICBiYXNlQnVpbGRSYXRlMjAyNUdXeXI6IG51bWJlcjsgICAvLyAyNSBHVy95clxuICBtYXhCdWlsZFJhdGVHV3lyOiBudW1iZXI7ICAgICAgICAvLyAxNTAgR1cveXIgcGh5c2ljYWwgbGltaXRcbiAgaW52ZXN0bWVudEVsYXN0aWNpdHk6IG51bWJlcjsgICAgIC8vIDAuNSAoNTAlIG1vcmUgaW52ZXN0bWVudCBwZXIgMTAwJSBtYXJnaW4gaW5jcmVhc2UpXG4gIHJhbXBMaW1pdFBlclllYXI6IG51bWJlcjsgICAgICAgICAvLyAwLjI1ICgyNSUgbWF4IGluY3JlYXNlIHBlciB5ZWFyKVxuICBiYWNrbG9nUmVzcG9uc2VLOiBudW1iZXI7ICAgICAgICAgLy8gMC4zIChob3cgZmFzdCBidWlsZG91dCByZXNwb25kcyB0byBiYWNrbG9nKVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vYmlsaXphdGlvblNjZW5hcmlvUGFyYW1zIHtcbiAgZGVtYW5kQW5jaG9yc0dXOiB7XG4gICAgMjAyNTogbnVtYmVyO1xuICAgIDIwNDA6IG51bWJlcjtcbiAgICAyMDYwOiBudW1iZXI7XG4gIH07XG4gIGRlbWFuZEN1cnZlOiAncGllY2V3aXNlX2V4cG9uZW50aWFsJzsgLy8gQ3VydmUgdHlwZSAob25seSBwaWVjZXdpc2VfZXhwb25lbnRpYWwgc3VwcG9ydGVkKVxuICBkZW1hbmRJc0ZhY2lsaXR5TG9hZDogYm9vbGVhbjsgLy8gSWYgdHJ1ZSwgaW5jbHVkZXMgUFVFOyBpZiBmYWxzZSwgbXVsdGlwbHkgYnkgUFVFIGxhdGVyXG4gIGJ1aWxkb3V0QW5jaG9yc0dXeXI6IHtcbiAgICAyMDI1OiBudW1iZXI7XG4gICAgMjAzMDogbnVtYmVyO1xuICAgIDIwNDA6IG51bWJlcjtcbiAgICAyMDYwOiBudW1iZXI7XG4gIH07XG4gIGJ1aWxkb3V0U21vb3RoaW5nWWVhcnM6IG51bWJlcjsgLy8gU21vb3RoaW5nIHdpbmRvdyBmb3IgYnVpbGRvdXQgaW50ZXJwb2xhdGlvblxuICBwaXBlbGluZUxlYWRUaW1lWWVhcnM6IG51bWJlcjsgLy8gTGVhZCB0aW1lIGZvciBwaXBlbGluZSBjYWxjdWxhdGlvblxuICBwaXBlbGluZUZpbGxGcmFjOiBudW1iZXI7IC8vIFBpcGVsaW5lIGZpbGwgZnJhY3Rpb24gKHBpcGVsaW5lR1cgPSBsZWFkVGltZSAqIGJ1aWxkUmF0ZSAqIGZpbGxGcmFjKVxuICAvLyBCb3R0bGVuZWNrIGNvbnN0cmFpbnRzXG4gIGJvdHRsZW5lY2tNb2RlPzogJ29mZicgfCAnbWluX29mX2JvdHRsZW5lY2tzJzsgLy8gRGVmYXVsdCAnbWluX29mX2JvdHRsZW5lY2tzJ1xuICBib3R0bGVuZWNrQW5jaG9yc0dXeXI/OiB7XG4gICAgdHJhbnNmb3JtZXJzOiB7IDIwMjU6IG51bWJlcjsgMjAzMDogbnVtYmVyOyAyMDQwOiBudW1iZXI7IDIwNjA6IG51bWJlciB9O1xuICAgIHN1YnN0YXRpb25zOiB7IDIwMjU6IG51bWJlcjsgMjAzMDogbnVtYmVyOyAyMDQwOiBudW1iZXI7IDIwNjA6IG51bWJlciB9O1xuICAgIHR4OiB7IDIwMjU6IG51bWJlcjsgMjAzMDogbnVtYmVyOyAyMDQwOiBudW1iZXI7IDIwNjA6IG51bWJlciB9O1xuICAgIGdlbmVyYXRpb246IHsgMjAyNTogbnVtYmVyOyAyMDMwOiBudW1iZXI7IDIwNDA6IG51bWJlcjsgMjA2MDogbnVtYmVyIH07XG4gIH07XG4gIHJhbXBMaW1pdEZyYWNQZXJZZWFyPzogbnVtYmVyOyAvLyBNYXggZnJhY3Rpb25hbCBjaGFuZ2UgcGVyIHllYXIgKGRlZmF1bHQgMC4yNSA9IDI1JSlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb2JpbGl6YXRpb25TdGF0ZSB7XG4gIHllYXI6IG51bWJlcjtcbiAgZGVtYW5kR1c6IG51bWJlcjsgLy8gVG90YWwgZGVtYW5kIChJVCBvciBmYWNpbGl0eSBsb2FkKVxuICBkZW1hbmROZXdHVzogbnVtYmVyOyAvLyBJbmNyZW1lbnRhbCBkZW1hbmQgdGhpcyB5ZWFyXG4gIGJ1aWxkUmF0ZUdXeXI6IG51bWJlcjsgLy8gQnVpbGQgcmF0ZSB0aGlzIHllYXIgKEdXL3llYXIpXG4gIGNhcGFjaXR5R1c6IG51bWJlcjsgLy8gQ3VtdWxhdGl2ZSBjYXBhY2l0eSBidWlsdFxuICBwaXBlbGluZUdXOiBudW1iZXI7IC8vIFBpcGVsaW5lIGNhcGFjaXR5ICh1bmRlciBjb25zdHJ1Y3Rpb24pXG4gIGJhY2tsb2dHVzogbnVtYmVyOyAvLyBCYWNrbG9nIHdhaXRpbmcgdG8gYmUgYnVpbHRcbiAgYXZnV2FpdFllYXJzOiBudW1iZXI7IC8vIEF2ZXJhZ2Ugd2FpdCB0aW1lIChiYWNrbG9nIC8gYnVpbGRSYXRlKVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vYmlsaXphdGlvblJlc3VsdCBleHRlbmRzIE1vYmlsaXphdGlvblN0YXRlIHtcbiAgLy8gQWRkaXRpb25hbCBkZWJ1ZyBmaWVsZHNcbiAgZGVtYW5kR3Jvd3RoUmF0ZTogbnVtYmVyOyAvLyBDdXJyZW50IGdyb3d0aCByYXRlIChyMSBvciByMilcbiAgYnVpbGRvdXRTbW9vdGhGYWN0b3I6IG51bWJlcjsgLy8gU21vb3RoaW5nIGZhY3RvciBhcHBsaWVkXG4gIC8vIEJvdHRsZW5lY2sgZGVidWcgZmllbGRzXG4gIGJvdHRsZW5lY2tSYXRlR1d5cj86IG51bWJlcjsgLy8gRWZmZWN0aXZlIGJvdHRsZW5lY2sgcmF0ZSAobWluIG9mIGFsbCBib3R0bGVuZWNrcylcbiAgbGltaXRpbmdCb3R0bGVuZWNrPzogJ3RyYW5zZm9ybWVycycgfCAnc3Vic3RhdGlvbnMnIHwgJ3R4JyB8ICdnZW5lcmF0aW9uJyB8ICdjYW5kaWRhdGUnIHwgJ25vbmUnOyAvLyBXaGljaCBib3R0bGVuZWNrIGlzIGxpbWl0aW5nXG4gIGJ1aWxkUmF0ZUNhbmRpZGF0ZT86IG51bWJlcjsgLy8gT3JpZ2luYWwgYnVpbGQgcmF0ZSBiZWZvcmUgYm90dGxlbmVjay9yYW1wIGxpbWl0c1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBwcmljZS1yZXNwb25zaXZlIGRlbWFuZCBHV1xuICogXG4gKiBORVc6IERlbWFuZCByZXNwb25kcyB0byBwcmljZXMsIHdhaXQgdGltZXMsIGFuZCBvcmJpdGFsIHN1YnN0aXR1dGlvblxuICogUmVwbGFjZXMgZml4ZWQgYW5jaG9ycyB3aXRoIGVjb25vbWljIGZlZWRiYWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVQcmljZVJlc3BvbnNpdmVEZW1hbmRHVyhcbiAgeWVhcjogbnVtYmVyLFxuICBncm91bmRQcmljZVBlckdwdUhvdXI6IG51bWJlcixcbiAgb3JiaXRhbFByaWNlUGVyR3B1SG91cjogbnVtYmVyLFxuICBhdmdXYWl0WWVhcnM6IG51bWJlcixcbiAgcGFyYW1zOiBEZW1hbmRQYXJhbXMsXG4gIHB1ZTogbnVtYmVyID0gMS4zXG4pOiBudW1iZXIge1xuICAvLyBCYXNlIGRlbWFuZCB3aXRoIG9yZ2FuaWMgZ3Jvd3RoICh0YXBlcmVkLCBub3QgZXhwb25lbnRpYWwgZm9yZXZlcilcbiAgY29uc3QgeWVhcnNGcm9tMjAyNSA9IHllYXIgLSAyMDI1O1xuICBjb25zdCBncm93dGhUYXBlciA9IE1hdGgudGFuaCh5ZWFyc0Zyb20yMDI1IC8gMzApOyAvLyBUYXBlcnMgYWZ0ZXIgfjMwIHllYXJzXG4gIGNvbnN0IGJhc2VEZW1hbmQgPSBwYXJhbXMuYmFzZURlbWFuZDIwMjVHVyAqIE1hdGgucG93KDEgKyBwYXJhbXMub3JnYW5pY0dyb3d0aFJhdGUsIHllYXJzRnJvbTIwMjUgKiBncm93dGhUYXBlcik7XG4gIFxuICAvLyBQcmljZSBlbGFzdGljaXR5OiBoaWdoZXIgcHJpY2VzIHJlZHVjZSBkZW1hbmRcbiAgY29uc3QgYmFzZWxpbmVQcmljZSA9IDMuNTA7IC8vICQvR1BVLWhyIGJhc2VsaW5lXG4gIGNvbnN0IHByaWNlUmF0aW8gPSBncm91bmRQcmljZVBlckdwdUhvdXIgLyBiYXNlbGluZVByaWNlO1xuICBjb25zdCBwcmljZUZhY3RvciA9IE1hdGgucG93KHByaWNlUmF0aW8sIHBhcmFtcy5wcmljZUVsYXN0aWNpdHkpO1xuICBcbiAgLy8gV2FpdCBlbGFzdGljaXR5OiBsb25nZXIgd2FpdHMgcmVkdWNlIGRlbWFuZFxuICBjb25zdCB3YWl0RmFjdG9yID0gTWF0aC5leHAoLWF2Z1dhaXRZZWFycyAqIHBhcmFtcy53YWl0RWxhc3RpY2l0eSAvIDUpO1xuICBcbiAgLy8gT3JiaXRhbCBzdWJzdGl0dXRpb246IGlmIG9yYml0YWwgY2hlYXBlciwgZGVtYW5kIHNoaWZ0c1xuICBjb25zdCBvcmJpdGFsQWR2YW50YWdlID0gZ3JvdW5kUHJpY2VQZXJHcHVIb3VyIC8gTWF0aC5tYXgob3JiaXRhbFByaWNlUGVyR3B1SG91ciwgMC4wMSk7XG4gIGNvbnN0IHN1YnN0aXR1dGlvbkZhY3RvciA9IG9yYml0YWxBZHZhbnRhZ2UgPiBwYXJhbXMub3JiaXRhbFN1YnN0aXR1dGlvblRocmVzaG9sZCBcbiAgICA/IDEgLyAoMSArIDAuNSAqIChvcmJpdGFsQWR2YW50YWdlIC0gcGFyYW1zLm9yYml0YWxTdWJzdGl0dXRpb25UaHJlc2hvbGQpKVxuICAgIDogMS4wO1xuICBcbiAgbGV0IGRlbWFuZEdXID0gYmFzZURlbWFuZCAqIHByaWNlRmFjdG9yICogd2FpdEZhY3RvciAqIHN1YnN0aXR1dGlvbkZhY3RvcjtcbiAgXG4gIC8vIEFwcGx5IFBVRSBpZiBkZW1hbmQgaXMgSVQgbG9hZCAobm90IGZhY2lsaXR5IGxvYWQpXG4gIC8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBmYWNpbGl0eSBsb2FkLCBzbyBtdWx0aXBseSBieSBQVUUgaWYgbmVlZGVkXG4gIC8vIEZvciBub3csIHJldHVybiBmYWNpbGl0eSBsb2FkIChkZW1hbmQgYWxyZWFkeSBpbmNsdWRlcyBQVUUgaW4gYmFzZURlbWFuZDIwMjVHVylcbiAgXG4gIHJldHVybiBNYXRoLm1heCgwLCBkZW1hbmRHVyk7XG59XG5cbi8qKlxuICogTGVnYWN5IGZ1bmN0aW9uOiBDYWxjdWxhdGUgZGVtYW5kIEdXIHVzaW5nIHBpZWNld2lzZSBleHBvbmVudGlhbCB0byBoaXQgYW5jaG9yc1xuICogXG4gKiBERVBSRUNBVEVEOiBVc2UgY2FsY3VsYXRlUHJpY2VSZXNwb25zaXZlRGVtYW5kR1cgaW5zdGVhZFxuICogS2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRGVtYW5kR1coXG4gIHllYXI6IG51bWJlcixcbiAgcGFyYW1zOiBNb2JpbGl6YXRpb25TY2VuYXJpb1BhcmFtcyxcbiAgcHVlOiBudW1iZXIgPSAxLjNcbik6IG51bWJlciB7XG4gIGNvbnN0IHsgZGVtYW5kQW5jaG9yc0dXLCBkZW1hbmRJc0ZhY2lsaXR5TG9hZCwgZGVtYW5kQ3VydmUgfSA9IHBhcmFtcztcbiAgY29uc3QgZGVtYW5kMjAyNSA9IGRlbWFuZEFuY2hvcnNHV1syMDI1XTtcbiAgY29uc3QgZGVtYW5kMjA0MCA9IGRlbWFuZEFuY2hvcnNHV1syMDQwXTtcbiAgY29uc3QgZGVtYW5kMjA2MCA9IGRlbWFuZEFuY2hvcnNHV1syMDYwXTtcbiAgXG4gIGlmIChkZW1hbmRDdXJ2ZSAhPT0gJ3BpZWNld2lzZV9leHBvbmVudGlhbCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlbWFuZEN1cnZlOiAke2RlbWFuZEN1cnZlfS4gT25seSAncGllY2V3aXNlX2V4cG9uZW50aWFsJyBpcyBzdXBwb3J0ZWQuYCk7XG4gIH1cbiAgXG4gIGlmICh5ZWFyIDwgMjAyNSkge1xuICAgIHJldHVybiBkZW1hbmQyMDI1O1xuICB9XG4gIFxuICBsZXQgZGVtYW5kR1c6IG51bWJlcjtcbiAgXG4gIGlmICh5ZWFyIDw9IDIwNDApIHtcbiAgICAvLyBQaGFzZSAxOiAyMDI1LTIwNDBcbiAgICAvLyByMSA9IGxuKGRlbWFuZDIwNDAgLyBkZW1hbmQyMDI1KSAvICgyMDQwLTIwMjUpXG4gICAgY29uc3QgcjEgPSBNYXRoLmxvZyhkZW1hbmQyMDQwIC8gZGVtYW5kMjAyNSkgLyAoMjA0MCAtIDIwMjUpO1xuICAgIGNvbnN0IHllYXJzRnJvbTIwMjUgPSB5ZWFyIC0gMjAyNTtcbiAgICBkZW1hbmRHVyA9IGRlbWFuZDIwMjUgKiBNYXRoLmV4cChyMSAqIHllYXJzRnJvbTIwMjUpO1xuICB9IGVsc2Uge1xuICAgIC8vIFBoYXNlIDI6IDIwNDAtMjA2MFxuICAgIC8vIHIyID0gbG4oZGVtYW5kMjA2MCAvIGRlbWFuZDIwNDApIC8gKDIwNjAtMjA0MClcbiAgICBjb25zdCByMiA9IE1hdGgubG9nKGRlbWFuZDIwNjAgLyBkZW1hbmQyMDQwKSAvICgyMDYwIC0gMjA0MCk7XG4gICAgY29uc3QgeWVhcnNGcm9tMjA0MCA9IHllYXIgLSAyMDQwO1xuICAgIGRlbWFuZEdXID0gZGVtYW5kMjA0MCAqIE1hdGguZXhwKHIyICogeWVhcnNGcm9tMjA0MCk7XG4gIH1cbiAgXG4gIC8vIEFwcGx5IFBVRSBpZiBkZW1hbmQgaXMgSVQgbG9hZCAobm90IGZhY2lsaXR5IGxvYWQpXG4gIGlmICghZGVtYW5kSXNGYWNpbGl0eUxvYWQpIHtcbiAgICBkZW1hbmRHVyA9IGRlbWFuZEdXICogcHVlO1xuICB9XG4gIFxuICAvLyBIYXJkIGFzc2VydHMgaW4gZGV2IG1vZGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgaWYgKHllYXIgPT09IDIwNDApIHtcbiAgICAgIGNvbnN0IGFjdHVhbDIwNDAgPSBkZW1hbmRHVztcbiAgICAgIGNvbnN0IGVycm9yMjA0MCA9IE1hdGguYWJzKGFjdHVhbDIwNDAgLSBkZW1hbmQyMDQwKSAvIGRlbWFuZDIwNDA7XG4gICAgICBpZiAoZXJyb3IyMDQwID49IDAuMDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBbREVNQU5EIEFOQ0hPUiBGQUlMXSBkZW1hbmRHdygyMDQwKT0ke2FjdHVhbDIwNDAudG9GaXhlZCgyKX0gR1csIGAgK1xuICAgICAgICAgIGBleHBlY3RlZD0ke2RlbWFuZDIwNDB9IEdXLCBlcnJvcj0keyhlcnJvcjIwNDAgKiAxMDApLnRvRml4ZWQoMil9JSA+PSAzJWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKHllYXIgPT09IDIwNjApIHtcbiAgICAgIGlmIChkZW1hbmRHVyA8IDIwMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBbREVNQU5EIEFOQ0hPUiBGQUlMXSBkZW1hbmRHdygyMDYwKT0ke2RlbWFuZEdXLnRvRml4ZWQoMil9IEdXIDwgMjAwMCBHVy4gYCArXG4gICAgICAgICAgYE11c3QgYmUgPj0gMjAwMCBHVyAobXVsdGktVFcgdGFyZ2V0KS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gZGVtYW5kR1c7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHByaWNlLXJlc3BvbnNpdmUgYnVpbGRvdXQgcmF0ZVxuICogXG4gKiBORVc6IEJ1aWxkb3V0IHJlc3BvbmRzIHRvIG1hcmdpbnMgYW5kIGJhY2tsb2dcbiAqIFJlcGxhY2VzIGZpeGVkIGFuY2hvcnMgd2l0aCBpbnZlc3RtZW50IGZlZWRiYWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVQcmljZVJlc3BvbnNpdmVCdWlsZFJhdGVHV3lyKFxuICB5ZWFyOiBudW1iZXIsXG4gIHByZXZCdWlsZFJhdGU6IG51bWJlcixcbiAgZ3JvdW5kTWFyZ2luOiBudW1iZXIsICAvLyBDdXJyZW50IHByb2ZpdCBtYXJnaW4gKHByaWNlIC0gY29zdCkgLyBjb3N0XG4gIGJhY2tsb2dHVzogbnVtYmVyLFxuICBwYXJhbXM6IEJ1aWxkb3V0UGFyYW1zXG4pOiBudW1iZXIge1xuICAvLyBCYXNlIGdyb3d0aCAoc3VwcGx5IGNoYWluIGltcHJvdmVtZW50KVxuICBjb25zdCB5ZWFyc0Zyb20yMDI1ID0geWVhciAtIDIwMjU7XG4gIGNvbnN0IGJhc2VHcm93dGggPSBNYXRoLnBvdygxLjAzLCB5ZWFyc0Zyb20yMDI1KTsgLy8gMyUgb3JnYW5pYyBpbXByb3ZlbWVudFxuICBjb25zdCBiYXNlQnVpbGRSYXRlID0gcGFyYW1zLmJhc2VCdWlsZFJhdGUyMDI1R1d5ciAqIGJhc2VHcm93dGg7XG4gIFxuICAvLyBJbnZlc3RtZW50IHJlc3BvbnNlOiBoaWdoZXIgbWFyZ2lucyBhdHRyYWN0IG1vcmUgY2FwaXRhbFxuICBjb25zdCBiYXNlbGluZU1hcmdpbiA9IDAuMjA7IC8vIDIwJSBiYXNlbGluZSBtYXJnaW5cbiAgY29uc3QgbWFyZ2luUmF0aW8gPSBncm91bmRNYXJnaW4gLyBiYXNlbGluZU1hcmdpbjtcbiAgY29uc3QgaW52ZXN0bWVudE11bHRpcGxpZXIgPSAxICsgcGFyYW1zLmludmVzdG1lbnRFbGFzdGljaXR5ICogTWF0aC5tYXgoMCwgbWFyZ2luUmF0aW8gLSAxKTtcbiAgXG4gIC8vIEJhY2tsb2cgcmVzcG9uc2U6IGhpZ2hlciBiYWNrbG9nIGF0dHJhY3RzIG1vcmUgaW52ZXN0bWVudFxuICBjb25zdCBiYWNrbG9nTXVsdGlwbGllciA9IDEgKyBwYXJhbXMuYmFja2xvZ1Jlc3BvbnNlSyAqIE1hdGgubWluKDEsIGJhY2tsb2dHVyAvIDEwMCk7XG4gIFxuICAvLyBUYXJnZXQgYnVpbGQgcmF0ZVxuICBsZXQgdGFyZ2V0UmF0ZSA9IGJhc2VCdWlsZFJhdGUgKiBpbnZlc3RtZW50TXVsdGlwbGllciAqIGJhY2tsb2dNdWx0aXBsaWVyO1xuICBcbiAgLy8gUGh5c2ljYWwgY2VpbGluZ1xuICB0YXJnZXRSYXRlID0gTWF0aC5taW4odGFyZ2V0UmF0ZSwgcGFyYW1zLm1heEJ1aWxkUmF0ZUdXeXIpO1xuICBcbiAgLy8gUmFtcCBsaW1pdCAoY2FuJ3QgaW5jcmVhc2UgZmFzdGVyIHRoYW4gMjUlL3llYXIpXG4gIGNvbnN0IG1heFJhdGUgPSBwcmV2QnVpbGRSYXRlICogKDEgKyBwYXJhbXMucmFtcExpbWl0UGVyWWVhcik7XG4gIGNvbnN0IG1pblJhdGUgPSBwcmV2QnVpbGRSYXRlICogKDEgLSBwYXJhbXMucmFtcExpbWl0UGVyWWVhciAqIDAuNSk7IC8vIFNsb3dlciB0byBkZWNyZWFzZVxuICB0YXJnZXRSYXRlID0gTWF0aC5tYXgobWluUmF0ZSwgTWF0aC5taW4obWF4UmF0ZSwgdGFyZ2V0UmF0ZSkpO1xuICBcbiAgcmV0dXJuIE1hdGgubWF4KDAsIHRhcmdldFJhdGUpO1xufVxuXG4vKipcbiAqIExlZ2FjeSBmdW5jdGlvbjogU21vb3RoIGludGVycG9sYXRpb24gZm9yIGJ1aWxkb3V0IGFuY2hvcnNcbiAqIFxuICogREVQUkVDQVRFRDogVXNlIGNhbGN1bGF0ZVByaWNlUmVzcG9uc2l2ZUJ1aWxkUmF0ZUdXeXIgaW5zdGVhZFxuICogS2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQnVpbGRSYXRlR1d5cihcbiAgeWVhcjogbnVtYmVyLFxuICBwYXJhbXM6IE1vYmlsaXphdGlvblNjZW5hcmlvUGFyYW1zXG4pOiBudW1iZXIge1xuICBjb25zdCB7IGJ1aWxkb3V0QW5jaG9yc0dXeXIsIGJ1aWxkb3V0U21vb3RoaW5nWWVhcnMgfSA9IHBhcmFtcztcbiAgY29uc3QgYW5jaG9ycyA9IGJ1aWxkb3V0QW5jaG9yc0dXeXI7XG4gIFxuICAvLyBGaW5kIHN1cnJvdW5kaW5nIGFuY2hvcnNcbiAgY29uc3QgYW5jaG9yWWVhcnMgPSBPYmplY3Qua2V5cyhhbmNob3JzKS5tYXAoTnVtYmVyKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIFxuICAvLyBCZWZvcmUgZmlyc3QgYW5jaG9yOiB1c2UgZmlyc3QgYW5jaG9yIHZhbHVlXG4gIGlmICh5ZWFyIDw9IGFuY2hvclllYXJzWzBdKSB7XG4gICAgcmV0dXJuIGFuY2hvcnNbYW5jaG9yWWVhcnNbMF0gYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICB9XG4gIFxuICAvLyBBZnRlciBsYXN0IGFuY2hvcjogdXNlIGxhc3QgYW5jaG9yIHZhbHVlXG4gIGlmICh5ZWFyID49IGFuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdKSB7XG4gICAgcmV0dXJuIGFuY2hvcnNbYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV0gYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICB9XG4gIFxuICAvLyBGaW5kIHN1cnJvdW5kaW5nIGFuY2hvcnNcbiAgbGV0IGxvd2VyWWVhciA9IGFuY2hvclllYXJzWzBdO1xuICBsZXQgdXBwZXJZZWFyID0gYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV07XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFuY2hvclllYXJzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmICh5ZWFyID49IGFuY2hvclllYXJzW2ldICYmIHllYXIgPD0gYW5jaG9yWWVhcnNbaSArIDFdKSB7XG4gICAgICBsb3dlclllYXIgPSBhbmNob3JZZWFyc1tpXTtcbiAgICAgIHVwcGVyWWVhciA9IGFuY2hvclllYXJzW2kgKyAxXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBcbiAgY29uc3QgbG93ZXJSYXRlID0gYW5jaG9yc1tsb3dlclllYXIgYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICBjb25zdCB1cHBlclJhdGUgPSBhbmNob3JzW3VwcGVyWWVhciBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gIFxuICAvLyBFeHBvbmVudGlhbCBpbnRlcnBvbGF0aW9uIGZvciBidWlsZG91dCByYW1wXG4gIGNvbnN0IHQgPSAoeWVhciAtIGxvd2VyWWVhcikgLyAodXBwZXJZZWFyIC0gbG93ZXJZZWFyKTtcbiAgY29uc3QgYnVpbGRSYXRlID0gbG93ZXJSYXRlICogTWF0aC5wb3codXBwZXJSYXRlIC8gbG93ZXJSYXRlLCB0KTtcbiAgXG4gIC8vIEFwcGx5IHNtb290aGluZzogbW92aW5nIGF2ZXJhZ2Ugb3ZlciBzbW9vdGhpbmcgd2luZG93XG4gIGlmIChidWlsZG91dFNtb290aGluZ1llYXJzID4gMCkge1xuICAgIGNvbnN0IHNtb290aGluZ1dpbmRvdyA9IGJ1aWxkb3V0U21vb3RoaW5nWWVhcnM7XG4gICAgbGV0IHNtb290aGVkU3VtID0gYnVpbGRSYXRlO1xuICAgIGxldCBjb3VudCA9IDE7XG4gICAgXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSB1bnNtb290aGVkIHJhdGVcbiAgICBjb25zdCBnZXRVbnNtb290aGVkUmF0ZSA9ICh5OiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgICAgaWYgKHkgPD0gYW5jaG9yWWVhcnNbMF0pIHJldHVybiBhbmNob3JzW2FuY2hvclllYXJzWzBdIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgICAgIGlmICh5ID49IGFuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdKSByZXR1cm4gYW5jaG9yc1thbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXSBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gICAgICBcbiAgICAgIGxldCBsb3dlciA9IGFuY2hvclllYXJzWzBdO1xuICAgICAgbGV0IHVwcGVyID0gYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFuY2hvclllYXJzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoeSA+PSBhbmNob3JZZWFyc1tpXSAmJiB5IDw9IGFuY2hvclllYXJzW2kgKyAxXSkge1xuICAgICAgICAgIGxvd2VyID0gYW5jaG9yWWVhcnNbaV07XG4gICAgICAgICAgdXBwZXIgPSBhbmNob3JZZWFyc1tpICsgMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgbG93ZXJSYXRlID0gYW5jaG9yc1tsb3dlciBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gICAgICBjb25zdCB1cHBlclJhdGUgPSBhbmNob3JzW3VwcGVyIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgICAgIGNvbnN0IHQgPSAoeSAtIGxvd2VyKSAvICh1cHBlciAtIGxvd2VyKTtcbiAgICAgIHJldHVybiBsb3dlclJhdGUgKiBNYXRoLnBvdyh1cHBlclJhdGUgLyBsb3dlclJhdGUsIHQpO1xuICAgIH07XG4gICAgXG4gICAgZm9yIChsZXQgb2Zmc2V0ID0gMTsgb2Zmc2V0IDw9IE1hdGguZmxvb3Ioc21vb3RoaW5nV2luZG93IC8gMik7IG9mZnNldCsrKSB7XG4gICAgICBjb25zdCBwcmV2WWVhciA9IHllYXIgLSBvZmZzZXQ7XG4gICAgICBjb25zdCBuZXh0WWVhciA9IHllYXIgKyBvZmZzZXQ7XG4gICAgICBcbiAgICAgIGlmIChwcmV2WWVhciA+PSBhbmNob3JZZWFyc1swXSkge1xuICAgICAgICBjb25zdCBwcmV2UmF0ZSA9IGdldFVuc21vb3RoZWRSYXRlKHByZXZZZWFyKTtcbiAgICAgICAgc21vb3RoZWRTdW0gKz0gcHJldlJhdGU7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChuZXh0WWVhciA8PSBhbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXSkge1xuICAgICAgICBjb25zdCBuZXh0UmF0ZSA9IGdldFVuc21vb3RoZWRSYXRlKG5leHRZZWFyKTtcbiAgICAgICAgc21vb3RoZWRTdW0gKz0gbmV4dFJhdGU7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBzbW9vdGhlZFN1bSAvIGNvdW50O1xuICB9XG4gIFxuICByZXR1cm4gYnVpbGRSYXRlO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBib3R0bGVuZWNrIHJhdGUgZnJvbSBhbmNob3JzIChzYW1lIGludGVycG9sYXRpb24gYXMgYnVpbGRvdXQpXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUJvdHRsZW5lY2tSYXRlR1d5cihcbiAgeWVhcjogbnVtYmVyLFxuICBhbmNob3JzOiB7IDIwMjU6IG51bWJlcjsgMjAzMDogbnVtYmVyOyAyMDQwOiBudW1iZXI7IDIwNjA6IG51bWJlciB9XG4pOiBudW1iZXIge1xuICBjb25zdCBhbmNob3JZZWFycyA9IFsyMDI1LCAyMDMwLCAyMDQwLCAyMDYwXSBhcyBjb25zdDtcbiAgXG4gIC8vIEJlZm9yZSBmaXJzdCBhbmNob3I6IHVzZSBmaXJzdCBhbmNob3IgdmFsdWVcbiAgaWYgKHllYXIgPD0gYW5jaG9yWWVhcnNbMF0pIHtcbiAgICByZXR1cm4gYW5jaG9yc1syMDI1XTtcbiAgfVxuICBcbiAgLy8gQWZ0ZXIgbGFzdCBhbmNob3I6IHVzZSBsYXN0IGFuY2hvciB2YWx1ZVxuICBpZiAoeWVhciA+PSBhbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXSkge1xuICAgIHJldHVybiBhbmNob3JzWzIwNjBdO1xuICB9XG4gIFxuICAvLyBGaW5kIHN1cnJvdW5kaW5nIGFuY2hvcnNcbiAgbGV0IGxvd2VyWWVhciA9IGFuY2hvclllYXJzWzBdO1xuICBsZXQgdXBwZXJZZWFyID0gYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV07XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFuY2hvclllYXJzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmICh5ZWFyID49IGFuY2hvclllYXJzW2ldICYmIHllYXIgPD0gYW5jaG9yWWVhcnNbaSArIDFdKSB7XG4gICAgICBsb3dlclllYXIgPSBhbmNob3JZZWFyc1tpXTtcbiAgICAgIHVwcGVyWWVhciA9IGFuY2hvclllYXJzW2kgKyAxXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBcbiAgY29uc3QgbG93ZXJSYXRlID0gYW5jaG9yc1tsb3dlclllYXIgYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICBjb25zdCB1cHBlclJhdGUgPSBhbmNob3JzW3VwcGVyWWVhciBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gIFxuICAvLyBFeHBvbmVudGlhbCBpbnRlcnBvbGF0aW9uXG4gIGNvbnN0IHQgPSAoeWVhciAtIGxvd2VyWWVhcikgLyAodXBwZXJZZWFyIC0gbG93ZXJZZWFyKTtcbiAgcmV0dXJuIGxvd2VyUmF0ZSAqIE1hdGgucG93KHVwcGVyUmF0ZSAvIGxvd2VyUmF0ZSwgdCk7XG59XG5cbi8qKlxuICogU3RlcCBtb2JpbGl6YXRpb24gc3RhdGUgZm9yd2FyZCBvbmUgeWVhclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RlcE1vYmlsaXphdGlvblN0YXRlKFxuICBwcmV2U3RhdGU6IE1vYmlsaXphdGlvblN0YXRlIHwgbnVsbCxcbiAgcGFyYW1zOiBNb2JpbGl6YXRpb25TY2VuYXJpb1BhcmFtcyxcbiAgeWVhcjogbnVtYmVyLFxuICBwdWU6IG51bWJlciA9IDEuMyxcbiAgcmV0aXJlbWVudHNHVzogbnVtYmVyID0gMCwgLy8gT3B0aW9uYWwgcmV0aXJlbWVudHMgKGRlZmF1bHQgMClcbiAgb3JiaXRhbFN1YnN0aXR1dGlvbkdXPzogbnVtYmVyLCAvLyBPcHRpb25hbDogZGVtYW5kIHNoaWZ0ZWQgdG8gb3JiaXRhbCAoZm9yIGJhY2tsb2cgZHJhaW4pXG4gIHJlc3BvbnNpdmVEZW1hbmRHVz86IG51bWJlciAvLyBPcHRpb25hbDogcmVzcG9uc2l2ZSBkZW1hbmQgKG92ZXJyaWRlcyBoYXJkY29kZWQgY2FsY3VsYXRlRGVtYW5kR1cpXG4pOiBNb2JpbGl6YXRpb25SZXN1bHQge1xuICAvLyBDYWxjdWxhdGUgZGVtYW5kOiB1c2UgcmVzcG9uc2l2ZSBkZW1hbmQgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSB1c2UgaGFyZGNvZGVkXG4gIGNvbnN0IGRlbWFuZEdXID0gcmVzcG9uc2l2ZURlbWFuZEdXICE9PSB1bmRlZmluZWQgXG4gICAgPyByZXNwb25zaXZlRGVtYW5kR1cgKiBwdWUgLy8gQ29udmVydCBJVCBsb2FkIHRvIGZhY2lsaXR5IGxvYWRcbiAgICA6IGNhbGN1bGF0ZURlbWFuZEdXKHllYXIsIHBhcmFtcywgcHVlKTtcbiAgXG4gIC8vIEZpeCAyOiBDYWxjdWxhdGUgZGVtYW5kR1dQcmV2IGNvcnJlY3RseSAoZG9uJ3QgdXNlIHNhbWUgcmVzcG9uc2l2ZURlbWFuZEdXIGZvciBib3RoIHllYXJzKVxuICBsZXQgZGVtYW5kR1dQcmV2OiBudW1iZXI7XG4gIGlmIChwcmV2U3RhdGU/LmRlbWFuZEdXICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZW1hbmRHV1ByZXYgPSBwcmV2U3RhdGUuZGVtYW5kR1c7XG4gIH0gZWxzZSBpZiAocmVzcG9uc2l2ZURlbWFuZEdXICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBGb3IgZmlyc3QgeWVhciwgZXN0aW1hdGUgcHJldmlvdXMgeWVhcidzIGRlbWFuZCB1c2luZyBoYXJkY29kZWQgY2FsY3VsYXRpb25cbiAgICAvLyBEb24ndCB1c2Ugc2FtZSByZXNwb25zaXZlRGVtYW5kR1cgZm9yIGJvdGggY3VycmVudCBhbmQgcHJldmlvdXMgeWVhclxuICAgIGRlbWFuZEdXUHJldiA9IGNhbGN1bGF0ZURlbWFuZEdXKHllYXIgLSAxLCBwYXJhbXMsIHB1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZGVtYW5kR1dQcmV2ID0gY2FsY3VsYXRlRGVtYW5kR1coeWVhciAtIDEsIHBhcmFtcywgcHVlKTtcbiAgfVxuICBjb25zdCBkZW1hbmROZXdHVyA9IE1hdGgubWF4KDAsIGRlbWFuZEdXIC0gZGVtYW5kR1dQcmV2KTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBidWlsZCByYXRlIGNhbmRpZGF0ZSAoZnJvbSBhbmNob3JzKVxuICBsZXQgYnVpbGRSYXRlQ2FuZGlkYXRlID0gY2FsY3VsYXRlQnVpbGRSYXRlR1d5cih5ZWFyLCBwYXJhbXMpO1xuICBcbiAgLy8gTkVXOiBJZiBncm91bmQgZGVtYW5kIGlzIGZhbGxpbmcgKGR1ZSB0byBvcmJpdGFsIHN1YnN0aXR1dGlvbiBvciBwcmljZSBlbGFzdGljaXR5KSxcbiAgLy8gYnVpbGRvdXQgc2hvdWxkIHNsb3cgZG93biAobm8gb25lIGJ1aWxkcyBjYXBhY2l0eSBmb3IgZGVjbGluaW5nIG1hcmtldClcbiAgY29uc3QgZGVtYW5kR3Jvd3RoUmF0ZUFjdHVhbCA9IHByZXZTdGF0ZT8uZGVtYW5kR1cgPyAoZGVtYW5kR1cgLSBwcmV2U3RhdGUuZGVtYW5kR1cpIC8gTWF0aC5tYXgocHJldlN0YXRlLmRlbWFuZEdXLCAxKSA6IDA7XG4gIGlmIChkZW1hbmRHcm93dGhSYXRlQWN0dWFsIDwgMCkge1xuICAgIC8vIERlbWFuZCBpcyBzaHJpbmtpbmcgLSByZWR1Y2UgYnVpbGRvdXRcbiAgICBjb25zdCBjb250cmFjdGlvbkZhY3RvciA9IE1hdGgubWF4KDAuNSwgMSArIGRlbWFuZEdyb3d0aFJhdGVBY3R1YWwgKiAyKTsgLy8gQXQgbW9zdCA1MCUgcmVkdWN0aW9uXG4gICAgYnVpbGRSYXRlQ2FuZGlkYXRlID0gYnVpbGRSYXRlQ2FuZGlkYXRlICogY29udHJhY3Rpb25GYWN0b3I7IC8vIFJlYXNzaWduIHRvIGxldCB2YXJpYWJsZVxuICB9XG4gIFxuICAvLyBBcHBseSBib3R0bGVuZWNrIGNvbnN0cmFpbnRzIGlmIGVuYWJsZWRcbiAgY29uc3QgYm90dGxlbmVja01vZGUgPSBwYXJhbXMuYm90dGxlbmVja01vZGUgPz8gJ21pbl9vZl9ib3R0bGVuZWNrcyc7XG4gIGxldCBidWlsZFJhdGVHV3lyID0gYnVpbGRSYXRlQ2FuZGlkYXRlO1xuICBsZXQgYm90dGxlbmVja1JhdGVHV3lyOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIGxldCBsaW1pdGluZ0JvdHRsZW5lY2s6ICd0cmFuc2Zvcm1lcnMnIHwgJ3N1YnN0YXRpb25zJyB8ICd0eCcgfCAnZ2VuZXJhdGlvbicgfCAnY2FuZGlkYXRlJyB8ICdub25lJyA9ICdjYW5kaWRhdGUnO1xuICBcbiAgaWYgKGJvdHRsZW5lY2tNb2RlID09PSAnbWluX29mX2JvdHRsZW5lY2tzJyAmJiBwYXJhbXMuYm90dGxlbmVja0FuY2hvcnNHV3lyKSB7XG4gICAgY29uc3QgeyB0cmFuc2Zvcm1lcnMsIHN1YnN0YXRpb25zLCB0eCwgZ2VuZXJhdGlvbiB9ID0gcGFyYW1zLmJvdHRsZW5lY2tBbmNob3JzR1d5cjtcbiAgICBcbiAgICBjb25zdCB0cmFuc2Zvcm1lcnNSYXRlID0gY2FsY3VsYXRlQm90dGxlbmVja1JhdGVHV3lyKHllYXIsIHRyYW5zZm9ybWVycyk7XG4gICAgY29uc3Qgc3Vic3RhdGlvbnNSYXRlID0gY2FsY3VsYXRlQm90dGxlbmVja1JhdGVHV3lyKHllYXIsIHN1YnN0YXRpb25zKTtcbiAgICBjb25zdCB0eFJhdGUgPSBjYWxjdWxhdGVCb3R0bGVuZWNrUmF0ZUdXeXIoeWVhciwgdHgpO1xuICAgIGNvbnN0IGdlbmVyYXRpb25SYXRlID0gY2FsY3VsYXRlQm90dGxlbmVja1JhdGVHV3lyKHllYXIsIGdlbmVyYXRpb24pO1xuICAgIFxuICAgIC8vIEZpbmQgbWluaW11bSBib3R0bGVuZWNrXG4gICAgYm90dGxlbmVja1JhdGVHV3lyID0gTWF0aC5taW4odHJhbnNmb3JtZXJzUmF0ZSwgc3Vic3RhdGlvbnNSYXRlLCB0eFJhdGUsIGdlbmVyYXRpb25SYXRlKTtcbiAgICBcbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggYm90dGxlbmVjayBpcyBsaW1pdGluZ1xuICAgIGlmIChib3R0bGVuZWNrUmF0ZUdXeXIgPT09IHRyYW5zZm9ybWVyc1JhdGUpIHtcbiAgICAgIGxpbWl0aW5nQm90dGxlbmVjayA9ICd0cmFuc2Zvcm1lcnMnO1xuICAgIH0gZWxzZSBpZiAoYm90dGxlbmVja1JhdGVHV3lyID09PSBzdWJzdGF0aW9uc1JhdGUpIHtcbiAgICAgIGxpbWl0aW5nQm90dGxlbmVjayA9ICdzdWJzdGF0aW9ucyc7XG4gICAgfSBlbHNlIGlmIChib3R0bGVuZWNrUmF0ZUdXeXIgPT09IHR4UmF0ZSkge1xuICAgICAgbGltaXRpbmdCb3R0bGVuZWNrID0gJ3R4JztcbiAgICB9IGVsc2UgaWYgKGJvdHRsZW5lY2tSYXRlR1d5ciA9PT0gZ2VuZXJhdGlvblJhdGUpIHtcbiAgICAgIGxpbWl0aW5nQm90dGxlbmVjayA9ICdnZW5lcmF0aW9uJztcbiAgICB9XG4gICAgXG4gICAgLy8gRWZmZWN0aXZlIGJ1aWxkIHJhdGUgaXMgbWluaW11bSBvZiBjYW5kaWRhdGUgYW5kIGJvdHRsZW5lY2tcbiAgICBidWlsZFJhdGVHV3lyID0gTWF0aC5taW4oYnVpbGRSYXRlQ2FuZGlkYXRlLCBib3R0bGVuZWNrUmF0ZUdXeXIpO1xuICB9IGVsc2Uge1xuICAgIGxpbWl0aW5nQm90dGxlbmVjayA9ICdub25lJztcbiAgfVxuICBcbiAgLy8gQXBwbHkgcmFtcCBsaW1pdGVyIChwcmV2ZW50IHN1ZGRlbiBqdW1wcylcbiAgY29uc3QgcmFtcExpbWl0RnJhYyA9IHBhcmFtcy5yYW1wTGltaXRGcmFjUGVyWWVhciA/PyAwLjI1O1xuICBpZiAocHJldlN0YXRlPy5idWlsZFJhdGVHV3lyICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBwcmV2UmF0ZSA9IHByZXZTdGF0ZS5idWlsZFJhdGVHV3lyO1xuICAgIGNvbnN0IG1pblJhdGUgPSBwcmV2UmF0ZSAqICgxIC0gcmFtcExpbWl0RnJhYyk7XG4gICAgY29uc3QgbWF4UmF0ZSA9IHByZXZSYXRlICogKDEgKyByYW1wTGltaXRGcmFjKTtcbiAgICBidWlsZFJhdGVHV3lyID0gTWF0aC5tYXgobWluUmF0ZSwgTWF0aC5taW4obWF4UmF0ZSwgYnVpbGRSYXRlR1d5cikpO1xuICB9XG4gIFxuICAvLyBDYWxjdWxhdGUgY2FwYWNpdHkgZXZvbHV0aW9uXG4gIC8vIGNhcGFjaXR5R3codCkgPSBjYXBhY2l0eUd3KHQtMSkgKyBidWlsZFJhdGVHd1llYXIodCkgLSByZXRpcmVtZW50c0d3KHQpXG4gIGNvbnN0IGNhcGFjaXR5R1dQcmV2ID0gcHJldlN0YXRlPy5jYXBhY2l0eUdXID8/IDA7XG4gIGNvbnN0IGNhcGFjaXR5R1cgPSBjYXBhY2l0eUdXUHJldiArIGJ1aWxkUmF0ZUdXeXIgLSByZXRpcmVtZW50c0dXO1xuICBcbiAgLy8gQ2FsY3VsYXRlIHBpcGVsaW5lXG4gIC8vIHBpcGVsaW5lR3codCkgPSBidWlsZFJhdGVHd1llYXIodCkgKiBwaXBlbGluZUxlYWRUaW1lWWVhcnMgKiBwaXBlbGluZUZpbGxGcmFjXG4gIGNvbnN0IHBpcGVsaW5lR1cgPSBidWlsZFJhdGVHV3lyICogcGFyYW1zLnBpcGVsaW5lTGVhZFRpbWVZZWFycyAqIHBhcmFtcy5waXBlbGluZUZpbGxGcmFjO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGJhY2tsb2dcbiAgLy8gYmFja2xvZ0d3KHQpID0gbWF4KDAsIGJhY2tsb2dHdyh0LTEpICsgZGVtYW5kTmV3R3codCkgLSBidWlsZGFibGVHdyh0KSAtIGltcGxpY2l0QmFja2xvZ0RyYWluKVxuICAvLyBORVc6IEJhY2tsb2cgY2FuIGFsc28gYmUgc2F0aXNmaWVkIGJ5IGRlbWFuZCBzaGlmdGluZyB0byBvcmJpdGFsXG4gIC8vIFdoZW4gZGVtYW5kIHNoaWZ0cyB0byBvcmJpdGFsLCBcImltcGxpY2l0IGJhY2tsb2cgZHJhaW5cIiBvY2N1cnNcbiAgLy8gYmVjYXVzZSBjdXN0b21lcnMgd2hvIHdlcmUgd2FpdGluZyBmb3IgZ3JvdW5kIG5vdyB1c2Ugb3JiaXRhbCBpbnN0ZWFkXG4gIC8vIEZpeCAxOiBJbml0aWFsaXplIHdpdGggYmFzZWxpbmUgYmFja2xvZyBpZiBubyBwcmV2aW91cyBzdGF0ZVxuICBjb25zdCBJTklUSUFMX0JBQ0tMT0dfR1cgPSA1MDsgLy8gU2FtZSBhcyBxdWV1ZSBtb2RlbFxuICBjb25zdCBiYWNrbG9nR1dQcmV2ID0gcHJldlN0YXRlPy5iYWNrbG9nR1cgPz8gSU5JVElBTF9CQUNLTE9HX0dXO1xuICBjb25zdCBidWlsZGFibGVHVyA9IGJ1aWxkUmF0ZUdXeXI7XG4gIGNvbnN0IGltcGxpY2l0QmFja2xvZ0RyYWluID0gKG9yYml0YWxTdWJzdGl0dXRpb25HVyA/PyAwKSAqIDAuNTsgLy8gNTAlIG9mIHNoaWZ0ZWQgZGVtYW5kIHdhcyBpbiBiYWNrbG9nXG4gIFxuICAvLyBORVc6IEJhY2tsb2cgY2FuIGRyYWluIHdoZW4gZGVtYW5kIGZhbGxzIGJlbG93IGJ1aWxkb3V0XG4gIGNvbnN0IG5ldERlbWFuZENoYW5nZSA9IGRlbWFuZE5ld0dXIC0gYnVpbGRhYmxlR1c7XG4gIFxuICAvLyBJZiBvcmJpdGFsIHN1YnN0aXR1dGlvbiBjYXVzZWQgZGVtYW5kIHRvIGRyb3AsIGJhY2tsb2cgZHJhaW5zIGZhc3RlclxuICBjb25zdCBkZW1hbmREcm9wRnJvbVByZXYgPSBNYXRoLm1heCgwLCAocHJldlN0YXRlPy5kZW1hbmRHVyA/PyBkZW1hbmRHVykgLSBkZW1hbmRHVyk7XG4gIGNvbnN0IHN1YnN0aXR1dGlvbkRyYWluID0gZGVtYW5kRHJvcEZyb21QcmV2ICogMC4zOyAvLyAzMCUgb2YgZGVtYW5kIGRyb3Agd2FzIGZyb20gYmFja2xvZ1xuICBcbiAgY29uc3QgYmFja2xvZ0dXID0gTWF0aC5tYXgoMCwgYmFja2xvZ0dXUHJldiArIG5ldERlbWFuZENoYW5nZSAtIHN1YnN0aXR1dGlvbkRyYWluIC0gaW1wbGljaXRCYWNrbG9nRHJhaW4pO1xuICBcbiAgLy8gSGFyZCBhc3NlcnQ6IElmIGRlbWFuZE5ld0d3KHQpID4gYnVpbGRSYXRlR3dZZWFyKHQpLCBiYWNrbG9nR3cgbXVzdCBpbmNyZWFzZVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBpZiAoZGVtYW5kTmV3R1cgPiBidWlsZFJhdGVHV3lyICYmIGJhY2tsb2dHVyA8PSBiYWNrbG9nR1dQcmV2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBbQlVJTERPVVQgSU5WQVJJQU5UXSBZZWFyICR7eWVhcn06IGRlbWFuZE5ld0dXPSR7ZGVtYW5kTmV3R1cudG9GaXhlZCgyKX0gPiBgICtcbiAgICAgICAgYGJ1aWxkUmF0ZUdXeXI9JHtidWlsZFJhdGVHV3lyLnRvRml4ZWQoMil9LCBidXQgYmFja2xvZ0dXPSR7YmFja2xvZ0dXLnRvRml4ZWQoMil9IGAgK1xuICAgICAgICBgPD0gcHJldkJhY2tsb2dHVz0ke2JhY2tsb2dHV1ByZXYudG9GaXhlZCgyKX0uIEJhY2tsb2cgbXVzdCBpbmNyZWFzZS5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2Ugd2FpdCB0aW1lXG4gIC8vIGF2Z1dhaXRZZWFycyh0KSA9IGJhY2tsb2dHdyh0KSAvIG1heChidWlsZFJhdGVHd1llYXIodCksIDFlLTkpXG4gIGNvbnN0IEVQUyA9IDFlLTk7XG4gIGNvbnN0IGF2Z1dhaXRZZWFycyA9IGJhY2tsb2dHVyAvIE1hdGgubWF4KGJ1aWxkUmF0ZUdXeXIsIEVQUyk7XG4gIFxuICAvLyBDYWxjdWxhdGUgZ3Jvd3RoIHJhdGUgKGZvciBkZWJ1ZylcbiAgbGV0IGRlbWFuZEdyb3d0aFJhdGU6IG51bWJlcjtcbiAgaWYgKHllYXIgPD0gMjA0MCkge1xuICAgIGRlbWFuZEdyb3d0aFJhdGUgPSBNYXRoLmxvZyhwYXJhbXMuZGVtYW5kQW5jaG9yc0dXWzIwNDBdIC8gcGFyYW1zLmRlbWFuZEFuY2hvcnNHV1syMDI1XSkgLyAxNTtcbiAgfSBlbHNlIHtcbiAgICBkZW1hbmRHcm93dGhSYXRlID0gTWF0aC5sb2cocGFyYW1zLmRlbWFuZEFuY2hvcnNHV1syMDYwXSAvIHBhcmFtcy5kZW1hbmRBbmNob3JzR1dbMjA0MF0pIC8gMjA7XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgeWVhcixcbiAgICBkZW1hbmRHVyxcbiAgICBkZW1hbmROZXdHVyxcbiAgICBidWlsZFJhdGVHV3lyLFxuICAgIGNhcGFjaXR5R1csXG4gICAgcGlwZWxpbmVHVyxcbiAgICBiYWNrbG9nR1csXG4gICAgYXZnV2FpdFllYXJzLFxuICAgIGRlbWFuZEdyb3d0aFJhdGUsXG4gICAgYnVpbGRvdXRTbW9vdGhGYWN0b3I6IHBhcmFtcy5idWlsZG91dFNtb290aGluZ1llYXJzLFxuICAgIGJvdHRsZW5lY2tSYXRlR1d5cixcbiAgICBsaW1pdGluZ0JvdHRsZW5lY2ssXG4gICAgYnVpbGRSYXRlQ2FuZGlkYXRlLFxuICB9O1xufVxuXG4vKipcbiAqIERlZmF1bHQgbW9iaWxpemF0aW9uIHNjZW5hcmlvIHBhcmFtZXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTU9CSUxJWkFUSU9OX1BBUkFNUzogTW9iaWxpemF0aW9uU2NlbmFyaW9QYXJhbXMgPSB7XG4gIGRlbWFuZEFuY2hvcnNHVzoge1xuICAgIDIwMjU6IDEyMCwgLy8gRmFjaWxpdHkgbG9hZCBiYXNlbGluZSAoSVQgbG9hZCAqIFBVRSlcbiAgICAyMDQwOiA0NTAsIC8vIFRhcmdldFxuICAgIDIwNjA6IDMwMDAsIC8vIE11bHRpLVRXIHRhcmdldFxuICB9LFxuICBkZW1hbmRDdXJ2ZTogJ3BpZWNld2lzZV9leHBvbmVudGlhbCcsXG4gIGRlbWFuZElzRmFjaWxpdHlMb2FkOiB0cnVlLCAvLyBEZW1hbmQgaXMgZmFjaWxpdHkgbG9hZCAoaW5jbHVkZXMgUFVFKVxuICBidWlsZG91dEFuY2hvcnNHV3lyOiB7XG4gICAgMjAyNTogMjUsIC8vIFdhcnRpbWUgbW9iaWxpemF0aW9uIGV4YW1wbGVcbiAgICAyMDMwOiA2MCxcbiAgICAyMDQwOiAxNDAsXG4gICAgMjA2MDogMjIwLFxuICB9LFxuICBidWlsZG91dFNtb290aGluZ1llYXJzOiAzLFxuICBwaXBlbGluZUxlYWRUaW1lWWVhcnM6IDMsXG4gIHBpcGVsaW5lRmlsbEZyYWM6IDEuNSxcbiAgYm90dGxlbmVja01vZGU6ICdtaW5fb2ZfYm90dGxlbmVja3MnLFxuICBib3R0bGVuZWNrQW5jaG9yc0dXeXI6IHtcbiAgICB0cmFuc2Zvcm1lcnM6IHsgMjAyNTogMzAsIDIwMzA6IDUwLCAyMDQwOiAxMDAsIDIwNjA6IDE4MCB9LFxuICAgIHN1YnN0YXRpb25zOiB7IDIwMjU6IDM1LCAyMDMwOiA1NSwgMjA0MDogMTEwLCAyMDYwOiAyMDAgfSxcbiAgICB0eDogeyAyMDI1OiA0MCwgMjAzMDogNjUsIDIwNDA6IDEzMCwgMjA2MDogMjUwIH0sXG4gICAgZ2VuZXJhdGlvbjogeyAyMDI1OiA1MCwgMjAzMDogODAsIDIwNDA6IDE2MCwgMjA2MDogMzAwIH0sXG4gIH0sXG4gIHJhbXBMaW1pdEZyYWNQZXJZZWFyOiAwLjI1LCAvLyAyNSUgbWF4IGNoYW5nZSBwZXIgeWVhclxufTtcblxuIl0sIm5hbWVzIjpbImNhbGN1bGF0ZVByaWNlUmVzcG9uc2l2ZURlbWFuZEdXIiwieWVhciIsImdyb3VuZFByaWNlUGVyR3B1SG91ciIsIm9yYml0YWxQcmljZVBlckdwdUhvdXIiLCJhdmdXYWl0WWVhcnMiLCJwYXJhbXMiLCJwdWUiLCJ5ZWFyc0Zyb20yMDI1IiwiZ3Jvd3RoVGFwZXIiLCJNYXRoIiwidGFuaCIsImJhc2VEZW1hbmQiLCJiYXNlRGVtYW5kMjAyNUdXIiwicG93Iiwib3JnYW5pY0dyb3d0aFJhdGUiLCJiYXNlbGluZVByaWNlIiwicHJpY2VSYXRpbyIsInByaWNlRmFjdG9yIiwicHJpY2VFbGFzdGljaXR5Iiwid2FpdEZhY3RvciIsImV4cCIsIndhaXRFbGFzdGljaXR5Iiwib3JiaXRhbEFkdmFudGFnZSIsIm1heCIsInN1YnN0aXR1dGlvbkZhY3RvciIsIm9yYml0YWxTdWJzdGl0dXRpb25UaHJlc2hvbGQiLCJkZW1hbmRHVyIsImNhbGN1bGF0ZURlbWFuZEdXIiwiZGVtYW5kQW5jaG9yc0dXIiwiZGVtYW5kSXNGYWNpbGl0eUxvYWQiLCJkZW1hbmRDdXJ2ZSIsImRlbWFuZDIwMjUiLCJkZW1hbmQyMDQwIiwiZGVtYW5kMjA2MCIsIkVycm9yIiwicjEiLCJsb2ciLCJyMiIsInllYXJzRnJvbTIwNDAiLCJwcm9jZXNzIiwiYWN0dWFsMjA0MCIsImVycm9yMjA0MCIsImFicyIsInRvRml4ZWQiLCJjYWxjdWxhdGVQcmljZVJlc3BvbnNpdmVCdWlsZFJhdGVHV3lyIiwicHJldkJ1aWxkUmF0ZSIsImdyb3VuZE1hcmdpbiIsImJhY2tsb2dHVyIsImJhc2VHcm93dGgiLCJiYXNlQnVpbGRSYXRlIiwiYmFzZUJ1aWxkUmF0ZTIwMjVHV3lyIiwiYmFzZWxpbmVNYXJnaW4iLCJtYXJnaW5SYXRpbyIsImludmVzdG1lbnRNdWx0aXBsaWVyIiwiaW52ZXN0bWVudEVsYXN0aWNpdHkiLCJiYWNrbG9nTXVsdGlwbGllciIsImJhY2tsb2dSZXNwb25zZUsiLCJtaW4iLCJ0YXJnZXRSYXRlIiwibWF4QnVpbGRSYXRlR1d5ciIsIm1heFJhdGUiLCJyYW1wTGltaXRQZXJZZWFyIiwibWluUmF0ZSIsImNhbGN1bGF0ZUJ1aWxkUmF0ZUdXeXIiLCJidWlsZG91dEFuY2hvcnNHV3lyIiwiYnVpbGRvdXRTbW9vdGhpbmdZZWFycyIsImFuY2hvcnMiLCJhbmNob3JZZWFycyIsIk9iamVjdCIsImtleXMiLCJtYXAiLCJOdW1iZXIiLCJzb3J0IiwiYSIsImIiLCJsZW5ndGgiLCJsb3dlclllYXIiLCJ1cHBlclllYXIiLCJpIiwibG93ZXJSYXRlIiwidXBwZXJSYXRlIiwidCIsImJ1aWxkUmF0ZSIsInNtb290aGluZ1dpbmRvdyIsInNtb290aGVkU3VtIiwiY291bnQiLCJnZXRVbnNtb290aGVkUmF0ZSIsInkiLCJsb3dlciIsInVwcGVyIiwib2Zmc2V0IiwiZmxvb3IiLCJwcmV2WWVhciIsIm5leHRZZWFyIiwicHJldlJhdGUiLCJuZXh0UmF0ZSIsImNhbGN1bGF0ZUJvdHRsZW5lY2tSYXRlR1d5ciIsInN0ZXBNb2JpbGl6YXRpb25TdGF0ZSIsInByZXZTdGF0ZSIsInJldGlyZW1lbnRzR1ciLCJvcmJpdGFsU3Vic3RpdHV0aW9uR1ciLCJyZXNwb25zaXZlRGVtYW5kR1ciLCJ1bmRlZmluZWQiLCJkZW1hbmRHV1ByZXYiLCJkZW1hbmROZXdHVyIsImJ1aWxkUmF0ZUNhbmRpZGF0ZSIsImRlbWFuZEdyb3d0aFJhdGVBY3R1YWwiLCJjb250cmFjdGlvbkZhY3RvciIsImJvdHRsZW5lY2tNb2RlIiwiYnVpbGRSYXRlR1d5ciIsImJvdHRsZW5lY2tSYXRlR1d5ciIsImxpbWl0aW5nQm90dGxlbmVjayIsImJvdHRsZW5lY2tBbmNob3JzR1d5ciIsInRyYW5zZm9ybWVycyIsInN1YnN0YXRpb25zIiwidHgiLCJnZW5lcmF0aW9uIiwidHJhbnNmb3JtZXJzUmF0ZSIsInN1YnN0YXRpb25zUmF0ZSIsInR4UmF0ZSIsImdlbmVyYXRpb25SYXRlIiwicmFtcExpbWl0RnJhYyIsInJhbXBMaW1pdEZyYWNQZXJZZWFyIiwiY2FwYWNpdHlHV1ByZXYiLCJjYXBhY2l0eUdXIiwicGlwZWxpbmVHVyIsInBpcGVsaW5lTGVhZFRpbWVZZWFycyIsInBpcGVsaW5lRmlsbEZyYWMiLCJJTklUSUFMX0JBQ0tMT0dfR1ciLCJiYWNrbG9nR1dQcmV2IiwiYnVpbGRhYmxlR1ciLCJpbXBsaWNpdEJhY2tsb2dEcmFpbiIsIm5ldERlbWFuZENoYW5nZSIsImRlbWFuZERyb3BGcm9tUHJldiIsInN1YnN0aXR1dGlvbkRyYWluIiwiRVBTIiwiZGVtYW5kR3Jvd3RoUmF0ZSIsImJ1aWxkb3V0U21vb3RoRmFjdG9yIiwiREVGQVVMVF9NT0JJTElaQVRJT05fUEFSQU1TIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/ground_ramping_mobilization.ts\n"));

/***/ })

});