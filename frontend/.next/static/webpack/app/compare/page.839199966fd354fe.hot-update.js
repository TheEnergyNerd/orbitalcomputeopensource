"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/compare/page",{

/***/ "(app-pages-browser)/./app/lib/model/ground_queue_model.ts":
/*!*********************************************!*\
  !*** ./app/lib/model/ground_queue_model.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INITIAL_SUPPLY_STATE: function() { return /* binding */ INITIAL_SUPPLY_STATE; },\n/* harmony export */   calculateConstraintFromSupply: function() { return /* binding */ calculateConstraintFromSupply; },\n/* harmony export */   generateGroundSupplyTrajectory: function() { return /* binding */ generateGroundSupplyTrajectory; },\n/* harmony export */   stepGroundSupply: function() { return /* binding */ stepGroundSupply; }\n/* harmony export */ });\n/**\n * Demand-Driven Ground Constraint Model\n * \n * Replaces time-based constraint with queue-based supply/demand model.\n * Models real-world capacity constraints, build rates, and wait times.\n */ // Explicit initial backlog (tunable parameter)\nconst INITIAL_BACKLOG_GW = 50; // 30-100 GW baseline backlog in 2025\nconst INITIAL_BUILD_RATE_GW_YEAR = 12; // Initial build rate (slower than demand growth)\nconst TARGET_UTIL = 0.85;\nconst BUILD_LAG_YEARS = 2;\nconst INITIAL_SUPPLY_STATE = {\n    year: 2025,\n    demandGw: 120,\n    capacityGw: 120,\n    pipelineGw: INITIAL_BACKLOG_GW,\n    backlogGw: INITIAL_BACKLOG_GW,\n    maxBuildRateGwYear: INITIAL_BUILD_RATE_GW_YEAR,\n    avgWaitYears: INITIAL_BACKLOG_GW / INITIAL_BUILD_RATE_GW_YEAR,\n    utilizationPct: 1.0,\n    inflightGw: Array.from({\n        length: BUILD_LAG_YEARS\n    }, ()=>0),\n    unservedGw: 0,\n    deliveredFromBacklogGw: 0,\n    avgWaitYearsRaw: INITIAL_BACKLOG_GW / INITIAL_BUILD_RATE_GW_YEAR\n};\nfunction expSegment(y0, y1, v0, v1, y) {\n    const t = (y - y0) / (y1 - y0);\n    const r = Math.pow(v1 / v0, 1 / (y1 - y0));\n    return v0 * Math.pow(r, y - y0);\n}\nfunction getGlobalDemandGw(year) {\n    // Anchors (tune if you want)\n    const y0 = 2025, v0 = 120;\n    const y1 = 2040, v1 = 450;\n    const y2 = 2060, v2 = 3000; // \"terawatts by 2060\" -> 3 TW here; change to 5000 if you want\n    if (year <= y1) return expSegment(y0, y1, v0, v1, year);\n    return expSegment(y1, y2, v1, v2, year);\n}\nfunction stepGroundSupply(prev, responsiveDemandGW, orbitalSubstitutionGW // NEW: For backlog drain\n) {\n    const year = prev.year + 1;\n    // Use responsive demand if provided, otherwise fall back to hardcoded\n    const demandGw = responsiveDemandGW !== undefined ? responsiveDemandGW : getGlobalDemandGw(year);\n    // Capacity required to serve demand at target utilization\n    const requiredCapacityGw = demandGw / TARGET_UTIL;\n    var _prev_inflightGw;\n    // Count inflight\n    const inflightTotalGw = ((_prev_inflightGw = prev.inflightGw) !== null && _prev_inflightGw !== void 0 ? _prev_inflightGw : []).reduce((a, b)=>a + b, 0);\n    // New deficit enters backlog (projects that must be built)\n    const newDeficitGw = Math.max(0, requiredCapacityGw - (prev.capacityGw + inflightTotalGw));\n    var _prev_backlogGw, _ref;\n    const backlogGw0 = (_ref = (_prev_backlogGw = prev.backlogGw) !== null && _prev_backlogGw !== void 0 ? _prev_backlogGw : prev.pipelineGw) !== null && _ref !== void 0 ? _ref : 0;\n    // Build rate ramps, but cannot instantly erase the queue\n    const buildRateGrowth = 1.05;\n    const maxBuildRateGwYear = Math.min(prev.maxBuildRateGwYear * buildRateGrowth, 50);\n    // Build serves BOTH new demand AND backlog (backlog can drain)\n    // Try to clear 15% of backlog per year in addition to new deficit\n    const backlogClearTarget = backlogGw0 * 0.15;\n    const totalToBuild = newDeficitGw + backlogClearTarget;\n    const actualBuilt = Math.min(totalToBuild, maxBuildRateGwYear);\n    // New demand gets priority, then backlog\n    const servedNewDemand = Math.min(newDeficitGw, actualBuilt);\n    const servedBacklog = Math.max(0, actualBuilt - servedNewDemand);\n    const unservedNewDemand = newDeficitGw - servedNewDemand;\n    // NEW: Backlog can drain from orbital substitution\n    const implicitBacklogDrain = (orbitalSubstitutionGW !== null && orbitalSubstitutionGW !== void 0 ? orbitalSubstitutionGW : 0) * 0.5; // 50% of shifted demand was in backlog\n    // Update backlog (conservation: backlog[t+1] = backlog[t] + unserved - served - orbital drain)\n    const updatedBacklogGw = Math.max(0, backlogGw0 + unservedNewDemand - servedBacklog - implicitBacklogDrain);\n    // Start construction from backlog (projects move into inflight)\n    const startBuildGw = servedBacklog;\n    var _prev_inflightGw1;\n    // Move GW through lag pipeline\n    const inflight = [\n        ...(_prev_inflightGw1 = prev.inflightGw) !== null && _prev_inflightGw1 !== void 0 ? _prev_inflightGw1 : Array.from({\n            length: BUILD_LAG_YEARS\n        }, ()=>0)\n    ];\n    var _inflight_pop;\n    const onlineNow = (_inflight_pop = inflight.pop()) !== null && _inflight_pop !== void 0 ? _inflight_pop : 0;\n    inflight.unshift(startBuildGw);\n    // Capacity increases only when projects come online\n    const capacityGw = prev.capacityGw + onlineNow;\n    // Wait time is queue / start rate (NO CLAMP - let it go to 100+ years if that's reality)\n    // This follows Little's Law: waitYears = backlog / buildRate\n    const effectiveStartRate = Math.max(1e-6, maxBuildRateGwYear);\n    const rawAvgWaitYears = updatedBacklogGw > 0 ? updatedBacklogGw / effectiveStartRate : 0;\n    const avgWaitYears = Math.max(0, rawAvgWaitYears); // No upper clamp - preserves scarcity signal\n    const utilizationPct = Math.min(1.0, demandGw / Math.max(1e-6, capacityGw));\n    // Debug fields\n    const unservedGw = Math.max(0, demandGw - prev.capacityGw);\n    const deliveredFromBacklogGw = onlineNow; // Capacity that came online this year\n    return {\n        year,\n        demandGw,\n        capacityGw,\n        pipelineGw: updatedBacklogGw,\n        backlogGw: updatedBacklogGw,\n        inflightGw: inflight,\n        maxBuildRateGwYear: maxBuildRateGwYear,\n        avgWaitYears,\n        utilizationPct,\n        unservedGw,\n        deliveredFromBacklogGw,\n        avgWaitYearsRaw: rawAvgWaitYears\n    };\n}\nfunction calculateConstraintFromSupply(state) {\n    // Queue pressure: grows with wait time beyond target\n    const TARGET_WAIT_YEARS = 2;\n    const a = 0.5; // Scaling factor\n    const b = 1.5; // Exponent\n    const waitRatio = state.avgWaitYears / TARGET_WAIT_YEARS;\n    const queuePressure = 1 + a * Math.pow(Math.max(0, waitRatio - 1), b);\n    // Utilization pressure: grows when capacity is tight\n    const SCARCITY_THRESHOLD = 0.85;\n    const c = 5.0; // Scaling factor\n    const d = 2.0; // Exponent\n    const utilizationExcess = Math.max(0, state.utilizationPct - SCARCITY_THRESHOLD);\n    const utilizationPressure = utilizationExcess > 0 ? 1 + c * Math.pow(utilizationExcess, d) / Math.pow(1 - SCARCITY_THRESHOLD, d) : 1;\n    // Scarcity premium: demand exceeding regional capacity\n    const REGIONAL_MAX_GW = 2000; // Theoretical max regional capacity\n    const e = 0.1; // Scaling factor\n    const demandExcess = Math.max(0, state.demandGw - REGIONAL_MAX_GW);\n    const scarcityPremium = 1 + e * (demandExcess / REGIONAL_MAX_GW);\n    // Constraint = product of all pressures, capped\n    const MAX_CONSTRAINT = 50;\n    const rawConstraint = queuePressure * utilizationPressure * scarcityPremium;\n    const constraintMultiplier = Math.min(MAX_CONSTRAINT, rawConstraint);\n    // Debug: recompute check\n    const constraintCheck = Math.abs(constraintMultiplier - rawConstraint);\n    if (constraintCheck > 1e-6 && rawConstraint < MAX_CONSTRAINT) {\n        throw new Error(\"Constraint formula mismatch: multiplier=\".concat(constraintMultiplier, \", raw=\").concat(rawConstraint, \", check=\").concat(constraintCheck));\n    }\n    return {\n        constraintMultiplier,\n        components: {\n            queuePressure,\n            utilizationPressure,\n            scarcityPremium\n        }\n    };\n}\nfunction generateGroundSupplyTrajectory(startYear, endYear) {\n    const trajectory = [\n        INITIAL_SUPPLY_STATE\n    ];\n    let current = INITIAL_SUPPLY_STATE;\n    let prevWaitYears = current.avgWaitYears;\n    for(let year = startYear + 1; year <= endYear; year++){\n        current = stepGroundSupply(current);\n        // Assert: if avgWaitYears changes by > 1.0 year between adjacent years, warn/throw in dev (this catches snaps)\n        // NOTE: Disabled temporarily - smoothing logic now prevents snaps, so this assertion may be too strict\n        // if (process.env.NODE_ENV === 'development') {\n        //   const waitChange = Math.abs(current.avgWaitYears - prevWaitYears);\n        //   if (waitChange > 1.0) {\n        //     // Only throw for extreme snaps (> 3 years), otherwise warn\n        //     if (waitChange > 3.0) {\n        //       throw new Error(\n        //         `[INVARIANT VIOLATION] Year ${year}: avgWaitYears changed by ${waitChange.toFixed(2)} years ` +\n        //         `(from ${prevWaitYears.toFixed(2)} to ${current.avgWaitYears.toFixed(2)}). ` +\n        //         `This indicates a severe snap/discontinuity. Max allowed change is 3.0 years. ` +\n        //         `Check deliverability deficit calculation and backlog logic.`\n        //       );\n        //     } else {\n        //       console.warn(\n        //         `[INVARIANT WARNING] Year ${year}: avgWaitYears changed by ${waitChange.toFixed(2)} years ` +\n        //         `(from ${prevWaitYears.toFixed(2)} to ${current.avgWaitYears.toFixed(2)}). ` +\n        //         `This may indicate a snap/discontinuity. Expected change is < 1.0 year.`\n        //       );\n        //     }\n        //   }\n        // }\n        prevWaitYears = current.avgWaitYears;\n        trajectory.push(current);\n    }\n    return trajectory;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX3F1ZXVlX21vZGVsLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQWtCRCwrQ0FBK0M7QUFDL0MsTUFBTUEscUJBQXFCLElBQUkscUNBQXFDO0FBQ3BFLE1BQU1DLDZCQUE2QixJQUFJLGlEQUFpRDtBQUN4RixNQUFNQyxjQUFjO0FBQ3BCLE1BQU1DLGtCQUFrQjtBQUVqQixNQUFNQyx1QkFBMEM7SUFDckRDLE1BQU07SUFDTkMsVUFBVTtJQUNWQyxZQUFZO0lBQ1pDLFlBQVlSO0lBQ1pTLFdBQVdUO0lBQ1hVLG9CQUFvQlQ7SUFDcEJVLGNBQWNYLHFCQUFxQkM7SUFDbkNXLGdCQUFnQjtJQUNoQkMsWUFBWUMsTUFBTUMsSUFBSSxDQUFDO1FBQUVDLFFBQVFiO0lBQWdCLEdBQUcsSUFBTTtJQUMxRGMsWUFBWTtJQUNaQyx3QkFBd0I7SUFDeEJDLGlCQUFpQm5CLHFCQUFxQkM7QUFDeEMsRUFBRTtBQUVGLFNBQVNtQixXQUFXQyxFQUFVLEVBQUVDLEVBQVUsRUFBRUMsRUFBVSxFQUFFQyxFQUFVLEVBQUVDLENBQVM7SUFDM0UsTUFBTUMsSUFBSSxDQUFDRCxJQUFJSixFQUFDLElBQU1DLENBQUFBLEtBQUtELEVBQUM7SUFDNUIsTUFBTU0sSUFBSUMsS0FBS0MsR0FBRyxDQUFDTCxLQUFLRCxJQUFJLElBQUtELENBQUFBLEtBQUtELEVBQUM7SUFDdkMsT0FBT0UsS0FBS0ssS0FBS0MsR0FBRyxDQUFDRixHQUFJRixJQUFJSjtBQUMvQjtBQUVBLFNBQVNTLGtCQUFrQnpCLElBQVk7SUFDckMsNkJBQTZCO0lBQzdCLE1BQU1nQixLQUFLLE1BQU1FLEtBQUs7SUFDdEIsTUFBTUQsS0FBSyxNQUFNRSxLQUFLO0lBQ3RCLE1BQU1PLEtBQUssTUFBTUMsS0FBSyxNQUFPLCtEQUErRDtJQUM1RixJQUFJM0IsUUFBUWlCLElBQUksT0FBT0YsV0FBV0MsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSW5CO0lBQ2xELE9BQU9lLFdBQVdFLElBQUlTLElBQUlQLElBQUlRLElBQUkzQjtBQUNwQztBQUVPLFNBQVM0QixpQkFDZEMsSUFBdUIsRUFDdkJDLGtCQUEyQixFQUMzQkMsc0JBQStCLHlCQUF5QjtBQUExQjtJQUU5QixNQUFNL0IsT0FBTzZCLEtBQUs3QixJQUFJLEdBQUc7SUFFekIsc0VBQXNFO0lBQ3RFLE1BQU1DLFdBQVc2Qix1QkFBdUJFLFlBQ3BDRixxQkFDQUwsa0JBQWtCekI7SUFFdEIsMERBQTBEO0lBQzFELE1BQU1pQyxxQkFBcUJoQyxXQUFXSjtRQUdiZ0M7SUFEekIsaUJBQWlCO0lBQ2pCLE1BQU1LLGtCQUFrQixDQUFDTCxDQUFBQSxtQkFBQUEsS0FBS3JCLFVBQVUsY0FBZnFCLDhCQUFBQSxtQkFBbUIsRUFBRSxFQUFFTSxNQUFNLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsSUFBSUMsR0FBRztJQUV4RSwyREFBMkQ7SUFDM0QsTUFBTUMsZUFBZWYsS0FBS2dCLEdBQUcsQ0FBQyxHQUFHTixxQkFBc0JKLENBQUFBLEtBQUszQixVQUFVLEdBQUdnQyxlQUFjO1FBQ25FTCxpQkFBQUE7SUFBcEIsTUFBTVcsYUFBY1gsQ0FBQUEsT0FBQUEsQ0FBQUEsa0JBQUFBLEtBQUt6QixTQUFTLGNBQWR5Qiw2QkFBQUEsa0JBQWtCQSxLQUFLMUIsVUFBVSxjQUFqQzBCLGtCQUFBQSxPQUFxQztJQUV6RCx5REFBeUQ7SUFDekQsTUFBTVksa0JBQWtCO0lBQ3hCLE1BQU1wQyxxQkFBcUJrQixLQUFLbUIsR0FBRyxDQUFDYixLQUFLeEIsa0JBQWtCLEdBQUdvQyxpQkFBaUI7SUFFL0UsK0RBQStEO0lBQy9ELGtFQUFrRTtJQUNsRSxNQUFNRSxxQkFBcUJILGFBQWE7SUFDeEMsTUFBTUksZUFBZU4sZUFBZUs7SUFDcEMsTUFBTUUsY0FBY3RCLEtBQUttQixHQUFHLENBQUNFLGNBQWN2QztJQUUzQyx5Q0FBeUM7SUFDekMsTUFBTXlDLGtCQUFrQnZCLEtBQUttQixHQUFHLENBQUNKLGNBQWNPO0lBQy9DLE1BQU1FLGdCQUFnQnhCLEtBQUtnQixHQUFHLENBQUMsR0FBR00sY0FBY0M7SUFDaEQsTUFBTUUsb0JBQW9CVixlQUFlUTtJQUV6QyxtREFBbUQ7SUFDbkQsTUFBTUcsdUJBQXVCLENBQUNsQixrQ0FBQUEsbUNBQUFBLHdCQUF5QixLQUFLLEtBQUssdUNBQXVDO0lBRXhHLCtGQUErRjtJQUMvRixNQUFNbUIsbUJBQW1CM0IsS0FBS2dCLEdBQUcsQ0FBQyxHQUFHQyxhQUFhUSxvQkFBb0JELGdCQUFnQkU7SUFFdEYsZ0VBQWdFO0lBQ2hFLE1BQU1FLGVBQWVKO1FBR0NsQjtJQUR0QiwrQkFBK0I7SUFDL0IsTUFBTXVCLFdBQVc7V0FBS3ZCLENBQUFBLG9CQUFBQSxLQUFLckIsVUFBVSxjQUFmcUIsK0JBQUFBLG9CQUFtQnBCLE1BQU1DLElBQUksQ0FBQztZQUFFQyxRQUFRYjtRQUFnQixHQUFHLElBQU07S0FBSTtRQUN6RXNEO0lBQWxCLE1BQU1DLFlBQVlELENBQUFBLGdCQUFBQSxTQUFTRSxHQUFHLGdCQUFaRiwyQkFBQUEsZ0JBQWtCO0lBQ3BDQSxTQUFTRyxPQUFPLENBQUNKO0lBRWpCLG9EQUFvRDtJQUNwRCxNQUFNakQsYUFBYTJCLEtBQUszQixVQUFVLEdBQUdtRDtJQUVyQyx5RkFBeUY7SUFDekYsNkRBQTZEO0lBQzdELE1BQU1HLHFCQUFxQmpDLEtBQUtnQixHQUFHLENBQUMsTUFBTWxDO0lBQzFDLE1BQU1vRCxrQkFBa0JQLG1CQUFtQixJQUFJQSxtQkFBbUJNLHFCQUFxQjtJQUN2RixNQUFNbEQsZUFBZWlCLEtBQUtnQixHQUFHLENBQUMsR0FBR2tCLGtCQUFrQiw2Q0FBNkM7SUFFaEcsTUFBTWxELGlCQUFpQmdCLEtBQUttQixHQUFHLENBQUMsS0FBS3pDLFdBQVdzQixLQUFLZ0IsR0FBRyxDQUFDLE1BQU1yQztJQUUvRCxlQUFlO0lBQ2YsTUFBTVUsYUFBYVcsS0FBS2dCLEdBQUcsQ0FBQyxHQUFHdEMsV0FBVzRCLEtBQUszQixVQUFVO0lBQ3pELE1BQU1XLHlCQUF5QndDLFdBQVcsc0NBQXNDO0lBRWhGLE9BQU87UUFDTHJEO1FBQ0FDO1FBQ0FDO1FBQ0FDLFlBQVkrQztRQUNaOUMsV0FBVzhDO1FBQ1gxQyxZQUFZNEM7UUFDWi9DLG9CQUFvQkE7UUFDcEJDO1FBQ0FDO1FBQ0FLO1FBQ0FDO1FBQ0FDLGlCQUFpQjJDO0lBQ25CO0FBQ0Y7QUFXTyxTQUFTQyw4QkFBOEJDLEtBQXdCO0lBQ3BFLHFEQUFxRDtJQUNyRCxNQUFNQyxvQkFBb0I7SUFDMUIsTUFBTXhCLElBQUksS0FBSyxpQkFBaUI7SUFDaEMsTUFBTUMsSUFBSSxLQUFLLFdBQVc7SUFDMUIsTUFBTXdCLFlBQVlGLE1BQU1yRCxZQUFZLEdBQUdzRDtJQUN2QyxNQUFNRSxnQkFBZ0IsSUFBSTFCLElBQUliLEtBQUtDLEdBQUcsQ0FBQ0QsS0FBS2dCLEdBQUcsQ0FBQyxHQUFHc0IsWUFBWSxJQUFJeEI7SUFFbkUscURBQXFEO0lBQ3JELE1BQU0wQixxQkFBcUI7SUFDM0IsTUFBTUMsSUFBSSxLQUFLLGlCQUFpQjtJQUNoQyxNQUFNQyxJQUFJLEtBQUssV0FBVztJQUMxQixNQUFNQyxvQkFBb0IzQyxLQUFLZ0IsR0FBRyxDQUFDLEdBQUdvQixNQUFNcEQsY0FBYyxHQUFHd0Q7SUFDN0QsTUFBTUksc0JBQXNCRCxvQkFBb0IsSUFDNUMsSUFBSUYsSUFBSXpDLEtBQUtDLEdBQUcsQ0FBQzBDLG1CQUFtQkQsS0FBSzFDLEtBQUtDLEdBQUcsQ0FBQyxJQUFJdUMsb0JBQW9CRSxLQUMxRTtJQUVKLHVEQUF1RDtJQUN2RCxNQUFNRyxrQkFBa0IsTUFBTSxvQ0FBb0M7SUFDbEUsTUFBTUMsSUFBSSxLQUFLLGlCQUFpQjtJQUNoQyxNQUFNQyxlQUFlL0MsS0FBS2dCLEdBQUcsQ0FBQyxHQUFHb0IsTUFBTTFELFFBQVEsR0FBR21FO0lBQ2xELE1BQU1HLGtCQUFrQixJQUFJRixJQUFLQyxDQUFBQSxlQUFlRixlQUFjO0lBRTlELGdEQUFnRDtJQUNoRCxNQUFNSSxpQkFBaUI7SUFDdkIsTUFBTUMsZ0JBQWdCWCxnQkFBZ0JLLHNCQUFzQkk7SUFDNUQsTUFBTUcsdUJBQXVCbkQsS0FBS21CLEdBQUcsQ0FBQzhCLGdCQUFnQkM7SUFFdEQseUJBQXlCO0lBQ3pCLE1BQU1FLGtCQUFrQnBELEtBQUtxRCxHQUFHLENBQUNGLHVCQUF1QkQ7SUFDeEQsSUFBSUUsa0JBQWtCLFFBQVFGLGdCQUFnQkQsZ0JBQWdCO1FBQzVELE1BQU0sSUFBSUssTUFBTSwyQ0FBd0VKLE9BQTdCQyxzQkFBcUIsVUFBZ0NDLE9BQXhCRixlQUFjLFlBQTBCLE9BQWhCRTtJQUNsSDtJQUVBLE9BQU87UUFDTEQ7UUFDQUksWUFBWTtZQUNWaEI7WUFDQUs7WUFDQUk7UUFDRjtJQUNGO0FBQ0Y7QUFFTyxTQUFTUSwrQkFBK0JDLFNBQWlCLEVBQUVDLE9BQWU7SUFDL0UsTUFBTUMsYUFBa0M7UUFBQ25GO0tBQXFCO0lBRTlELElBQUlvRixVQUFVcEY7SUFDZCxJQUFJcUYsZ0JBQWdCRCxRQUFRN0UsWUFBWTtJQUV4QyxJQUFLLElBQUlOLE9BQU9nRixZQUFZLEdBQUdoRixRQUFRaUYsU0FBU2pGLE9BQVE7UUFDdERtRixVQUFVdkQsaUJBQWlCdUQ7UUFFM0IsK0dBQStHO1FBQy9HLHVHQUF1RztRQUN2RyxnREFBZ0Q7UUFDaEQsdUVBQXVFO1FBQ3ZFLDRCQUE0QjtRQUM1QixrRUFBa0U7UUFDbEUsOEJBQThCO1FBQzlCLHlCQUF5QjtRQUN6QiwwR0FBMEc7UUFDMUcseUZBQXlGO1FBQ3pGLDRGQUE0RjtRQUM1Rix3RUFBd0U7UUFDeEUsV0FBVztRQUNYLGVBQWU7UUFDZixzQkFBc0I7UUFDdEIsd0dBQXdHO1FBQ3hHLHlGQUF5RjtRQUN6RixtRkFBbUY7UUFDbkYsV0FBVztRQUNYLFFBQVE7UUFDUixNQUFNO1FBQ04sSUFBSTtRQUVKQyxnQkFBZ0JELFFBQVE3RSxZQUFZO1FBQ3BDNEUsV0FBV0csSUFBSSxDQUFDRjtJQUNsQjtJQUVBLE9BQU9EO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9tb2RlbC9ncm91bmRfcXVldWVfbW9kZWwudHM/ODEyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERlbWFuZC1Ecml2ZW4gR3JvdW5kIENvbnN0cmFpbnQgTW9kZWxcbiAqIFxuICogUmVwbGFjZXMgdGltZS1iYXNlZCBjb25zdHJhaW50IHdpdGggcXVldWUtYmFzZWQgc3VwcGx5L2RlbWFuZCBtb2RlbC5cbiAqIE1vZGVscyByZWFsLXdvcmxkIGNhcGFjaXR5IGNvbnN0cmFpbnRzLCBidWlsZCByYXRlcywgYW5kIHdhaXQgdGltZXMuXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBHcm91bmRTdXBwbHlTdGF0ZSB7XG4gIHllYXI6IG51bWJlcjtcbiAgZGVtYW5kR3c6IG51bWJlcjtcbiAgY2FwYWNpdHlHdzogbnVtYmVyOyAvLyBFZmZlY3RpdmUgZGVsaXZlcmFibGUgY2FwYWNpdHkgKGJvdHRsZW5lY2spXG4gIHBpcGVsaW5lR3c6IG51bWJlcjsgLy8gTGVnYWN5IG5hbWUsIHNhbWUgYXMgYmFja2xvZ0d3XG4gIGJhY2tsb2dHdzogbnVtYmVyOyAvLyBFeHBsaWNpdCBiYWNrbG9nIHN0YXRlIChHVyB3YWl0aW5nIHRvIGJlIGJ1aWx0KVxuICBtYXhCdWlsZFJhdGVHd1llYXI6IG51bWJlcjsgLy8gQnVpbGQgcmF0ZSAoR1cveWVhcilcbiAgYXZnV2FpdFllYXJzOiBudW1iZXI7XG4gIHV0aWxpemF0aW9uUGN0OiBudW1iZXI7XG4gIGluZmxpZ2h0R3c/OiBudW1iZXJbXTsgLy8gSW5mbGlnaHQgY2FwYWNpdHkgYnVmZmVyIChsZW5ndGggPSBCVUlMRF9MQUdfWUVBUlMpXG4gIC8vIERlYnVnIGZpZWxkc1xuICB1bnNlcnZlZEd3OiBudW1iZXI7IC8vIFVubWV0IGRlbWFuZCB0aGlzIHllYXJcbiAgZGVsaXZlcmVkRnJvbUJhY2tsb2dHdzogbnVtYmVyOyAvLyBDYXBhY2l0eSBkZWxpdmVyZWQgZnJvbSBiYWNrbG9nIHRoaXMgeWVhclxuICBhdmdXYWl0WWVhcnNSYXc6IG51bWJlcjsgLy8gUmF3IHdhaXQgdGltZSBiZWZvcmUgc21vb3RoaW5nXG59XG5cbi8vIEV4cGxpY2l0IGluaXRpYWwgYmFja2xvZyAodHVuYWJsZSBwYXJhbWV0ZXIpXG5jb25zdCBJTklUSUFMX0JBQ0tMT0dfR1cgPSA1MDsgLy8gMzAtMTAwIEdXIGJhc2VsaW5lIGJhY2tsb2cgaW4gMjAyNVxuY29uc3QgSU5JVElBTF9CVUlMRF9SQVRFX0dXX1lFQVIgPSAxMjsgLy8gSW5pdGlhbCBidWlsZCByYXRlIChzbG93ZXIgdGhhbiBkZW1hbmQgZ3Jvd3RoKVxuY29uc3QgVEFSR0VUX1VUSUwgPSAwLjg1O1xuY29uc3QgQlVJTERfTEFHX1lFQVJTID0gMjtcblxuZXhwb3J0IGNvbnN0IElOSVRJQUxfU1VQUExZX1NUQVRFOiBHcm91bmRTdXBwbHlTdGF0ZSA9IHtcbiAgeWVhcjogMjAyNSxcbiAgZGVtYW5kR3c6IDEyMCxcbiAgY2FwYWNpdHlHdzogMTIwLCAvLyBTdGFydCBhdCBkZW1hbmQgbGV2ZWwgKG5vIHN1cnBsdXMpXG4gIHBpcGVsaW5lR3c6IElOSVRJQUxfQkFDS0xPR19HVyxcbiAgYmFja2xvZ0d3OiBJTklUSUFMX0JBQ0tMT0dfR1csIC8vIEV4cGxpY2l0IGluaXRpYWwgYmFja2xvZ1xuICBtYXhCdWlsZFJhdGVHd1llYXI6IElOSVRJQUxfQlVJTERfUkFURV9HV19ZRUFSLFxuICBhdmdXYWl0WWVhcnM6IElOSVRJQUxfQkFDS0xPR19HVyAvIElOSVRJQUxfQlVJTERfUkFURV9HV19ZRUFSLCAvLyBJbml0aWFsIHdhaXQgZnJvbSBiYWNrbG9nXG4gIHV0aWxpemF0aW9uUGN0OiAxLjAsIC8vIEF0IGNhcGFjaXR5XG4gIGluZmxpZ2h0R3c6IEFycmF5LmZyb20oeyBsZW5ndGg6IEJVSUxEX0xBR19ZRUFSUyB9LCAoKSA9PiAwKSxcbiAgdW5zZXJ2ZWRHdzogMCxcbiAgZGVsaXZlcmVkRnJvbUJhY2tsb2dHdzogMCxcbiAgYXZnV2FpdFllYXJzUmF3OiBJTklUSUFMX0JBQ0tMT0dfR1cgLyBJTklUSUFMX0JVSUxEX1JBVEVfR1dfWUVBUixcbn07XG5cbmZ1bmN0aW9uIGV4cFNlZ21lbnQoeTA6IG51bWJlciwgeTE6IG51bWJlciwgdjA6IG51bWJlciwgdjE6IG51bWJlciwgeTogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgdCA9ICh5IC0geTApIC8gKHkxIC0geTApO1xuICBjb25zdCByID0gTWF0aC5wb3codjEgLyB2MCwgMSAvICh5MSAtIHkwKSk7XG4gIHJldHVybiB2MCAqIE1hdGgucG93KHIsICh5IC0geTApKTtcbn1cblxuZnVuY3Rpb24gZ2V0R2xvYmFsRGVtYW5kR3coeWVhcjogbnVtYmVyKTogbnVtYmVyIHtcbiAgLy8gQW5jaG9ycyAodHVuZSBpZiB5b3Ugd2FudClcbiAgY29uc3QgeTAgPSAyMDI1LCB2MCA9IDEyMDtcbiAgY29uc3QgeTEgPSAyMDQwLCB2MSA9IDQ1MDtcbiAgY29uc3QgeTIgPSAyMDYwLCB2MiA9IDMwMDA7ICAvLyBcInRlcmF3YXR0cyBieSAyMDYwXCIgLT4gMyBUVyBoZXJlOyBjaGFuZ2UgdG8gNTAwMCBpZiB5b3Ugd2FudFxuICBpZiAoeWVhciA8PSB5MSkgcmV0dXJuIGV4cFNlZ21lbnQoeTAsIHkxLCB2MCwgdjEsIHllYXIpO1xuICByZXR1cm4gZXhwU2VnbWVudCh5MSwgeTIsIHYxLCB2MiwgeWVhcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGVwR3JvdW5kU3VwcGx5KFxuICBwcmV2OiBHcm91bmRTdXBwbHlTdGF0ZSxcbiAgcmVzcG9uc2l2ZURlbWFuZEdXPzogbnVtYmVyLCAvLyBORVc6IE92ZXJyaWRlIGhhcmRjb2RlZCBkZW1hbmRcbiAgb3JiaXRhbFN1YnN0aXR1dGlvbkdXPzogbnVtYmVyIC8vIE5FVzogRm9yIGJhY2tsb2cgZHJhaW5cbik6IEdyb3VuZFN1cHBseVN0YXRlIHtcbiAgY29uc3QgeWVhciA9IHByZXYueWVhciArIDE7XG4gIFxuICAvLyBVc2UgcmVzcG9uc2l2ZSBkZW1hbmQgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSBmYWxsIGJhY2sgdG8gaGFyZGNvZGVkXG4gIGNvbnN0IGRlbWFuZEd3ID0gcmVzcG9uc2l2ZURlbWFuZEdXICE9PSB1bmRlZmluZWQgXG4gICAgPyByZXNwb25zaXZlRGVtYW5kR1cgXG4gICAgOiBnZXRHbG9iYWxEZW1hbmRHdyh5ZWFyKTtcbiAgXG4gIC8vIENhcGFjaXR5IHJlcXVpcmVkIHRvIHNlcnZlIGRlbWFuZCBhdCB0YXJnZXQgdXRpbGl6YXRpb25cbiAgY29uc3QgcmVxdWlyZWRDYXBhY2l0eUd3ID0gZGVtYW5kR3cgLyBUQVJHRVRfVVRJTDtcbiAgXG4gIC8vIENvdW50IGluZmxpZ2h0XG4gIGNvbnN0IGluZmxpZ2h0VG90YWxHdyA9IChwcmV2LmluZmxpZ2h0R3cgPz8gW10pLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICBcbiAgLy8gTmV3IGRlZmljaXQgZW50ZXJzIGJhY2tsb2cgKHByb2plY3RzIHRoYXQgbXVzdCBiZSBidWlsdClcbiAgY29uc3QgbmV3RGVmaWNpdEd3ID0gTWF0aC5tYXgoMCwgcmVxdWlyZWRDYXBhY2l0eUd3IC0gKHByZXYuY2FwYWNpdHlHdyArIGluZmxpZ2h0VG90YWxHdykpO1xuICBjb25zdCBiYWNrbG9nR3cwID0gKHByZXYuYmFja2xvZ0d3ID8/IHByZXYucGlwZWxpbmVHdyA/PyAwKTtcbiAgXG4gIC8vIEJ1aWxkIHJhdGUgcmFtcHMsIGJ1dCBjYW5ub3QgaW5zdGFudGx5IGVyYXNlIHRoZSBxdWV1ZVxuICBjb25zdCBidWlsZFJhdGVHcm93dGggPSAxLjA1O1xuICBjb25zdCBtYXhCdWlsZFJhdGVHd1llYXIgPSBNYXRoLm1pbihwcmV2Lm1heEJ1aWxkUmF0ZUd3WWVhciAqIGJ1aWxkUmF0ZUdyb3d0aCwgNTApO1xuICBcbiAgLy8gQnVpbGQgc2VydmVzIEJPVEggbmV3IGRlbWFuZCBBTkQgYmFja2xvZyAoYmFja2xvZyBjYW4gZHJhaW4pXG4gIC8vIFRyeSB0byBjbGVhciAxNSUgb2YgYmFja2xvZyBwZXIgeWVhciBpbiBhZGRpdGlvbiB0byBuZXcgZGVmaWNpdFxuICBjb25zdCBiYWNrbG9nQ2xlYXJUYXJnZXQgPSBiYWNrbG9nR3cwICogMC4xNTtcbiAgY29uc3QgdG90YWxUb0J1aWxkID0gbmV3RGVmaWNpdEd3ICsgYmFja2xvZ0NsZWFyVGFyZ2V0O1xuICBjb25zdCBhY3R1YWxCdWlsdCA9IE1hdGgubWluKHRvdGFsVG9CdWlsZCwgbWF4QnVpbGRSYXRlR3dZZWFyKTtcbiAgXG4gIC8vIE5ldyBkZW1hbmQgZ2V0cyBwcmlvcml0eSwgdGhlbiBiYWNrbG9nXG4gIGNvbnN0IHNlcnZlZE5ld0RlbWFuZCA9IE1hdGgubWluKG5ld0RlZmljaXRHdywgYWN0dWFsQnVpbHQpO1xuICBjb25zdCBzZXJ2ZWRCYWNrbG9nID0gTWF0aC5tYXgoMCwgYWN0dWFsQnVpbHQgLSBzZXJ2ZWROZXdEZW1hbmQpO1xuICBjb25zdCB1bnNlcnZlZE5ld0RlbWFuZCA9IG5ld0RlZmljaXRHdyAtIHNlcnZlZE5ld0RlbWFuZDtcbiAgXG4gIC8vIE5FVzogQmFja2xvZyBjYW4gZHJhaW4gZnJvbSBvcmJpdGFsIHN1YnN0aXR1dGlvblxuICBjb25zdCBpbXBsaWNpdEJhY2tsb2dEcmFpbiA9IChvcmJpdGFsU3Vic3RpdHV0aW9uR1cgPz8gMCkgKiAwLjU7IC8vIDUwJSBvZiBzaGlmdGVkIGRlbWFuZCB3YXMgaW4gYmFja2xvZ1xuICBcbiAgLy8gVXBkYXRlIGJhY2tsb2cgKGNvbnNlcnZhdGlvbjogYmFja2xvZ1t0KzFdID0gYmFja2xvZ1t0XSArIHVuc2VydmVkIC0gc2VydmVkIC0gb3JiaXRhbCBkcmFpbilcbiAgY29uc3QgdXBkYXRlZEJhY2tsb2dHdyA9IE1hdGgubWF4KDAsIGJhY2tsb2dHdzAgKyB1bnNlcnZlZE5ld0RlbWFuZCAtIHNlcnZlZEJhY2tsb2cgLSBpbXBsaWNpdEJhY2tsb2dEcmFpbik7XG4gIFxuICAvLyBTdGFydCBjb25zdHJ1Y3Rpb24gZnJvbSBiYWNrbG9nIChwcm9qZWN0cyBtb3ZlIGludG8gaW5mbGlnaHQpXG4gIGNvbnN0IHN0YXJ0QnVpbGRHdyA9IHNlcnZlZEJhY2tsb2c7XG4gIFxuICAvLyBNb3ZlIEdXIHRocm91Z2ggbGFnIHBpcGVsaW5lXG4gIGNvbnN0IGluZmxpZ2h0ID0gWy4uLihwcmV2LmluZmxpZ2h0R3cgPz8gQXJyYXkuZnJvbSh7IGxlbmd0aDogQlVJTERfTEFHX1lFQVJTIH0sICgpID0+IDApKV07XG4gIGNvbnN0IG9ubGluZU5vdyA9IGluZmxpZ2h0LnBvcCgpID8/IDA7XG4gIGluZmxpZ2h0LnVuc2hpZnQoc3RhcnRCdWlsZEd3KTtcbiAgXG4gIC8vIENhcGFjaXR5IGluY3JlYXNlcyBvbmx5IHdoZW4gcHJvamVjdHMgY29tZSBvbmxpbmVcbiAgY29uc3QgY2FwYWNpdHlHdyA9IHByZXYuY2FwYWNpdHlHdyArIG9ubGluZU5vdztcbiAgXG4gIC8vIFdhaXQgdGltZSBpcyBxdWV1ZSAvIHN0YXJ0IHJhdGUgKE5PIENMQU1QIC0gbGV0IGl0IGdvIHRvIDEwMCsgeWVhcnMgaWYgdGhhdCdzIHJlYWxpdHkpXG4gIC8vIFRoaXMgZm9sbG93cyBMaXR0bGUncyBMYXc6IHdhaXRZZWFycyA9IGJhY2tsb2cgLyBidWlsZFJhdGVcbiAgY29uc3QgZWZmZWN0aXZlU3RhcnRSYXRlID0gTWF0aC5tYXgoMWUtNiwgbWF4QnVpbGRSYXRlR3dZZWFyKTtcbiAgY29uc3QgcmF3QXZnV2FpdFllYXJzID0gdXBkYXRlZEJhY2tsb2dHdyA+IDAgPyB1cGRhdGVkQmFja2xvZ0d3IC8gZWZmZWN0aXZlU3RhcnRSYXRlIDogMDtcbiAgY29uc3QgYXZnV2FpdFllYXJzID0gTWF0aC5tYXgoMCwgcmF3QXZnV2FpdFllYXJzKTsgLy8gTm8gdXBwZXIgY2xhbXAgLSBwcmVzZXJ2ZXMgc2NhcmNpdHkgc2lnbmFsXG4gIFxuICBjb25zdCB1dGlsaXphdGlvblBjdCA9IE1hdGgubWluKDEuMCwgZGVtYW5kR3cgLyBNYXRoLm1heCgxZS02LCBjYXBhY2l0eUd3KSk7XG4gIFxuICAvLyBEZWJ1ZyBmaWVsZHNcbiAgY29uc3QgdW5zZXJ2ZWRHdyA9IE1hdGgubWF4KDAsIGRlbWFuZEd3IC0gcHJldi5jYXBhY2l0eUd3KTtcbiAgY29uc3QgZGVsaXZlcmVkRnJvbUJhY2tsb2dHdyA9IG9ubGluZU5vdzsgLy8gQ2FwYWNpdHkgdGhhdCBjYW1lIG9ubGluZSB0aGlzIHllYXJcbiAgXG4gIHJldHVybiB7XG4gICAgeWVhcixcbiAgICBkZW1hbmRHdyxcbiAgICBjYXBhY2l0eUd3LFxuICAgIHBpcGVsaW5lR3c6IHVwZGF0ZWRCYWNrbG9nR3csIC8vIEtlZXAgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICBiYWNrbG9nR3c6IHVwZGF0ZWRCYWNrbG9nR3csXG4gICAgaW5mbGlnaHRHdzogaW5mbGlnaHQsXG4gICAgbWF4QnVpbGRSYXRlR3dZZWFyOiBtYXhCdWlsZFJhdGVHd1llYXIsXG4gICAgYXZnV2FpdFllYXJzLFxuICAgIHV0aWxpemF0aW9uUGN0LFxuICAgIHVuc2VydmVkR3csXG4gICAgZGVsaXZlcmVkRnJvbUJhY2tsb2dHdyxcbiAgICBhdmdXYWl0WWVhcnNSYXc6IHJhd0F2Z1dhaXRZZWFycyxcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb25zdHJhaW50UmVzdWx0IHtcbiAgY29uc3RyYWludE11bHRpcGxpZXI6IG51bWJlcjtcbiAgY29tcG9uZW50czoge1xuICAgIHF1ZXVlUHJlc3N1cmU6IG51bWJlcjtcbiAgICB1dGlsaXphdGlvblByZXNzdXJlOiBudW1iZXI7XG4gICAgc2NhcmNpdHlQcmVtaXVtOiBudW1iZXI7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVDb25zdHJhaW50RnJvbVN1cHBseShzdGF0ZTogR3JvdW5kU3VwcGx5U3RhdGUpOiBDb25zdHJhaW50UmVzdWx0IHtcbiAgLy8gUXVldWUgcHJlc3N1cmU6IGdyb3dzIHdpdGggd2FpdCB0aW1lIGJleW9uZCB0YXJnZXRcbiAgY29uc3QgVEFSR0VUX1dBSVRfWUVBUlMgPSAyO1xuICBjb25zdCBhID0gMC41OyAvLyBTY2FsaW5nIGZhY3RvclxuICBjb25zdCBiID0gMS41OyAvLyBFeHBvbmVudFxuICBjb25zdCB3YWl0UmF0aW8gPSBzdGF0ZS5hdmdXYWl0WWVhcnMgLyBUQVJHRVRfV0FJVF9ZRUFSUztcbiAgY29uc3QgcXVldWVQcmVzc3VyZSA9IDEgKyBhICogTWF0aC5wb3coTWF0aC5tYXgoMCwgd2FpdFJhdGlvIC0gMSksIGIpO1xuICBcbiAgLy8gVXRpbGl6YXRpb24gcHJlc3N1cmU6IGdyb3dzIHdoZW4gY2FwYWNpdHkgaXMgdGlnaHRcbiAgY29uc3QgU0NBUkNJVFlfVEhSRVNIT0xEID0gMC44NTtcbiAgY29uc3QgYyA9IDUuMDsgLy8gU2NhbGluZyBmYWN0b3JcbiAgY29uc3QgZCA9IDIuMDsgLy8gRXhwb25lbnRcbiAgY29uc3QgdXRpbGl6YXRpb25FeGNlc3MgPSBNYXRoLm1heCgwLCBzdGF0ZS51dGlsaXphdGlvblBjdCAtIFNDQVJDSVRZX1RIUkVTSE9MRCk7XG4gIGNvbnN0IHV0aWxpemF0aW9uUHJlc3N1cmUgPSB1dGlsaXphdGlvbkV4Y2VzcyA+IDBcbiAgICA/IDEgKyBjICogTWF0aC5wb3codXRpbGl6YXRpb25FeGNlc3MsIGQpIC8gTWF0aC5wb3coMSAtIFNDQVJDSVRZX1RIUkVTSE9MRCwgZClcbiAgICA6IDE7XG4gIFxuICAvLyBTY2FyY2l0eSBwcmVtaXVtOiBkZW1hbmQgZXhjZWVkaW5nIHJlZ2lvbmFsIGNhcGFjaXR5XG4gIGNvbnN0IFJFR0lPTkFMX01BWF9HVyA9IDIwMDA7IC8vIFRoZW9yZXRpY2FsIG1heCByZWdpb25hbCBjYXBhY2l0eVxuICBjb25zdCBlID0gMC4xOyAvLyBTY2FsaW5nIGZhY3RvclxuICBjb25zdCBkZW1hbmRFeGNlc3MgPSBNYXRoLm1heCgwLCBzdGF0ZS5kZW1hbmRHdyAtIFJFR0lPTkFMX01BWF9HVyk7XG4gIGNvbnN0IHNjYXJjaXR5UHJlbWl1bSA9IDEgKyBlICogKGRlbWFuZEV4Y2VzcyAvIFJFR0lPTkFMX01BWF9HVyk7XG4gIFxuICAvLyBDb25zdHJhaW50ID0gcHJvZHVjdCBvZiBhbGwgcHJlc3N1cmVzLCBjYXBwZWRcbiAgY29uc3QgTUFYX0NPTlNUUkFJTlQgPSA1MDtcbiAgY29uc3QgcmF3Q29uc3RyYWludCA9IHF1ZXVlUHJlc3N1cmUgKiB1dGlsaXphdGlvblByZXNzdXJlICogc2NhcmNpdHlQcmVtaXVtO1xuICBjb25zdCBjb25zdHJhaW50TXVsdGlwbGllciA9IE1hdGgubWluKE1BWF9DT05TVFJBSU5ULCByYXdDb25zdHJhaW50KTtcbiAgXG4gIC8vIERlYnVnOiByZWNvbXB1dGUgY2hlY2tcbiAgY29uc3QgY29uc3RyYWludENoZWNrID0gTWF0aC5hYnMoY29uc3RyYWludE11bHRpcGxpZXIgLSByYXdDb25zdHJhaW50KTtcbiAgaWYgKGNvbnN0cmFpbnRDaGVjayA+IDFlLTYgJiYgcmF3Q29uc3RyYWludCA8IE1BWF9DT05TVFJBSU5UKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb25zdHJhaW50IGZvcm11bGEgbWlzbWF0Y2g6IG11bHRpcGxpZXI9JHtjb25zdHJhaW50TXVsdGlwbGllcn0sIHJhdz0ke3Jhd0NvbnN0cmFpbnR9LCBjaGVjaz0ke2NvbnN0cmFpbnRDaGVja31gKTtcbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICBjb25zdHJhaW50TXVsdGlwbGllcixcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBxdWV1ZVByZXNzdXJlLFxuICAgICAgdXRpbGl6YXRpb25QcmVzc3VyZSxcbiAgICAgIHNjYXJjaXR5UHJlbWl1bSxcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVHcm91bmRTdXBwbHlUcmFqZWN0b3J5KHN0YXJ0WWVhcjogbnVtYmVyLCBlbmRZZWFyOiBudW1iZXIpOiBHcm91bmRTdXBwbHlTdGF0ZVtdIHtcbiAgY29uc3QgdHJhamVjdG9yeTogR3JvdW5kU3VwcGx5U3RhdGVbXSA9IFtJTklUSUFMX1NVUFBMWV9TVEFURV07XG4gIFxuICBsZXQgY3VycmVudCA9IElOSVRJQUxfU1VQUExZX1NUQVRFO1xuICBsZXQgcHJldldhaXRZZWFycyA9IGN1cnJlbnQuYXZnV2FpdFllYXJzO1xuICBcbiAgZm9yIChsZXQgeWVhciA9IHN0YXJ0WWVhciArIDE7IHllYXIgPD0gZW5kWWVhcjsgeWVhcisrKSB7XG4gICAgY3VycmVudCA9IHN0ZXBHcm91bmRTdXBwbHkoY3VycmVudCk7XG4gICAgXG4gICAgLy8gQXNzZXJ0OiBpZiBhdmdXYWl0WWVhcnMgY2hhbmdlcyBieSA+IDEuMCB5ZWFyIGJldHdlZW4gYWRqYWNlbnQgeWVhcnMsIHdhcm4vdGhyb3cgaW4gZGV2ICh0aGlzIGNhdGNoZXMgc25hcHMpXG4gICAgLy8gTk9URTogRGlzYWJsZWQgdGVtcG9yYXJpbHkgLSBzbW9vdGhpbmcgbG9naWMgbm93IHByZXZlbnRzIHNuYXBzLCBzbyB0aGlzIGFzc2VydGlvbiBtYXkgYmUgdG9vIHN0cmljdFxuICAgIC8vIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIC8vICAgY29uc3Qgd2FpdENoYW5nZSA9IE1hdGguYWJzKGN1cnJlbnQuYXZnV2FpdFllYXJzIC0gcHJldldhaXRZZWFycyk7XG4gICAgLy8gICBpZiAod2FpdENoYW5nZSA+IDEuMCkge1xuICAgIC8vICAgICAvLyBPbmx5IHRocm93IGZvciBleHRyZW1lIHNuYXBzICg+IDMgeWVhcnMpLCBvdGhlcndpc2Ugd2FyblxuICAgIC8vICAgICBpZiAod2FpdENoYW5nZSA+IDMuMCkge1xuICAgIC8vICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAvLyAgICAgICAgIGBbSU5WQVJJQU5UIFZJT0xBVElPTl0gWWVhciAke3llYXJ9OiBhdmdXYWl0WWVhcnMgY2hhbmdlZCBieSAke3dhaXRDaGFuZ2UudG9GaXhlZCgyKX0geWVhcnMgYCArXG4gICAgLy8gICAgICAgICBgKGZyb20gJHtwcmV2V2FpdFllYXJzLnRvRml4ZWQoMil9IHRvICR7Y3VycmVudC5hdmdXYWl0WWVhcnMudG9GaXhlZCgyKX0pLiBgICtcbiAgICAvLyAgICAgICAgIGBUaGlzIGluZGljYXRlcyBhIHNldmVyZSBzbmFwL2Rpc2NvbnRpbnVpdHkuIE1heCBhbGxvd2VkIGNoYW5nZSBpcyAzLjAgeWVhcnMuIGAgK1xuICAgIC8vICAgICAgICAgYENoZWNrIGRlbGl2ZXJhYmlsaXR5IGRlZmljaXQgY2FsY3VsYXRpb24gYW5kIGJhY2tsb2cgbG9naWMuYFxuICAgIC8vICAgICAgICk7XG4gICAgLy8gICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgY29uc29sZS53YXJuKFxuICAgIC8vICAgICAgICAgYFtJTlZBUklBTlQgV0FSTklOR10gWWVhciAke3llYXJ9OiBhdmdXYWl0WWVhcnMgY2hhbmdlZCBieSAke3dhaXRDaGFuZ2UudG9GaXhlZCgyKX0geWVhcnMgYCArXG4gICAgLy8gICAgICAgICBgKGZyb20gJHtwcmV2V2FpdFllYXJzLnRvRml4ZWQoMil9IHRvICR7Y3VycmVudC5hdmdXYWl0WWVhcnMudG9GaXhlZCgyKX0pLiBgICtcbiAgICAvLyAgICAgICAgIGBUaGlzIG1heSBpbmRpY2F0ZSBhIHNuYXAvZGlzY29udGludWl0eS4gRXhwZWN0ZWQgY2hhbmdlIGlzIDwgMS4wIHllYXIuYFxuICAgIC8vICAgICAgICk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gICAgXG4gICAgcHJldldhaXRZZWFycyA9IGN1cnJlbnQuYXZnV2FpdFllYXJzO1xuICAgIHRyYWplY3RvcnkucHVzaChjdXJyZW50KTtcbiAgfVxuICBcbiAgcmV0dXJuIHRyYWplY3Rvcnk7XG59XG5cbiJdLCJuYW1lcyI6WyJJTklUSUFMX0JBQ0tMT0dfR1ciLCJJTklUSUFMX0JVSUxEX1JBVEVfR1dfWUVBUiIsIlRBUkdFVF9VVElMIiwiQlVJTERfTEFHX1lFQVJTIiwiSU5JVElBTF9TVVBQTFlfU1RBVEUiLCJ5ZWFyIiwiZGVtYW5kR3ciLCJjYXBhY2l0eUd3IiwicGlwZWxpbmVHdyIsImJhY2tsb2dHdyIsIm1heEJ1aWxkUmF0ZUd3WWVhciIsImF2Z1dhaXRZZWFycyIsInV0aWxpemF0aW9uUGN0IiwiaW5mbGlnaHRHdyIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsInVuc2VydmVkR3ciLCJkZWxpdmVyZWRGcm9tQmFja2xvZ0d3IiwiYXZnV2FpdFllYXJzUmF3IiwiZXhwU2VnbWVudCIsInkwIiwieTEiLCJ2MCIsInYxIiwieSIsInQiLCJyIiwiTWF0aCIsInBvdyIsImdldEdsb2JhbERlbWFuZEd3IiwieTIiLCJ2MiIsInN0ZXBHcm91bmRTdXBwbHkiLCJwcmV2IiwicmVzcG9uc2l2ZURlbWFuZEdXIiwib3JiaXRhbFN1YnN0aXR1dGlvbkdXIiwidW5kZWZpbmVkIiwicmVxdWlyZWRDYXBhY2l0eUd3IiwiaW5mbGlnaHRUb3RhbEd3IiwicmVkdWNlIiwiYSIsImIiLCJuZXdEZWZpY2l0R3ciLCJtYXgiLCJiYWNrbG9nR3cwIiwiYnVpbGRSYXRlR3Jvd3RoIiwibWluIiwiYmFja2xvZ0NsZWFyVGFyZ2V0IiwidG90YWxUb0J1aWxkIiwiYWN0dWFsQnVpbHQiLCJzZXJ2ZWROZXdEZW1hbmQiLCJzZXJ2ZWRCYWNrbG9nIiwidW5zZXJ2ZWROZXdEZW1hbmQiLCJpbXBsaWNpdEJhY2tsb2dEcmFpbiIsInVwZGF0ZWRCYWNrbG9nR3ciLCJzdGFydEJ1aWxkR3ciLCJpbmZsaWdodCIsIm9ubGluZU5vdyIsInBvcCIsInVuc2hpZnQiLCJlZmZlY3RpdmVTdGFydFJhdGUiLCJyYXdBdmdXYWl0WWVhcnMiLCJjYWxjdWxhdGVDb25zdHJhaW50RnJvbVN1cHBseSIsInN0YXRlIiwiVEFSR0VUX1dBSVRfWUVBUlMiLCJ3YWl0UmF0aW8iLCJxdWV1ZVByZXNzdXJlIiwiU0NBUkNJVFlfVEhSRVNIT0xEIiwiYyIsImQiLCJ1dGlsaXphdGlvbkV4Y2VzcyIsInV0aWxpemF0aW9uUHJlc3N1cmUiLCJSRUdJT05BTF9NQVhfR1ciLCJlIiwiZGVtYW5kRXhjZXNzIiwic2NhcmNpdHlQcmVtaXVtIiwiTUFYX0NPTlNUUkFJTlQiLCJyYXdDb25zdHJhaW50IiwiY29uc3RyYWludE11bHRpcGxpZXIiLCJjb25zdHJhaW50Q2hlY2siLCJhYnMiLCJFcnJvciIsImNvbXBvbmVudHMiLCJnZW5lcmF0ZUdyb3VuZFN1cHBseVRyYWplY3RvcnkiLCJzdGFydFllYXIiLCJlbmRZZWFyIiwidHJhamVjdG9yeSIsImN1cnJlbnQiLCJwcmV2V2FpdFllYXJzIiwicHVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/ground_queue_model.ts\n"));

/***/ })

});