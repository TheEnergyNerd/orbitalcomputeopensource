"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/compare/page",{

/***/ "(app-pages-browser)/./app/lib/utils/chartValidator.ts":
/*!*****************************************!*\
  !*** ./app/lib/utils/chartValidator.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CHART_CONTRACTS: function() { return /* binding */ CHART_CONTRACTS; },\n/* harmony export */   ensureGroundData: function() { return /* binding */ ensureGroundData; },\n/* harmony export */   validateAllCharts: function() { return /* binding */ validateAllCharts; },\n/* harmony export */   validateChartData: function() { return /* binding */ validateChartData; }\n/* harmony export */ });\n/**\n * Chart Data Validator\n * \n * Validates that exported data has required paths for each chart.\n * Used to catch missing data early and provide helpful error messages.\n */ /**\n * Chart contracts - defines what data each chart needs\n */ const CHART_CONTRACTS = [\n    {\n        chartName: \"GPU-Hour Pricing\",\n        requiredPaths: [\n            \"orbit.gpuHourPricing.standard.pricePerGpuHour\",\n            \"ground.gpuHourPricing.standard.pricePerGpuHour\"\n        ]\n    },\n    {\n        chartName: \"Ground Buildout Constraints\",\n        requiredPaths: [\n            \"ground.buildoutDebug.demandGW\",\n            \"ground.buildoutDebug.buildRateGWyr\",\n            \"ground.buildoutDebug.backlogGW\",\n            \"ground.buildoutDebug.timeToPowerYears\"\n        ],\n        optionalPaths: [\n            \"ground.buildoutDebug.demandNewGW\",\n            \"ground.buildoutDebug.capacityGW\",\n            \"ground.buildoutDebug.pipelineGW\"\n        ]\n    },\n    {\n        chartName: \"Power Buildout\",\n        requiredPaths: [\n            \"ground.buildoutDebug.demandGW\",\n            \"ground.supplyMetrics.maxBuildRateGwYear\",\n            \"ground.backlogGw\",\n            \"ground.avgWaitYears\"\n        ]\n    }\n];\n/**\n * Get value at a nested path (e.g., \"orbit.gpuHourPricing.standard.pricePerGpuHour\")\n */ function getValueAtPath(obj, path) {\n    const parts = path.split(\".\");\n    let current = obj;\n    for (const part of parts){\n        if (current === null || current === undefined) {\n            return undefined;\n        }\n        current = current[part];\n    }\n    return current;\n}\n/**\n * Find nearest valid path when a required path is missing\n */ function findNearestPath(obj, missingPath) {\n    const parts = missingPath.split(\".\");\n    for(let i = parts.length - 1; i > 0; i--){\n        const partialPath = parts.slice(0, i).join(\".\");\n        const value = getValueAtPath(obj, partialPath);\n        if (value !== null && value !== undefined) {\n            return partialPath;\n        }\n    }\n    return undefined;\n}\n/**\n * Validate a single data point against a chart contract\n */ function validateChartData(data, contract, scenarioId, year) {\n    const missingPaths = [];\n    for (const path of contract.requiredPaths){\n        const value = getValueAtPath(data, path);\n        // Treat 0 as valid (it is), but keep NaN/undefined invalid\n        if (value === null || value === undefined || !isFinite(value) && value !== 0) {\n            missingPaths.push(path);\n        }\n    }\n    const nearestPath = missingPaths.length > 0 ? findNearestPath(data, missingPaths[0]) : undefined;\n    return {\n        valid: missingPaths.length === 0,\n        missingPaths,\n        nearestPath,\n        scenarioId,\n        year,\n        chartName: contract.chartName\n    };\n}\n/**\n * Validate all chart contracts for a data point\n */ function validateAllCharts(data, scenarioId, year) {\n    return CHART_CONTRACTS.map((contract)=>validateChartData(data, contract, scenarioId, year));\n}\n/**\n * Ensure ground data is always present (even if orbital is infeasible)\n */ function ensureGroundData(data) {\n    var _data_metadata_chartInputs, _data_metadata, _data_ground_buildoutDebug, _data_ground_buildoutDebug1, _data_ground_buildoutDebug2, _data_ground_buildoutDebug3;\n    // If ground is missing entirely, create a minimal structure\n    if (!data.ground) {\n        data.ground = {};\n    }\n    // Ensure gpuHourPricing exists and has all SLA tiers\n    if (!data.ground.gpuHourPricing) {\n        data.ground.gpuHourPricing = {};\n    }\n    // Always create all SLA tiers if missing\n    for (const k of [\n        \"basic\",\n        \"standard\",\n        \"premium\"\n    ]){\n        if (!data.ground.gpuHourPricing[k]) {\n            data.ground.gpuHourPricing[k] = {\n                pricePerGpuHour: 0,\n                costBreakdown: {}\n            };\n        }\n    }\n    // If ground was missing entirely, also create other required fields\n    if (!data.ground.totalCostPerPflopYear && data.ground.totalCostPerPflopYear !== 0) {\n        data.ground.totalCostPerPflopYear = 0;\n    }\n    if (!data.ground.tokenPricing) {\n        data.ground.tokenPricing = {\n            llama70B: {\n                costPer1kTokens: 0\n            },\n            llama405B: {\n                costPer1kTokens: 0\n            }\n        };\n    }\n    if (!data.ground.buildoutDebug) {\n        data.ground.buildoutDebug = {\n            demandGW: 0,\n            buildRateGWyr: 0\n        };\n    }\n    if (data.ground.backlogGw === undefined && data.ground.backlogGw !== 0) {\n        data.ground.backlogGw = 0;\n    }\n    if (data.ground.avgWaitYears === undefined && data.ground.avgWaitYears !== 0) {\n        data.ground.avgWaitYears = 0;\n    }\n    if (!data.ground.supplyMetrics) {\n        data.ground.supplyMetrics = {\n            maxBuildRateGwYear: 0\n        };\n    }\n    // Ensure buildoutDebug exists\n    if (!data.ground.buildoutDebug) {\n        var _data_ground_supplyMetrics, _data_ground_supplyMetrics1, _data_ground_supplyMetrics2, _data_ground_supplyMetrics3;\n        var _data_ground_supplyMetrics_demandGw, _data_ground_supplyMetrics_maxBuildRateGwYear, _data_ground_supplyMetrics_capacityGw, _data_ground_supplyMetrics_pipelineGw;\n        data.ground.buildoutDebug = {\n            demandGW: (_data_ground_supplyMetrics_demandGw = (_data_ground_supplyMetrics = data.ground.supplyMetrics) === null || _data_ground_supplyMetrics === void 0 ? void 0 : _data_ground_supplyMetrics.demandGw) !== null && _data_ground_supplyMetrics_demandGw !== void 0 ? _data_ground_supplyMetrics_demandGw : 0,\n            buildRateGWyr: (_data_ground_supplyMetrics_maxBuildRateGwYear = (_data_ground_supplyMetrics1 = data.ground.supplyMetrics) === null || _data_ground_supplyMetrics1 === void 0 ? void 0 : _data_ground_supplyMetrics1.maxBuildRateGwYear) !== null && _data_ground_supplyMetrics_maxBuildRateGwYear !== void 0 ? _data_ground_supplyMetrics_maxBuildRateGwYear : 0,\n            demandNewGW: 0,\n            capacityGW: (_data_ground_supplyMetrics_capacityGw = (_data_ground_supplyMetrics2 = data.ground.supplyMetrics) === null || _data_ground_supplyMetrics2 === void 0 ? void 0 : _data_ground_supplyMetrics2.capacityGw) !== null && _data_ground_supplyMetrics_capacityGw !== void 0 ? _data_ground_supplyMetrics_capacityGw : 0,\n            pipelineGW: (_data_ground_supplyMetrics_pipelineGw = (_data_ground_supplyMetrics3 = data.ground.supplyMetrics) === null || _data_ground_supplyMetrics3 === void 0 ? void 0 : _data_ground_supplyMetrics3.pipelineGw) !== null && _data_ground_supplyMetrics_pipelineGw !== void 0 ? _data_ground_supplyMetrics_pipelineGw : 0\n        };\n    }\n    // Normalize backlog + wait fields from multiple sources (fixes chart disappearing)\n    const pb = (_data_metadata = data.metadata) === null || _data_metadata === void 0 ? void 0 : (_data_metadata_chartInputs = _data_metadata.chartInputs) === null || _data_metadata_chartInputs === void 0 ? void 0 : _data_metadata_chartInputs.powerBuildout;\n    var _ref, _ref1, _ref2, _ref3;\n    // FIX: Skip 0 values to allow fallback chain to continue to buildoutDebug\n    const backlog = (_ref3 = (_ref2 = (_ref1 = (_ref = data.ground.backlogGw !== undefined && data.ground.backlogGw > 0 ? data.ground.backlogGw : undefined) !== null && _ref !== void 0 ? _ref : (_data_ground_buildoutDebug = data.ground.buildoutDebug) === null || _data_ground_buildoutDebug === void 0 ? void 0 : _data_ground_buildoutDebug.backlogGW) !== null && _ref1 !== void 0 ? _ref1 : (_data_ground_buildoutDebug1 = data.ground.buildoutDebug) === null || _data_ground_buildoutDebug1 === void 0 ? void 0 : _data_ground_buildoutDebug1.backlogGw) !== null && _ref2 !== void 0 ? _ref2 : pb === null || pb === void 0 ? void 0 : pb.backlogGw) !== null && _ref3 !== void 0 ? _ref3 : 0;\n    var _data_ground_avgWaitYears, _ref4, _ref5, _ref6;\n    const wait = (_ref6 = (_ref5 = (_ref4 = (_data_ground_avgWaitYears = data.ground.avgWaitYears) !== null && _data_ground_avgWaitYears !== void 0 ? _data_ground_avgWaitYears : (_data_ground_buildoutDebug2 = data.ground.buildoutDebug) === null || _data_ground_buildoutDebug2 === void 0 ? void 0 : _data_ground_buildoutDebug2.timeToPowerYears) !== null && _ref4 !== void 0 ? _ref4 : (_data_ground_buildoutDebug3 = data.ground.buildoutDebug) === null || _data_ground_buildoutDebug3 === void 0 ? void 0 : _data_ground_buildoutDebug3.avgWaitYears) !== null && _ref5 !== void 0 ? _ref5 : pb === null || pb === void 0 ? void 0 : pb.avgWaitYears) !== null && _ref6 !== void 0 ? _ref6 : 0;\n    // Normalize to required contract fields\n    data.ground.backlogGw = backlog;\n    data.ground.avgWaitYears = wait;\n    var _data_ground_buildoutDebug_backlogGW;\n    // Normalize buildoutDebug names used by charts\n    data.ground.buildoutDebug.backlogGW = (_data_ground_buildoutDebug_backlogGW = data.ground.buildoutDebug.backlogGW) !== null && _data_ground_buildoutDebug_backlogGW !== void 0 ? _data_ground_buildoutDebug_backlogGW : backlog;\n    var _data_ground_buildoutDebug_timeToPowerYears;\n    data.ground.buildoutDebug.timeToPowerYears = (_data_ground_buildoutDebug_timeToPowerYears = data.ground.buildoutDebug.timeToPowerYears) !== null && _data_ground_buildoutDebug_timeToPowerYears !== void 0 ? _data_ground_buildoutDebug_timeToPowerYears : wait;\n    // Ensure supplyMetrics exists\n    if (!data.ground.supplyMetrics) {\n        var _data_ground_buildoutDebug4, _data_ground_buildoutDebug5, _data_ground_buildoutDebug6, _data_ground_buildoutDebug7;\n        var _data_ground_buildoutDebug_demandGW, _data_ground_buildoutDebug_capacityGW, _data_ground_buildoutDebug_pipelineGW, _data_ground_buildoutDebug_buildRateGWyr;\n        data.ground.supplyMetrics = {\n            demandGw: (_data_ground_buildoutDebug_demandGW = (_data_ground_buildoutDebug4 = data.ground.buildoutDebug) === null || _data_ground_buildoutDebug4 === void 0 ? void 0 : _data_ground_buildoutDebug4.demandGW) !== null && _data_ground_buildoutDebug_demandGW !== void 0 ? _data_ground_buildoutDebug_demandGW : 0,\n            capacityGw: (_data_ground_buildoutDebug_capacityGW = (_data_ground_buildoutDebug5 = data.ground.buildoutDebug) === null || _data_ground_buildoutDebug5 === void 0 ? void 0 : _data_ground_buildoutDebug5.capacityGW) !== null && _data_ground_buildoutDebug_capacityGW !== void 0 ? _data_ground_buildoutDebug_capacityGW : 0,\n            pipelineGw: (_data_ground_buildoutDebug_pipelineGW = (_data_ground_buildoutDebug6 = data.ground.buildoutDebug) === null || _data_ground_buildoutDebug6 === void 0 ? void 0 : _data_ground_buildoutDebug6.pipelineGW) !== null && _data_ground_buildoutDebug_pipelineGW !== void 0 ? _data_ground_buildoutDebug_pipelineGW : 0,\n            maxBuildRateGwYear: (_data_ground_buildoutDebug_buildRateGWyr = (_data_ground_buildoutDebug7 = data.ground.buildoutDebug) === null || _data_ground_buildoutDebug7 === void 0 ? void 0 : _data_ground_buildoutDebug7.buildRateGWyr) !== null && _data_ground_buildoutDebug_buildRateGWyr !== void 0 ? _data_ground_buildoutDebug_buildRateGWyr : 0,\n            avgWaitYears: wait,\n            utilizationPct: 0\n        };\n    }\n    return data;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvdXRpbHMvY2hhcnRWYWxpZGF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7OztDQUtDLEdBaUJEOztDQUVDLEdBQ00sTUFBTUEsa0JBQW1DO0lBQzlDO1FBQ0VDLFdBQVc7UUFDWEMsZUFBZTtZQUNiO1lBQ0E7U0FDRDtJQUNIO0lBQ0E7UUFDRUQsV0FBVztRQUNYQyxlQUFlO1lBQ2I7WUFDQTtZQUNBO1lBQ0E7U0FDRDtRQUNEQyxlQUFlO1lBQ2I7WUFDQTtZQUNBO1NBQ0Q7SUFDSDtJQUNBO1FBQ0VGLFdBQVc7UUFDWEMsZUFBZTtZQUNiO1lBQ0E7WUFDQTtZQUNBO1NBQ0Q7SUFDSDtDQUNELENBQUM7QUFFRjs7Q0FFQyxHQUNELFNBQVNFLGVBQWVDLEdBQVEsRUFBRUMsSUFBWTtJQUM1QyxNQUFNQyxRQUFRRCxLQUFLRSxLQUFLLENBQUM7SUFDekIsSUFBSUMsVUFBVUo7SUFDZCxLQUFLLE1BQU1LLFFBQVFILE1BQU87UUFDeEIsSUFBSUUsWUFBWSxRQUFRQSxZQUFZRSxXQUFXO1lBQzdDLE9BQU9BO1FBQ1Q7UUFDQUYsVUFBVUEsT0FBTyxDQUFDQyxLQUFLO0lBQ3pCO0lBQ0EsT0FBT0Q7QUFDVDtBQUVBOztDQUVDLEdBQ0QsU0FBU0csZ0JBQWdCUCxHQUFRLEVBQUVRLFdBQW1CO0lBQ3BELE1BQU1OLFFBQVFNLFlBQVlMLEtBQUssQ0FBQztJQUNoQyxJQUFLLElBQUlNLElBQUlQLE1BQU1RLE1BQU0sR0FBRyxHQUFHRCxJQUFJLEdBQUdBLElBQUs7UUFDekMsTUFBTUUsY0FBY1QsTUFBTVUsS0FBSyxDQUFDLEdBQUdILEdBQUdJLElBQUksQ0FBQztRQUMzQyxNQUFNQyxRQUFRZixlQUFlQyxLQUFLVztRQUNsQyxJQUFJRyxVQUFVLFFBQVFBLFVBQVVSLFdBQVc7WUFDekMsT0FBT0s7UUFDVDtJQUNGO0lBQ0EsT0FBT0w7QUFDVDtBQUVBOztDQUVDLEdBQ00sU0FBU1Msa0JBQ2RDLElBQVMs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Qiw2QkFDRUEsNkJBQ0FBLDZCQUNRQTtZQUhWQSxxQ0FDRUEsdUNBQ0FBLHVDQUNRQTtRQUp0QkEsS0FBS1ksTUFBTSxDQUFDZSxhQUFhLEdBQUc7WUFDMUJFLFVBQVU3QixDQUFBQSx1Q0FBQUEsOEJBQUFBLEtBQUtZLE1BQU0sQ0FBQ1UsYUFBYSxjQUF6QnRCLGtEQUFBQSw0QkFBMkJ1QixRQUFRLGNBQW5DdkIsaURBQUFBLHNDQUF1QztZQUNqRGdDLFlBQVloQyxDQUFBQSx5Q0FBQUEsOEJBQUFBLEtBQUtZLE1BQU0sQ0FBQ1UsYUFBYSxjQUF6QnRCLGtEQUFBQSw0QkFBMkIrQixVQUFVLGNBQXJDL0IsbURBQUFBLHdDQUF5QztZQUNyRGtDLFlBQVlsQyxDQUFBQSx5Q0FBQUEsOEJBQUFBLEtBQUtZLE1BQU0sQ0FBQ1UsYUFBYSxjQUF6QnRCLGtEQUFBQSw0QkFBMkJpQyxVQUFVLGNBQXJDakMsbURBQUFBLHdDQUF5QztZQUNyRDRCLG9CQUFvQjVCLENBQUFBLDRDQUFBQSw4QkFBQUEsS0FBS1ksTUFBTSxDQUFDVSxhQUFhLGNBQXpCdEIsa0RBQUFBLDRCQUEyQndCLGFBQWEsY0FBeEN4QixzREFBQUEsMkNBQTRDO1lBQ2hFMEIsY0FBY2U7WUFDZEUsZ0JBQWdCO1FBQ2xCO0lBQ0Y7SUFFQSxPQUFPM0M7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvbGliL3V0aWxzL2NoYXJ0VmFsaWRhdG9yLnRzPzczZTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDaGFydCBEYXRhIFZhbGlkYXRvclxuICogXG4gKiBWYWxpZGF0ZXMgdGhhdCBleHBvcnRlZCBkYXRhIGhhcyByZXF1aXJlZCBwYXRocyBmb3IgZWFjaCBjaGFydC5cbiAqIFVzZWQgdG8gY2F0Y2ggbWlzc2luZyBkYXRhIGVhcmx5IGFuZCBwcm92aWRlIGhlbHBmdWwgZXJyb3IgbWVzc2FnZXMuXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBDaGFydENvbnRyYWN0IHtcbiAgY2hhcnROYW1lOiBzdHJpbmc7XG4gIHJlcXVpcmVkUGF0aHM6IHN0cmluZ1tdO1xuICBvcHRpb25hbFBhdGhzPzogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvblJlc3VsdCB7XG4gIHZhbGlkOiBib29sZWFuO1xuICBtaXNzaW5nUGF0aHM6IHN0cmluZ1tdO1xuICBuZWFyZXN0UGF0aD86IHN0cmluZztcbiAgc2NlbmFyaW9JZD86IHN0cmluZztcbiAgeWVhcj86IG51bWJlcjtcbiAgY2hhcnROYW1lPzogc3RyaW5nOyAvLyBOYW1lIG9mIHRoZSBjaGFydCBiZWluZyB2YWxpZGF0ZWRcbn1cblxuLyoqXG4gKiBDaGFydCBjb250cmFjdHMgLSBkZWZpbmVzIHdoYXQgZGF0YSBlYWNoIGNoYXJ0IG5lZWRzXG4gKi9cbmV4cG9ydCBjb25zdCBDSEFSVF9DT05UUkFDVFM6IENoYXJ0Q29udHJhY3RbXSA9IFtcbiAge1xuICAgIGNoYXJ0TmFtZTogJ0dQVS1Ib3VyIFByaWNpbmcnLFxuICAgIHJlcXVpcmVkUGF0aHM6IFtcbiAgICAgICdvcmJpdC5ncHVIb3VyUHJpY2luZy5zdGFuZGFyZC5wcmljZVBlckdwdUhvdXInLFxuICAgICAgJ2dyb3VuZC5ncHVIb3VyUHJpY2luZy5zdGFuZGFyZC5wcmljZVBlckdwdUhvdXInLFxuICAgIF0sXG4gIH0sXG4gIHtcbiAgICBjaGFydE5hbWU6ICdHcm91bmQgQnVpbGRvdXQgQ29uc3RyYWludHMnLFxuICAgIHJlcXVpcmVkUGF0aHM6IFtcbiAgICAgICdncm91bmQuYnVpbGRvdXREZWJ1Zy5kZW1hbmRHVycsXG4gICAgICAnZ3JvdW5kLmJ1aWxkb3V0RGVidWcuYnVpbGRSYXRlR1d5cicsXG4gICAgICAnZ3JvdW5kLmJ1aWxkb3V0RGVidWcuYmFja2xvZ0dXJyxcbiAgICAgICdncm91bmQuYnVpbGRvdXREZWJ1Zy50aW1lVG9Qb3dlclllYXJzJyxcbiAgICBdLFxuICAgIG9wdGlvbmFsUGF0aHM6IFtcbiAgICAgICdncm91bmQuYnVpbGRvdXREZWJ1Zy5kZW1hbmROZXdHVycsXG4gICAgICAnZ3JvdW5kLmJ1aWxkb3V0RGVidWcuY2FwYWNpdHlHVycsXG4gICAgICAnZ3JvdW5kLmJ1aWxkb3V0RGVidWcucGlwZWxpbmVHVycsXG4gICAgXSxcbiAgfSxcbiAge1xuICAgIGNoYXJ0TmFtZTogJ1Bvd2VyIEJ1aWxkb3V0JyxcbiAgICByZXF1aXJlZFBhdGhzOiBbXG4gICAgICAnZ3JvdW5kLmJ1aWxkb3V0RGVidWcuZGVtYW5kR1cnLFxuICAgICAgJ2dyb3VuZC5zdXBwbHlNZXRyaWNzLm1heEJ1aWxkUmF0ZUd3WWVhcicsXG4gICAgICAnZ3JvdW5kLmJhY2tsb2dHdycsXG4gICAgICAnZ3JvdW5kLmF2Z1dhaXRZZWFycycsXG4gICAgXSxcbiAgfSxcbl07XG5cbi8qKlxuICogR2V0IHZhbHVlIGF0IGEgbmVzdGVkIHBhdGggKGUuZy4sIFwib3JiaXQuZ3B1SG91clByaWNpbmcuc3RhbmRhcmQucHJpY2VQZXJHcHVIb3VyXCIpXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlQXRQYXRoKG9iajogYW55LCBwYXRoOiBzdHJpbmcpOiBhbnkge1xuICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgbGV0IGN1cnJlbnQgPSBvYmo7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY3VycmVudCA9IGN1cnJlbnRbcGFydF07XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5cbi8qKlxuICogRmluZCBuZWFyZXN0IHZhbGlkIHBhdGggd2hlbiBhIHJlcXVpcmVkIHBhdGggaXMgbWlzc2luZ1xuICovXG5mdW5jdGlvbiBmaW5kTmVhcmVzdFBhdGgob2JqOiBhbnksIG1pc3NpbmdQYXRoOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBjb25zdCBwYXJ0cyA9IG1pc3NpbmdQYXRoLnNwbGl0KCcuJyk7XG4gIGZvciAobGV0IGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgY29uc3QgcGFydGlhbFBhdGggPSBwYXJ0cy5zbGljZSgwLCBpKS5qb2luKCcuJyk7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRWYWx1ZUF0UGF0aChvYmosIHBhcnRpYWxQYXRoKTtcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHBhcnRpYWxQYXRoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGEgc2luZ2xlIGRhdGEgcG9pbnQgYWdhaW5zdCBhIGNoYXJ0IGNvbnRyYWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUNoYXJ0RGF0YShcbiAgZGF0YTogYW55LFxuICBjb250cmFjdDogQ2hhcnRDb250cmFjdCxcbiAgc2NlbmFyaW9JZD86IHN0cmluZyxcbiAgeWVhcj86IG51bWJlclxuKTogVmFsaWRhdGlvblJlc3VsdCB7XG4gIGNvbnN0IG1pc3NpbmdQYXRoczogc3RyaW5nW10gPSBbXTtcbiAgXG4gIGZvciAoY29uc3QgcGF0aCBvZiBjb250cmFjdC5yZXF1aXJlZFBhdGhzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRWYWx1ZUF0UGF0aChkYXRhLCBwYXRoKTtcbiAgICAvLyBUcmVhdCAwIGFzIHZhbGlkIChpdCBpcyksIGJ1dCBrZWVwIE5hTi91bmRlZmluZWQgaW52YWxpZFxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICghaXNGaW5pdGUodmFsdWUpICYmIHZhbHVlICE9PSAwKSkge1xuICAgICAgbWlzc2luZ1BhdGhzLnB1c2gocGF0aCk7XG4gICAgfVxuICB9XG4gIFxuICBjb25zdCBuZWFyZXN0UGF0aCA9IG1pc3NpbmdQYXRocy5sZW5ndGggPiAwIFxuICAgID8gZmluZE5lYXJlc3RQYXRoKGRhdGEsIG1pc3NpbmdQYXRoc1swXSlcbiAgICA6IHVuZGVmaW5lZDtcbiAgXG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IG1pc3NpbmdQYXRocy5sZW5ndGggPT09IDAsXG4gICAgbWlzc2luZ1BhdGhzLFxuICAgIG5lYXJlc3RQYXRoLFxuICAgIHNjZW5hcmlvSWQsXG4gICAgeWVhcixcbiAgICBjaGFydE5hbWU6IGNvbnRyYWN0LmNoYXJ0TmFtZSxcbiAgfTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhbGwgY2hhcnQgY29udHJhY3RzIGZvciBhIGRhdGEgcG9pbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQWxsQ2hhcnRzKFxuICBkYXRhOiBhbnksXG4gIHNjZW5hcmlvSWQ/OiBzdHJpbmcsXG4gIHllYXI/OiBudW1iZXJcbik6IFZhbGlkYXRpb25SZXN1bHRbXSB7XG4gIHJldHVybiBDSEFSVF9DT05UUkFDVFMubWFwKGNvbnRyYWN0ID0+IFxuICAgIHZhbGlkYXRlQ2hhcnREYXRhKGRhdGEsIGNvbnRyYWN0LCBzY2VuYXJpb0lkLCB5ZWFyKVxuICApO1xufVxuXG4vKipcbiAqIEVuc3VyZSBncm91bmQgZGF0YSBpcyBhbHdheXMgcHJlc2VudCAoZXZlbiBpZiBvcmJpdGFsIGlzIGluZmVhc2libGUpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVHcm91bmREYXRhKGRhdGE6IGFueSk6IGFueSB7XG4gIC8vIElmIGdyb3VuZCBpcyBtaXNzaW5nIGVudGlyZWx5LCBjcmVhdGUgYSBtaW5pbWFsIHN0cnVjdHVyZVxuICBpZiAoIWRhdGEuZ3JvdW5kKSB7XG4gICAgZGF0YS5ncm91bmQgPSB7fTtcbiAgfVxuICBcbiAgLy8gRW5zdXJlIGdwdUhvdXJQcmljaW5nIGV4aXN0cyBhbmQgaGFzIGFsbCBTTEEgdGllcnNcbiAgaWYgKCFkYXRhLmdyb3VuZC5ncHVIb3VyUHJpY2luZykge1xuICAgIGRhdGEuZ3JvdW5kLmdwdUhvdXJQcmljaW5nID0ge307XG4gIH1cbiAgXG4gIC8vIEFsd2F5cyBjcmVhdGUgYWxsIFNMQSB0aWVycyBpZiBtaXNzaW5nXG4gIGZvciAoY29uc3QgayBvZiBbJ2Jhc2ljJywgJ3N0YW5kYXJkJywgJ3ByZW1pdW0nXSBhcyBjb25zdCkge1xuICAgIGlmICghZGF0YS5ncm91bmQuZ3B1SG91clByaWNpbmdba10pIHtcbiAgICAgIGRhdGEuZ3JvdW5kLmdwdUhvdXJQcmljaW5nW2tdID0geyBcbiAgICAgICAgcHJpY2VQZXJHcHVIb3VyOiAwLCBcbiAgICAgICAgY29zdEJyZWFrZG93bjoge30gXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBcbiAgLy8gSWYgZ3JvdW5kIHdhcyBtaXNzaW5nIGVudGlyZWx5LCBhbHNvIGNyZWF0ZSBvdGhlciByZXF1aXJlZCBmaWVsZHNcbiAgaWYgKCFkYXRhLmdyb3VuZC50b3RhbENvc3RQZXJQZmxvcFllYXIgJiYgZGF0YS5ncm91bmQudG90YWxDb3N0UGVyUGZsb3BZZWFyICE9PSAwKSB7XG4gICAgZGF0YS5ncm91bmQudG90YWxDb3N0UGVyUGZsb3BZZWFyID0gMDtcbiAgfVxuICBcbiAgaWYgKCFkYXRhLmdyb3VuZC50b2tlblByaWNpbmcpIHtcbiAgICBkYXRhLmdyb3VuZC50b2tlblByaWNpbmcgPSB7XG4gICAgICBsbGFtYTcwQjogeyBjb3N0UGVyMWtUb2tlbnM6IDAgfSxcbiAgICAgIGxsYW1hNDA1QjogeyBjb3N0UGVyMWtUb2tlbnM6IDAgfSxcbiAgICB9O1xuICB9XG4gIFxuICBpZiAoIWRhdGEuZ3JvdW5kLmJ1aWxkb3V0RGVidWcpIHtcbiAgICBkYXRhLmdyb3VuZC5idWlsZG91dERlYnVnID0ge1xuICAgICAgZGVtYW5kR1c6IDAsXG4gICAgICBidWlsZFJhdGVHV3lyOiAwLFxuICAgIH07XG4gIH1cbiAgXG4gIGlmIChkYXRhLmdyb3VuZC5iYWNrbG9nR3cgPT09IHVuZGVmaW5lZCAmJiBkYXRhLmdyb3VuZC5iYWNrbG9nR3cgIT09IDApIHtcbiAgICBkYXRhLmdyb3VuZC5iYWNrbG9nR3cgPSAwO1xuICB9XG4gIFxuICBpZiAoZGF0YS5ncm91bmQuYXZnV2FpdFllYXJzID09PSB1bmRlZmluZWQgJiYgZGF0YS5ncm91bmQuYXZnV2FpdFllYXJzICE9PSAwKSB7XG4gICAgZGF0YS5ncm91bmQuYXZnV2FpdFllYXJzID0gMDtcbiAgfVxuICBcbiAgaWYgKCFkYXRhLmdyb3VuZC5zdXBwbHlNZXRyaWNzKSB7XG4gICAgZGF0YS5ncm91bmQuc3VwcGx5TWV0cmljcyA9IHtcbiAgICAgIG1heEJ1aWxkUmF0ZUd3WWVhcjogMCxcbiAgICB9O1xuICB9XG4gIFxuICAvLyBFbnN1cmUgYnVpbGRvdXREZWJ1ZyBleGlzdHNcbiAgaWYgKCFkYXRhLmdyb3VuZC5idWlsZG91dERlYnVnKSB7XG4gICAgZGF0YS5ncm91bmQuYnVpbGRvdXREZWJ1ZyA9IHtcbiAgICAgIGRlbWFuZEdXOiBkYXRhLmdyb3VuZC5zdXBwbHlNZXRyaWNzPy5kZW1hbmRHdyA/PyAwLFxuICAgICAgYnVpbGRSYXRlR1d5cjogZGF0YS5ncm91bmQuc3VwcGx5TWV0cmljcz8ubWF4QnVpbGRSYXRlR3dZZWFyID8/IDAsXG4gICAgICBkZW1hbmROZXdHVzogMCxcbiAgICAgIGNhcGFjaXR5R1c6IGRhdGEuZ3JvdW5kLnN1cHBseU1ldHJpY3M/LmNhcGFjaXR5R3cgPz8gMCxcbiAgICAgIHBpcGVsaW5lR1c6IGRhdGEuZ3JvdW5kLnN1cHBseU1ldHJpY3M/LnBpcGVsaW5lR3cgPz8gMCxcbiAgICB9O1xuICB9XG4gIFxuICAvLyBOb3JtYWxpemUgYmFja2xvZyArIHdhaXQgZmllbGRzIGZyb20gbXVsdGlwbGUgc291cmNlcyAoZml4ZXMgY2hhcnQgZGlzYXBwZWFyaW5nKVxuICBjb25zdCBwYiA9IGRhdGEubWV0YWRhdGE/LmNoYXJ0SW5wdXRzPy5wb3dlckJ1aWxkb3V0O1xuICBcbiAgLy8gRklYOiBTa2lwIDAgdmFsdWVzIHRvIGFsbG93IGZhbGxiYWNrIGNoYWluIHRvIGNvbnRpbnVlIHRvIGJ1aWxkb3V0RGVidWdcbiAgY29uc3QgYmFja2xvZyA9XG4gICAgKGRhdGEuZ3JvdW5kLmJhY2tsb2dHdyAhPT0gdW5kZWZpbmVkICYmIGRhdGEuZ3JvdW5kLmJhY2tsb2dHdyA+IDAgPyBkYXRhLmdyb3VuZC5iYWNrbG9nR3cgOiB1bmRlZmluZWQpID8/XG4gICAgZGF0YS5ncm91bmQuYnVpbGRvdXREZWJ1Zz8uYmFja2xvZ0dXID8/XG4gICAgZGF0YS5ncm91bmQuYnVpbGRvdXREZWJ1Zz8uYmFja2xvZ0d3ID8/XG4gICAgcGI/LmJhY2tsb2dHdyA/P1xuICAgIDA7XG4gIFxuICBjb25zdCB3YWl0ID1cbiAgICBkYXRhLmdyb3VuZC5hdmdXYWl0WWVhcnMgPz9cbiAgICBkYXRhLmdyb3VuZC5idWlsZG91dERlYnVnPy50aW1lVG9Qb3dlclllYXJzID8/XG4gICAgZGF0YS5ncm91bmQuYnVpbGRvdXREZWJ1Zz8uYXZnV2FpdFllYXJzID8/XG4gICAgcGI/LmF2Z1dhaXRZZWFycyA/P1xuICAgIDA7XG4gIFxuICAvLyBOb3JtYWxpemUgdG8gcmVxdWlyZWQgY29udHJhY3QgZmllbGRzXG4gIGRhdGEuZ3JvdW5kLmJhY2tsb2dHdyA9IGJhY2tsb2c7XG4gIGRhdGEuZ3JvdW5kLmF2Z1dhaXRZZWFycyA9IHdhaXQ7XG4gIFxuICAvLyBOb3JtYWxpemUgYnVpbGRvdXREZWJ1ZyBuYW1lcyB1c2VkIGJ5IGNoYXJ0c1xuICBkYXRhLmdyb3VuZC5idWlsZG91dERlYnVnLmJhY2tsb2dHVyA9IGRhdGEuZ3JvdW5kLmJ1aWxkb3V0RGVidWcuYmFja2xvZ0dXID8/IGJhY2tsb2c7XG4gIGRhdGEuZ3JvdW5kLmJ1aWxkb3V0RGVidWcudGltZVRvUG93ZXJZZWFycyA9IGRhdGEuZ3JvdW5kLmJ1aWxkb3V0RGVidWcudGltZVRvUG93ZXJZZWFycyA/PyB3YWl0O1xuICBcbiAgLy8gRW5zdXJlIHN1cHBseU1ldHJpY3MgZXhpc3RzXG4gIGlmICghZGF0YS5ncm91bmQuc3VwcGx5TWV0cmljcykge1xuICAgIGRhdGEuZ3JvdW5kLnN1cHBseU1ldHJpY3MgPSB7XG4gICAgICBkZW1hbmRHdzogZGF0YS5ncm91bmQuYnVpbGRvdXREZWJ1Zz8uZGVtYW5kR1cgPz8gMCxcbiAgICAgIGNhcGFjaXR5R3c6IGRhdGEuZ3JvdW5kLmJ1aWxkb3V0RGVidWc/LmNhcGFjaXR5R1cgPz8gMCxcbiAgICAgIHBpcGVsaW5lR3c6IGRhdGEuZ3JvdW5kLmJ1aWxkb3V0RGVidWc/LnBpcGVsaW5lR1cgPz8gMCxcbiAgICAgIG1heEJ1aWxkUmF0ZUd3WWVhcjogZGF0YS5ncm91bmQuYnVpbGRvdXREZWJ1Zz8uYnVpbGRSYXRlR1d5ciA/PyAwLFxuICAgICAgYXZnV2FpdFllYXJzOiB3YWl0LFxuICAgICAgdXRpbGl6YXRpb25QY3Q6IDAsXG4gICAgfTtcbiAgfVxuICBcbiAgcmV0dXJuIGRhdGE7XG59XG5cbiJdLCJuYW1lcyI6WyJDSEFSVF9DT05UUkFDVFMiLCJjaGFydE5hbWUiLCJyZXF1aXJlZFBhdGhzIiwib3B0aW9uYWxQYXRocyIsImdldFZhbHVlQXRQYXRoIiwib2JqIiwicGF0aCIsInBhcnRzIiwic3BsaXQiLCJjdXJyZW50IiwicGFydCIsInVuZGVmaW5lZCIsImZpbmROZWFyZXN0UGF0aCIsIm1pc3NpbmdQYXRoIiwiaSIsImxlbmd0aCIsInBhcnRpYWxQYXRoIiwic2xpY2UiLCJqb2luIiwidmFsdWUiLCJ2YWxpZGF0ZUNoYXJ0RGF0YSIsImRhdGEiLCJjb250cmFjdCIsInNjZW5hcmlvSWQiLCJ5ZWFyIiwibWlzc2luZ1BhdGhzIiwiaXNGaW5pdGUiLCJwdXNoIiwibmVhcmVzdFBhdGgiLCJ2YWxpZCIsInZhbGlkYXRlQWxsQ2hhcnRzIiwibWFwIiwiZW5zdXJlR3JvdW5kRGF0YSIsImdyb3VuZCIsImdwdUhvdXJQcmljaW5nIiwiayIsInByaWNlUGVyR3B1SG91ciIsImNvc3RCcmVha2Rvd24iLCJ0b3RhbENvc3RQZXJQZmxvcFllYXIiLCJ0b2tlblByaWNpbmciLCJsbGFtYTcwQiIsImNvc3RQZXIxa1Rva2VucyIsImxsYW1hNDA1QiIsImJ1aWxkb3V0RGVidWciLCJkZW1hbmRHVyIsImJ1aWxkUmF0ZUdXeXIiLCJiYWNrbG9nR3ciLCJhdmdXYWl0WWVhcnMiLCJzdXBwbHlNZXRyaWNzIiwibWF4QnVpbGRSYXRlR3dZZWFyIiwiZGVtYW5kR3ciLCJkZW1hbmROZXdHVyIsImNhcGFjaXR5R1ciLCJjYXBhY2l0eUd3IiwicGlwZWxpbmVHVyIsInBpcGVsaW5lR3ciLCJwYiIsIm1ldGFkYXRhIiwiY2hhcnRJbnB1dHMiLCJwb3dlckJ1aWxkb3V0IiwiYmFja2xvZyIsImJhY2tsb2dHVyIsIndhaXQiLCJ0aW1lVG9Qb3dlclllYXJzIiwidXRpbGl6YXRpb25QY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/utils/chartValidator.ts\n"));

/***/ })

});