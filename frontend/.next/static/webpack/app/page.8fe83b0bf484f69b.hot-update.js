"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/model/ground_ramping_mobilization.ts":
/*!******************************************************!*\
  !*** ./app/lib/model/ground_ramping_mobilization.ts ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_MOBILIZATION_PARAMS: function() { return /* binding */ DEFAULT_MOBILIZATION_PARAMS; },\n/* harmony export */   calculateBuildRateGWyr: function() { return /* binding */ calculateBuildRateGWyr; },\n/* harmony export */   calculateDemandGW: function() { return /* binding */ calculateDemandGW; },\n/* harmony export */   calculatePriceResponsiveBuildRateGWyr: function() { return /* binding */ calculatePriceResponsiveBuildRateGWyr; },\n/* harmony export */   calculatePriceResponsiveDemandGW: function() { return /* binding */ calculatePriceResponsiveDemandGW; },\n/* harmony export */   stepMobilizationState: function() { return /* binding */ stepMobilizationState; }\n/* harmony export */ });\n/**\n * Ground Ramping Mobilization Model\n * \n * Models demand growth with price-responsive demand and buildout capacity\n * ramping with investment response. Tracks capacity evolution, pipeline, backlog,\n * and wait times.\n * \n * NEW: Price-responsive demand and investment-responsive buildout (replaces fixed anchors)\n */ /**\n * Calculate price-responsive demand GW\n * \n * NEW: Demand responds to prices, wait times, and orbital substitution\n * Replaces fixed anchors with economic feedback\n */ function calculatePriceResponsiveDemandGW(year, groundPricePerGpuHour, orbitalPricePerGpuHour, avgWaitYears, params) {\n    let pue = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1.3;\n    // Base demand with organic growth (tapered, not exponential forever)\n    const yearsFrom2025 = year - 2025;\n    const growthTaper = Math.tanh(yearsFrom2025 / 30); // Tapers after ~30 years\n    const baseDemand = params.baseDemand2025GW * Math.pow(1 + params.organicGrowthRate, yearsFrom2025 * growthTaper);\n    // Price elasticity: higher prices reduce demand\n    const baselinePrice = 3.50; // $/GPU-hr baseline\n    const priceRatio = groundPricePerGpuHour / baselinePrice;\n    const priceFactor = Math.pow(priceRatio, params.priceElasticity);\n    // Wait elasticity: longer waits reduce demand\n    const waitFactor = Math.exp(-avgWaitYears * params.waitElasticity / 5);\n    // Orbital substitution: if orbital cheaper, demand shifts\n    const orbitalAdvantage = groundPricePerGpuHour / Math.max(orbitalPricePerGpuHour, 0.01);\n    const substitutionFactor = orbitalAdvantage > params.orbitalSubstitutionThreshold ? 1 / (1 + 0.5 * (orbitalAdvantage - params.orbitalSubstitutionThreshold)) : 1.0;\n    let demandGW = baseDemand * priceFactor * waitFactor * substitutionFactor;\n    // Apply PUE if demand is IT load (not facility load)\n    // Note: This function assumes facility load, so multiply by PUE if needed\n    // For now, return facility load (demand already includes PUE in baseDemand2025GW)\n    return Math.max(0, demandGW);\n}\n/**\n * Legacy function: Calculate demand GW using piecewise exponential to hit anchors\n * \n * DEPRECATED: Use calculatePriceResponsiveDemandGW instead\n * Kept for backward compatibility\n */ function calculateDemandGW(year, params) {\n    let pue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1.3;\n    const { demandAnchorsGW, demandIsFacilityLoad, demandCurve } = params;\n    const demand2025 = demandAnchorsGW[2025];\n    const demand2040 = demandAnchorsGW[2040];\n    const demand2060 = demandAnchorsGW[2060];\n    if (demandCurve !== \"piecewise_exponential\") {\n        throw new Error(\"Unsupported demandCurve: \".concat(demandCurve, \". Only 'piecewise_exponential' is supported.\"));\n    }\n    if (year < 2025) {\n        return demand2025;\n    }\n    let demandGW;\n    if (year <= 2040) {\n        // Phase 1: 2025-2040\n        // r1 = ln(demand2040 / demand2025) / (2040-2025)\n        const r1 = Math.log(demand2040 / demand2025) / (2040 - 2025);\n        const yearsFrom2025 = year - 2025;\n        demandGW = demand2025 * Math.exp(r1 * yearsFrom2025);\n    } else {\n        // Phase 2: 2040-2060\n        // r2 = ln(demand2060 / demand2040) / (2060-2040)\n        const r2 = Math.log(demand2060 / demand2040) / (2060 - 2040);\n        const yearsFrom2040 = year - 2040;\n        demandGW = demand2040 * Math.exp(r2 * yearsFrom2040);\n    }\n    // Apply PUE if demand is IT load (not facility load)\n    if (!demandIsFacilityLoad) {\n        demandGW = demandGW * pue;\n    }\n    // Hard asserts in dev mode\n    if (true) {\n        if (year === 2040) {\n            const actual2040 = demandGW;\n            const error2040 = Math.abs(actual2040 - demand2040) / demand2040;\n            if (error2040 >= 0.03) {\n                throw new Error(\"[DEMAND ANCHOR FAIL] demandGw(2040)=\".concat(actual2040.toFixed(2), \" GW, \") + \"expected=\".concat(demand2040, \" GW, error=\").concat((error2040 * 100).toFixed(2), \"% >= 3%\"));\n            }\n        }\n        if (year === 2060) {\n            if (demandGW < 2000) {\n                throw new Error(\"[DEMAND ANCHOR FAIL] demandGw(2060)=\".concat(demandGW.toFixed(2), \" GW < 2000 GW. \") + \"Must be >= 2000 GW (multi-TW target).\");\n            }\n        }\n    }\n    return demandGW;\n}\n/**\n * Calculate price-responsive buildout rate\n * \n * NEW: Buildout responds to margins and backlog\n * Replaces fixed anchors with investment feedback\n */ function calculatePriceResponsiveBuildRateGWyr(year, prevBuildRate, groundMargin, backlogGW, params) {\n    // Base growth (supply chain improvement)\n    const yearsFrom2025 = year - 2025;\n    const baseGrowth = Math.pow(1.03, yearsFrom2025); // 3% organic improvement\n    const baseBuildRate = params.baseBuildRate2025GWyr * baseGrowth;\n    // Investment response: higher margins attract more capital\n    const baselineMargin = 0.20; // 20% baseline margin\n    const marginRatio = groundMargin / baselineMargin;\n    const investmentMultiplier = 1 + params.investmentElasticity * Math.max(0, marginRatio - 1);\n    // Backlog response: higher backlog attracts more investment\n    const backlogMultiplier = 1 + params.backlogResponseK * Math.min(1, backlogGW / 100);\n    // Target build rate\n    let targetRate = baseBuildRate * investmentMultiplier * backlogMultiplier;\n    // Physical ceiling\n    targetRate = Math.min(targetRate, params.maxBuildRateGWyr);\n    // Ramp limit (can't increase faster than 25%/year)\n    const maxRate = prevBuildRate * (1 + params.rampLimitPerYear);\n    const minRate = prevBuildRate * (1 - params.rampLimitPerYear * 0.5); // Slower to decrease\n    targetRate = Math.max(minRate, Math.min(maxRate, targetRate));\n    return Math.max(0, targetRate);\n}\n/**\n * Legacy function: Smooth interpolation for buildout anchors\n * \n * DEPRECATED: Use calculatePriceResponsiveBuildRateGWyr instead\n * Kept for backward compatibility\n */ function calculateBuildRateGWyr(year, params) {\n    const { buildoutAnchorsGWyr, buildoutSmoothingYears } = params;\n    const anchors = buildoutAnchorsGWyr;\n    // Find surrounding anchors\n    const anchorYears = Object.keys(anchors).map(Number).sort((a, b)=>a - b);\n    // Before first anchor: use first anchor value\n    if (year <= anchorYears[0]) {\n        return anchors[anchorYears[0]];\n    }\n    // After last anchor: use last anchor value\n    if (year >= anchorYears[anchorYears.length - 1]) {\n        return anchors[anchorYears[anchorYears.length - 1]];\n    }\n    // Find surrounding anchors\n    let lowerYear = anchorYears[0];\n    let upperYear = anchorYears[anchorYears.length - 1];\n    for(let i = 0; i < anchorYears.length - 1; i++){\n        if (year >= anchorYears[i] && year <= anchorYears[i + 1]) {\n            lowerYear = anchorYears[i];\n            upperYear = anchorYears[i + 1];\n            break;\n        }\n    }\n    const lowerRate = anchors[lowerYear];\n    const upperRate = anchors[upperYear];\n    // Exponential interpolation for buildout ramp\n    const t = (year - lowerYear) / (upperYear - lowerYear);\n    const buildRate = lowerRate * Math.pow(upperRate / lowerRate, t);\n    // Apply smoothing: moving average over smoothing window\n    if (buildoutSmoothingYears > 0) {\n        const smoothingWindow = buildoutSmoothingYears;\n        let smoothedSum = buildRate;\n        let count = 1;\n        // Helper function to calculate unsmoothed rate\n        const getUnsmoothedRate = (y)=>{\n            if (y <= anchorYears[0]) return anchors[anchorYears[0]];\n            if (y >= anchorYears[anchorYears.length - 1]) return anchors[anchorYears[anchorYears.length - 1]];\n            let lower = anchorYears[0];\n            let upper = anchorYears[anchorYears.length - 1];\n            for(let i = 0; i < anchorYears.length - 1; i++){\n                if (y >= anchorYears[i] && y <= anchorYears[i + 1]) {\n                    lower = anchorYears[i];\n                    upper = anchorYears[i + 1];\n                    break;\n                }\n            }\n            const lowerRate = anchors[lower];\n            const upperRate = anchors[upper];\n            const t = (y - lower) / (upper - lower);\n            return lowerRate * Math.pow(upperRate / lowerRate, t);\n        };\n        for(let offset = 1; offset <= Math.floor(smoothingWindow / 2); offset++){\n            const prevYear = year - offset;\n            const nextYear = year + offset;\n            if (prevYear >= anchorYears[0]) {\n                const prevRate = getUnsmoothedRate(prevYear);\n                smoothedSum += prevRate;\n                count++;\n            }\n            if (nextYear <= anchorYears[anchorYears.length - 1]) {\n                const nextRate = getUnsmoothedRate(nextYear);\n                smoothedSum += nextRate;\n                count++;\n            }\n        }\n        return smoothedSum / count;\n    }\n    return buildRate;\n}\n/**\n * Calculate bottleneck rate from anchors (same interpolation as buildout)\n */ function calculateBottleneckRateGWyr(year, anchors) {\n    const anchorYears = [\n        2025,\n        2030,\n        2040,\n        2060\n    ];\n    // Before first anchor: use first anchor value\n    if (year <= anchorYears[0]) {\n        return anchors[2025];\n    }\n    // After last anchor: use last anchor value\n    if (year >= anchorYears[anchorYears.length - 1]) {\n        return anchors[2060];\n    }\n    // Find surrounding anchors\n    let lowerYear = anchorYears[0];\n    let upperYear = anchorYears[anchorYears.length - 1];\n    for(let i = 0; i < anchorYears.length - 1; i++){\n        if (year >= anchorYears[i] && year <= anchorYears[i + 1]) {\n            lowerYear = anchorYears[i];\n            upperYear = anchorYears[i + 1];\n            break;\n        }\n    }\n    const lowerRate = anchors[lowerYear];\n    const upperRate = anchors[upperYear];\n    // Exponential interpolation\n    const t = (year - lowerYear) / (upperYear - lowerYear);\n    return lowerRate * Math.pow(upperRate / lowerRate, t);\n}\n/**\n * Step mobilization state forward one year\n */ function stepMobilizationState(prevState, params, year) {\n    let pue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1.3, retirementsGW = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, orbitalSubstitutionGW = arguments.length > 5 ? arguments[5] : void 0, responsiveDemandGW // Optional: responsive demand (overrides hardcoded calculateDemandGW)\n     = arguments.length > 6 ? arguments[6] : void 0;\n    // Calculate demand: use responsive demand if provided, otherwise use hardcoded\n    const demandGW = responsiveDemandGW !== undefined ? responsiveDemandGW * pue // Convert IT load to facility load\n     : calculateDemandGW(year, params, pue);\n    // Fix 2: Calculate demandGWPrev correctly (don't use same responsiveDemandGW for both years)\n    let demandGWPrev;\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.demandGW) !== undefined) {\n        demandGWPrev = prevState.demandGW;\n    } else if (responsiveDemandGW !== undefined) {\n        // For first year, estimate previous year's demand using hardcoded calculation\n        // Don't use same responsiveDemandGW for both current and previous year\n        demandGWPrev = calculateDemandGW(year - 1, params, pue);\n    } else {\n        demandGWPrev = calculateDemandGW(year - 1, params, pue);\n    }\n    const demandNewGW = Math.max(0, demandGW - demandGWPrev);\n    // Calculate build rate candidate (from anchors)\n    let buildRateCandidate = calculateBuildRateGWyr(year, params);\n    // NEW: If ground demand is falling (due to orbital substitution or price elasticity),\n    // buildout should slow down (no one builds capacity for declining market)\n    const demandGrowthRateActual = (prevState === null || prevState === void 0 ? void 0 : prevState.demandGW) ? (demandGW - prevState.demandGW) / Math.max(prevState.demandGW, 1) : 0;\n    if (demandGrowthRateActual < 0) {\n        // Demand is shrinking - reduce buildout\n        const contractionFactor = Math.max(0.5, 1 + demandGrowthRateActual * 2); // At most 50% reduction\n        buildRateCandidate = buildRateCandidate * contractionFactor; // Reassign to let variable\n    }\n    var _params_bottleneckMode;\n    // Apply bottleneck constraints if enabled\n    const bottleneckMode = (_params_bottleneckMode = params.bottleneckMode) !== null && _params_bottleneckMode !== void 0 ? _params_bottleneckMode : \"min_of_bottlenecks\";\n    let buildRateGWyr = buildRateCandidate;\n    let bottleneckRateGWyr;\n    let limitingBottleneck = \"candidate\";\n    if (bottleneckMode === \"min_of_bottlenecks\" && params.bottleneckAnchorsGWyr) {\n        const { transformers, substations, tx, generation } = params.bottleneckAnchorsGWyr;\n        const transformersRate = calculateBottleneckRateGWyr(year, transformers);\n        const substationsRate = calculateBottleneckRateGWyr(year, substations);\n        const txRate = calculateBottleneckRateGWyr(year, tx);\n        const generationRate = calculateBottleneckRateGWyr(year, generation);\n        // Find minimum bottleneck\n        bottleneckRateGWyr = Math.min(transformersRate, substationsRate, txRate, generationRate);\n        // Determine which bottleneck is limiting\n        if (bottleneckRateGWyr === transformersRate) {\n            limitingBottleneck = \"transformers\";\n        } else if (bottleneckRateGWyr === substationsRate) {\n            limitingBottleneck = \"substations\";\n        } else if (bottleneckRateGWyr === txRate) {\n            limitingBottleneck = \"tx\";\n        } else if (bottleneckRateGWyr === generationRate) {\n            limitingBottleneck = \"generation\";\n        }\n        // Effective build rate is minimum of candidate and bottleneck\n        buildRateGWyr = Math.min(buildRateCandidate, bottleneckRateGWyr);\n    } else {\n        limitingBottleneck = \"none\";\n    }\n    var _params_rampLimitFracPerYear;\n    // Apply ramp limiter (prevent sudden jumps)\n    const rampLimitFrac = (_params_rampLimitFracPerYear = params.rampLimitFracPerYear) !== null && _params_rampLimitFracPerYear !== void 0 ? _params_rampLimitFracPerYear : 0.25;\n    if ((prevState === null || prevState === void 0 ? void 0 : prevState.buildRateGWyr) !== undefined) {\n        const prevRate = prevState.buildRateGWyr;\n        const minRate = prevRate * (1 - rampLimitFrac);\n        const maxRate = prevRate * (1 + rampLimitFrac);\n        buildRateGWyr = Math.max(minRate, Math.min(maxRate, buildRateGWyr));\n    }\n    var _prevState_capacityGW;\n    // Calculate capacity evolution\n    // capacityGw(t) = capacityGw(t-1) + buildRateGwYear(t) - retirementsGw(t)\n    const capacityGWPrev = (_prevState_capacityGW = prevState === null || prevState === void 0 ? void 0 : prevState.capacityGW) !== null && _prevState_capacityGW !== void 0 ? _prevState_capacityGW : 0;\n    const capacityGW = capacityGWPrev + buildRateGWyr - retirementsGW;\n    // Calculate pipeline\n    // pipelineGw(t) = buildRateGwYear(t) * pipelineLeadTimeYears * pipelineFillFrac\n    const pipelineGW = buildRateGWyr * params.pipelineLeadTimeYears * params.pipelineFillFrac;\n    // Calculate backlog\n    // backlogGw(t) = max(0, backlogGw(t-1) + demandNewGw(t) - buildableGw(t) - implicitBacklogDrain)\n    // NEW: Backlog can also be satisfied by demand shifting to orbital\n    // When demand shifts to orbital, \"implicit backlog drain\" occurs\n    // because customers who were waiting for ground now use orbital instead\n    // Fix 1: Initialize with baseline backlog if no previous state\n    const INITIAL_BACKLOG_GW = 50; // Same as queue model\n    var _prevState_backlogGW;\n    const backlogGWPrev = (_prevState_backlogGW = prevState === null || prevState === void 0 ? void 0 : prevState.backlogGW) !== null && _prevState_backlogGW !== void 0 ? _prevState_backlogGW : INITIAL_BACKLOG_GW;\n    const buildableGW = buildRateGWyr;\n    const implicitBacklogDrain = (orbitalSubstitutionGW !== null && orbitalSubstitutionGW !== void 0 ? orbitalSubstitutionGW : 0) * 0.5; // 50% of shifted demand was in backlog\n    // NEW: Backlog can drain when demand falls below buildout\n    const netDemandChange = demandNewGW - buildableGW;\n    var _prevState_demandGW;\n    // If orbital substitution caused demand to drop, backlog drains faster\n    const demandDropFromPrev = Math.max(0, ((_prevState_demandGW = prevState === null || prevState === void 0 ? void 0 : prevState.demandGW) !== null && _prevState_demandGW !== void 0 ? _prevState_demandGW : demandGW) - demandGW);\n    const substitutionDrain = demandDropFromPrev * 0.3; // 30% of demand drop was from backlog\n    // Fix 3: Ensure backlog reflects demand-capacity gap\n    // If demand >> capacity, backlog must be at least (demand - capacity)\n    const unservedGW = Math.max(0, demandGW - capacityGW);\n    const backlogFloor = unservedGW * 0.5; // At least 50% of unserved is in backlog\n    const backlogGW = Math.max(backlogFloor, Math.max(0, backlogGWPrev + netDemandChange - substitutionDrain - implicitBacklogDrain));\n    // Hard assert: If demandNewGw(t) > buildRateGwYear(t), backlogGw must increase\n    if (true) {\n        if (demandNewGW > buildRateGWyr && backlogGW <= backlogGWPrev) {\n            throw new Error(\"[BUILDOUT INVARIANT] Year \".concat(year, \": demandNewGW=\").concat(demandNewGW.toFixed(2), \" > \") + \"buildRateGWyr=\".concat(buildRateGWyr.toFixed(2), \", but backlogGW=\").concat(backlogGW.toFixed(2), \" \") + \"<= prevBacklogGW=\".concat(backlogGWPrev.toFixed(2), \". Backlog must increase.\"));\n        }\n    }\n    // Calculate average wait time\n    // avgWaitYears(t) = backlogGw(t) / max(buildRateGwYear(t), 1e-9)\n    const EPS = 1e-9;\n    const avgWaitYears = backlogGW / Math.max(buildRateGWyr, EPS);\n    // Calculate growth rate (for debug)\n    let demandGrowthRate;\n    if (year <= 2040) {\n        demandGrowthRate = Math.log(params.demandAnchorsGW[2040] / params.demandAnchorsGW[2025]) / 15;\n    } else {\n        demandGrowthRate = Math.log(params.demandAnchorsGW[2060] / params.demandAnchorsGW[2040]) / 20;\n    }\n    return {\n        year,\n        demandGW,\n        demandNewGW,\n        buildRateGWyr,\n        capacityGW,\n        pipelineGW,\n        backlogGW,\n        avgWaitYears,\n        demandGrowthRate,\n        buildoutSmoothFactor: params.buildoutSmoothingYears,\n        bottleneckRateGWyr,\n        limitingBottleneck,\n        buildRateCandidate\n    };\n}\n/**\n * Default mobilization scenario parameters\n */ const DEFAULT_MOBILIZATION_PARAMS = {\n    demandAnchorsGW: {\n        2025: 120,\n        2040: 450,\n        2060: 3000\n    },\n    demandCurve: \"piecewise_exponential\",\n    demandIsFacilityLoad: true,\n    buildoutAnchorsGWyr: {\n        2025: 25,\n        2030: 60,\n        2040: 140,\n        2060: 220\n    },\n    buildoutSmoothingYears: 3,\n    pipelineLeadTimeYears: 3,\n    pipelineFillFrac: 1.5,\n    bottleneckMode: \"min_of_bottlenecks\",\n    bottleneckAnchorsGWyr: {\n        transformers: {\n            2025: 30,\n            2030: 50,\n            2040: 100,\n            2060: 180\n        },\n        substations: {\n            2025: 35,\n            2030: 55,\n            2040: 110,\n            2060: 200\n        },\n        tx: {\n            2025: 40,\n            2030: 65,\n            2040: 130,\n            2060: 250\n        },\n        generation: {\n            2025: 50,\n            2030: 80,\n            2040: 160,\n            2060: 300\n        }\n    },\n    rampLimitFracPerYear: 0.25\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX3JhbXBpbmdfbW9iaWxpemF0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Ozs7OztDQVFDLEdBbUVEOzs7OztDQUtDLEdBQ00sU0FBU0EsaUNBQ2RDLElBQVksRUFDWkMscUJBQTZCLEVBQzdCQyxzQkFBOEIsRUFDOUJDLFlBQW9CLEVBQ3BCQyxNQUFvQjtRQUNwQkMsTUFBQUEsaUVBQWM7SUFFZCxxRUFBcUU7SUFDckUsTUFBTUMsZ0JBQWdCTixPQUFPO0lBQzdCLE1BQU1PLGNBQWNDLEtBQUtDLElBQUksQ0FBQ0gsZ0JBQWdCLEtBQUsseUJBQXlCO0lBQzVFLE1BQU1JLGFBQWFOLE9BQU9PLGdCQUFnQixHQUFHSCxLQUFLSSxHQUFHLENBQUMsSUFBSVIsT0FBT1MsaUJBQWlCLEVBQUVQLGdCQUFnQkM7SUFFcEcsZ0RBQWdEO0lBQ2hELE1BQU1PLGdCQUFnQixNQUFNLG9CQUFvQjtJQUNoRCxNQUFNQyxhQUFhZCx3QkFBd0JhO0lBQzNDLE1BQU1FLGNBQWNSLEtBQUtJLEdBQUcsQ0FBQ0csWUFBWVgsT0FBT2EsZUFBZTtJQUUvRCw4Q0FBOEM7SUFDOUMsTUFBTUMsYUFBYVYsS0FBS1csR0FBRyxDQUFDLENBQUNoQixlQUFlQyxPQUFPZ0IsY0FBYyxHQUFHO0lBRXBFLDBEQUEwRDtJQUMxRCxNQUFNQyxtQkFBbUJwQix3QkFBd0JPLEtBQUtjLEdBQUcsQ0FBQ3BCLHdCQUF3QjtJQUNsRixNQUFNcUIscUJBQXFCRixtQkFBbUJqQixPQUFPb0IsNEJBQTRCLEdBQzdFLElBQUssS0FBSSxNQUFPSCxDQUFBQSxtQkFBbUJqQixPQUFPb0IsNEJBQTRCLEtBQ3RFO0lBRUosSUFBSUMsV0FBV2YsYUFBYU0sY0FBY0UsYUFBYUs7SUFFdkQscURBQXFEO0lBQ3JELDBFQUEwRTtJQUMxRSxrRkFBa0Y7SUFFbEYsT0FBT2YsS0FBS2MsR0FBRyxDQUFDLEdBQUdHO0FBQ3JCO0FBRUE7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LE1BQU07WUFBSSxNQUFNO1lBQUssTUFBTTtRQUFJO1FBQy9DQyxZQUFZO1lBQUUsTUFBTTtZQUFJLE1BQU07WUFBSSxNQUFNO1lBQUssTUFBTTtRQUFJO0lBQ3pEO0lBQ0FNLHNCQUFzQjtBQUN4QixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvbW9kZWwvZ3JvdW5kX3JhbXBpbmdfbW9iaWxpemF0aW9uLnRzPzQ0NTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHcm91bmQgUmFtcGluZyBNb2JpbGl6YXRpb24gTW9kZWxcbiAqIFxuICogTW9kZWxzIGRlbWFuZCBncm93dGggd2l0aCBwcmljZS1yZXNwb25zaXZlIGRlbWFuZCBhbmQgYnVpbGRvdXQgY2FwYWNpdHlcbiAqIHJhbXBpbmcgd2l0aCBpbnZlc3RtZW50IHJlc3BvbnNlLiBUcmFja3MgY2FwYWNpdHkgZXZvbHV0aW9uLCBwaXBlbGluZSwgYmFja2xvZyxcbiAqIGFuZCB3YWl0IHRpbWVzLlxuICogXG4gKiBORVc6IFByaWNlLXJlc3BvbnNpdmUgZGVtYW5kIGFuZCBpbnZlc3RtZW50LXJlc3BvbnNpdmUgYnVpbGRvdXQgKHJlcGxhY2VzIGZpeGVkIGFuY2hvcnMpXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBEZW1hbmRQYXJhbXMge1xuICBiYXNlRGVtYW5kMjAyNUdXOiBudW1iZXI7ICAgICAgICAvLyAxMjAgR1dcbiAgb3JnYW5pY0dyb3d0aFJhdGU6IG51bWJlcjsgICAgICAgLy8gMC4xMCAoMTAlIENBR1IgYmFzZSlcbiAgcHJpY2VFbGFzdGljaXR5OiBudW1iZXI7ICAgICAgICAgLy8gLTAuMyAoMzAlIGRlbWFuZCBkcm9wIHBlciAxMDAlIHByaWNlIGluY3JlYXNlKVxuICB3YWl0RWxhc3RpY2l0eTogbnVtYmVyOyAgICAgICAgICAvLyAtMC4yICgyMCUgZGVtYW5kIGRyb3AgcGVyIDV5ciB3YWl0KVxuICBvcmJpdGFsU3Vic3RpdHV0aW9uVGhyZXNob2xkOiBudW1iZXI7IC8vIFByaWNlIHJhdGlvIGF0IHdoaWNoIGRlbWFuZCBzaGlmdHMgdG8gb3JiaXRhbCAoZGVmYXVsdCAxLjIgPSAyMCUgY2hlYXBlcilcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCdWlsZG91dFBhcmFtcyB7XG4gIGJhc2VCdWlsZFJhdGUyMDI1R1d5cjogbnVtYmVyOyAgIC8vIDI1IEdXL3lyXG4gIG1heEJ1aWxkUmF0ZUdXeXI6IG51bWJlcjsgICAgICAgIC8vIDE1MCBHVy95ciBwaHlzaWNhbCBsaW1pdFxuICBpbnZlc3RtZW50RWxhc3RpY2l0eTogbnVtYmVyOyAgICAgLy8gMC41ICg1MCUgbW9yZSBpbnZlc3RtZW50IHBlciAxMDAlIG1hcmdpbiBpbmNyZWFzZSlcbiAgcmFtcExpbWl0UGVyWWVhcjogbnVtYmVyOyAgICAgICAgIC8vIDAuMjUgKDI1JSBtYXggaW5jcmVhc2UgcGVyIHllYXIpXG4gIGJhY2tsb2dSZXNwb25zZUs6IG51bWJlcjsgICAgICAgICAvLyAwLjMgKGhvdyBmYXN0IGJ1aWxkb3V0IHJlc3BvbmRzIHRvIGJhY2tsb2cpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9iaWxpemF0aW9uU2NlbmFyaW9QYXJhbXMge1xuICBkZW1hbmRBbmNob3JzR1c6IHtcbiAgICAyMDI1OiBudW1iZXI7XG4gICAgMjA0MDogbnVtYmVyO1xuICAgIDIwNjA6IG51bWJlcjtcbiAgfTtcbiAgZGVtYW5kQ3VydmU6ICdwaWVjZXdpc2VfZXhwb25lbnRpYWwnOyAvLyBDdXJ2ZSB0eXBlIChvbmx5IHBpZWNld2lzZV9leHBvbmVudGlhbCBzdXBwb3J0ZWQpXG4gIGRlbWFuZElzRmFjaWxpdHlMb2FkOiBib29sZWFuOyAvLyBJZiB0cnVlLCBpbmNsdWRlcyBQVUU7IGlmIGZhbHNlLCBtdWx0aXBseSBieSBQVUUgbGF0ZXJcbiAgYnVpbGRvdXRBbmNob3JzR1d5cjoge1xuICAgIDIwMjU6IG51bWJlcjtcbiAgICAyMDMwOiBudW1iZXI7XG4gICAgMjA0MDogbnVtYmVyO1xuICAgIDIwNjA6IG51bWJlcjtcbiAgfTtcbiAgYnVpbGRvdXRTbW9vdGhpbmdZZWFyczogbnVtYmVyOyAvLyBTbW9vdGhpbmcgd2luZG93IGZvciBidWlsZG91dCBpbnRlcnBvbGF0aW9uXG4gIHBpcGVsaW5lTGVhZFRpbWVZZWFyczogbnVtYmVyOyAvLyBMZWFkIHRpbWUgZm9yIHBpcGVsaW5lIGNhbGN1bGF0aW9uXG4gIHBpcGVsaW5lRmlsbEZyYWM6IG51bWJlcjsgLy8gUGlwZWxpbmUgZmlsbCBmcmFjdGlvbiAocGlwZWxpbmVHVyA9IGxlYWRUaW1lICogYnVpbGRSYXRlICogZmlsbEZyYWMpXG4gIC8vIEJvdHRsZW5lY2sgY29uc3RyYWludHNcbiAgYm90dGxlbmVja01vZGU/OiAnb2ZmJyB8ICdtaW5fb2ZfYm90dGxlbmVja3MnOyAvLyBEZWZhdWx0ICdtaW5fb2ZfYm90dGxlbmVja3MnXG4gIGJvdHRsZW5lY2tBbmNob3JzR1d5cj86IHtcbiAgICB0cmFuc2Zvcm1lcnM6IHsgMjAyNTogbnVtYmVyOyAyMDMwOiBudW1iZXI7IDIwNDA6IG51bWJlcjsgMjA2MDogbnVtYmVyIH07XG4gICAgc3Vic3RhdGlvbnM6IHsgMjAyNTogbnVtYmVyOyAyMDMwOiBudW1iZXI7IDIwNDA6IG51bWJlcjsgMjA2MDogbnVtYmVyIH07XG4gICAgdHg6IHsgMjAyNTogbnVtYmVyOyAyMDMwOiBudW1iZXI7IDIwNDA6IG51bWJlcjsgMjA2MDogbnVtYmVyIH07XG4gICAgZ2VuZXJhdGlvbjogeyAyMDI1OiBudW1iZXI7IDIwMzA6IG51bWJlcjsgMjA0MDogbnVtYmVyOyAyMDYwOiBudW1iZXIgfTtcbiAgfTtcbiAgcmFtcExpbWl0RnJhY1BlclllYXI/OiBudW1iZXI7IC8vIE1heCBmcmFjdGlvbmFsIGNoYW5nZSBwZXIgeWVhciAoZGVmYXVsdCAwLjI1ID0gMjUlKVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vYmlsaXphdGlvblN0YXRlIHtcbiAgeWVhcjogbnVtYmVyO1xuICBkZW1hbmRHVzogbnVtYmVyOyAvLyBUb3RhbCBkZW1hbmQgKElUIG9yIGZhY2lsaXR5IGxvYWQpXG4gIGRlbWFuZE5ld0dXOiBudW1iZXI7IC8vIEluY3JlbWVudGFsIGRlbWFuZCB0aGlzIHllYXJcbiAgYnVpbGRSYXRlR1d5cjogbnVtYmVyOyAvLyBCdWlsZCByYXRlIHRoaXMgeWVhciAoR1cveWVhcilcbiAgY2FwYWNpdHlHVzogbnVtYmVyOyAvLyBDdW11bGF0aXZlIGNhcGFjaXR5IGJ1aWx0XG4gIHBpcGVsaW5lR1c6IG51bWJlcjsgLy8gUGlwZWxpbmUgY2FwYWNpdHkgKHVuZGVyIGNvbnN0cnVjdGlvbilcbiAgYmFja2xvZ0dXOiBudW1iZXI7IC8vIEJhY2tsb2cgd2FpdGluZyB0byBiZSBidWlsdFxuICBhdmdXYWl0WWVhcnM6IG51bWJlcjsgLy8gQXZlcmFnZSB3YWl0IHRpbWUgKGJhY2tsb2cgLyBidWlsZFJhdGUpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9iaWxpemF0aW9uUmVzdWx0IGV4dGVuZHMgTW9iaWxpemF0aW9uU3RhdGUge1xuICAvLyBBZGRpdGlvbmFsIGRlYnVnIGZpZWxkc1xuICBkZW1hbmRHcm93dGhSYXRlOiBudW1iZXI7IC8vIEN1cnJlbnQgZ3Jvd3RoIHJhdGUgKHIxIG9yIHIyKVxuICBidWlsZG91dFNtb290aEZhY3RvcjogbnVtYmVyOyAvLyBTbW9vdGhpbmcgZmFjdG9yIGFwcGxpZWRcbiAgLy8gQm90dGxlbmVjayBkZWJ1ZyBmaWVsZHNcbiAgYm90dGxlbmVja1JhdGVHV3lyPzogbnVtYmVyOyAvLyBFZmZlY3RpdmUgYm90dGxlbmVjayByYXRlIChtaW4gb2YgYWxsIGJvdHRsZW5lY2tzKVxuICBsaW1pdGluZ0JvdHRsZW5lY2s/OiAndHJhbnNmb3JtZXJzJyB8ICdzdWJzdGF0aW9ucycgfCAndHgnIHwgJ2dlbmVyYXRpb24nIHwgJ2NhbmRpZGF0ZScgfCAnbm9uZSc7IC8vIFdoaWNoIGJvdHRsZW5lY2sgaXMgbGltaXRpbmdcbiAgYnVpbGRSYXRlQ2FuZGlkYXRlPzogbnVtYmVyOyAvLyBPcmlnaW5hbCBidWlsZCByYXRlIGJlZm9yZSBib3R0bGVuZWNrL3JhbXAgbGltaXRzXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHByaWNlLXJlc3BvbnNpdmUgZGVtYW5kIEdXXG4gKiBcbiAqIE5FVzogRGVtYW5kIHJlc3BvbmRzIHRvIHByaWNlcywgd2FpdCB0aW1lcywgYW5kIG9yYml0YWwgc3Vic3RpdHV0aW9uXG4gKiBSZXBsYWNlcyBmaXhlZCBhbmNob3JzIHdpdGggZWNvbm9taWMgZmVlZGJhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVByaWNlUmVzcG9uc2l2ZURlbWFuZEdXKFxuICB5ZWFyOiBudW1iZXIsXG4gIGdyb3VuZFByaWNlUGVyR3B1SG91cjogbnVtYmVyLFxuICBvcmJpdGFsUHJpY2VQZXJHcHVIb3VyOiBudW1iZXIsXG4gIGF2Z1dhaXRZZWFyczogbnVtYmVyLFxuICBwYXJhbXM6IERlbWFuZFBhcmFtcyxcbiAgcHVlOiBudW1iZXIgPSAxLjNcbik6IG51bWJlciB7XG4gIC8vIEJhc2UgZGVtYW5kIHdpdGggb3JnYW5pYyBncm93dGggKHRhcGVyZWQsIG5vdCBleHBvbmVudGlhbCBmb3JldmVyKVxuICBjb25zdCB5ZWFyc0Zyb20yMDI1ID0geWVhciAtIDIwMjU7XG4gIGNvbnN0IGdyb3d0aFRhcGVyID0gTWF0aC50YW5oKHllYXJzRnJvbTIwMjUgLyAzMCk7IC8vIFRhcGVycyBhZnRlciB+MzAgeWVhcnNcbiAgY29uc3QgYmFzZURlbWFuZCA9IHBhcmFtcy5iYXNlRGVtYW5kMjAyNUdXICogTWF0aC5wb3coMSArIHBhcmFtcy5vcmdhbmljR3Jvd3RoUmF0ZSwgeWVhcnNGcm9tMjAyNSAqIGdyb3d0aFRhcGVyKTtcbiAgXG4gIC8vIFByaWNlIGVsYXN0aWNpdHk6IGhpZ2hlciBwcmljZXMgcmVkdWNlIGRlbWFuZFxuICBjb25zdCBiYXNlbGluZVByaWNlID0gMy41MDsgLy8gJC9HUFUtaHIgYmFzZWxpbmVcbiAgY29uc3QgcHJpY2VSYXRpbyA9IGdyb3VuZFByaWNlUGVyR3B1SG91ciAvIGJhc2VsaW5lUHJpY2U7XG4gIGNvbnN0IHByaWNlRmFjdG9yID0gTWF0aC5wb3cocHJpY2VSYXRpbywgcGFyYW1zLnByaWNlRWxhc3RpY2l0eSk7XG4gIFxuICAvLyBXYWl0IGVsYXN0aWNpdHk6IGxvbmdlciB3YWl0cyByZWR1Y2UgZGVtYW5kXG4gIGNvbnN0IHdhaXRGYWN0b3IgPSBNYXRoLmV4cCgtYXZnV2FpdFllYXJzICogcGFyYW1zLndhaXRFbGFzdGljaXR5IC8gNSk7XG4gIFxuICAvLyBPcmJpdGFsIHN1YnN0aXR1dGlvbjogaWYgb3JiaXRhbCBjaGVhcGVyLCBkZW1hbmQgc2hpZnRzXG4gIGNvbnN0IG9yYml0YWxBZHZhbnRhZ2UgPSBncm91bmRQcmljZVBlckdwdUhvdXIgLyBNYXRoLm1heChvcmJpdGFsUHJpY2VQZXJHcHVIb3VyLCAwLjAxKTtcbiAgY29uc3Qgc3Vic3RpdHV0aW9uRmFjdG9yID0gb3JiaXRhbEFkdmFudGFnZSA+IHBhcmFtcy5vcmJpdGFsU3Vic3RpdHV0aW9uVGhyZXNob2xkIFxuICAgID8gMSAvICgxICsgMC41ICogKG9yYml0YWxBZHZhbnRhZ2UgLSBwYXJhbXMub3JiaXRhbFN1YnN0aXR1dGlvblRocmVzaG9sZCkpXG4gICAgOiAxLjA7XG4gIFxuICBsZXQgZGVtYW5kR1cgPSBiYXNlRGVtYW5kICogcHJpY2VGYWN0b3IgKiB3YWl0RmFjdG9yICogc3Vic3RpdHV0aW9uRmFjdG9yO1xuICBcbiAgLy8gQXBwbHkgUFVFIGlmIGRlbWFuZCBpcyBJVCBsb2FkIChub3QgZmFjaWxpdHkgbG9hZClcbiAgLy8gTm90ZTogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIGZhY2lsaXR5IGxvYWQsIHNvIG11bHRpcGx5IGJ5IFBVRSBpZiBuZWVkZWRcbiAgLy8gRm9yIG5vdywgcmV0dXJuIGZhY2lsaXR5IGxvYWQgKGRlbWFuZCBhbHJlYWR5IGluY2x1ZGVzIFBVRSBpbiBiYXNlRGVtYW5kMjAyNUdXKVxuICBcbiAgcmV0dXJuIE1hdGgubWF4KDAsIGRlbWFuZEdXKTtcbn1cblxuLyoqXG4gKiBMZWdhY3kgZnVuY3Rpb246IENhbGN1bGF0ZSBkZW1hbmQgR1cgdXNpbmcgcGllY2V3aXNlIGV4cG9uZW50aWFsIHRvIGhpdCBhbmNob3JzXG4gKiBcbiAqIERFUFJFQ0FURUQ6IFVzZSBjYWxjdWxhdGVQcmljZVJlc3BvbnNpdmVEZW1hbmRHVyBpbnN0ZWFkXG4gKiBLZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVEZW1hbmRHVyhcbiAgeWVhcjogbnVtYmVyLFxuICBwYXJhbXM6IE1vYmlsaXphdGlvblNjZW5hcmlvUGFyYW1zLFxuICBwdWU6IG51bWJlciA9IDEuM1xuKTogbnVtYmVyIHtcbiAgY29uc3QgeyBkZW1hbmRBbmNob3JzR1csIGRlbWFuZElzRmFjaWxpdHlMb2FkLCBkZW1hbmRDdXJ2ZSB9ID0gcGFyYW1zO1xuICBjb25zdCBkZW1hbmQyMDI1ID0gZGVtYW5kQW5jaG9yc0dXWzIwMjVdO1xuICBjb25zdCBkZW1hbmQyMDQwID0gZGVtYW5kQW5jaG9yc0dXWzIwNDBdO1xuICBjb25zdCBkZW1hbmQyMDYwID0gZGVtYW5kQW5jaG9yc0dXWzIwNjBdO1xuICBcbiAgaWYgKGRlbWFuZEN1cnZlICE9PSAncGllY2V3aXNlX2V4cG9uZW50aWFsJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVtYW5kQ3VydmU6ICR7ZGVtYW5kQ3VydmV9LiBPbmx5ICdwaWVjZXdpc2VfZXhwb25lbnRpYWwnIGlzIHN1cHBvcnRlZC5gKTtcbiAgfVxuICBcbiAgaWYgKHllYXIgPCAyMDI1KSB7XG4gICAgcmV0dXJuIGRlbWFuZDIwMjU7XG4gIH1cbiAgXG4gIGxldCBkZW1hbmRHVzogbnVtYmVyO1xuICBcbiAgaWYgKHllYXIgPD0gMjA0MCkge1xuICAgIC8vIFBoYXNlIDE6IDIwMjUtMjA0MFxuICAgIC8vIHIxID0gbG4oZGVtYW5kMjA0MCAvIGRlbWFuZDIwMjUpIC8gKDIwNDAtMjAyNSlcbiAgICBjb25zdCByMSA9IE1hdGgubG9nKGRlbWFuZDIwNDAgLyBkZW1hbmQyMDI1KSAvICgyMDQwIC0gMjAyNSk7XG4gICAgY29uc3QgeWVhcnNGcm9tMjAyNSA9IHllYXIgLSAyMDI1O1xuICAgIGRlbWFuZEdXID0gZGVtYW5kMjAyNSAqIE1hdGguZXhwKHIxICogeWVhcnNGcm9tMjAyNSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUGhhc2UgMjogMjA0MC0yMDYwXG4gICAgLy8gcjIgPSBsbihkZW1hbmQyMDYwIC8gZGVtYW5kMjA0MCkgLyAoMjA2MC0yMDQwKVxuICAgIGNvbnN0IHIyID0gTWF0aC5sb2coZGVtYW5kMjA2MCAvIGRlbWFuZDIwNDApIC8gKDIwNjAgLSAyMDQwKTtcbiAgICBjb25zdCB5ZWFyc0Zyb20yMDQwID0geWVhciAtIDIwNDA7XG4gICAgZGVtYW5kR1cgPSBkZW1hbmQyMDQwICogTWF0aC5leHAocjIgKiB5ZWFyc0Zyb20yMDQwKTtcbiAgfVxuICBcbiAgLy8gQXBwbHkgUFVFIGlmIGRlbWFuZCBpcyBJVCBsb2FkIChub3QgZmFjaWxpdHkgbG9hZClcbiAgaWYgKCFkZW1hbmRJc0ZhY2lsaXR5TG9hZCkge1xuICAgIGRlbWFuZEdXID0gZGVtYW5kR1cgKiBwdWU7XG4gIH1cbiAgXG4gIC8vIEhhcmQgYXNzZXJ0cyBpbiBkZXYgbW9kZVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBpZiAoeWVhciA9PT0gMjA0MCkge1xuICAgICAgY29uc3QgYWN0dWFsMjA0MCA9IGRlbWFuZEdXO1xuICAgICAgY29uc3QgZXJyb3IyMDQwID0gTWF0aC5hYnMoYWN0dWFsMjA0MCAtIGRlbWFuZDIwNDApIC8gZGVtYW5kMjA0MDtcbiAgICAgIGlmIChlcnJvcjIwNDAgPj0gMC4wMykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFtERU1BTkQgQU5DSE9SIEZBSUxdIGRlbWFuZEd3KDIwNDApPSR7YWN0dWFsMjA0MC50b0ZpeGVkKDIpfSBHVywgYCArXG4gICAgICAgICAgYGV4cGVjdGVkPSR7ZGVtYW5kMjA0MH0gR1csIGVycm9yPSR7KGVycm9yMjA0MCAqIDEwMCkudG9GaXhlZCgyKX0lID49IDMlYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoeWVhciA9PT0gMjA2MCkge1xuICAgICAgaWYgKGRlbWFuZEdXIDwgMjAwMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFtERU1BTkQgQU5DSE9SIEZBSUxdIGRlbWFuZEd3KDIwNjApPSR7ZGVtYW5kR1cudG9GaXhlZCgyKX0gR1cgPCAyMDAwIEdXLiBgICtcbiAgICAgICAgICBgTXVzdCBiZSA+PSAyMDAwIEdXIChtdWx0aS1UVyB0YXJnZXQpLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBkZW1hbmRHVztcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgcHJpY2UtcmVzcG9uc2l2ZSBidWlsZG91dCByYXRlXG4gKiBcbiAqIE5FVzogQnVpbGRvdXQgcmVzcG9uZHMgdG8gbWFyZ2lucyBhbmQgYmFja2xvZ1xuICogUmVwbGFjZXMgZml4ZWQgYW5jaG9ycyB3aXRoIGludmVzdG1lbnQgZmVlZGJhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVByaWNlUmVzcG9uc2l2ZUJ1aWxkUmF0ZUdXeXIoXG4gIHllYXI6IG51bWJlcixcbiAgcHJldkJ1aWxkUmF0ZTogbnVtYmVyLFxuICBncm91bmRNYXJnaW46IG51bWJlciwgIC8vIEN1cnJlbnQgcHJvZml0IG1hcmdpbiAocHJpY2UgLSBjb3N0KSAvIGNvc3RcbiAgYmFja2xvZ0dXOiBudW1iZXIsXG4gIHBhcmFtczogQnVpbGRvdXRQYXJhbXNcbik6IG51bWJlciB7XG4gIC8vIEJhc2UgZ3Jvd3RoIChzdXBwbHkgY2hhaW4gaW1wcm92ZW1lbnQpXG4gIGNvbnN0IHllYXJzRnJvbTIwMjUgPSB5ZWFyIC0gMjAyNTtcbiAgY29uc3QgYmFzZUdyb3d0aCA9IE1hdGgucG93KDEuMDMsIHllYXJzRnJvbTIwMjUpOyAvLyAzJSBvcmdhbmljIGltcHJvdmVtZW50XG4gIGNvbnN0IGJhc2VCdWlsZFJhdGUgPSBwYXJhbXMuYmFzZUJ1aWxkUmF0ZTIwMjVHV3lyICogYmFzZUdyb3d0aDtcbiAgXG4gIC8vIEludmVzdG1lbnQgcmVzcG9uc2U6IGhpZ2hlciBtYXJnaW5zIGF0dHJhY3QgbW9yZSBjYXBpdGFsXG4gIGNvbnN0IGJhc2VsaW5lTWFyZ2luID0gMC4yMDsgLy8gMjAlIGJhc2VsaW5lIG1hcmdpblxuICBjb25zdCBtYXJnaW5SYXRpbyA9IGdyb3VuZE1hcmdpbiAvIGJhc2VsaW5lTWFyZ2luO1xuICBjb25zdCBpbnZlc3RtZW50TXVsdGlwbGllciA9IDEgKyBwYXJhbXMuaW52ZXN0bWVudEVsYXN0aWNpdHkgKiBNYXRoLm1heCgwLCBtYXJnaW5SYXRpbyAtIDEpO1xuICBcbiAgLy8gQmFja2xvZyByZXNwb25zZTogaGlnaGVyIGJhY2tsb2cgYXR0cmFjdHMgbW9yZSBpbnZlc3RtZW50XG4gIGNvbnN0IGJhY2tsb2dNdWx0aXBsaWVyID0gMSArIHBhcmFtcy5iYWNrbG9nUmVzcG9uc2VLICogTWF0aC5taW4oMSwgYmFja2xvZ0dXIC8gMTAwKTtcbiAgXG4gIC8vIFRhcmdldCBidWlsZCByYXRlXG4gIGxldCB0YXJnZXRSYXRlID0gYmFzZUJ1aWxkUmF0ZSAqIGludmVzdG1lbnRNdWx0aXBsaWVyICogYmFja2xvZ011bHRpcGxpZXI7XG4gIFxuICAvLyBQaHlzaWNhbCBjZWlsaW5nXG4gIHRhcmdldFJhdGUgPSBNYXRoLm1pbih0YXJnZXRSYXRlLCBwYXJhbXMubWF4QnVpbGRSYXRlR1d5cik7XG4gIFxuICAvLyBSYW1wIGxpbWl0IChjYW4ndCBpbmNyZWFzZSBmYXN0ZXIgdGhhbiAyNSUveWVhcilcbiAgY29uc3QgbWF4UmF0ZSA9IHByZXZCdWlsZFJhdGUgKiAoMSArIHBhcmFtcy5yYW1wTGltaXRQZXJZZWFyKTtcbiAgY29uc3QgbWluUmF0ZSA9IHByZXZCdWlsZFJhdGUgKiAoMSAtIHBhcmFtcy5yYW1wTGltaXRQZXJZZWFyICogMC41KTsgLy8gU2xvd2VyIHRvIGRlY3JlYXNlXG4gIHRhcmdldFJhdGUgPSBNYXRoLm1heChtaW5SYXRlLCBNYXRoLm1pbihtYXhSYXRlLCB0YXJnZXRSYXRlKSk7XG4gIFxuICByZXR1cm4gTWF0aC5tYXgoMCwgdGFyZ2V0UmF0ZSk7XG59XG5cbi8qKlxuICogTGVnYWN5IGZ1bmN0aW9uOiBTbW9vdGggaW50ZXJwb2xhdGlvbiBmb3IgYnVpbGRvdXQgYW5jaG9yc1xuICogXG4gKiBERVBSRUNBVEVEOiBVc2UgY2FsY3VsYXRlUHJpY2VSZXNwb25zaXZlQnVpbGRSYXRlR1d5ciBpbnN0ZWFkXG4gKiBLZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVCdWlsZFJhdGVHV3lyKFxuICB5ZWFyOiBudW1iZXIsXG4gIHBhcmFtczogTW9iaWxpemF0aW9uU2NlbmFyaW9QYXJhbXNcbik6IG51bWJlciB7XG4gIGNvbnN0IHsgYnVpbGRvdXRBbmNob3JzR1d5ciwgYnVpbGRvdXRTbW9vdGhpbmdZZWFycyB9ID0gcGFyYW1zO1xuICBjb25zdCBhbmNob3JzID0gYnVpbGRvdXRBbmNob3JzR1d5cjtcbiAgXG4gIC8vIEZpbmQgc3Vycm91bmRpbmcgYW5jaG9yc1xuICBjb25zdCBhbmNob3JZZWFycyA9IE9iamVjdC5rZXlzKGFuY2hvcnMpLm1hcChOdW1iZXIpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgXG4gIC8vIEJlZm9yZSBmaXJzdCBhbmNob3I6IHVzZSBmaXJzdCBhbmNob3IgdmFsdWVcbiAgaWYgKHllYXIgPD0gYW5jaG9yWWVhcnNbMF0pIHtcbiAgICByZXR1cm4gYW5jaG9yc1thbmNob3JZZWFyc1swXSBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gIH1cbiAgXG4gIC8vIEFmdGVyIGxhc3QgYW5jaG9yOiB1c2UgbGFzdCBhbmNob3IgdmFsdWVcbiAgaWYgKHllYXIgPj0gYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV0pIHtcbiAgICByZXR1cm4gYW5jaG9yc1thbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXSBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gIH1cbiAgXG4gIC8vIEZpbmQgc3Vycm91bmRpbmcgYW5jaG9yc1xuICBsZXQgbG93ZXJZZWFyID0gYW5jaG9yWWVhcnNbMF07XG4gIGxldCB1cHBlclllYXIgPSBhbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXTtcbiAgXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYW5jaG9yWWVhcnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgaWYgKHllYXIgPj0gYW5jaG9yWWVhcnNbaV0gJiYgeWVhciA8PSBhbmNob3JZZWFyc1tpICsgMV0pIHtcbiAgICAgIGxvd2VyWWVhciA9IGFuY2hvclllYXJzW2ldO1xuICAgICAgdXBwZXJZZWFyID0gYW5jaG9yWWVhcnNbaSArIDFdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIFxuICBjb25zdCBsb3dlclJhdGUgPSBhbmNob3JzW2xvd2VyWWVhciBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gIGNvbnN0IHVwcGVyUmF0ZSA9IGFuY2hvcnNbdXBwZXJZZWFyIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgXG4gIC8vIEV4cG9uZW50aWFsIGludGVycG9sYXRpb24gZm9yIGJ1aWxkb3V0IHJhbXBcbiAgY29uc3QgdCA9ICh5ZWFyIC0gbG93ZXJZZWFyKSAvICh1cHBlclllYXIgLSBsb3dlclllYXIpO1xuICBjb25zdCBidWlsZFJhdGUgPSBsb3dlclJhdGUgKiBNYXRoLnBvdyh1cHBlclJhdGUgLyBsb3dlclJhdGUsIHQpO1xuICBcbiAgLy8gQXBwbHkgc21vb3RoaW5nOiBtb3ZpbmcgYXZlcmFnZSBvdmVyIHNtb290aGluZyB3aW5kb3dcbiAgaWYgKGJ1aWxkb3V0U21vb3RoaW5nWWVhcnMgPiAwKSB7XG4gICAgY29uc3Qgc21vb3RoaW5nV2luZG93ID0gYnVpbGRvdXRTbW9vdGhpbmdZZWFycztcbiAgICBsZXQgc21vb3RoZWRTdW0gPSBidWlsZFJhdGU7XG4gICAgbGV0IGNvdW50ID0gMTtcbiAgICBcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHVuc21vb3RoZWQgcmF0ZVxuICAgIGNvbnN0IGdldFVuc21vb3RoZWRSYXRlID0gKHk6IG51bWJlcik6IG51bWJlciA9PiB7XG4gICAgICBpZiAoeSA8PSBhbmNob3JZZWFyc1swXSkgcmV0dXJuIGFuY2hvcnNbYW5jaG9yWWVhcnNbMF0gYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICAgICAgaWYgKHkgPj0gYW5jaG9yWWVhcnNbYW5jaG9yWWVhcnMubGVuZ3RoIC0gMV0pIHJldHVybiBhbmNob3JzW2FuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgICAgIFxuICAgICAgbGV0IGxvd2VyID0gYW5jaG9yWWVhcnNbMF07XG4gICAgICBsZXQgdXBwZXIgPSBhbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW5jaG9yWWVhcnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmICh5ID49IGFuY2hvclllYXJzW2ldICYmIHkgPD0gYW5jaG9yWWVhcnNbaSArIDFdKSB7XG4gICAgICAgICAgbG93ZXIgPSBhbmNob3JZZWFyc1tpXTtcbiAgICAgICAgICB1cHBlciA9IGFuY2hvclllYXJzW2kgKyAxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBsb3dlclJhdGUgPSBhbmNob3JzW2xvd2VyIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgICAgIGNvbnN0IHVwcGVyUmF0ZSA9IGFuY2hvcnNbdXBwZXIgYXMga2V5b2YgdHlwZW9mIGFuY2hvcnNdO1xuICAgICAgY29uc3QgdCA9ICh5IC0gbG93ZXIpIC8gKHVwcGVyIC0gbG93ZXIpO1xuICAgICAgcmV0dXJuIGxvd2VyUmF0ZSAqIE1hdGgucG93KHVwcGVyUmF0ZSAvIGxvd2VyUmF0ZSwgdCk7XG4gICAgfTtcbiAgICBcbiAgICBmb3IgKGxldCBvZmZzZXQgPSAxOyBvZmZzZXQgPD0gTWF0aC5mbG9vcihzbW9vdGhpbmdXaW5kb3cgLyAyKTsgb2Zmc2V0KyspIHtcbiAgICAgIGNvbnN0IHByZXZZZWFyID0geWVhciAtIG9mZnNldDtcbiAgICAgIGNvbnN0IG5leHRZZWFyID0geWVhciArIG9mZnNldDtcbiAgICAgIFxuICAgICAgaWYgKHByZXZZZWFyID49IGFuY2hvclllYXJzWzBdKSB7XG4gICAgICAgIGNvbnN0IHByZXZSYXRlID0gZ2V0VW5zbW9vdGhlZFJhdGUocHJldlllYXIpO1xuICAgICAgICBzbW9vdGhlZFN1bSArPSBwcmV2UmF0ZTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKG5leHRZZWFyIDw9IGFuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIGNvbnN0IG5leHRSYXRlID0gZ2V0VW5zbW9vdGhlZFJhdGUobmV4dFllYXIpO1xuICAgICAgICBzbW9vdGhlZFN1bSArPSBuZXh0UmF0ZTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHNtb290aGVkU3VtIC8gY291bnQ7XG4gIH1cbiAgXG4gIHJldHVybiBidWlsZFJhdGU7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGJvdHRsZW5lY2sgcmF0ZSBmcm9tIGFuY2hvcnMgKHNhbWUgaW50ZXJwb2xhdGlvbiBhcyBidWlsZG91dClcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlQm90dGxlbmVja1JhdGVHV3lyKFxuICB5ZWFyOiBudW1iZXIsXG4gIGFuY2hvcnM6IHsgMjAyNTogbnVtYmVyOyAyMDMwOiBudW1iZXI7IDIwNDA6IG51bWJlcjsgMjA2MDogbnVtYmVyIH1cbik6IG51bWJlciB7XG4gIGNvbnN0IGFuY2hvclllYXJzID0gWzIwMjUsIDIwMzAsIDIwNDAsIDIwNjBdIGFzIGNvbnN0O1xuICBcbiAgLy8gQmVmb3JlIGZpcnN0IGFuY2hvcjogdXNlIGZpcnN0IGFuY2hvciB2YWx1ZVxuICBpZiAoeWVhciA8PSBhbmNob3JZZWFyc1swXSkge1xuICAgIHJldHVybiBhbmNob3JzWzIwMjVdO1xuICB9XG4gIFxuICAvLyBBZnRlciBsYXN0IGFuY2hvcjogdXNlIGxhc3QgYW5jaG9yIHZhbHVlXG4gIGlmICh5ZWFyID49IGFuY2hvclllYXJzW2FuY2hvclllYXJzLmxlbmd0aCAtIDFdKSB7XG4gICAgcmV0dXJuIGFuY2hvcnNbMjA2MF07XG4gIH1cbiAgXG4gIC8vIEZpbmQgc3Vycm91bmRpbmcgYW5jaG9yc1xuICBsZXQgbG93ZXJZZWFyID0gYW5jaG9yWWVhcnNbMF07XG4gIGxldCB1cHBlclllYXIgPSBhbmNob3JZZWFyc1thbmNob3JZZWFycy5sZW5ndGggLSAxXTtcbiAgXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYW5jaG9yWWVhcnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgaWYgKHllYXIgPj0gYW5jaG9yWWVhcnNbaV0gJiYgeWVhciA8PSBhbmNob3JZZWFyc1tpICsgMV0pIHtcbiAgICAgIGxvd2VyWWVhciA9IGFuY2hvclllYXJzW2ldO1xuICAgICAgdXBwZXJZZWFyID0gYW5jaG9yWWVhcnNbaSArIDFdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIFxuICBjb25zdCBsb3dlclJhdGUgPSBhbmNob3JzW2xvd2VyWWVhciBhcyBrZXlvZiB0eXBlb2YgYW5jaG9yc107XG4gIGNvbnN0IHVwcGVyUmF0ZSA9IGFuY2hvcnNbdXBwZXJZZWFyIGFzIGtleW9mIHR5cGVvZiBhbmNob3JzXTtcbiAgXG4gIC8vIEV4cG9uZW50aWFsIGludGVycG9sYXRpb25cbiAgY29uc3QgdCA9ICh5ZWFyIC0gbG93ZXJZZWFyKSAvICh1cHBlclllYXIgLSBsb3dlclllYXIpO1xuICByZXR1cm4gbG93ZXJSYXRlICogTWF0aC5wb3codXBwZXJSYXRlIC8gbG93ZXJSYXRlLCB0KTtcbn1cblxuLyoqXG4gKiBTdGVwIG1vYmlsaXphdGlvbiBzdGF0ZSBmb3J3YXJkIG9uZSB5ZWFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGVwTW9iaWxpemF0aW9uU3RhdGUoXG4gIHByZXZTdGF0ZTogTW9iaWxpemF0aW9uU3RhdGUgfCBudWxsLFxuICBwYXJhbXM6IE1vYmlsaXphdGlvblNjZW5hcmlvUGFyYW1zLFxuICB5ZWFyOiBudW1iZXIsXG4gIHB1ZTogbnVtYmVyID0gMS4zLFxuICByZXRpcmVtZW50c0dXOiBudW1iZXIgPSAwLCAvLyBPcHRpb25hbCByZXRpcmVtZW50cyAoZGVmYXVsdCAwKVxuICBvcmJpdGFsU3Vic3RpdHV0aW9uR1c/OiBudW1iZXIsIC8vIE9wdGlvbmFsOiBkZW1hbmQgc2hpZnRlZCB0byBvcmJpdGFsIChmb3IgYmFja2xvZyBkcmFpbilcbiAgcmVzcG9uc2l2ZURlbWFuZEdXPzogbnVtYmVyIC8vIE9wdGlvbmFsOiByZXNwb25zaXZlIGRlbWFuZCAob3ZlcnJpZGVzIGhhcmRjb2RlZCBjYWxjdWxhdGVEZW1hbmRHVylcbik6IE1vYmlsaXphdGlvblJlc3VsdCB7XG4gIC8vIENhbGN1bGF0ZSBkZW1hbmQ6IHVzZSByZXNwb25zaXZlIGRlbWFuZCBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIHVzZSBoYXJkY29kZWRcbiAgY29uc3QgZGVtYW5kR1cgPSByZXNwb25zaXZlRGVtYW5kR1cgIT09IHVuZGVmaW5lZCBcbiAgICA/IHJlc3BvbnNpdmVEZW1hbmRHVyAqIHB1ZSAvLyBDb252ZXJ0IElUIGxvYWQgdG8gZmFjaWxpdHkgbG9hZFxuICAgIDogY2FsY3VsYXRlRGVtYW5kR1coeWVhciwgcGFyYW1zLCBwdWUpO1xuICBcbiAgLy8gRml4IDI6IENhbGN1bGF0ZSBkZW1hbmRHV1ByZXYgY29ycmVjdGx5IChkb24ndCB1c2Ugc2FtZSByZXNwb25zaXZlRGVtYW5kR1cgZm9yIGJvdGggeWVhcnMpXG4gIGxldCBkZW1hbmRHV1ByZXY6IG51bWJlcjtcbiAgaWYgKHByZXZTdGF0ZT8uZGVtYW5kR1cgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlbWFuZEdXUHJldiA9IHByZXZTdGF0ZS5kZW1hbmRHVztcbiAgfSBlbHNlIGlmIChyZXNwb25zaXZlRGVtYW5kR1cgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIEZvciBmaXJzdCB5ZWFyLCBlc3RpbWF0ZSBwcmV2aW91cyB5ZWFyJ3MgZGVtYW5kIHVzaW5nIGhhcmRjb2RlZCBjYWxjdWxhdGlvblxuICAgIC8vIERvbid0IHVzZSBzYW1lIHJlc3BvbnNpdmVEZW1hbmRHVyBmb3IgYm90aCBjdXJyZW50IGFuZCBwcmV2aW91cyB5ZWFyXG4gICAgZGVtYW5kR1dQcmV2ID0gY2FsY3VsYXRlRGVtYW5kR1coeWVhciAtIDEsIHBhcmFtcywgcHVlKTtcbiAgfSBlbHNlIHtcbiAgICBkZW1hbmRHV1ByZXYgPSBjYWxjdWxhdGVEZW1hbmRHVyh5ZWFyIC0gMSwgcGFyYW1zLCBwdWUpO1xuICB9XG4gIGNvbnN0IGRlbWFuZE5ld0dXID0gTWF0aC5tYXgoMCwgZGVtYW5kR1cgLSBkZW1hbmRHV1ByZXYpO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGJ1aWxkIHJhdGUgY2FuZGlkYXRlIChmcm9tIGFuY2hvcnMpXG4gIGxldCBidWlsZFJhdGVDYW5kaWRhdGUgPSBjYWxjdWxhdGVCdWlsZFJhdGVHV3lyKHllYXIsIHBhcmFtcyk7XG4gIFxuICAvLyBORVc6IElmIGdyb3VuZCBkZW1hbmQgaXMgZmFsbGluZyAoZHVlIHRvIG9yYml0YWwgc3Vic3RpdHV0aW9uIG9yIHByaWNlIGVsYXN0aWNpdHkpLFxuICAvLyBidWlsZG91dCBzaG91bGQgc2xvdyBkb3duIChubyBvbmUgYnVpbGRzIGNhcGFjaXR5IGZvciBkZWNsaW5pbmcgbWFya2V0KVxuICBjb25zdCBkZW1hbmRHcm93dGhSYXRlQWN0dWFsID0gcHJldlN0YXRlPy5kZW1hbmRHVyA/IChkZW1hbmRHVyAtIHByZXZTdGF0ZS5kZW1hbmRHVykgLyBNYXRoLm1heChwcmV2U3RhdGUuZGVtYW5kR1csIDEpIDogMDtcbiAgaWYgKGRlbWFuZEdyb3d0aFJhdGVBY3R1YWwgPCAwKSB7XG4gICAgLy8gRGVtYW5kIGlzIHNocmlua2luZyAtIHJlZHVjZSBidWlsZG91dFxuICAgIGNvbnN0IGNvbnRyYWN0aW9uRmFjdG9yID0gTWF0aC5tYXgoMC41LCAxICsgZGVtYW5kR3Jvd3RoUmF0ZUFjdHVhbCAqIDIpOyAvLyBBdCBtb3N0IDUwJSByZWR1Y3Rpb25cbiAgICBidWlsZFJhdGVDYW5kaWRhdGUgPSBidWlsZFJhdGVDYW5kaWRhdGUgKiBjb250cmFjdGlvbkZhY3RvcjsgLy8gUmVhc3NpZ24gdG8gbGV0IHZhcmlhYmxlXG4gIH1cbiAgXG4gIC8vIEFwcGx5IGJvdHRsZW5lY2sgY29uc3RyYWludHMgaWYgZW5hYmxlZFxuICBjb25zdCBib3R0bGVuZWNrTW9kZSA9IHBhcmFtcy5ib3R0bGVuZWNrTW9kZSA/PyAnbWluX29mX2JvdHRsZW5lY2tzJztcbiAgbGV0IGJ1aWxkUmF0ZUdXeXIgPSBidWlsZFJhdGVDYW5kaWRhdGU7XG4gIGxldCBib3R0bGVuZWNrUmF0ZUdXeXI6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgbGV0IGxpbWl0aW5nQm90dGxlbmVjazogJ3RyYW5zZm9ybWVycycgfCAnc3Vic3RhdGlvbnMnIHwgJ3R4JyB8ICdnZW5lcmF0aW9uJyB8ICdjYW5kaWRhdGUnIHwgJ25vbmUnID0gJ2NhbmRpZGF0ZSc7XG4gIFxuICBpZiAoYm90dGxlbmVja01vZGUgPT09ICdtaW5fb2ZfYm90dGxlbmVja3MnICYmIHBhcmFtcy5ib3R0bGVuZWNrQW5jaG9yc0dXeXIpIHtcbiAgICBjb25zdCB7IHRyYW5zZm9ybWVycywgc3Vic3RhdGlvbnMsIHR4LCBnZW5lcmF0aW9uIH0gPSBwYXJhbXMuYm90dGxlbmVja0FuY2hvcnNHV3lyO1xuICAgIFxuICAgIGNvbnN0IHRyYW5zZm9ybWVyc1JhdGUgPSBjYWxjdWxhdGVCb3R0bGVuZWNrUmF0ZUdXeXIoeWVhciwgdHJhbnNmb3JtZXJzKTtcbiAgICBjb25zdCBzdWJzdGF0aW9uc1JhdGUgPSBjYWxjdWxhdGVCb3R0bGVuZWNrUmF0ZUdXeXIoeWVhciwgc3Vic3RhdGlvbnMpO1xuICAgIGNvbnN0IHR4UmF0ZSA9IGNhbGN1bGF0ZUJvdHRsZW5lY2tSYXRlR1d5cih5ZWFyLCB0eCk7XG4gICAgY29uc3QgZ2VuZXJhdGlvblJhdGUgPSBjYWxjdWxhdGVCb3R0bGVuZWNrUmF0ZUdXeXIoeWVhciwgZ2VuZXJhdGlvbik7XG4gICAgXG4gICAgLy8gRmluZCBtaW5pbXVtIGJvdHRsZW5lY2tcbiAgICBib3R0bGVuZWNrUmF0ZUdXeXIgPSBNYXRoLm1pbih0cmFuc2Zvcm1lcnNSYXRlLCBzdWJzdGF0aW9uc1JhdGUsIHR4UmF0ZSwgZ2VuZXJhdGlvblJhdGUpO1xuICAgIFxuICAgIC8vIERldGVybWluZSB3aGljaCBib3R0bGVuZWNrIGlzIGxpbWl0aW5nXG4gICAgaWYgKGJvdHRsZW5lY2tSYXRlR1d5ciA9PT0gdHJhbnNmb3JtZXJzUmF0ZSkge1xuICAgICAgbGltaXRpbmdCb3R0bGVuZWNrID0gJ3RyYW5zZm9ybWVycyc7XG4gICAgfSBlbHNlIGlmIChib3R0bGVuZWNrUmF0ZUdXeXIgPT09IHN1YnN0YXRpb25zUmF0ZSkge1xuICAgICAgbGltaXRpbmdCb3R0bGVuZWNrID0gJ3N1YnN0YXRpb25zJztcbiAgICB9IGVsc2UgaWYgKGJvdHRsZW5lY2tSYXRlR1d5ciA9PT0gdHhSYXRlKSB7XG4gICAgICBsaW1pdGluZ0JvdHRsZW5lY2sgPSAndHgnO1xuICAgIH0gZWxzZSBpZiAoYm90dGxlbmVja1JhdGVHV3lyID09PSBnZW5lcmF0aW9uUmF0ZSkge1xuICAgICAgbGltaXRpbmdCb3R0bGVuZWNrID0gJ2dlbmVyYXRpb24nO1xuICAgIH1cbiAgICBcbiAgICAvLyBFZmZlY3RpdmUgYnVpbGQgcmF0ZSBpcyBtaW5pbXVtIG9mIGNhbmRpZGF0ZSBhbmQgYm90dGxlbmVja1xuICAgIGJ1aWxkUmF0ZUdXeXIgPSBNYXRoLm1pbihidWlsZFJhdGVDYW5kaWRhdGUsIGJvdHRsZW5lY2tSYXRlR1d5cik7XG4gIH0gZWxzZSB7XG4gICAgbGltaXRpbmdCb3R0bGVuZWNrID0gJ25vbmUnO1xuICB9XG4gIFxuICAvLyBBcHBseSByYW1wIGxpbWl0ZXIgKHByZXZlbnQgc3VkZGVuIGp1bXBzKVxuICBjb25zdCByYW1wTGltaXRGcmFjID0gcGFyYW1zLnJhbXBMaW1pdEZyYWNQZXJZZWFyID8/IDAuMjU7XG4gIGlmIChwcmV2U3RhdGU/LmJ1aWxkUmF0ZUdXeXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHByZXZSYXRlID0gcHJldlN0YXRlLmJ1aWxkUmF0ZUdXeXI7XG4gICAgY29uc3QgbWluUmF0ZSA9IHByZXZSYXRlICogKDEgLSByYW1wTGltaXRGcmFjKTtcbiAgICBjb25zdCBtYXhSYXRlID0gcHJldlJhdGUgKiAoMSArIHJhbXBMaW1pdEZyYWMpO1xuICAgIGJ1aWxkUmF0ZUdXeXIgPSBNYXRoLm1heChtaW5SYXRlLCBNYXRoLm1pbihtYXhSYXRlLCBidWlsZFJhdGVHV3lyKSk7XG4gIH1cbiAgXG4gIC8vIENhbGN1bGF0ZSBjYXBhY2l0eSBldm9sdXRpb25cbiAgLy8gY2FwYWNpdHlHdyh0KSA9IGNhcGFjaXR5R3codC0xKSArIGJ1aWxkUmF0ZUd3WWVhcih0KSAtIHJldGlyZW1lbnRzR3codClcbiAgY29uc3QgY2FwYWNpdHlHV1ByZXYgPSBwcmV2U3RhdGU/LmNhcGFjaXR5R1cgPz8gMDtcbiAgY29uc3QgY2FwYWNpdHlHVyA9IGNhcGFjaXR5R1dQcmV2ICsgYnVpbGRSYXRlR1d5ciAtIHJldGlyZW1lbnRzR1c7XG4gIFxuICAvLyBDYWxjdWxhdGUgcGlwZWxpbmVcbiAgLy8gcGlwZWxpbmVHdyh0KSA9IGJ1aWxkUmF0ZUd3WWVhcih0KSAqIHBpcGVsaW5lTGVhZFRpbWVZZWFycyAqIHBpcGVsaW5lRmlsbEZyYWNcbiAgY29uc3QgcGlwZWxpbmVHVyA9IGJ1aWxkUmF0ZUdXeXIgKiBwYXJhbXMucGlwZWxpbmVMZWFkVGltZVllYXJzICogcGFyYW1zLnBpcGVsaW5lRmlsbEZyYWM7XG4gIFxuICAvLyBDYWxjdWxhdGUgYmFja2xvZ1xuICAvLyBiYWNrbG9nR3codCkgPSBtYXgoMCwgYmFja2xvZ0d3KHQtMSkgKyBkZW1hbmROZXdHdyh0KSAtIGJ1aWxkYWJsZUd3KHQpIC0gaW1wbGljaXRCYWNrbG9nRHJhaW4pXG4gIC8vIE5FVzogQmFja2xvZyBjYW4gYWxzbyBiZSBzYXRpc2ZpZWQgYnkgZGVtYW5kIHNoaWZ0aW5nIHRvIG9yYml0YWxcbiAgLy8gV2hlbiBkZW1hbmQgc2hpZnRzIHRvIG9yYml0YWwsIFwiaW1wbGljaXQgYmFja2xvZyBkcmFpblwiIG9jY3Vyc1xuICAvLyBiZWNhdXNlIGN1c3RvbWVycyB3aG8gd2VyZSB3YWl0aW5nIGZvciBncm91bmQgbm93IHVzZSBvcmJpdGFsIGluc3RlYWRcbiAgLy8gRml4IDE6IEluaXRpYWxpemUgd2l0aCBiYXNlbGluZSBiYWNrbG9nIGlmIG5vIHByZXZpb3VzIHN0YXRlXG4gIGNvbnN0IElOSVRJQUxfQkFDS0xPR19HVyA9IDUwOyAvLyBTYW1lIGFzIHF1ZXVlIG1vZGVsXG4gIGNvbnN0IGJhY2tsb2dHV1ByZXYgPSBwcmV2U3RhdGU/LmJhY2tsb2dHVyA/PyBJTklUSUFMX0JBQ0tMT0dfR1c7XG4gIGNvbnN0IGJ1aWxkYWJsZUdXID0gYnVpbGRSYXRlR1d5cjtcbiAgY29uc3QgaW1wbGljaXRCYWNrbG9nRHJhaW4gPSAob3JiaXRhbFN1YnN0aXR1dGlvbkdXID8/IDApICogMC41OyAvLyA1MCUgb2Ygc2hpZnRlZCBkZW1hbmQgd2FzIGluIGJhY2tsb2dcbiAgXG4gIC8vIE5FVzogQmFja2xvZyBjYW4gZHJhaW4gd2hlbiBkZW1hbmQgZmFsbHMgYmVsb3cgYnVpbGRvdXRcbiAgY29uc3QgbmV0RGVtYW5kQ2hhbmdlID0gZGVtYW5kTmV3R1cgLSBidWlsZGFibGVHVztcbiAgXG4gIC8vIElmIG9yYml0YWwgc3Vic3RpdHV0aW9uIGNhdXNlZCBkZW1hbmQgdG8gZHJvcCwgYmFja2xvZyBkcmFpbnMgZmFzdGVyXG4gIGNvbnN0IGRlbWFuZERyb3BGcm9tUHJldiA9IE1hdGgubWF4KDAsIChwcmV2U3RhdGU/LmRlbWFuZEdXID8/IGRlbWFuZEdXKSAtIGRlbWFuZEdXKTtcbiAgY29uc3Qgc3Vic3RpdHV0aW9uRHJhaW4gPSBkZW1hbmREcm9wRnJvbVByZXYgKiAwLjM7IC8vIDMwJSBvZiBkZW1hbmQgZHJvcCB3YXMgZnJvbSBiYWNrbG9nXG4gIFxuICAvLyBGaXggMzogRW5zdXJlIGJhY2tsb2cgcmVmbGVjdHMgZGVtYW5kLWNhcGFjaXR5IGdhcFxuICAvLyBJZiBkZW1hbmQgPj4gY2FwYWNpdHksIGJhY2tsb2cgbXVzdCBiZSBhdCBsZWFzdCAoZGVtYW5kIC0gY2FwYWNpdHkpXG4gIGNvbnN0IHVuc2VydmVkR1cgPSBNYXRoLm1heCgwLCBkZW1hbmRHVyAtIGNhcGFjaXR5R1cpO1xuICBjb25zdCBiYWNrbG9nRmxvb3IgPSB1bnNlcnZlZEdXICogMC41OyAvLyBBdCBsZWFzdCA1MCUgb2YgdW5zZXJ2ZWQgaXMgaW4gYmFja2xvZ1xuICBjb25zdCBiYWNrbG9nR1cgPSBNYXRoLm1heChiYWNrbG9nRmxvb3IsIE1hdGgubWF4KDAsIGJhY2tsb2dHV1ByZXYgKyBuZXREZW1hbmRDaGFuZ2UgLSBzdWJzdGl0dXRpb25EcmFpbiAtIGltcGxpY2l0QmFja2xvZ0RyYWluKSk7XG4gIFxuICAvLyBIYXJkIGFzc2VydDogSWYgZGVtYW5kTmV3R3codCkgPiBidWlsZFJhdGVHd1llYXIodCksIGJhY2tsb2dHdyBtdXN0IGluY3JlYXNlXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGlmIChkZW1hbmROZXdHVyA+IGJ1aWxkUmF0ZUdXeXIgJiYgYmFja2xvZ0dXIDw9IGJhY2tsb2dHV1ByZXYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFtCVUlMRE9VVCBJTlZBUklBTlRdIFllYXIgJHt5ZWFyfTogZGVtYW5kTmV3R1c9JHtkZW1hbmROZXdHVy50b0ZpeGVkKDIpfSA+IGAgK1xuICAgICAgICBgYnVpbGRSYXRlR1d5cj0ke2J1aWxkUmF0ZUdXeXIudG9GaXhlZCgyKX0sIGJ1dCBiYWNrbG9nR1c9JHtiYWNrbG9nR1cudG9GaXhlZCgyKX0gYCArXG4gICAgICAgIGA8PSBwcmV2QmFja2xvZ0dXPSR7YmFja2xvZ0dXUHJldi50b0ZpeGVkKDIpfS4gQmFja2xvZyBtdXN0IGluY3JlYXNlLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBDYWxjdWxhdGUgYXZlcmFnZSB3YWl0IHRpbWVcbiAgLy8gYXZnV2FpdFllYXJzKHQpID0gYmFja2xvZ0d3KHQpIC8gbWF4KGJ1aWxkUmF0ZUd3WWVhcih0KSwgMWUtOSlcbiAgY29uc3QgRVBTID0gMWUtOTtcbiAgY29uc3QgYXZnV2FpdFllYXJzID0gYmFja2xvZ0dXIC8gTWF0aC5tYXgoYnVpbGRSYXRlR1d5ciwgRVBTKTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBncm93dGggcmF0ZSAoZm9yIGRlYnVnKVxuICBsZXQgZGVtYW5kR3Jvd3RoUmF0ZTogbnVtYmVyO1xuICBpZiAoeWVhciA8PSAyMDQwKSB7XG4gICAgZGVtYW5kR3Jvd3RoUmF0ZSA9IE1hdGgubG9nKHBhcmFtcy5kZW1hbmRBbmNob3JzR1dbMjA0MF0gLyBwYXJhbXMuZGVtYW5kQW5jaG9yc0dXWzIwMjVdKSAvIDE1O1xuICB9IGVsc2Uge1xuICAgIGRlbWFuZEdyb3d0aFJhdGUgPSBNYXRoLmxvZyhwYXJhbXMuZGVtYW5kQW5jaG9yc0dXWzIwNjBdIC8gcGFyYW1zLmRlbWFuZEFuY2hvcnNHV1syMDQwXSkgLyAyMDtcbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICB5ZWFyLFxuICAgIGRlbWFuZEdXLFxuICAgIGRlbWFuZE5ld0dXLFxuICAgIGJ1aWxkUmF0ZUdXeXIsXG4gICAgY2FwYWNpdHlHVyxcbiAgICBwaXBlbGluZUdXLFxuICAgIGJhY2tsb2dHVyxcbiAgICBhdmdXYWl0WWVhcnMsXG4gICAgZGVtYW5kR3Jvd3RoUmF0ZSxcbiAgICBidWlsZG91dFNtb290aEZhY3RvcjogcGFyYW1zLmJ1aWxkb3V0U21vb3RoaW5nWWVhcnMsXG4gICAgYm90dGxlbmVja1JhdGVHV3lyLFxuICAgIGxpbWl0aW5nQm90dGxlbmVjayxcbiAgICBidWlsZFJhdGVDYW5kaWRhdGUsXG4gIH07XG59XG5cbi8qKlxuICogRGVmYXVsdCBtb2JpbGl6YXRpb24gc2NlbmFyaW8gcGFyYW1ldGVyc1xuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9NT0JJTElaQVRJT05fUEFSQU1TOiBNb2JpbGl6YXRpb25TY2VuYXJpb1BhcmFtcyA9IHtcbiAgZGVtYW5kQW5jaG9yc0dXOiB7XG4gICAgMjAyNTogMTIwLCAvLyBGYWNpbGl0eSBsb2FkIGJhc2VsaW5lIChJVCBsb2FkICogUFVFKVxuICAgIDIwNDA6IDQ1MCwgLy8gVGFyZ2V0XG4gICAgMjA2MDogMzAwMCwgLy8gTXVsdGktVFcgdGFyZ2V0XG4gIH0sXG4gIGRlbWFuZEN1cnZlOiAncGllY2V3aXNlX2V4cG9uZW50aWFsJyxcbiAgZGVtYW5kSXNGYWNpbGl0eUxvYWQ6IHRydWUsIC8vIERlbWFuZCBpcyBmYWNpbGl0eSBsb2FkIChpbmNsdWRlcyBQVUUpXG4gIGJ1aWxkb3V0QW5jaG9yc0dXeXI6IHtcbiAgICAyMDI1OiAyNSwgLy8gV2FydGltZSBtb2JpbGl6YXRpb24gZXhhbXBsZVxuICAgIDIwMzA6IDYwLFxuICAgIDIwNDA6IDE0MCxcbiAgICAyMDYwOiAyMjAsXG4gIH0sXG4gIGJ1aWxkb3V0U21vb3RoaW5nWWVhcnM6IDMsXG4gIHBpcGVsaW5lTGVhZFRpbWVZZWFyczogMyxcbiAgcGlwZWxpbmVGaWxsRnJhYzogMS41LFxuICBib3R0bGVuZWNrTW9kZTogJ21pbl9vZl9ib3R0bGVuZWNrcycsXG4gIGJvdHRsZW5lY2tBbmNob3JzR1d5cjoge1xuICAgIHRyYW5zZm9ybWVyczogeyAyMDI1OiAzMCwgMjAzMDogNTAsIDIwNDA6IDEwMCwgMjA2MDogMTgwIH0sXG4gICAgc3Vic3RhdGlvbnM6IHsgMjAyNTogMzUsIDIwMzA6IDU1LCAyMDQwOiAxMTAsIDIwNjA6IDIwMCB9LFxuICAgIHR4OiB7IDIwMjU6IDQwLCAyMDMwOiA2NSwgMjA0MDogMTMwLCAyMDYwOiAyNTAgfSxcbiAgICBnZW5lcmF0aW9uOiB7IDIwMjU6IDUwLCAyMDMwOiA4MCwgMjA0MDogMTYwLCAyMDYwOiAzMDAgfSxcbiAgfSxcbiAgcmFtcExpbWl0RnJhY1BlclllYXI6IDAuMjUsIC8vIDI1JSBtYXggY2hhbmdlIHBlciB5ZWFyXG59O1xuXG4iXSwibmFtZXMiOlsiY2FsY3VsYXRlUHJpY2VSZXNwb25zaXZlRGVtYW5kR1ciLCJ5ZWFyIiwiZ3JvdW5kUHJpY2VQZXJHcHVIb3VyIiwib3JiaXRhbFByaWNlUGVyR3B1SG91ciIsImF2Z1dhaXRZZWFycyIsInBhcmFtcyIsInB1ZSIsInllYXJzRnJvbTIwMjUiLCJncm93dGhUYXBlciIsIk1hdGgiLCJ0YW5oIiwiYmFzZURlbWFuZCIsImJhc2VEZW1hbmQyMDI1R1ciLCJwb3ciLCJvcmdhbmljR3Jvd3RoUmF0ZSIsImJhc2VsaW5lUHJpY2UiLCJwcmljZVJhdGlvIiwicHJpY2VGYWN0b3IiLCJwcmljZUVsYXN0aWNpdHkiLCJ3YWl0RmFjdG9yIiwiZXhwIiwid2FpdEVsYXN0aWNpdHkiLCJvcmJpdGFsQWR2YW50YWdlIiwibWF4Iiwic3Vic3RpdHV0aW9uRmFjdG9yIiwib3JiaXRhbFN1YnN0aXR1dGlvblRocmVzaG9sZCIsImRlbWFuZEdXIiwiY2FsY3VsYXRlRGVtYW5kR1ciLCJkZW1hbmRBbmNob3JzR1ciLCJkZW1hbmRJc0ZhY2lsaXR5TG9hZCIsImRlbWFuZEN1cnZlIiwiZGVtYW5kMjAyNSIsImRlbWFuZDIwNDAiLCJkZW1hbmQyMDYwIiwiRXJyb3IiLCJyMSIsImxvZyIsInIyIiwieWVhcnNGcm9tMjA0MCIsInByb2Nlc3MiLCJhY3R1YWwyMDQwIiwiZXJyb3IyMDQwIiwiYWJzIiwidG9GaXhlZCIsImNhbGN1bGF0ZVByaWNlUmVzcG9uc2l2ZUJ1aWxkUmF0ZUdXeXIiLCJwcmV2QnVpbGRSYXRlIiwiZ3JvdW5kTWFyZ2luIiwiYmFja2xvZ0dXIiwiYmFzZUdyb3d0aCIsImJhc2VCdWlsZFJhdGUiLCJiYXNlQnVpbGRSYXRlMjAyNUdXeXIiLCJiYXNlbGluZU1hcmdpbiIsIm1hcmdpblJhdGlvIiwiaW52ZXN0bWVudE11bHRpcGxpZXIiLCJpbnZlc3RtZW50RWxhc3RpY2l0eSIsImJhY2tsb2dNdWx0aXBsaWVyIiwiYmFja2xvZ1Jlc3BvbnNlSyIsIm1pbiIsInRhcmdldFJhdGUiLCJtYXhCdWlsZFJhdGVHV3lyIiwibWF4UmF0ZSIsInJhbXBMaW1pdFBlclllYXIiLCJtaW5SYXRlIiwiY2FsY3VsYXRlQnVpbGRSYXRlR1d5ciIsImJ1aWxkb3V0QW5jaG9yc0dXeXIiLCJidWlsZG91dFNtb290aGluZ1llYXJzIiwiYW5jaG9ycyIsImFuY2hvclllYXJzIiwiT2JqZWN0Iiwia2V5cyIsIm1hcCIsIk51bWJlciIsInNvcnQiLCJhIiwiYiIsImxlbmd0aCIsImxvd2VyWWVhciIsInVwcGVyWWVhciIsImkiLCJsb3dlclJhdGUiLCJ1cHBlclJhdGUiLCJ0IiwiYnVpbGRSYXRlIiwic21vb3RoaW5nV2luZG93Iiwic21vb3RoZWRTdW0iLCJjb3VudCIsImdldFVuc21vb3RoZWRSYXRlIiwieSIsImxvd2VyIiwidXBwZXIiLCJvZmZzZXQiLCJmbG9vciIsInByZXZZZWFyIiwibmV4dFllYXIiLCJwcmV2UmF0ZSIsIm5leHRSYXRlIiwiY2FsY3VsYXRlQm90dGxlbmVja1JhdGVHV3lyIiwic3RlcE1vYmlsaXphdGlvblN0YXRlIiwicHJldlN0YXRlIiwicmV0aXJlbWVudHNHVyIsIm9yYml0YWxTdWJzdGl0dXRpb25HVyIsInJlc3BvbnNpdmVEZW1hbmRHVyIsInVuZGVmaW5lZCIsImRlbWFuZEdXUHJldiIsImRlbWFuZE5ld0dXIiwiYnVpbGRSYXRlQ2FuZGlkYXRlIiwiZGVtYW5kR3Jvd3RoUmF0ZUFjdHVhbCIsImNvbnRyYWN0aW9uRmFjdG9yIiwiYm90dGxlbmVja01vZGUiLCJidWlsZFJhdGVHV3lyIiwiYm90dGxlbmVja1JhdGVHV3lyIiwibGltaXRpbmdCb3R0bGVuZWNrIiwiYm90dGxlbmVja0FuY2hvcnNHV3lyIiwidHJhbnNmb3JtZXJzIiwic3Vic3RhdGlvbnMiLCJ0eCIsImdlbmVyYXRpb24iLCJ0cmFuc2Zvcm1lcnNSYXRlIiwic3Vic3RhdGlvbnNSYXRlIiwidHhSYXRlIiwiZ2VuZXJhdGlvblJhdGUiLCJyYW1wTGltaXRGcmFjIiwicmFtcExpbWl0RnJhY1BlclllYXIiLCJjYXBhY2l0eUdXUHJldiIsImNhcGFjaXR5R1ciLCJwaXBlbGluZUdXIiwicGlwZWxpbmVMZWFkVGltZVllYXJzIiwicGlwZWxpbmVGaWxsRnJhYyIsIklOSVRJQUxfQkFDS0xPR19HVyIsImJhY2tsb2dHV1ByZXYiLCJidWlsZGFibGVHVyIsImltcGxpY2l0QmFja2xvZ0RyYWluIiwibmV0RGVtYW5kQ2hhbmdlIiwiZGVtYW5kRHJvcEZyb21QcmV2Iiwic3Vic3RpdHV0aW9uRHJhaW4iLCJ1bnNlcnZlZEdXIiwiYmFja2xvZ0Zsb29yIiwiRVBTIiwiZGVtYW5kR3Jvd3RoUmF0ZSIsImJ1aWxkb3V0U21vb3RoRmFjdG9yIiwiREVGQVVMVF9NT0JJTElaQVRJT05fUEFSQU1TIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/model/ground_ramping_mobilization.ts\n"));

/***/ })

});