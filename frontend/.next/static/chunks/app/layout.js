/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fpranav%2FCoding_Projects%2FCursor%2Forbitalcompute%2Ffrontend%2Fapp%2Fcomponents%2FSimPollingProvider.tsx&modules=%2FUsers%2Fpranav%2FCoding_Projects%2FCursor%2Forbitalcompute%2Ffrontend%2Fapp%2Fglobals.css&server=false!":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fpranav%2FCoding_Projects%2FCursor%2Forbitalcompute%2Ffrontend%2Fapp%2Fcomponents%2FSimPollingProvider.tsx&modules=%2FUsers%2Fpranav%2FCoding_Projects%2FCursor%2Forbitalcompute%2Ffrontend%2Fapp%2Fglobals.css&server=false! ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/components/SimPollingProvider.tsx */ \"(app-pages-browser)/./app/components/SimPollingProvider.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/globals.css */ \"(app-pages-browser)/./app/globals.css\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRnByYW5hdiUyRkNvZGluZ19Qcm9qZWN0cyUyRkN1cnNvciUyRm9yYml0YWxjb21wdXRlJTJGZnJvbnRlbmQlMkZhcHAlMkZjb21wb25lbnRzJTJGU2ltUG9sbGluZ1Byb3ZpZGVyLnRzeCZtb2R1bGVzPSUyRlVzZXJzJTJGcHJhbmF2JTJGQ29kaW5nX1Byb2plY3RzJTJGQ3Vyc29yJTJGb3JiaXRhbGNvbXB1dGUlMkZmcm9udGVuZCUyRmFwcCUyRmdsb2JhbHMuY3NzJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsd01BQXVJO0FBQ3ZJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/NDllMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9wcmFuYXYvQ29kaW5nX1Byb2plY3RzL0N1cnNvci9vcmJpdGFsY29tcHV0ZS9mcm9udGVuZC9hcHAvY29tcG9uZW50cy9TaW1Qb2xsaW5nUHJvdmlkZXIudHN4XCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvcHJhbmF2L0NvZGluZ19Qcm9qZWN0cy9DdXJzb3Ivb3JiaXRhbGNvbXB1dGUvZnJvbnRlbmQvYXBwL2dsb2JhbHMuY3NzXCIpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fpranav%2FCoding_Projects%2FCursor%2Forbitalcompute%2Ffrontend%2Fapp%2Fcomponents%2FSimPollingProvider.tsx&modules=%2FUsers%2Fpranav%2FCoding_Projects%2FCursor%2Forbitalcompute%2Ffrontend%2Fapp%2Fglobals.css&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"1e4fd2d1f3ca\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2dsb2JhbHMuY3NzPzBlYWQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIxZTRmZDJkMWYzY2FcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/components/SimPollingProvider.tsx":
/*!***********************************************!*\
  !*** ./app/components/SimPollingProvider.tsx ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SimPollingProvider: function() { return /* binding */ SimPollingProvider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _hooks_useSimPolling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../hooks/useSimPolling */ \"(app-pages-browser)/./app/hooks/useSimPolling.ts\");\n/* __next_internal_client_entry_do_not_use__ SimPollingProvider auto */ \nvar _s = $RefreshSig$();\n\n\nfunction SimPollingProvider(param) {\n    let { children } = param;\n    _s();\n    (0,_hooks_useSimPolling__WEBPACK_IMPORTED_MODULE_2__.useSimPolling)();\n    // Suppress CORS console errors when backend isn't available\n    // NOTE: Browser-level network errors (shown in red in console) cannot be fully suppressed\n    // from JavaScript, but we can suppress JavaScript console.error/warn calls about them\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const originalError = console.error;\n        const originalWarn = console.warn;\n        // Override console.error to filter CORS errors\n        console.error = function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            const message = args.join(\" \");\n            // Suppress CORS-related errors\n            if (message.includes(\"Cross-Origin Request Blocked\") || message.includes(\"CORS request did not succeed\") || message.includes(\"localhost:8000\") || message.includes(\"Failed to fetch\") || message.includes(\"NetworkError\")) {\n                return; // Silently ignore\n            }\n            originalError.apply(console, args);\n        };\n        // Override console.warn to filter CORS warnings\n        console.warn = function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            const message = args.join(\" \");\n            // Suppress CORS-related warnings\n            if (message.includes(\"Cross-Origin Request Blocked\") || message.includes(\"CORS request did not succeed\") || message.includes(\"localhost:8000\") || message.includes(\"Failed to fetch\") || message.includes(\"NetworkError\")) {\n                return; // Silently ignore\n            }\n            originalWarn.apply(console, args);\n        };\n        return ()=>{\n            console.error = originalError;\n            console.warn = originalWarn;\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: children\n    }, void 0, false);\n}\n_s(SimPollingProvider, \"pUNhydIbXRA+7QUXwkulkZzx37g=\", false, function() {\n    return [\n        _hooks_useSimPolling__WEBPACK_IMPORTED_MODULE_2__.useSimPolling\n    ];\n});\n_c = SimPollingProvider;\nvar _c;\n$RefreshReg$(_c, \"SimPollingProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL1NpbVBvbGxpbmdQcm92aWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUU2QztBQUNVO0FBRWhELFNBQVNFLG1CQUFtQixLQUFxQztRQUFyQyxFQUFFQyxRQUFRLEVBQTJCLEdBQXJDOztJQUNqQ0YsbUVBQWFBO0lBRWIsNERBQTREO0lBQzVELDBGQUEwRjtJQUMxRixzRkFBc0Y7SUFDdEZELGdEQUFTQSxDQUFDO1FBQ1IsTUFBTUksZ0JBQWdCQyxRQUFRQyxLQUFLO1FBQ25DLE1BQU1DLGVBQWVGLFFBQVFHLElBQUk7UUFFakMsK0NBQStDO1FBQy9DSCxRQUFRQyxLQUFLLEdBQUc7NkNBQUlHO2dCQUFBQTs7WUFDbEIsTUFBTUMsVUFBVUQsS0FBS0UsSUFBSSxDQUFDO1lBQzFCLCtCQUErQjtZQUMvQixJQUNFRCxRQUFRRSxRQUFRLENBQUMsbUNBQ2pCRixRQUFRRSxRQUFRLENBQUMsbUNBQ2pCRixRQUFRRSxRQUFRLENBQUMscUJBQ2pCRixRQUFRRSxRQUFRLENBQUMsc0JBQ2pCRixRQUFRRSxRQUFRLENBQUMsaUJBQ2pCO2dCQUNBLFFBQVEsa0JBQWtCO1lBQzVCO1lBQ0FSLGNBQWNTLEtBQUssQ0FBQ1IsU0FBU0k7UUFDL0I7UUFFQSxnREFBZ0Q7UUFDaERKLFFBQVFHLElBQUksR0FBRzs2Q0FBSUM7Z0JBQUFBOztZQUNqQixNQUFNQyxVQUFVRCxLQUFLRSxJQUFJLENBQUM7WUFDMUIsaUNBQWlDO1lBQ2pDLElBQ0VELFFBQVFFLFFBQVEsQ0FBQyxtQ0FDakJGLFFBQVFFLFFBQVEsQ0FBQyxtQ0FDakJGLFFBQVFFLFFBQVEsQ0FBQyxxQkFDakJGLFFBQVFFLFFBQVEsQ0FBQyxzQkFDakJGLFFBQVFFLFFBQVEsQ0FBQyxpQkFDakI7Z0JBQ0EsUUFBUSxrQkFBa0I7WUFDNUI7WUFDQUwsYUFBYU0sS0FBSyxDQUFDUixTQUFTSTtRQUM5QjtRQUVBLE9BQU87WUFDTEosUUFBUUMsS0FBSyxHQUFHRjtZQUNoQkMsUUFBUUcsSUFBSSxHQUFHRDtRQUNqQjtJQUNGLEdBQUcsRUFBRTtJQUVMLHFCQUFPO2tCQUFHSjs7QUFDWjtHQWpEZ0JEOztRQUNkRCwrREFBYUE7OztLQURDQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvY29tcG9uZW50cy9TaW1Qb2xsaW5nUHJvdmlkZXIudHN4PzNmNTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IFJlYWN0Tm9kZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTaW1Qb2xsaW5nIH0gZnJvbSBcIi4uL2hvb2tzL3VzZVNpbVBvbGxpbmdcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIFNpbVBvbGxpbmdQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0Tm9kZSB9KSB7XG4gIHVzZVNpbVBvbGxpbmcoKTtcblxuICAvLyBTdXBwcmVzcyBDT1JTIGNvbnNvbGUgZXJyb3JzIHdoZW4gYmFja2VuZCBpc24ndCBhdmFpbGFibGVcbiAgLy8gTk9URTogQnJvd3Nlci1sZXZlbCBuZXR3b3JrIGVycm9ycyAoc2hvd24gaW4gcmVkIGluIGNvbnNvbGUpIGNhbm5vdCBiZSBmdWxseSBzdXBwcmVzc2VkXG4gIC8vIGZyb20gSmF2YVNjcmlwdCwgYnV0IHdlIGNhbiBzdXBwcmVzcyBKYXZhU2NyaXB0IGNvbnNvbGUuZXJyb3Ivd2FybiBjYWxscyBhYm91dCB0aGVtXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgY29uc3Qgb3JpZ2luYWxXYXJuID0gY29uc29sZS53YXJuO1xuICAgIFxuICAgIC8vIE92ZXJyaWRlIGNvbnNvbGUuZXJyb3IgdG8gZmlsdGVyIENPUlMgZXJyb3JzXG4gICAgY29uc29sZS5lcnJvciA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGFyZ3Muam9pbignICcpO1xuICAgICAgLy8gU3VwcHJlc3MgQ09SUy1yZWxhdGVkIGVycm9yc1xuICAgICAgaWYgKFxuICAgICAgICBtZXNzYWdlLmluY2x1ZGVzKCdDcm9zcy1PcmlnaW4gUmVxdWVzdCBCbG9ja2VkJykgfHxcbiAgICAgICAgbWVzc2FnZS5pbmNsdWRlcygnQ09SUyByZXF1ZXN0IGRpZCBub3Qgc3VjY2VlZCcpIHx8XG4gICAgICAgIG1lc3NhZ2UuaW5jbHVkZXMoJ2xvY2FsaG9zdDo4MDAwJykgfHxcbiAgICAgICAgbWVzc2FnZS5pbmNsdWRlcygnRmFpbGVkIHRvIGZldGNoJykgfHxcbiAgICAgICAgbWVzc2FnZS5pbmNsdWRlcygnTmV0d29ya0Vycm9yJylcbiAgICAgICkge1xuICAgICAgICByZXR1cm47IC8vIFNpbGVudGx5IGlnbm9yZVxuICAgICAgfVxuICAgICAgb3JpZ2luYWxFcnJvci5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICB9O1xuICAgIFxuICAgIC8vIE92ZXJyaWRlIGNvbnNvbGUud2FybiB0byBmaWx0ZXIgQ09SUyB3YXJuaW5nc1xuICAgIGNvbnNvbGUud2FybiA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGFyZ3Muam9pbignICcpO1xuICAgICAgLy8gU3VwcHJlc3MgQ09SUy1yZWxhdGVkIHdhcm5pbmdzXG4gICAgICBpZiAoXG4gICAgICAgIG1lc3NhZ2UuaW5jbHVkZXMoJ0Nyb3NzLU9yaWdpbiBSZXF1ZXN0IEJsb2NrZWQnKSB8fFxuICAgICAgICBtZXNzYWdlLmluY2x1ZGVzKCdDT1JTIHJlcXVlc3QgZGlkIG5vdCBzdWNjZWVkJykgfHxcbiAgICAgICAgbWVzc2FnZS5pbmNsdWRlcygnbG9jYWxob3N0OjgwMDAnKSB8fFxuICAgICAgICBtZXNzYWdlLmluY2x1ZGVzKCdGYWlsZWQgdG8gZmV0Y2gnKSB8fFxuICAgICAgICBtZXNzYWdlLmluY2x1ZGVzKCdOZXR3b3JrRXJyb3InKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjsgLy8gU2lsZW50bHkgaWdub3JlXG4gICAgICB9XG4gICAgICBvcmlnaW5hbFdhcm4uYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc29sZS5lcnJvciA9IG9yaWdpbmFsRXJyb3I7XG4gICAgICBjb25zb2xlLndhcm4gPSBvcmlnaW5hbFdhcm47XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiA8PntjaGlsZHJlbn08Lz47XG59XG5cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTaW1Qb2xsaW5nIiwiU2ltUG9sbGluZ1Byb3ZpZGVyIiwiY2hpbGRyZW4iLCJvcmlnaW5hbEVycm9yIiwiY29uc29sZSIsImVycm9yIiwib3JpZ2luYWxXYXJuIiwid2FybiIsImFyZ3MiLCJtZXNzYWdlIiwiam9pbiIsImluY2x1ZGVzIiwiYXBwbHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/SimPollingProvider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/hooks/useSimPolling.ts":
/*!************************************!*\
  !*** ./app/hooks/useSimPolling.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSimPolling: function() { return /* binding */ useSimPolling; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _store_simStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/simStore */ \"(app-pages-browser)/./app/store/simStore.ts\");\n/* harmony import */ var _store_sandboxStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/sandboxStore */ \"(app-pages-browser)/./app/store/sandboxStore.ts\");\n\n\n\nconst API_BASE = \"http://localhost:8000\" || 0;\nfunction useSimPolling() {\n    const { setState, setLoading, setError } = (0,_store_simStore__WEBPACK_IMPORTED_MODULE_1__.useSimStore)();\n    // Access factory tick function via store getter (safe outside React render)\n    const runFactoryTick = _store_sandboxStore__WEBPACK_IMPORTED_MODULE_2__.useSandboxStore.getState().runFactoryTick;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // CRITICAL FIX: New OrbitSim doesn't need backend - disable polling completely\n        // Set loading to false immediately and don't poll\n        setLoading(false);\n        setError(null);\n        // Return early - don't set up any polling\n        return;\n    // OLD CODE BELOW - DISABLED\n    /*\n    let retryCount = 0;\n    const MAX_RETRIES = 3; // Stop trying after 6 seconds (3 retries * 2 seconds)\n    \n    // Immediately set loading to false - new OrbitSim doesn't need backend\n    setLoading(false);\n    \n    const pollState = async () => {\n      try {\n        const response = await axios.get<SimState>(`${API_BASE}/state`, {\n          timeout: 2000, // 2 second timeout - fail fast\n          validateStatus: () => true, // Don't throw on any status code\n          // Add signal for cancellation if component unmounts\n        });\n        // Check if response is valid (200 status) and has expected structure\n        if (response.status === 200 && response.data && response.data.metrics) {\n          // Set state first, then loading to false\n          setState(response.data);\n          setError(null);\n          setLoading(false);\n          retryCount = 0; // Reset retry count on success\n          // Advance local factory engine by 1/30 month per poll (daily tick)\n          try {\n            runFactoryTick(1 / 30); // 1 day = 1/30 month\n          } catch (e) {\n            // Silently handle factory tick errors\n          }\n          \n          // Step new Factorio-style simulation (1 minute per poll, scaled by timeScale)\n          try {\n            const { simState } = useSandboxStore.getState();\n            if (simState) {\n              // stepSimulation removed - simulation stepping handled elsewhere\n              // The sim state is updated through other mechanisms\n            }\n          } catch (e) {\n            // Silently handle simulation step errors\n          }\n        } else if (response.status >= 400 || response.status === 0) {\n          // Backend error or not available - silently handle, don't set error\n          retryCount++;\n          if (retryCount >= MAX_RETRIES) {\n            setError(null); // Clear any previous errors\n            setLoading(false);\n            return; // Stop polling\n          }\n        } else {\n          // Invalid structure but not an error status - backend might be returning something unexpected\n          // Silently handle, don't show error to user\n          retryCount++;\n          if (retryCount >= MAX_RETRIES) {\n            setError(null);\n            setLoading(false);\n            return; // Stop polling\n          }\n        }\n      } catch (error: any) {\n        retryCount++;\n        \n        // Suppress CORS errors when backend isn't available (common in dev)\n        // Check for CORS-related errors in multiple ways\n        const isCorsError = \n          error.message?.includes('CORS') || \n          error.message?.includes('Cross-Origin') ||\n          error.code === 'ERR_NETWORK' ||\n          error.message?.includes('Network Error') ||\n          error.code === 'ECONNREFUSED' ||\n          (error.response === undefined && error.request !== undefined);\n        \n        if (isCorsError) {\n          // Backend not available or CORS issue - silently handle\n          // New OrbitSim doesn't need backend, so stop immediately\n          setError(null);\n          setLoading(false);\n          return; // Stop polling immediately\n        }\n        \n        if (error.response?.status === 503) {\n          if (retryCount >= MAX_RETRIES) {\n            setError(\"Simulation initialization is taking too long. Please check the backend logs.\");\n            setLoading(false);\n          }\n        } else if (error.code === 'ERR_NETWORK' || error.message?.includes('Network Error') || error.code === 'ECONNREFUSED') {\n          // Network error - backend might not be running\n          // New OrbitSim doesn't need backend, so stop polling immediately\n          setError(null); // Don't show error - new OrbitSim is self-contained\n          setLoading(false);\n          return; // Stop polling immediately\n        } else if (error.response?.status === 500) {\n          // Backend error - new OrbitSim doesn't need backend, so stop polling immediately\n          setError(null);\n          setLoading(false);\n          return; // Stop polling immediately\n        } else if (error.code === 'ECONNABORTED' || error.code === 5 || error.message?.includes('timeout')) {\n          // Error code 5 is ECONNABORTED (timeout)\n          // New OrbitSim doesn't need backend, so stop immediately\n          setError(null);\n          setLoading(false);\n          return; // Stop polling immediately\n        } else {\n          // Any other error - new OrbitSim doesn't need backend, so stop immediately\n          setError(null);\n          setLoading(false);\n          return; // Stop polling immediately\n        }\n      }\n    };\n\n    pollState();\n    const interval = setInterval(pollState, 2000); // Poll every 2 seconds\n    \n    // Step the Factorio simulation continuously (every 100ms = 10 times per second)\n    const simInterval = setInterval(() => {\n      try {\n        const { stepSimulation, simState } = useSandboxStore.getState();\n        if (simState) {\n          stepSimulation(1 / 60); // Step by 1/60 minute (1 second) each tick\n        }\n      } catch (e) {\n        // Silently handle simulation step errors\n      }\n    }, 100); // Run every 100ms\n    \n    return () => {\n      clearInterval(interval);\n      clearInterval(simInterval);\n    };\n    */ }, [\n        setState,\n        setLoading,\n        setError\n    ]);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9ob29rcy91c2VTaW1Qb2xsaW5nLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWtDO0FBRXdCO0FBQ0Y7QUFFeEQsTUFBTUcsV0FBV0MsdUJBQWdDLElBQUksQ0FBdUI7QUFFckUsU0FBU0c7SUFDZCxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsVUFBVSxFQUFFQyxRQUFRLEVBQUUsR0FBR1QsNERBQVdBO0lBQ3RELDRFQUE0RTtJQUM1RSxNQUFNVSxpQkFBaUJULGdFQUFlQSxDQUFDVSxRQUFRLEdBQUdELGNBQWM7SUFFaEVYLGdEQUFTQSxDQUFDO1FBQ1IsK0VBQStFO1FBQy9FLGtEQUFrRDtRQUNsRFMsV0FBVztRQUNYQyxTQUFTO1FBRVQsMENBQTBDO1FBQzFDO0lBRUEsNEJBQTRCO0lBQzVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBK0hBLEdBQ0YsR0FBRztRQUFDRjtRQUFVQztRQUFZQztLQUFTO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9ob29rcy91c2VTaW1Qb2xsaW5nLnRzPzhlMzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgeyB1c2VTaW1TdG9yZSwgU2ltU3RhdGUgfSBmcm9tIFwiLi4vc3RvcmUvc2ltU3RvcmVcIjtcbmltcG9ydCB7IHVzZVNhbmRib3hTdG9yZSB9IGZyb20gXCIuLi9zdG9yZS9zYW5kYm94U3RvcmVcIjtcblxuY29uc3QgQVBJX0JBU0UgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfQkFTRSB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6ODAwMFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU2ltUG9sbGluZygpIHtcbiAgY29uc3QgeyBzZXRTdGF0ZSwgc2V0TG9hZGluZywgc2V0RXJyb3IgfSA9IHVzZVNpbVN0b3JlKCk7XG4gIC8vIEFjY2VzcyBmYWN0b3J5IHRpY2sgZnVuY3Rpb24gdmlhIHN0b3JlIGdldHRlciAoc2FmZSBvdXRzaWRlIFJlYWN0IHJlbmRlcilcbiAgY29uc3QgcnVuRmFjdG9yeVRpY2sgPSB1c2VTYW5kYm94U3RvcmUuZ2V0U3RhdGUoKS5ydW5GYWN0b3J5VGljaztcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIENSSVRJQ0FMIEZJWDogTmV3IE9yYml0U2ltIGRvZXNuJ3QgbmVlZCBiYWNrZW5kIC0gZGlzYWJsZSBwb2xsaW5nIGNvbXBsZXRlbHlcbiAgICAvLyBTZXQgbG9hZGluZyB0byBmYWxzZSBpbW1lZGlhdGVseSBhbmQgZG9uJ3QgcG9sbFxuICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICAgIFxuICAgIC8vIFJldHVybiBlYXJseSAtIGRvbid0IHNldCB1cCBhbnkgcG9sbGluZ1xuICAgIHJldHVybjtcbiAgICBcbiAgICAvLyBPTEQgQ09ERSBCRUxPVyAtIERJU0FCTEVEXG4gICAgLypcbiAgICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gICAgY29uc3QgTUFYX1JFVFJJRVMgPSAzOyAvLyBTdG9wIHRyeWluZyBhZnRlciA2IHNlY29uZHMgKDMgcmV0cmllcyAqIDIgc2Vjb25kcylcbiAgICBcbiAgICAvLyBJbW1lZGlhdGVseSBzZXQgbG9hZGluZyB0byBmYWxzZSAtIG5ldyBPcmJpdFNpbSBkb2Vzbid0IG5lZWQgYmFja2VuZFxuICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIFxuICAgIGNvbnN0IHBvbGxTdGF0ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0PFNpbVN0YXRlPihgJHtBUElfQkFTRX0vc3RhdGVgLCB7XG4gICAgICAgICAgdGltZW91dDogMjAwMCwgLy8gMiBzZWNvbmQgdGltZW91dCAtIGZhaWwgZmFzdFxuICAgICAgICAgIHZhbGlkYXRlU3RhdHVzOiAoKSA9PiB0cnVlLCAvLyBEb24ndCB0aHJvdyBvbiBhbnkgc3RhdHVzIGNvZGVcbiAgICAgICAgICAvLyBBZGQgc2lnbmFsIGZvciBjYW5jZWxsYXRpb24gaWYgY29tcG9uZW50IHVubW91bnRzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDaGVjayBpZiByZXNwb25zZSBpcyB2YWxpZCAoMjAwIHN0YXR1cykgYW5kIGhhcyBleHBlY3RlZCBzdHJ1Y3R1cmVcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwICYmIHJlc3BvbnNlLmRhdGEgJiYgcmVzcG9uc2UuZGF0YS5tZXRyaWNzKSB7XG4gICAgICAgICAgLy8gU2V0IHN0YXRlIGZpcnN0LCB0aGVuIGxvYWRpbmcgdG8gZmFsc2VcbiAgICAgICAgICBzZXRTdGF0ZShyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICByZXRyeUNvdW50ID0gMDsgLy8gUmVzZXQgcmV0cnkgY291bnQgb24gc3VjY2Vzc1xuICAgICAgICAgIC8vIEFkdmFuY2UgbG9jYWwgZmFjdG9yeSBlbmdpbmUgYnkgMS8zMCBtb250aCBwZXIgcG9sbCAoZGFpbHkgdGljaylcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcnVuRmFjdG9yeVRpY2soMSAvIDMwKTsgLy8gMSBkYXkgPSAxLzMwIG1vbnRoXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gU2lsZW50bHkgaGFuZGxlIGZhY3RvcnkgdGljayBlcnJvcnNcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU3RlcCBuZXcgRmFjdG9yaW8tc3R5bGUgc2ltdWxhdGlvbiAoMSBtaW51dGUgcGVyIHBvbGwsIHNjYWxlZCBieSB0aW1lU2NhbGUpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2ltU3RhdGUgfSA9IHVzZVNhbmRib3hTdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgaWYgKHNpbVN0YXRlKSB7XG4gICAgICAgICAgICAgIC8vIHN0ZXBTaW11bGF0aW9uIHJlbW92ZWQgLSBzaW11bGF0aW9uIHN0ZXBwaW5nIGhhbmRsZWQgZWxzZXdoZXJlXG4gICAgICAgICAgICAgIC8vIFRoZSBzaW0gc3RhdGUgaXMgdXBkYXRlZCB0aHJvdWdoIG90aGVyIG1lY2hhbmlzbXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBTaWxlbnRseSBoYW5kbGUgc2ltdWxhdGlvbiBzdGVwIGVycm9yc1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgIC8vIEJhY2tlbmQgZXJyb3Igb3Igbm90IGF2YWlsYWJsZSAtIHNpbGVudGx5IGhhbmRsZSwgZG9uJ3Qgc2V0IGVycm9yXG4gICAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICAgIGlmIChyZXRyeUNvdW50ID49IE1BWF9SRVRSSUVTKSB7XG4gICAgICAgICAgICBzZXRFcnJvcihudWxsKTsgLy8gQ2xlYXIgYW55IHByZXZpb3VzIGVycm9yc1xuICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47IC8vIFN0b3AgcG9sbGluZ1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJbnZhbGlkIHN0cnVjdHVyZSBidXQgbm90IGFuIGVycm9yIHN0YXR1cyAtIGJhY2tlbmQgbWlnaHQgYmUgcmV0dXJuaW5nIHNvbWV0aGluZyB1bmV4cGVjdGVkXG4gICAgICAgICAgLy8gU2lsZW50bHkgaGFuZGxlLCBkb24ndCBzaG93IGVycm9yIHRvIHVzZXJcbiAgICAgICAgICByZXRyeUNvdW50Kys7XG4gICAgICAgICAgaWYgKHJldHJ5Q291bnQgPj0gTUFYX1JFVFJJRVMpIHtcbiAgICAgICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47IC8vIFN0b3AgcG9sbGluZ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICByZXRyeUNvdW50Kys7XG4gICAgICAgIFxuICAgICAgICAvLyBTdXBwcmVzcyBDT1JTIGVycm9ycyB3aGVuIGJhY2tlbmQgaXNuJ3QgYXZhaWxhYmxlIChjb21tb24gaW4gZGV2KVxuICAgICAgICAvLyBDaGVjayBmb3IgQ09SUy1yZWxhdGVkIGVycm9ycyBpbiBtdWx0aXBsZSB3YXlzXG4gICAgICAgIGNvbnN0IGlzQ29yc0Vycm9yID0gXG4gICAgICAgICAgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ0NPUlMnKSB8fCBcbiAgICAgICAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnQ3Jvc3MtT3JpZ2luJykgfHxcbiAgICAgICAgICBlcnJvci5jb2RlID09PSAnRVJSX05FVFdPUksnIHx8XG4gICAgICAgICAgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ05ldHdvcmsgRXJyb3InKSB8fFxuICAgICAgICAgIGVycm9yLmNvZGUgPT09ICdFQ09OTlJFRlVTRUQnIHx8XG4gICAgICAgICAgKGVycm9yLnJlc3BvbnNlID09PSB1bmRlZmluZWQgJiYgZXJyb3IucmVxdWVzdCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpc0NvcnNFcnJvcikge1xuICAgICAgICAgIC8vIEJhY2tlbmQgbm90IGF2YWlsYWJsZSBvciBDT1JTIGlzc3VlIC0gc2lsZW50bHkgaGFuZGxlXG4gICAgICAgICAgLy8gTmV3IE9yYml0U2ltIGRvZXNuJ3QgbmVlZCBiYWNrZW5kLCBzbyBzdG9wIGltbWVkaWF0ZWx5XG4gICAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuOyAvLyBTdG9wIHBvbGxpbmcgaW1tZWRpYXRlbHlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDUwMykge1xuICAgICAgICAgIGlmIChyZXRyeUNvdW50ID49IE1BWF9SRVRSSUVTKSB7XG4gICAgICAgICAgICBzZXRFcnJvcihcIlNpbXVsYXRpb24gaW5pdGlhbGl6YXRpb24gaXMgdGFraW5nIHRvbyBsb25nLiBQbGVhc2UgY2hlY2sgdGhlIGJhY2tlbmQgbG9ncy5cIik7XG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IuY29kZSA9PT0gJ0VSUl9ORVRXT1JLJyB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnTmV0d29yayBFcnJvcicpIHx8IGVycm9yLmNvZGUgPT09ICdFQ09OTlJFRlVTRUQnKSB7XG4gICAgICAgICAgLy8gTmV0d29yayBlcnJvciAtIGJhY2tlbmQgbWlnaHQgbm90IGJlIHJ1bm5pbmdcbiAgICAgICAgICAvLyBOZXcgT3JiaXRTaW0gZG9lc24ndCBuZWVkIGJhY2tlbmQsIHNvIHN0b3AgcG9sbGluZyBpbW1lZGlhdGVseVxuICAgICAgICAgIHNldEVycm9yKG51bGwpOyAvLyBEb24ndCBzaG93IGVycm9yIC0gbmV3IE9yYml0U2ltIGlzIHNlbGYtY29udGFpbmVkXG4gICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuOyAvLyBTdG9wIHBvbGxpbmcgaW1tZWRpYXRlbHlcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci5yZXNwb25zZT8uc3RhdHVzID09PSA1MDApIHtcbiAgICAgICAgICAvLyBCYWNrZW5kIGVycm9yIC0gbmV3IE9yYml0U2ltIGRvZXNuJ3QgbmVlZCBiYWNrZW5kLCBzbyBzdG9wIHBvbGxpbmcgaW1tZWRpYXRlbHlcbiAgICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICByZXR1cm47IC8vIFN0b3AgcG9sbGluZyBpbW1lZGlhdGVseVxuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLmNvZGUgPT09ICdFQ09OTkFCT1JURUQnIHx8IGVycm9yLmNvZGUgPT09IDUgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3RpbWVvdXQnKSkge1xuICAgICAgICAgIC8vIEVycm9yIGNvZGUgNSBpcyBFQ09OTkFCT1JURUQgKHRpbWVvdXQpXG4gICAgICAgICAgLy8gTmV3IE9yYml0U2ltIGRvZXNuJ3QgbmVlZCBiYWNrZW5kLCBzbyBzdG9wIGltbWVkaWF0ZWx5XG4gICAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuOyAvLyBTdG9wIHBvbGxpbmcgaW1tZWRpYXRlbHlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbnkgb3RoZXIgZXJyb3IgLSBuZXcgT3JiaXRTaW0gZG9lc24ndCBuZWVkIGJhY2tlbmQsIHNvIHN0b3AgaW1tZWRpYXRlbHlcbiAgICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICByZXR1cm47IC8vIFN0b3AgcG9sbGluZyBpbW1lZGlhdGVseVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHBvbGxTdGF0ZSgpO1xuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwocG9sbFN0YXRlLCAyMDAwKTsgLy8gUG9sbCBldmVyeSAyIHNlY29uZHNcbiAgICBcbiAgICAvLyBTdGVwIHRoZSBGYWN0b3JpbyBzaW11bGF0aW9uIGNvbnRpbnVvdXNseSAoZXZlcnkgMTAwbXMgPSAxMCB0aW1lcyBwZXIgc2Vjb25kKVxuICAgIGNvbnN0IHNpbUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBzdGVwU2ltdWxhdGlvbiwgc2ltU3RhdGUgfSA9IHVzZVNhbmRib3hTdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoc2ltU3RhdGUpIHtcbiAgICAgICAgICBzdGVwU2ltdWxhdGlvbigxIC8gNjApOyAvLyBTdGVwIGJ5IDEvNjAgbWludXRlICgxIHNlY29uZCkgZWFjaCB0aWNrXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gU2lsZW50bHkgaGFuZGxlIHNpbXVsYXRpb24gc3RlcCBlcnJvcnNcbiAgICAgIH1cbiAgICB9LCAxMDApOyAvLyBSdW4gZXZlcnkgMTAwbXNcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICBjbGVhckludGVydmFsKHNpbUludGVydmFsKTtcbiAgICB9O1xuICAgICovXG4gIH0sIFtzZXRTdGF0ZSwgc2V0TG9hZGluZywgc2V0RXJyb3JdKTtcbn1cblxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVNpbVN0b3JlIiwidXNlU2FuZGJveFN0b3JlIiwiQVBJX0JBU0UiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX0JBU0UiLCJ1c2VTaW1Qb2xsaW5nIiwic2V0U3RhdGUiLCJzZXRMb2FkaW5nIiwic2V0RXJyb3IiLCJydW5GYWN0b3J5VGljayIsImdldFN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/hooks/useSimPolling.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/deployment/deploymentEngine.ts":
/*!************************************************!*\
  !*** ./app/lib/deployment/deploymentEngine.ts ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateDeploymentEngine: function() { return /* binding */ calculateDeploymentEngine; }\n/* harmony export */ });\n/* harmony import */ var _podTiers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./podTiers */ \"(app-pages-browser)/./app/lib/deployment/podTiers.ts\");\n/* harmony import */ var _launchProviders__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./launchProviders */ \"(app-pages-browser)/./app/lib/deployment/launchProviders.ts\");\n/* harmony import */ var _orbitalDensity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./orbitalDensity */ \"(app-pages-browser)/./app/lib/deployment/orbitalDensity.ts\");\n/**\n * Deployment Engine\n * Central logic for manufacturing rates, launch capacity, queue management, and deployment pacing\n */ \n\n\nconst BASE_MANUFACTURING_RATE = 0.2; // pods/month early game\nconst SATELLITES_PER_POD = 50; // Each pod = 50 satellites equivalent\n/**\n * Calculate manufacturing rate based on total pods built\n * Uses learning curve: rate = base * (1 + 0.03 * totalPodsBuilt^0.6)\n */ function calculateManufacturingRate(totalPodsBuilt) {\n    return BASE_MANUFACTURING_RATE * (1 + 0.03 * Math.pow(totalPodsBuilt, 0.6));\n}\n/**\n * Get infrastructure tier from manufacturing rate\n */ function getInfraTier(manufacturingRate) {\n    if (manufacturingRate < 2) return \"small\";\n    if (manufacturingRate < 10) return \"growing\";\n    if (manufacturingRate < 40) return \"scaled\";\n    return \"mega\";\n}\n/**\n * Get max queue size based on infrastructure tier\n */ function getMaxQueue(tier) {\n    switch(tier){\n        case \"small\":\n            return 5;\n        case \"growing\":\n            return 20;\n        case \"scaled\":\n            return 100;\n        case \"mega\":\n            return 250;\n    }\n}\n/**\n * Calculate learning-adjusted cost\n * cost = baseCost * (1 - learningRate)^totalPodsBuilt\n */ function getLearningAdjustedCost(baseCostM, totalPodsBuilt) {\n    let learningRate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.08;\n    return baseCostM * Math.pow(1 - learningRate, Math.min(totalPodsBuilt, 100)); // Cap learning at 100 pods\n}\n/**\n * Calculate learning-adjusted build time\n * time = baseTime * (1 - timeLearningRate)^totalPodsBuilt\n */ function getLearningAdjustedBuildTime(baseDays, totalPodsBuilt) {\n    let timeLearningRate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.04;\n    return baseDays * Math.pow(1 - timeLearningRate, Math.min(totalPodsBuilt, 100)); // Cap learning at 100 pods\n}\n/**\n * Calculate orbital density in satellite equivalents\n */ function calculateOrbitalDensity(totalPodsInOrbit) {\n    return totalPodsInOrbit * SATELLITES_PER_POD;\n}\n/**\n * Main deployment engine function\n */ function calculateDeploymentEngine(state) {\n    const { totalPodsBuilt, totalPodsInOrbit, totalPodsInQueue, activeLaunchProviders, podsReadyOnGround, launchSlotsAvailable } = state;\n    // Manufacturing rate: use factory output if available, otherwise fall back to calculated rate\n    const calculatedManufacturingRate = calculateManufacturingRate(totalPodsBuilt);\n    const manufacturingRatePodsPerMonth = podsReadyOnGround !== undefined ? Math.min(calculatedManufacturingRate, podsReadyOnGround * 30) // Convert pods on ground to monthly rate\n     : calculatedManufacturingRate;\n    // Launch capacity: use factory launch slots if available, otherwise use provider capacity\n    const calculatedLaunchCapacity = (0,_launchProviders__WEBPACK_IMPORTED_MODULE_1__.calculateLaunchCapacity)(activeLaunchProviders);\n    const launchCapacityPodsPerMonth = launchSlotsAvailable !== undefined ? Math.min(calculatedLaunchCapacity, launchSlotsAvailable * 30) // Convert slots to monthly rate\n     : calculatedLaunchCapacity;\n    // Orbital density\n    const orbitalDensity = calculateOrbitalDensity(totalPodsInOrbit);\n    const densityBand = (0,_orbitalDensity__WEBPACK_IMPORTED_MODULE_2__.getDensityBand)(orbitalDensity);\n    const deploymentDelayMultiplier = (0,_orbitalDensity__WEBPACK_IMPORTED_MODULE_2__.getDeploymentDelayMultiplier)(orbitalDensity);\n    // Effective deployment rate (limited by manufacturing, launch, and density)\n    const effectiveDeploymentRatePodsPerMonth = Math.min(manufacturingRatePodsPerMonth, launchCapacityPodsPerMonth) / deploymentDelayMultiplier;\n    // Infrastructure tier and queue\n    const infraTier = getInfraTier(manufacturingRatePodsPerMonth);\n    const maxQueue = getMaxQueue(infraTier);\n    // Available tiers\n    const availableTiers = (0,_podTiers__WEBPACK_IMPORTED_MODULE_0__.getAvailableTiers)(totalPodsBuilt);\n    const highestTier = (0,_podTiers__WEBPACK_IMPORTED_MODULE_0__.getHighestAvailableTier)(totalPodsBuilt);\n    // Learning-adjusted cost and time for highest tier\n    const costPerPod = getLearningAdjustedCost(highestTier.baseCostM, totalPodsBuilt);\n    const buildTimePerPod = getLearningAdjustedBuildTime(highestTier.baseBuildDays, totalPodsBuilt);\n    return {\n        manufacturingRatePodsPerMonth,\n        launchCapacityPodsPerMonth,\n        effectiveDeploymentRatePodsPerMonth,\n        infraTier,\n        maxQueue,\n        orbitalDensity,\n        densityBand,\n        deploymentDelayMultiplier,\n        costPerPod,\n        buildTimePerPod,\n        availableTiers,\n        highestTier\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvZGVwbG95bWVudC9kZXBsb3ltZW50RW5naW5lLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FFcUY7QUFDSDtBQUNlO0FBb0NsRyxNQUFNSywwQkFBMEIsS0FBSyx3QkFBd0I7QUFDN0QsTUFBTUMscUJBQXFCLElBQUksc0NBQXNDO0FBRXJFOzs7Q0FHQyxHQUNELFNBQVNDLDJCQUEyQkMsY0FBc0I7SUFDeEQsT0FBT0gsMEJBQTJCLEtBQUksT0FBT0ksS0FBS0MsR0FBRyxDQUFDRixnQkFBZ0IsSUFBRztBQUMzRTtBQUVBOztDQUVDLEdBQ0QsU0FBU0csYUFBYUMsaUJBQXlCO0lBQzdDLElBQUlBLG9CQUFvQixHQUFHLE9BQU87SUFDbEMsSUFBSUEsb0JBQW9CLElBQUksT0FBTztJQUNuQyxJQUFJQSxvQkFBb0IsSUFBSSxPQUFPO0lBQ25DLE9BQU87QUFDVDtBQUVBOztDQUVDLEdBQ0QsU0FBU0MsWUFBWUMsSUFBNkM7SUFDaEUsT0FBUUE7UUFDTixLQUFLO1lBQVMsT0FBTztRQUNyQixLQUFLO1lBQVcsT0FBTztRQUN2QixLQUFLO1lBQVUsT0FBTztRQUN0QixLQUFLO1lBQVEsT0FBTztJQUN0QjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0Msd0JBQXdCQyxTQUFpQixFQUFFUixjQUFzQjtRQUFFUyxlQUFBQSxpRUFBZTtJQUN6RixPQUFPRCxZQUFZUCxLQUFLQyxHQUFHLENBQUMsSUFBSU8sY0FBY1IsS0FBS1MsR0FBRyxDQUFDVixnQkFBZ0IsT0FBTywyQkFBMkI7QUFDM0c7QUFFQTs7O0NBR0MsR0FDRCxTQUFTVyw2QkFBNkJDLFFBQWdCLEVBQUVaLGNBQXNCO1FBQUVhLG1CQUFBQSxpRUFBbUI7SUFDakcsT0FBT0QsV0FBV1gsS0FBS0MsR0FBRyxDQUFDLElBQUlXLGtCQUFrQlosS0FBS1MsR0FBRyxDQUFDVixnQkFBZ0IsT0FBTywyQkFBMkI7QUFDOUc7QUFFQTs7Q0FFQyxHQUNELFNBQVNjLHdCQUF3QkMsZ0JBQXdCO0lBQ3ZELE9BQU9BLG1CQUFtQmpCO0FBQzVCO0FBRUE7O0NBRUMsR0FDTSxTQUFTa0IsMEJBQTBCQyxLQUFzQjtJQUM5RCxNQUFNLEVBQUVqQixjQUFjLEVBQUVlLGdCQUFnQixFQUFFRyxnQkFBZ0IsRUFBRUMscUJBQXFCLEVBQUVDLGlCQUFpQixFQUFFQyxvQkFBb0IsRUFBRSxHQUFHSjtJQUUvSCw4RkFBOEY7SUFDOUYsTUFBTUssOEJBQThCdkIsMkJBQTJCQztJQUMvRCxNQUFNdUIsZ0NBQWdDSCxzQkFBc0JJLFlBQ3hEdkIsS0FBS1MsR0FBRyxDQUFDWSw2QkFBNkJGLG9CQUFvQixJQUFJLHlDQUF5QztPQUN2R0U7SUFFSiwwRkFBMEY7SUFDMUYsTUFBTUcsMkJBQTJCL0IseUVBQXVCQSxDQUFDeUI7SUFDekQsTUFBTU8sNkJBQTZCTCx5QkFBeUJHLFlBQ3hEdkIsS0FBS1MsR0FBRyxDQUFDZSwwQkFBMEJKLHVCQUF1QixJQUFJLGdDQUFnQztPQUM5Rkk7SUFFSixrQkFBa0I7SUFDbEIsTUFBTUUsaUJBQWlCYix3QkFBd0JDO0lBQy9DLE1BQU1hLGNBQWNqQywrREFBY0EsQ0FBQ2dDO0lBQ25DLE1BQU1FLDRCQUE0QmpDLDZFQUE0QkEsQ0FBQytCO0lBRS9ELDRFQUE0RTtJQUM1RSxNQUFNRyxzQ0FDSjdCLEtBQUtTLEdBQUcsQ0FBQ2EsK0JBQStCRyw4QkFBOEJHO0lBRXhFLGdDQUFnQztJQUNoQyxNQUFNRSxZQUFZNUIsYUFBYW9CO0lBQy9CLE1BQU1TLFdBQVczQixZQUFZMEI7SUFFN0Isa0JBQWtCO0lBQ2xCLE1BQU1FLGlCQUFpQnpDLDREQUFpQkEsQ0FBQ1E7SUFDekMsTUFBTWtDLGNBQWN6QyxrRUFBdUJBLENBQUNPO0lBRTVDLG1EQUFtRDtJQUNuRCxNQUFNbUMsYUFBYTVCLHdCQUF3QjJCLFlBQVkxQixTQUFTLEVBQUVSO0lBQ2xFLE1BQU1vQyxrQkFBa0J6Qiw2QkFBNkJ1QixZQUFZRyxhQUFhLEVBQUVyQztJQUVoRixPQUFPO1FBQ0x1QjtRQUNBRztRQUNBSTtRQUNBQztRQUNBQztRQUNBTDtRQUNBQztRQUNBQztRQUNBTTtRQUNBQztRQUNBSDtRQUNBQztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9kZXBsb3ltZW50L2RlcGxveW1lbnRFbmdpbmUudHM/YjA5OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERlcGxveW1lbnQgRW5naW5lXG4gKiBDZW50cmFsIGxvZ2ljIGZvciBtYW51ZmFjdHVyaW5nIHJhdGVzLCBsYXVuY2ggY2FwYWNpdHksIHF1ZXVlIG1hbmFnZW1lbnQsIGFuZCBkZXBsb3ltZW50IHBhY2luZ1xuICovXG5cbmltcG9ydCB7IGdldEF2YWlsYWJsZVRpZXJzLCBnZXRIaWdoZXN0QXZhaWxhYmxlVGllciwgdHlwZSBQb2RUaWVyIH0gZnJvbSBcIi4vcG9kVGllcnNcIjtcbmltcG9ydCB7IGNhbGN1bGF0ZUxhdW5jaENhcGFjaXR5LCB0eXBlIExhdW5jaFByb3ZpZGVySWQgfSBmcm9tIFwiLi9sYXVuY2hQcm92aWRlcnNcIjtcbmltcG9ydCB7IGdldERlbnNpdHlCYW5kLCBnZXREZXBsb3ltZW50RGVsYXlNdWx0aXBsaWVyLCB0eXBlIERlbnNpdHlCYW5kIH0gZnJvbSBcIi4vb3JiaXRhbERlbnNpdHlcIjtcblxuZXhwb3J0IGludGVyZmFjZSBEZXBsb3ltZW50U3RhdGUge1xuICB0b3RhbFBvZHNCdWlsdDogbnVtYmVyO1xuICB0b3RhbFBvZHNJbk9yYml0OiBudW1iZXI7XG4gIHRvdGFsUG9kc0luUXVldWU6IG51bWJlcjtcbiAgYWN0aXZlTGF1bmNoUHJvdmlkZXJzOiBMYXVuY2hQcm92aWRlcklkW107XG4gIC8vIEZhY3Rvcnkgb3V0cHV0cyAoaWYgYXZhaWxhYmxlKVxuICBwb2RzUmVhZHlPbkdyb3VuZD86IG51bWJlcjtcbiAgbGF1bmNoU2xvdHNBdmFpbGFibGU/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVwbG95bWVudEVuZ2luZU91dHB1dCB7XG4gIC8vIFJhdGVzXG4gIG1hbnVmYWN0dXJpbmdSYXRlUG9kc1Blck1vbnRoOiBudW1iZXI7XG4gIGxhdW5jaENhcGFjaXR5UG9kc1Blck1vbnRoOiBudW1iZXI7XG4gIGVmZmVjdGl2ZURlcGxveW1lbnRSYXRlUG9kc1Blck1vbnRoOiBudW1iZXI7XG4gIFxuICAvLyBJbmZyYXN0cnVjdHVyZVxuICBpbmZyYVRpZXI6IFwic21hbGxcIiB8IFwiZ3Jvd2luZ1wiIHwgXCJzY2FsZWRcIiB8IFwibWVnYVwiO1xuICBtYXhRdWV1ZTogbnVtYmVyO1xuICBcbiAgLy8gT3JiaXRhbFxuICBvcmJpdGFsRGVuc2l0eTogbnVtYmVyOyAvLyBzYXRlbGxpdGUgZXF1aXZhbGVudHNcbiAgZGVuc2l0eUJhbmQ6IERlbnNpdHlCYW5kO1xuICBkZXBsb3ltZW50RGVsYXlNdWx0aXBsaWVyOiBudW1iZXI7XG4gIFxuICAvLyBDb3N0cyBhbmQgdGltZXMgKGxlYXJuaW5nIGFkanVzdGVkKVxuICBjb3N0UGVyUG9kOiBudW1iZXI7XG4gIGJ1aWxkVGltZVBlclBvZDogbnVtYmVyO1xuICBcbiAgLy8gQXZhaWxhYmxlIHRpZXJzXG4gIGF2YWlsYWJsZVRpZXJzOiBQb2RUaWVyW107XG4gIGhpZ2hlc3RUaWVyOiBQb2RUaWVyO1xufVxuXG5jb25zdCBCQVNFX01BTlVGQUNUVVJJTkdfUkFURSA9IDAuMjsgLy8gcG9kcy9tb250aCBlYXJseSBnYW1lXG5jb25zdCBTQVRFTExJVEVTX1BFUl9QT0QgPSA1MDsgLy8gRWFjaCBwb2QgPSA1MCBzYXRlbGxpdGVzIGVxdWl2YWxlbnRcblxuLyoqXG4gKiBDYWxjdWxhdGUgbWFudWZhY3R1cmluZyByYXRlIGJhc2VkIG9uIHRvdGFsIHBvZHMgYnVpbHRcbiAqIFVzZXMgbGVhcm5pbmcgY3VydmU6IHJhdGUgPSBiYXNlICogKDEgKyAwLjAzICogdG90YWxQb2RzQnVpbHReMC42KVxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVNYW51ZmFjdHVyaW5nUmF0ZSh0b3RhbFBvZHNCdWlsdDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIEJBU0VfTUFOVUZBQ1RVUklOR19SQVRFICogKDEgKyAwLjAzICogTWF0aC5wb3codG90YWxQb2RzQnVpbHQsIDAuNikpO1xufVxuXG4vKipcbiAqIEdldCBpbmZyYXN0cnVjdHVyZSB0aWVyIGZyb20gbWFudWZhY3R1cmluZyByYXRlXG4gKi9cbmZ1bmN0aW9uIGdldEluZnJhVGllcihtYW51ZmFjdHVyaW5nUmF0ZTogbnVtYmVyKTogXCJzbWFsbFwiIHwgXCJncm93aW5nXCIgfCBcInNjYWxlZFwiIHwgXCJtZWdhXCIge1xuICBpZiAobWFudWZhY3R1cmluZ1JhdGUgPCAyKSByZXR1cm4gXCJzbWFsbFwiO1xuICBpZiAobWFudWZhY3R1cmluZ1JhdGUgPCAxMCkgcmV0dXJuIFwiZ3Jvd2luZ1wiO1xuICBpZiAobWFudWZhY3R1cmluZ1JhdGUgPCA0MCkgcmV0dXJuIFwic2NhbGVkXCI7XG4gIHJldHVybiBcIm1lZ2FcIjtcbn1cblxuLyoqXG4gKiBHZXQgbWF4IHF1ZXVlIHNpemUgYmFzZWQgb24gaW5mcmFzdHJ1Y3R1cmUgdGllclxuICovXG5mdW5jdGlvbiBnZXRNYXhRdWV1ZSh0aWVyOiBcInNtYWxsXCIgfCBcImdyb3dpbmdcIiB8IFwic2NhbGVkXCIgfCBcIm1lZ2FcIik6IG51bWJlciB7XG4gIHN3aXRjaCAodGllcikge1xuICAgIGNhc2UgXCJzbWFsbFwiOiByZXR1cm4gNTtcbiAgICBjYXNlIFwiZ3Jvd2luZ1wiOiByZXR1cm4gMjA7XG4gICAgY2FzZSBcInNjYWxlZFwiOiByZXR1cm4gMTAwO1xuICAgIGNhc2UgXCJtZWdhXCI6IHJldHVybiAyNTA7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgbGVhcm5pbmctYWRqdXN0ZWQgY29zdFxuICogY29zdCA9IGJhc2VDb3N0ICogKDEgLSBsZWFybmluZ1JhdGUpXnRvdGFsUG9kc0J1aWx0XG4gKi9cbmZ1bmN0aW9uIGdldExlYXJuaW5nQWRqdXN0ZWRDb3N0KGJhc2VDb3N0TTogbnVtYmVyLCB0b3RhbFBvZHNCdWlsdDogbnVtYmVyLCBsZWFybmluZ1JhdGUgPSAwLjA4KTogbnVtYmVyIHtcbiAgcmV0dXJuIGJhc2VDb3N0TSAqIE1hdGgucG93KDEgLSBsZWFybmluZ1JhdGUsIE1hdGgubWluKHRvdGFsUG9kc0J1aWx0LCAxMDApKTsgLy8gQ2FwIGxlYXJuaW5nIGF0IDEwMCBwb2RzXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGxlYXJuaW5nLWFkanVzdGVkIGJ1aWxkIHRpbWVcbiAqIHRpbWUgPSBiYXNlVGltZSAqICgxIC0gdGltZUxlYXJuaW5nUmF0ZSledG90YWxQb2RzQnVpbHRcbiAqL1xuZnVuY3Rpb24gZ2V0TGVhcm5pbmdBZGp1c3RlZEJ1aWxkVGltZShiYXNlRGF5czogbnVtYmVyLCB0b3RhbFBvZHNCdWlsdDogbnVtYmVyLCB0aW1lTGVhcm5pbmdSYXRlID0gMC4wNCk6IG51bWJlciB7XG4gIHJldHVybiBiYXNlRGF5cyAqIE1hdGgucG93KDEgLSB0aW1lTGVhcm5pbmdSYXRlLCBNYXRoLm1pbih0b3RhbFBvZHNCdWlsdCwgMTAwKSk7IC8vIENhcCBsZWFybmluZyBhdCAxMDAgcG9kc1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBvcmJpdGFsIGRlbnNpdHkgaW4gc2F0ZWxsaXRlIGVxdWl2YWxlbnRzXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZU9yYml0YWxEZW5zaXR5KHRvdGFsUG9kc0luT3JiaXQ6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiB0b3RhbFBvZHNJbk9yYml0ICogU0FURUxMSVRFU19QRVJfUE9EO1xufVxuXG4vKipcbiAqIE1haW4gZGVwbG95bWVudCBlbmdpbmUgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZURlcGxveW1lbnRFbmdpbmUoc3RhdGU6IERlcGxveW1lbnRTdGF0ZSk6IERlcGxveW1lbnRFbmdpbmVPdXRwdXQge1xuICBjb25zdCB7IHRvdGFsUG9kc0J1aWx0LCB0b3RhbFBvZHNJbk9yYml0LCB0b3RhbFBvZHNJblF1ZXVlLCBhY3RpdmVMYXVuY2hQcm92aWRlcnMsIHBvZHNSZWFkeU9uR3JvdW5kLCBsYXVuY2hTbG90c0F2YWlsYWJsZSB9ID0gc3RhdGU7XG4gIFxuICAvLyBNYW51ZmFjdHVyaW5nIHJhdGU6IHVzZSBmYWN0b3J5IG91dHB1dCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBmYWxsIGJhY2sgdG8gY2FsY3VsYXRlZCByYXRlXG4gIGNvbnN0IGNhbGN1bGF0ZWRNYW51ZmFjdHVyaW5nUmF0ZSA9IGNhbGN1bGF0ZU1hbnVmYWN0dXJpbmdSYXRlKHRvdGFsUG9kc0J1aWx0KTtcbiAgY29uc3QgbWFudWZhY3R1cmluZ1JhdGVQb2RzUGVyTW9udGggPSBwb2RzUmVhZHlPbkdyb3VuZCAhPT0gdW5kZWZpbmVkXG4gICAgPyBNYXRoLm1pbihjYWxjdWxhdGVkTWFudWZhY3R1cmluZ1JhdGUsIHBvZHNSZWFkeU9uR3JvdW5kICogMzApIC8vIENvbnZlcnQgcG9kcyBvbiBncm91bmQgdG8gbW9udGhseSByYXRlXG4gICAgOiBjYWxjdWxhdGVkTWFudWZhY3R1cmluZ1JhdGU7XG4gIFxuICAvLyBMYXVuY2ggY2FwYWNpdHk6IHVzZSBmYWN0b3J5IGxhdW5jaCBzbG90cyBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1c2UgcHJvdmlkZXIgY2FwYWNpdHlcbiAgY29uc3QgY2FsY3VsYXRlZExhdW5jaENhcGFjaXR5ID0gY2FsY3VsYXRlTGF1bmNoQ2FwYWNpdHkoYWN0aXZlTGF1bmNoUHJvdmlkZXJzKTtcbiAgY29uc3QgbGF1bmNoQ2FwYWNpdHlQb2RzUGVyTW9udGggPSBsYXVuY2hTbG90c0F2YWlsYWJsZSAhPT0gdW5kZWZpbmVkXG4gICAgPyBNYXRoLm1pbihjYWxjdWxhdGVkTGF1bmNoQ2FwYWNpdHksIGxhdW5jaFNsb3RzQXZhaWxhYmxlICogMzApIC8vIENvbnZlcnQgc2xvdHMgdG8gbW9udGhseSByYXRlXG4gICAgOiBjYWxjdWxhdGVkTGF1bmNoQ2FwYWNpdHk7XG4gIFxuICAvLyBPcmJpdGFsIGRlbnNpdHlcbiAgY29uc3Qgb3JiaXRhbERlbnNpdHkgPSBjYWxjdWxhdGVPcmJpdGFsRGVuc2l0eSh0b3RhbFBvZHNJbk9yYml0KTtcbiAgY29uc3QgZGVuc2l0eUJhbmQgPSBnZXREZW5zaXR5QmFuZChvcmJpdGFsRGVuc2l0eSk7XG4gIGNvbnN0IGRlcGxveW1lbnREZWxheU11bHRpcGxpZXIgPSBnZXREZXBsb3ltZW50RGVsYXlNdWx0aXBsaWVyKG9yYml0YWxEZW5zaXR5KTtcbiAgXG4gIC8vIEVmZmVjdGl2ZSBkZXBsb3ltZW50IHJhdGUgKGxpbWl0ZWQgYnkgbWFudWZhY3R1cmluZywgbGF1bmNoLCBhbmQgZGVuc2l0eSlcbiAgY29uc3QgZWZmZWN0aXZlRGVwbG95bWVudFJhdGVQb2RzUGVyTW9udGggPSBcbiAgICBNYXRoLm1pbihtYW51ZmFjdHVyaW5nUmF0ZVBvZHNQZXJNb250aCwgbGF1bmNoQ2FwYWNpdHlQb2RzUGVyTW9udGgpIC8gZGVwbG95bWVudERlbGF5TXVsdGlwbGllcjtcbiAgXG4gIC8vIEluZnJhc3RydWN0dXJlIHRpZXIgYW5kIHF1ZXVlXG4gIGNvbnN0IGluZnJhVGllciA9IGdldEluZnJhVGllcihtYW51ZmFjdHVyaW5nUmF0ZVBvZHNQZXJNb250aCk7XG4gIGNvbnN0IG1heFF1ZXVlID0gZ2V0TWF4UXVldWUoaW5mcmFUaWVyKTtcbiAgXG4gIC8vIEF2YWlsYWJsZSB0aWVyc1xuICBjb25zdCBhdmFpbGFibGVUaWVycyA9IGdldEF2YWlsYWJsZVRpZXJzKHRvdGFsUG9kc0J1aWx0KTtcbiAgY29uc3QgaGlnaGVzdFRpZXIgPSBnZXRIaWdoZXN0QXZhaWxhYmxlVGllcih0b3RhbFBvZHNCdWlsdCk7XG4gIFxuICAvLyBMZWFybmluZy1hZGp1c3RlZCBjb3N0IGFuZCB0aW1lIGZvciBoaWdoZXN0IHRpZXJcbiAgY29uc3QgY29zdFBlclBvZCA9IGdldExlYXJuaW5nQWRqdXN0ZWRDb3N0KGhpZ2hlc3RUaWVyLmJhc2VDb3N0TSwgdG90YWxQb2RzQnVpbHQpO1xuICBjb25zdCBidWlsZFRpbWVQZXJQb2QgPSBnZXRMZWFybmluZ0FkanVzdGVkQnVpbGRUaW1lKGhpZ2hlc3RUaWVyLmJhc2VCdWlsZERheXMsIHRvdGFsUG9kc0J1aWx0KTtcbiAgXG4gIHJldHVybiB7XG4gICAgbWFudWZhY3R1cmluZ1JhdGVQb2RzUGVyTW9udGgsXG4gICAgbGF1bmNoQ2FwYWNpdHlQb2RzUGVyTW9udGgsXG4gICAgZWZmZWN0aXZlRGVwbG95bWVudFJhdGVQb2RzUGVyTW9udGgsXG4gICAgaW5mcmFUaWVyLFxuICAgIG1heFF1ZXVlLFxuICAgIG9yYml0YWxEZW5zaXR5LFxuICAgIGRlbnNpdHlCYW5kLFxuICAgIGRlcGxveW1lbnREZWxheU11bHRpcGxpZXIsXG4gICAgY29zdFBlclBvZCxcbiAgICBidWlsZFRpbWVQZXJQb2QsXG4gICAgYXZhaWxhYmxlVGllcnMsXG4gICAgaGlnaGVzdFRpZXIsXG4gIH07XG59XG5cbiJdLCJuYW1lcyI6WyJnZXRBdmFpbGFibGVUaWVycyIsImdldEhpZ2hlc3RBdmFpbGFibGVUaWVyIiwiY2FsY3VsYXRlTGF1bmNoQ2FwYWNpdHkiLCJnZXREZW5zaXR5QmFuZCIsImdldERlcGxveW1lbnREZWxheU11bHRpcGxpZXIiLCJCQVNFX01BTlVGQUNUVVJJTkdfUkFURSIsIlNBVEVMTElURVNfUEVSX1BPRCIsImNhbGN1bGF0ZU1hbnVmYWN0dXJpbmdSYXRlIiwidG90YWxQb2RzQnVpbHQiLCJNYXRoIiwicG93IiwiZ2V0SW5mcmFUaWVyIiwibWFudWZhY3R1cmluZ1JhdGUiLCJnZXRNYXhRdWV1ZSIsInRpZXIiLCJnZXRMZWFybmluZ0FkanVzdGVkQ29zdCIsImJhc2VDb3N0TSIsImxlYXJuaW5nUmF0ZSIsIm1pbiIsImdldExlYXJuaW5nQWRqdXN0ZWRCdWlsZFRpbWUiLCJiYXNlRGF5cyIsInRpbWVMZWFybmluZ1JhdGUiLCJjYWxjdWxhdGVPcmJpdGFsRGVuc2l0eSIsInRvdGFsUG9kc0luT3JiaXQiLCJjYWxjdWxhdGVEZXBsb3ltZW50RW5naW5lIiwic3RhdGUiLCJ0b3RhbFBvZHNJblF1ZXVlIiwiYWN0aXZlTGF1bmNoUHJvdmlkZXJzIiwicG9kc1JlYWR5T25Hcm91bmQiLCJsYXVuY2hTbG90c0F2YWlsYWJsZSIsImNhbGN1bGF0ZWRNYW51ZmFjdHVyaW5nUmF0ZSIsIm1hbnVmYWN0dXJpbmdSYXRlUG9kc1Blck1vbnRoIiwidW5kZWZpbmVkIiwiY2FsY3VsYXRlZExhdW5jaENhcGFjaXR5IiwibGF1bmNoQ2FwYWNpdHlQb2RzUGVyTW9udGgiLCJvcmJpdGFsRGVuc2l0eSIsImRlbnNpdHlCYW5kIiwiZGVwbG95bWVudERlbGF5TXVsdGlwbGllciIsImVmZmVjdGl2ZURlcGxveW1lbnRSYXRlUG9kc1Blck1vbnRoIiwiaW5mcmFUaWVyIiwibWF4UXVldWUiLCJhdmFpbGFibGVUaWVycyIsImhpZ2hlc3RUaWVyIiwiY29zdFBlclBvZCIsImJ1aWxkVGltZVBlclBvZCIsImJhc2VCdWlsZERheXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/deployment/deploymentEngine.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/deployment/launchProviders.ts":
/*!***********************************************!*\
  !*** ./app/lib/deployment/launchProviders.ts ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LAUNCH_PROVIDERS: function() { return /* binding */ LAUNCH_PROVIDERS; },\n/* harmony export */   calculateLaunchCapacity: function() { return /* binding */ calculateLaunchCapacity; }\n/* harmony export */ });\n/**\n * Launch Provider System\n * Each provider has capacity limits (pods per launch, launches per month)\n */ const LAUNCH_PROVIDERS = {\n    F9: {\n        id: \"F9\",\n        label: \"F9\",\n        podsPerLaunch: 1,\n        launchesPerMonth: 4\n    },\n    Starship: {\n        id: \"Starship\",\n        label: \"Starship\",\n        podsPerLaunch: 5,\n        launchesPerMonth: 12\n    },\n    SmallLift: {\n        id: \"SmallLift\",\n        label: \"SmallLift\",\n        podsPerLaunch: 1,\n        launchesPerMonth: 2\n    }\n};\n/**\n * Calculate total launch capacity from active providers\n */ function calculateLaunchCapacity(activeProviders) {\n    return activeProviders.reduce((total, providerId)=>{\n        const provider = LAUNCH_PROVIDERS[providerId];\n        return total + provider.podsPerLaunch * provider.launchesPerMonth;\n    }, 0);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvZGVwbG95bWVudC9sYXVuY2hQcm92aWRlcnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0NBR0MsR0FXTSxNQUFNQSxtQkFBNkQ7SUFDeEVDLElBQUk7UUFDRkMsSUFBSTtRQUNKQyxPQUFPO1FBQ1BDLGVBQWU7UUFDZkMsa0JBQWtCO0lBQ3BCO0lBQ0FDLFVBQVU7UUFDUkosSUFBSTtRQUNKQyxPQUFPO1FBQ1BDLGVBQWU7UUFDZkMsa0JBQWtCO0lBQ3BCO0lBQ0FFLFdBQVc7UUFDVEwsSUFBSTtRQUNKQyxPQUFPO1FBQ1BDLGVBQWU7UUFDZkMsa0JBQWtCO0lBQ3BCO0FBQ0YsRUFBRTtBQUVGOztDQUVDLEdBQ00sU0FBU0csd0JBQXdCQyxlQUFtQztJQUN6RSxPQUFPQSxnQkFBZ0JDLE1BQU0sQ0FBQyxDQUFDQyxPQUFPQztRQUNwQyxNQUFNQyxXQUFXYixnQkFBZ0IsQ0FBQ1ksV0FBVztRQUM3QyxPQUFPRCxRQUFTRSxTQUFTVCxhQUFhLEdBQUdTLFNBQVNSLGdCQUFnQjtJQUNwRSxHQUFHO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9kZXBsb3ltZW50L2xhdW5jaFByb3ZpZGVycy50cz82OWUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGF1bmNoIFByb3ZpZGVyIFN5c3RlbVxuICogRWFjaCBwcm92aWRlciBoYXMgY2FwYWNpdHkgbGltaXRzIChwb2RzIHBlciBsYXVuY2gsIGxhdW5jaGVzIHBlciBtb250aClcbiAqL1xuXG5leHBvcnQgdHlwZSBMYXVuY2hQcm92aWRlcklkID0gXCJGOVwiIHwgXCJTdGFyc2hpcFwiIHwgXCJTbWFsbExpZnRcIjtcblxuZXhwb3J0IGludGVyZmFjZSBMYXVuY2hQcm92aWRlciB7XG4gIGlkOiBMYXVuY2hQcm92aWRlcklkO1xuICBsYWJlbDogc3RyaW5nO1xuICBwb2RzUGVyTGF1bmNoOiBudW1iZXI7XG4gIGxhdW5jaGVzUGVyTW9udGg6IG51bWJlcjsgLy8gQXZlcmFnZSBsYXVuY2hlcyBwZXIgbW9udGhcbn1cblxuZXhwb3J0IGNvbnN0IExBVU5DSF9QUk9WSURFUlM6IFJlY29yZDxMYXVuY2hQcm92aWRlcklkLCBMYXVuY2hQcm92aWRlcj4gPSB7XG4gIEY5OiB7XG4gICAgaWQ6IFwiRjlcIixcbiAgICBsYWJlbDogXCJGOVwiLFxuICAgIHBvZHNQZXJMYXVuY2g6IDEsXG4gICAgbGF1bmNoZXNQZXJNb250aDogNCwgLy8gMy01IHJhbmdlLCBhdmVyYWdlIDRcbiAgfSxcbiAgU3RhcnNoaXA6IHtcbiAgICBpZDogXCJTdGFyc2hpcFwiLFxuICAgIGxhYmVsOiBcIlN0YXJzaGlwXCIsXG4gICAgcG9kc1BlckxhdW5jaDogNSxcbiAgICBsYXVuY2hlc1Blck1vbnRoOiAxMiwgLy8gMTAtMjAgcmFuZ2UsIGF2ZXJhZ2UgMTJcbiAgfSxcbiAgU21hbGxMaWZ0OiB7XG4gICAgaWQ6IFwiU21hbGxMaWZ0XCIsXG4gICAgbGFiZWw6IFwiU21hbGxMaWZ0XCIsXG4gICAgcG9kc1BlckxhdW5jaDogMSxcbiAgICBsYXVuY2hlc1Blck1vbnRoOiAyLCAvLyAxLTIgcmFuZ2UsIGF2ZXJhZ2UgMlxuICB9LFxufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdG90YWwgbGF1bmNoIGNhcGFjaXR5IGZyb20gYWN0aXZlIHByb3ZpZGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlTGF1bmNoQ2FwYWNpdHkoYWN0aXZlUHJvdmlkZXJzOiBMYXVuY2hQcm92aWRlcklkW10pOiBudW1iZXIge1xuICByZXR1cm4gYWN0aXZlUHJvdmlkZXJzLnJlZHVjZSgodG90YWwsIHByb3ZpZGVySWQpID0+IHtcbiAgICBjb25zdCBwcm92aWRlciA9IExBVU5DSF9QUk9WSURFUlNbcHJvdmlkZXJJZF07XG4gICAgcmV0dXJuIHRvdGFsICsgKHByb3ZpZGVyLnBvZHNQZXJMYXVuY2ggKiBwcm92aWRlci5sYXVuY2hlc1Blck1vbnRoKTtcbiAgfSwgMCk7XG59XG5cbiJdLCJuYW1lcyI6WyJMQVVOQ0hfUFJPVklERVJTIiwiRjkiLCJpZCIsImxhYmVsIiwicG9kc1BlckxhdW5jaCIsImxhdW5jaGVzUGVyTW9udGgiLCJTdGFyc2hpcCIsIlNtYWxsTGlmdCIsImNhbGN1bGF0ZUxhdW5jaENhcGFjaXR5IiwiYWN0aXZlUHJvdmlkZXJzIiwicmVkdWNlIiwidG90YWwiLCJwcm92aWRlcklkIiwicHJvdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/deployment/launchProviders.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/deployment/metrics.ts":
/*!***************************************!*\
  !*** ./app/lib/deployment/metrics.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateAnnualOpex: function() { return /* binding */ calculateAnnualOpex; },\n/* harmony export */   calculateDeploymentMetrics: function() { return /* binding */ calculateDeploymentMetrics; },\n/* harmony export */   calculateMetricsDelta: function() { return /* binding */ calculateMetricsDelta; },\n/* harmony export */   calculateMixedCarbon: function() { return /* binding */ calculateMixedCarbon; },\n/* harmony export */   calculateMixedCostPerTFLOP: function() { return /* binding */ calculateMixedCostPerTFLOP; },\n/* harmony export */   calculateMixedLatency: function() { return /* binding */ calculateMixedLatency; },\n/* harmony export */   calculateOrbitalShare: function() { return /* binding */ calculateOrbitalShare; }\n/* harmony export */ });\n/* harmony import */ var _sim_orbitConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sim/orbitConfig */ \"(app-pages-browser)/./app/lib/sim/orbitConfig.ts\");\n/**\n * Deployment metrics calculations\n * Based on orbital share and economic formulas\n */ \n// Constants for calculations\nconst KWH_PER_TFLOP = 1000; // kWh per TFLOP (example value, adjust as needed)\nconst HOURS_PER_YEAR = 8760;\n/**\n * Calculate orbital share (0-1)\n */ function calculateOrbitalShare(podsInOrbit, orbitalSpec, groundComputeKw) {\n    let degradationFactor = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1.0;\n    const orbitalComputeKw = (0,_sim_orbitConfig__WEBPACK_IMPORTED_MODULE_0__.getOrbitalComputeKw)(podsInOrbit, orbitalSpec, degradationFactor);\n    const totalComputeKw = orbitalComputeKw + groundComputeKw;\n    if (totalComputeKw === 0) return 0;\n    const share = orbitalComputeKw / totalComputeKw;\n    return Math.max(0, Math.min(1, share)); // Clamp to [0, 1]\n}\n/**\n * Calculate cost per TFLOP-year for ground compute\n */ function calculateGroundCostPerTFLOP(groundSpec) {\n    // Energy cost per TFLOP-yr\n    const energyPerTFLOP = KWH_PER_TFLOP / 1000; // MWh per TFLOP\n    const energyCost = energyPerTFLOP * groundSpec.energyPricePerMwh * groundSpec.pue;\n    // Cooling cost (simplified - could add more detail)\n    const coolingCost = energyPerTFLOP * groundSpec.coolingWaterLPerMwh * 0.001; // $0.001/L\n    // Facility cost (simplified - could add more detail)\n    const facilityCost = energyPerTFLOP * 10; // $10/MWh facility cost\n    return energyCost + coolingCost + facilityCost;\n}\n/**\n * Calculate cost per TFLOP-year for orbital compute\n */ function calculateOrbitalCostPerTFLOP(orbitalSpec, podsInOrbit) {\n    // Pod compute capacity in TFLOP-yr\n    const podComputeTFLOPyr = orbitalSpec.computeKw / 1000 * HOURS_PER_YEAR / KWH_PER_TFLOP;\n    // Amortized capex per TFLOP-yr\n    const capexPerTFLOPyr = orbitalSpec.capexPerPod / (orbitalSpec.lifetimeYears * podComputeTFLOPyr);\n    // Opex per TFLOP-yr\n    const opexPerTFLOPyr = orbitalSpec.opexPerYearPerPod / podComputeTFLOPyr;\n    // Energy savings (orbital uses solar, minimal cost)\n    const energySavings = 0; // Could add if needed\n    // Cooling savings (no cooling needed in space)\n    const coolingSavings = 0; // Could add if needed\n    return capexPerTFLOPyr + opexPerTFLOPyr - energySavings - coolingSavings;\n}\n/**\n * Calculate mixed cost per TFLOP-year\n */ function calculateMixedCostPerTFLOP(orbitalShare, groundCostPerTFLOP, orbitalCostPerTFLOP) {\n    return (1 - orbitalShare) * groundCostPerTFLOP + orbitalShare * orbitalCostPerTFLOP;\n}\n/**\n * Calculate annual OPEX\n */ function calculateAnnualOpex(costPerTFLOP, totalComputeDemandTFLOPyr) {\n    return costPerTFLOP * totalComputeDemandTFLOPyr;\n}\n/**\n * Calculate mixed latency (weighted average)\n */ function calculateMixedLatency(orbitalShare, groundLatencyMs, orbitalLatencyMs) {\n    return (1 - orbitalShare) * groundLatencyMs + orbitalShare * orbitalLatencyMs;\n}\n/**\n * Calculate mixed carbon emissions\n */ function calculateMixedCarbon(orbitalShare, groundCarbonPerTFLOP, orbitalCarbonPerTFLOP, totalComputeDemandTFLOPyr) {\n    const mixedCarbonPerTFLOP = (1 - orbitalShare) * groundCarbonPerTFLOP + orbitalShare * orbitalCarbonPerTFLOP;\n    return mixedCarbonPerTFLOP * totalComputeDemandTFLOPyr;\n}\n/**\n * Calculate ground carbon per TFLOP-yr\n */ function calculateGroundCarbonPerTFLOP(groundSpec) {\n    const energyPerTFLOP = KWH_PER_TFLOP / 1000; // MWh per TFLOP\n    return energyPerTFLOP * groundSpec.co2PerMwh * groundSpec.pue;\n}\n/**\n * Calculate orbital carbon per TFLOP-yr (amortized launch carbon)\n */ function calculateOrbitalCarbonPerTFLOP(orbitalSpec) {\n    const podComputeTFLOPyr = orbitalSpec.computeKw / 1000 * HOURS_PER_YEAR / KWH_PER_TFLOP;\n    return orbitalSpec.co2PerYearPerPod / podComputeTFLOPyr;\n}\n/**\n * Calculate all deployment metrics\n */ function calculateDeploymentMetrics(simState) {\n    let groundLatencyMs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 120, orbitalLatencyMs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 89;\n    const { podsInOrbit, orbitalPodSpec, groundDcSpec, targetComputeKw, podDegradationFactor } = simState;\n    // Calculate orbital share\n    const orbitalShare = calculateOrbitalShare(podsInOrbit, orbitalPodSpec, targetComputeKw, podDegradationFactor);\n    // Calculate per-unit costs\n    const groundCostPerTFLOP = calculateGroundCostPerTFLOP(groundDcSpec);\n    const orbitalCostPerTFLOP = calculateOrbitalCostPerTFLOP(orbitalPodSpec, podsInOrbit);\n    // Calculate mixed metrics\n    const costPerTFLOP = calculateMixedCostPerTFLOP(orbitalShare, groundCostPerTFLOP, orbitalCostPerTFLOP);\n    // Total compute demand in TFLOP-yr\n    const totalComputeKw = (0,_sim_orbitConfig__WEBPACK_IMPORTED_MODULE_0__.getOrbitalComputeKw)(podsInOrbit, orbitalPodSpec, podDegradationFactor) + targetComputeKw;\n    const totalComputeTFLOPyr = totalComputeKw / 1000 * HOURS_PER_YEAR / KWH_PER_TFLOP;\n    const annualOpex = calculateAnnualOpex(costPerTFLOP, totalComputeTFLOPyr);\n    const latencyMs = calculateMixedLatency(orbitalShare, groundLatencyMs, orbitalLatencyMs);\n    // Carbon calculations\n    const groundCarbonPerTFLOP = calculateGroundCarbonPerTFLOP(groundDcSpec);\n    const orbitalCarbonPerTFLOP = calculateOrbitalCarbonPerTFLOP(orbitalPodSpec);\n    const carbonTonsPerYear = calculateMixedCarbon(orbitalShare, groundCarbonPerTFLOP, orbitalCarbonPerTFLOP, totalComputeTFLOPyr);\n    return {\n        costPerTFLOP,\n        annualOpex,\n        latencyMs,\n        carbonTonsPerYear\n    };\n}\n/**\n * Calculate metrics delta between before and after launch\n */ function calculateMetricsDelta(metricsBefore, metricsAfter) {\n    return {\n        costPerTFLOP: {\n            before: metricsBefore.costPerTFLOP,\n            after: metricsAfter.costPerTFLOP,\n            delta: metricsAfter.costPerTFLOP - metricsBefore.costPerTFLOP,\n            deltaPercent: (metricsAfter.costPerTFLOP - metricsBefore.costPerTFLOP) / metricsBefore.costPerTFLOP * 100\n        },\n        annualOpex: {\n            before: metricsBefore.annualOpex,\n            after: metricsAfter.annualOpex,\n            delta: metricsAfter.annualOpex - metricsBefore.annualOpex,\n            deltaPercent: (metricsAfter.annualOpex - metricsBefore.annualOpex) / metricsBefore.annualOpex * 100\n        },\n        latencyMs: {\n            before: metricsBefore.latencyMs,\n            after: metricsAfter.latencyMs,\n            delta: metricsAfter.latencyMs - metricsBefore.latencyMs\n        },\n        carbonTonsPerYear: {\n            before: metricsBefore.carbonTonsPerYear,\n            after: metricsAfter.carbonTonsPerYear,\n            delta: metricsAfter.carbonTonsPerYear - metricsBefore.carbonTonsPerYear\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvZGVwbG95bWVudC9tZXRyaWNzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBSXdEO0FBRXpELDZCQUE2QjtBQUM3QixNQUFNQyxnQkFBZ0IsTUFBTSxrREFBa0Q7QUFDOUUsTUFBTUMsaUJBQWlCO0FBZ0J2Qjs7Q0FFQyxHQUNNLFNBQVNDLHNCQUNkQyxXQUFtQixFQUNuQkMsV0FBMkIsRUFDM0JDLGVBQXVCO1FBQ3ZCQyxvQkFBQUEsaUVBQTRCO0lBRTVCLE1BQU1DLG1CQUFtQlIscUVBQW1CQSxDQUFDSSxhQUFhQyxhQUFhRTtJQUN2RSxNQUFNRSxpQkFBaUJELG1CQUFtQkY7SUFFMUMsSUFBSUcsbUJBQW1CLEdBQUcsT0FBTztJQUVqQyxNQUFNQyxRQUFRRixtQkFBbUJDO0lBQ2pDLE9BQU9FLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsR0FBR0gsU0FBUyxrQkFBa0I7QUFDNUQ7QUFFQTs7Q0FFQyxHQUNELFNBQVNJLDRCQUE0QkMsVUFBd0I7SUFDM0QsMkJBQTJCO0lBQzNCLE1BQU1DLGlCQUFpQmYsZ0JBQWdCLE1BQU0sZ0JBQWdCO0lBQzdELE1BQU1nQixhQUFhRCxpQkFBaUJELFdBQVdHLGlCQUFpQixHQUFHSCxXQUFXSSxHQUFHO0lBRWpGLG9EQUFvRDtJQUNwRCxNQUFNQyxjQUFjSixpQkFBaUJELFdBQVdNLG1CQUFtQixHQUFHLE9BQU8sV0FBVztJQUV4RixxREFBcUQ7SUFDckQsTUFBTUMsZUFBZU4saUJBQWlCLElBQUksd0JBQXdCO0lBRWxFLE9BQU9DLGFBQWFHLGNBQWNFO0FBQ3BDO0FBRUE7O0NBRUMsR0FDRCxTQUFTQyw2QkFDUGxCLFdBQTJCLEVBQzNCRCxXQUFtQjtJQUVuQixtQ0FBbUM7SUFDbkMsTUFBTW9CLG9CQUFvQixZQUFhQyxTQUFTLEdBQUcsT0FBUXZCLGlCQUFpQkQ7SUFFNUUsK0JBQStCO0lBQy9CLE1BQU15QixrQkFB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T0FBT0gsYUFBYXpCLFlBQVksR0FBR3dCLGNBQWN4QixZQUFZO1lBQzdENkIsY0FBYyxDQUFFSixhQUFhekIsWUFBWSxHQUFHd0IsY0FBY3hCLFlBQVksSUFBSXdCLGNBQWN4QixZQUFZLEdBQUk7UUFDMUc7UUFDQW9CLFlBQVk7WUFDVk0sUUFBUUYsY0FBY0osVUFBVTtZQUNoQ08sT0FBT0YsYUFBYUwsVUFBVTtZQUM5QlEsT0FBT0gsYUFBYUwsVUFBVSxHQUFHSSxjQUFjSixVQUFVO1lBQ3pEUyxjQUFjLENBQUVKLGFBQWFMLFVBQVUsR0FBR0ksY0FBY0osVUFBVSxJQUFJSSxjQUFjSixVQUFVLEdBQUk7UUFDcEc7UUFDQUMsV0FBVztZQUNUSyxRQUFRRixjQUFjSCxTQUFTO1lBQy9CTSxPQUFPRixhQUFhSixTQUFTO1lBQzdCTyxPQUFPSCxhQUFhSixTQUFTLEdBQUdHLGNBQWNILFNBQVM7UUFDekQ7UUFDQUMsbUJBQW1CO1lBQ2pCSSxRQUFRRixjQUFjRixpQkFBaUI7WUFDdkNLLE9BQU9GLGFBQWFILGlCQUFpQjtZQUNyQ00sT0FBT0gsYUFBYUgsaUJBQWlCLEdBQUdFLGNBQWNGLGlCQUFpQjtRQUN6RTtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9kZXBsb3ltZW50L21ldHJpY3MudHM/YzExMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERlcGxveW1lbnQgbWV0cmljcyBjYWxjdWxhdGlvbnNcbiAqIEJhc2VkIG9uIG9yYml0YWwgc2hhcmUgYW5kIGVjb25vbWljIGZvcm11bGFzXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBTaW1TdGF0ZSB9IGZyb20gXCIuLi9zaW0vbW9kZWxcIjtcbmltcG9ydCB0eXBlIHsgT3JiaXRhbFBvZFNwZWMsIEdyb3VuZERjU3BlYyB9IGZyb20gXCIuLi9zaW0vb3JiaXRDb25maWdcIjtcbmltcG9ydCB7IGdldE9yYml0YWxDb21wdXRlS3cgfSBmcm9tIFwiLi4vc2ltL29yYml0Q29uZmlnXCI7XG5cbi8vIENvbnN0YW50cyBmb3IgY2FsY3VsYXRpb25zXG5jb25zdCBLV0hfUEVSX1RGTE9QID0gMTAwMDsgLy8ga1doIHBlciBURkxPUCAoZXhhbXBsZSB2YWx1ZSwgYWRqdXN0IGFzIG5lZWRlZClcbmNvbnN0IEhPVVJTX1BFUl9ZRUFSID0gODc2MDtcblxuZXhwb3J0IGludGVyZmFjZSBEZXBsb3ltZW50TWV0cmljcyB7XG4gIGNvc3RQZXJURkxPUDogbnVtYmVyOyAgICAgIC8vICQvVEZMT1AteXJcbiAgYW5udWFsT3BleDogbnVtYmVyOyAgICAgICAgIC8vICQveXJcbiAgbGF0ZW5jeU1zOiBudW1iZXI7ICAgICAgICAgIC8vIG1zXG4gIGNhcmJvblRvbnNQZXJZZWFyOiBudW1iZXI7ICAvLyB0Q08yL3lyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWV0cmljc0RlbHRhIHtcbiAgY29zdFBlclRGTE9QOiB7IGJlZm9yZTogbnVtYmVyOyBhZnRlcjogbnVtYmVyOyBkZWx0YTogbnVtYmVyOyBkZWx0YVBlcmNlbnQ6IG51bWJlciB9O1xuICBhbm51YWxPcGV4OiB7IGJlZm9yZTogbnVtYmVyOyBhZnRlcjogbnVtYmVyOyBkZWx0YTogbnVtYmVyOyBkZWx0YVBlcmNlbnQ6IG51bWJlciB9O1xuICBsYXRlbmN5TXM6IHsgYmVmb3JlOiBudW1iZXI7IGFmdGVyOiBudW1iZXI7IGRlbHRhOiBudW1iZXIgfTtcbiAgY2FyYm9uVG9uc1BlclllYXI6IHsgYmVmb3JlOiBudW1iZXI7IGFmdGVyOiBudW1iZXI7IGRlbHRhOiBudW1iZXIgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgb3JiaXRhbCBzaGFyZSAoMC0xKVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlT3JiaXRhbFNoYXJlKFxuICBwb2RzSW5PcmJpdDogbnVtYmVyLFxuICBvcmJpdGFsU3BlYzogT3JiaXRhbFBvZFNwZWMsXG4gIGdyb3VuZENvbXB1dGVLdzogbnVtYmVyLFxuICBkZWdyYWRhdGlvbkZhY3RvcjogbnVtYmVyID0gMS4wXG4pOiBudW1iZXIge1xuICBjb25zdCBvcmJpdGFsQ29tcHV0ZUt3ID0gZ2V0T3JiaXRhbENvbXB1dGVLdyhwb2RzSW5PcmJpdCwgb3JiaXRhbFNwZWMsIGRlZ3JhZGF0aW9uRmFjdG9yKTtcbiAgY29uc3QgdG90YWxDb21wdXRlS3cgPSBvcmJpdGFsQ29tcHV0ZUt3ICsgZ3JvdW5kQ29tcHV0ZUt3O1xuICBcbiAgaWYgKHRvdGFsQ29tcHV0ZUt3ID09PSAwKSByZXR1cm4gMDtcbiAgXG4gIGNvbnN0IHNoYXJlID0gb3JiaXRhbENvbXB1dGVLdyAvIHRvdGFsQ29tcHV0ZUt3O1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgc2hhcmUpKTsgLy8gQ2xhbXAgdG8gWzAsIDFdXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGNvc3QgcGVyIFRGTE9QLXllYXIgZm9yIGdyb3VuZCBjb21wdXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUdyb3VuZENvc3RQZXJURkxPUChncm91bmRTcGVjOiBHcm91bmREY1NwZWMpOiBudW1iZXIge1xuICAvLyBFbmVyZ3kgY29zdCBwZXIgVEZMT1AteXJcbiAgY29uc3QgZW5lcmd5UGVyVEZMT1AgPSBLV0hfUEVSX1RGTE9QIC8gMTAwMDsgLy8gTVdoIHBlciBURkxPUFxuICBjb25zdCBlbmVyZ3lDb3N0ID0gZW5lcmd5UGVyVEZMT1AgKiBncm91bmRTcGVjLmVuZXJneVByaWNlUGVyTXdoICogZ3JvdW5kU3BlYy5wdWU7XG4gIFxuICAvLyBDb29saW5nIGNvc3QgKHNpbXBsaWZpZWQgLSBjb3VsZCBhZGQgbW9yZSBkZXRhaWwpXG4gIGNvbnN0IGNvb2xpbmdDb3N0ID0gZW5lcmd5UGVyVEZMT1AgKiBncm91bmRTcGVjLmNvb2xpbmdXYXRlckxQZXJNd2ggKiAwLjAwMTsgLy8gJDAuMDAxL0xcbiAgXG4gIC8vIEZhY2lsaXR5IGNvc3QgKHNpbXBsaWZpZWQgLSBjb3VsZCBhZGQgbW9yZSBkZXRhaWwpXG4gIGNvbnN0IGZhY2lsaXR5Q29zdCA9IGVuZXJneVBlclRGTE9QICogMTA7IC8vICQxMC9NV2ggZmFjaWxpdHkgY29zdFxuICBcbiAgcmV0dXJuIGVuZXJneUNvc3QgKyBjb29saW5nQ29zdCArIGZhY2lsaXR5Q29zdDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgY29zdCBwZXIgVEZMT1AteWVhciBmb3Igb3JiaXRhbCBjb21wdXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZU9yYml0YWxDb3N0UGVyVEZMT1AoXG4gIG9yYml0YWxTcGVjOiBPcmJpdGFsUG9kU3BlYyxcbiAgcG9kc0luT3JiaXQ6IG51bWJlclxuKTogbnVtYmVyIHtcbiAgLy8gUG9kIGNvbXB1dGUgY2FwYWNpdHkgaW4gVEZMT1AteXJcbiAgY29uc3QgcG9kQ29tcHV0ZVRGTE9QeXIgPSAob3JiaXRhbFNwZWMuY29tcHV0ZUt3IC8gMTAwMCkgKiBIT1VSU19QRVJfWUVBUiAvIEtXSF9QRVJfVEZMT1A7XG4gIFxuICAvLyBBbW9ydGl6ZWQgY2FwZXggcGVyIFRGTE9QLXlyXG4gIGNvbnN0IGNhcGV4UGVyVEZMT1B5ciA9IG9yYml0YWxTcGVjLmNhcGV4UGVyUG9kIC8gKG9yYml0YWxTcGVjLmxpZmV0aW1lWWVhcnMgKiBwb2RDb21wdXRlVEZMT1B5cik7XG4gIFxuICAvLyBPcGV4IHBlciBURkxPUC15clxuICBjb25zdCBvcGV4UGVyVEZMT1B5ciA9IG9yYml0YWxTcGVjLm9wZXhQZXJZZWFyUGVyUG9kIC8gcG9kQ29tcHV0ZVRGTE9QeXI7XG4gIFxuICAvLyBFbmVyZ3kgc2F2aW5ncyAob3JiaXRhbCB1c2VzIHNvbGFyLCBtaW5pbWFsIGNvc3QpXG4gIGNvbnN0IGVuZXJneVNhdmluZ3MgPSAwOyAvLyBDb3VsZCBhZGQgaWYgbmVlZGVkXG4gIFxuICAvLyBDb29saW5nIHNhdmluZ3MgKG5vIGNvb2xpbmcgbmVlZGVkIGluIHNwYWNlKVxuICBjb25zdCBjb29saW5nU2F2aW5ncyA9IDA7IC8vIENvdWxkIGFkZCBpZiBuZWVkZWRcbiAgXG4gIHJldHVybiBjYXBleFBlclRGTE9QeXIgKyBvcGV4UGVyVEZMT1B5ciAtIGVuZXJneVNhdmluZ3MgLSBjb29saW5nU2F2aW5ncztcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgbWl4ZWQgY29zdCBwZXIgVEZMT1AteWVhclxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlTWl4ZWRDb3N0UGVyVEZMT1AoXG4gIG9yYml0YWxTaGFyZTogbnVtYmVyLFxuICBncm91bmRDb3N0UGVyVEZMT1A6IG51bWJlcixcbiAgb3JiaXRhbENvc3RQZXJURkxPUDogbnVtYmVyXG4pOiBudW1iZXIge1xuICByZXR1cm4gKDEgLSBvcmJpdGFsU2hhcmUpICogZ3JvdW5kQ29zdFBlclRGTE9QICsgb3JiaXRhbFNoYXJlICogb3JiaXRhbENvc3RQZXJURkxPUDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgYW5udWFsIE9QRVhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUFubnVhbE9wZXgoXG4gIGNvc3RQZXJURkxPUDogbnVtYmVyLFxuICB0b3RhbENvbXB1dGVEZW1hbmRURkxPUHlyOiBudW1iZXJcbik6IG51bWJlciB7XG4gIHJldHVybiBjb3N0UGVyVEZMT1AgKiB0b3RhbENvbXB1dGVEZW1hbmRURkxPUHlyO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBtaXhlZCBsYXRlbmN5ICh3ZWlnaHRlZCBhdmVyYWdlKVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlTWl4ZWRMYXRlbmN5KFxuICBvcmJpdGFsU2hhcmU6IG51bWJlcixcbiAgZ3JvdW5kTGF0ZW5jeU1zOiBudW1iZXIsXG4gIG9yYml0YWxMYXRlbmN5TXM6IG51bWJlclxuKTogbnVtYmVyIHtcbiAgcmV0dXJuICgxIC0gb3JiaXRhbFNoYXJlKSAqIGdyb3VuZExhdGVuY3lNcyArIG9yYml0YWxTaGFyZSAqIG9yYml0YWxMYXRlbmN5TXM7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIG1peGVkIGNhcmJvbiBlbWlzc2lvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZU1peGVkQ2FyYm9uKFxuICBvcmJpdGFsU2hhcmU6IG51bWJlcixcbiAgZ3JvdW5kQ2FyYm9uUGVyVEZMT1A6IG51bWJlcixcbiAgb3JiaXRhbENhcmJvblBlclRGTE9QOiBudW1iZXIsXG4gIHRvdGFsQ29tcHV0ZURlbWFuZFRGTE9QeXI6IG51bWJlclxuKTogbnVtYmVyIHtcbiAgY29uc3QgbWl4ZWRDYXJib25QZXJURkxPUCA9ICgxIC0gb3JiaXRhbFNoYXJlKSAqIGdyb3VuZENhcmJvblBlclRGTE9QICsgb3JiaXRhbFNoYXJlICogb3JiaXRhbENhcmJvblBlclRGTE9QO1xuICByZXR1cm4gbWl4ZWRDYXJib25QZXJURkxPUCAqIHRvdGFsQ29tcHV0ZURlbWFuZFRGTE9QeXI7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGdyb3VuZCBjYXJib24gcGVyIFRGTE9QLXlyXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUdyb3VuZENhcmJvblBlclRGTE9QKGdyb3VuZFNwZWM6IEdyb3VuZERjU3BlYyk6IG51bWJlciB7XG4gIGNvbnN0IGVuZXJneVBlclRGTE9QID0gS1dIX1BFUl9URkxPUCAvIDEwMDA7IC8vIE1XaCBwZXIgVEZMT1BcbiAgcmV0dXJuIGVuZXJneVBlclRGTE9QICogZ3JvdW5kU3BlYy5jbzJQZXJNd2ggKiBncm91bmRTcGVjLnB1ZTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgb3JiaXRhbCBjYXJib24gcGVyIFRGTE9QLXlyIChhbW9ydGl6ZWQgbGF1bmNoIGNhcmJvbilcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlT3JiaXRhbENhcmJvblBlclRGTE9QKG9yYml0YWxTcGVjOiBPcmJpdGFsUG9kU3BlYyk6IG51bWJlciB7XG4gIGNvbnN0IHBvZENvbXB1dGVURkxPUHlyID0gKG9yYml0YWxTcGVjLmNvbXB1dGVLdyAvIDEwMDApICogSE9VUlNfUEVSX1lFQVIgLyBLV0hfUEVSX1RGTE9QO1xuICByZXR1cm4gb3JiaXRhbFNwZWMuY28yUGVyWWVhclBlclBvZCAvIHBvZENvbXB1dGVURkxPUHlyO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBhbGwgZGVwbG95bWVudCBtZXRyaWNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVEZXBsb3ltZW50TWV0cmljcyhcbiAgc2ltU3RhdGU6IFNpbVN0YXRlLFxuICBncm91bmRMYXRlbmN5TXM6IG51bWJlciA9IDEyMCxcbiAgb3JiaXRhbExhdGVuY3lNczogbnVtYmVyID0gODlcbik6IERlcGxveW1lbnRNZXRyaWNzIHtcbiAgY29uc3QgeyBwb2RzSW5PcmJpdCwgb3JiaXRhbFBvZFNwZWMsIGdyb3VuZERjU3BlYywgdGFyZ2V0Q29tcHV0ZUt3LCBwb2REZWdyYWRhdGlvbkZhY3RvciB9ID0gc2ltU3RhdGU7XG4gIFxuICAvLyBDYWxjdWxhdGUgb3JiaXRhbCBzaGFyZVxuICBjb25zdCBvcmJpdGFsU2hhcmUgPSBjYWxjdWxhdGVPcmJpdGFsU2hhcmUoXG4gICAgcG9kc0luT3JiaXQsXG4gICAgb3JiaXRhbFBvZFNwZWMsXG4gICAgdGFyZ2V0Q29tcHV0ZUt3LFxuICAgIHBvZERlZ3JhZGF0aW9uRmFjdG9yXG4gICk7XG4gIFxuICAvLyBDYWxjdWxhdGUgcGVyLXVuaXQgY29zdHNcbiAgY29uc3QgZ3JvdW5kQ29zdFBlclRGTE9QID0gY2FsY3VsYXRlR3JvdW5kQ29zdFBlclRGTE9QKGdyb3VuZERjU3BlYyk7XG4gIGNvbnN0IG9yYml0YWxDb3N0UGVyVEZMT1AgPSBjYWxjdWxhdGVPcmJpdGFsQ29zdFBlclRGTE9QKG9yYml0YWxQb2RTcGVjLCBwb2RzSW5PcmJpdCk7XG4gIFxuICAvLyBDYWxjdWxhdGUgbWl4ZWQgbWV0cmljc1xuICBjb25zdCBjb3N0UGVyVEZMT1AgPSBjYWxjdWxhdGVNaXhlZENvc3RQZXJURkxPUChvcmJpdGFsU2hhcmUsIGdyb3VuZENvc3RQZXJURkxPUCwgb3JiaXRhbENvc3RQZXJURkxPUCk7XG4gIFxuICAvLyBUb3RhbCBjb21wdXRlIGRlbWFuZCBpbiBURkxPUC15clxuICBjb25zdCB0b3RhbENvbXB1dGVLdyA9IGdldE9yYml0YWxDb21wdXRlS3cocG9kc0luT3JiaXQsIG9yYml0YWxQb2RTcGVjLCBwb2REZWdyYWRhdGlvbkZhY3RvcikgKyB0YXJnZXRDb21wdXRlS3c7XG4gIGNvbnN0IHRvdGFsQ29tcHV0ZVRGTE9QeXIgPSAodG90YWxDb21wdXRlS3cgLyAxMDAwKSAqIEhPVVJTX1BFUl9ZRUFSIC8gS1dIX1BFUl9URkxPUDtcbiAgXG4gIGNvbnN0IGFubnVhbE9wZXggPSBjYWxjdWxhdGVBbm51YWxPcGV4KGNvc3RQZXJURkxPUCwgdG90YWxDb21wdXRlVEZMT1B5cik7XG4gIGNvbnN0IGxhdGVuY3lNcyA9IGNhbGN1bGF0ZU1peGVkTGF0ZW5jeShvcmJpdGFsU2hhcmUsIGdyb3VuZExhdGVuY3lNcywgb3JiaXRhbExhdGVuY3lNcyk7XG4gIFxuICAvLyBDYXJib24gY2FsY3VsYXRpb25zXG4gIGNvbnN0IGdyb3VuZENhcmJvblBlclRGTE9QID0gY2FsY3VsYXRlR3JvdW5kQ2FyYm9uUGVyVEZMT1AoZ3JvdW5kRGNTcGVjKTtcbiAgY29uc3Qgb3JiaXRhbENhcmJvblBlclRGTE9QID0gY2FsY3VsYXRlT3JiaXRhbENhcmJvblBlclRGTE9QKG9yYml0YWxQb2RTcGVjKTtcbiAgY29uc3QgY2FyYm9uVG9uc1BlclllYXIgPSBjYWxjdWxhdGVNaXhlZENhcmJvbihcbiAgICBvcmJpdGFsU2hhcmUsXG4gICAgZ3JvdW5kQ2FyYm9uUGVyVEZMT1AsXG4gICAgb3JiaXRhbENhcmJvblBlclRGTE9QLFxuICAgIHRvdGFsQ29tcHV0ZVRGTE9QeXJcbiAgKTtcbiAgXG4gIHJldHVybiB7XG4gICAgY29zdFBlclRGTE9QLFxuICAgIGFubnVhbE9wZXgsXG4gICAgbGF0ZW5jeU1zLFxuICAgIGNhcmJvblRvbnNQZXJZZWFyLFxuICB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBtZXRyaWNzIGRlbHRhIGJldHdlZW4gYmVmb3JlIGFuZCBhZnRlciBsYXVuY2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZU1ldHJpY3NEZWx0YShcbiAgbWV0cmljc0JlZm9yZTogRGVwbG95bWVudE1ldHJpY3MsXG4gIG1ldHJpY3NBZnRlcjogRGVwbG95bWVudE1ldHJpY3Ncbik6IE1ldHJpY3NEZWx0YSB7XG4gIHJldHVybiB7XG4gICAgY29zdFBlclRGTE9QOiB7XG4gICAgICBiZWZvcmU6IG1ldHJpY3NCZWZvcmUuY29zdFBlclRGTE9QLFxuICAgICAgYWZ0ZXI6IG1ldHJpY3NBZnRlci5jb3N0UGVyVEZMT1AsXG4gICAgICBkZWx0YTogbWV0cmljc0FmdGVyLmNvc3RQZXJURkxPUCAtIG1ldHJpY3NCZWZvcmUuY29zdFBlclRGTE9QLFxuICAgICAgZGVsdGFQZXJjZW50OiAoKG1ldHJpY3NBZnRlci5jb3N0UGVyVEZMT1AgLSBtZXRyaWNzQmVmb3JlLmNvc3RQZXJURkxPUCkgLyBtZXRyaWNzQmVmb3JlLmNvc3RQZXJURkxPUCkgKiAxMDAsXG4gICAgfSxcbiAgICBhbm51YWxPcGV4OiB7XG4gICAgICBiZWZvcmU6IG1ldHJpY3NCZWZvcmUuYW5udWFsT3BleCxcbiAgICAgIGFmdGVyOiBtZXRyaWNzQWZ0ZXIuYW5udWFsT3BleCxcbiAgICAgIGRlbHRhOiBtZXRyaWNzQWZ0ZXIuYW5udWFsT3BleCAtIG1ldHJpY3NCZWZvcmUuYW5udWFsT3BleCxcbiAgICAgIGRlbHRhUGVyY2VudDogKChtZXRyaWNzQWZ0ZXIuYW5udWFsT3BleCAtIG1ldHJpY3NCZWZvcmUuYW5udWFsT3BleCkgLyBtZXRyaWNzQmVmb3JlLmFubnVhbE9wZXgpICogMTAwLFxuICAgIH0sXG4gICAgbGF0ZW5jeU1zOiB7XG4gICAgICBiZWZvcmU6IG1ldHJpY3NCZWZvcmUubGF0ZW5jeU1zLFxuICAgICAgYWZ0ZXI6IG1ldHJpY3NBZnRlci5sYXRlbmN5TXMsXG4gICAgICBkZWx0YTogbWV0cmljc0FmdGVyLmxhdGVuY3lNcyAtIG1ldHJpY3NCZWZvcmUubGF0ZW5jeU1zLFxuICAgIH0sXG4gICAgY2FyYm9uVG9uc1BlclllYXI6IHtcbiAgICAgIGJlZm9yZTogbWV0cmljc0JlZm9yZS5jYXJib25Ub25zUGVyWWVhcixcbiAgICAgIGFmdGVyOiBtZXRyaWNzQWZ0ZXIuY2FyYm9uVG9uc1BlclllYXIsXG4gICAgICBkZWx0YTogbWV0cmljc0FmdGVyLmNhcmJvblRvbnNQZXJZZWFyIC0gbWV0cmljc0JlZm9yZS5jYXJib25Ub25zUGVyWWVhcixcbiAgICB9LFxuICB9O1xufVxuXG4iXSwibmFtZXMiOlsiZ2V0T3JiaXRhbENvbXB1dGVLdyIsIktXSF9QRVJfVEZMT1AiLCJIT1VSU19QRVJfWUVBUiIsImNhbGN1bGF0ZU9yYml0YWxTaGFyZSIsInBvZHNJbk9yYml0Iiwib3JiaXRhbFNwZWMiLCJncm91bmRDb21wdXRlS3ciLCJkZWdyYWRhdGlvbkZhY3RvciIsIm9yYml0YWxDb21wdXRlS3ciLCJ0b3RhbENvbXB1dGVLdyIsInNoYXJlIiwiTWF0aCIsIm1heCIsIm1pbiIsImNhbGN1bGF0ZUdyb3VuZENvc3RQZXJURkxPUCIsImdyb3VuZFNwZWMiLCJlbmVyZ3lQZXJURkxPUCIsImVuZXJneUNvc3QiLCJlbmVyZ3lQcmljZVBlck13aCIsInB1ZSIsImNvb2xpbmdDb3N0IiwiY29vbGluZ1dhdGVyTFBlck13aCIsImZhY2lsaXR5Q29zdCIsImNhbGN1bGF0ZU9yYml0YWxDb3N0UGVyVEZMT1AiLCJwb2RDb21wdXRlVEZMT1B5ciIsImNvbXB1dGVLdyIsImNhcGV4UGVyVEZMT1B5ciIsImNhcGV4UGVyUG9kIiwibGlmZXRpbWVZZWFycyIsIm9wZXhQZXJURkxPUHlyIiwib3BleFBlclllYXJQZXJQb2QiLCJlbmVyZ3lTYXZpbmdzIiwiY29vbGluZ1NhdmluZ3MiLCJjYWxjdWxhdGVNaXhlZENvc3RQZXJURkxPUCIsIm9yYml0YWxTaGFyZSIsImdyb3VuZENvc3RQZXJURkxPUCIsIm9yYml0YWxDb3N0UGVyVEZMT1AiLCJjYWxjdWxhdGVBbm51YWxPcGV4IiwiY29zdFBlclRGTE9QIiwidG90YWxDb21wdXRlRGVtYW5kVEZMT1B5ciIsImNhbGN1bGF0ZU1peGVkTGF0ZW5jeSIsImdyb3VuZExhdGVuY3lNcyIsIm9yYml0YWxMYXRlbmN5TXMiLCJjYWxjdWxhdGVNaXhlZENhcmJvbiIsImdyb3VuZENhcmJvblBlclRGTE9QIiwib3JiaXRhbENhcmJvblBlclRGTE9QIiwibWl4ZWRDYXJib25QZXJURkxPUCIsImNhbGN1bGF0ZUdyb3VuZENhcmJvblBlclRGTE9QIiwiY28yUGVyTXdoIiwiY2FsY3VsYXRlT3JiaXRhbENhcmJvblBlclRGTE9QIiwiY28yUGVyWWVhclBlclBvZCIsImNhbGN1bGF0ZURlcGxveW1lbnRNZXRyaWNzIiwic2ltU3RhdGUiLCJvcmJpdGFsUG9kU3BlYyIsImdyb3VuZERjU3BlYyIsInRhcmdldENvbXB1dGVLdyIsInBvZERlZ3JhZGF0aW9uRmFjdG9yIiwidG90YWxDb21wdXRlVEZMT1B5ciIsImFubnVhbE9wZXgiLCJsYXRlbmN5TXMiLCJjYXJib25Ub25zUGVyWWVhciIsImNhbGN1bGF0ZU1ldHJpY3NEZWx0YSIsIm1ldHJpY3NCZWZvcmUiLCJtZXRyaWNzQWZ0ZXIiLCJiZWZvcmUiLCJhZnRlciIsImRlbHRhIiwiZGVsdGFQZXJjZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/deployment/metrics.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/deployment/orbitalDensity.ts":
/*!**********************************************!*\
  !*** ./app/lib/deployment/orbitalDensity.ts ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DensityBand: function() { return /* binding */ DensityBand; },\n/* harmony export */   getDensityBand: function() { return /* binding */ getDensityBand; },\n/* harmony export */   getDeploymentDelayMultiplier: function() { return /* binding */ getDeploymentDelayMultiplier; },\n/* harmony export */   getFailureRate: function() { return /* binding */ getFailureRate; },\n/* harmony export */   getLatencyPenalty: function() { return /* binding */ getLatencyPenalty; }\n/* harmony export */ });\n/**\n * Orbital Density System\n * Tracks density in \"satellite equivalents\" and applies effects\n */ var DensityBand;\n(function(DensityBand) {\n    DensityBand[\"SAFE\"] = \"Safe\";\n    DensityBand[\"BUSY\"] = \"Busy\";\n    DensityBand[\"CONGESTED\"] = \"Congested\";\n    DensityBand[\"UNSAFE\"] = \"Unsafe\";\n})(DensityBand || (DensityBand = {}));\nconst SAFE_DENSITY = 5000;\nconst BUSY_DENSITY = 15000;\nconst CONGESTED_DENSITY = 25000;\n/**\n * Get density band from satellite-equivalent count\n * Each pod = ~50 satellites equivalent\n */ function getDensityBand(density) {\n    if (density < SAFE_DENSITY) return \"Safe\";\n    if (density < BUSY_DENSITY) return \"Busy\";\n    if (density < CONGESTED_DENSITY) return \"Congested\";\n    return \"Unsafe\";\n}\n/**\n * Calculate deployment delay multiplier based on density\n * Higher density = slower deployments\n */ function getDeploymentDelayMultiplier(density) {\n    const safeDensity = 10000; // Safe threshold\n    return 1 + Math.pow(density / safeDensity, 2);\n}\n/**\n * Calculate failure rate based on density band\n */ function getFailureRate(densityBand) {\n    switch(densityBand){\n        case \"Safe\":\n            return 0.01; // 1% failure rate\n        case \"Busy\":\n            return 0.02; // 2% failure rate\n        case \"Congested\":\n            return 0.05; // 5% failure rate\n        case \"Unsafe\":\n            return 0.10; // 10% failure rate\n    }\n}\n/**\n * Calculate latency penalty from density\n */ function getLatencyPenalty(densityBand) {\n    switch(densityBand){\n        case \"Safe\":\n        case \"Busy\":\n            return 0; // No penalty\n        case \"Congested\":\n            return 5; // +5ms penalty\n        case \"Unsafe\":\n            return 15; // +15ms penalty\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvZGVwbG95bWVudC9vcmJpdGFsRGVuc2l0eS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Q0FHQztVQUVXQTs7Ozs7R0FBQUEsZ0JBQUFBO0FBT1osTUFBTUMsZUFBZTtBQUNyQixNQUFNQyxlQUFlO0FBQ3JCLE1BQU1DLG9CQUFvQjtBQUUxQjs7O0NBR0MsR0FDTSxTQUFTQyxlQUFlQyxPQUFlO0lBQzVDLElBQUlBLFVBQVVKLGNBQWM7SUFDNUIsSUFBSUksVUFBVUgsY0FBYztJQUM1QixJQUFJRyxVQUFVRixtQkFBbUI7SUFDakM7QUFDRjtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNHLDZCQUE2QkQsT0FBZTtJQUMxRCxNQUFNRSxjQUFjLE9BQVEsaUJBQWlCO0lBQzdDLE9BQU8sSUFBSUMsS0FBS0MsR0FBRyxDQUFDSixVQUFVRSxhQUFhO0FBQzdDO0FBRUE7O0NBRUMsR0FDTSxTQUFTRyxlQUFlQyxXQUF3QjtJQUNyRCxPQUFRQTtRQUNOO1lBQ0UsT0FBTyxNQUFNLGtCQUFrQjtRQUNqQztZQUNFLE9BQU8sTUFBTSxrQkFBa0I7UUFDakM7WUFDRSxPQUFPLE1BQU0sa0JBQWtCO1FBQ2pDO1lBQ0UsT0FBTyxNQUFNLG1CQUFtQjtJQUNwQztBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTQyxrQkFBa0JELFdBQXdCO0lBQ3hELE9BQVFBO1FBQ047UUFDQTtZQUNFLE9BQU8sR0FBRyxhQUFhO1FBQ3pCO1lBQ0UsT0FBTyxHQUFHLGVBQWU7UUFDM0I7WUFDRSxPQUFPLElBQUksZ0JBQWdCO0lBQy9CO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9kZXBsb3ltZW50L29yYml0YWxEZW5zaXR5LnRzPzlhYmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBPcmJpdGFsIERlbnNpdHkgU3lzdGVtXG4gKiBUcmFja3MgZGVuc2l0eSBpbiBcInNhdGVsbGl0ZSBlcXVpdmFsZW50c1wiIGFuZCBhcHBsaWVzIGVmZmVjdHNcbiAqL1xuXG5leHBvcnQgZW51bSBEZW5zaXR5QmFuZCB7XG4gIFNBRkUgPSBcIlNhZmVcIixcbiAgQlVTWSA9IFwiQnVzeVwiLFxuICBDT05HRVNURUQgPSBcIkNvbmdlc3RlZFwiLFxuICBVTlNBRkUgPSBcIlVuc2FmZVwiLFxufVxuXG5jb25zdCBTQUZFX0RFTlNJVFkgPSA1XzAwMDtcbmNvbnN0IEJVU1lfREVOU0lUWSA9IDE1XzAwMDtcbmNvbnN0IENPTkdFU1RFRF9ERU5TSVRZID0gMjVfMDAwO1xuXG4vKipcbiAqIEdldCBkZW5zaXR5IGJhbmQgZnJvbSBzYXRlbGxpdGUtZXF1aXZhbGVudCBjb3VudFxuICogRWFjaCBwb2QgPSB+NTAgc2F0ZWxsaXRlcyBlcXVpdmFsZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZW5zaXR5QmFuZChkZW5zaXR5OiBudW1iZXIpOiBEZW5zaXR5QmFuZCB7XG4gIGlmIChkZW5zaXR5IDwgU0FGRV9ERU5TSVRZKSByZXR1cm4gRGVuc2l0eUJhbmQuU0FGRTtcbiAgaWYgKGRlbnNpdHkgPCBCVVNZX0RFTlNJVFkpIHJldHVybiBEZW5zaXR5QmFuZC5CVVNZO1xuICBpZiAoZGVuc2l0eSA8IENPTkdFU1RFRF9ERU5TSVRZKSByZXR1cm4gRGVuc2l0eUJhbmQuQ09OR0VTVEVEO1xuICByZXR1cm4gRGVuc2l0eUJhbmQuVU5TQUZFO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBkZXBsb3ltZW50IGRlbGF5IG11bHRpcGxpZXIgYmFzZWQgb24gZGVuc2l0eVxuICogSGlnaGVyIGRlbnNpdHkgPSBzbG93ZXIgZGVwbG95bWVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERlcGxveW1lbnREZWxheU11bHRpcGxpZXIoZGVuc2l0eTogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3Qgc2FmZURlbnNpdHkgPSAxMF8wMDA7IC8vIFNhZmUgdGhyZXNob2xkXG4gIHJldHVybiAxICsgTWF0aC5wb3coZGVuc2l0eSAvIHNhZmVEZW5zaXR5LCAyKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgZmFpbHVyZSByYXRlIGJhc2VkIG9uIGRlbnNpdHkgYmFuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmFpbHVyZVJhdGUoZGVuc2l0eUJhbmQ6IERlbnNpdHlCYW5kKTogbnVtYmVyIHtcbiAgc3dpdGNoIChkZW5zaXR5QmFuZCkge1xuICAgIGNhc2UgRGVuc2l0eUJhbmQuU0FGRTpcbiAgICAgIHJldHVybiAwLjAxOyAvLyAxJSBmYWlsdXJlIHJhdGVcbiAgICBjYXNlIERlbnNpdHlCYW5kLkJVU1k6XG4gICAgICByZXR1cm4gMC4wMjsgLy8gMiUgZmFpbHVyZSByYXRlXG4gICAgY2FzZSBEZW5zaXR5QmFuZC5DT05HRVNURUQ6XG4gICAgICByZXR1cm4gMC4wNTsgLy8gNSUgZmFpbHVyZSByYXRlXG4gICAgY2FzZSBEZW5zaXR5QmFuZC5VTlNBRkU6XG4gICAgICByZXR1cm4gMC4xMDsgLy8gMTAlIGZhaWx1cmUgcmF0ZVxuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGxhdGVuY3kgcGVuYWx0eSBmcm9tIGRlbnNpdHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExhdGVuY3lQZW5hbHR5KGRlbnNpdHlCYW5kOiBEZW5zaXR5QmFuZCk6IG51bWJlciB7XG4gIHN3aXRjaCAoZGVuc2l0eUJhbmQpIHtcbiAgICBjYXNlIERlbnNpdHlCYW5kLlNBRkU6XG4gICAgY2FzZSBEZW5zaXR5QmFuZC5CVVNZOlxuICAgICAgcmV0dXJuIDA7IC8vIE5vIHBlbmFsdHlcbiAgICBjYXNlIERlbnNpdHlCYW5kLkNPTkdFU1RFRDpcbiAgICAgIHJldHVybiA1OyAvLyArNW1zIHBlbmFsdHlcbiAgICBjYXNlIERlbnNpdHlCYW5kLlVOU0FGRTpcbiAgICAgIHJldHVybiAxNTsgLy8gKzE1bXMgcGVuYWx0eVxuICB9XG59XG5cbiJdLCJuYW1lcyI6WyJEZW5zaXR5QmFuZCIsIlNBRkVfREVOU0lUWSIsIkJVU1lfREVOU0lUWSIsIkNPTkdFU1RFRF9ERU5TSVRZIiwiZ2V0RGVuc2l0eUJhbmQiLCJkZW5zaXR5IiwiZ2V0RGVwbG95bWVudERlbGF5TXVsdGlwbGllciIsInNhZmVEZW5zaXR5IiwiTWF0aCIsInBvdyIsImdldEZhaWx1cmVSYXRlIiwiZGVuc2l0eUJhbmQiLCJnZXRMYXRlbmN5UGVuYWx0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/deployment/orbitalDensity.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/deployment/podTiers.ts":
/*!****************************************!*\
  !*** ./app/lib/deployment/podTiers.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POD_TIERS: function() { return /* binding */ POD_TIERS; },\n/* harmony export */   getAvailableTiers: function() { return /* binding */ getAvailableTiers; },\n/* harmony export */   getHighestAvailableTier: function() { return /* binding */ getHighestAvailableTier; }\n/* harmony export */ });\n/**\n * Pod Tier System\n * Progression based on total pods built, not difficulty modes\n */ // NEW POWER-FIRST POD TIERS (all >= 100kW)\nconst POD_TIERS = [\n    {\n        id: \"tier1\",\n        label: \"Base Pod\",\n        powerKW: 100,\n        unlockAtTotalPods: 0,\n        baseCostM: 2,\n        baseBuildDays: 180\n    },\n    {\n        id: \"tier2\",\n        label: \"Enhanced Pod\",\n        powerKW: 500,\n        unlockAtTotalPods: 50,\n        baseCostM: 5,\n        baseBuildDays: 150\n    },\n    {\n        id: \"tier3\",\n        label: \"High-Power Pod\",\n        powerKW: 1000,\n        unlockAtTotalPods: 200,\n        baseCostM: 10,\n        baseBuildDays: 120\n    }\n];\n/**\n * Get available pod tiers based on total pods built\n */ function getAvailableTiers(totalPodsBuilt) {\n    return POD_TIERS.filter((tier)=>totalPodsBuilt >= tier.unlockAtTotalPods);\n}\n/**\n * Get the highest tier available\n */ function getHighestAvailableTier(totalPodsBuilt) {\n    const available = getAvailableTiers(totalPodsBuilt);\n    return available[available.length - 1] || POD_TIERS[0];\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvZGVwbG95bWVudC9wb2RUaWVycy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7O0NBR0MsR0FhRCwyQ0FBMkM7QUFDcEMsTUFBTUEsWUFBdUI7SUFDbEM7UUFDRUMsSUFBSTtRQUNKQyxPQUFPO1FBQ1BDLFNBQVM7UUFDVEMsbUJBQW1CO1FBQ25CQyxXQUFXO1FBQ1hDLGVBQWU7SUFDakI7SUFDQTtRQUNFTCxJQUFJO1FBQ0pDLE9BQU87UUFDUEMsU0FBUztRQUNUQyxtQkFBbUI7UUFDbkJDLFdBQVc7UUFDWEMsZUFBZTtJQUNqQjtJQUNBO1FBQ0VMLElBQUk7UUFDSkMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLG1CQUFtQjtRQUNuQkMsV0FBVztRQUNYQyxlQUFlO0lBQ2pCO0NBQ0QsQ0FBQztBQUVGOztDQUVDLEdBQ00sU0FBU0Msa0JBQWtCQyxjQUFzQjtJQUN0RCxPQUFPUixVQUFVUyxNQUFNLENBQUMsQ0FBQ0MsT0FBU0Ysa0JBQWtCRSxLQUFLTixpQkFBaUI7QUFDNUU7QUFFQTs7Q0FFQyxHQUNNLFNBQVNPLHdCQUF3QkgsY0FBc0I7SUFDNUQsTUFBTUksWUFBWUwsa0JBQWtCQztJQUNwQyxPQUFPSSxTQUFTLENBQUNBLFVBQVVDLE1BQU0sR0FBRyxFQUFFLElBQUliLFNBQVMsQ0FBQyxFQUFFO0FBQ3hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvZGVwbG95bWVudC9wb2RUaWVycy50cz82MmRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUG9kIFRpZXIgU3lzdGVtXG4gKiBQcm9ncmVzc2lvbiBiYXNlZCBvbiB0b3RhbCBwb2RzIGJ1aWx0LCBub3QgZGlmZmljdWx0eSBtb2Rlc1xuICovXG5cbmV4cG9ydCB0eXBlIFBvZFRpZXJJZCA9IFwidGllcjFcIiB8IFwidGllcjJcIiB8IFwidGllcjNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBQb2RUaWVyIHtcbiAgaWQ6IFBvZFRpZXJJZDtcbiAgbGFiZWw6IHN0cmluZztcbiAgcG93ZXJLVzogbnVtYmVyO1xuICB1bmxvY2tBdFRvdGFsUG9kczogbnVtYmVyO1xuICBiYXNlQ29zdE06IG51bWJlcjsgLy8gcGVyIHBvZCBpbiAkTVxuICBiYXNlQnVpbGREYXlzOiBudW1iZXI7IC8vIGluaXRpYWwgYnVpbGQgdGltZSBwZXIgcG9kXG59XG5cbi8vIE5FVyBQT1dFUi1GSVJTVCBQT0QgVElFUlMgKGFsbCA+PSAxMDBrVylcbmV4cG9ydCBjb25zdCBQT0RfVElFUlM6IFBvZFRpZXJbXSA9IFtcbiAge1xuICAgIGlkOiBcInRpZXIxXCIsXG4gICAgbGFiZWw6IFwiQmFzZSBQb2RcIixcbiAgICBwb3dlcktXOiAxMDAsIC8vIDEwMCBrVyBtaW5pbXVtICgyMDI1IHBoeXNpY3MgZmxvb3IpXG4gICAgdW5sb2NrQXRUb3RhbFBvZHM6IDAsXG4gICAgYmFzZUNvc3RNOiAyLCAvLyAkMk0gKEJBU0VfUE9EIGNvc3QpXG4gICAgYmFzZUJ1aWxkRGF5czogMTgwLFxuICB9LFxuICB7XG4gICAgaWQ6IFwidGllcjJcIixcbiAgICBsYWJlbDogXCJFbmhhbmNlZCBQb2RcIixcbiAgICBwb3dlcktXOiA1MDAsIC8vIDUwMCBrV1xuICAgIHVubG9ja0F0VG90YWxQb2RzOiA1MCxcbiAgICBiYXNlQ29zdE06IDUsXG4gICAgYmFzZUJ1aWxkRGF5czogMTUwLFxuICB9LFxuICB7XG4gICAgaWQ6IFwidGllcjNcIixcbiAgICBsYWJlbDogXCJIaWdoLVBvd2VyIFBvZFwiLFxuICAgIHBvd2VyS1c6IDEwMDAsIC8vIDEgTVdcbiAgICB1bmxvY2tBdFRvdGFsUG9kczogMjAwLFxuICAgIGJhc2VDb3N0TTogMTAsXG4gICAgYmFzZUJ1aWxkRGF5czogMTIwLFxuICB9LFxuXTtcblxuLyoqXG4gKiBHZXQgYXZhaWxhYmxlIHBvZCB0aWVycyBiYXNlZCBvbiB0b3RhbCBwb2RzIGJ1aWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdmFpbGFibGVUaWVycyh0b3RhbFBvZHNCdWlsdDogbnVtYmVyKTogUG9kVGllcltdIHtcbiAgcmV0dXJuIFBPRF9USUVSUy5maWx0ZXIoKHRpZXIpID0+IHRvdGFsUG9kc0J1aWx0ID49IHRpZXIudW5sb2NrQXRUb3RhbFBvZHMpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgaGlnaGVzdCB0aWVyIGF2YWlsYWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGlnaGVzdEF2YWlsYWJsZVRpZXIodG90YWxQb2RzQnVpbHQ6IG51bWJlcik6IFBvZFRpZXIge1xuICBjb25zdCBhdmFpbGFibGUgPSBnZXRBdmFpbGFibGVUaWVycyh0b3RhbFBvZHNCdWlsdCk7XG4gIHJldHVybiBhdmFpbGFibGVbYXZhaWxhYmxlLmxlbmd0aCAtIDFdIHx8IFBPRF9USUVSU1swXTtcbn1cblxuIl0sIm5hbWVzIjpbIlBPRF9USUVSUyIsImlkIiwibGFiZWwiLCJwb3dlcktXIiwidW5sb2NrQXRUb3RhbFBvZHMiLCJiYXNlQ29zdE0iLCJiYXNlQnVpbGREYXlzIiwiZ2V0QXZhaWxhYmxlVGllcnMiLCJ0b3RhbFBvZHNCdWlsdCIsImZpbHRlciIsInRpZXIiLCJnZXRIaWdoZXN0QXZhaWxhYmxlVGllciIsImF2YWlsYWJsZSIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/deployment/podTiers.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/factory/factoryRecipes.ts":
/*!*******************************************!*\
  !*** ./app/lib/factory/factoryRecipes.ts ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FACTORY_RECIPES: function() { return /* binding */ FACTORY_RECIPES; },\n/* harmony export */   computeBottlenecks: function() { return /* binding */ computeBottlenecks; },\n/* harmony export */   createDefaultFactoryState: function() { return /* binding */ createDefaultFactoryState; },\n/* harmony export */   runFactoryTick: function() { return /* binding */ runFactoryTick; }\n/* harmony export */ });\n/**\n * Factorio-style resource chain and recipes\n * Single source of truth for production recipes\n */ const FACTORY_RECIPES = {\n    chipFab: {\n        input: {},\n        output: {\n            chips: 200\n        }\n    },\n    rackLine: {\n        input: {\n            chips: 100\n        },\n        output: {\n            racks: 10\n        }\n    },\n    podFactory: {\n        input: {\n            chips: 300,\n            racks: 10\n        },\n        output: {\n            pods: 1\n        }\n    },\n    fuelDepot: {\n        input: {},\n        output: {\n            fuel: 50\n        }\n    },\n    launchComplex: {\n        input: {\n            pods: 1,\n            fuel: 10\n        },\n        output: {\n            orbitPods: 1\n        }\n    }\n};\nfunction createDefaultFactoryState() {\n    return {\n        lines: {\n            chipFab: 1,\n            rackLine: 1,\n            podFactory: 1,\n            fuelDepot: 1,\n            launchComplex: 1\n        },\n        maxInfraPoints: 40,\n        usedInfraPoints: 5,\n        inventory: {\n            chips: 0,\n            racks: 0,\n            pods: 0,\n            fuel: 0,\n            orbitPods: 0\n        },\n        utilization: {\n            chipFab: 0,\n            rackLine: 0,\n            podFactory: 0,\n            fuelDepot: 0,\n            launchComplex: 0\n        },\n        buffers: {\n            chips: 0,\n            racks: 0,\n            pods: 0,\n            fuel: 0,\n            orbitPods: 0\n        }\n    };\n}\n// FactoryNodeId renamed to RecipeFactoryNodeId above to avoid conflict with factoryLayout\n/**\n * Compute production for one tick (one month)\n */ function runFactoryTick(factory) {\n    let monthFraction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1.0;\n    const next = {\n        ...factory,\n        inventory: {\n            ...factory.inventory\n        },\n        buffers: {\n            ...factory.buffers\n        },\n        utilization: {\n            ...factory.utilization\n        }\n    };\n    // Process each factory node\n    const nodeOrder = [\n        \"chipFab\",\n        \"rackLine\",\n        \"podFactory\",\n        \"fuelDepot\",\n        \"launchComplex\"\n    ];\n    for (const nodeId of nodeOrder){\n        const lines = factory.lines[nodeId];\n        if (lines <= 0) {\n            next.utilization[nodeId] = 0;\n            continue;\n        }\n        const recipe = FACTORY_RECIPES[nodeId];\n        const potentialOutput = {\n            ...recipe.output\n        };\n        // Scale by lines and month fraction\n        Object.keys(potentialOutput).forEach((key)=>{\n            const resourceKey = key;\n            var _potentialOutput_resourceKey;\n            potentialOutput[resourceKey] = ((_potentialOutput_resourceKey = potentialOutput[resourceKey]) !== null && _potentialOutput_resourceKey !== void 0 ? _potentialOutput_resourceKey : 0) * lines * monthFraction;\n        });\n        // Check input constraints\n        let maxFeasibleOutput = Infinity;\n        Object.keys(recipe.input).forEach((key)=>{\n            const resourceKey = key;\n            var _recipe_input_resourceKey;\n            const required = ((_recipe_input_resourceKey = recipe.input[resourceKey]) !== null && _recipe_input_resourceKey !== void 0 ? _recipe_input_resourceKey : 0) * lines * monthFraction;\n            var _next_inventory_resourceKey;\n            const available = (_next_inventory_resourceKey = next.inventory[resourceKey]) !== null && _next_inventory_resourceKey !== void 0 ? _next_inventory_resourceKey : 0;\n            if (required > 0) {\n                const feasibleBatches = available / required;\n                var _Object_values_;\n                // Calculate how much output we can produce with available inputs\n                const outputAmount = (_Object_values_ = Object.values(potentialOutput)[0]) !== null && _Object_values_ !== void 0 ? _Object_values_ : 0;\n                maxFeasibleOutput = Math.min(maxFeasibleOutput, feasibleBatches * outputAmount);\n            }\n        });\n        if (maxFeasibleOutput === Infinity) {\n            var _Object_values_;\n            maxFeasibleOutput = (_Object_values_ = Object.values(potentialOutput)[0]) !== null && _Object_values_ !== void 0 ? _Object_values_ : 0;\n        }\n        var _Object_values_1;\n        // Calculate actual output (constrained by inputs)\n        const actualOutput = Math.max(0, Math.min(maxFeasibleOutput, (_Object_values_1 = Object.values(potentialOutput)[0]) !== null && _Object_values_1 !== void 0 ? _Object_values_1 : 0));\n        var _Object_values_2;\n        const maxPossibleOutput = (_Object_values_2 = Object.values(potentialOutput)[0]) !== null && _Object_values_2 !== void 0 ? _Object_values_2 : 0;\n        // Utilization = actual / max possible\n        next.utilization[nodeId] = maxPossibleOutput > 0 ? actualOutput / maxPossibleOutput : 0;\n        // Consume inputs\n        Object.keys(recipe.input).forEach((key)=>{\n            const resourceKey = key;\n            var _recipe_input_resourceKey;\n            const required = ((_recipe_input_resourceKey = recipe.input[resourceKey]) !== null && _recipe_input_resourceKey !== void 0 ? _recipe_input_resourceKey : 0) * lines * monthFraction;\n            var _next_inventory_resourceKey;\n            const actualConsumed = Math.min(required, (_next_inventory_resourceKey = next.inventory[resourceKey]) !== null && _next_inventory_resourceKey !== void 0 ? _next_inventory_resourceKey : 0);\n            var _next_inventory_resourceKey1;\n            next.inventory[resourceKey] = ((_next_inventory_resourceKey1 = next.inventory[resourceKey]) !== null && _next_inventory_resourceKey1 !== void 0 ? _next_inventory_resourceKey1 : 0) - actualConsumed;\n        });\n        // Add outputs\n        Object.keys(recipe.output).forEach((key)=>{\n            const resourceKey = key;\n            var _recipe_output_resourceKey;\n            const produced = ((_recipe_output_resourceKey = recipe.output[resourceKey]) !== null && _recipe_output_resourceKey !== void 0 ? _recipe_output_resourceKey : 0) * lines * monthFraction;\n            // Only add if we have enough inputs (scale down if needed)\n            const scaleFactor = maxPossibleOutput > 0 ? actualOutput / maxPossibleOutput : 0;\n            const amountToAdd = produced * scaleFactor;\n            // For discrete resources (pods, orbitPods), round to nearest integer\n            if (resourceKey === \"pods\" || resourceKey === \"orbitPods\") {\n                var _next_inventory_resourceKey;\n                next.inventory[resourceKey] = ((_next_inventory_resourceKey = next.inventory[resourceKey]) !== null && _next_inventory_resourceKey !== void 0 ? _next_inventory_resourceKey : 0) + Math.round(amountToAdd);\n            } else {\n                var _next_inventory_resourceKey1;\n                next.inventory[resourceKey] = ((_next_inventory_resourceKey1 = next.inventory[resourceKey]) !== null && _next_inventory_resourceKey1 !== void 0 ? _next_inventory_resourceKey1 : 0) + amountToAdd;\n            }\n        });\n        // Update buffers (current inventory levels)\n        next.buffers = {\n            ...next.inventory\n        };\n    }\n    // Update infra points\n    next.usedInfraPoints = Object.values(next.lines).reduce((sum, lines)=>sum + lines, 0);\n    return next;\n}\n/**\n * Compute bottlenecks\n */ function computeBottlenecks(factory) {\n    const bottlenecks = [];\n    // Map factory nodes to resources\n    const nodeToResource = {\n        chipFab: \"chips\",\n        rackLine: \"racks\",\n        podFactory: \"pods\",\n        fuelDepot: \"fuel\",\n        launchComplex: \"orbitPods\"\n    };\n    for (const [nodeId, resource] of Object.entries(nodeToResource)){\n        const utilization = factory.utilization[nodeId];\n        if (utilization > 0.95) {\n            bottlenecks.push({\n                resource: resource,\n                utilization: utilization * 100\n            });\n        }\n    }\n    return bottlenecks;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvZmFjdG9yeS9mYWN0b3J5UmVjaXBlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7OztDQUdDLEdBY00sTUFBTUEsa0JBQXVEO0lBQ2xFQyxTQUFTO1FBQ1BDLE9BQU8sQ0FBQztRQUNSQyxRQUFRO1lBQUVDLE9BQU87UUFBSTtJQUN2QjtJQUNBQyxVQUFVO1FBQ1JILE9BQU87WUFBRUUsT0FBTztRQUFJO1FBQ3BCRCxRQUFRO1lBQUVHLE9BQU87UUFBRztJQUN0QjtJQUNBQyxZQUFZO1FBQ1ZMLE9BQU87WUFBRUUsT0FBTztZQUFLRSxPQUFPO1FBQUc7UUFDL0JILFFBQVE7WUFBRUssTUFBTTtRQUFFO0lBQ3BCO0lBQ0FDLFdBQVc7UUFDVFAsT0FBTyxDQUFDO1FBQ1JDLFFBQVE7WUFBRU8sTUFBTTtRQUFHO0lBQ3JCO0lBQ0FDLGVBQWU7UUFDYlQsT0FBTztZQUFFTSxNQUFNO1lBQUdFLE1BQU07UUFBRztRQUMzQlAsUUFBUTtZQUFFUyxXQUFXO1FBQUU7SUFDekI7QUFDRixFQUFXO0FBZ0JKLFNBQVNDO0lBQ2QsT0FBTztRQUNMQyxPQUFPO1lBQ0xiLFNBQVM7WUFDVEksVUFBVTtZQUNWRSxZQUFZO1lBQ1pFLFdBQVc7WUFDWEUsZUFBZTtRQUNqQjtRQUNBSSxnQkFBZ0I7UUFDaEJDLGlCQUFpQjtRQUNqQkMsV0FBVztZQUNUYixPQUFPO1lBQ1BFLE9BQU87WUFDUEUsTUFBTTtZQUNORSxNQUFNO1lBQ05FLFdBQVc7UUFDYjtRQUNBTSxhQUFhO1lBQ1hqQixTQUFTO1lBQ1RJLFVBQVU7WUFDVkUsWUFBWTtZQUNaRSxXQUFXO1lBQ1hFLGVBQWU7UUFDakI7UUFDQVEsU0FBUztZQUNQZixPQUFPO1lBQ1BFLE9BQU87WUFDUEUsTUFBTTtZQUNORSxNQUFNO1lBQ05FLFdBQVc7UUFDYjtJQUNGO0FBQ0Y7QUFFQSwwRkFBMEY7QUFFMUY7O0NBRUMsR0FDTSxTQUFTUSxlQUNkQyxPQUFxQjtRQUNyQkMsZ0JB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QUFNLENBQUNoQixLQUFLVCxLQUFLLEVBQUVvQyxNQUFNLENBQUMsQ0FBQ0MsS0FBS3JDLFFBQVVxQyxNQUFNckMsT0FBTztJQUVyRixPQUFPUztBQUNUO0FBRUE7O0NBRUMsR0FDTSxTQUFTNkIsbUJBQW1CL0IsT0FBcUI7SUFDdEQsTUFBTWdDLGNBQTRCLEVBQUU7SUFFcEMsaUNBQWlDO0lBQy9CLE1BQU1DLGlCQUEwRDtRQUNoRXJELFNBQVM7UUFDVEksVUFBVTtRQUNWRSxZQUFZO1FBQ1pFLFdBQVc7UUFDWEUsZUFBZTtJQUNqQjtJQUVBLEtBQUssTUFBTSxDQUFDYyxRQUFROEIsU0FBUyxJQUFJM0IsT0FBTzRCLE9BQU8sQ0FBQ0YsZ0JBQWlCO1FBQy9ELE1BQU1wQyxjQUFjRyxRQUFRSCxXQUFXLENBQUNPLE9BQThCO1FBQ3RFLElBQUlQLGNBQWMsTUFBTTtZQUN0Qm1DLFlBQVlJLElBQUksQ0FBQztnQkFDZkYsVUFBVUE7Z0JBQ1ZyQyxhQUFhQSxjQUFjO1lBQzdCO1FBQ0Y7SUFDRjtJQUVBLE9BQU9tQztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvZmFjdG9yeS9mYWN0b3J5UmVjaXBlcy50cz9kNDljIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRmFjdG9yaW8tc3R5bGUgcmVzb3VyY2UgY2hhaW4gYW5kIHJlY2lwZXNcbiAqIFNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIHByb2R1Y3Rpb24gcmVjaXBlc1xuICovXG5cbmV4cG9ydCB0eXBlIFJlc291cmNlSWQgPSAnY2hpcHMnIHwgJ3JhY2tzJyB8ICdwb2RzJyB8ICdmdWVsJyB8ICdvcmJpdFBvZHMnO1xuXG5leHBvcnQgdHlwZSBSZXNvdXJjZUludmVudG9yeSA9IFJlY29yZDxSZXNvdXJjZUlkLCBudW1iZXI+O1xuXG4vLyBGYWN0b3J5Tm9kZUlkIHR5cGVzIGRpZmZlciBiZXR3ZWVuIGZpbGVzIC0gdXNlIGxvY2FsIGRlZmluaXRpb24gZm9yIHJlY2lwZXNcbmV4cG9ydCB0eXBlIFJlY2lwZUZhY3RvcnlOb2RlSWQgPSAnY2hpcEZhYicgfCAncmFja0xpbmUnIHwgJ3BvZEZhY3RvcnknIHwgJ2Z1ZWxEZXBvdCcgfCAnbGF1bmNoQ29tcGxleCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVjaXBlIHtcbiAgaW5wdXQ6IFBhcnRpYWw8UmVzb3VyY2VJbnZlbnRvcnk+O1xuICBvdXRwdXQ6IFBhcnRpYWw8UmVzb3VyY2VJbnZlbnRvcnk+O1xufVxuXG5leHBvcnQgY29uc3QgRkFDVE9SWV9SRUNJUEVTOiBSZWNvcmQ8UmVjaXBlRmFjdG9yeU5vZGVJZCwgUmVjaXBlPiA9IHtcbiAgY2hpcEZhYjoge1xuICAgIGlucHV0OiB7fSxcbiAgICBvdXRwdXQ6IHsgY2hpcHM6IDIwMCB9LCAvLyBwZXIgbGluZSBwZXIgbW9udGhcbiAgfSxcbiAgcmFja0xpbmU6IHtcbiAgICBpbnB1dDogeyBjaGlwczogMTAwIH0sXG4gICAgb3V0cHV0OiB7IHJhY2tzOiAxMCB9LFxuICB9LFxuICBwb2RGYWN0b3J5OiB7XG4gICAgaW5wdXQ6IHsgY2hpcHM6IDMwMCwgcmFja3M6IDEwIH0sXG4gICAgb3V0cHV0OiB7IHBvZHM6IDEgfSxcbiAgfSxcbiAgZnVlbERlcG90OiB7XG4gICAgaW5wdXQ6IHt9LFxuICAgIG91dHB1dDogeyBmdWVsOiA1MCB9LCAvLyB0b25zIC8gbW9udGhcbiAgfSxcbiAgbGF1bmNoQ29tcGxleDoge1xuICAgIGlucHV0OiB7IHBvZHM6IDEsIGZ1ZWw6IDEwIH0sXG4gICAgb3V0cHV0OiB7IG9yYml0UG9kczogMSB9LFxuICB9LFxufSBhcyBjb25zdDtcblxuZXhwb3J0IHR5cGUgRmFjdG9yeVN0YXRlID0ge1xuICBsaW5lczogUmVjb3JkPFJlY2lwZUZhY3RvcnlOb2RlSWQsIG51bWJlcj47IC8vIGludGVnZXIgbGluZXMsIG1pbiAwXG4gIG1heEluZnJhUG9pbnRzOiBudW1iZXI7IC8vIGUuZy4gNDBcbiAgdXNlZEluZnJhUG9pbnRzOiBudW1iZXI7IC8vIHN1bShsaW5lcylcbiAgaW52ZW50b3J5OiBSZXNvdXJjZUludmVudG9yeTtcbiAgdXRpbGl6YXRpb246IFJlY29yZDxSZWNpcGVGYWN0b3J5Tm9kZUlkLCBudW1iZXI+OyAvLyAwLTEsID4xID0gYm90dGxlbmVja1xuICBidWZmZXJzOiBSZXNvdXJjZUludmVudG9yeTsgLy8gY3VycmVudCBpbnZlbnRvcnkgbGV2ZWxzXG59O1xuXG5leHBvcnQgdHlwZSBCb3R0bGVuZWNrID0ge1xuICByZXNvdXJjZTogUmVzb3VyY2VJZDtcbiAgdXRpbGl6YXRpb246IG51bWJlcjsgLy8gMC4uPjEsID4xID0gZGVtYW5kID4gc3VwcGx5XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVmYXVsdEZhY3RvcnlTdGF0ZSgpOiBGYWN0b3J5U3RhdGUge1xuICByZXR1cm4ge1xuICAgIGxpbmVzOiB7XG4gICAgICBjaGlwRmFiOiAxLFxuICAgICAgcmFja0xpbmU6IDEsXG4gICAgICBwb2RGYWN0b3J5OiAxLFxuICAgICAgZnVlbERlcG90OiAxLFxuICAgICAgbGF1bmNoQ29tcGxleDogMSxcbiAgICB9LFxuICAgIG1heEluZnJhUG9pbnRzOiA0MCxcbiAgICB1c2VkSW5mcmFQb2ludHM6IDUsIC8vIGluaXRpYWwgNSBsaW5lc1xuICAgIGludmVudG9yeToge1xuICAgICAgY2hpcHM6IDAsXG4gICAgICByYWNrczogMCxcbiAgICAgIHBvZHM6IDAsXG4gICAgICBmdWVsOiAwLFxuICAgICAgb3JiaXRQb2RzOiAwLFxuICAgIH0sXG4gICAgdXRpbGl6YXRpb246IHtcbiAgICAgIGNoaXBGYWI6IDAsXG4gICAgICByYWNrTGluZTogMCxcbiAgICAgIHBvZEZhY3Rvcnk6IDAsXG4gICAgICBmdWVsRGVwb3Q6IDAsXG4gICAgICBsYXVuY2hDb21wbGV4OiAwLFxuICAgIH0sXG4gICAgYnVmZmVyczoge1xuICAgICAgY2hpcHM6IDAsXG4gICAgICByYWNrczogMCxcbiAgICAgIHBvZHM6IDAsXG4gICAgICBmdWVsOiAwLFxuICAgICAgb3JiaXRQb2RzOiAwLFxuICAgIH0sXG4gIH07XG59XG5cbi8vIEZhY3RvcnlOb2RlSWQgcmVuYW1lZCB0byBSZWNpcGVGYWN0b3J5Tm9kZUlkIGFib3ZlIHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggZmFjdG9yeUxheW91dFxuXG4vKipcbiAqIENvbXB1dGUgcHJvZHVjdGlvbiBmb3Igb25lIHRpY2sgKG9uZSBtb250aClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bkZhY3RvcnlUaWNrKFxuICBmYWN0b3J5OiBGYWN0b3J5U3RhdGUsXG4gIG1vbnRoRnJhY3Rpb246IG51bWJlciA9IDEuMFxuKTogRmFjdG9yeVN0YXRlIHtcbiAgY29uc3QgbmV4dDogRmFjdG9yeVN0YXRlID0ge1xuICAgIC4uLmZhY3RvcnksXG4gICAgaW52ZW50b3J5OiB7IC4uLmZhY3RvcnkuaW52ZW50b3J5IH0sXG4gICAgYnVmZmVyczogeyAuLi5mYWN0b3J5LmJ1ZmZlcnMgfSxcbiAgICB1dGlsaXphdGlvbjogeyAuLi5mYWN0b3J5LnV0aWxpemF0aW9uIH0sXG4gIH07XG5cbiAgLy8gUHJvY2VzcyBlYWNoIGZhY3Rvcnkgbm9kZVxuICBjb25zdCBub2RlT3JkZXI6IFJlY2lwZUZhY3RvcnlOb2RlSWRbXSA9IFsnY2hpcEZhYicsICdyYWNrTGluZScsICdwb2RGYWN0b3J5JywgJ2Z1ZWxEZXBvdCcsICdsYXVuY2hDb21wbGV4J107XG4gIFxuICBmb3IgKGNvbnN0IG5vZGVJZCBvZiBub2RlT3JkZXIpIHtcbiAgICBjb25zdCBsaW5lcyA9IGZhY3RvcnkubGluZXNbbm9kZUlkXTtcbiAgICBpZiAobGluZXMgPD0gMCkge1xuICAgICAgbmV4dC51dGlsaXphdGlvbltub2RlSWRdID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlY2lwZSA9IEZBQ1RPUllfUkVDSVBFU1tub2RlSWRdO1xuICAgIGNvbnN0IHBvdGVudGlhbE91dHB1dCA9IHsgLi4ucmVjaXBlLm91dHB1dCB9O1xuICAgIFxuICAgIC8vIFNjYWxlIGJ5IGxpbmVzIGFuZCBtb250aCBmcmFjdGlvblxuICAgIE9iamVjdC5rZXlzKHBvdGVudGlhbE91dHB1dCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCByZXNvdXJjZUtleSA9IGtleSBhcyBSZXNvdXJjZUlkO1xuICAgICAgcG90ZW50aWFsT3V0cHV0W3Jlc291cmNlS2V5XSA9IChwb3RlbnRpYWxPdXRwdXRbcmVzb3VyY2VLZXldID8/IDApICogbGluZXMgKiBtb250aEZyYWN0aW9uO1xuICAgIH0pO1xuXG4gICAgLy8gQ2hlY2sgaW5wdXQgY29uc3RyYWludHNcbiAgICBsZXQgbWF4RmVhc2libGVPdXRwdXQgPSBJbmZpbml0eTtcbiAgICBPYmplY3Qua2V5cyhyZWNpcGUuaW5wdXQpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgcmVzb3VyY2VLZXkgPSBrZXkgYXMgUmVzb3VyY2VJZDtcbiAgICAgIGNvbnN0IHJlcXVpcmVkID0gKHJlY2lwZS5pbnB1dFtyZXNvdXJjZUtleV0gPz8gMCkgKiBsaW5lcyAqIG1vbnRoRnJhY3Rpb247XG4gICAgICBjb25zdCBhdmFpbGFibGUgPSBuZXh0LmludmVudG9yeVtyZXNvdXJjZUtleV0gPz8gMDtcbiAgICAgIGlmIChyZXF1aXJlZCA+IDApIHtcbiAgICAgICAgY29uc3QgZmVhc2libGVCYXRjaGVzID0gYXZhaWxhYmxlIC8gcmVxdWlyZWQ7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBob3cgbXVjaCBvdXRwdXQgd2UgY2FuIHByb2R1Y2Ugd2l0aCBhdmFpbGFibGUgaW5wdXRzXG4gICAgICAgIGNvbnN0IG91dHB1dEFtb3VudCA9IE9iamVjdC52YWx1ZXMocG90ZW50aWFsT3V0cHV0KVswXSA/PyAwO1xuICAgICAgICBtYXhGZWFzaWJsZU91dHB1dCA9IE1hdGgubWluKG1heEZlYXNpYmxlT3V0cHV0LCBmZWFzaWJsZUJhdGNoZXMgKiBvdXRwdXRBbW91bnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG1heEZlYXNpYmxlT3V0cHV0ID09PSBJbmZpbml0eSkge1xuICAgICAgbWF4RmVhc2libGVPdXRwdXQgPSBPYmplY3QudmFsdWVzKHBvdGVudGlhbE91dHB1dClbMF0gPz8gMDtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgYWN0dWFsIG91dHB1dCAoY29uc3RyYWluZWQgYnkgaW5wdXRzKVxuICAgIGNvbnN0IGFjdHVhbE91dHB1dCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heEZlYXNpYmxlT3V0cHV0LCBPYmplY3QudmFsdWVzKHBvdGVudGlhbE91dHB1dClbMF0gPz8gMCkpO1xuICAgIGNvbnN0IG1heFBvc3NpYmxlT3V0cHV0ID0gT2JqZWN0LnZhbHVlcyhwb3RlbnRpYWxPdXRwdXQpWzBdID8/IDA7XG4gICAgXG4gICAgLy8gVXRpbGl6YXRpb24gPSBhY3R1YWwgLyBtYXggcG9zc2libGVcbiAgICBuZXh0LnV0aWxpemF0aW9uW25vZGVJZF0gPSBtYXhQb3NzaWJsZU91dHB1dCA+IDAgPyBhY3R1YWxPdXRwdXQgLyBtYXhQb3NzaWJsZU91dHB1dCA6IDA7XG5cbiAgICAvLyBDb25zdW1lIGlucHV0c1xuICAgIE9iamVjdC5rZXlzKHJlY2lwZS5pbnB1dCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCByZXNvdXJjZUtleSA9IGtleSBhcyBSZXNvdXJjZUlkO1xuICAgICAgY29uc3QgcmVxdWlyZWQgPSAocmVjaXBlLmlucHV0W3Jlc291cmNlS2V5XSA/PyAwKSAqIGxpbmVzICogbW9udGhGcmFjdGlvbjtcbiAgICAgIGNvbnN0IGFjdHVhbENvbnN1bWVkID0gTWF0aC5taW4ocmVxdWlyZWQsIG5leHQuaW52ZW50b3J5W3Jlc291cmNlS2V5XSA/PyAwKTtcbiAgICAgIG5leHQuaW52ZW50b3J5W3Jlc291cmNlS2V5XSA9IChuZXh0LmludmVudG9yeVtyZXNvdXJjZUtleV0gPz8gMCkgLSBhY3R1YWxDb25zdW1lZDtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBvdXRwdXRzXG4gICAgT2JqZWN0LmtleXMocmVjaXBlLm91dHB1dCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCByZXNvdXJjZUtleSA9IGtleSBhcyBSZXNvdXJjZUlkO1xuICAgICAgY29uc3QgcHJvZHVjZWQgPSAocmVjaXBlLm91dHB1dFtyZXNvdXJjZUtleV0gPz8gMCkgKiBsaW5lcyAqIG1vbnRoRnJhY3Rpb247XG4gICAgICAvLyBPbmx5IGFkZCBpZiB3ZSBoYXZlIGVub3VnaCBpbnB1dHMgKHNjYWxlIGRvd24gaWYgbmVlZGVkKVxuICAgICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBtYXhQb3NzaWJsZU91dHB1dCA+IDAgPyBhY3R1YWxPdXRwdXQgLyBtYXhQb3NzaWJsZU91dHB1dCA6IDA7XG4gICAgICBjb25zdCBhbW91bnRUb0FkZCA9IHByb2R1Y2VkICogc2NhbGVGYWN0b3I7XG4gICAgICBcbiAgICAgIC8vIEZvciBkaXNjcmV0ZSByZXNvdXJjZXMgKHBvZHMsIG9yYml0UG9kcyksIHJvdW5kIHRvIG5lYXJlc3QgaW50ZWdlclxuICAgICAgaWYgKHJlc291cmNlS2V5ID09PSAncG9kcycgfHwgcmVzb3VyY2VLZXkgPT09ICdvcmJpdFBvZHMnKSB7XG4gICAgICAgIG5leHQuaW52ZW50b3J5W3Jlc291cmNlS2V5XSA9IChuZXh0LmludmVudG9yeVtyZXNvdXJjZUtleV0gPz8gMCkgKyBNYXRoLnJvdW5kKGFtb3VudFRvQWRkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHQuaW52ZW50b3J5W3Jlc291cmNlS2V5XSA9IChuZXh0LmludmVudG9yeVtyZXNvdXJjZUtleV0gPz8gMCkgKyBhbW91bnRUb0FkZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSBidWZmZXJzIChjdXJyZW50IGludmVudG9yeSBsZXZlbHMpXG4gICAgbmV4dC5idWZmZXJzID0geyAuLi5uZXh0LmludmVudG9yeSB9O1xuICB9XG5cbiAgLy8gVXBkYXRlIGluZnJhIHBvaW50c1xuICBuZXh0LnVzZWRJbmZyYVBvaW50cyA9IE9iamVjdC52YWx1ZXMobmV4dC5saW5lcykucmVkdWNlKChzdW0sIGxpbmVzKSA9PiBzdW0gKyBsaW5lcywgMCk7XG5cbiAgcmV0dXJuIG5leHQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZSBib3R0bGVuZWNrc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUJvdHRsZW5lY2tzKGZhY3Rvcnk6IEZhY3RvcnlTdGF0ZSk6IEJvdHRsZW5lY2tbXSB7XG4gIGNvbnN0IGJvdHRsZW5lY2tzOiBCb3R0bGVuZWNrW10gPSBbXTtcbiAgXG4gIC8vIE1hcCBmYWN0b3J5IG5vZGVzIHRvIHJlc291cmNlc1xuICAgIGNvbnN0IG5vZGVUb1Jlc291cmNlOiBSZWNvcmQ8UmVjaXBlRmFjdG9yeU5vZGVJZCwgUmVzb3VyY2VJZD4gPSB7XG4gICAgY2hpcEZhYjogJ2NoaXBzJyxcbiAgICByYWNrTGluZTogJ3JhY2tzJyxcbiAgICBwb2RGYWN0b3J5OiAncG9kcycsXG4gICAgZnVlbERlcG90OiAnZnVlbCcsXG4gICAgbGF1bmNoQ29tcGxleDogJ29yYml0UG9kcycsXG4gIH07XG5cbiAgZm9yIChjb25zdCBbbm9kZUlkLCByZXNvdXJjZV0gb2YgT2JqZWN0LmVudHJpZXMobm9kZVRvUmVzb3VyY2UpKSB7XG4gICAgY29uc3QgdXRpbGl6YXRpb24gPSBmYWN0b3J5LnV0aWxpemF0aW9uW25vZGVJZCBhcyBSZWNpcGVGYWN0b3J5Tm9kZUlkXTtcbiAgICBpZiAodXRpbGl6YXRpb24gPiAwLjk1KSB7XG4gICAgICBib3R0bGVuZWNrcy5wdXNoKHtcbiAgICAgICAgcmVzb3VyY2U6IHJlc291cmNlIGFzIFJlc291cmNlSWQsXG4gICAgICAgIHV0aWxpemF0aW9uOiB1dGlsaXphdGlvbiAqIDEwMCwgLy8gQ29udmVydCB0byBwZXJjZW50YWdlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYm90dGxlbmVja3M7XG59XG5cbiJdLCJuYW1lcyI6WyJGQUNUT1JZX1JFQ0lQRVMiLCJjaGlwRmFiIiwiaW5wdXQiLCJvdXRwdXQiLCJjaGlwcyIsInJhY2tMaW5lIiwicmFja3MiLCJwb2RGYWN0b3J5IiwicG9kcyIsImZ1ZWxEZXBvdCIsImZ1ZWwiLCJsYXVuY2hDb21wbGV4Iiwib3JiaXRQb2RzIiwiY3JlYXRlRGVmYXVsdEZhY3RvcnlTdGF0ZSIsImxpbmVzIiwibWF4SW5mcmFQb2ludHMiLCJ1c2VkSW5mcmFQb2ludHMiLCJpbnZlbnRvcnkiLCJ1dGlsaXphdGlvbiIsImJ1ZmZlcnMiLCJydW5GYWN0b3J5VGljayIsImZhY3RvcnkiLCJtb250aEZyYWN0aW9uIiwibmV4dCIsIm5vZGVPcmRlciIsIm5vZGVJZCIsInJlY2lwZSIsInBvdGVudGlhbE91dHB1dCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwicmVzb3VyY2VLZXkiLCJtYXhGZWFzaWJsZU91dHB1dCIsIkluZmluaXR5IiwicmVxdWlyZWQiLCJhdmFpbGFibGUiLCJmZWFzaWJsZUJhdGNoZXMiLCJvdXRwdXRBbW91bnQiLCJ2YWx1ZXMiLCJNYXRoIiwibWluIiwiYWN0dWFsT3V0cHV0IiwibWF4IiwibWF4UG9zc2libGVPdXRwdXQiLCJhY3R1YWxDb25zdW1lZCIsInByb2R1Y2VkIiwic2NhbGVGYWN0b3IiLCJhbW91bnRUb0FkZCIsInJvdW5kIiwicmVkdWNlIiwic3VtIiwiY29tcHV0ZUJvdHRsZW5lY2tzIiwiYm90dGxlbmVja3MiLCJub2RlVG9SZXNvdXJjZSIsInJlc291cmNlIiwiZW50cmllcyIsInB1c2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/factory/factoryRecipes.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/launch/launchQueue.ts":
/*!***************************************!*\
  !*** ./app/lib/launch/launchQueue.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_LAUNCH_PROVIDERS: function() { return /* binding */ DEFAULT_LAUNCH_PROVIDERS; },\n/* harmony export */   calculateDeploymentRate: function() { return /* binding */ calculateDeploymentRate; },\n/* harmony export */   createDefaultLaunchState: function() { return /* binding */ createDefaultLaunchState; },\n/* harmony export */   processLaunchQueue: function() { return /* binding */ processLaunchQueue; }\n/* harmony export */ });\n/**\n * Launch queue and provider system\n */ const DEFAULT_LAUNCH_PROVIDERS = {\n    f9: {\n        id: \"f9\",\n        podsPerLaunch: 1,\n        launchesPerMonth: 4\n    },\n    starship: {\n        id: \"starship\",\n        podsPerLaunch: 5,\n        launchesPerMonth: 12\n    },\n    smallLift: {\n        id: \"smallLift\",\n        podsPerLaunch: 1,\n        launchesPerMonth: 2\n    }\n};\nfunction createDefaultLaunchState() {\n    return {\n        providers: {\n            f9: {\n                ...DEFAULT_LAUNCH_PROVIDERS.f9,\n                enabled: true\n            },\n            starship: {\n                ...DEFAULT_LAUNCH_PROVIDERS.starship,\n                enabled: false\n            },\n            smallLift: {\n                ...DEFAULT_LAUNCH_PROVIDERS.smallLift,\n                enabled: false\n            }\n        },\n        queue: [],\n        maxQueue: 5\n    };\n}\n/**\n * Calculate deployment rate from launch providers\n */ function calculateDeploymentRate(launchState) {\n    let totalPodsPerMonth = 0;\n    for (const provider of Object.values(launchState.providers)){\n        if (provider.enabled) {\n            totalPodsPerMonth += provider.launchesPerMonth * provider.podsPerLaunch;\n        }\n    }\n    return totalPodsPerMonth;\n}\n/**\n * Process launch queue for one month\n * Returns: number of pods launched this month\n */ function processLaunchQueue(launchState, podsAvailable, fuelAvailable) {\n    let fuelPerLaunch = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 10, monthFraction = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1.0;\n    const next = {\n        ...launchState,\n        queue: (launchState.queue || []).map((item)=>({\n                ...item,\n                etaMonths: item.etaMonths - monthFraction\n            }))\n    };\n    // Remove completed launches\n    const completed = next.queue.filter((item)=>item.etaMonths <= 0).length;\n    next.queue = next.queue.filter((item)=>item.etaMonths > 0);\n    // Initialize queue if undefined\n    if (!next.queue) {\n        next.queue = [];\n    }\n    let podsLaunched = completed;\n    // Try to add new launches to queue\n    const deploymentRate = calculateDeploymentRate(launchState);\n    const maxNewLaunches = Math.floor(deploymentRate / 12); // Approximate per-month launches\n    for(let i = 0; i < maxNewLaunches; i++){\n        if (next.queue.length < next.maxQueue && podsAvailable >= 1 && fuelAvailable >= fuelPerLaunch) {\n            next.queue.push({\n                id: \"launch_\".concat(Date.now(), \"_\").concat(Math.random()),\n                etaMonths: 6\n            });\n            podsAvailable -= 1;\n            fuelAvailable -= fuelPerLaunch;\n        }\n    }\n    return {\n        newState: next,\n        podsLaunched\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvbGF1bmNoL2xhdW5jaFF1ZXVlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Q0FFQyxHQXNCTSxNQUFNQSwyQkFBc0Y7SUFDakdDLElBQUk7UUFDRkMsSUFBSTtRQUNKQyxlQUFlO1FBQ2ZDLGtCQUFrQjtJQUNwQjtJQUNBQyxVQUFVO1FBQ1JILElBQUk7UUFDSkMsZUFBZTtRQUNmQyxrQkFBa0I7SUFDcEI7SUFDQUUsV0FBVztRQUNUSixJQUFJO1FBQ0pDLGVBQWU7UUFDZkMsa0JBQWtCO0lBQ3BCO0FBQ0YsRUFBRTtBQUVLLFNBQVNHO0lBQ2QsT0FBTztRQUNMQyxXQUFXO1lBQ1RQLElBQUk7Z0JBQUUsR0FBR0QseUJBQXlCQyxFQUFFO2dCQUFFUSxTQUFTO1lBQUs7WUFDcERKLFVBQVU7Z0JBQUUsR0FBR0wseUJBQXlCSyxRQUFRO2dCQUFFSSxTQUFTO1lBQU07WUFDakVILFdBQVc7Z0JBQUUsR0FBR04seUJBQXlCTSxTQUFTO2dCQUFFRyxTQUFTO1lBQU07UUFDckU7UUFDQUMsT0FBTyxFQUFFO1FBQ1RDLFVBQVU7SUFDWjtBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTQyx3QkFBd0JDLFdBQXdCO0lBQzlELElBQUlDLG9CQUFvQjtJQUN4QixLQUFLLE1BQU1DLFlBQVlDLE9BQU9DLE1BQU0sQ0FBQ0osWUFBWUwsU0FBUyxFQUFHO1FBQzNELElBQUlPLFNBQVNOLE9BQU8sRUFBRTtZQUNwQksscUJBQXFCQyxTQUFTWCxnQkFBZ0IsR0FBR1csU0FBU1osYUFBYTtRQUN6RTtJQUNGO0lBQ0EsT0FBT1c7QUFDVDtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNJLG1CQUNkTCxXQUF3QixFQUN4Qk0sYUFBcUIsRUFDckJDLGFBQXFCO1FBQ3JCQyxnQkFBQUEsaUVBQXdCLElBQ3hCQyxnQkFBQUEsaUVBQXdCO0lBRXhCLE1BQU1DLE9BQW9CO1FBQ3hCLEdBQUdWLFdBQVc7UUFDZEgsT0FBTyxDQUFDRyxZQUFZSCxLQUFLLElBQUksRUFBRSxFQUFFYyxHQUFHLENBQUNDLENBQUFBLE9BQVM7Z0JBQUUsR0FBR0EsSUFBSTtnQkFBRUMsV0FBV0QsS0FBS0MsU0FBUyxHQUFHSjtZQUFjO0lBQ3JHO0lBRUEsNEJBQTRCO0lBQzVCLE1BQU1LLFlBQVlKLEtBQUtiLEtBQUssQ0FBQ2tCLE1BQU0sQ0FBQ0gsQ0FBQUEsT0FBUUEsS0FBS0MsU0FBUyxJQUFJLEdBQUdHLE1BQU07SUFDdkVOLEtBQUtiLEtBQUssR0FBR2EsS0FBS2IsS0FBSyxDQUFDa0IsTUFBTSxDQUFDSCxDQUFBQSxPQUFRQSxLQUFLQyxTQUFTLEdBQUc7SUFFeEQsZ0NBQWdDO0lBQ2hDLElBQUksQ0FBQ0gsS0FBS2IsS0FBSyxFQUFFO1FBQ2ZhLEtBQUtiLEtBQUssR0FBRyxFQUFFO0lBQ2pCO0lBRUEsSUFBSW9CLGVBQWVIO0lBRW5CLG1DQUFtQztJQUNuQyxNQUFNSSxpQkFBaUJuQix3QkFBd0JDO0lBQy9DLE1BQU1tQixpQkFBaUJDLEtBQUtDLEtBQUssQ0FBQ0gsaUJBQWlCLEtBQUssaUNBQWlDO0lBRXpGLElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJSCxnQkFBZ0JHLElBQUs7UUFDdkMsSUFDRVosS0FBS2IsS0FBSyxDQUFDbUIsTUFBTSxHQUFHTixLQUFLWixRQUFRLElBQ2pDUSxpQkFBaUIsS0FDakJDLGlCQUFpQkMsZUFDakI7WUFDQUUsS0FBS2IsS0FBSyxDQUFDMEIsSUFBSSxDQUFDO2dCQUNkbEMsSUFBSSxVQUF3QitCLE9BQWRJLEtBQUtDLEdBQUcsSUFBRyxLQUFpQixPQUFkTCxLQUFLTSxNQUFNO2dCQUN2Q2IsV0FBVztZQUNiO1lBQ0FQLGlCQUFpQjtZQUNqQkMsaUJBQWlCQztRQUNuQjtJQUNGO0lBRUEsT0FBTztRQUFFbUIsVUFBVWpCO1FBQU1PO0lBQWE7QUFDeEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9sYXVuY2gvbGF1bmNoUXVldWUudHM/YTg2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExhdW5jaCBxdWV1ZSBhbmQgcHJvdmlkZXIgc3lzdGVtXG4gKi9cblxuZXhwb3J0IHR5cGUgTGF1bmNoUHJvdmlkZXJJZCA9ICdmOScgfCAnc3RhcnNoaXAnIHwgJ3NtYWxsTGlmdCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGF1bmNoUHJvdmlkZXIge1xuICBpZDogTGF1bmNoUHJvdmlkZXJJZDtcbiAgZW5hYmxlZDogYm9vbGVhbjtcbiAgcG9kc1BlckxhdW5jaDogbnVtYmVyO1xuICBsYXVuY2hlc1Blck1vbnRoOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGF1bmNoUXVldWVJdGVtIHtcbiAgaWQ6IHN0cmluZztcbiAgZXRhTW9udGhzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGF1bmNoU3RhdGUge1xuICBwcm92aWRlcnM6IFJlY29yZDxMYXVuY2hQcm92aWRlcklkLCBMYXVuY2hQcm92aWRlcj47XG4gIHF1ZXVlOiBMYXVuY2hRdWV1ZUl0ZW1bXTtcbiAgbWF4UXVldWU6IG51bWJlcjsgLy8gZS5nLiA1IGluaXRpYWxseVxufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9MQVVOQ0hfUFJPVklERVJTOiBSZWNvcmQ8TGF1bmNoUHJvdmlkZXJJZCwgT21pdDxMYXVuY2hQcm92aWRlciwgJ2VuYWJsZWQnPj4gPSB7XG4gIGY5OiB7XG4gICAgaWQ6ICdmOScsXG4gICAgcG9kc1BlckxhdW5jaDogMSxcbiAgICBsYXVuY2hlc1Blck1vbnRoOiA0LFxuICB9LFxuICBzdGFyc2hpcDoge1xuICAgIGlkOiAnc3RhcnNoaXAnLFxuICAgIHBvZHNQZXJMYXVuY2g6IDUsXG4gICAgbGF1bmNoZXNQZXJNb250aDogMTIsXG4gIH0sXG4gIHNtYWxsTGlmdDoge1xuICAgIGlkOiAnc21hbGxMaWZ0JyxcbiAgICBwb2RzUGVyTGF1bmNoOiAxLFxuICAgIGxhdW5jaGVzUGVyTW9udGg6IDIsXG4gIH0sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVmYXVsdExhdW5jaFN0YXRlKCk6IExhdW5jaFN0YXRlIHtcbiAgcmV0dXJuIHtcbiAgICBwcm92aWRlcnM6IHtcbiAgICAgIGY5OiB7IC4uLkRFRkFVTFRfTEFVTkNIX1BST1ZJREVSUy5mOSwgZW5hYmxlZDogdHJ1ZSB9LFxuICAgICAgc3RhcnNoaXA6IHsgLi4uREVGQVVMVF9MQVVOQ0hfUFJPVklERVJTLnN0YXJzaGlwLCBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgc21hbGxMaWZ0OiB7IC4uLkRFRkFVTFRfTEFVTkNIX1BST1ZJREVSUy5zbWFsbExpZnQsIGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgfSxcbiAgICBxdWV1ZTogW10sXG4gICAgbWF4UXVldWU6IDUsXG4gIH07XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRlcGxveW1lbnQgcmF0ZSBmcm9tIGxhdW5jaCBwcm92aWRlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZURlcGxveW1lbnRSYXRlKGxhdW5jaFN0YXRlOiBMYXVuY2hTdGF0ZSk6IG51bWJlciB7XG4gIGxldCB0b3RhbFBvZHNQZXJNb250aCA9IDA7XG4gIGZvciAoY29uc3QgcHJvdmlkZXIgb2YgT2JqZWN0LnZhbHVlcyhsYXVuY2hTdGF0ZS5wcm92aWRlcnMpKSB7XG4gICAgaWYgKHByb3ZpZGVyLmVuYWJsZWQpIHtcbiAgICAgIHRvdGFsUG9kc1Blck1vbnRoICs9IHByb3ZpZGVyLmxhdW5jaGVzUGVyTW9udGggKiBwcm92aWRlci5wb2RzUGVyTGF1bmNoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG90YWxQb2RzUGVyTW9udGg7XG59XG5cbi8qKlxuICogUHJvY2VzcyBsYXVuY2ggcXVldWUgZm9yIG9uZSBtb250aFxuICogUmV0dXJuczogbnVtYmVyIG9mIHBvZHMgbGF1bmNoZWQgdGhpcyBtb250aFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0xhdW5jaFF1ZXVlKFxuICBsYXVuY2hTdGF0ZTogTGF1bmNoU3RhdGUsXG4gIHBvZHNBdmFpbGFibGU6IG51bWJlcixcbiAgZnVlbEF2YWlsYWJsZTogbnVtYmVyLFxuICBmdWVsUGVyTGF1bmNoOiBudW1iZXIgPSAxMCxcbiAgbW9udGhGcmFjdGlvbjogbnVtYmVyID0gMS4wXG4pOiB7IG5ld1N0YXRlOiBMYXVuY2hTdGF0ZTsgcG9kc0xhdW5jaGVkOiBudW1iZXIgfSB7XG4gIGNvbnN0IG5leHQ6IExhdW5jaFN0YXRlID0ge1xuICAgIC4uLmxhdW5jaFN0YXRlLFxuICAgIHF1ZXVlOiAobGF1bmNoU3RhdGUucXVldWUgfHwgW10pLm1hcChpdGVtID0+ICh7IC4uLml0ZW0sIGV0YU1vbnRoczogaXRlbS5ldGFNb250aHMgLSBtb250aEZyYWN0aW9uIH0pKSxcbiAgfTtcblxuICAvLyBSZW1vdmUgY29tcGxldGVkIGxhdW5jaGVzXG4gIGNvbnN0IGNvbXBsZXRlZCA9IG5leHQucXVldWUuZmlsdGVyKGl0ZW0gPT4gaXRlbS5ldGFNb250aHMgPD0gMCkubGVuZ3RoO1xuICBuZXh0LnF1ZXVlID0gbmV4dC5xdWV1ZS5maWx0ZXIoaXRlbSA9PiBpdGVtLmV0YU1vbnRocyA+IDApO1xuICBcbiAgLy8gSW5pdGlhbGl6ZSBxdWV1ZSBpZiB1bmRlZmluZWRcbiAgaWYgKCFuZXh0LnF1ZXVlKSB7XG4gICAgbmV4dC5xdWV1ZSA9IFtdO1xuICB9XG5cbiAgbGV0IHBvZHNMYXVuY2hlZCA9IGNvbXBsZXRlZDtcblxuICAvLyBUcnkgdG8gYWRkIG5ldyBsYXVuY2hlcyB0byBxdWV1ZVxuICBjb25zdCBkZXBsb3ltZW50UmF0ZSA9IGNhbGN1bGF0ZURlcGxveW1lbnRSYXRlKGxhdW5jaFN0YXRlKTtcbiAgY29uc3QgbWF4TmV3TGF1bmNoZXMgPSBNYXRoLmZsb29yKGRlcGxveW1lbnRSYXRlIC8gMTIpOyAvLyBBcHByb3hpbWF0ZSBwZXItbW9udGggbGF1bmNoZXNcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1heE5ld0xhdW5jaGVzOyBpKyspIHtcbiAgICBpZiAoXG4gICAgICBuZXh0LnF1ZXVlLmxlbmd0aCA8IG5leHQubWF4UXVldWUgJiZcbiAgICAgIHBvZHNBdmFpbGFibGUgPj0gMSAmJlxuICAgICAgZnVlbEF2YWlsYWJsZSA+PSBmdWVsUGVyTGF1bmNoXG4gICAgKSB7XG4gICAgICBuZXh0LnF1ZXVlLnB1c2goe1xuICAgICAgICBpZDogYGxhdW5jaF8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKX1gLFxuICAgICAgICBldGFNb250aHM6IDYsIC8vIEJhc2UgbGF1bmNoIGR1cmF0aW9uOiA2IG1vbnRoc1xuICAgICAgfSk7XG4gICAgICBwb2RzQXZhaWxhYmxlIC09IDE7XG4gICAgICBmdWVsQXZhaWxhYmxlIC09IGZ1ZWxQZXJMYXVuY2g7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgbmV3U3RhdGU6IG5leHQsIHBvZHNMYXVuY2hlZCB9O1xufVxuXG4iXSwibmFtZXMiOlsiREVGQVVMVF9MQVVOQ0hfUFJPVklERVJTIiwiZjkiLCJpZCIsInBvZHNQZXJMYXVuY2giLCJsYXVuY2hlc1Blck1vbnRoIiwic3RhcnNoaXAiLCJzbWFsbExpZnQiLCJjcmVhdGVEZWZhdWx0TGF1bmNoU3RhdGUiLCJwcm92aWRlcnMiLCJlbmFibGVkIiwicXVldWUiLCJtYXhRdWV1ZSIsImNhbGN1bGF0ZURlcGxveW1lbnRSYXRlIiwibGF1bmNoU3RhdGUiLCJ0b3RhbFBvZHNQZXJNb250aCIsInByb3ZpZGVyIiwiT2JqZWN0IiwidmFsdWVzIiwicHJvY2Vzc0xhdW5jaFF1ZXVlIiwicG9kc0F2YWlsYWJsZSIsImZ1ZWxBdmFpbGFibGUiLCJmdWVsUGVyTGF1bmNoIiwibW9udGhGcmFjdGlvbiIsIm5leHQiLCJtYXAiLCJpdGVtIiwiZXRhTW9udGhzIiwiY29tcGxldGVkIiwiZmlsdGVyIiwibGVuZ3RoIiwicG9kc0xhdW5jaGVkIiwiZGVwbG95bWVudFJhdGUiLCJtYXhOZXdMYXVuY2hlcyIsIk1hdGgiLCJmbG9vciIsImkiLCJwdXNoIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsIm5ld1N0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/launch/launchQueue.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/sim/constraints.ts":
/*!************************************!*\
  !*** ./app/lib/sim/constraints.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canAddMachineLine: function() { return /* binding */ canAddMachineLine; },\n/* harmony export */   findPlacementSpot: function() { return /* binding */ findPlacementSpot; },\n/* harmony export */   freeGridCells: function() { return /* binding */ freeGridCells; },\n/* harmony export */   occupyGridCells: function() { return /* binding */ occupyGridCells; }\n/* harmony export */ });\n/**\n * Factory constraint validation and grid management\n */ /**\n * Check if a machine line can be added given current constraints\n */ function canAddMachineLine(state, machineId) {\n    let additionalLines = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n    const machine = state.machines[machineId];\n    if (!machine) {\n        return {\n            canAdd: false,\n            reason: \"Machine not found\"\n        };\n    }\n    const constraints = state.constraints;\n    const newLines = machine.lines + additionalLines;\n    // Check workforce\n    const totalWorkersNeeded = machine.workers * newLines;\n    if (totalWorkersNeeded > constraints.workforceTotal) {\n        return {\n            canAdd: false,\n            reason: \"Not enough operators\",\n            errorType: \"workforce\"\n        };\n    }\n    // Check power\n    const totalPowerNeeded = machine.powerDrawMW * newLines;\n    if (totalPowerNeeded > constraints.powerCapacityMW) {\n        return {\n            canAdd: false,\n            reason: \"Insufficient power\",\n            errorType: \"power\"\n        };\n    }\n    // Check cooling\n    const totalCoolingNeeded = machine.heatMW * newLines;\n    if (totalCoolingNeeded > constraints.coolingCapacityMW) {\n        return {\n            canAdd: false,\n            reason: \"Insufficient cooling\",\n            errorType: \"cooling\"\n        };\n    }\n    // Check floor space\n    const footprint = machine.footprint;\n    if (!footprint || !footprint.width || !footprint.height) {\n    // Machine doesn't have footprint defined, skip space check\n    // (but still check other constraints)\n    } else {\n        const spaceNeeded = footprint.width * footprint.height * additionalLines;\n        const availableSpace = countAvailableGridCells(constraints);\n        if (spaceNeeded > availableSpace) {\n            return {\n                canAdd: false,\n                reason: \"No floor space available\",\n                errorType: \"space\"\n            };\n        }\n    }\n    return {\n        canAdd: true\n    };\n}\n/**\n * Count available grid cells\n */ function countAvailableGridCells(constraints) {\n    let count = 0;\n    for(let y = 0; y < constraints.gridHeight; y++){\n        for(let x = 0; x < constraints.gridWidth; x++){\n            if (!constraints.gridOccupied[y][x]) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n/**\n * Find a placement spot for a machine footprint\n */ function findPlacementSpot(constraints, footprint) {\n    for(let y = 0; y <= constraints.gridHeight - footprint.height; y++){\n        for(let x = 0; x <= constraints.gridWidth - footprint.width; x++){\n            // Check if this area is free\n            let isFree = true;\n            for(let dy = 0; dy < footprint.height; dy++){\n                for(let dx = 0; dx < footprint.width; dx++){\n                    if (constraints.gridOccupied[y + dy][x + dx]) {\n                        isFree = false;\n                        break;\n                    }\n                }\n                if (!isFree) break;\n            }\n            if (isFree) {\n                return {\n                    x,\n                    y\n                };\n            }\n        }\n    }\n    return null;\n}\n/**\n * Mark grid cells as occupied\n */ function occupyGridCells(constraints, x, y, footprint) {\n    for(let dy = 0; dy < footprint.height; dy++){\n        for(let dx = 0; dx < footprint.width; dx++){\n            if (y + dy < constraints.gridHeight && x + dx < constraints.gridWidth) {\n                constraints.gridOccupied[y + dy][x + dx] = true;\n            }\n        }\n    }\n}\n/**\n * Free grid cells\n */ function freeGridCells(constraints, x, y, footprint) {\n    for(let dy = 0; dy < footprint.height; dy++){\n        for(let dx = 0; dx < footprint.width; dx++){\n            if (y + dy < constraints.gridHeight && x + dx < constraints.gridWidth) {\n                constraints.gridOccupied[y + dy][x + dx] = false;\n            }\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvc2ltL2NvbnN0cmFpbnRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Q0FFQyxHQVVEOztDQUVDLEdBQ00sU0FBU0Esa0JBQ2RDLEtBQWUsRUFDZkMsU0FBb0I7UUFDcEJDLGtCQUFBQSxpRUFBMEI7SUFFMUIsTUFBTUMsVUFBVUgsTUFBTUksUUFBUSxDQUFDSCxVQUFVO0lBQ3pDLElBQUksQ0FBQ0UsU0FBUztRQUNaLE9BQU87WUFBRUUsUUFBUTtZQUFPQyxRQUFRO1FBQW9CO0lBQ3REO0lBRUEsTUFBTUMsY0FBY1AsTUFBTU8sV0FBVztJQUNyQyxNQUFNQyxXQUFXTCxRQUFRTSxLQUFLLEdBQUdQO0lBRWpDLGtCQUFrQjtJQUNsQixNQUFNUSxxQkFBcUJQLFFBQVFRLE9BQU8sR0FBR0g7SUFDN0MsSUFBSUUscUJBQXFCSCxZQUFZSyxjQUFjLEVBQUU7UUFDbkQsT0FBTztZQUNMUCxRQUFRO1lBQ1JDLFFBQVE7WUFDUk8sV0FBVztRQUNiO0lBQ0Y7SUFFQSxjQUFjO0lBQ2QsTUFBTUMsbUJBQW1CWCxRQUFRWSxXQUFXLEdBQUdQO0lBQy9DLElBQUlNLG1CQUFtQlAsWUFBWVMsZUFBZSxFQUFFO1FBQ2xELE9BQU87WUFDTFgsUUFBUTtZQUNSQyxRQUFRO1lBQ1JPLFdBQVc7UUFDYjtJQUNGO0lBRUEsZ0JBQWdCO0lBQ2hCLE1BQU1JLHFCQUFxQmQsUUFBUWUsTUFBTSxHQUFHVjtJQUM1QyxJQUFJUyxxQkFBcUJWLFlBQVlZLGlCQUFpQixFQUFFO1FBQ3RELE9BQU87WUFDTGQsUUFBUTtZQUNSQyxRQUFRO1lBQ1JPLFdBQVc7UUFDYjtJQUNGO0lBRUEsb0JBQW9CO0lBQ3BCLE1BQU1PLFlBQVlqQixRQUFRaUIsU0FBUztJQUNuQyxJQUFJLENBQUNBLGFBQWEsQ0FBQ0EsVUFBVUMsS0FBSyxJQUFJLENBQUNELFVBQVVFLE1BQU0sRUFBRTtJQUN2RCwyREFBMkQ7SUFDM0Qsc0NBQXNDO0lBQ3hDLE9BQU87UUFDTCxNQUFNQyxjQUFjSCxVQUFVQyxLQUFLLEdBQUdELFVBQVVFLE1BQU0sR0FBR3BCO1FBQ3pELE1BQU1zQixpQkFBaUJDLHdCQUF3QmxCO1FBRS9DLElBQUlnQixjQUFjQyxnQkFBZ0I7WUFDaEMsT0FBTztnQkFDTG5CLFFBQVE7Z0JBQ1JDLFFBQVE7Z0JBQ1JPLFdBQVc7WUFDYjtRQUNGO0lBQ0Y7SUFFQSxPQUFPO1FBQUVSLFFBQVE7SUFBSztBQUN4QjtBQUVBOztDQUVDLEdBQ0QsU0FBU29CLHdCQUF3QmxCLFdBQStCO0lBQzlELElBQUltQixRQUFRO0lBQ1osSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlwQixZQUFZcUIsVUFBVSxFQUFFRCxJQUFLO1FBQy9DLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJdEIsWUFBWXVCLFNBQVMsRUFBRUQsSUFBSztZQUM5QyxJQUFJLENBQUN0QixZQUFZd0IsWUFBWSxDQUFDSixFQUFFLENBQUNFLEVBQUUsRUFBRTtnQkFDbkNIO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsT0FBT0E7QUFDVDtBQUVBOztDQUVDLEdBQ00sU0FBU00sa0JBQ2R6QixXQUErQixFQUMvQmEsU0FBNEM7SUFFNUMsSUFBSyxJQUFJTyxJQUFJLEdBQUdBLEtBQUtwQixZQUFZcUIsVUFBVSxHQUFHUixVQUFVRSxNQUFNLEVBQUVLLElBQUs7UUFDbkUsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLEtBQUt0QixZQUFZdUIsU0FBUyxHQUFHVixVQUFVQyxLQUFLLEVBQUVRLElBQUs7WUFDakUsNkJBQTZCO1lBQzdCLElBQUlJLFNBQVM7WUFDYixJQUFLLElBQUlDLEtBQUssR0FBR0EsS0FBS2QsVUFBVUUsTUFBTSxFQUFFWSxLQUFNO2dCQUM1QyxJQUFLLElBQUlDLEtBQUssR0FBR0EsS0FBS2YsVUFBVUMsS0FBSyxFQUFFYyxLQUFNO29CQUMzQyxJQUFJNUIsWUFBWXdCLFlBQVksQ0FBQ0osSUFBSU8sR0FBRyxDQUFDTCxJQUFJTSxHQUFHLEVBQUU7d0JBQzVDRixTQUFTO3dCQUNUO29CQUNGO2dCQUNGO2dCQUNBLElBQUksQ0FBQ0EsUUFBUTtZQUNmO1lBRUEsSUFBSUEsUUFBUTtnQkFDVixPQUFPO29CQUFFSjtvQkFBR0Y7Z0JBQUU7WUFDaEI7UUFDRjtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBRUE7O0NBRUMsR0FDTSxTQUFTUyxnQkFDZDdCLFdBQStCLEVBQy9Cc0IsQ0FBUyxFQUNURixDQUFTLEVBQ1RQLFNBQTRDO0lBRTVDLElBQUssSUFBSWMsS0FBSyxHQUFHQSxLQUFLZCxVQUFVRSxNQUFNLEVBQUVZLEtBQU07UUFDNUMsSUFBSyxJQUFJQyxLQUFLLEdBQUdBLEtBQUtmLFVBQVVDLEtBQUssRUFBRWMsS0FBTTtZQUMzQyxJQUFJUixJQUFJTyxLQUFLM0IsWUFBWXFCLFVBQVUsSUFBSUMsSUFBSU0sS0FBSzVCLFlBQVl1QixTQUFTLEVBQUU7Z0JBQ3JFdkIsWUFBWXdCLFlBQVksQ0FBQ0osSUFBSU8sR0FBRyxDQUFDTCxJQUFJTSxHQUFHLEdBQUc7WUFDN0M7UUFDRjtJQUNGO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVNFLGNBQ2Q5QixXQUErQixFQUMvQnNCLENBQVMsRUFDVEYsQ0FBUyxFQUNUUCxTQUE0QztJQUU1QyxJQUFLLElBQUljLEtBQUssR0FBR0EsS0FBS2QsVUFBVUUsTUFBTSxFQUFFWSxLQUFNO1FBQzVDLElBQUssSUFBSUMsS0FBSyxHQUFHQSxLQUFLZixVQUFVQyxLQUFLLEVBQUVjLEtBQU07WUFDM0MsSUFBSVIsSUFBSU8sS0FBSzNCLFlBQVlxQixVQUFVLElBQUlDLElBQUlNLEtBQUs1QixZQUFZdUIsU0FBUyxFQUFFO2dCQUNyRXZCLFlBQVl3QixZQUFZLENBQUNKLElBQUlPLEdBQUcsQ0FBQ0wsSUFBSU0sR0FBRyxHQUFHO1lBQzdDO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvc2ltL2NvbnN0cmFpbnRzLnRzP2YxYmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBGYWN0b3J5IGNvbnN0cmFpbnQgdmFsaWRhdGlvbiBhbmQgZ3JpZCBtYW5hZ2VtZW50XG4gKi9cblxuaW1wb3J0IHR5cGUgeyBTaW1TdGF0ZSwgTWFjaGluZSwgTWFjaGluZUlkLCBGYWN0b3J5Q29uc3RyYWludHMgfSBmcm9tIFwiLi9tb2RlbFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbnN0cmFpbnRDaGVja1Jlc3VsdCB7XG4gIGNhbkFkZDogYm9vbGVhbjtcbiAgcmVhc29uPzogc3RyaW5nO1xuICBlcnJvclR5cGU/OiBcInBvd2VyXCIgfCBcImNvb2xpbmdcIiB8IFwid29ya2ZvcmNlXCIgfCBcInNwYWNlXCI7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBtYWNoaW5lIGxpbmUgY2FuIGJlIGFkZGVkIGdpdmVuIGN1cnJlbnQgY29uc3RyYWludHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbkFkZE1hY2hpbmVMaW5lKFxuICBzdGF0ZTogU2ltU3RhdGUsXG4gIG1hY2hpbmVJZDogTWFjaGluZUlkLFxuICBhZGRpdGlvbmFsTGluZXM6IG51bWJlciA9IDFcbik6IENvbnN0cmFpbnRDaGVja1Jlc3VsdCB7XG4gIGNvbnN0IG1hY2hpbmUgPSBzdGF0ZS5tYWNoaW5lc1ttYWNoaW5lSWRdO1xuICBpZiAoIW1hY2hpbmUpIHtcbiAgICByZXR1cm4geyBjYW5BZGQ6IGZhbHNlLCByZWFzb246IFwiTWFjaGluZSBub3QgZm91bmRcIiB9O1xuICB9XG5cbiAgY29uc3QgY29uc3RyYWludHMgPSBzdGF0ZS5jb25zdHJhaW50cztcbiAgY29uc3QgbmV3TGluZXMgPSBtYWNoaW5lLmxpbmVzICsgYWRkaXRpb25hbExpbmVzO1xuXG4gIC8vIENoZWNrIHdvcmtmb3JjZVxuICBjb25zdCB0b3RhbFdvcmtlcnNOZWVkZWQgPSBtYWNoaW5lLndvcmtlcnMgKiBuZXdMaW5lcztcbiAgaWYgKHRvdGFsV29ya2Vyc05lZWRlZCA+IGNvbnN0cmFpbnRzLndvcmtmb3JjZVRvdGFsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbkFkZDogZmFsc2UsXG4gICAgICByZWFzb246IFwiTm90IGVub3VnaCBvcGVyYXRvcnNcIixcbiAgICAgIGVycm9yVHlwZTogXCJ3b3JrZm9yY2VcIixcbiAgICB9O1xuICB9XG5cbiAgLy8gQ2hlY2sgcG93ZXJcbiAgY29uc3QgdG90YWxQb3dlck5lZWRlZCA9IG1hY2hpbmUucG93ZXJEcmF3TVcgKiBuZXdMaW5lcztcbiAgaWYgKHRvdGFsUG93ZXJOZWVkZWQgPiBjb25zdHJhaW50cy5wb3dlckNhcGFjaXR5TVcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2FuQWRkOiBmYWxzZSxcbiAgICAgIHJlYXNvbjogXCJJbnN1ZmZpY2llbnQgcG93ZXJcIixcbiAgICAgIGVycm9yVHlwZTogXCJwb3dlclwiLFxuICAgIH07XG4gIH1cblxuICAvLyBDaGVjayBjb29saW5nXG4gIGNvbnN0IHRvdGFsQ29vbGluZ05lZWRlZCA9IG1hY2hpbmUuaGVhdE1XICogbmV3TGluZXM7XG4gIGlmICh0b3RhbENvb2xpbmdOZWVkZWQgPiBjb25zdHJhaW50cy5jb29saW5nQ2FwYWNpdHlNVykge1xuICAgIHJldHVybiB7XG4gICAgICBjYW5BZGQ6IGZhbHNlLFxuICAgICAgcmVhc29uOiBcIkluc3VmZmljaWVudCBjb29saW5nXCIsXG4gICAgICBlcnJvclR5cGU6IFwiY29vbGluZ1wiLFxuICAgIH07XG4gIH1cblxuICAvLyBDaGVjayBmbG9vciBzcGFjZVxuICBjb25zdCBmb290cHJpbnQgPSBtYWNoaW5lLmZvb3RwcmludDtcbiAgaWYgKCFmb290cHJpbnQgfHwgIWZvb3RwcmludC53aWR0aCB8fCAhZm9vdHByaW50LmhlaWdodCkge1xuICAgIC8vIE1hY2hpbmUgZG9lc24ndCBoYXZlIGZvb3RwcmludCBkZWZpbmVkLCBza2lwIHNwYWNlIGNoZWNrXG4gICAgLy8gKGJ1dCBzdGlsbCBjaGVjayBvdGhlciBjb25zdHJhaW50cylcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzcGFjZU5lZWRlZCA9IGZvb3RwcmludC53aWR0aCAqIGZvb3RwcmludC5oZWlnaHQgKiBhZGRpdGlvbmFsTGluZXM7XG4gICAgY29uc3QgYXZhaWxhYmxlU3BhY2UgPSBjb3VudEF2YWlsYWJsZUdyaWRDZWxscyhjb25zdHJhaW50cyk7XG4gICAgXG4gICAgaWYgKHNwYWNlTmVlZGVkID4gYXZhaWxhYmxlU3BhY2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbkFkZDogZmFsc2UsXG4gICAgICAgIHJlYXNvbjogXCJObyBmbG9vciBzcGFjZSBhdmFpbGFibGVcIixcbiAgICAgICAgZXJyb3JUeXBlOiBcInNwYWNlXCIsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGNhbkFkZDogdHJ1ZSB9O1xufVxuXG4vKipcbiAqIENvdW50IGF2YWlsYWJsZSBncmlkIGNlbGxzXG4gKi9cbmZ1bmN0aW9uIGNvdW50QXZhaWxhYmxlR3JpZENlbGxzKGNvbnN0cmFpbnRzOiBGYWN0b3J5Q29uc3RyYWludHMpOiBudW1iZXIge1xuICBsZXQgY291bnQgPSAwO1xuICBmb3IgKGxldCB5ID0gMDsgeSA8IGNvbnN0cmFpbnRzLmdyaWRIZWlnaHQ7IHkrKykge1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgY29uc3RyYWludHMuZ3JpZFdpZHRoOyB4KyspIHtcbiAgICAgIGlmICghY29uc3RyYWludHMuZ3JpZE9jY3VwaWVkW3ldW3hdKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn1cblxuLyoqXG4gKiBGaW5kIGEgcGxhY2VtZW50IHNwb3QgZm9yIGEgbWFjaGluZSBmb290cHJpbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRQbGFjZW1lbnRTcG90KFxuICBjb25zdHJhaW50czogRmFjdG9yeUNvbnN0cmFpbnRzLFxuICBmb290cHJpbnQ6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfVxuKTogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgbnVsbCB7XG4gIGZvciAobGV0IHkgPSAwOyB5IDw9IGNvbnN0cmFpbnRzLmdyaWRIZWlnaHQgLSBmb290cHJpbnQuaGVpZ2h0OyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8PSBjb25zdHJhaW50cy5ncmlkV2lkdGggLSBmb290cHJpbnQud2lkdGg7IHgrKykge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBhcmVhIGlzIGZyZWVcbiAgICAgIGxldCBpc0ZyZWUgPSB0cnVlO1xuICAgICAgZm9yIChsZXQgZHkgPSAwOyBkeSA8IGZvb3RwcmludC5oZWlnaHQ7IGR5KyspIHtcbiAgICAgICAgZm9yIChsZXQgZHggPSAwOyBkeCA8IGZvb3RwcmludC53aWR0aDsgZHgrKykge1xuICAgICAgICAgIGlmIChjb25zdHJhaW50cy5ncmlkT2NjdXBpZWRbeSArIGR5XVt4ICsgZHhdKSB7XG4gICAgICAgICAgICBpc0ZyZWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRnJlZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChpc0ZyZWUpIHtcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBNYXJrIGdyaWQgY2VsbHMgYXMgb2NjdXBpZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9jY3VweUdyaWRDZWxscyhcbiAgY29uc3RyYWludHM6IEZhY3RvcnlDb25zdHJhaW50cyxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXIsXG4gIGZvb3RwcmludDogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9XG4pOiB2b2lkIHtcbiAgZm9yIChsZXQgZHkgPSAwOyBkeSA8IGZvb3RwcmludC5oZWlnaHQ7IGR5KyspIHtcbiAgICBmb3IgKGxldCBkeCA9IDA7IGR4IDwgZm9vdHByaW50LndpZHRoOyBkeCsrKSB7XG4gICAgICBpZiAoeSArIGR5IDwgY29uc3RyYWludHMuZ3JpZEhlaWdodCAmJiB4ICsgZHggPCBjb25zdHJhaW50cy5ncmlkV2lkdGgpIHtcbiAgICAgICAgY29uc3RyYWludHMuZ3JpZE9jY3VwaWVkW3kgKyBkeV1beCArIGR4XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRnJlZSBncmlkIGNlbGxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcmVlR3JpZENlbGxzKFxuICBjb25zdHJhaW50czogRmFjdG9yeUNvbnN0cmFpbnRzLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgZm9vdHByaW50OiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH1cbik6IHZvaWQge1xuICBmb3IgKGxldCBkeSA9IDA7IGR5IDwgZm9vdHByaW50LmhlaWdodDsgZHkrKykge1xuICAgIGZvciAobGV0IGR4ID0gMDsgZHggPCBmb290cHJpbnQud2lkdGg7IGR4KyspIHtcbiAgICAgIGlmICh5ICsgZHkgPCBjb25zdHJhaW50cy5ncmlkSGVpZ2h0ICYmIHggKyBkeCA8IGNvbnN0cmFpbnRzLmdyaWRXaWR0aCkge1xuICAgICAgICBjb25zdHJhaW50cy5ncmlkT2NjdXBpZWRbeSArIGR5XVt4ICsgZHhdID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbiJdLCJuYW1lcyI6WyJjYW5BZGRNYWNoaW5lTGluZSIsInN0YXRlIiwibWFjaGluZUlkIiwiYWRkaXRpb25hbExpbmVzIiwibWFjaGluZSIsIm1hY2hpbmVzIiwiY2FuQWRkIiwicmVhc29uIiwiY29uc3RyYWludHMiLCJuZXdMaW5lcyIsImxpbmVzIiwidG90YWxXb3JrZXJzTmVlZGVkIiwid29ya2VycyIsIndvcmtmb3JjZVRvdGFsIiwiZXJyb3JUeXBlIiwidG90YWxQb3dlck5lZWRlZCIsInBvd2VyRHJhd01XIiwicG93ZXJDYXBhY2l0eU1XIiwidG90YWxDb29saW5nTmVlZGVkIiwiaGVhdE1XIiwiY29vbGluZ0NhcGFjaXR5TVciLCJmb290cHJpbnQiLCJ3aWR0aCIsImhlaWdodCIsInNwYWNlTmVlZGVkIiwiYXZhaWxhYmxlU3BhY2UiLCJjb3VudEF2YWlsYWJsZUdyaWRDZWxscyIsImNvdW50IiwieSIsImdyaWRIZWlnaHQiLCJ4IiwiZ3JpZFdpZHRoIiwiZ3JpZE9jY3VwaWVkIiwiZmluZFBsYWNlbWVudFNwb3QiLCJpc0ZyZWUiLCJkeSIsImR4Iiwib2NjdXB5R3JpZENlbGxzIiwiZnJlZUdyaWRDZWxscyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/sim/constraints.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/sim/engine.ts":
/*!*******************************!*\
  !*** ./app/lib/sim/engine.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMachineUtilization: function() { return /* binding */ getMachineUtilization; },\n/* harmony export */   getResourceThroughput: function() { return /* binding */ getResourceThroughput; },\n/* harmony export */   stepSim: function() { return /* binding */ stepSim; }\n/* harmony export */ });\n/* harmony import */ var _orbitConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./orbitConfig */ \"(app-pages-browser)/./app/lib/sim/orbitConfig.ts\");\n/**\n * Simulation engine for Factorio-style production chain\n */ \n/**\n * Get machine utilization (0-1, can exceed 1 if bottlenecked)\n * Now considers: inputs, outputs, power, cooling, workforce\n */ function getMachineUtilization(m, resources, constraints) {\n    if (m.lines === 0) return 0;\n    // Calculate effective output rate considering upgrades\n    const speedMultiplier = 1 + m.upgrades.speedLevel * 0.2; // 20% per level\n    const effectiveOutputPerLine = m.baseOutputPerLine * speedMultiplier;\n    const maxOutputPerMin = effectiveOutputPerLine * m.lines;\n    // Check input constraints\n    let maxFeasibleOutput = Infinity;\n    for (const [resourceId, consumptionPerLine] of Object.entries(m.inputRates)){\n        const resource = resources[resourceId];\n        if (!resource) continue;\n        const efficiencyMultiplier = 1 - m.upgrades.efficiencyLevel * 0.1; // 10% reduction per level\n        const effectiveConsumption = (consumptionPerLine !== null && consumptionPerLine !== void 0 ? consumptionPerLine : 0) * efficiencyMultiplier;\n        const totalConsumptionPerMin = effectiveConsumption * m.lines;\n        if (totalConsumptionPerMin > 0) {\n            // How long can we run with current buffer?\n            const available = resource.buffer;\n            const runTimeMinutes = available / totalConsumptionPerMin;\n            const feasibleOutput = runTimeMinutes * maxOutputPerMin;\n            maxFeasibleOutput = Math.min(maxFeasibleOutput, feasibleOutput);\n        }\n    }\n    // Check constraint ratios if constraints are provided\n    if (constraints) {\n        const totalPowerNeeded = m.powerDrawMW * m.lines;\n        const powerAvailableRatio = constraints.powerCapacityMW > 0 ? Math.min(1, constraints.powerCapacityMW / totalPowerNeeded) : 0;\n        maxFeasibleOutput = Math.min(maxFeasibleOutput, maxOutputPerMin * powerAvailableRatio);\n        const totalCoolingNeeded = m.heatMW * m.lines;\n        const coolingAvailableRatio = constraints.coolingCapacityMW > 0 ? Math.min(1, constraints.coolingCapacityMW / totalCoolingNeeded) : 0;\n        maxFeasibleOutput = Math.min(maxFeasibleOutput, maxOutputPerMin * coolingAvailableRatio);\n        const totalWorkersNeeded = m.workers * m.lines;\n        const workforceAvailableRatio = constraints.workforceTotal > 0 ? Math.min(1, constraints.workforceTotal / totalWorkersNeeded) : 0;\n        maxFeasibleOutput = Math.min(maxFeasibleOutput, maxOutputPerMin * workforceAvailableRatio);\n    }\n    if (maxFeasibleOutput === Infinity) {\n        maxFeasibleOutput = maxOutputPerMin;\n    }\n    // Utilization = actual output / max possible output\n    const actualOutput = Math.min(maxFeasibleOutput, maxOutputPerMin);\n    return maxOutputPerMin > 0 ? actualOutput / maxOutputPerMin : 0;\n}\n/**\n * Step the simulation forward by dtMinutes\n */ function stepSim(state, dtMinutes) {\n    const scaledDt = dtMinutes * state.timeScale;\n    const next = {\n        ...state,\n        resources: {\n            ...state.resources\n        },\n        machines: {\n            ...state.machines\n        },\n        constraints: {\n            ...state.constraints,\n            gridOccupied: state.constraints.gridOccupied.map((row)=>[\n                    ...row\n                ])\n        }\n    };\n    // Calculate constraint usage from machines\n    let totalPowerUsed = 0;\n    let totalCoolingUsed = 0;\n    let totalWorkforceUsed = 0;\n    Object.values(next.machines).forEach((machine)=>{\n        totalPowerUsed += (machine.powerDrawMW || 0) * machine.lines;\n        totalCoolingUsed += (machine.heatMW || 0) * machine.lines;\n        totalWorkforceUsed += (machine.workers || 0) * machine.lines;\n    });\n    next.constraints.powerUsedMW = totalPowerUsed;\n    next.constraints.coolingUsedMW = totalCoolingUsed;\n    next.constraints.workforceUsed = totalWorkforceUsed;\n    // Safety checks: apply penalties if over capacity\n    const powerOverCapacity = next.constraints.powerUsedMW > next.constraints.powerCapacityMW;\n    const coolingOverCapacity = next.constraints.coolingUsedMW > next.constraints.coolingCapacityMW;\n    const workforceOverCapacity = next.constraints.workforceUsed > next.constraints.workforceTotal;\n    // Reset production/consumption rates\n    for (const resourceId of Object.keys(next.resources)){\n        next.resources[resourceId] = {\n            ...next.resources[resourceId],\n            prodPerMin: 0,\n            consPerMin: 0\n        };\n    }\n    // Generate source resources (infinite sources)\n    for (const resourceId of Object.keys(next.resources)){\n        const resource = next.resources[resourceId];\n        if (resource.isSource && resource.baseSourceRate) {\n            const sourceProd = resource.baseSourceRate * scaledDt;\n            resource.buffer += sourceProd;\n            resource.prodPerMin += resource.baseSourceRate;\n            // Clamp buffer to a reasonable maximum for visual feedback\n            if (resource.buffer > 100000) {\n                resource.buffer = 100000;\n            }\n        }\n    }\n    // Process each machine\n    for (const machineId of Object.keys(next.machines)){\n        const machine = next.machines[machineId];\n        if (machine.lines === 0) continue;\n        // Calculate effective rates with upgrades\n        const speedMultiplier = 1 + machine.upgrades.speedLevel * 0.2;\n        const efficiencyMultiplier = 1 - machine.upgrades.efficiencyLevel * 0.1;\n        const effectiveOutputPerLine = machine.baseOutputPerLine * speedMultiplier;\n        const maxOutputPerMin = effectiveOutputPerLine * machine.lines;\n        // Check input constraints\n        let maxFeasibleOutput = Infinity;\n        const inputConsumptions = [];\n        for (const [resourceId, consumptionPerLine] of Object.entries(machine.inputRates)){\n            const resource = next.resources[resourceId];\n            if (!resource || !consumptionPerLine) continue;\n            const effectiveConsumption = consumptionPerLine * efficiencyMultiplier;\n            const totalConsumptionPerMin = effectiveConsumption * machine.lines;\n            inputConsumptions.push({\n                resourceId: resourceId,\n                rate: totalConsumptionPerMin\n            });\n            if (totalConsumptionPerMin > 0) {\n                // Calculate feasible output based on available inputs\n                const available = resource.buffer;\n                const runTimeMinutes = available / totalConsumptionPerMin;\n                const feasibleOutput = runTimeMinutes * maxOutputPerMin;\n                maxFeasibleOutput = Math.min(maxFeasibleOutput, feasibleOutput);\n            }\n        }\n        if (maxFeasibleOutput === Infinity) {\n            maxFeasibleOutput = maxOutputPerMin;\n        }\n        // Get machine utilization considering constraints\n        let utilization = getMachineUtilization(machine, next.resources, next.constraints);\n        // Apply constraint penalties if over capacity\n        // Force utilization reduction if constraints are exceeded\n        const powerRatio = next.constraints.powerCapacityMW > 0 ? Math.min(1, next.constraints.powerCapacityMW / Math.max(1, totalPowerUsed)) : 1;\n        const coolingRatio = next.constraints.coolingCapacityMW > 0 ? Math.min(1, next.constraints.coolingCapacityMW / Math.max(1, totalCoolingUsed)) : 1;\n        const workforceRatio = next.constraints.workforceTotal > 0 ? Math.min(1, next.constraints.workforceTotal / Math.max(1, totalWorkforceUsed)) : 1;\n        // Apply the most restrictive constraint\n        const constraintMultiplier = Math.min(powerRatio, coolingRatio, workforceRatio);\n        utilization = utilization * constraintMultiplier;\n        // If inputs are missing, mark as starved (utilization < 0.1)\n        const hasInputs = Object.keys(machine.inputRates).length === 0 || Object.entries(machine.inputRates).some((param)=>{\n            let [resourceId] = param;\n            const resource = next.resources[resourceId];\n            return resource && resource.buffer > 0;\n        });\n        if (!hasInputs && machine.lines > 0) {\n            utilization = Math.min(utilization, 0.05); // Starved machines run at 5% max\n        }\n        // Actual output is limited by inputs and constraints\n        const actualOutputPerMin = Math.min(maxFeasibleOutput, maxOutputPerMin) * utilization;\n        // Consume inputs\n        for (const { resourceId, rate } of inputConsumptions){\n            const consumed = rate * utilization * scaledDt;\n            const resource = next.resources[resourceId];\n            if (resource) {\n                const actualConsumed = Math.min(consumed, resource.buffer);\n                resource.buffer = Math.max(0, resource.buffer - actualConsumed);\n                resource.consPerMin += rate * utilization;\n                // For source resources, don't let buffer go below a minimum threshold\n                if (resource.isSource && resource.buffer < 1000) {\n                    resource.buffer = 1000;\n                }\n            }\n        }\n        // Produce outputs\n        const produced = actualOutputPerMin * scaledDt;\n        const outputResource = next.resources[machine.outputResource];\n        if (outputResource) {\n            // For discrete resources (pods, launches), round to nearest integer\n            if (machine.outputResource === \"pods\") {\n                const podsProduced = Math.round(produced);\n                outputResource.buffer += podsProduced;\n            } else if (machine.outputResource === \"launches\") {\n                // Launches immediately become pods in orbit (no buffer accumulation)\n                // Track production rate for UI (always, even if no whole launches yet)\n                outputResource.prodPerMin += actualOutputPerMin;\n                // Only add whole launches to orbit (round down to avoid premature launches)\n                const wholeLaunches = Math.floor(produced);\n                if (wholeLaunches > 0) {\n                    next.podsInOrbit = Math.floor(next.podsInOrbit + wholeLaunches);\n                }\n            } else {\n                outputResource.buffer += produced;\n                outputResource.prodPerMin += actualOutputPerMin;\n            }\n        }\n    }\n    // Ensure buffers don't go negative (safety check)\n    for (const resourceId of Object.keys(next.resources)){\n        if (next.resources[resourceId].buffer < 0) {\n            next.resources[resourceId].buffer = 0;\n        }\n    }\n    // Apply pod degradation (3% per year)\n    // dtMinutes is in minutes, so 1 year = 365 * 24 * 60 = 525600 minutes\n    const degradationPerYear = 0.03;\n    const yearsElapsed = scaledDt / (365 * 24 * 60);\n    if (yearsElapsed > 0 && next.podsInOrbit > 0) {\n        // Degrade by 3% per year\n        const degradationFactor = Math.pow(1 - degradationPerYear, yearsElapsed);\n        next.podDegradationFactor = Math.max(0.1, next.podDegradationFactor * degradationFactor);\n    }\n    // Apply generational upgrades to orbital pod spec\n    // Each generation increases compute per pod, reduces mass/cost\n    if (next.generation > 0) {\n        const genMultiplier = Math.pow(1.5, next.generation); // 1.5x per generation\n        const costReduction = Math.pow(0.8, next.generation); // 20% cost reduction per generation\n        const massReduction = Math.pow(0.85, next.generation); // 15% mass reduction per generation\n        // Update orbital pod spec with generational improvements\n        next.orbitalPodSpec = {\n            ...next.orbitalPodSpec,\n            computeKw: _orbitConfig__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_ORBITAL_POD_SPEC.computeKw * genMultiplier,\n            capexPerPod: _orbitConfig__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_ORBITAL_POD_SPEC.capexPerPod * costReduction\n        };\n    }\n    return next;\n}\n/**\n * Get resource throughput (max of production and consumption)\n * Used for belt animation - belts should animate based on flow, not net rate\n */ function getResourceThroughput(resourceId, sim) {\n    const r = sim.resources[resourceId];\n    if (!r) return 0;\n    // \"Flow\" is the gross movement through the chain, not the net.\n    // Use max of prod and cons so belts animate even in steady-state.\n    return Math.max(r.prodPerMin, r.consPerMin, 0);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvc2ltL2VuZ2luZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0NBRUMsR0FHd0Q7QUFFekQ7OztDQUdDLEdBQ00sU0FBU0Msc0JBQ2RDLENBQVUsRUFDVkMsU0FBNEMsRUFDNUNDLFdBQWdDO0lBRWhDLElBQUlGLEVBQUVHLEtBQUssS0FBSyxHQUFHLE9BQU87SUFFMUIsdURBQXVEO0lBQ3ZELE1BQU1DLGtCQUFrQixJQUFLSixFQUFFSyxRQUFRLENBQUNDLFVBQVUsR0FBRyxLQUFNLGdCQUFnQjtJQUMzRSxNQUFNQyx5QkFBeUJQLEVBQUVRLGlCQUFpQixHQUFHSjtJQUNyRCxNQUFNSyxrQkFBa0JGLHlCQUF5QlAsRUFBRUcsS0FBSztJQUV4RCwwQkFBMEI7SUFDMUIsSUFBSU8sb0JBQW9CQztJQUV4QixLQUFLLE1BQU0sQ0FBQ0MsWUFBWUMsbUJBQW1CLElBQUlDLE9BQU9DLE9BQU8sQ0FBQ2YsRUFBRWdCLFVBQVUsRUFBRztRQUMzRSxNQUFNQyxXQUFXaEIsU0FBUyxDQUFDVyxXQUF5QjtRQUNwRCxJQUFJLENBQUNLLFVBQVU7UUFFZixNQUFNQyx1QkFBdUIsSUFBS2xCLEVBQUVLLFFBQVEsQ0FBQ2MsZUFBZSxHQUFHLEtBQU0sMEJBQTBCO1FBQy9GLE1BQU1DLHVCQUF1QixDQUFDUCwrQkFBQUEsZ0NBQUFBLHFCQUFzQixLQUFLSztRQUN6RCxNQUFNRyx5QkFBeUJELHVCQUF1QnBCLEVBQUVHLEtBQUs7UUFFN0QsSUFBSWtCLHlCQUF5QixHQUFHO1lBQzlCLDJDQUEyQztZQUMzQyxNQUFNQyxZQUFZTCxTQUFTTSxNQUFNO1lBQ2pDLE1BQU1DLGlCQUFpQkYsWUFBWUQ7WUFDbkMsTUFBTUksaUJBQWlCRCxpQkFBaUJmO1lBQ3hDQyxvQkFBb0JnQixLQUFLQyxHQUFHLENBQUNqQixtQkFBbUJlO1FBQ2xEO0lBQ0Y7SUFFQSxzREFBc0Q7SUFDdEQsSUFBSXZCLGFBQWE7UUFDZixNQUFNMEIsbUJBQW1CNUIsRUFBRTZCLFdBQVcsR0FBRzdCLEVBQUVHLEtBQUs7UUFDaEQsTUFBTTJCLHNCQUFzQjVCLFlBQVk2QixlQUFlLEdBQUcsSUFDdERMLEtBQUtDLEdBQUcsQ0FBQyxHQUFHekIsWUFBWTZCLGVBQWUsR0FBR0gsb0JBQzFDO1FBQ0psQixvQkFBb0JnQixLQUFLQyxHQUFHLENBQUNqQixtQkFBbUJELGtCQUFrQnFCO1FBRWxFLE1BQU1FLHFCQUFxQmhDLEVBQUVpQyxNQUFNLEdBQUdqQyxFQUFFRyxLQUFLO1FBQzdDLE1BQU0rQix3QkFBd0JoQyxZQUFZaUMsaUJBQWlCLEdBQUcsSUFDMURULEtBQUtDLEdBQUcsQ0FBQyxHQUFHekIsWUFBWWlDLGlCQUFpQixHQUFHSCxzQkFDNUM7UUFDSnRCLG9CQUFvQmdCLEtBQUtDLEdBQUcsQ0FBQ2pCLG1CQUFtQkQsa0JBQWtCeUI7UUFFbEUsTUFBTUUscUJBQXFCcEMsRUFBRXFDLE9BQU8sR0FBR3JDLEVBQUVHLEtBQUs7UUFDOUMsTUFBTW1DLDBCQUEwQnBDLFlBQVlxQyxjQUFjLEdBQUcsSUFDekRiLEtBQUtDLEdBQUcsQ0FBQyxHQUFHekIsWUFBWXFDLGNBQWMsR0FBR0gsc0JBQ3pDO1FBQ0oxQixvQkFBb0JnQixLQUFLQyxHQUFHLENBQUNqQixtQkFBbUJELGtCQUFrQjZCO0lBQ3BFO0lBRUEsSUFBSTVCLHNCQUFzQkMsVUFBVTtRQUNsQ0Qsb0JBQW9CRDtJQUN0QjtJQUVBLG9EQUFvRDtJQUNwRCxNQUFNK0IsZUFBZWQsS0FBS0MsR0FBRyxDQUFDakIsbUJBQW1CRDtJQUNqRCxPQUFPQSxrQkFBa0IsSUFBSStCLGVBQWUvQixrQkFBa0I7QUFDaEU7QUFFQTs7Q0FFQyxHQUNNLFNBQVNnQyxRQUFRQyxLQUFlLEVBQUVDLFNBQWlCO0lBQ3hELE1BQU1DLFdBQVdELFlBQVlELE1BQU1HLFNBQVM7SUFDNUMsTUFBTUMsT0FBaUI7UUFDckIsR0FBR0osS0FBSztRQUNSekMsV0FBVztZQUFFLEdBQUd5QyxNQUFNekMsU0FBUztRQUFDO1FBQ2hDOEMsVUFBVTtZQUFFLEdBQUdMLE1BQU1LLFFBQVE7UUFBQztRQUM5QjdDLGFBQWE7WUFDWCxHQUFHd0MsTUFBTXhDLFdBQVc7WUFDcEI4QyxjQUFjTixNQUFNeEMsV0FBVyxDQUFDOEMsWUFBWSxDQUFDQyxHQUFHLENBQUNDLENBQUFBLE1BQU87dUJBQUlBO2lCQUFJO1FBQ2xFO0lBQ0Y7SUFFQSwyQ0FBMkM7SUFDM0MsSUFBSUMsaUJBQWlCO0lBQ3JCLElBQUlDLG1CQUFtQjtJQUN2QixJQUFJQyxxQkFBcUI7SUFFekJ2QyxPQUFPd0MsTUFBTSxDQUFDUixLQUFLQyxRQUFRLEVBQUVRLE9BQU8sQ0FBQ0MsQ0FBQUE7UUFDbkNMLGtCQUFrQixDQUFDSyxRQUFRM0IsV0FBVyxJQUFJLEtBQUsyQixRQUFRckQsS0FBSztRQUM1RGlELG9CQUFvQixDQUFDSSxRQUFRdkIsTUFBTSxJQUFJLEtBQUt1QixRQUFRckQsS0FBSztRQUN6RGtELHNCQUFzQixDQUFDRyxRQUFRbkIsT0FBTyxJQUFJLEtBQUttQixRQUFRckQsS0FBSztJQUM5RDtJQUVBMkMsS0FBSzVDLFdBQVcsQ0FBQ3VELFdBQVcsR0FBR047SUFDL0JMLEtBQUs1QyxXQUFXLENBQUN3RCxhQUFhLEdBQUdOO0lBQ2pDTixLQUFLNUMsV0FBVyxDQUFDeUQsYUFBYSxHQUFHTjtJQUVqQyxrREFBa0Q7SUFDbEQsTUFBTU8sb0JBQW9CZCxLQUFLNUMsV0FBVyxDQUFDdUQsV0FBVyxHQUFHWCxLQUFLNUMsV0FBVyxDQUFDNkIsZUFBZTtJQUN6RixNQUFNOEIsc0JBQXNCZixLQUFLNUMsV0FBVyxDQUFDd0QsYUFBYSxHQUFHWixLQUFLNUMsV0FBVyxDQUFDaUMsaUJBQWlCO0lBQy9GLE1BQU0yQix3QkFBd0JoQixLQUFLNUMsV0FBVyxDQUFDeUQsYUFBYSxHQUFHYixLQUFLNUMsV0FBVyxDQUFDcUMsY0FBYztJQUU5RixxQ0FBcUM7SUFDckMsS0FBSyxNQUFNM0IsY0FBY0UsT0FBT2lELElBQUksQ0FBQ2pCLEtBQUs3QyxTQUFTLEVBQW1CO1FBQ3BFNkMsS0FBSzdDLFNBQVMsQ0FBQ1csV0FBVyxHQUFHO1lBQzNCLEdBQUdrQyxLQUFLN0MsU0FBUyxDQUFDVyxXQUFXO1lBQzdCb0QsWUFBWTtZQUNaQyxZQUFZO1FBQ2Q7SUFDRjtJQUVBLCtDQUErQztJQUMvQyxLQUFLLE1BQU1yRCxjQUFjRSxPQUFPaUQsSUFBSSxDQUFDakIsS0FBSzdDLFNBQVMsRUFBbUI7UUFDcEUsTUFBTWdCLFdBQVc2QixLQUFLN0MsU0FBUyxDQUFDVyxXQUFXO1FBQzNDLElBQUlLLFNBQVNpRCxRQUFRLElBQUlqRCxTQUFTa0QsY0FBYyxFQUFFO1lBQ2hELE1BQU1DLGFBQWFuRCxTQUFTa0QsY0FBYyxHQUFHdkI7WUFDN0MzQixTQUFTTSxNQUFNLElBQUk2QztZQUNuQm5ELFNBQVMrQyxVQUFVLElBQUkvQyxTQUFTa0QsY0FBYztZQUM5QywyREFBMkQ7WUFDM0QsSUFBSWxELFNBQVNNLE1BQU0sR0FBRyxRQUFRO2dCQUM1Qk4sU0FBU00sTUFBTSxHQUFHO1lBQ3BCO1FBQ0Y7SUFDRjtJQUVBLHVCQUF1QjtJQUN2QixLQUFLLE1BQU04QyxhQUFhdkQsT0FBT2lELElBQUksQ0FBQ2pCLEtBQUtDLFFBQVEsRUFBd0M7UUFDdkYsTUFBTVMsVUFBVVYsS0FBS0MsUUFBUSxDQUFDc0IsVUFBVTtRQUN4QyxJQUFJYixRQUFRckQsS0FBSyxLQUFLLEdBQUc7UUFFekIsMENBQTBDO1FBQzFDLE1BQU1DLGtCQUFrQixJQUFLb0QsUUFBUW5ELFFBQVEsQ0FBQ0MsVUFBVSxHQUFHO1FBQzNELE1BQU1ZLHVCQUF1QixJQUFLc0MsUUFBUW5ELFFBQVEsQ0FBQ2MsZUFBZSxHQUFHO1FBQ3JFLE1BQU1aLHlCQUF5QmlELFFBQVFoRCxpQkFBaUIsR0FBR0o7UUFDM0QsTUFBTUssa0JBQWtCRix5QkFBeUJpRCxRQUFRckQsS0FBSztRQUU5RCwwQkFBMEI7UUFDMUIsSUFBSU8sb0JBQW9CQztRQUN4QixNQUFNMkQsb0JBQXFFLEVBQUU7UUFFN0UsS0FBSyxNQUFNLENBQUMxRCxZQUFZQyxtQkFBbUIsSUFBSUMsT0FBT0MsT0FBTyxDQUFDeUMsUUFBUXhDLFVBQVUsRUFBRztZQUNqRixNQUFNQyxXQUFXNkIsS0FBSzdDLFNBQVMsQ0FBQ1csV0FBeUI7WUFDekQsSUFBSSxDQUFDSyxZQUFZLENBQUNKLG9CQUFvQjtZQUV0QyxNQUFNTyx1QkFBdUJQLHFCQUFxQks7WUFDbEQsTUFBTUcseUJBQXlCRCx1QkFBdUJvQyxRQUFRckQsS0FBSztZQUNuRW1FLGtCQUFrQkMsSUFBSSxDQUFDO2dCQUFFM0QsWUFBWUE7Z0JBQTBCNEQsTUFBTW5EO1lBQXVCO1lBRTVGLElBQUlBLHlCQUF5QixHQUFHO2dCQUM5QixzREFBc0Q7Z0JBQ3RELE1BQU1DLFlBQVlMLFNBQVNNLE1BQU07Z0JBQ2pDLE1BQU1DLGlCQUFpQkYsWUFBWUQ7Z0JBQ25DLE1BQU1JLGlCQUFpQkQsaUJBQWlCZjtnQkFDeENDLG9CQUFvQmdCLEtBQUtDLEdBQUcsQ0FBQ2pCLG1CQUFtQmU7WUFDbEQ7UUFDRjtRQUVBLElBQUlmLHNCQUFzQkMsVUFBVTtZQUNsQ0Qsb0JBQW9CRDtRQUN0QjtRQUVBLGtEQUFrRDtRQUNsRCxJQUFJZ0UsY0FBYzFFLHNCQUFzQnlELFNBQVNWLEtBQUs3QyxTQUFTLEVBQUU2QyxLQUFLNUMsV0FBVztRQUVqRiw4Q0FBOEM7UUFDOUMsMERBQTBEO1FBQzFELE1BQU13RSxhQUFhNUIsS0FBSzVDLFdBQVcsQ0FBQzZCLGVBQWUsR0FBRyxJQUNsREwsS0FBS0MsR0FBRyxDQUFDLEdBQUdtQixLQUFLNUMsV0FBVyxDQUFDNkIsZUFBZSxHQUFHTCxLQUFLaUQsR0FBRyxDQUFDLEdBQUd4QixtQkFDM0Q7UUFDSixNQUFNeUIsZUFBZTlCLEtBQUs1QyxXQUFXLENBQUNpQyxpQkFBaUIsR0FBRyxJQUN0RFQsS0FBS0MsR0FBRyxDQUFDLEdBQUdtQixLQUFLNUMsV0FBVyxDQUFDaUMsaUJBQWlCLEdBQUdULEtBQUtpRCxHQUFHLENBQUMsR0FBR3ZCLHFCQUM3RDtRQUNKLE1BQU15QixpQkFBaUIvQixLQUFLNUMsV0FBVyxDQUFDcUMsY0FBYyxHQUFHLElBQ3JEYixLQUFLQyxHQUFHLENBQUMsR0FBR21CLEtBQUs1QyxXQUFXLENBQUNxQyxjQUFjLEdBQUdiLEtBQUtpRCxHQUFHLENBQUMsR0FBR3RCLHVCQUMxRDtRQUVKLHdDQUF3QztRQUN4QyxNQUFNeUIsdUJBQXVCcEQsS0FBS0MsR0FBRyxDQUFDK0MsWUFBWUUsY0FBY0M7UUFDaEVKLGNBQWNBLGNBQWNLO1FBRTVCLDZEQUE2RDtRQUM3RCxNQUFNQyxZQUFZakUsT0FBT2lELElBQUksQ0FBQ1AsUUFBUXhDLFVBQVUsRUFBRWdFLE1BQU0sS0FBSyxLQUMzRGxFLE9BQU9DLE9BQU8sQ0FBQ3lDLFFBQVF4QyxVQUFVLEVBQUVpRSxJQUFJLENBQUM7Z0JBQUMsQ0FBQ3JFLFdBQVc7WUFDbkQsTUFBTUssV0FBVzZCLEtBQUs3QyxTQUFTLENBQUNXLFdBQXlCO1lBQ3pELE9BQU9LLFlBQVlBLFNBQVNNLE1BQU0sR0FBRztRQUN2QztRQUNGLElBQUksQ0FBQ3dELGFBQWF2QixRQUFRckQsS0FBSyxHQUFHLEdBQUc7WUFDbkNzRSxjQUFjL0MsS0FBS0MsR0FBRyxDQUFDOEMsYUFBYSxPQUFPLGlDQUFpQztRQUM5RTtRQUVBLHFEQUFxRDtRQUNyRCxNQUFNUyxxQkFBcUJ4RCxLQUFLQyxHQUFHLENBQUNqQixtQkFBbUJELG1CQUFtQmdFO1FBRTFFLGlCQUFpQjtRQUNqQixLQUFLLE1BQU0sRUFBRTdELFVBQVUsRUFBRTRELElBQUksRUFBRSxJQUFJRixrQkFBbUI7WUFDcEQsTUFBTWEsV0FBV1gsT0FBT0MsY0FBYzdCO1lBQ3RDLE1BQU0zQixXQUFXNkIsS0FBSzdDLFNBQVMsQ0FBQ1csV0FBVztZQUMzQyxJQUFJSyxVQUFVO2dCQUNaLE1BQU1tRSxpQkFBaUIxRCxLQUFLQyxHQUFHLENBQUN3RCxVQUFVbEUsU0FBU00sTUFBTTtnQkFDekROLFNBQVNNLE1BQU0sR0FBR0csS0FBS2lELEdBQUcsQ0FBQyxHQUFHMUQsU0FBU00sTUFBTSxHQUFHNkQ7Z0JBQ2hEbkUsU0FBU2dELFVBQVUsSUFBSU8sT0FBT0M7Z0JBRTlCLHNFQUFzRTtnQkFDdEUsSUFBSXhELFNBQVNpRCxRQUFRLElBQUlqRCxTQUFTTSxNQUFNLEdBQUcsTUFBTTtvQkFDL0NOLFNBQVNNLE1BQU0sR0FBRztnQkFDcEI7WUFDRjtRQUNGO1FBRUEsa0JBQWtCO1FBQ2xCLE1BQU04RCxXQUFXSCxxQkFBcUJ0QztRQUN0QyxNQUFNMEMsaUJBQWlCeEMsS0FBSzdDLFNBQVMsQ0FBQ3VELFFBQVE4QixjQUFjLENBQUM7UUFDN0QsSUFBSUEsZ0JBQWdCO1lBQ2xCLG9FQUFvRTtZQUNwRSxJQUFJOUIsUUFBUThCLGNBQWMsS0FBSyxRQUFRO2dCQUNyQyxNQUFNQyxlQUFlN0QsS0FBSzhELEtBQUssQ0FBQ0g7Z0JBQ2hDQyxlQUFlL0QsTUFBTSxJQUFJZ0U7WUFDM0IsT0FBTyxJQUFJL0IsUUFBUThCLGNBQWMsS0FBSyxZQUFZO2dCQUNoRCxxRUFBcUU7Z0JBQ3JFLHVFQUF1RTtnQkFDdkVBLGVBQWV0QixVQUFVLElBQUlrQjtnQkFFN0IsNEVBQTRFO2dCQUM1RSxNQUFNTyxnQkFBZ0IvRCxLQUFLZ0UsS0FBSyxDQUFDTDtnQkFDakMsSUFBSUksZ0JBQWdCLEdBQUc7b0JBQ3JCM0MsS0FBSzZDLFdBQVcsR0FBR2pFLEtBQUtnRSxLQUFLLENBQUM1QyxLQUFLNkMsV0FBVyxHQUFHRjtnQkFDbkQ7WUFDRixPQUFPO2dCQUNMSCxlQUFlL0QsTUFBTSxJQUFJOEQ7Z0JBQ3pCQyxlQUFldEIsVUFBVSxJQUFJa0I7WUFDL0I7UUFDRjtJQUNGO0lBRUEsa0RBQWtEO0lBQ2xELEtBQUssTUFBTXRFLGNBQWNFLE9BQU9pRCxJQUFJLENBQUNqQixLQUFLN0MsU0FBUyxFQUFtQjtRQUNwRSxJQUFJNkMsS0FBSzdDLFNBQVMsQ0FBQ1csV0FBVyxDQUFDVyxNQUFNLEdBQUcsR0FBRztZQUN6Q3VCLEtBQUs3QyxTQUFTLENBQUNXLFdBQVcsQ0FBQ1csTUFBTSxHQUFHO1FBQ3RDO0lBQ0Y7SUFFQSxzQ0FBc0M7SUFDdEMsc0VBQXNFO0lBQ3RFLE1BQU1xRSxxQkFBcUI7SUFDM0IsTUFBTUMsZUFBZWpELFdBQVksT0FBTSxLQUFLLEVBQUM7SUFDN0MsSUFBSWlELGVBQWUsS0FBSy9DLEtBQUs2QyxXQUFXLEdBQUcsR0FBRztRQUM1Qyx5QkFBeUI7UUFDekIsTUFBTUcsb0JBQW9CcEUsS0FBS3FFLEdBQUcsQ0FBQyxJQUFJSCxvQkFBb0JDO1FBQzNEL0MsS0FBS2tELG9CQUFvQixHQUFHdEUsS0FBS2lELEdBQUcsQ0FBQyxLQUFLN0IsS0FBS2tELG9CQUFvQixHQUFHRjtJQUN4RTtJQUVBLGtEQUFrRDtJQUNsRCwrREFBK0Q7SUFDL0QsSUFBSWhELEtBQUttRCxVQUFVLEdBQUcsR0FBRztRQUN2QixNQUFNQyxnQkFBZ0J4RSxLQUFLcUUsR0FBRyxDQUFDLEtBQUtqRCxLQUFLbUQsVUFBVSxHQUFHLHNCQUFzQjtRQUM1RSxNQUFNRSxnQkFBZ0J6RSxLQUFLcUUsR0FBRyxDQUFDLEtBQUtqRCxLQUFLbUQsVUFBVSxHQUFHLG9DQUFvQztRQUMxRixNQUFNRyxnQkFBZ0IxRSxLQUFLcUUsR0FBRyxDQUFDLE1BQU1qRCxLQUFLbUQsVUFBVSxHQUFHLG9DQUFvQztRQUUzRix5REFBeUQ7UUFDekRuRCxLQUFLdUQsY0FBYyxHQUFHO1lBQ3BCLEdBQUd2RCxLQUFLdUQsY0FBYztZQUN0QkMsV0FBV3hHLGtFQUF3QkEsQ0FBQ3dHLFNBQVMsR0FBR0o7WUFDaERLLGFBQWF6RyxrRUFBd0JBLENBQUN5RyxXQUFXLEdBQUdKO1FBRXREO0lBQ0Y7SUFFQSxPQUFPckQ7QUFDVDtBQUVBOzs7Q0FHQyxHQUNNLFNBQVMwRCxzQkFDZDVGLFVBQXNCLEVBQ3RCNkYsR0FBYTtJQUViLE1BQU1DLElBQUlELElBQUl4RyxTQUFTLENBQUNXLFdBQVc7SUFDbkMsSUFBSSxDQUFDOEYsR0FBRyxPQUFPO0lBQ2YsK0RBQStEO0lBQy9ELGtFQUFrRTtJQUNsRSxPQUFPaEYsS0FBS2lELEdBQUcsQ0FBQytCLEVBQUUxQyxVQUFVLEVBQUUwQyxFQUFFekMsVUFBVSxFQUFFO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvc2ltL2VuZ2luZS50cz81MWYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2ltdWxhdGlvbiBlbmdpbmUgZm9yIEZhY3RvcmlvLXN0eWxlIHByb2R1Y3Rpb24gY2hhaW5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7IFNpbVN0YXRlLCBNYWNoaW5lLCBSZXNvdXJjZUlkLCBSZXNvdXJjZVN0YXRlLCBGYWN0b3J5Q29uc3RyYWludHMgfSBmcm9tICcuL21vZGVsJztcbmltcG9ydCB7IERFRkFVTFRfT1JCSVRBTF9QT0RfU1BFQyB9IGZyb20gJy4vb3JiaXRDb25maWcnO1xuXG4vKipcbiAqIEdldCBtYWNoaW5lIHV0aWxpemF0aW9uICgwLTEsIGNhbiBleGNlZWQgMSBpZiBib3R0bGVuZWNrZWQpXG4gKiBOb3cgY29uc2lkZXJzOiBpbnB1dHMsIG91dHB1dHMsIHBvd2VyLCBjb29saW5nLCB3b3JrZm9yY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1hY2hpbmVVdGlsaXphdGlvbihcbiAgbTogTWFjaGluZSxcbiAgcmVzb3VyY2VzOiBSZWNvcmQ8UmVzb3VyY2VJZCwgUmVzb3VyY2VTdGF0ZT4sXG4gIGNvbnN0cmFpbnRzPzogRmFjdG9yeUNvbnN0cmFpbnRzXG4pOiBudW1iZXIge1xuICBpZiAobS5saW5lcyA9PT0gMCkgcmV0dXJuIDA7XG5cbiAgLy8gQ2FsY3VsYXRlIGVmZmVjdGl2ZSBvdXRwdXQgcmF0ZSBjb25zaWRlcmluZyB1cGdyYWRlc1xuICBjb25zdCBzcGVlZE11bHRpcGxpZXIgPSAxICsgKG0udXBncmFkZXMuc3BlZWRMZXZlbCAqIDAuMik7IC8vIDIwJSBwZXIgbGV2ZWxcbiAgY29uc3QgZWZmZWN0aXZlT3V0cHV0UGVyTGluZSA9IG0uYmFzZU91dHB1dFBlckxpbmUgKiBzcGVlZE11bHRpcGxpZXI7XG4gIGNvbnN0IG1heE91dHB1dFBlck1pbiA9IGVmZmVjdGl2ZU91dHB1dFBlckxpbmUgKiBtLmxpbmVzO1xuXG4gIC8vIENoZWNrIGlucHV0IGNvbnN0cmFpbnRzXG4gIGxldCBtYXhGZWFzaWJsZU91dHB1dCA9IEluZmluaXR5O1xuICBcbiAgZm9yIChjb25zdCBbcmVzb3VyY2VJZCwgY29uc3VtcHRpb25QZXJMaW5lXSBvZiBPYmplY3QuZW50cmllcyhtLmlucHV0UmF0ZXMpKSB7XG4gICAgY29uc3QgcmVzb3VyY2UgPSByZXNvdXJjZXNbcmVzb3VyY2VJZCBhcyBSZXNvdXJjZUlkXTtcbiAgICBpZiAoIXJlc291cmNlKSBjb250aW51ZTtcbiAgICBcbiAgICBjb25zdCBlZmZpY2llbmN5TXVsdGlwbGllciA9IDEgLSAobS51cGdyYWRlcy5lZmZpY2llbmN5TGV2ZWwgKiAwLjEpOyAvLyAxMCUgcmVkdWN0aW9uIHBlciBsZXZlbFxuICAgIGNvbnN0IGVmZmVjdGl2ZUNvbnN1bXB0aW9uID0gKGNvbnN1bXB0aW9uUGVyTGluZSA/PyAwKSAqIGVmZmljaWVuY3lNdWx0aXBsaWVyO1xuICAgIGNvbnN0IHRvdGFsQ29uc3VtcHRpb25QZXJNaW4gPSBlZmZlY3RpdmVDb25zdW1wdGlvbiAqIG0ubGluZXM7XG4gICAgXG4gICAgaWYgKHRvdGFsQ29uc3VtcHRpb25QZXJNaW4gPiAwKSB7XG4gICAgICAvLyBIb3cgbG9uZyBjYW4gd2UgcnVuIHdpdGggY3VycmVudCBidWZmZXI/XG4gICAgICBjb25zdCBhdmFpbGFibGUgPSByZXNvdXJjZS5idWZmZXI7XG4gICAgICBjb25zdCBydW5UaW1lTWludXRlcyA9IGF2YWlsYWJsZSAvIHRvdGFsQ29uc3VtcHRpb25QZXJNaW47XG4gICAgICBjb25zdCBmZWFzaWJsZU91dHB1dCA9IHJ1blRpbWVNaW51dGVzICogbWF4T3V0cHV0UGVyTWluO1xuICAgICAgbWF4RmVhc2libGVPdXRwdXQgPSBNYXRoLm1pbihtYXhGZWFzaWJsZU91dHB1dCwgZmVhc2libGVPdXRwdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrIGNvbnN0cmFpbnQgcmF0aW9zIGlmIGNvbnN0cmFpbnRzIGFyZSBwcm92aWRlZFxuICBpZiAoY29uc3RyYWludHMpIHtcbiAgICBjb25zdCB0b3RhbFBvd2VyTmVlZGVkID0gbS5wb3dlckRyYXdNVyAqIG0ubGluZXM7XG4gICAgY29uc3QgcG93ZXJBdmFpbGFibGVSYXRpbyA9IGNvbnN0cmFpbnRzLnBvd2VyQ2FwYWNpdHlNVyA+IDAgXG4gICAgICA/IE1hdGgubWluKDEsIGNvbnN0cmFpbnRzLnBvd2VyQ2FwYWNpdHlNVyAvIHRvdGFsUG93ZXJOZWVkZWQpXG4gICAgICA6IDA7XG4gICAgbWF4RmVhc2libGVPdXRwdXQgPSBNYXRoLm1pbihtYXhGZWFzaWJsZU91dHB1dCwgbWF4T3V0cHV0UGVyTWluICogcG93ZXJBdmFpbGFibGVSYXRpbyk7XG5cbiAgICBjb25zdCB0b3RhbENvb2xpbmdOZWVkZWQgPSBtLmhlYXRNVyAqIG0ubGluZXM7XG4gICAgY29uc3QgY29vbGluZ0F2YWlsYWJsZVJhdGlvID0gY29uc3RyYWludHMuY29vbGluZ0NhcGFjaXR5TVcgPiAwXG4gICAgICA/IE1hdGgubWluKDEsIGNvbnN0cmFpbnRzLmNvb2xpbmdDYXBhY2l0eU1XIC8gdG90YWxDb29saW5nTmVlZGVkKVxuICAgICAgOiAwO1xuICAgIG1heEZlYXNpYmxlT3V0cHV0ID0gTWF0aC5taW4obWF4RmVhc2libGVPdXRwdXQsIG1heE91dHB1dFBlck1pbiAqIGNvb2xpbmdBdmFpbGFibGVSYXRpbyk7XG5cbiAgICBjb25zdCB0b3RhbFdvcmtlcnNOZWVkZWQgPSBtLndvcmtlcnMgKiBtLmxpbmVzO1xuICAgIGNvbnN0IHdvcmtmb3JjZUF2YWlsYWJsZVJhdGlvID0gY29uc3RyYWludHMud29ya2ZvcmNlVG90YWwgPiAwXG4gICAgICA/IE1hdGgubWluKDEsIGNvbnN0cmFpbnRzLndvcmtmb3JjZVRvdGFsIC8gdG90YWxXb3JrZXJzTmVlZGVkKVxuICAgICAgOiAwO1xuICAgIG1heEZlYXNpYmxlT3V0cHV0ID0gTWF0aC5taW4obWF4RmVhc2libGVPdXRwdXQsIG1heE91dHB1dFBlck1pbiAqIHdvcmtmb3JjZUF2YWlsYWJsZVJhdGlvKTtcbiAgfVxuXG4gIGlmIChtYXhGZWFzaWJsZU91dHB1dCA9PT0gSW5maW5pdHkpIHtcbiAgICBtYXhGZWFzaWJsZU91dHB1dCA9IG1heE91dHB1dFBlck1pbjtcbiAgfVxuXG4gIC8vIFV0aWxpemF0aW9uID0gYWN0dWFsIG91dHB1dCAvIG1heCBwb3NzaWJsZSBvdXRwdXRcbiAgY29uc3QgYWN0dWFsT3V0cHV0ID0gTWF0aC5taW4obWF4RmVhc2libGVPdXRwdXQsIG1heE91dHB1dFBlck1pbik7XG4gIHJldHVybiBtYXhPdXRwdXRQZXJNaW4gPiAwID8gYWN0dWFsT3V0cHV0IC8gbWF4T3V0cHV0UGVyTWluIDogMDtcbn1cblxuLyoqXG4gKiBTdGVwIHRoZSBzaW11bGF0aW9uIGZvcndhcmQgYnkgZHRNaW51dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGVwU2ltKHN0YXRlOiBTaW1TdGF0ZSwgZHRNaW51dGVzOiBudW1iZXIpOiBTaW1TdGF0ZSB7XG4gIGNvbnN0IHNjYWxlZER0ID0gZHRNaW51dGVzICogc3RhdGUudGltZVNjYWxlO1xuICBjb25zdCBuZXh0OiBTaW1TdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICByZXNvdXJjZXM6IHsgLi4uc3RhdGUucmVzb3VyY2VzIH0sXG4gICAgbWFjaGluZXM6IHsgLi4uc3RhdGUubWFjaGluZXMgfSxcbiAgICBjb25zdHJhaW50czoge1xuICAgICAgLi4uc3RhdGUuY29uc3RyYWludHMsXG4gICAgICBncmlkT2NjdXBpZWQ6IHN0YXRlLmNvbnN0cmFpbnRzLmdyaWRPY2N1cGllZC5tYXAocm93ID0+IFsuLi5yb3ddKSwgLy8gRGVlcCBjb3B5IGdyaWRcbiAgICB9LFxuICB9O1xuXG4gIC8vIENhbGN1bGF0ZSBjb25zdHJhaW50IHVzYWdlIGZyb20gbWFjaGluZXNcbiAgbGV0IHRvdGFsUG93ZXJVc2VkID0gMDtcbiAgbGV0IHRvdGFsQ29vbGluZ1VzZWQgPSAwO1xuICBsZXQgdG90YWxXb3JrZm9yY2VVc2VkID0gMDtcblxuICBPYmplY3QudmFsdWVzKG5leHQubWFjaGluZXMpLmZvckVhY2gobWFjaGluZSA9PiB7XG4gICAgdG90YWxQb3dlclVzZWQgKz0gKG1hY2hpbmUucG93ZXJEcmF3TVcgfHwgMCkgKiBtYWNoaW5lLmxpbmVzO1xuICAgIHRvdGFsQ29vbGluZ1VzZWQgKz0gKG1hY2hpbmUuaGVhdE1XIHx8IDApICogbWFjaGluZS5saW5lcztcbiAgICB0b3RhbFdvcmtmb3JjZVVzZWQgKz0gKG1hY2hpbmUud29ya2VycyB8fCAwKSAqIG1hY2hpbmUubGluZXM7XG4gIH0pO1xuXG4gIG5leHQuY29uc3RyYWludHMucG93ZXJVc2VkTVcgPSB0b3RhbFBvd2VyVXNlZDtcbiAgbmV4dC5jb25zdHJhaW50cy5jb29saW5nVXNlZE1XID0gdG90YWxDb29saW5nVXNlZDtcbiAgbmV4dC5jb25zdHJhaW50cy53b3JrZm9yY2VVc2VkID0gdG90YWxXb3JrZm9yY2VVc2VkO1xuXG4gIC8vIFNhZmV0eSBjaGVja3M6IGFwcGx5IHBlbmFsdGllcyBpZiBvdmVyIGNhcGFjaXR5XG4gIGNvbnN0IHBvd2VyT3ZlckNhcGFjaXR5ID0gbmV4dC5jb25zdHJhaW50cy5wb3dlclVzZWRNVyA+IG5leHQuY29uc3RyYWludHMucG93ZXJDYXBhY2l0eU1XO1xuICBjb25zdCBjb29saW5nT3ZlckNhcGFjaXR5ID0gbmV4dC5jb25zdHJhaW50cy5jb29saW5nVXNlZE1XID4gbmV4dC5jb25zdHJhaW50cy5jb29saW5nQ2FwYWNpdHlNVztcbiAgY29uc3Qgd29ya2ZvcmNlT3ZlckNhcGFjaXR5ID0gbmV4dC5jb25zdHJhaW50cy53b3JrZm9yY2VVc2VkID4gbmV4dC5jb25zdHJhaW50cy53b3JrZm9yY2VUb3RhbDtcblxuICAvLyBSZXNldCBwcm9kdWN0aW9uL2NvbnN1bXB0aW9uIHJhdGVzXG4gIGZvciAoY29uc3QgcmVzb3VyY2VJZCBvZiBPYmplY3Qua2V5cyhuZXh0LnJlc291cmNlcykgYXMgUmVzb3VyY2VJZFtdKSB7XG4gICAgbmV4dC5yZXNvdXJjZXNbcmVzb3VyY2VJZF0gPSB7XG4gICAgICAuLi5uZXh0LnJlc291cmNlc1tyZXNvdXJjZUlkXSxcbiAgICAgIHByb2RQZXJNaW46IDAsXG4gICAgICBjb25zUGVyTWluOiAwLFxuICAgIH07XG4gIH1cblxuICAvLyBHZW5lcmF0ZSBzb3VyY2UgcmVzb3VyY2VzIChpbmZpbml0ZSBzb3VyY2VzKVxuICBmb3IgKGNvbnN0IHJlc291cmNlSWQgb2YgT2JqZWN0LmtleXMobmV4dC5yZXNvdXJjZXMpIGFzIFJlc291cmNlSWRbXSkge1xuICAgIGNvbnN0IHJlc291cmNlID0gbmV4dC5yZXNvdXJjZXNbcmVzb3VyY2VJZF07XG4gICAgaWYgKHJlc291cmNlLmlzU291cmNlICYmIHJlc291cmNlLmJhc2VTb3VyY2VSYXRlKSB7XG4gICAgICBjb25zdCBzb3VyY2VQcm9kID0gcmVzb3VyY2UuYmFzZVNvdXJjZVJhdGUgKiBzY2FsZWREdDtcbiAgICAgIHJlc291cmNlLmJ1ZmZlciArPSBzb3VyY2VQcm9kO1xuICAgICAgcmVzb3VyY2UucHJvZFBlck1pbiArPSByZXNvdXJjZS5iYXNlU291cmNlUmF0ZTtcbiAgICAgIC8vIENsYW1wIGJ1ZmZlciB0byBhIHJlYXNvbmFibGUgbWF4aW11bSBmb3IgdmlzdWFsIGZlZWRiYWNrXG4gICAgICBpZiAocmVzb3VyY2UuYnVmZmVyID4gMTAwMDAwKSB7XG4gICAgICAgIHJlc291cmNlLmJ1ZmZlciA9IDEwMDAwMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBQcm9jZXNzIGVhY2ggbWFjaGluZVxuICBmb3IgKGNvbnN0IG1hY2hpbmVJZCBvZiBPYmplY3Qua2V5cyhuZXh0Lm1hY2hpbmVzKSBhcyBBcnJheTxrZXlvZiB0eXBlb2YgbmV4dC5tYWNoaW5lcz4pIHtcbiAgICBjb25zdCBtYWNoaW5lID0gbmV4dC5tYWNoaW5lc1ttYWNoaW5lSWRdO1xuICAgIGlmIChtYWNoaW5lLmxpbmVzID09PSAwKSBjb250aW51ZTtcblxuICAgIC8vIENhbGN1bGF0ZSBlZmZlY3RpdmUgcmF0ZXMgd2l0aCB1cGdyYWRlc1xuICAgIGNvbnN0IHNwZWVkTXVsdGlwbGllciA9IDEgKyAobWFjaGluZS51cGdyYWRlcy5zcGVlZExldmVsICogMC4yKTtcbiAgICBjb25zdCBlZmZpY2llbmN5TXVsdGlwbGllciA9IDEgLSAobWFjaGluZS51cGdyYWRlcy5lZmZpY2llbmN5TGV2ZWwgKiAwLjEpO1xuICAgIGNvbnN0IGVmZmVjdGl2ZU91dHB1dFBlckxpbmUgPSBtYWNoaW5lLmJhc2VPdXRwdXRQZXJMaW5lICogc3BlZWRNdWx0aXBsaWVyO1xuICAgIGNvbnN0IG1heE91dHB1dFBlck1pbiA9IGVmZmVjdGl2ZU91dHB1dFBlckxpbmUgKiBtYWNoaW5lLmxpbmVzO1xuXG4gICAgLy8gQ2hlY2sgaW5wdXQgY29uc3RyYWludHNcbiAgICBsZXQgbWF4RmVhc2libGVPdXRwdXQgPSBJbmZpbml0eTtcbiAgICBjb25zdCBpbnB1dENvbnN1bXB0aW9uczogQXJyYXk8eyByZXNvdXJjZUlkOiBSZXNvdXJjZUlkOyByYXRlOiBudW1iZXIgfT4gPSBbXTtcblxuICAgIGZvciAoY29uc3QgW3Jlc291cmNlSWQsIGNvbnN1bXB0aW9uUGVyTGluZV0gb2YgT2JqZWN0LmVudHJpZXMobWFjaGluZS5pbnB1dFJhdGVzKSkge1xuICAgICAgY29uc3QgcmVzb3VyY2UgPSBuZXh0LnJlc291cmNlc1tyZXNvdXJjZUlkIGFzIFJlc291cmNlSWRdO1xuICAgICAgaWYgKCFyZXNvdXJjZSB8fCAhY29uc3VtcHRpb25QZXJMaW5lKSBjb250aW51ZTtcblxuICAgICAgY29uc3QgZWZmZWN0aXZlQ29uc3VtcHRpb24gPSBjb25zdW1wdGlvblBlckxpbmUgKiBlZmZpY2llbmN5TXVsdGlwbGllcjtcbiAgICAgIGNvbnN0IHRvdGFsQ29uc3VtcHRpb25QZXJNaW4gPSBlZmZlY3RpdmVDb25zdW1wdGlvbiAqIG1hY2hpbmUubGluZXM7XG4gICAgICBpbnB1dENvbnN1bXB0aW9ucy5wdXNoKHsgcmVzb3VyY2VJZDogcmVzb3VyY2VJZCBhcyBSZXNvdXJjZUlkLCByYXRlOiB0b3RhbENvbnN1bXB0aW9uUGVyTWluIH0pO1xuXG4gICAgICBpZiAodG90YWxDb25zdW1wdGlvblBlck1pbiA+IDApIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGZlYXNpYmxlIG91dHB1dCBiYXNlZCBvbiBhdmFpbGFibGUgaW5wdXRzXG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZSA9IHJlc291cmNlLmJ1ZmZlcjtcbiAgICAgICAgY29uc3QgcnVuVGltZU1pbnV0ZXMgPSBhdmFpbGFibGUgLyB0b3RhbENvbnN1bXB0aW9uUGVyTWluO1xuICAgICAgICBjb25zdCBmZWFzaWJsZU91dHB1dCA9IHJ1blRpbWVNaW51dGVzICogbWF4T3V0cHV0UGVyTWluO1xuICAgICAgICBtYXhGZWFzaWJsZU91dHB1dCA9IE1hdGgubWluKG1heEZlYXNpYmxlT3V0cHV0LCBmZWFzaWJsZU91dHB1dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1heEZlYXNpYmxlT3V0cHV0ID09PSBJbmZpbml0eSkge1xuICAgICAgbWF4RmVhc2libGVPdXRwdXQgPSBtYXhPdXRwdXRQZXJNaW47XG4gICAgfVxuXG4gICAgLy8gR2V0IG1hY2hpbmUgdXRpbGl6YXRpb24gY29uc2lkZXJpbmcgY29uc3RyYWludHNcbiAgICBsZXQgdXRpbGl6YXRpb24gPSBnZXRNYWNoaW5lVXRpbGl6YXRpb24obWFjaGluZSwgbmV4dC5yZXNvdXJjZXMsIG5leHQuY29uc3RyYWludHMpO1xuICAgIFxuICAgIC8vIEFwcGx5IGNvbnN0cmFpbnQgcGVuYWx0aWVzIGlmIG92ZXIgY2FwYWNpdHlcbiAgICAvLyBGb3JjZSB1dGlsaXphdGlvbiByZWR1Y3Rpb24gaWYgY29uc3RyYWludHMgYXJlIGV4Y2VlZGVkXG4gICAgY29uc3QgcG93ZXJSYXRpbyA9IG5leHQuY29uc3RyYWludHMucG93ZXJDYXBhY2l0eU1XID4gMCBcbiAgICAgID8gTWF0aC5taW4oMSwgbmV4dC5jb25zdHJhaW50cy5wb3dlckNhcGFjaXR5TVcgLyBNYXRoLm1heCgxLCB0b3RhbFBvd2VyVXNlZCkpXG4gICAgICA6IDE7XG4gICAgY29uc3QgY29vbGluZ1JhdGlvID0gbmV4dC5jb25zdHJhaW50cy5jb29saW5nQ2FwYWNpdHlNVyA+IDBcbiAgICAgID8gTWF0aC5taW4oMSwgbmV4dC5jb25zdHJhaW50cy5jb29saW5nQ2FwYWNpdHlNVyAvIE1hdGgubWF4KDEsIHRvdGFsQ29vbGluZ1VzZWQpKVxuICAgICAgOiAxO1xuICAgIGNvbnN0IHdvcmtmb3JjZVJhdGlvID0gbmV4dC5jb25zdHJhaW50cy53b3JrZm9yY2VUb3RhbCA+IDBcbiAgICAgID8gTWF0aC5taW4oMSwgbmV4dC5jb25zdHJhaW50cy53b3JrZm9yY2VUb3RhbCAvIE1hdGgubWF4KDEsIHRvdGFsV29ya2ZvcmNlVXNlZCkpXG4gICAgICA6IDE7XG4gICAgXG4gICAgLy8gQXBwbHkgdGhlIG1vc3QgcmVzdHJpY3RpdmUgY29uc3RyYWludFxuICAgIGNvbnN0IGNvbnN0cmFpbnRNdWx0aXBsaWVyID0gTWF0aC5taW4ocG93ZXJSYXRpbywgY29vbGluZ1JhdGlvLCB3b3JrZm9yY2VSYXRpbyk7XG4gICAgdXRpbGl6YXRpb24gPSB1dGlsaXphdGlvbiAqIGNvbnN0cmFpbnRNdWx0aXBsaWVyO1xuICAgIFxuICAgIC8vIElmIGlucHV0cyBhcmUgbWlzc2luZywgbWFyayBhcyBzdGFydmVkICh1dGlsaXphdGlvbiA8IDAuMSlcbiAgICBjb25zdCBoYXNJbnB1dHMgPSBPYmplY3Qua2V5cyhtYWNoaW5lLmlucHV0UmF0ZXMpLmxlbmd0aCA9PT0gMCB8fCBcbiAgICAgIE9iamVjdC5lbnRyaWVzKG1hY2hpbmUuaW5wdXRSYXRlcykuc29tZSgoW3Jlc291cmNlSWRdKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc291cmNlID0gbmV4dC5yZXNvdXJjZXNbcmVzb3VyY2VJZCBhcyBSZXNvdXJjZUlkXTtcbiAgICAgICAgcmV0dXJuIHJlc291cmNlICYmIHJlc291cmNlLmJ1ZmZlciA+IDA7XG4gICAgICB9KTtcbiAgICBpZiAoIWhhc0lucHV0cyAmJiBtYWNoaW5lLmxpbmVzID4gMCkge1xuICAgICAgdXRpbGl6YXRpb24gPSBNYXRoLm1pbih1dGlsaXphdGlvbiwgMC4wNSk7IC8vIFN0YXJ2ZWQgbWFjaGluZXMgcnVuIGF0IDUlIG1heFxuICAgIH1cblxuICAgIC8vIEFjdHVhbCBvdXRwdXQgaXMgbGltaXRlZCBieSBpbnB1dHMgYW5kIGNvbnN0cmFpbnRzXG4gICAgY29uc3QgYWN0dWFsT3V0cHV0UGVyTWluID0gTWF0aC5taW4obWF4RmVhc2libGVPdXRwdXQsIG1heE91dHB1dFBlck1pbikgKiB1dGlsaXphdGlvbjtcblxuICAgIC8vIENvbnN1bWUgaW5wdXRzXG4gICAgZm9yIChjb25zdCB7IHJlc291cmNlSWQsIHJhdGUgfSBvZiBpbnB1dENvbnN1bXB0aW9ucykge1xuICAgICAgY29uc3QgY29uc3VtZWQgPSByYXRlICogdXRpbGl6YXRpb24gKiBzY2FsZWREdDtcbiAgICAgIGNvbnN0IHJlc291cmNlID0gbmV4dC5yZXNvdXJjZXNbcmVzb3VyY2VJZF07XG4gICAgICBpZiAocmVzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgYWN0dWFsQ29uc3VtZWQgPSBNYXRoLm1pbihjb25zdW1lZCwgcmVzb3VyY2UuYnVmZmVyKTtcbiAgICAgICAgcmVzb3VyY2UuYnVmZmVyID0gTWF0aC5tYXgoMCwgcmVzb3VyY2UuYnVmZmVyIC0gYWN0dWFsQ29uc3VtZWQpO1xuICAgICAgICByZXNvdXJjZS5jb25zUGVyTWluICs9IHJhdGUgKiB1dGlsaXphdGlvbjtcbiAgICAgICAgXG4gICAgICAgIC8vIEZvciBzb3VyY2UgcmVzb3VyY2VzLCBkb24ndCBsZXQgYnVmZmVyIGdvIGJlbG93IGEgbWluaW11bSB0aHJlc2hvbGRcbiAgICAgICAgaWYgKHJlc291cmNlLmlzU291cmNlICYmIHJlc291cmNlLmJ1ZmZlciA8IDEwMDApIHtcbiAgICAgICAgICByZXNvdXJjZS5idWZmZXIgPSAxMDAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJvZHVjZSBvdXRwdXRzXG4gICAgY29uc3QgcHJvZHVjZWQgPSBhY3R1YWxPdXRwdXRQZXJNaW4gKiBzY2FsZWREdDtcbiAgICBjb25zdCBvdXRwdXRSZXNvdXJjZSA9IG5leHQucmVzb3VyY2VzW21hY2hpbmUub3V0cHV0UmVzb3VyY2VdO1xuICAgIGlmIChvdXRwdXRSZXNvdXJjZSkge1xuICAgICAgLy8gRm9yIGRpc2NyZXRlIHJlc291cmNlcyAocG9kcywgbGF1bmNoZXMpLCByb3VuZCB0byBuZWFyZXN0IGludGVnZXJcbiAgICAgIGlmIChtYWNoaW5lLm91dHB1dFJlc291cmNlID09PSAncG9kcycpIHtcbiAgICAgICAgY29uc3QgcG9kc1Byb2R1Y2VkID0gTWF0aC5yb3VuZChwcm9kdWNlZCk7XG4gICAgICAgIG91dHB1dFJlc291cmNlLmJ1ZmZlciArPSBwb2RzUHJvZHVjZWQ7XG4gICAgICB9IGVsc2UgaWYgKG1hY2hpbmUub3V0cHV0UmVzb3VyY2UgPT09ICdsYXVuY2hlcycpIHtcbiAgICAgICAgLy8gTGF1bmNoZXMgaW1tZWRpYXRlbHkgYmVjb21lIHBvZHMgaW4gb3JiaXQgKG5vIGJ1ZmZlciBhY2N1bXVsYXRpb24pXG4gICAgICAgIC8vIFRyYWNrIHByb2R1Y3Rpb24gcmF0ZSBmb3IgVUkgKGFsd2F5cywgZXZlbiBpZiBubyB3aG9sZSBsYXVuY2hlcyB5ZXQpXG4gICAgICAgIG91dHB1dFJlc291cmNlLnByb2RQZXJNaW4gKz0gYWN0dWFsT3V0cHV0UGVyTWluO1xuICAgICAgICBcbiAgICAgICAgLy8gT25seSBhZGQgd2hvbGUgbGF1bmNoZXMgdG8gb3JiaXQgKHJvdW5kIGRvd24gdG8gYXZvaWQgcHJlbWF0dXJlIGxhdW5jaGVzKVxuICAgICAgICBjb25zdCB3aG9sZUxhdW5jaGVzID0gTWF0aC5mbG9vcihwcm9kdWNlZCk7XG4gICAgICAgIGlmICh3aG9sZUxhdW5jaGVzID4gMCkge1xuICAgICAgICAgIG5leHQucG9kc0luT3JiaXQgPSBNYXRoLmZsb29yKG5leHQucG9kc0luT3JiaXQgKyB3aG9sZUxhdW5jaGVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0UmVzb3VyY2UuYnVmZmVyICs9IHByb2R1Y2VkO1xuICAgICAgICBvdXRwdXRSZXNvdXJjZS5wcm9kUGVyTWluICs9IGFjdHVhbE91dHB1dFBlck1pbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBFbnN1cmUgYnVmZmVycyBkb24ndCBnbyBuZWdhdGl2ZSAoc2FmZXR5IGNoZWNrKVxuICBmb3IgKGNvbnN0IHJlc291cmNlSWQgb2YgT2JqZWN0LmtleXMobmV4dC5yZXNvdXJjZXMpIGFzIFJlc291cmNlSWRbXSkge1xuICAgIGlmIChuZXh0LnJlc291cmNlc1tyZXNvdXJjZUlkXS5idWZmZXIgPCAwKSB7XG4gICAgICBuZXh0LnJlc291cmNlc1tyZXNvdXJjZUlkXS5idWZmZXIgPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFwcGx5IHBvZCBkZWdyYWRhdGlvbiAoMyUgcGVyIHllYXIpXG4gIC8vIGR0TWludXRlcyBpcyBpbiBtaW51dGVzLCBzbyAxIHllYXIgPSAzNjUgKiAyNCAqIDYwID0gNTI1NjAwIG1pbnV0ZXNcbiAgY29uc3QgZGVncmFkYXRpb25QZXJZZWFyID0gMC4wMztcbiAgY29uc3QgeWVhcnNFbGFwc2VkID0gc2NhbGVkRHQgLyAoMzY1ICogMjQgKiA2MCk7XG4gIGlmICh5ZWFyc0VsYXBzZWQgPiAwICYmIG5leHQucG9kc0luT3JiaXQgPiAwKSB7XG4gICAgLy8gRGVncmFkZSBieSAzJSBwZXIgeWVhclxuICAgIGNvbnN0IGRlZ3JhZGF0aW9uRmFjdG9yID0gTWF0aC5wb3coMSAtIGRlZ3JhZGF0aW9uUGVyWWVhciwgeWVhcnNFbGFwc2VkKTtcbiAgICBuZXh0LnBvZERlZ3JhZGF0aW9uRmFjdG9yID0gTWF0aC5tYXgoMC4xLCBuZXh0LnBvZERlZ3JhZGF0aW9uRmFjdG9yICogZGVncmFkYXRpb25GYWN0b3IpO1xuICB9XG5cbiAgLy8gQXBwbHkgZ2VuZXJhdGlvbmFsIHVwZ3JhZGVzIHRvIG9yYml0YWwgcG9kIHNwZWNcbiAgLy8gRWFjaCBnZW5lcmF0aW9uIGluY3JlYXNlcyBjb21wdXRlIHBlciBwb2QsIHJlZHVjZXMgbWFzcy9jb3N0XG4gIGlmIChuZXh0LmdlbmVyYXRpb24gPiAwKSB7XG4gICAgY29uc3QgZ2VuTXVsdGlwbGllciA9IE1hdGgucG93KDEuNSwgbmV4dC5nZW5lcmF0aW9uKTsgLy8gMS41eCBwZXIgZ2VuZXJhdGlvblxuICAgIGNvbnN0IGNvc3RSZWR1Y3Rpb24gPSBNYXRoLnBvdygwLjgsIG5leHQuZ2VuZXJhdGlvbik7IC8vIDIwJSBjb3N0IHJlZHVjdGlvbiBwZXIgZ2VuZXJhdGlvblxuICAgIGNvbnN0IG1hc3NSZWR1Y3Rpb24gPSBNYXRoLnBvdygwLjg1LCBuZXh0LmdlbmVyYXRpb24pOyAvLyAxNSUgbWFzcyByZWR1Y3Rpb24gcGVyIGdlbmVyYXRpb25cbiAgICBcbiAgICAvLyBVcGRhdGUgb3JiaXRhbCBwb2Qgc3BlYyB3aXRoIGdlbmVyYXRpb25hbCBpbXByb3ZlbWVudHNcbiAgICBuZXh0Lm9yYml0YWxQb2RTcGVjID0ge1xuICAgICAgLi4ubmV4dC5vcmJpdGFsUG9kU3BlYyxcbiAgICAgIGNvbXB1dGVLdzogREVGQVVMVF9PUkJJVEFMX1BPRF9TUEVDLmNvbXB1dGVLdyAqIGdlbk11bHRpcGxpZXIsXG4gICAgICBjYXBleFBlclBvZDogREVGQVVMVF9PUkJJVEFMX1BPRF9TUEVDLmNhcGV4UGVyUG9kICogY29zdFJlZHVjdGlvbixcbiAgICAgIC8vIE1hc3MgcmVkdWN0aW9uIGFmZmVjdHMgbGF1bmNoIGNvc3RzIGluZGlyZWN0bHkgKGhhbmRsZWQgaW4gZWNvbm9taWNzKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbmV4dDtcbn1cblxuLyoqXG4gKiBHZXQgcmVzb3VyY2UgdGhyb3VnaHB1dCAobWF4IG9mIHByb2R1Y3Rpb24gYW5kIGNvbnN1bXB0aW9uKVxuICogVXNlZCBmb3IgYmVsdCBhbmltYXRpb24gLSBiZWx0cyBzaG91bGQgYW5pbWF0ZSBiYXNlZCBvbiBmbG93LCBub3QgbmV0IHJhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlc291cmNlVGhyb3VnaHB1dChcbiAgcmVzb3VyY2VJZDogUmVzb3VyY2VJZCxcbiAgc2ltOiBTaW1TdGF0ZVxuKTogbnVtYmVyIHtcbiAgY29uc3QgciA9IHNpbS5yZXNvdXJjZXNbcmVzb3VyY2VJZF07XG4gIGlmICghcikgcmV0dXJuIDA7XG4gIC8vIFwiRmxvd1wiIGlzIHRoZSBncm9zcyBtb3ZlbWVudCB0aHJvdWdoIHRoZSBjaGFpbiwgbm90IHRoZSBuZXQuXG4gIC8vIFVzZSBtYXggb2YgcHJvZCBhbmQgY29ucyBzbyBiZWx0cyBhbmltYXRlIGV2ZW4gaW4gc3RlYWR5LXN0YXRlLlxuICByZXR1cm4gTWF0aC5tYXgoci5wcm9kUGVyTWluLCByLmNvbnNQZXJNaW4sIDApO1xufVxuXG4iXSwibmFtZXMiOlsiREVGQVVMVF9PUkJJVEFMX1BPRF9TUEVDIiwiZ2V0TWFjaGluZVV0aWxpemF0aW9uIiwibSIsInJlc291cmNlcyIsImNvbnN0cmFpbnRzIiwibGluZXMiLCJzcGVlZE11bHRpcGxpZXIiLCJ1cGdyYWRlcyIsInNwZWVkTGV2ZWwiLCJlZmZlY3RpdmVPdXRwdXRQZXJMaW5lIiwiYmFzZU91dHB1dFBlckxpbmUiLCJtYXhPdXRwdXRQZXJNaW4iLCJtYXhGZWFzaWJsZU91dHB1dCIsIkluZmluaXR5IiwicmVzb3VyY2VJZCIsImNvbnN1bXB0aW9uUGVyTGluZSIsIk9iamVjdCIsImVudHJpZXMiLCJpbnB1dFJhdGVzIiwicmVzb3VyY2UiLCJlZmZpY2llbmN5TXVsdGlwbGllciIsImVmZmljaWVuY3lMZXZlbCIsImVmZmVjdGl2ZUNvbnN1bXB0aW9uIiwidG90YWxDb25zdW1wdGlvblBlck1pbiIsImF2YWlsYWJsZSIsImJ1ZmZlciIsInJ1blRpbWVNaW51dGVzIiwiZmVhc2libGVPdXRwdXQiLCJNYXRoIiwibWluIiwidG90YWxQb3dlck5lZWRlZCIsInBvd2VyRHJhd01XIiwicG93ZXJBdmFpbGFibGVSYXRpbyIsInBvd2VyQ2FwYWNpdHlNVyIsInRvdGFsQ29vbGluZ05lZWRlZCIsImhlYXRNVyIsImNvb2xpbmdBdmFpbGFibGVSYXRpbyIsImNvb2xpbmdDYXBhY2l0eU1XIiwidG90YWxXb3JrZXJzTmVlZGVkIiwid29ya2VycyIsIndvcmtmb3JjZUF2YWlsYWJsZVJhdGlvIiwid29ya2ZvcmNlVG90YWwiLCJhY3R1YWxPdXRwdXQiLCJzdGVwU2ltIiwic3RhdGUiLCJkdE1pbnV0ZXMiLCJzY2FsZWREdCIsInRpbWVTY2FsZSIsIm5leHQiLCJtYWNoaW5lcyIsImdyaWRPY2N1cGllZCIsIm1hcCIsInJvdyIsInRvdGFsUG93ZXJVc2VkIiwidG90YWxDb29saW5nVXNlZCIsInRvdGFsV29ya2ZvcmNlVXNlZCIsInZhbHVlcyIsImZvckVhY2giLCJtYWNoaW5lIiwicG93ZXJVc2VkTVciLCJjb29saW5nVXNlZE1XIiwid29ya2ZvcmNlVXNlZCIsInBvd2VyT3ZlckNhcGFjaXR5IiwiY29vbGluZ092ZXJDYXBhY2l0eSIsIndvcmtmb3JjZU92ZXJDYXBhY2l0eSIsImtleXMiLCJwcm9kUGVyTWluIiwiY29uc1Blck1pbiIsImlzU291cmNlIiwiYmFzZVNvdXJjZVJhdGUiLCJzb3VyY2VQcm9kIiwibWFjaGluZUlkIiwiaW5wdXRDb25zdW1wdGlvbnMiLCJwdXNoIiwicmF0ZSIsInV0aWxpemF0aW9uIiwicG93ZXJSYXRpbyIsIm1heCIsImNvb2xpbmdSYXRpbyIsIndvcmtmb3JjZVJhdGlvIiwiY29uc3RyYWludE11bHRpcGxpZXIiLCJoYXNJbnB1dHMiLCJsZW5ndGgiLCJzb21lIiwiYWN0dWFsT3V0cHV0UGVyTWluIiwiY29uc3VtZWQiLCJhY3R1YWxDb25zdW1lZCIsInByb2R1Y2VkIiwib3V0cHV0UmVzb3VyY2UiLCJwb2RzUHJvZHVjZWQiLCJyb3VuZCIsIndob2xlTGF1bmNoZXMiLCJmbG9vciIsInBvZHNJbk9yYml0IiwiZGVncmFkYXRpb25QZXJZZWFyIiwieWVhcnNFbGFwc2VkIiwiZGVncmFkYXRpb25GYWN0b3IiLCJwb3ciLCJwb2REZWdyYWRhdGlvbkZhY3RvciIsImdlbmVyYXRpb24iLCJnZW5NdWx0aXBsaWVyIiwiY29zdFJlZHVjdGlvbiIsIm1hc3NSZWR1Y3Rpb24iLCJvcmJpdGFsUG9kU3BlYyIsImNvbXB1dGVLdyIsImNhcGV4UGVyUG9kIiwiZ2V0UmVzb3VyY2VUaHJvdWdocHV0Iiwic2ltIiwiciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/sim/engine.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/sim/model.ts":
/*!******************************!*\
  !*** ./app/lib/sim/model.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UPGRADES: function() { return /* binding */ UPGRADES; },\n/* harmony export */   createInitialSimState: function() { return /* binding */ createInitialSimState; }\n/* harmony export */ });\n/* harmony import */ var _orbitConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./orbitConfig */ \"(app-pages-browser)/./app/lib/sim/orbitConfig.ts\");\n/**\n * Core data model for Factorio-style production chain simulation\n */ \n/**\n * Create initial simulation state with reasonable defaults\n */ function createInitialSimState() {\n    const resources = {\n        silicon: {\n            id: \"silicon\",\n            name: \"Silicon\",\n            units: \"wafers\",\n            buffer: 10000,\n            prodPerMin: 0,\n            consPerMin: 0,\n            isSource: true,\n            baseSourceRate: 1000\n        },\n        steel: {\n            id: \"steel\",\n            name: \"Steel\",\n            units: \"t\",\n            buffer: 5000,\n            prodPerMin: 0,\n            consPerMin: 0,\n            isSource: true,\n            baseSourceRate: 50\n        },\n        chips: {\n            id: \"chips\",\n            name: \"Chips\",\n            units: \"units\",\n            buffer: 0,\n            prodPerMin: 0,\n            consPerMin: 0\n        },\n        computeUnits: {\n            id: \"computeUnits\",\n            name: \"Compute Units\",\n            units: \"units\",\n            buffer: 0,\n            prodPerMin: 0,\n            consPerMin: 0\n        },\n        pods: {\n            id: \"pods\",\n            name: \"Pods\",\n            units: \"pods\",\n            buffer: 0,\n            prodPerMin: 0,\n            consPerMin: 0\n        },\n        launchOpsResource: {\n            id: \"launchOpsResource\",\n            name: \"Launch Ops\",\n            units: \"units\",\n            buffer: 1000,\n            prodPerMin: 0,\n            consPerMin: 0,\n            isSource: true,\n            baseSourceRate: 100\n        },\n        launches: {\n            id: \"launches\",\n            name: \"Launches\",\n            units: \"launches\",\n            buffer: 0,\n            prodPerMin: 0,\n            consPerMin: 0\n        },\n        // Additional resources for factory layout\n        racks: {\n            id: \"racks\",\n            name: \"Racks\",\n            units: \"racks\",\n            buffer: 0,\n            prodPerMin: 0,\n            consPerMin: 0\n        },\n        fuel: {\n            id: \"fuel\",\n            name: \"Fuel\",\n            units: \"t\",\n            buffer: 0,\n            prodPerMin: 0,\n            consPerMin: 0\n        },\n        methane: {\n            id: \"methane\",\n            name: \"Methane\",\n            units: \"t\",\n            buffer: 0,\n            prodPerMin: 0,\n            consPerMin: 0,\n            isSource: true,\n            baseSourceRate: 10\n        },\n        lox: {\n            id: \"lox\",\n            name: \"LOX\",\n            units: \"t\",\n            buffer: 0,\n            prodPerMin: 0,\n            consPerMin: 0,\n            isSource: true,\n            baseSourceRate: 10\n        }\n    };\n    const machines = {\n        chipFab: {\n            id: \"chipFab\",\n            name: \"Chip Fab\",\n            lines: 1,\n            baseOutputPerLine: 200,\n            inputRates: {\n                silicon: 100\n            },\n            outputResource: \"chips\",\n            upgrades: {\n                speedLevel: 0,\n                efficiencyLevel: 0\n            },\n            powerDrawMW: 2.0,\n            heatMW: 1.5,\n            workers: 5,\n            footprint: {\n                width: 2,\n                height: 2\n            }\n        },\n        computeLine: {\n            id: \"computeLine\",\n            name: \"Compute Line\",\n            lines: 1,\n            baseOutputPerLine: 10,\n            inputRates: {\n                steel: 5,\n                chips: 50\n            },\n            outputResource: \"computeUnits\",\n            upgrades: {\n                speedLevel: 0,\n                efficiencyLevel: 0\n            },\n            powerDrawMW: 1.0,\n            heatMW: 0.8,\n            workers: 3,\n            footprint: {\n                width: 2,\n                height: 1\n            }\n        },\n        podFactory: {\n            id: \"podFactory\",\n            name: \"Pod Factory\",\n            lines: 1,\n            baseOutputPerLine: 6,\n            inputRates: {\n                chips: 300,\n                computeUnits: 10\n            },\n            outputResource: \"pods\",\n            upgrades: {\n                speedLevel: 0,\n                efficiencyLevel: 0\n            },\n            powerDrawMW: 3.0,\n            heatMW: 2.0,\n            workers: 8,\n            footprint: {\n                width: 3,\n                height: 2\n            }\n        },\n        launchOps: {\n            id: \"launchOps\",\n            name: \"Launch Ops\",\n            lines: 0,\n            baseOutputPerLine: 0.5,\n            inputRates: {\n                pods: 1,\n                launchOpsResource: 10\n            },\n            outputResource: \"launches\",\n            upgrades: {\n                speedLevel: 0,\n                efficiencyLevel: 0\n            },\n            powerDrawMW: 5.0,\n            heatMW: 3.0,\n            workers: 12,\n            footprint: {\n                width: 4,\n                height: 3\n            }\n        }\n    };\n    const flows = [\n        {\n            from: \"silicon\",\n            to: \"chips\"\n        },\n        {\n            from: \"steel\",\n            to: \"computeUnits\"\n        },\n        {\n            from: \"chips\",\n            to: \"computeUnits\"\n        },\n        {\n            from: \"chips\",\n            to: \"pods\"\n        },\n        {\n            from: \"computeUnits\",\n            to: \"pods\"\n        },\n        {\n            from: \"pods\",\n            to: \"launches\"\n        },\n        {\n            from: \"launchOpsResource\",\n            to: \"launches\"\n        }\n    ];\n    // Initialize factory constraints\n    const gridWidth = 12;\n    const gridHeight = 8;\n    const constraints = {\n        powerCapacityMW: 50,\n        powerUsedMW: 0,\n        coolingCapacityMW: 40,\n        coolingUsedMW: 0,\n        workforceTotal: 50,\n        workforceUsed: 0,\n        gridWidth,\n        gridHeight,\n        gridOccupied: Array(gridHeight).fill(null).map(()=>Array(gridWidth).fill(false))\n    };\n    return {\n        resources,\n        machines,\n        flows,\n        timeScale: 1,\n        rdPoints: 0,\n        constraints,\n        orbitalPodSpec: _orbitConfig__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_ORBITAL_POD_SPEC,\n        groundDcSpec: _orbitConfig__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_GROUND_DC_SPEC,\n        podsInOrbit: 0,\n        targetComputeKw: 42000,\n        generation: 0,\n        podDegradationFactor: 1.0\n    };\n}\nconst UPGRADES = [\n    // Speed upgrades\n    {\n        id: \"chipFab_speed_1\",\n        name: \"Chip Fab Speed +20%\",\n        machineId: \"chipFab\",\n        type: \"speed\",\n        level: 1,\n        cost: 10,\n        effect: 1.2\n    },\n    {\n        id: \"chipFab_speed_2\",\n        name: \"Chip Fab Speed +40%\",\n        machineId: \"chipFab\",\n        type: \"speed\",\n        level: 2,\n        cost: 25,\n        effect: 1.4\n    },\n    {\n        id: \"computeLine_speed_1\",\n        name: \"Compute Line Speed +20%\",\n        machineId: \"computeLine\",\n        type: \"speed\",\n        level: 1,\n        cost: 10,\n        effect: 1.2\n    },\n    {\n        id: \"podFactory_speed_1\",\n        name: \"Pod Factory Speed +20%\",\n        machineId: \"podFactory\",\n        type: \"speed\",\n        level: 1,\n        cost: 20,\n        effect: 1.2\n    },\n    {\n        id: \"launchOps_speed_1\",\n        name: \"Launch Ops Speed +20%\",\n        machineId: \"launchOps\",\n        type: \"speed\",\n        level: 1,\n        cost: 30,\n        effect: 1.2\n    },\n    // Efficiency upgrades (reduce input consumption)\n    {\n        id: \"chipFab_eff_1\",\n        name: \"Chip Fab Efficiency +10%\",\n        machineId: \"chipFab\",\n        type: \"efficiency\",\n        level: 1,\n        cost: 15,\n        effect: 0.9\n    },\n    {\n        id: \"computeLine_eff_1\",\n        name: \"Compute Line Efficiency +10%\",\n        machineId: \"computeLine\",\n        type: \"efficiency\",\n        level: 1,\n        cost: 15,\n        effect: 0.9\n    },\n    {\n        id: \"podFactory_eff_1\",\n        name: \"Pod Factory Efficiency +10%\",\n        machineId: \"podFactory\",\n        type: \"efficiency\",\n        level: 1,\n        cost: 25,\n        effect: 0.9\n    }\n];\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvc2ltL21vZGVsLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztDQUVDLEdBd0RnRjtBQXFCakY7O0NBRUMsR0FDTSxTQUFTRTtJQUNkLE1BQU1DLFlBQStDO1FBQ25EQyxTQUFTO1lBQ1BDLElBQUk7WUFDSkMsTUFBTTtZQUNOQyxPQUFPO1lBQ1BDLFFBQVE7WUFDUkMsWUFBWTtZQUNaQyxZQUFZO1lBQ1pDLFVBQVU7WUFDVkMsZ0JBQWdCO1FBQ2xCO1FBQ0FDLE9BQU87WUFDTFIsSUFBSTtZQUNKQyxNQUFNO1lBQ05DLE9BQU87WUFDUEMsUUFBUTtZQUNSQyxZQUFZO1lBQ1pDLFlBQVk7WUFDWkMsVUFBVTtZQUNWQyxnQkFBZ0I7UUFDbEI7UUFDQUUsT0FBTztZQUNMVCxJQUFJO1lBQ0pDLE1BQU07WUFDTkMsT0FBTztZQUNQQyxRQUFRO1lBQ1JDLFlBQVk7WUFDWkMsWUFBWTtRQUNkO1FBQ0FLLGNBQWM7WUFDWlYsSUFBSTtZQUNKQyxNQUFNO1lBQ05DLE9BQU87WUFDUEMsUUFBUTtZQUNSQyxZQUFZO1lBQ1pDLFlBQVk7UUFDZDtRQUNBTSxNQUFNO1lBQ0pYLElBQUk7WUFDSkMsTUFBTTtZQUNOQyxPQUFPO1lBQ1BDLFFBQVE7WUFDUkMsWUFBWTtZQUNaQyxZQUFZO1FBQ2Q7UUFDQU8sbUJBQW1CO1lBQ2pCWixJQUFJO1lBQ0pDLE1BQU07WUFDTkMsT0FBTztZQUNQQyxRQUFRO1lBQ1JDLFlBQVk7WUFDWkMsWUFBWTtZQUNaQyxVQUFVO1lBQ1ZDLGdCQUFnQjtRQUNsQjtRQUNBTSxVQUFVO1lBQ1JiLElBQUk7WUFDSkMsTUFBTTtZQUNOQyxPQUFPO1lBQ1BDLFFBQVE7WUFDUkMsWUFBWTtZQUNaQyxZQUFZO1FBQ2Q7UUFDQSwwQ0FBMEM7UUFDMUNTLE9BQU87WUFDTGQsSUFBSTtZQUNKQyxNQUFNO1lBQ05DLE9BQU87WUFDUEMsUUFBUTtZQUNSQyxZQUFZO1lBQ1pDLFlBQVk7UUFDZDtRQUNBVSxNQUFNO1lBQ0pmLElBQUk7WUFDSkMsTUFBTTtZQUNOQyxPQUFPO1lBQ1BDLFFBQVE7WUFDUkMsWUFBWTtZQUNaQyxZQUFZO1FBQ2Q7UUFDQVcsU0FBUztZQUNQaEIsSUFBSTtZQUNKQyxNQUFNO1lBQ05DLE9BQU87WUFDUEMsUUFBUTtZQUNSQyxZQUFZO1lBQ1pDLFlBQVk7WUFDWkMsVUFBVTtZQUNWQyxnQkFBZ0I7UUFDbEI7UUFDQVUsS0FBSztZQUNIakIsSUFBSTtZQUNKQyxNQUFNO1lBQ05DLE9BQU87WUFDUEMsUUFBUTtZQUNSQyxZQUFZO1lBQ1pDLFlBQVk7WUFDWkMsVUFBVTtZQUNWQyxnQkFBZ0I7UUFDbEI7SUFDRjtJQUVBLE1BQU1XLFdBQXVDO1FBQzNDQyxTQUFTO1lBQ1BuQixJQUFJO1lBQ0pDLE1BQU07WUFDTm1CLE9BQU87WUFDUEMsbUJBQW1CO1lBQ25CQyxZQUFZO2dCQUNWdkIsU0FBUztZQUNYO1lBQ0F3QixnQkFBZ0I7WUFDaEJDLFVBQVU7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLGlCQUFpQjtZQUNuQjtZQUNBQyxhQUFhO1lBQ2JDLFFBQVE7WUFDUkMsU0FBUztZQUNUQyxXQUFXO2dCQUFFQyxPQUFPO2dCQUFHQyxRQUFRO1lBQUU7UUFDbkM7UUFDQUMsYUFBYTtZQUNYakMsSUFBSTtZQUNKQyxNQUFNO1lBQ05tQixPQUFPO1lBQ1BDLG1CQUFtQjtZQUNuQkMsWUFBWTtnQkFDVmQsT0FBTztnQkFDUEMsT0FBTztZQUNUO1lBQ0FjLGdCQUFnQjtZQUNoQkMsVUFBVTtnQkFDUkMsWUFBWTtnQkFDWkMsaUJBQWlCO1lBQ25CO1lBQ0FDLGFBQWE7WUFDYkMsUUFBUTtZQUNSQyxTQUFTO1lBQ1RDLFdBQVc7Z0JBQUVDLE9BQU87Z0JBQUdDLFFBQVE7WUFBRTtRQUNuQztRQUNBRSxZQUFZO1lBQ1ZsQyxJQUFJO1lBQ0pDLE1BQU07WUFDTm1CLE9BQU87WUFDUEMsbUJBQW1CO1lBQ25CQyxZQUFZO2dCQUNWYixPQUFPO2dCQUNQQyxjQUFjO1lBQ2hCO1lBQ0FhLGdCQUFnQjtZQUNoQkMsVUFBVTtnQkFDUkMsWUFBWTtnQkFDWkMsaUJBQWlCO1lBQ25CO1lBQ0FDLGFBQWE7WUFDYkMsUUFBUTtZQUNSQyxTQUFTO1lBQ1RDLFdBQVc7Z0JBQUVDLE9BQU87Z0JBQUdDLFFBQVE7WUFBRTtRQUNuQztRQUNBRyxXQUFXO1lBQ1RuQyxJQUFJO1lBQ0pDLE1BQU07WUFDTm1CLE9BQU87WUFDUEMsbUJBQW1CO1lBQ25CQyxZQUFZO2dCQUNWWCxNQUFNO2dCQUNOQyxtQkFBbUI7WUFDckI7WUFDQVcsZ0JBQWdCO1lBQ2hCQyxVQUFVO2dCQUNSQyxZQUFZO2dCQUNaQyxpQkFBaUI7WUFDbkI7WUFDQUMsYUFBYTtZQUNiQyxRQUFRO1lBQ1JDLFNBQVM7WUFDVEMsV0FBVztnQkFBRUMsT0FBTztnQkFBR0MsUUFBUTtZQUFFO1FBQ25DO0lBQ0Y7SUFFQSxNQUFNSSxRQUFvQjtRQUN4QjtZQUFFQyxNQUFNO1lBQVdDLElBQUk7UUFBUTtRQUMvQjtZQUFFRCxNQUFNO1lBQVNDLElBQUk7UUFBZTtRQUNwQztZQUFFRCxNQUFNO1lBQVNDLElBQUk7UUFBZTtRQUNwQztZQUFFRCxNQUFNO1lBQVNDLElBQUk7UUFBTztRQUM1QjtZQUFFRCxNQUFNO1lBQWdCQyxJQUFJO1FBQU87UUFDbkM7WUFBRUQsTUFBTTtZQUFRQyxJQUFJO1FBQVc7UUFDL0I7WUFBRUQsTUFBTTtZQUFxQkMsSUFBSTtRQUFXO0tBQzdDO0lBRUQsaUNBQWlDO0lBQ2pDLE1BQU1DLFlBQVk7SUFDbEIsTUFBTUMsYUFBYTtJQUNuQixNQUFNQyxjQUFrQztRQUN0Q0MsaUJBQWlCO1FBQ2pCQyxhQUFhO1FBQ2JDLG1CQUFtQjtRQUNuQkMsZUFBZTtRQUNmQyxnQkFBZ0I7UUFDaEJDLGVBQWU7UUFDZlI7UUFDQUM7UUFDQVEsY0FBY0MsTUFBTVQsWUFBWVUsSUFBSSxDQUFDLE1BQU1DLEdBQUcsQ0FBQyxJQUFNRixNQUFNVixXQUFXVyxJQUFJLENBQUM7SUFDN0U7SUFFQSxPQUFPO1FBQ0xwRDtRQUNBb0I7UUFDQWtCO1FBQ0FnQixXQUFXO1FBQ1hDLFVBQVU7UUFDVlo7UUFDQWEsZ0JBQWdCM0Qsa0VBQXdCQTtRQUN4QzRELGNBQWMzRCxnRUFBc0JBO1FBQ3BDNEQsYUFBYTtRQUNiQyxpQkFBaUI7UUFDakJDLFlBQVk7UUFDWkMsc0JBQXNCO0lBQ3hCO0FBQ0Y7QUFlTyxNQUFNQyxXQUFzQjtJQUNqQyxpQkFBaUI7SUFDakI7UUFBRTVELElBQUk7UUFBbUJDLE1BQU07UUFBdUI0RCxXQUFXO1FBQVdDLE1BQU07UUFBU0MsT0FBTztRQUFHQyxNQUFNO1FBQUlDLFFBQVE7SUFBSTtJQUMzSDtRQUFFakUsSUFBSTtRQUFtQkMsTUFBTTtRQUF1QjRELFdBQVc7UUFBV0MsTUFBTTtRQUFTQyxPQUFPO1FBQUdDLE1BQU07UUFBSUMsUUFBUTtJQUFJO0lBQzNIO1FBQUVqRSxJQUFJO1FBQXVCQyxNQUFNO1FBQTJCNEQsV0FBVztRQUFlQyxNQUFNO1FBQVNDLE9BQU87UUFBR0MsTUFBTTtRQUFJQyxRQUFRO0lBQUk7SUFDdkk7UUFBRWpFLElBQUk7UUFBc0JDLE1BQU07UUFBMEI0RCxXQUFXO1FBQWNDLE1BQU07UUFBU0MsT0FBTztRQUFHQyxNQUFNO1FBQUlDLFFBQVE7SUFBSTtJQUNwSTtRQUFFakUsSUFBSTtRQUFxQkMsTUFBTTtRQUF5QjRELFdBQVc7UUFBYUMsTUFBTTtRQUFTQyxPQUFPO1FBQUdDLE1BQU07UUFBSUMsUUFBUTtJQUFJO0lBRWpJLGlEQUFpRDtJQUNqRDtRQUFFakUsSUFBSTtRQUFpQkMsTUFBTTtRQUE0QjRELFdBQVc7UUFBV0MsTUFBTTtRQUFjQyxPQUFPO1FBQUdDLE1BQU07UUFBSUMsUUFBUTtJQUFJO0lBQ25JO1FBQUVqRSxJQUFJO1FBQXFCQyxNQUFNO1FBQWdDNEQsV0FBVztRQUFlQyxNQUFNO1FBQWNDLE9BQU87UUFBR0MsTUFBTTtRQUFJQyxRQUFRO0lBQUk7SUFDL0k7UUFBRWpFLElBQUk7UUFBb0JDLE1BQU07UUFBK0I0RCxXQUFXO1FBQWNDLE1BQU07UUFBY0MsT0FBTztRQUFHQyxNQUFNO1FBQUlDLFFBQVE7SUFBSTtDQUM3SSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvc2ltL21vZGVsLnRzP2MwNWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3JlIGRhdGEgbW9kZWwgZm9yIEZhY3RvcmlvLXN0eWxlIHByb2R1Y3Rpb24gY2hhaW4gc2ltdWxhdGlvblxuICovXG5cbmV4cG9ydCB0eXBlIFJlc291cmNlSWQgPSAnc2lsaWNvbicgfCAnc3RlZWwnIHwgJ2NoaXBzJyB8ICdyYWNrcycgfCAnY29tcHV0ZVVuaXRzJyB8ICdwb2RzJyB8ICdtZXRoYW5lJyB8ICdsb3gnIHwgJ2Z1ZWwnIHwgJ2xhdW5jaE9wc1Jlc291cmNlJyB8ICdsYXVuY2hlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb3VyY2VTdGF0ZSB7XG4gIGlkOiBSZXNvdXJjZUlkO1xuICBuYW1lOiBzdHJpbmc7XG4gIHVuaXRzOiBzdHJpbmc7ICAgICAvLyBcIndhZmVyc1wiLCBcInJhY2tzXCIsIFwicG9kc1wiLCBcInRcIiwgXCJsYXVuY2hlc1wiXG4gIGJ1ZmZlcjogbnVtYmVyOyAgICAvLyBjdXJyZW50IHN0b2NrXG4gIHByb2RQZXJNaW46IG51bWJlcjtcbiAgY29uc1Blck1pbjogbnVtYmVyO1xuICBpc1NvdXJjZT86IGJvb2xlYW47ICAgICAgLy8gdHJ1ZSBmb3IgaW5maW5pdGUgc291cmNlIHJlc291cmNlcyAoc2lsaWNvbiwgc3RlZWwsIG1ldGhhbmUsIGxveClcbiAgYmFzZVNvdXJjZVJhdGU/OiBudW1iZXI7IC8vIHByb2R1Y3Rpb24gcmF0ZSBmb3Igc291cmNlIHJlc291cmNlc1xufVxuXG5leHBvcnQgdHlwZSBNYWNoaW5lSWQgPSAnY2hpcEZhYicgfCAnY29tcHV0ZUxpbmUnIHwgJ3BvZEZhY3RvcnknIHwgJ2xhdW5jaE9wcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFjaGluZSB7XG4gIGlkOiBNYWNoaW5lSWQ7XG4gIG5hbWU6IHN0cmluZztcbiAgbGluZXM6IG51bWJlcjtcbiAgYmFzZU91dHB1dFBlckxpbmU6IG51bWJlcjsgLy8gdW5pdHMvbWluIHJlc291cmNlIHByb2R1Y2VkXG4gIGlucHV0UmF0ZXM6IFBhcnRpYWw8UmVjb3JkPFJlc291cmNlSWQsIG51bWJlcj4+OyAvLyB1bml0cy9taW4gY29uc3VtZWQgcGVyIGxpbmVcbiAgb3V0cHV0UmVzb3VyY2U6IFJlc291cmNlSWQ7XG4gIHVwZ3JhZGVzOiB7XG4gICAgc3BlZWRMZXZlbDogbnVtYmVyOyAgICAgIC8vIDDigKZOXG4gICAgZWZmaWNpZW5jeUxldmVsOiBudW1iZXI7IC8vIDDigKZOXG4gIH07XG4gIC8vIENvbnN0cmFpbnQgbWV0YWRhdGFcbiAgcG93ZXJEcmF3TVc6IG51bWJlcjsgICAgICAvLyBQb3dlciBkcmF3IHBlciBsaW5lXG4gIGhlYXRNVzogbnVtYmVyOyAgICAgICAgICAgLy8gSGVhdCBvdXRwdXQgcGVyIGxpbmVcbiAgd29ya2VyczogbnVtYmVyOyAgICAgICAgICAvLyBXb3JrZXJzIHJlcXVpcmVkIHBlciBsaW5lXG4gIGZvb3RwcmludDogeyAgICAgICAgICAgICAgLy8gR3JpZCBjZWxscyBvY2N1cGllZFxuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmxvd0VkZ2Uge1xuICBmcm9tOiBSZXNvdXJjZUlkO1xuICB0bzogUmVzb3VyY2VJZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGYWN0b3J5Q29uc3RyYWludHMge1xuICBwb3dlckNhcGFjaXR5TVc6IG51bWJlcjtcbiAgcG93ZXJVc2VkTVc6IG51bWJlcjtcbiAgY29vbGluZ0NhcGFjaXR5TVc6IG51bWJlcjtcbiAgY29vbGluZ1VzZWRNVzogbnVtYmVyO1xuICB3b3JrZm9yY2VUb3RhbDogbnVtYmVyO1xuICB3b3JrZm9yY2VVc2VkOiBudW1iZXI7XG4gIGdyaWRXaWR0aDogbnVtYmVyO1xuICBncmlkSGVpZ2h0OiBudW1iZXI7XG4gIGdyaWRPY2N1cGllZDogYm9vbGVhbltdW107IC8vIDJEIGdyaWQgb2Ygb2NjdXBpZWQgY2VsbHNcbn1cblxuaW1wb3J0IHR5cGUgeyBPcmJpdGFsUG9kU3BlYywgR3JvdW5kRGNTcGVjIH0gZnJvbSBcIi4vb3JiaXRDb25maWdcIjtcbmltcG9ydCB7IERFRkFVTFRfT1JCSVRBTF9QT0RfU1BFQywgREVGQVVMVF9HUk9VTkRfRENfU1BFQyB9IGZyb20gXCIuL29yYml0Q29uZmlnXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2ltU3RhdGUge1xuICByZXNvdXJjZXM6IFJlY29yZDxSZXNvdXJjZUlkLCBSZXNvdXJjZVN0YXRlPjtcbiAgbWFjaGluZXM6IFJlY29yZDxNYWNoaW5lSWQsIE1hY2hpbmU+O1xuICBmbG93czogRmxvd0VkZ2VbXTtcbiAgdGltZVNjYWxlOiAxIHwgMTAgfCAxMDA7XG4gIHJkUG9pbnRzOiBudW1iZXI7XG4gIGNvbnN0cmFpbnRzOiBGYWN0b3J5Q29uc3RyYWludHM7XG4gIC8vIE9yYml0IGNvbmZpZ3NcbiAgb3JiaXRhbFBvZFNwZWM6IE9yYml0YWxQb2RTcGVjO1xuICBncm91bmREY1NwZWM6IEdyb3VuZERjU3BlYztcbiAgLy8gU2ltcGxlIHN0YXRlXG4gIHBvZHNJbk9yYml0OiBudW1iZXI7XG4gIHRhcmdldENvbXB1dGVLdzogbnVtYmVyOyAvLyBUb3RhbCBjb21wdXRlIGRlbWFuZFxuICAvLyBHZW5lcmF0aW9uYWwgdXBncmFkZXNcbiAgZ2VuZXJhdGlvbjogbnVtYmVyOyAvLyAwID0gR2VuIDEsIDEgPSBHZW4gMiwgZXRjLlxuICAvLyBQb2QgZGVncmFkYXRpb25cbiAgcG9kRGVncmFkYXRpb25GYWN0b3I6IG51bWJlcjsgLy8gMC45NyBwZXIgeWVhciwgc3RhcnRzIGF0IDEuMFxufVxuXG4vKipcbiAqIENyZWF0ZSBpbml0aWFsIHNpbXVsYXRpb24gc3RhdGUgd2l0aCByZWFzb25hYmxlIGRlZmF1bHRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbml0aWFsU2ltU3RhdGUoKTogU2ltU3RhdGUge1xuICBjb25zdCByZXNvdXJjZXM6IFJlY29yZDxSZXNvdXJjZUlkLCBSZXNvdXJjZVN0YXRlPiA9IHtcbiAgICBzaWxpY29uOiB7XG4gICAgICBpZDogJ3NpbGljb24nLFxuICAgICAgbmFtZTogJ1NpbGljb24nLFxuICAgICAgdW5pdHM6ICd3YWZlcnMnLFxuICAgICAgYnVmZmVyOiAxMDAwMCwgLy8gTGFyZ2UgYnVmZmVyIGZvciB2aXN1YWwgZmVlZGJhY2tcbiAgICAgIHByb2RQZXJNaW46IDAsXG4gICAgICBjb25zUGVyTWluOiAwLFxuICAgICAgaXNTb3VyY2U6IHRydWUsXG4gICAgICBiYXNlU291cmNlUmF0ZTogMTAwMCwgLy8gRW5vdWdoIHRvIHN1cHBvcnQgbXVsdGlwbGUgY2hpcCBmYWIgbGluZXNcbiAgICB9LFxuICAgIHN0ZWVsOiB7XG4gICAgICBpZDogJ3N0ZWVsJyxcbiAgICAgIG5hbWU6ICdTdGVlbCcsXG4gICAgICB1bml0czogJ3QnLFxuICAgICAgYnVmZmVyOiA1MDAwLCAvLyBMYXJnZSBidWZmZXIgZm9yIHZpc3VhbCBmZWVkYmFja1xuICAgICAgcHJvZFBlck1pbjogMCxcbiAgICAgIGNvbnNQZXJNaW46IDAsXG4gICAgICBpc1NvdXJjZTogdHJ1ZSxcbiAgICAgIGJhc2VTb3VyY2VSYXRlOiA1MCwgLy8gRW5vdWdoIHRvIHN1cHBvcnQgcmFjayBsaW5lc1xuICAgIH0sXG4gICAgY2hpcHM6IHtcbiAgICAgIGlkOiAnY2hpcHMnLFxuICAgICAgbmFtZTogJ0NoaXBzJyxcbiAgICAgIHVuaXRzOiAndW5pdHMnLFxuICAgICAgYnVmZmVyOiAwLFxuICAgICAgcHJvZFBlck1pbjogMCxcbiAgICAgIGNvbnNQZXJNaW46IDAsXG4gICAgfSxcbiAgICBjb21wdXRlVW5pdHM6IHtcbiAgICAgIGlkOiAnY29tcHV0ZVVuaXRzJyxcbiAgICAgIG5hbWU6ICdDb21wdXRlIFVuaXRzJyxcbiAgICAgIHVuaXRzOiAndW5pdHMnLFxuICAgICAgYnVmZmVyOiAwLFxuICAgICAgcHJvZFBlck1pbjogMCxcbiAgICAgIGNvbnNQZXJNaW46IDAsXG4gICAgfSxcbiAgICBwb2RzOiB7XG4gICAgICBpZDogJ3BvZHMnLFxuICAgICAgbmFtZTogJ1BvZHMnLFxuICAgICAgdW5pdHM6ICdwb2RzJyxcbiAgICAgIGJ1ZmZlcjogMCxcbiAgICAgIHByb2RQZXJNaW46IDAsXG4gICAgICBjb25zUGVyTWluOiAwLFxuICAgIH0sXG4gICAgbGF1bmNoT3BzUmVzb3VyY2U6IHtcbiAgICAgIGlkOiAnbGF1bmNoT3BzUmVzb3VyY2UnLFxuICAgICAgbmFtZTogJ0xhdW5jaCBPcHMnLFxuICAgICAgdW5pdHM6ICd1bml0cycsXG4gICAgICBidWZmZXI6IDEwMDAsIC8vIExhcmdlIGJ1ZmZlciBmb3IgdmlzdWFsIGZlZWRiYWNrXG4gICAgICBwcm9kUGVyTWluOiAwLFxuICAgICAgY29uc1Blck1pbjogMCxcbiAgICAgIGlzU291cmNlOiB0cnVlLFxuICAgICAgYmFzZVNvdXJjZVJhdGU6IDEwMCwgLy8gRW5vdWdoIHRvIHN1cHBvcnQgbGF1bmNoIG9wc1xuICAgIH0sXG4gICAgbGF1bmNoZXM6IHtcbiAgICAgIGlkOiAnbGF1bmNoZXMnLFxuICAgICAgbmFtZTogJ0xhdW5jaGVzJyxcbiAgICAgIHVuaXRzOiAnbGF1bmNoZXMnLFxuICAgICAgYnVmZmVyOiAwLFxuICAgICAgcHJvZFBlck1pbjogMCxcbiAgICAgIGNvbnNQZXJNaW46IDAsXG4gICAgfSxcbiAgICAvLyBBZGRpdGlvbmFsIHJlc291cmNlcyBmb3IgZmFjdG9yeSBsYXlvdXRcbiAgICByYWNrczoge1xuICAgICAgaWQ6ICdyYWNrcycsXG4gICAgICBuYW1lOiAnUmFja3MnLFxuICAgICAgdW5pdHM6ICdyYWNrcycsXG4gICAgICBidWZmZXI6IDAsXG4gICAgICBwcm9kUGVyTWluOiAwLFxuICAgICAgY29uc1Blck1pbjogMCxcbiAgICB9LFxuICAgIGZ1ZWw6IHtcbiAgICAgIGlkOiAnZnVlbCcsXG4gICAgICBuYW1lOiAnRnVlbCcsXG4gICAgICB1bml0czogJ3QnLFxuICAgICAgYnVmZmVyOiAwLFxuICAgICAgcHJvZFBlck1pbjogMCxcbiAgICAgIGNvbnNQZXJNaW46IDAsXG4gICAgfSxcbiAgICBtZXRoYW5lOiB7XG4gICAgICBpZDogJ21ldGhhbmUnLFxuICAgICAgbmFtZTogJ01ldGhhbmUnLFxuICAgICAgdW5pdHM6ICd0JyxcbiAgICAgIGJ1ZmZlcjogMCxcbiAgICAgIHByb2RQZXJNaW46IDAsXG4gICAgICBjb25zUGVyTWluOiAwLFxuICAgICAgaXNTb3VyY2U6IHRydWUsXG4gICAgICBiYXNlU291cmNlUmF0ZTogMTAsXG4gICAgfSxcbiAgICBsb3g6IHtcbiAgICAgIGlkOiAnbG94JyxcbiAgICAgIG5hbWU6ICdMT1gnLFxuICAgICAgdW5pdHM6ICd0JyxcbiAgICAgIGJ1ZmZlcjogMCxcbiAgICAgIHByb2RQZXJNaW46IDAsXG4gICAgICBjb25zUGVyTWluOiAwLFxuICAgICAgaXNTb3VyY2U6IHRydWUsXG4gICAgICBiYXNlU291cmNlUmF0ZTogMTAsXG4gICAgfSxcbiAgfTtcblxuICBjb25zdCBtYWNoaW5lczogUmVjb3JkPE1hY2hpbmVJZCwgTWFjaGluZT4gPSB7XG4gICAgY2hpcEZhYjoge1xuICAgICAgaWQ6ICdjaGlwRmFiJyxcbiAgICAgIG5hbWU6ICdDaGlwIEZhYicsXG4gICAgICBsaW5lczogMSxcbiAgICAgIGJhc2VPdXRwdXRQZXJMaW5lOiAyMDAsIC8vIGNoaXBzL21pblxuICAgICAgaW5wdXRSYXRlczoge1xuICAgICAgICBzaWxpY29uOiAxMDAsIC8vIHdhZmVycy9taW4gcGVyIGxpbmVcbiAgICAgIH0sXG4gICAgICBvdXRwdXRSZXNvdXJjZTogJ2NoaXBzJyxcbiAgICAgIHVwZ3JhZGVzOiB7XG4gICAgICAgIHNwZWVkTGV2ZWw6IDAsXG4gICAgICAgIGVmZmljaWVuY3lMZXZlbDogMCxcbiAgICAgIH0sXG4gICAgICBwb3dlckRyYXdNVzogMi4wLFxuICAgICAgaGVhdE1XOiAxLjUsXG4gICAgICB3b3JrZXJzOiA1LFxuICAgICAgZm9vdHByaW50OiB7IHdpZHRoOiAyLCBoZWlnaHQ6IDIgfSxcbiAgICB9LFxuICAgIGNvbXB1dGVMaW5lOiB7XG4gICAgICBpZDogJ2NvbXB1dGVMaW5lJyxcbiAgICAgIG5hbWU6ICdDb21wdXRlIExpbmUnLFxuICAgICAgbGluZXM6IDEsXG4gICAgICBiYXNlT3V0cHV0UGVyTGluZTogMTAsIC8vIGNvbXB1dGUgdW5pdHMvbWluXG4gICAgICBpbnB1dFJhdGVzOiB7XG4gICAgICAgIHN0ZWVsOiA1LCAvLyB0L21pbiBwZXIgbGluZVxuICAgICAgICBjaGlwczogNTAsIC8vIGNoaXBzL21pbiBwZXIgbGluZVxuICAgICAgfSxcbiAgICAgIG91dHB1dFJlc291cmNlOiAnY29tcHV0ZVVuaXRzJyxcbiAgICAgIHVwZ3JhZGVzOiB7XG4gICAgICAgIHNwZWVkTGV2ZWw6IDAsXG4gICAgICAgIGVmZmljaWVuY3lMZXZlbDogMCxcbiAgICAgIH0sXG4gICAgICBwb3dlckRyYXdNVzogMS4wLFxuICAgICAgaGVhdE1XOiAwLjgsXG4gICAgICB3b3JrZXJzOiAzLFxuICAgICAgZm9vdHByaW50OiB7IHdpZHRoOiAyLCBoZWlnaHQ6IDEgfSxcbiAgICB9LFxuICAgIHBvZEZhY3Rvcnk6IHtcbiAgICAgIGlkOiAncG9kRmFjdG9yeScsXG4gICAgICBuYW1lOiAnUG9kIEZhY3RvcnknLFxuICAgICAgbGluZXM6IDEsXG4gICAgICBiYXNlT3V0cHV0UGVyTGluZTogNiwgLy8gcG9kcy9taW4gKDEgcG9kIHBlciAxMCBzZWNvbmRzKVxuICAgICAgaW5wdXRSYXRlczoge1xuICAgICAgICBjaGlwczogMzAwLCAvLyBjaGlwcy9taW4gcGVyIGxpbmVcbiAgICAgICAgY29tcHV0ZVVuaXRzOiAxMCwgLy8gY29tcHV0ZSB1bml0cy9taW4gcGVyIGxpbmVcbiAgICAgIH0sXG4gICAgICBvdXRwdXRSZXNvdXJjZTogJ3BvZHMnLFxuICAgICAgdXBncmFkZXM6IHtcbiAgICAgICAgc3BlZWRMZXZlbDogMCxcbiAgICAgICAgZWZmaWNpZW5jeUxldmVsOiAwLFxuICAgICAgfSxcbiAgICAgIHBvd2VyRHJhd01XOiAzLjAsXG4gICAgICBoZWF0TVc6IDIuMCxcbiAgICAgIHdvcmtlcnM6IDgsXG4gICAgICBmb290cHJpbnQ6IHsgd2lkdGg6IDMsIGhlaWdodDogMiB9LFxuICAgIH0sXG4gICAgbGF1bmNoT3BzOiB7XG4gICAgICBpZDogJ2xhdW5jaE9wcycsXG4gICAgICBuYW1lOiAnTGF1bmNoIE9wcycsXG4gICAgICBsaW5lczogMCwgLy8gU3RhcnQgd2l0aCAwIGxpbmVzIHNvIHBvZHMgY2FuIGFjY3VtdWxhdGUgZmlyc3RcbiAgICAgIGJhc2VPdXRwdXRQZXJMaW5lOiAwLjUsIC8vIGxhdW5jaGVzL21pbiAoMSBsYXVuY2ggcGVyIDIgbWluID0gZmFzdGVyIGZvciBnYW1lcGxheSlcbiAgICAgIGlucHV0UmF0ZXM6IHtcbiAgICAgICAgcG9kczogMSwgLy8gcG9kcy9taW4gcGVyIGxpbmVcbiAgICAgICAgbGF1bmNoT3BzUmVzb3VyY2U6IDEwLCAvLyBsYXVuY2ggb3BzIHVuaXRzL21pbiBwZXIgbGluZVxuICAgICAgfSxcbiAgICAgIG91dHB1dFJlc291cmNlOiAnbGF1bmNoZXMnLFxuICAgICAgdXBncmFkZXM6IHtcbiAgICAgICAgc3BlZWRMZXZlbDogMCxcbiAgICAgICAgZWZmaWNpZW5jeUxldmVsOiAwLFxuICAgICAgfSxcbiAgICAgIHBvd2VyRHJhd01XOiA1LjAsXG4gICAgICBoZWF0TVc6IDMuMCxcbiAgICAgIHdvcmtlcnM6IDEyLFxuICAgICAgZm9vdHByaW50OiB7IHdpZHRoOiA0LCBoZWlnaHQ6IDMgfSxcbiAgICB9LFxuICB9O1xuXG4gIGNvbnN0IGZsb3dzOiBGbG93RWRnZVtdID0gW1xuICAgIHsgZnJvbTogJ3NpbGljb24nLCB0bzogJ2NoaXBzJyB9LFxuICAgIHsgZnJvbTogJ3N0ZWVsJywgdG86ICdjb21wdXRlVW5pdHMnIH0sXG4gICAgeyBmcm9tOiAnY2hpcHMnLCB0bzogJ2NvbXB1dGVVbml0cycgfSxcbiAgICB7IGZyb206ICdjaGlwcycsIHRvOiAncG9kcycgfSxcbiAgICB7IGZyb206ICdjb21wdXRlVW5pdHMnLCB0bzogJ3BvZHMnIH0sXG4gICAgeyBmcm9tOiAncG9kcycsIHRvOiAnbGF1bmNoZXMnIH0sXG4gICAgeyBmcm9tOiAnbGF1bmNoT3BzUmVzb3VyY2UnLCB0bzogJ2xhdW5jaGVzJyB9LFxuICBdO1xuXG4gIC8vIEluaXRpYWxpemUgZmFjdG9yeSBjb25zdHJhaW50c1xuICBjb25zdCBncmlkV2lkdGggPSAxMjtcbiAgY29uc3QgZ3JpZEhlaWdodCA9IDg7XG4gIGNvbnN0IGNvbnN0cmFpbnRzOiBGYWN0b3J5Q29uc3RyYWludHMgPSB7XG4gICAgcG93ZXJDYXBhY2l0eU1XOiA1MCwgICAgICAvLyBJbml0aWFsIHBvd2VyIGNhcGFjaXR5XG4gICAgcG93ZXJVc2VkTVc6IDAsXG4gICAgY29vbGluZ0NhcGFjaXR5TVc6IDQwLCAgICAgLy8gSW5pdGlhbCBjb29saW5nIGNhcGFjaXR5XG4gICAgY29vbGluZ1VzZWRNVzogMCxcbiAgICB3b3JrZm9yY2VUb3RhbDogNTAsICAgICAgICAvLyBJbml0aWFsIHdvcmtmb3JjZVxuICAgIHdvcmtmb3JjZVVzZWQ6IDAsXG4gICAgZ3JpZFdpZHRoLFxuICAgIGdyaWRIZWlnaHQsXG4gICAgZ3JpZE9jY3VwaWVkOiBBcnJheShncmlkSGVpZ2h0KS5maWxsKG51bGwpLm1hcCgoKSA9PiBBcnJheShncmlkV2lkdGgpLmZpbGwoZmFsc2UpKSxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHJlc291cmNlcyxcbiAgICBtYWNoaW5lcyxcbiAgICBmbG93cyxcbiAgICB0aW1lU2NhbGU6IDEsXG4gICAgcmRQb2ludHM6IDAsXG4gICAgY29uc3RyYWludHMsXG4gICAgb3JiaXRhbFBvZFNwZWM6IERFRkFVTFRfT1JCSVRBTF9QT0RfU1BFQyxcbiAgICBncm91bmREY1NwZWM6IERFRkFVTFRfR1JPVU5EX0RDX1NQRUMsXG4gICAgcG9kc0luT3JiaXQ6IDAsXG4gICAgdGFyZ2V0Q29tcHV0ZUt3OiA0MjAwMCwgLy8gNDIgR1cgYmFzZWxpbmUgZ3JvdW5kIGNhcGFjaXR5XG4gICAgZ2VuZXJhdGlvbjogMCwgLy8gU3RhcnQgYXQgR2VuIDFcbiAgICBwb2REZWdyYWRhdGlvbkZhY3RvcjogMS4wLCAvLyBObyBkZWdyYWRhdGlvbiBpbml0aWFsbHlcbiAgfTtcbn1cblxuLyoqXG4gKiBVcGdyYWRlIGRlZmluaXRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXBncmFkZSB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgbWFjaGluZUlkOiBNYWNoaW5lSWQ7XG4gIHR5cGU6ICdzcGVlZCcgfCAnZWZmaWNpZW5jeSc7XG4gIGxldmVsOiBudW1iZXI7XG4gIGNvc3Q6IG51bWJlcjsgLy8gUkQgcG9pbnRzXG4gIGVmZmVjdDogbnVtYmVyOyAvLyBtdWx0aXBsaWVyIG9yIHJlZHVjdGlvblxufVxuXG5leHBvcnQgY29uc3QgVVBHUkFERVM6IFVwZ3JhZGVbXSA9IFtcbiAgLy8gU3BlZWQgdXBncmFkZXNcbiAgeyBpZDogJ2NoaXBGYWJfc3BlZWRfMScsIG5hbWU6ICdDaGlwIEZhYiBTcGVlZCArMjAlJywgbWFjaGluZUlkOiAnY2hpcEZhYicsIHR5cGU6ICdzcGVlZCcsIGxldmVsOiAxLCBjb3N0OiAxMCwgZWZmZWN0OiAxLjIgfSxcbiAgeyBpZDogJ2NoaXBGYWJfc3BlZWRfMicsIG5hbWU6ICdDaGlwIEZhYiBTcGVlZCArNDAlJywgbWFjaGluZUlkOiAnY2hpcEZhYicsIHR5cGU6ICdzcGVlZCcsIGxldmVsOiAyLCBjb3N0OiAyNSwgZWZmZWN0OiAxLjQgfSxcbiAgeyBpZDogJ2NvbXB1dGVMaW5lX3NwZWVkXzEnLCBuYW1lOiAnQ29tcHV0ZSBMaW5lIFNwZWVkICsyMCUnLCBtYWNoaW5lSWQ6ICdjb21wdXRlTGluZScsIHR5cGU6ICdzcGVlZCcsIGxldmVsOiAxLCBjb3N0OiAxMCwgZWZmZWN0OiAxLjIgfSxcbiAgeyBpZDogJ3BvZEZhY3Rvcnlfc3BlZWRfMScsIG5hbWU6ICdQb2QgRmFjdG9yeSBTcGVlZCArMjAlJywgbWFjaGluZUlkOiAncG9kRmFjdG9yeScsIHR5cGU6ICdzcGVlZCcsIGxldmVsOiAxLCBjb3N0OiAyMCwgZWZmZWN0OiAxLjIgfSxcbiAgeyBpZDogJ2xhdW5jaE9wc19zcGVlZF8xJywgbmFtZTogJ0xhdW5jaCBPcHMgU3BlZWQgKzIwJScsIG1hY2hpbmVJZDogJ2xhdW5jaE9wcycsIHR5cGU6ICdzcGVlZCcsIGxldmVsOiAxLCBjb3N0OiAzMCwgZWZmZWN0OiAxLjIgfSxcbiAgXG4gIC8vIEVmZmljaWVuY3kgdXBncmFkZXMgKHJlZHVjZSBpbnB1dCBjb25zdW1wdGlvbilcbiAgeyBpZDogJ2NoaXBGYWJfZWZmXzEnLCBuYW1lOiAnQ2hpcCBGYWIgRWZmaWNpZW5jeSArMTAlJywgbWFjaGluZUlkOiAnY2hpcEZhYicsIHR5cGU6ICdlZmZpY2llbmN5JywgbGV2ZWw6IDEsIGNvc3Q6IDE1LCBlZmZlY3Q6IDAuOSB9LFxuICB7IGlkOiAnY29tcHV0ZUxpbmVfZWZmXzEnLCBuYW1lOiAnQ29tcHV0ZSBMaW5lIEVmZmljaWVuY3kgKzEwJScsIG1hY2hpbmVJZDogJ2NvbXB1dGVMaW5lJywgdHlwZTogJ2VmZmljaWVuY3knLCBsZXZlbDogMSwgY29zdDogMTUsIGVmZmVjdDogMC45IH0sXG4gIHsgaWQ6ICdwb2RGYWN0b3J5X2VmZl8xJywgbmFtZTogJ1BvZCBGYWN0b3J5IEVmZmljaWVuY3kgKzEwJScsIG1hY2hpbmVJZDogJ3BvZEZhY3RvcnknLCB0eXBlOiAnZWZmaWNpZW5jeScsIGxldmVsOiAxLCBjb3N0OiAyNSwgZWZmZWN0OiAwLjkgfSxcbl07XG5cbiJdLCJuYW1lcyI6WyJERUZBVUxUX09SQklUQUxfUE9EX1NQRUMiLCJERUZBVUxUX0dST1VORF9EQ19TUEVDIiwiY3JlYXRlSW5pdGlhbFNpbVN0YXRlIiwicmVzb3VyY2VzIiwic2lsaWNvbiIsImlkIiwibmFtZSIsInVuaXRzIiwiYnVmZmVyIiwicHJvZFBlck1pbiIsImNvbnNQZXJNaW4iLCJpc1NvdXJjZSIsImJhc2VTb3VyY2VSYXRlIiwic3RlZWwiLCJjaGlwcyIsImNvbXB1dGVVbml0cyIsInBvZHMiLCJsYXVuY2hPcHNSZXNvdXJjZSIsImxhdW5jaGVzIiwicmFja3MiLCJmdWVsIiwibWV0aGFuZSIsImxveCIsIm1hY2hpbmVzIiwiY2hpcEZhYiIsImxpbmVzIiwiYmFzZU91dHB1dFBlckxpbmUiLCJpbnB1dFJhdGVzIiwib3V0cHV0UmVzb3VyY2UiLCJ1cGdyYWRlcyIsInNwZWVkTGV2ZWwiLCJlZmZpY2llbmN5TGV2ZWwiLCJwb3dlckRyYXdNVyIsImhlYXRNVyIsIndvcmtlcnMiLCJmb290cHJpbnQiLCJ3aWR0aCIsImhlaWdodCIsImNvbXB1dGVMaW5lIiwicG9kRmFjdG9yeSIsImxhdW5jaE9wcyIsImZsb3dzIiwiZnJvbSIsInRvIiwiZ3JpZFdpZHRoIiwiZ3JpZEhlaWdodCIsImNvbnN0cmFpbnRzIiwicG93ZXJDYXBhY2l0eU1XIiwicG93ZXJVc2VkTVciLCJjb29saW5nQ2FwYWNpdHlNVyIsImNvb2xpbmdVc2VkTVciLCJ3b3JrZm9yY2VUb3RhbCIsIndvcmtmb3JjZVVzZWQiLCJncmlkT2NjdXBpZWQiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJ0aW1lU2NhbGUiLCJyZFBvaW50cyIsIm9yYml0YWxQb2RTcGVjIiwiZ3JvdW5kRGNTcGVjIiwicG9kc0luT3JiaXQiLCJ0YXJnZXRDb21wdXRlS3ciLCJnZW5lcmF0aW9uIiwicG9kRGVncmFkYXRpb25GYWN0b3IiLCJVUEdSQURFUyIsIm1hY2hpbmVJZCIsInR5cGUiLCJsZXZlbCIsImNvc3QiLCJlZmZlY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/sim/model.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/sim/orbitConfig.ts":
/*!************************************!*\
  !*** ./app/lib/sim/orbitConfig.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_GROUND_DC_SPEC: function() { return /* binding */ DEFAULT_GROUND_DC_SPEC; },\n/* harmony export */   DEFAULT_ORBITAL_POD_SPEC: function() { return /* binding */ DEFAULT_ORBITAL_POD_SPEC; },\n/* harmony export */   getGroundEnergyMwhPerYear: function() { return /* binding */ getGroundEnergyMwhPerYear; },\n/* harmony export */   getOrbitHybridCo2TonsPerYear: function() { return /* binding */ getOrbitHybridCo2TonsPerYear; },\n/* harmony export */   getOrbitHybridEnergyCostPerYear: function() { return /* binding */ getOrbitHybridEnergyCostPerYear; },\n/* harmony export */   getOrbitHybridEnergyMwhPerYear: function() { return /* binding */ getOrbitHybridEnergyMwhPerYear; },\n/* harmony export */   getOrbitalComputeKw: function() { return /* binding */ getOrbitalComputeKw; },\n/* harmony export */   getOrbitalEnergyMwhPerYear: function() { return /* binding */ getOrbitalEnergyMwhPerYear; },\n/* harmony export */   getOrbitalPowerMw: function() { return /* binding */ getOrbitalPowerMw; }\n/* harmony export */ });\n/**\n * Orbital and Ground DC configuration specs\n * Used for annualized capacity and cost calculations\n */ const DEFAULT_ORBITAL_POD_SPEC = {\n    computeKw: 150,\n    solarKw: 200,\n    capacityFactor: 0.85,\n    effectivePue: 1.05,\n    lifetimeYears: 7,\n    capexPerPod: 50000000,\n    opexPerYearPerPod: 2000000,\n    co2PerYearPerPod: 500\n};\nconst DEFAULT_GROUND_DC_SPEC = {\n    computeKwPerRack: 50,\n    pue: 1.5,\n    energyPricePerMwh: 50,\n    coolingWaterLPerMwh: 2000,\n    co2PerMwh: 0.5\n};\n/**\n * Get orbital compute capacity in kW\n * Accounts for pod degradation and generational upgrades\n */ function getOrbitalComputeKw(podsInOrbit, spec, degradationFactor) {\n    const degFactor = degradationFactor !== null && degradationFactor !== void 0 ? degradationFactor : 1.0;\n    return podsInOrbit * spec.computeKw * degFactor;\n}\n/**\n * Get orbital power in MW (solar capacity * capacity factor)\n */ function getOrbitalPowerMw(podsInOrbit, spec) {\n    return podsInOrbit * spec.solarKw * spec.capacityFactor / 1000;\n}\n/**\n * Get orbital energy consumption in MWh/year\n */ function getOrbitalEnergyMwhPerYear(podsInOrbit, spec) {\n    const powerMw = getOrbitalPowerMw(podsInOrbit, spec);\n    return powerMw * 24 * 365;\n}\n/**\n * Get ground energy consumption in MWh/year\n */ function getGroundEnergyMwhPerYear(groundComputeKw, spec) {\n    return groundComputeKw * spec.pue * 24 * 365 / 1000;\n}\n/**\n * Get hybrid (ground + orbit) energy consumption in MWh/year\n */ function getOrbitHybridEnergyMwhPerYear(totalComputeKw, orbitalComputeKw, orbitalSpec, groundSpec, degradationFactor) {\n    const groundKw = Math.max(0, totalComputeKw - orbitalComputeKw);\n    const groundMwh = getGroundEnergyMwhPerYear(groundKw, groundSpec);\n    const orbitalMwh = getOrbitalEnergyMwhPerYear(orbitalComputeKw / orbitalSpec.computeKw, orbitalSpec);\n    return groundMwh + orbitalMwh;\n}\n/**\n * Get hybrid CO2 emissions in tons/year\n */ function getOrbitHybridCo2TonsPerYear(totalComputeKw, podsInOrbit, orbitalSpec, groundSpec, degradationFactor) {\n    const orbitalComputeKw = getOrbitalComputeKw(podsInOrbit, orbitalSpec, degradationFactor);\n    const groundKw = Math.max(0, totalComputeKw - orbitalComputeKw);\n    const groundEnergy = getGroundEnergyMwhPerYear(groundKw, groundSpec);\n    const groundCo2 = groundEnergy * groundSpec.co2PerMwh;\n    const orbitalCo2 = podsInOrbit * orbitalSpec.co2PerYearPerPod;\n    return groundCo2 + orbitalCo2;\n}\n/**\n * Get hybrid energy cost in $/year\n */ function getOrbitHybridEnergyCostPerYear(totalComputeKw, podsInOrbit, orbitalSpec, groundSpec, degradationFactor) {\n    const orbitalComputeKw = getOrbitalComputeKw(podsInOrbit, orbitalSpec, degradationFactor);\n    const groundKw = Math.max(0, totalComputeKw - orbitalComputeKw);\n    const groundEnergy = getGroundEnergyMwhPerYear(groundKw, groundSpec);\n    const groundCost = groundEnergy * groundSpec.energyPricePerMwh;\n    const orbitalOpex = podsInOrbit * orbitalSpec.opexPerYearPerPod;\n    return groundCost + orbitalOpex;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvc2ltL29yYml0Q29uZmlnLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQXFCTSxNQUFNQSwyQkFBMkM7SUFDdERDLFdBQVc7SUFDWEMsU0FBUztJQUNUQyxnQkFBZ0I7SUFDaEJDLGNBQWM7SUFDZEMsZUFBZTtJQUNmQyxhQUFhO0lBQ2JDLG1CQUFtQjtJQUNuQkMsa0JBQWtCO0FBQ3BCLEVBQUU7QUFFSyxNQUFNQyx5QkFBdUM7SUFDbERDLGtCQUFrQjtJQUNsQkMsS0FBSztJQUNMQyxtQkFBbUI7SUFDbkJDLHFCQUFxQjtJQUNyQkMsV0FBVztBQUNiLEVBQUU7QUFFRjs7O0NBR0MsR0FDTSxTQUFTQyxvQkFDZEMsV0FBbUIsRUFDbkJDLElBQW9CLEVBQ3BCQyxpQkFBMEI7SUFFMUIsTUFBTUMsWUFBWUQsOEJBQUFBLCtCQUFBQSxvQkFBcUI7SUFDdkMsT0FBT0YsY0FBY0MsS0FBS2hCLFNBQVMsR0FBR2tCO0FBQ3hDO0FBRUE7O0NBRUMsR0FDTSxTQUFTQyxrQkFBa0JKLFdBQW1CLEVBQUVDLElBQW9CO0lBQ3pFLE9BQU9ELGNBQWNDLEtBQUtmLE9BQU8sR0FBR2UsS0FBS2QsY0FBYyxHQUFHO0FBQzVEO0FBRUE7O0NBRUMsR0FDTSxTQUFTa0IsMkJBQTJCTCxXQUFtQixFQUFFQyxJQUFvQjtJQUNsRixNQUFNSyxVQUFVRixrQkFBa0JKLGFBQWFDO0lBQy9DLE9BQU9LLFVBQVUsS0FBSztBQUN4QjtBQUVBOztDQUVDLEdBQ00sU0FBU0MsMEJBQTBCQyxlQUF1QixFQUFFUCxJQUFrQjtJQUNuRixPQUFPTyxrQkFBa0JQLEtBQUtOLEdBQUcsR0FBRyxLQUFLLE1BQU07QUFDakQ7QUFFQTs7Q0FFQyxHQUNNLFNBQVNjLCtCQUNkQyxjQUFzQixFQUN0QkMsZ0JBQXdCLEVBQ3hCQyxXQUEyQixFQUMzQkMsVUFBd0IsRUFDeEJYLGlCQUEwQjtJQUUxQixNQUFNWSxXQUFXQyxLQUFLQyxHQUFHLENBQUMsR0FBR04saUJBQWlCQztJQUU5QyxNQUFNTSxZQUFZViwwQkFBMEJPLFVBQVVEO0lBQ3RELE1BQU1LLGFBQWFiLDJCQUNqQk0sbUJBQW1CQyxZQUFZM0IsU0FBUyxFQUN4QzJCO0lBR0YsT0FBT0ssWUFBWUM7QUFDckI7QUFFQTs7Q0FFQyxHQUNNLFNBQVNDLDZCQUNkVCxjQUFzQixFQUN0QlYsV0FBbUIsRUFDbkJZLFdBQTJCLEVBQzNCQyxVQUF3QixFQUN4QlgsaUJBQTBCO0lBRTFCLE1BQU1TLG1CQUFtQlosb0JBQW9CQyxhQUFhWSxhQUFhVjtJQUN2RSxNQUFNWSxXQUFXQyxLQUFLQyxHQUFHLENBQUMsR0FBR04saUJBQWlCQztJQUU5QyxNQUFNUyxlQUFlYiwwQkFBMEJPLFVBQVVEO0lBQ3pELE1BQU1RLFlBQVlELGVBQWVQLFdBQVdmLFNBQVM7SUFFckQsTUFBTXdCLGFBQWF0QixjQUFjWSxZQUFZcEIsZ0JBQWdCO0lBRTdELE9BQU82QixZQUFZQztBQUNyQjtBQUVBOztDQUVDLEdBQ00sU0FBU0MsZ0NBQ2RiLGNBQXNCLEVBQ3RCVixXQUFtQixFQUNuQlksV0FBMkIsRUFDM0JDLFVBQXdCLEVBQ3hCWCxpQkFBMEI7SUFFMUIsTUFBTVMsbUJBQW1CWixvQkFBb0JDLGFBQWFZLGFBQWFWO0lBQ3ZFLE1BQU1ZLFdBQVdDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHTixpQkFBaUJDO0lBRTlDLE1BQU1TLGVBQWViLDBCQUEwQk8sVUFBVUQ7SUFDekQsTUFBTVcsYUFBYUosZUFBZVAsV0FBV2pCLGlCQUFpQjtJQUU5RCxNQUFNNkIsY0FBY3pCLGNBQWNZLFlBQVlyQixpQkFBaUI7SUFFL0QsT0FBT2lDLGFBQWFDO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvc2ltL29yYml0Q29uZmlnLnRzP2RmZjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBPcmJpdGFsIGFuZCBHcm91bmQgREMgY29uZmlndXJhdGlvbiBzcGVjc1xuICogVXNlZCBmb3IgYW5udWFsaXplZCBjYXBhY2l0eSBhbmQgY29zdCBjYWxjdWxhdGlvbnNcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIE9yYml0YWxQb2RTcGVjIHtcbiAgY29tcHV0ZUt3OiBudW1iZXI7ICAgICAgICAvLyBuYW1lcGxhdGUgY29tcHV0ZSBwZXIgcG9kIChlLmcuIDE1MCBrVylcbiAgc29sYXJLdzogbnVtYmVyOyAgICAgICAgICAvLyBuYW1lcGxhdGUgc29sYXIgcGVyIHBvZCAoYXJyYXlzKVxuICBjYXBhY2l0eUZhY3RvcjogbnVtYmVyOyAgIC8vIDAuLjEgYXZlcmFnZSB1dGlsaXphdGlvbiBvZiBzb2xhciAoZS5nLiAwLjg1KVxuICBlZmZlY3RpdmVQdWU6IG51bWJlcjsgICAgIC8vIGUuZy4gMS4wNSAodnMgMS41IGdyb3VuZClcbiAgbGlmZXRpbWVZZWFyczogbnVtYmVyOyAgICAvLyBwb2QgbGlmZXRpbWUsIGUuZy4gN1xuICBjYXBleFBlclBvZDogbnVtYmVyOyAgICAgIC8vICQgYnVpbGQgKyBsYXVuY2hcbiAgb3BleFBlclllYXJQZXJQb2Q6IG51bWJlcjsgLy8gJC95ciBpbiBvcmJpdCBvcHNcbiAgY28yUGVyWWVhclBlclBvZDogbnVtYmVyOyAvLyB0Q08yL3lyIChtb3N0bHkgbGF1bmNoIGFtb3J0aXplZClcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcm91bmREY1NwZWMge1xuICBjb21wdXRlS3dQZXJSYWNrOiBudW1iZXI7XG4gIHB1ZTogbnVtYmVyOyAgICAgICAgICAgICAgLy8gMS41IGV0Yy5cbiAgZW5lcmd5UHJpY2VQZXJNd2g6IG51bWJlcjtcbiAgY29vbGluZ1dhdGVyTFBlck13aDogbnVtYmVyO1xuICBjbzJQZXJNd2g6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfT1JCSVRBTF9QT0RfU1BFQzogT3JiaXRhbFBvZFNwZWMgPSB7XG4gIGNvbXB1dGVLdzogMTUwLCAgICAgICAgICAgLy8gMTUwIGtXIHBlciBwb2RcbiAgc29sYXJLdzogMjAwLCAgICAgICAgICAgICAvLyAyMDAga1cgc29sYXIgYXJyYXlzIHBlciBwb2RcbiAgY2FwYWNpdHlGYWN0b3I6IDAuODUsICAgICAvLyA4NSUgYXZlcmFnZSBzb2xhciB1dGlsaXphdGlvblxuICBlZmZlY3RpdmVQdWU6IDEuMDUsICAgICAgIC8vIFZlcnkgZWZmaWNpZW50IGluIHNwYWNlXG4gIGxpZmV0aW1lWWVhcnM6IDcsICAgICAgICAgIC8vIDcgeWVhciBsaWZldGltZVxuICBjYXBleFBlclBvZDogNTBfMDAwXzAwMCwgIC8vICQ1ME0gcGVyIHBvZCAoYnVpbGQgKyBsYXVuY2gpXG4gIG9wZXhQZXJZZWFyUGVyUG9kOiAyXzAwMF8wMDAsIC8vICQyTS95ZWFyIG9wc1xuICBjbzJQZXJZZWFyUGVyUG9kOiA1MDAsICAgIC8vIDUwMCB0Q08yL3llYXIgKGxhdW5jaCBhbW9ydGl6ZWQpXG59O1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9HUk9VTkRfRENfU1BFQzogR3JvdW5kRGNTcGVjID0ge1xuICBjb21wdXRlS3dQZXJSYWNrOiA1MCwgICAgIC8vIDUwIGtXIHBlciByYWNrXG4gIHB1ZTogMS41LCAgICAgICAgICAgICAgICAgLy8gMS41IFBVRSB0eXBpY2FsXG4gIGVuZXJneVByaWNlUGVyTXdoOiA1MCwgICAgLy8gJDUwL01XaFxuICBjb29saW5nV2F0ZXJMUGVyTXdoOiAyMDAwLCAvLyAyMDAwIEwvTVdoIGNvb2xpbmdcbiAgY28yUGVyTXdoOiAwLjUsICAgICAgICAgICAvLyAwLjUgdENPMi9NV2hcbn07XG5cbi8qKlxuICogR2V0IG9yYml0YWwgY29tcHV0ZSBjYXBhY2l0eSBpbiBrV1xuICogQWNjb3VudHMgZm9yIHBvZCBkZWdyYWRhdGlvbiBhbmQgZ2VuZXJhdGlvbmFsIHVwZ3JhZGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcmJpdGFsQ29tcHV0ZUt3KFxuICBwb2RzSW5PcmJpdDogbnVtYmVyLCBcbiAgc3BlYzogT3JiaXRhbFBvZFNwZWMsIFxuICBkZWdyYWRhdGlvbkZhY3Rvcj86IG51bWJlclxuKTogbnVtYmVyIHtcbiAgY29uc3QgZGVnRmFjdG9yID0gZGVncmFkYXRpb25GYWN0b3IgPz8gMS4wO1xuICByZXR1cm4gcG9kc0luT3JiaXQgKiBzcGVjLmNvbXB1dGVLdyAqIGRlZ0ZhY3Rvcjtcbn1cblxuLyoqXG4gKiBHZXQgb3JiaXRhbCBwb3dlciBpbiBNVyAoc29sYXIgY2FwYWNpdHkgKiBjYXBhY2l0eSBmYWN0b3IpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcmJpdGFsUG93ZXJNdyhwb2RzSW5PcmJpdDogbnVtYmVyLCBzcGVjOiBPcmJpdGFsUG9kU3BlYyk6IG51bWJlciB7XG4gIHJldHVybiBwb2RzSW5PcmJpdCAqIHNwZWMuc29sYXJLdyAqIHNwZWMuY2FwYWNpdHlGYWN0b3IgLyAxMDAwO1xufVxuXG4vKipcbiAqIEdldCBvcmJpdGFsIGVuZXJneSBjb25zdW1wdGlvbiBpbiBNV2gveWVhclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3JiaXRhbEVuZXJneU13aFBlclllYXIocG9kc0luT3JiaXQ6IG51bWJlciwgc3BlYzogT3JiaXRhbFBvZFNwZWMpOiBudW1iZXIge1xuICBjb25zdCBwb3dlck13ID0gZ2V0T3JiaXRhbFBvd2VyTXcocG9kc0luT3JiaXQsIHNwZWMpO1xuICByZXR1cm4gcG93ZXJNdyAqIDI0ICogMzY1O1xufVxuXG4vKipcbiAqIEdldCBncm91bmQgZW5lcmd5IGNvbnN1bXB0aW9uIGluIE1XaC95ZWFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHcm91bmRFbmVyZ3lNd2hQZXJZZWFyKGdyb3VuZENvbXB1dGVLdzogbnVtYmVyLCBzcGVjOiBHcm91bmREY1NwZWMpOiBudW1iZXIge1xuICByZXR1cm4gZ3JvdW5kQ29tcHV0ZUt3ICogc3BlYy5wdWUgKiAyNCAqIDM2NSAvIDEwMDA7XG59XG5cbi8qKlxuICogR2V0IGh5YnJpZCAoZ3JvdW5kICsgb3JiaXQpIGVuZXJneSBjb25zdW1wdGlvbiBpbiBNV2gveWVhclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3JiaXRIeWJyaWRFbmVyZ3lNd2hQZXJZZWFyKFxuICB0b3RhbENvbXB1dGVLdzogbnVtYmVyLFxuICBvcmJpdGFsQ29tcHV0ZUt3OiBudW1iZXIsXG4gIG9yYml0YWxTcGVjOiBPcmJpdGFsUG9kU3BlYyxcbiAgZ3JvdW5kU3BlYzogR3JvdW5kRGNTcGVjLFxuICBkZWdyYWRhdGlvbkZhY3Rvcj86IG51bWJlclxuKTogbnVtYmVyIHtcbiAgY29uc3QgZ3JvdW5kS3cgPSBNYXRoLm1heCgwLCB0b3RhbENvbXB1dGVLdyAtIG9yYml0YWxDb21wdXRlS3cpO1xuICBcbiAgY29uc3QgZ3JvdW5kTXdoID0gZ2V0R3JvdW5kRW5lcmd5TXdoUGVyWWVhcihncm91bmRLdywgZ3JvdW5kU3BlYyk7XG4gIGNvbnN0IG9yYml0YWxNd2ggPSBnZXRPcmJpdGFsRW5lcmd5TXdoUGVyWWVhcihcbiAgICBvcmJpdGFsQ29tcHV0ZUt3IC8gb3JiaXRhbFNwZWMuY29tcHV0ZUt3LFxuICAgIG9yYml0YWxTcGVjXG4gICk7XG4gIFxuICByZXR1cm4gZ3JvdW5kTXdoICsgb3JiaXRhbE13aDtcbn1cblxuLyoqXG4gKiBHZXQgaHlicmlkIENPMiBlbWlzc2lvbnMgaW4gdG9ucy95ZWFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcmJpdEh5YnJpZENvMlRvbnNQZXJZZWFyKFxuICB0b3RhbENvbXB1dGVLdzogbnVtYmVyLFxuICBwb2RzSW5PcmJpdDogbnVtYmVyLFxuICBvcmJpdGFsU3BlYzogT3JiaXRhbFBvZFNwZWMsXG4gIGdyb3VuZFNwZWM6IEdyb3VuZERjU3BlYyxcbiAgZGVncmFkYXRpb25GYWN0b3I/OiBudW1iZXJcbik6IG51bWJlciB7XG4gIGNvbnN0IG9yYml0YWxDb21wdXRlS3cgPSBnZXRPcmJpdGFsQ29tcHV0ZUt3KHBvZHNJbk9yYml0LCBvcmJpdGFsU3BlYywgZGVncmFkYXRpb25GYWN0b3IpO1xuICBjb25zdCBncm91bmRLdyA9IE1hdGgubWF4KDAsIHRvdGFsQ29tcHV0ZUt3IC0gb3JiaXRhbENvbXB1dGVLdyk7XG4gIFxuICBjb25zdCBncm91bmRFbmVyZ3kgPSBnZXRHcm91bmRFbmVyZ3lNd2hQZXJZZWFyKGdyb3VuZEt3LCBncm91bmRTcGVjKTtcbiAgY29uc3QgZ3JvdW5kQ28yID0gZ3JvdW5kRW5lcmd5ICogZ3JvdW5kU3BlYy5jbzJQZXJNd2g7XG4gIFxuICBjb25zdCBvcmJpdGFsQ28yID0gcG9kc0luT3JiaXQgKiBvcmJpdGFsU3BlYy5jbzJQZXJZZWFyUGVyUG9kO1xuICBcbiAgcmV0dXJuIGdyb3VuZENvMiArIG9yYml0YWxDbzI7XG59XG5cbi8qKlxuICogR2V0IGh5YnJpZCBlbmVyZ3kgY29zdCBpbiAkL3llYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9yYml0SHlicmlkRW5lcmd5Q29zdFBlclllYXIoXG4gIHRvdGFsQ29tcHV0ZUt3OiBudW1iZXIsXG4gIHBvZHNJbk9yYml0OiBudW1iZXIsXG4gIG9yYml0YWxTcGVjOiBPcmJpdGFsUG9kU3BlYyxcbiAgZ3JvdW5kU3BlYzogR3JvdW5kRGNTcGVjLFxuICBkZWdyYWRhdGlvbkZhY3Rvcj86IG51bWJlclxuKTogbnVtYmVyIHtcbiAgY29uc3Qgb3JiaXRhbENvbXB1dGVLdyA9IGdldE9yYml0YWxDb21wdXRlS3cocG9kc0luT3JiaXQsIG9yYml0YWxTcGVjLCBkZWdyYWRhdGlvbkZhY3Rvcik7XG4gIGNvbnN0IGdyb3VuZEt3ID0gTWF0aC5tYXgoMCwgdG90YWxDb21wdXRlS3cgLSBvcmJpdGFsQ29tcHV0ZUt3KTtcbiAgXG4gIGNvbnN0IGdyb3VuZEVuZXJneSA9IGdldEdyb3VuZEVuZXJneU13aFBlclllYXIoZ3JvdW5kS3csIGdyb3VuZFNwZWMpO1xuICBjb25zdCBncm91bmRDb3N0ID0gZ3JvdW5kRW5lcmd5ICogZ3JvdW5kU3BlYy5lbmVyZ3lQcmljZVBlck13aDtcbiAgXG4gIGNvbnN0IG9yYml0YWxPcGV4ID0gcG9kc0luT3JiaXQgKiBvcmJpdGFsU3BlYy5vcGV4UGVyWWVhclBlclBvZDtcbiAgXG4gIHJldHVybiBncm91bmRDb3N0ICsgb3JiaXRhbE9wZXg7XG59XG5cbiJdLCJuYW1lcyI6WyJERUZBVUxUX09SQklUQUxfUE9EX1NQRUMiLCJjb21wdXRlS3ciLCJzb2xhckt3IiwiY2FwYWNpdHlGYWN0b3IiLCJlZmZlY3RpdmVQdWUiLCJsaWZldGltZVllYXJzIiwiY2FwZXhQZXJQb2QiLCJvcGV4UGVyWWVhclBlclBvZCIsImNvMlBlclllYXJQZXJQb2QiLCJERUZBVUxUX0dST1VORF9EQ19TUEVDIiwiY29tcHV0ZUt3UGVyUmFjayIsInB1ZSIsImVuZXJneVByaWNlUGVyTXdoIiwiY29vbGluZ1dhdGVyTFBlck13aCIsImNvMlBlck13aCIsImdldE9yYml0YWxDb21wdXRlS3ciLCJwb2RzSW5PcmJpdCIsInNwZWMiLCJkZWdyYWRhdGlvbkZhY3RvciIsImRlZ0ZhY3RvciIsImdldE9yYml0YWxQb3dlck13IiwiZ2V0T3JiaXRhbEVuZXJneU13aFBlclllYXIiLCJwb3dlck13IiwiZ2V0R3JvdW5kRW5lcmd5TXdoUGVyWWVhciIsImdyb3VuZENvbXB1dGVLdyIsImdldE9yYml0SHlicmlkRW5lcmd5TXdoUGVyWWVhciIsInRvdGFsQ29tcHV0ZUt3Iiwib3JiaXRhbENvbXB1dGVLdyIsIm9yYml0YWxTcGVjIiwiZ3JvdW5kU3BlYyIsImdyb3VuZEt3IiwiTWF0aCIsIm1heCIsImdyb3VuZE13aCIsIm9yYml0YWxNd2giLCJnZXRPcmJpdEh5YnJpZENvMlRvbnNQZXJZZWFyIiwiZ3JvdW5kRW5lcmd5IiwiZ3JvdW5kQ28yIiwib3JiaXRhbENvMiIsImdldE9yYml0SHlicmlkRW5lcmd5Q29zdFBlclllYXIiLCJncm91bmRDb3N0Iiwib3JiaXRhbE9wZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/sim/orbitConfig.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/utils/toast.ts":
/*!********************************!*\
  !*** ./app/lib/utils/toast.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getToasts: function() { return /* binding */ getToasts; },\n/* harmony export */   showToast: function() { return /* binding */ showToast; },\n/* harmony export */   subscribe: function() { return /* binding */ subscribe; }\n/* harmony export */ });\n/**\n * Simple toast notification system\n */ let toastId = 0;\nconst toasts = [];\nlet listeners = [];\nfunction showToast(message) {\n    let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"error\";\n    const id = toastId++;\n    toasts.push({\n        id,\n        message,\n        type\n    });\n    // Auto-remove after 3 seconds\n    setTimeout(()=>{\n        const index = toasts.findIndex((t)=>t.id === id);\n        if (index >= 0) {\n            toasts.splice(index, 1);\n            notifyListeners();\n        }\n    }, 3000);\n    notifyListeners();\n}\nfunction getToasts() {\n    return [\n        ...toasts\n    ];\n}\nfunction subscribe(callback) {\n    listeners.push(callback);\n    return ()=>{\n        listeners = listeners.filter((l)=>l !== callback);\n    };\n}\nfunction notifyListeners() {\n    listeners.forEach((l)=>l());\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvdXRpbHMvdG9hc3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0NBRUMsR0FFRCxJQUFJQSxVQUFVO0FBQ2QsTUFBTUMsU0FBcUYsRUFBRTtBQUM3RixJQUFJQyxZQUErQixFQUFFO0FBRTlCLFNBQVNDLFVBQVVDLE9BQWU7UUFBRUMsT0FBQUEsaUVBQXFDO0lBQzlFLE1BQU1DLEtBQUtOO0lBQ1hDLE9BQU9NLElBQUksQ0FBQztRQUFFRDtRQUFJRjtRQUFTQztJQUFLO0lBRWhDLDhCQUE4QjtJQUM5QkcsV0FBVztRQUNULE1BQU1DLFFBQVFSLE9BQU9TLFNBQVMsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUwsRUFBRSxLQUFLQTtRQUM3QyxJQUFJRyxTQUFTLEdBQUc7WUFDZFIsT0FBT1csTUFBTSxDQUFDSCxPQUFPO1lBQ3JCSTtRQUNGO0lBQ0YsR0FBRztJQUVIQTtBQUNGO0FBRU8sU0FBU0M7SUFDZCxPQUFPO1dBQUliO0tBQU87QUFDcEI7QUFFTyxTQUFTYyxVQUFVQyxRQUFvQjtJQUM1Q2QsVUFBVUssSUFBSSxDQUFDUztJQUNmLE9BQU87UUFDTGQsWUFBWUEsVUFBVWUsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxNQUFNRjtJQUMxQztBQUNGO0FBRUEsU0FBU0g7SUFDUFgsVUFBVWlCLE9BQU8sQ0FBQ0QsQ0FBQUEsSUFBS0E7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi91dGlscy90b2FzdC50cz9jMTBmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2ltcGxlIHRvYXN0IG5vdGlmaWNhdGlvbiBzeXN0ZW1cbiAqL1xuXG5sZXQgdG9hc3RJZCA9IDA7XG5jb25zdCB0b2FzdHM6IEFycmF5PHsgaWQ6IG51bWJlcjsgbWVzc2FnZTogc3RyaW5nOyB0eXBlOiAnZXJyb3InIHwgJ3dhcm5pbmcnIHwgJ2luZm8nIH0+ID0gW107XG5sZXQgbGlzdGVuZXJzOiBBcnJheTwoKSA9PiB2b2lkPiA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gc2hvd1RvYXN0KG1lc3NhZ2U6IHN0cmluZywgdHlwZTogJ2Vycm9yJyB8ICd3YXJuaW5nJyB8ICdpbmZvJyA9ICdlcnJvcicpIHtcbiAgY29uc3QgaWQgPSB0b2FzdElkKys7XG4gIHRvYXN0cy5wdXNoKHsgaWQsIG1lc3NhZ2UsIHR5cGUgfSk7XG4gIFxuICAvLyBBdXRvLXJlbW92ZSBhZnRlciAzIHNlY29uZHNcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSB0b2FzdHMuZmluZEluZGV4KHQgPT4gdC5pZCA9PT0gaWQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0b2FzdHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIG5vdGlmeUxpc3RlbmVycygpO1xuICAgIH1cbiAgfSwgMzAwMCk7XG4gIFxuICBub3RpZnlMaXN0ZW5lcnMoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRvYXN0cygpIHtcbiAgcmV0dXJuIFsuLi50b2FzdHNdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrOiAoKSA9PiB2b2lkKSB7XG4gIGxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKGwgPT4gbCAhPT0gY2FsbGJhY2spO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMoKSB7XG4gIGxpc3RlbmVycy5mb3JFYWNoKGwgPT4gbCgpKTtcbn1cblxuIl0sIm5hbWVzIjpbInRvYXN0SWQiLCJ0b2FzdHMiLCJsaXN0ZW5lcnMiLCJzaG93VG9hc3QiLCJtZXNzYWdlIiwidHlwZSIsImlkIiwicHVzaCIsInNldFRpbWVvdXQiLCJpbmRleCIsImZpbmRJbmRleCIsInQiLCJzcGxpY2UiLCJub3RpZnlMaXN0ZW5lcnMiLCJnZXRUb2FzdHMiLCJzdWJzY3JpYmUiLCJjYWxsYmFjayIsImZpbHRlciIsImwiLCJmb3JFYWNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/utils/toast.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/store/orbitalUnitsStore.ts":
/*!****************************************!*\
  !*** ./app/store/orbitalUnitsStore.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UNIT_DEFINITIONS: function() { return /* binding */ UNIT_DEFINITIONS; },\n/* harmony export */   useOrbitalUnitsStore: function() { return /* binding */ useOrbitalUnitsStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var _lib_deployment_podTiers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/deployment/podTiers */ \"(app-pages-browser)/./app/lib/deployment/podTiers.ts\");\n/* harmony import */ var _lib_deployment_deploymentEngine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/deployment/deploymentEngine */ \"(app-pages-browser)/./app/lib/deployment/deploymentEngine.ts\");\n\n\n\n// NEW POWER-FIRST UNIT DEFINITIONS (100kW minimum)\nconst UNIT_DEFINITIONS = {\n    leo_pod: {\n        type: \"leo_pod\",\n        name: \"Orbital Compute Pod\",\n        cost: 2,\n        powerOutputMw: 0.1,\n        latencyMs: 65,\n        lifetimeYears: 7,\n        buildTimeDays: 180\n    }\n};\nconst useOrbitalUnitsStore = (0,zustand__WEBPACK_IMPORTED_MODULE_2__.create)((set, get)=>({\n        units: [],\n        deploymentQueue: [],\n        totalRealWorldTimeDays: 0,\n        addToQueue: (unitData, strategicLevers)=>{\n            return get().addToQueueInternal(unitData, strategicLevers);\n        },\n        addToQueueInternal: (unitData, strategicLevers)=>{\n            const state = get();\n            // Get deployment state from sandbox store\n            let podTier = \"tier1\";\n            let orbitMode = \"LEO\";\n            let activeLaunchProviders = [\n                \"F9\"\n            ];\n            let totalPodsBuilt = 0;\n            try {\n                const { useSandboxStore } = __webpack_require__(/*! ./sandboxStore */ \"(app-pages-browser)/./app/store/sandboxStore.ts\");\n                const sandboxState = useSandboxStore.getState();\n                podTier = (strategicLevers === null || strategicLevers === void 0 ? void 0 : strategicLevers.podTier) || sandboxState.selectedPodTier;\n                orbitMode = (strategicLevers === null || strategicLevers === void 0 ? void 0 : strategicLevers.orbitMode) || sandboxState.orbitMode;\n                activeLaunchProviders = (strategicLevers === null || strategicLevers === void 0 ? void 0 : strategicLevers.activeLaunchProviders) || sandboxState.activeLaunchProviders;\n                totalPodsBuilt = sandboxState.totalPodsBuilt;\n            } catch (e) {\n            // Use defaults if store not available\n            }\n            // Calculate deployment engine state\n            const totalPodsInOrbit = state.units.filter((u)=>u.status === \"deployed\").length;\n            const totalPodsInQueue = state.deploymentQueue.length;\n            const deploymentState = {\n                totalPodsBuilt,\n                totalPodsInOrbit,\n                totalPodsInQueue,\n                activeLaunchProviders\n            };\n            const engine = (0,_lib_deployment_deploymentEngine__WEBPACK_IMPORTED_MODULE_1__.calculateDeploymentEngine)(deploymentState);\n            // Check queue cap\n            if (totalPodsInQueue >= engine.maxQueue) {\n                return false; // Queue full\n            }\n            // Get pod tier definition\n            const tier = _lib_deployment_podTiers__WEBPACK_IMPORTED_MODULE_0__.POD_TIERS.find((t)=>t.id === podTier) || _lib_deployment_podTiers__WEBPACK_IMPORTED_MODULE_0__.POD_TIERS[0];\n            // Calculate learning-adjusted cost and time\n            const learningRate = 0.08;\n            const timeLearningRate = 0.04;\n            const costPerPod = tier.baseCostM * Math.pow(1 - learningRate, Math.min(totalPodsBuilt, 100));\n            const buildTimePerPod = tier.baseBuildDays * Math.pow(1 - timeLearningRate, Math.min(totalPodsBuilt, 100));\n            // For now, use leo_pod as base unit type\n            // TODO: Map pod tiers to actual unit types\n            const unit = {\n                ...unitData,\n                cost: Math.round(costPerPod * 100) / 100,\n                buildTimeDays: Math.round(buildTimePerPod),\n                id: \"unit_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9)),\n                status: \"queued\"\n            };\n            set((state)=>({\n                    deploymentQueue: [\n                        ...state.deploymentQueue,\n                        unit\n                    ]\n                }));\n            return true; // Successfully added\n        },\n        startBuild: (unitId)=>{\n            const unit = get().deploymentQueue.find((u)=>u.id === unitId);\n            if (!unit) return;\n            // Check if this unit is already being built or deployed (to avoid double-counting time)\n            const existingUnit = get().units.find((u)=>u.id === unitId);\n            if (existingUnit) return; // Already building or deployed\n            // Allow parallel builds - start immediately if there are available slots\n            set((state)=>{\n                const currentlyBuilding = state.units.filter((u)=>u.status === \"building\");\n                const newUnits = [\n                    ...state.units,\n                    {\n                        ...unit,\n                        status: \"building\",\n                        buildStartTime: Date.now()\n                    }\n                ];\n                // Logarithmic \"parallel batch\" time curve:\n                // 1 unit  = 1x base time\n                // 2 units = ~1.5x base time\n                // 3+ units = diminishing additional time\n                const BASE_DAYS = unit.buildTimeDays;\n                const prevCount = currentlyBuilding.length;\n                const newCount = prevCount + 1;\n                const curve = (n)=>n <= 0 ? 0 : BASE_DAYS * (1 + 0.5 * Math.log2(n));\n                const prevBatchTime = curve(prevCount);\n                const newBatchTime = curve(newCount);\n                const timeToAdd = newBatchTime - prevBatchTime;\n                return {\n                    deploymentQueue: state.deploymentQueue.filter((u)=>u.id !== unitId),\n                    units: newUnits,\n                    totalRealWorldTimeDays: state.totalRealWorldTimeDays + Math.max(0, timeToAdd)\n                };\n            });\n        },\n        deployUnit: (unitId)=>{\n            set((state)=>{\n                const unit = state.units.find((u)=>u.id === unitId);\n                if (!unit || unit.status === \"deployed\") return state;\n                // Increment total pods built in sandbox store\n                try {\n                    const { useSandboxStore } = __webpack_require__(/*! ./sandboxStore */ \"(app-pages-browser)/./app/store/sandboxStore.ts\");\n                    useSandboxStore.getState().incrementTotalPodsBuilt();\n                } catch (e) {\n                // Ignore if store not available\n                }\n                return {\n                    units: state.units.map((u)=>u.id === unitId ? {\n                            ...u,\n                            status: \"deployed\",\n                            deployedAt: Date.now()\n                        } : u)\n                };\n            });\n        },\n        removeUnit: (unitId)=>{\n            set((state)=>({\n                    units: state.units.filter((u)=>u.id !== unitId),\n                    deploymentQueue: state.deploymentQueue.filter((u)=>u.id !== unitId)\n                }));\n        },\n        getQueuedUnits: ()=>get().deploymentQueue,\n        getBuildingUnits: ()=>get().units.filter((u)=>u.status === \"building\"),\n        getDeployedUnits: ()=>get().units.filter((u)=>u.status === \"deployed\"),\n        updateBuildProgress: ()=>{\n            const now = Date.now();\n            // Base build time is 5 seconds, but parallel builds reduce time using logarithmic scaling\n            // Formula: baseTime / (1 + log2(parallelCount))\n            // So 1 unit = 5s, 2 units = 5/2 = 2.5s, 4 units = 5/3 = 1.67s, 8 units = 5/4 = 1.25s, etc.\n            const BASE_BUILD_TIME_MS = 5000; // 5 seconds base\n            set((state)=>{\n                const buildingUnits = state.units.filter((u)=>u.status === \"building\");\n                const parallelCount = buildingUnits.length;\n                // Logarithmic scaling: more units = faster, but diminishing returns\n                const buildTimeMs = parallelCount > 1 ? BASE_BUILD_TIME_MS / (1 + Math.log2(parallelCount)) : BASE_BUILD_TIME_MS;\n                return {\n                    units: state.units.map((unit)=>{\n                        if (unit.status === \"building\" && unit.buildStartTime) {\n                            const elapsed = now - unit.buildStartTime;\n                            if (elapsed >= buildTimeMs) {\n                                return {\n                                    ...unit,\n                                    status: \"deployed\",\n                                    deployedAt: now\n                                };\n                            }\n                        }\n                        return unit;\n                    })\n                };\n            });\n        },\n        reset: ()=>{\n            set({\n                units: [],\n                deploymentQueue: [],\n                totalRealWorldTimeDays: 0\n            });\n        }\n    }));\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zdG9yZS9vcmJpdGFsVW5pdHNTdG9yZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFpQztBQUUrRDtBQUNLO0FBNENyRyxtREFBbUQ7QUFDbkQsTUFBTUcsbUJBQTJHO0lBQy9HQyxTQUFTO1FBQ1BDLE1BQU07UUFDTkMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLGVBQWU7UUFDZkMsV0FBVztRQUNYQyxlQUFlO1FBQ2ZDLGVBQWU7SUFDakI7QUFDRjtBQUVPLE1BQU1DLHVCQUF1QlosK0NBQU1BLENBQW9CLENBQUNhLEtBQUtDLE1BQVM7UUFDM0VDLE9BQU8sRUFBRTtRQUNUQyxpQkFBaUIsRUFBRTtRQUNuQkMsd0JBQXdCO1FBRXhCQyxZQUFZLENBQUNDLFVBQVVDO1lBQ3JCLE9BQU9OLE1BQU1PLGtCQUFrQixDQUFDRixVQUFVQztRQUM1QztRQUVBQyxvQkFBb0IsQ0FBQ0YsVUFBVUM7WUFDN0IsTUFBTUUsUUFBUVI7WUFFZCwwQ0FBMEM7WUFDMUMsSUFBSVMsVUFBcUI7WUFDekIsSUFBSUMsWUFBWTtZQUNoQixJQUFJQyx3QkFBNEM7Z0JBQUM7YUFBSztZQUN0RCxJQUFJQyxpQkFBaUI7WUFFckIsSUFBSTtnQkFDRixNQUFNLEVBQUVDLGVBQWUsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQyx1RUFBZ0I7Z0JBQ3BELE1BQU1DLGVBQWVGLGdCQUFnQkcsUUFBUTtnQkFDN0NQLFVBQVVILENBQUFBLDRCQUFBQSxzQ0FBQUEsZ0JBQWlCRyxPQUFPLEtBQUlNLGFBQWFFLGVBQWU7Z0JBQ2xFUCxZQUFZSixDQUFBQSw0QkFBQUEsc0NBQUFBLGdCQUFpQkksU0FBUyxLQUFJSyxhQUFhTCxTQUFTO2dCQUNoRUMsd0JBQXdCTCxDQUFBQSw0QkFBQUEsc0NBQUFBLGdCQUFpQksscUJBQXFCLEtBQUlJLGFBQWFKLHFCQUFxQjtnQkFDcEdDLGlCQUFpQkcsYUFBYUgsY0FBYztZQUM5QyxFQUFFLE9BQU9NLEdBQUc7WUFDVixzQ0FB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Oi8vX05fRS8uL2FwcC9zdG9yZS9vcmJpdGFsVW5pdHNTdG9yZS50cz80OTkyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZSB9IGZyb20gXCJ6dXN0YW5kXCI7XG5pbXBvcnQgeyBjYWxjdWxhdGVTY2FsaW5nRWNvbm9taWVzIH0gZnJvbSBcIi4uL2xpYi9tZXRyaWNzL2NhbGN1bGF0ZU1ldHJpY3NcIjtcbmltcG9ydCB7IFBPRF9USUVSUywgZ2V0SGlnaGVzdEF2YWlsYWJsZVRpZXIsIHR5cGUgUG9kVGllcklkIH0gZnJvbSBcIi4uL2xpYi9kZXBsb3ltZW50L3BvZFRpZXJzXCI7XG5pbXBvcnQgeyBjYWxjdWxhdGVEZXBsb3ltZW50RW5naW5lLCB0eXBlIERlcGxveW1lbnRTdGF0ZSB9IGZyb20gXCIuLi9saWIvZGVwbG95bWVudC9kZXBsb3ltZW50RW5naW5lXCI7XG5pbXBvcnQgdHlwZSB7IExhdW5jaFByb3ZpZGVySWQgfSBmcm9tIFwiLi4vbGliL2RlcGxveW1lbnQvbGF1bmNoUHJvdmlkZXJzXCI7XG5cbmV4cG9ydCB0eXBlIFVuaXRUeXBlID0gXCJsZW9fcG9kXCI7IC8vIEdFTyBhbmQgc2VydmVyX2Zhcm0gcmVtb3ZlZCAtIHVzaW5nIDQtc2hlbGwgbW9kZWwgb25seVxuXG5leHBvcnQgaW50ZXJmYWNlIE9yYml0YWxVbml0IHtcbiAgaWQ6IHN0cmluZztcbiAgdHlwZTogVW5pdFR5cGU7XG4gIG5hbWU6IHN0cmluZztcbiAgY29zdDogbnVtYmVyOyAvLyBpbiBtaWxsaW9uc1xuICBwb3dlck91dHB1dE13OiBudW1iZXI7XG4gIGxhdGVuY3lNczogbnVtYmVyO1xuICBsaWZldGltZVllYXJzOiBudW1iZXI7XG4gIGJ1aWxkVGltZURheXM6IG51bWJlcjtcbiAgZGVwbG95ZWRBdD86IG51bWJlcjsgLy8gdGltZXN0YW1wIHdoZW4gZGVwbG95ZWRcbiAgYnVpbGRTdGFydFRpbWU/OiBudW1iZXI7IC8vIHRpbWVzdGFtcCB3aGVuIGJ1aWxkIHN0YXJ0ZWRcbiAgc3RhdHVzOiBcInF1ZXVlZFwiIHwgXCJidWlsZGluZ1wiIHwgXCJkZXBsb3llZFwiIHwgXCJkZWNvbW1pc3Npb25lZFwiO1xuICBzYXRlbGxpdGVzPzogc3RyaW5nW107IC8vIHNhdGVsbGl0ZSBJRHMgZm9yIExFTyBwb2RzXG4gIHBvc2l0aW9uPzogeyBsYXQ6IG51bWJlcjsgbG9uOiBudW1iZXI7IGFsdF9rbTogbnVtYmVyIH07IC8vIGZvciBHRU8gaHVic1xufVxuXG5pbnRlcmZhY2UgU3RyYXRlZ2ljTGV2ZXJzIHtcbiAgcG9kVGllcjogUG9kVGllcklkO1xuICBvcmJpdE1vZGU6IHN0cmluZztcbiAgYWN0aXZlTGF1bmNoUHJvdmlkZXJzOiBMYXVuY2hQcm92aWRlcklkW107XG59XG5cbmludGVyZmFjZSBPcmJpdGFsVW5pdHNTdG9yZSB7XG4gIHVuaXRzOiBPcmJpdGFsVW5pdFtdO1xuICBkZXBsb3ltZW50UXVldWU6IE9yYml0YWxVbml0W107XG4gIHRvdGFsUmVhbFdvcmxkVGltZURheXM6IG51bWJlcjsgLy8gU3VtIG9mIGFsbCBkZXBsb3ltZW50IHJlYWwtd29ybGQgdGltZXNcbiAgYWRkVG9RdWV1ZTogKHVuaXQ6IE9taXQ8T3JiaXRhbFVuaXQsIFwiaWRcIiB8IFwic3RhdHVzXCIgfCBcImJ1aWxkU3RhcnRUaW1lXCI+LCBzdHJhdGVnaWNMZXZlcnM/OiBTdHJhdGVnaWNMZXZlcnMpID0+IGJvb2xlYW47IC8vIFJldHVybnMgdHJ1ZSBpZiBhZGRlZCwgZmFsc2UgaWYgcXVldWUgZnVsbFxuICAvLyBJbnRlcm5hbCBoZWxwZXIgdXNlZCBieSBhZGRUb1F1ZXVlOyBleHBvc2VkIGhlcmUgc28gdGhlIHN0b3JlIHR5cGUgbWF0Y2hlcyB0aGUgaW1wbGVtZW50YXRpb25cbiAgYWRkVG9RdWV1ZUludGVybmFsOiAodW5pdDogT21pdDxPcmJpdGFsVW5pdCwgXCJpZFwiIHwgXCJzdGF0dXNcIiB8IFwiYnVpbGRTdGFydFRpbWVcIj4sIHN0cmF0ZWdpY0xldmVycz86IFN0cmF0ZWdpY0xldmVycykgPT4gYm9vbGVhbjtcbiAgc3RhcnRCdWlsZDogKHVuaXRJZDogc3RyaW5nKSA9PiB2b2lkO1xuICBkZXBsb3lVbml0OiAodW5pdElkOiBzdHJpbmcpID0+IHZvaWQ7XG4gIHJlbW92ZVVuaXQ6ICh1bml0SWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgZ2V0UXVldWVkVW5pdHM6ICgpID0+IE9yYml0YWxVbml0W107XG4gIGdldEJ1aWxkaW5nVW5pdHM6ICgpID0+IE9yYml0YWxVbml0W107XG4gIGdldERlcGxveWVkVW5pdHM6ICgpID0+IE9yYml0YWxVbml0W107XG4gIHVwZGF0ZUJ1aWxkUHJvZ3Jlc3M6ICgpID0+IHZvaWQ7XG4gIHJlc2V0OiAoKSA9PiB2b2lkO1xufVxuXG4vLyBORVcgUE9XRVItRklSU1QgVU5JVCBERUZJTklUSU9OUyAoMTAwa1cgbWluaW11bSlcbmNvbnN0IFVOSVRfREVGSU5JVElPTlM6IFJlY29yZDxVbml0VHlwZSwgT21pdDxPcmJpdGFsVW5pdCwgXCJpZFwiIHwgXCJzdGF0dXNcIiB8IFwiYnVpbGRTdGFydFRpbWVcIiB8IFwiZGVwbG95ZWRBdFwiPj4gPSB7XG4gIGxlb19wb2Q6IHtcbiAgICB0eXBlOiBcImxlb19wb2RcIixcbiAgICBuYW1lOiBcIk9yYml0YWwgQ29tcHV0ZSBQb2RcIixcbiAgICBjb3N0OiAyLCAvLyAkMk0gKEJBU0VfUE9EIGNvc3QpXG4gICAgcG93ZXJPdXRwdXRNdzogMC4xLCAvLyAxMDAga1cgbWluaW11bSAoMC4xIE1XKVxuICAgIGxhdGVuY3lNczogNjUsIC8vIE1JRC1MRU8gZGVmYXVsdCBsYXRlbmN5XG4gICAgbGlmZXRpbWVZZWFyczogNyxcbiAgICBidWlsZFRpbWVEYXlzOiAxODAsXG4gIH0sXG59O1xuXG5leHBvcnQgY29uc3QgdXNlT3JiaXRhbFVuaXRzU3RvcmUgPSBjcmVhdGU8T3JiaXRhbFVuaXRzU3RvcmU+KChzZXQsIGdldCkgPT4gKHtcbiAgdW5pdHM6IFtdLFxuICBkZXBsb3ltZW50UXVldWU6IFtdLFxuICB0b3RhbFJlYWxXb3JsZFRpbWVEYXlzOiAwLFxuICBcbiAgYWRkVG9RdWV1ZTogKHVuaXREYXRhLCBzdHJhdGVnaWNMZXZlcnM/OiBTdHJhdGVnaWNMZXZlcnMpID0+IHtcbiAgICByZXR1cm4gZ2V0KCkuYWRkVG9RdWV1ZUludGVybmFsKHVuaXREYXRhLCBzdHJhdGVnaWNMZXZlcnMpO1xuICB9LFxuICBcbiAgYWRkVG9RdWV1ZUludGVybmFsOiAodW5pdERhdGEsIHN0cmF0ZWdpY0xldmVycz86IFN0cmF0ZWdpY0xldmVycykgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgXG4gICAgLy8gR2V0IGRlcGxveW1lbnQgc3RhdGUgZnJvbSBzYW5kYm94IHN0b3JlXG4gICAgbGV0IHBvZFRpZXI6IFBvZFRpZXJJZCA9IFwidGllcjFcIjtcbiAgICBsZXQgb3JiaXRNb2RlID0gXCJMRU9cIjtcbiAgICBsZXQgYWN0aXZlTGF1bmNoUHJvdmlkZXJzOiBMYXVuY2hQcm92aWRlcklkW10gPSBbXCJGOVwiXTtcbiAgICBsZXQgdG90YWxQb2RzQnVpbHQgPSAwO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHVzZVNhbmRib3hTdG9yZSB9ID0gcmVxdWlyZShcIi4vc2FuZGJveFN0b3JlXCIpO1xuICAgICAgY29uc3Qgc2FuZGJveFN0YXRlID0gdXNlU2FuZGJveFN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBwb2RUaWVyID0gc3RyYXRlZ2ljTGV2ZXJzPy5wb2RUaWVyIHx8IHNhbmRib3hTdGF0ZS5zZWxlY3RlZFBvZFRpZXI7XG4gICAgICBvcmJpdE1vZGUgPSBzdHJhdGVnaWNMZXZlcnM/Lm9yYml0TW9kZSB8fCBzYW5kYm94U3RhdGUub3JiaXRNb2RlO1xuICAgICAgYWN0aXZlTGF1bmNoUHJvdmlkZXJzID0gc3RyYXRlZ2ljTGV2ZXJzPy5hY3RpdmVMYXVuY2hQcm92aWRlcnMgfHwgc2FuZGJveFN0YXRlLmFjdGl2ZUxhdW5jaFByb3ZpZGVycztcbiAgICAgIHRvdGFsUG9kc0J1aWx0ID0gc2FuZGJveFN0YXRlLnRvdGFsUG9kc0J1aWx0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFVzZSBkZWZhdWx0cyBpZiBzdG9yZSBub3QgYXZhaWxhYmxlXG4gICAgfVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBkZXBsb3ltZW50IGVuZ2luZSBzdGF0ZVxuICAgIGNvbnN0IHRvdGFsUG9kc0luT3JiaXQgPSBzdGF0ZS51bml0cy5maWx0ZXIodSA9PiB1LnN0YXR1cyA9PT0gXCJkZXBsb3llZFwiKS5sZW5ndGg7XG4gICAgY29uc3QgdG90YWxQb2RzSW5RdWV1ZSA9IHN0YXRlLmRlcGxveW1lbnRRdWV1ZS5sZW5ndGg7XG4gICAgXG4gICAgY29uc3QgZGVwbG95bWVudFN0YXRlOiBEZXBsb3ltZW50U3RhdGUgPSB7XG4gICAgICB0b3RhbFBvZHNCdWlsdCxcbiAgICAgIHRvdGFsUG9kc0luT3JiaXQsXG4gICAgICB0b3RhbFBvZHNJblF1ZXVlLFxuICAgICAgYWN0aXZlTGF1bmNoUHJvdmlkZXJzLFxuICAgIH07XG4gICAgXG4gICAgY29uc3QgZW5naW5lID0gY2FsY3VsYXRlRGVwbG95bWVudEVuZ2luZShkZXBsb3ltZW50U3RhdGUpO1xuICAgIFxuICAgIC8vIENoZWNrIHF1ZXVlIGNhcFxuICAgIGlmICh0b3RhbFBvZHNJblF1ZXVlID49IGVuZ2luZS5tYXhRdWV1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBRdWV1ZSBmdWxsXG4gICAgfVxuICAgIFxuICAgIC8vIEdldCBwb2QgdGllciBkZWZpbml0aW9uXG4gICAgY29uc3QgdGllciA9IFBPRF9USUVSUy5maW5kKHQgPT4gdC5pZCA9PT0gcG9kVGllcikgfHwgUE9EX1RJRVJTWzBdO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBsZWFybmluZy1hZGp1c3RlZCBjb3N0IGFuZCB0aW1lXG4gICAgY29uc3QgbGVhcm5pbmdSYXRlID0gMC4wODtcbiAgICBjb25zdCB0aW1lTGVhcm5pbmdSYXRlID0gMC4wNDtcbiAgICBjb25zdCBjb3N0UGVyUG9kID0gdGllci5iYXNlQ29zdE0gKiBNYXRoLnBvdygxIC0gbGVhcm5pbmdSYXRlLCBNYXRoLm1pbih0b3RhbFBvZHNCdWlsdCwgMTAwKSk7XG4gICAgY29uc3QgYnVpbGRUaW1lUGVyUG9kID0gdGllci5iYXNlQnVpbGREYXlzICogTWF0aC5wb3coMSAtIHRpbWVMZWFybmluZ1JhdGUsIE1hdGgubWluKHRvdGFsUG9kc0J1aWx0LCAxMDApKTtcbiAgICBcbiAgICAvLyBGb3Igbm93LCB1c2UgbGVvX3BvZCBhcyBiYXNlIHVuaXQgdHlwZVxuICAgIC8vIFRPRE86IE1hcCBwb2QgdGllcnMgdG8gYWN0dWFsIHVuaXQgdHlwZXNcbiAgICAgIGNvbnN0IHVuaXQ6IE9yYml0YWxVbml0ID0ge1xuICAgICAgICAuLi51bml0RGF0YSxcbiAgICAgIGNvc3Q6IE1hdGgucm91bmQoY29zdFBlclBvZCAqIDEwMCkgLyAxMDAsXG4gICAgICBidWlsZFRpbWVEYXlzOiBNYXRoLnJvdW5kKGJ1aWxkVGltZVBlclBvZCksXG4gICAgICAgIGlkOiBgdW5pdF8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKVxuICAgICAgICAgIC50b1N0cmluZygzNilcbiAgICAgICAgICAuc3Vic3RyKDIsIDkpfWAsXG4gICAgICAgIHN0YXR1czogXCJxdWV1ZWRcIixcbiAgICAgIH07XG5cbiAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICBkZXBsb3ltZW50UXVldWU6IFsuLi5zdGF0ZS5kZXBsb3ltZW50UXVldWUsIHVuaXRdLFxuICAgIH0pKTtcbiAgICBcbiAgICByZXR1cm4gdHJ1ZTsgLy8gU3VjY2Vzc2Z1bGx5IGFkZGVkXG4gIH0sXG4gIFxuICBzdGFydEJ1aWxkOiAodW5pdElkKSA9PiB7XG4gICAgY29uc3QgdW5pdCA9IGdldCgpLmRlcGxveW1lbnRRdWV1ZS5maW5kKCh1KSA9PiB1LmlkID09PSB1bml0SWQpO1xuICAgIGlmICghdW5pdCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoaXMgdW5pdCBpcyBhbHJlYWR5IGJlaW5nIGJ1aWx0IG9yIGRlcGxveWVkICh0byBhdm9pZCBkb3VibGUtY291bnRpbmcgdGltZSlcbiAgICBjb25zdCBleGlzdGluZ1VuaXQgPSBnZXQoKS51bml0cy5maW5kKCh1KSA9PiB1LmlkID09PSB1bml0SWQpO1xuICAgIGlmIChleGlzdGluZ1VuaXQpIHJldHVybjsgLy8gQWxyZWFkeSBidWlsZGluZyBvciBkZXBsb3llZFxuICAgIFxuICAgIC8vIEFsbG93IHBhcmFsbGVsIGJ1aWxkcyAtIHN0YXJ0IGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBhdmFpbGFibGUgc2xvdHNcbiAgICBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50bHlCdWlsZGluZyA9IHN0YXRlLnVuaXRzLmZpbHRlcihcbiAgICAgICAgKHUpID0+IHUuc3RhdHVzID09PSBcImJ1aWxkaW5nXCJcbiAgICAgICk7XG4gICAgICBjb25zdCBuZXdVbml0cyA9IFtcbiAgICAgICAgLi4uc3RhdGUudW5pdHMsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi51bml0LFxuICAgICAgICAgIHN0YXR1czogXCJidWlsZGluZ1wiLFxuICAgICAgICAgIGJ1aWxkU3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICB9IGFzIE9yYml0YWxVbml0LFxuICAgICAgXTtcblxuICAgICAgLy8gTG9nYXJpdGhtaWMgXCJwYXJhbGxlbCBiYXRjaFwiIHRpbWUgY3VydmU6XG4gICAgICAvLyAxIHVuaXQgID0gMXggYmFzZSB0aW1lXG4gICAgICAvLyAyIHVuaXRzID0gfjEuNXggYmFzZSB0aW1lXG4gICAgICAvLyAzKyB1bml0cyA9IGRpbWluaXNoaW5nIGFkZGl0aW9uYWwgdGltZVxuICAgICAgY29uc3QgQkFTRV9EQVlTID0gdW5pdC5idWlsZFRpbWVEYXlzO1xuICAgICAgY29uc3QgcHJldkNvdW50ID0gY3VycmVudGx5QnVpbGRpbmcubGVuZ3RoO1xuICAgICAgY29uc3QgbmV3Q291bnQgPSBwcmV2Q291bnQgKyAxO1xuICAgICAgY29uc3QgY3VydmUgPSAobjogbnVtYmVyKSA9PlxuICAgICAgICBuIDw9IDAgPyAwIDogQkFTRV9EQVlTICogKDEgKyAwLjUgKiBNYXRoLmxvZzIobikpO1xuXG4gICAgICBjb25zdCBwcmV2QmF0Y2hUaW1lID0gY3VydmUocHJldkNvdW50KTtcbiAgICAgIGNvbnN0IG5ld0JhdGNoVGltZSA9IGN1cnZlKG5ld0NvdW50KTtcbiAgICAgIGNvbnN0IHRpbWVUb0FkZCA9IG5ld0JhdGNoVGltZSAtIHByZXZCYXRjaFRpbWU7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlcGxveW1lbnRRdWV1ZTogc3RhdGUuZGVwbG95bWVudFF1ZXVlLmZpbHRlcihcbiAgICAgICAgICAodSkgPT4gdS5pZCAhPT0gdW5pdElkXG4gICAgICAgICksXG4gICAgICAgIHVuaXRzOiBuZXdVbml0cyxcbiAgICAgICAgdG90YWxSZWFsV29ybGRUaW1lRGF5czpcbiAgICAgICAgICBzdGF0ZS50b3RhbFJlYWxXb3JsZFRpbWVEYXlzICsgTWF0aC5tYXgoMCwgdGltZVRvQWRkKSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH0sXG4gIFxuICBkZXBsb3lVbml0OiAodW5pdElkKSA9PiB7XG4gICAgc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgdW5pdCA9IHN0YXRlLnVuaXRzLmZpbmQodSA9PiB1LmlkID09PSB1bml0SWQpO1xuICAgICAgaWYgKCF1bml0IHx8IHVuaXQuc3RhdHVzID09PSBcImRlcGxveWVkXCIpIHJldHVybiBzdGF0ZTtcbiAgICAgIFxuICAgICAgLy8gSW5jcmVtZW50IHRvdGFsIHBvZHMgYnVpbHQgaW4gc2FuZGJveCBzdG9yZVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyB1c2VTYW5kYm94U3RvcmUgfSA9IHJlcXVpcmUoXCIuL3NhbmRib3hTdG9yZVwiKTtcbiAgICAgICAgdXNlU2FuZGJveFN0b3JlLmdldFN0YXRlKCkuaW5jcmVtZW50VG90YWxQb2RzQnVpbHQoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSWdub3JlIGlmIHN0b3JlIG5vdCBhdmFpbGFibGVcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgIHVuaXRzOiBzdGF0ZS51bml0cy5tYXAoKHUpID0+XG4gICAgICAgIHUuaWQgPT09IHVuaXRJZFxuICAgICAgICAgICAgPyB7IC4uLnUsIHN0YXR1czogXCJkZXBsb3llZFwiIGFzIGNvbnN0LCBkZXBsb3llZEF0OiBEYXRlLm5vdygpIH1cbiAgICAgICAgICA6IHVcbiAgICAgICksXG4gICAgICB9O1xuICAgIH0pO1xuICB9LFxuICBcbiAgcmVtb3ZlVW5pdDogKHVuaXRJZCkgPT4ge1xuICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICB1bml0czogc3RhdGUudW5pdHMuZmlsdGVyKCh1KSA9PiB1LmlkICE9PSB1bml0SWQpLFxuICAgICAgZGVwbG95bWVudFF1ZXVlOiBzdGF0ZS5kZXBsb3ltZW50UXVldWUuZmlsdGVyKCh1KSA9PiB1LmlkICE9PSB1bml0SWQpLFxuICAgIH0pKTtcbiAgfSxcbiAgXG4gIGdldFF1ZXVlZFVuaXRzOiAoKSA9PiBnZXQoKS5kZXBsb3ltZW50UXVldWUsXG4gIFxuICBnZXRCdWlsZGluZ1VuaXRzOiAoKSA9PiBnZXQoKS51bml0cy5maWx0ZXIoKHUpID0+IHUuc3RhdHVzID09PSBcImJ1aWxkaW5nXCIpLFxuICBcbiAgZ2V0RGVwbG95ZWRVbml0czogKCkgPT4gZ2V0KCkudW5pdHMuZmlsdGVyKCh1KSA9PiB1LnN0YXR1cyA9PT0gXCJkZXBsb3llZFwiKSxcbiAgXG4gIHVwZGF0ZUJ1aWxkUHJvZ3Jlc3M6ICgpID0+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIC8vIEJhc2UgYnVpbGQgdGltZSBpcyA1IHNlY29uZHMsIGJ1dCBwYXJhbGxlbCBidWlsZHMgcmVkdWNlIHRpbWUgdXNpbmcgbG9nYXJpdGhtaWMgc2NhbGluZ1xuICAgIC8vIEZvcm11bGE6IGJhc2VUaW1lIC8gKDEgKyBsb2cyKHBhcmFsbGVsQ291bnQpKVxuICAgIC8vIFNvIDEgdW5pdCA9IDVzLCAyIHVuaXRzID0gNS8yID0gMi41cywgNCB1bml0cyA9IDUvMyA9IDEuNjdzLCA4IHVuaXRzID0gNS80ID0gMS4yNXMsIGV0Yy5cbiAgICBjb25zdCBCQVNFX0JVSUxEX1RJTUVfTVMgPSA1MDAwOyAvLyA1IHNlY29uZHMgYmFzZVxuICAgIFxuICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGJ1aWxkaW5nVW5pdHMgPSBzdGF0ZS51bml0cy5maWx0ZXIoKHUpID0+IHUuc3RhdHVzID09PSBcImJ1aWxkaW5nXCIpO1xuICAgICAgY29uc3QgcGFyYWxsZWxDb3VudCA9IGJ1aWxkaW5nVW5pdHMubGVuZ3RoO1xuICAgICAgLy8gTG9nYXJpdGhtaWMgc2NhbGluZzogbW9yZSB1bml0cyA9IGZhc3RlciwgYnV0IGRpbWluaXNoaW5nIHJldHVybnNcbiAgICAgIGNvbnN0IGJ1aWxkVGltZU1zID0gcGFyYWxsZWxDb3VudCA+IDEgXG4gICAgICAgID8gQkFTRV9CVUlMRF9USU1FX01TIC8gKDEgKyBNYXRoLmxvZzIocGFyYWxsZWxDb3VudCkpXG4gICAgICAgIDogQkFTRV9CVUlMRF9USU1FX01TO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1bml0czogc3RhdGUudW5pdHMubWFwKCh1bml0KSA9PiB7XG4gICAgICAgICAgaWYgKHVuaXQuc3RhdHVzID09PSBcImJ1aWxkaW5nXCIgJiYgdW5pdC5idWlsZFN0YXJ0VGltZSkge1xuICAgICAgICAgICAgY29uc3QgZWxhcHNlZCA9IG5vdyAtIHVuaXQuYnVpbGRTdGFydFRpbWU7XG4gICAgICAgICAgICBpZiAoZWxhcHNlZCA+PSBidWlsZFRpbWVNcykge1xuICAgICAgICAgICAgICByZXR1cm4geyAuLi51bml0LCBzdGF0dXM6IFwiZGVwbG95ZWRcIiwgZGVwbG95ZWRBdDogbm93IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB1bml0O1xuICAgICAgICB9KSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH0sXG4gIFxuICByZXNldDogKCkgPT4ge1xuICAgIHNldCh7XG4gICAgICB1bml0czogW10sXG4gICAgICBkZXBsb3ltZW50UXVldWU6IFtdLFxuICAgICAgdG90YWxSZWFsV29ybGRUaW1lRGF5czogMCxcbiAgICB9KTtcbiAgfSxcbn0pKTtcblxuZXhwb3J0IHsgVU5JVF9ERUZJTklUSU9OUyB9O1xuXG4iXSwibmFtZXMiOlsiY3JlYXRlIiwiUE9EX1RJRVJTIiwiY2FsY3VsYXRlRGVwbG95bWVudEVuZ2luZSIsIlVOSVRfREVGSU5JVElPTlMiLCJsZW9fcG9kIiwidHlwZSIsIm5hbWUiLCJjb3N0IiwicG93ZXJPdXRwdXRNdyIsImxhdGVuY3lNcyIsImxpZmV0aW1lWWVhcnMiLCJidWlsZFRpbWVEYXlzIiwidXNlT3JiaXRhbFVuaXRzU3RvcmUiLCJzZXQiLCJnZXQiLCJ1bml0cyIsImRlcGxveW1lbnRRdWV1ZSIsInRvdGFsUmVhbFdvcmxkVGltZURheXMiLCJhZGRUb1F1ZXVlIiwidW5pdERhdGEiLCJzdHJhdGVnaWNMZXZlcnMiLCJhZGRUb1F1ZXVlSW50ZXJuYWwiLCJzdGF0ZSIsInBvZFRpZXIiLCJvcmJpdE1vZGUiLCJhY3RpdmVMYXVuY2hQcm92aWRlcnMiLCJ0b3RhbFBvZHNCdWlsdCIsInVzZVNhbmRib3hTdG9yZSIsInJlcXVpcmUiLCJzYW5kYm94U3RhdGUiLCJnZXRTdGF0ZSIsInNlbGVjdGVkUG9kVGllciIsImUiLCJ0b3RhbFBvZHNJbk9yYml0IiwiZmlsdGVyIiwidSIsInN0YXR1cyIsImxlbmd0aCIsInRvdGFsUG9kc0luUXVldWUiLCJkZXBsb3ltZW50U3RhdGUiLCJlbmdpbmUiLCJtYXhRdWV1ZSIsInRpZXIiLCJmaW5kIiwidCIsImlkIiwibGVhcm5pbmdSYXRlIiwidGltZUxlYXJuaW5nUmF0ZSIsImNvc3RQZXJQb2QiLCJiYXNlQ29zdE0iLCJNYXRoIiwicG93IiwibWluIiwiYnVpbGRUaW1lUGVyUG9kIiwiYmFzZUJ1aWxkRGF5cyIsInVuaXQiLCJyb3VuZCIsIkRhdGUiLCJub3ciLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsInN0YXJ0QnVpbGQiLCJ1bml0SWQiLCJleGlzdGluZ1VuaXQiLCJjdXJyZW50bHlCdWlsZGluZyIsIm5ld1VuaXRzIiwiYnVpbGRTdGFydFRpbWUiLCJCQVNFX0RBWVMiLCJwcmV2Q291bnQiLCJuZXdDb3VudCIsImN1cnZlIiwibiIsImxvZzIiLCJwcmV2QmF0Y2hUaW1lIiwibmV3QmF0Y2hUaW1lIiwidGltZVRvQWRkIiwibWF4IiwiZGVwbG95VW5pdCIsImluY3JlbWVudFRvdGFsUG9kc0J1aWx0IiwibWFwIiwiZGVwbG95ZWRBdCIsInJlbW92ZVVuaXQiLCJnZXRRdWV1ZWRVbml0cyIsImdldEJ1aWxkaW5nVW5pdHMiLCJnZXREZXBsb3llZFVuaXRzIiwidXBkYXRlQnVpbGRQcm9ncmVzcyIsIkJBU0VfQlVJTERfVElNRV9NUyIsImJ1aWxkaW5nVW5pdHMiLCJwYXJhbGxlbENvdW50IiwiYnVpbGRUaW1lTXMiLCJlbGFwc2VkIiwicmVzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/store/orbitalUnitsStore.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/store/sandboxStore.ts":
/*!***********************************!*\
  !*** ./app/store/sandboxStore.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSandboxStore: function() { return /* binding */ useSandboxStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var _lib_factory_factoryRecipes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/factory/factoryRecipes */ \"(app-pages-browser)/./app/lib/factory/factoryRecipes.ts\");\n/* harmony import */ var _lib_launch_launchQueue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/launch/launchQueue */ \"(app-pages-browser)/./app/lib/launch/launchQueue.ts\");\n/* harmony import */ var _lib_sim_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/sim/model */ \"(app-pages-browser)/./app/lib/sim/model.ts\");\n/* harmony import */ var _lib_sim_engine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/sim/engine */ \"(app-pages-browser)/./app/lib/sim/engine.ts\");\n\n\n\n\n\nconst useSandboxStore = (0,zustand__WEBPACK_IMPORTED_MODULE_4__.create)((set, get)=>({\n        orbitalComputeUnits: 0,\n        groundDCReduction: 0,\n        isMostlySpaceMode: false,\n        currentPreset: \"custom\",\n        sandboxMode: \"freeplay\",\n        activeMissionId: null,\n        missionProgress: 0,\n        unlockedMissions: [\n            \"mission_latency_desert\"\n        ],\n        completedMissions: [],\n        unlockedUnits: [\n            \"leo_pod\"\n        ],\n        isTutorialActive: false,\n        tutorialStep: 0,\n        isCompleted: false,\n        tutorialOrbitShareTarget: 30,\n        // Mission system state\n        unlockedOrbitModes: [\n            \"LEO\"\n        ],\n        unlockedLaunchProviders: [\n            \"F9\"\n        ],\n        missionStartTime: null,\n        missionTimeLimit: null,\n        // Strategic levers - defaults\n        selectedPodTier: \"tier1\",\n        orbitMode: \"LEO\",\n        activeLaunchProviders: [\n            \"F9\"\n        ],\n        offloadPct: 0,\n        densityMode: \"Safe\",\n        // Deployment state\n        totalPodsBuilt: 0,\n        // Factory state (new system)\n        factory: (0,_lib_factory_factoryRecipes__WEBPACK_IMPORTED_MODULE_0__.createDefaultFactoryState)(),\n        factoryBottlenecks: [],\n        launchState: (0,_lib_launch_launchQueue__WEBPACK_IMPORTED_MODULE_1__.createDefaultLaunchState)(),\n        // New Factorio-style sim state\n        simState: (0,_lib_sim_model__WEBPACK_IMPORTED_MODULE_2__.createInitialSimState)(),\n        // Deployment state\n        launchThreshold: 5,\n        fuelAvailableLaunches: 10,\n        launchSlotsThisMonth: 12,\n        podsPerLaunchCapacity: 6,\n        launchReliability: 0.95,\n        coolingOverhead: 0.20,\n        lastLaunchMetrics: null,\n        setOrbitalComputeUnits: (units)=>{\n            set({\n                orbitalComputeUnits: units\n            });\n            // Check if we've entered \"mostly space\" mode\n            const orbitShare = units / (units + (100 - get().groundDCReduction)) * 100;\n            set({\n                isMostlySpaceMode: orbitShare > 50\n            });\n        },\n        addOrbitalCompute: ()=>{\n            set((state)=>{\n                const newUnits = state.orbitalComputeUnits + 1;\n                const orbitShare = newUnits / (newUnits + (100 - state.groundDCReduction)) * 100;\n                return {\n                    orbitalComputeUnits: newUnits,\n                    isMostlySpaceMode: orbitShare > 50\n                };\n            });\n        },\n        setGroundDCReduction: (percent)=>{\n            set({\n                groundDCReduction: Math.max(0, Math.min(100, percent))\n            });\n            const state = get();\n            const orbitShare = state.orbitalComputeUnits / (state.orbitalComputeUnits + (100 - percent)) * 100;\n            set({\n                isMostlySpaceMode: orbitShare > 50\n            });\n            // Update mission progress if active\n            if (state.activeMissionId) {\n                const totalCompute = state.orbitalComputeUnits + (100 - percent);\n                const currentOrbitShare = totalCompute > 0 ? state.orbitalComputeUnits / totalCompute * 100 : 0;\n                if (state.activeMissionId === \"stabilize_abilene\" || state.activeMissionId === \"surge_event\") {\n                    const targetOrbitShare = 50;\n                    const progress = Math.min(100, currentOrbitShare / targetOrbitShare * 100);\n                    set({\n                        missionProgress: progress\n                    });\n                }\n            }\n        },\n        setPreset: (preset)=>{\n            if (preset === \"all_earth\") {\n                set({\n                    orbitalComputeUnits: 0,\n                    groundDCReduction: 0,\n                    currentPreset: preset\n                });\n            } else if (preset === \"hybrid_2035\") {\n                set({\n                    orbitalComputeUnits: 30,\n                    groundDCReduction: 0,\n                    currentPreset: preset\n                });\n            } else if (preset === \"orbit_dominant_2060\") {\n                set({\n                    orbitalComputeUnits: 75,\n                    groundDCReduction: 20,\n                    currentPreset: preset\n                });\n            } else if (preset === \"extreme_100_orbit\") {\n                set({\n                    orbitalComputeUnits: 100,\n                    groundDCReduction: 100,\n                    currentPreset: preset\n                });\n            } else {\n                set({\n                    currentPreset: preset\n                });\n            }\n            const state = get();\n            const orbitShare = state.orbitalComputeUnits / (state.orbitalComputeUnits + (100 - state.groundDCReduction)) * 100;\n            set({\n                isMostlySpaceMode: orbitShare > 50\n            });\n        },\n        setSandboxMode: (mode)=>{\n            set({\n                sandboxMode: mode\n            });\n            // In freeplay, unlock all units. In missions, only LEO pod is unlocked\n            if (mode === \"freeplay\") {\n                set({\n                    unlockedUnits: [\n                        \"leo_pod\",\n                        \"geo_hub\",\n                        \"server_farm\"\n                    ]\n                });\n            } else {\n                set({\n                    unlockedUnits: [\n                        \"leo_pod\"\n                    ]\n                });\n            }\n        },\n        setActiveMission: (missionId)=>{\n            if (!missionId) {\n                set({\n                    activeMissionId: null,\n                    sandboxMode: \"freeplay\",\n                    missionStartTime: null,\n                    missionTimeLimit: null\n                });\n                return;\n            }\n            // Load mission from missions module\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_app_game_missions_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ../game/missions */ \"(app-pages-browser)/./app/game/missions.ts\")).then((missionsModule)=>{\n                const mission = missionsModule.getMissionById(missionId);\n                if (mission) {\n                    const startingState = mission.startingState;\n                    const { reset } = (__webpack_require__(/*! ./orbitalUnitsStore */ \"(app-pages-browser)/./app/store/orbitalUnitsStore.ts\").useOrbitalUnitsStore.getState)();\n                    // Reset deployment queue\n                    reset();\n                    // Apply mission starting state\n                    set({\n                        activeMissionId: missionId,\n                        sandboxMode: \"missions\",\n                        orbitalComputeUnits: 0,\n                        groundDCReduction: 0,\n                        currentPreset: \"custom\",\n                        missionProgress: 0,\n                        selectedPodTier: \"tier1\",\n                        orbitMode: startingState.orbitBand,\n                        activeLaunchProviders: startingState.launchProvider ? [\n                            startingState.launchProvider\n                        ] : [\n                            \"F9\"\n                        ],\n                        densityMode: startingState.densityMode,\n                        offloadPct: startingState.offloadPct,\n                        missionStartTime: Date.now(),\n                        missionTimeLimit: null\n                    });\n                }\n            });\n        },\n        setMissionProgress: (progress)=>{\n            const newProgress = Math.max(0, Math.min(100, progress));\n            set({\n                missionProgress: newProgress\n            });\n            // Check if mission is complete and unlock units\n            const state = get();\n            if (newProgress >= 100 && state.activeMissionId) {\n                if (state.activeMissionId === \"stabilize_abilene\" && !state.unlockedUnits.includes(\"geo_hub\")) {\n                    set((s)=>({\n                            unlockedUnits: [\n                                ...s.unlockedUnits,\n                                \"geo_hub\"\n                            ]\n                        }));\n                } else if (state.activeMissionId === \"surge_event\" && !state.unlockedUnits.includes(\"server_farm\")) {\n                    set((s)=>({\n                            unlockedUnits: [\n                                ...s.unlockedUnits,\n                                \"server_farm\"\n                            ]\n                        }));\n                }\n            }\n        },\n        unlockUnit: (unitType)=>set((state)=>({\n                    unlockedUnits: state.unlockedUnits.includes(unitType) ? state.unlockedUnits : [\n                        ...state.unlockedUnits,\n                        unitType\n                    ]\n                })),\n        unlockMission: (missionId)=>set((state)=>({\n                    unlockedMissions: state.unlockedMissions.includes(missionId) ? state.unlockedMissions : [\n                        ...state.unlockedMissions,\n                        missionId\n                    ]\n                })),\n        markMissionCompleted: (missionId)=>{\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_app_game_missions_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ../game/missions */ \"(app-pages-browser)/./app/game/missions.ts\")).then((missionsModule)=>{\n                const mission = missionsModule.getMissionById(missionId);\n                if (mission) {\n                    const state = get();\n                    const newCompleted = state.completedMissions.includes(missionId) ? state.completedMissions : [\n                        ...state.completedMissions,\n                        missionId\n                    ];\n                    // Apply rewards\n                    const newUnlockedMissions = [\n                        ...state.unlockedMissions\n                    ];\n                    const newUnlockedOrbitModes = [\n                        ...state.unlockedOrbitModes\n                    ];\n                    const newUnlockedLaunchProviders = [\n                        ...state.unlockedLaunchProviders\n                    ];\n                    mission.rewards.forEach((reward)=>{\n                        if (reward.type === \"UNLOCK_MISSION\" && !newUnlockedMissions.includes(reward.value)) {\n                            newUnlockedMissions.push(reward.value);\n                        }\n                        if (reward.type === \"UNLOCK_ORBIT_MODE\" && !newUnlockedOrbitModes.includes(reward.value)) {\n                            newUnlockedOrbitModes.push(reward.value);\n                        }\n                        if (reward.type === \"UNLOCK_LAUNCH_PROVIDER\" && !newUnlockedLaunchProviders.includes(reward.value)) {\n                            newUnlockedLaunchProviders.push(reward.value);\n                        }\n                    // Note: Tech level unlocks are now handled by pod tier unlocks (automatic at 100/500 pods)\n                    });\n                    set({\n                        completedMissions: newCompleted,\n                        unlockedMissions: newUnlockedMissions,\n                        unlockedOrbitModes: newUnlockedOrbitModes,\n                        unlockedLaunchProviders: newUnlockedLaunchProviders,\n                        activeMissionId: null,\n                        sandboxMode: \"freeplay\",\n                        missionStartTime: null\n                    });\n                }\n            });\n        },\n        startTutorial: ()=>{\n            // Reset sandbox to baseline (ground-only) when starting tutorial\n            const state = get();\n            set({\n                isTutorialActive: true,\n                tutorialStep: 1,\n                orbitalComputeUnits: 0,\n                groundDCReduction: 0,\n                currentPreset: \"all_earth\",\n                missionProgress: 0,\n                activeMissionId: null\n            });\n        },\n        nextTutorialStep: ()=>set((state)=>{\n                if (state.tutorialStep === \"done\") return state;\n                const next = state.tutorialStep + 1;\n                if (next > 11) {\n                    return {\n                        tutorialStep: \"done\",\n                        isTutorialActive: false,\n                        isCompleted: true\n                    };\n                }\n                return {\n                    tutorialStep: next\n                };\n            }),\n        completeTutorial: ()=>set({\n                isTutorialActive: false,\n                tutorialStep: \"done\",\n                isCompleted: true\n            }),\n        setTutorialOrbitShareTarget: (target)=>set({\n                tutorialOrbitShareTarget: target\n            }),\n        setOrbitShare: (percent)=>{\n            const targetShare = Math.max(0, Math.min(100, percent)) / 100;\n            const state = get();\n            if (!state.simState) return;\n            // Calculate target pods based on orbital share\n            // Formula: orbitalShare = (podsInOrbit * podComputeKw) / targetComputeKw\n            // Solving: podsInOrbit = (targetShare * targetComputeKw) / podComputeKw\n            const targetComputeKw = state.simState.targetComputeKw;\n            const podComputeKw = state.simState.orbitalPodSpec.computeKw;\n            const targetPods = Math.round(targetShare * targetComputeKw / podComputeKw);\n            // Directly set podsInOrbit in simState\n            set({\n                simState: {\n                    ...state.simState,\n                    podsInOrbit: targetPods\n                },\n                orbitalComputeUnits: targetPods,\n                isMostlySpaceMode: targetShare > 0.5\n            });\n        },\n        resetSandbox: ()=>{\n            const state = get();\n            const mode = state.sandboxMode;\n            // In freeplay, unlock all units. In missions, only LEO pod\n            const defaultUnlocked = mode === \"freeplay\" ? [\n                \"leo_pod\",\n                \"geo_hub\",\n                \"server_farm\"\n            ] : [\n                \"leo_pod\"\n            ];\n            set({\n                orbitalComputeUnits: 0,\n                groundDCReduction: 0,\n                isMostlySpaceMode: false,\n                currentPreset: \"custom\",\n                activeMissionId: null,\n                missionProgress: 0,\n                unlockedUnits: defaultUnlocked,\n                // Reset strategic levers to defaults\n                selectedPodTier: \"tier1\",\n                orbitMode: \"MEO\",\n                activeLaunchProviders: [\n                    \"F9\"\n                ],\n                offloadPct: 0,\n                densityMode: \"Optimized\",\n                totalPodsBuilt: 0\n            });\n        },\n        // Strategic lever setters\n        setSelectedPodTier: (tier)=>set({\n                selectedPodTier: tier\n            }),\n        setOrbitMode: (mode)=>set({\n                orbitMode: mode\n            }),\n        setActiveLaunchProviders: (providers)=>set({\n                activeLaunchProviders: providers\n            }),\n        toggleLaunchProviderOld: (provider)=>set((state)=>{\n                const current = state.activeLaunchProviders;\n                if (current.includes(provider)) {\n                    // Remove if already active (but keep at least one)\n                    if (current.length > 1) {\n                        return {\n                            activeLaunchProviders: current.filter((p)=>p !== provider)\n                        };\n                    }\n                    return state; // Can't remove the last provider\n                } else {\n                    // Add if not active\n                    return {\n                        activeLaunchProviders: [\n                            ...current,\n                            provider\n                        ]\n                    };\n                }\n            }),\n        setOffloadPct: (pct)=>set({\n                offloadPct: Math.max(0, Math.min(100, pct))\n            }),\n        setDensityMode: (mode)=>set({\n                densityMode: mode\n            }),\n        incrementTotalPodsBuilt: ()=>set((state)=>({\n                    totalPodsBuilt: state.totalPodsBuilt + 1\n                })),\n        // Factory controls (new system)\n        runFactoryTick: (monthFraction)=>{\n            set((state)=>{\n                // Run factory production\n                const updatedFactory = (0,_lib_factory_factoryRecipes__WEBPACK_IMPORTED_MODULE_0__.runFactoryTick)(state.factory, monthFraction);\n                var _updatedFactory_inventory_pods;\n                // Process launch queue\n                const podsAvailable = (_updatedFactory_inventory_pods = updatedFactory.inventory.pods) !== null && _updatedFactory_inventory_pods !== void 0 ? _updatedFactory_inventory_pods : 0;\n                var _updatedFactory_inventory_fuel;\n                const fuelAvailable = (_updatedFactory_inventory_fuel = updatedFactory.inventory.fuel) !== null && _updatedFactory_inventory_fuel !== void 0 ? _updatedFactory_inventory_fuel : 0;\n                // Ensure launchState exists\n                const currentLaunchState = state.launchState || (0,_lib_launch_launchQueue__WEBPACK_IMPORTED_MODULE_1__.createDefaultLaunchState)();\n                const { newState: updatedLaunchState, podsLaunched } = (0,_lib_launch_launchQueue__WEBPACK_IMPORTED_MODULE_1__.processLaunchQueue)(currentLaunchState, podsAvailable, fuelAvailable, 10, monthFraction);\n                // Consume pods and fuel for launches, add to orbit\n                if (podsLaunched > 0) {\n                    var _updatedFactory_inventory_pods1;\n                    updatedFactory.inventory.pods = Math.max(0, ((_updatedFactory_inventory_pods1 = updatedFactory.inventory.pods) !== null && _updatedFactory_inventory_pods1 !== void 0 ? _updatedFactory_inventory_pods1 : 0) - podsLaunched);\n                    var _updatedFactory_inventory_fuel1;\n                    updatedFactory.inventory.fuel = Math.max(0, ((_updatedFactory_inventory_fuel1 = updatedFactory.inventory.fuel) !== null && _updatedFactory_inventory_fuel1 !== void 0 ? _updatedFactory_inventory_fuel1 : 0) - podsLaunched * 10);\n                    var _updatedFactory_inventory_orbitPods;\n                    updatedFactory.inventory.orbitPods = Math.floor(((_updatedFactory_inventory_orbitPods = updatedFactory.inventory.orbitPods) !== null && _updatedFactory_inventory_orbitPods !== void 0 ? _updatedFactory_inventory_orbitPods : 0) + podsLaunched);\n                }\n                // Compute bottlenecks\n                const bottlenecks = (0,_lib_factory_factoryRecipes__WEBPACK_IMPORTED_MODULE_0__.computeBottlenecks)(updatedFactory);\n                var _updatedFactory_inventory_orbitPods1;\n                return {\n                    factory: updatedFactory,\n                    factoryBottlenecks: bottlenecks,\n                    launchState: updatedLaunchState,\n                    totalPodsBuilt: (_updatedFactory_inventory_orbitPods1 = updatedFactory.inventory.orbitPods) !== null && _updatedFactory_inventory_orbitPods1 !== void 0 ? _updatedFactory_inventory_orbitPods1 : 0\n                };\n            });\n        },\n        updateFactoryLines: (nodeId, newLines)=>{\n            const currentState = get();\n            // Convert FactoryNodeId to RecipeFactoryNodeId\n            // Only nodes that exist in RecipeFactoryNodeId can be updated\n            let recipeNodeId;\n            if (nodeId === \"fuelPlant\") {\n                recipeNodeId = \"fuelDepot\";\n            } else if (nodeId === \"chipFab\" || nodeId === \"rackLine\" || nodeId === \"podFactory\" || nodeId === \"launchComplex\") {\n                recipeNodeId = nodeId;\n            } else {\n                // Node doesn't exist in RecipeFactoryNodeId (e.g., methaneTank, loxTank, etc.)\n                return false;\n            }\n            var _currentState_factory_lines_recipeNodeId;\n            const currentLines = (_currentState_factory_lines_recipeNodeId = currentState.factory.lines[recipeNodeId]) !== null && _currentState_factory_lines_recipeNodeId !== void 0 ? _currentState_factory_lines_recipeNodeId : 0;\n            const delta = newLines - currentLines;\n            // Check infra cap\n            const newUsedInfra = currentState.factory.usedInfraPoints + delta;\n            if (newUsedInfra > currentState.factory.maxInfraPoints) {\n                return false; // Can't exceed infra cap\n            }\n            // Update lines\n            const updatedLines = {\n                ...currentState.factory.lines,\n                [recipeNodeId]: Math.max(0, newLines)\n            };\n            set({\n                factory: {\n                    ...currentState.factory,\n                    lines: updatedLines,\n                    usedInfraPoints: newUsedInfra\n                }\n            });\n            return true; // Success\n        },\n        toggleLaunchProvider: (providerId)=>{\n            set((state)=>{\n                const provider = state.launchState.providers[providerId];\n                if (!provider) return state;\n                return {\n                    launchState: {\n                        ...state.launchState,\n                        providers: {\n                            ...state.launchState.providers,\n                            [providerId]: {\n                                ...provider,\n                                enabled: !provider.enabled\n                            }\n                        }\n                    }\n                };\n            });\n        },\n        // New Factorio-style sim controls\n        stepSimulation: (dtMinutes)=>{\n            set((state)=>{\n                var _nextState_resources_launches;\n                if (!state.simState) return state;\n                const nextState = (0,_lib_sim_engine__WEBPACK_IMPORTED_MODULE_3__.stepSim)(state.simState, dtMinutes);\n                var _nextState_resources_launches_buffer;\n                // Sync podsInOrbit from launches buffer (when launches complete, they become pods in orbit)\n                // This happens in stepSim when launches are produced, but we ensure it's synced here\n                const launchesBuffer = Math.floor((_nextState_resources_launches_buffer = (_nextState_resources_launches = nextState.resources.launches) === null || _nextState_resources_launches === void 0 ? void 0 : _nextState_resources_launches.buffer) !== null && _nextState_resources_launches_buffer !== void 0 ? _nextState_resources_launches_buffer : 0);\n                // podsInOrbit is already updated in stepSim when launches are produced\n                return {\n                    simState: nextState\n                };\n            });\n        },\n        updateMachineLines: (machineId, lines)=>{\n            set((state)=>{\n                if (!state.simState) return state;\n                const machine = state.simState.machines[machineId];\n                if (!machine) return state;\n                const newLines = Math.max(0, Math.floor(lines));\n                const lineDelta = newLines - machine.lines;\n                // If adding lines, check constraints\n                if (lineDelta > 0) {\n                    const { canAddMachineLine } = __webpack_require__(/*! ../lib/sim/constraints */ \"(app-pages-browser)/./app/lib/sim/constraints.ts\");\n                    const check = canAddMachineLine(state.simState, machineId, lineDelta);\n                    if (!check.canAdd) {\n                        // Show toast error\n                        const { showToast } = __webpack_require__(/*! ../lib/utils/toast */ \"(app-pages-browser)/./app/lib/utils/toast.ts\");\n                        showToast(check.reason || \"Cannot add machine line\", \"error\");\n                        // Return state unchanged\n                        return state;\n                    }\n                }\n                // Update machine lines\n                const updatedMachine = {\n                    ...machine,\n                    lines: newLines\n                };\n                // Recalculate constraints usage from all machines\n                const constraints = {\n                    ...state.simState.constraints\n                };\n                let totalPowerUsed = 0;\n                let totalCoolingUsed = 0;\n                let totalWorkforceUsed = 0;\n                Object.values(state.simState.machines).forEach((m)=>{\n                    const lines = m.id === machineId ? newLines : m.lines;\n                    totalPowerUsed += (m.powerDrawMW || 0) * lines;\n                    totalCoolingUsed += (m.heatMW || 0) * lines;\n                    totalWorkforceUsed += (m.workers || 0) * lines;\n                });\n                constraints.powerUsedMW = totalPowerUsed;\n                constraints.coolingUsedMW = totalCoolingUsed;\n                constraints.workforceUsed = totalWorkforceUsed;\n                return {\n                    simState: {\n                        ...state.simState,\n                        machines: {\n                            ...state.simState.machines,\n                            [machineId]: updatedMachine\n                        },\n                        constraints\n                    }\n                };\n            });\n        },\n        setTimeScale: (scale)=>{\n            set((state)=>{\n                if (!state.simState) return state;\n                return {\n                    simState: {\n                        ...state.simState,\n                        timeScale: scale\n                    }\n                };\n            });\n        },\n        // Deployment controls\n        setLaunchThreshold: (threshold)=>{\n            set({\n                launchThreshold: threshold\n            });\n        },\n        performLaunch: ()=>{\n            var _state_simState_resources_pods;\n            const state = get();\n            if (!state.simState) {\n                return {\n                    success: false,\n                    error: \"Simulation state not initialized\"\n                };\n            }\n            const podsInWarehouse = Math.floor(((_state_simState_resources_pods = state.simState.resources.pods) === null || _state_simState_resources_pods === void 0 ? void 0 : _state_simState_resources_pods.buffer) || 0);\n            const { launchThreshold, fuelAvailableLaunches, launchSlotsThisMonth, podsPerLaunchCapacity } = state;\n            // Check readiness\n            if (podsInWarehouse < launchThreshold) {\n                return {\n                    success: false,\n                    error: \"Need more pods\"\n                };\n            }\n            if (fuelAvailableLaunches <= 0) {\n                return {\n                    success: false,\n                    error: \"No fuel available\"\n                };\n            }\n            if (launchSlotsThisMonth <= 0) {\n                return {\n                    success: false,\n                    error: \"No launch slots remaining\"\n                };\n            }\n            // Calculate pods to launch\n            const maxPods = Math.min(launchThreshold, podsInWarehouse, podsPerLaunchCapacity);\n            const podsThisLaunch = Math.floor(maxPods);\n            if (podsThisLaunch <= 0) {\n                return {\n                    success: false,\n                    error: \"Cannot launch 0 pods\"\n                };\n            }\n            // Store metrics before launch\n            const { calculateDeploymentMetrics } = __webpack_require__(/*! ../lib/deployment/metrics */ \"(app-pages-browser)/./app/lib/deployment/metrics.ts\");\n            const metricsBefore = calculateDeploymentMetrics(state.simState);\n            // Update state\n            set((s)=>{\n                if (!s.simState) return s;\n                const updatedResources = {\n                    ...s.simState.resources,\n                    pods: {\n                        ...s.simState.resources.pods,\n                        buffer: Math.max(0, s.simState.resources.pods.buffer - podsThisLaunch)\n                    }\n                };\n                const updatedSimState = {\n                    ...s.simState,\n                    resources: updatedResources,\n                    podsInOrbit: s.simState.podsInOrbit + podsThisLaunch\n                };\n                // Calculate metrics after launch\n                const metricsAfter = calculateDeploymentMetrics(updatedSimState);\n                return {\n                    simState: updatedSimState,\n                    fuelAvailableLaunches: Math.max(0, s.fuelAvailableLaunches - 1),\n                    launchSlotsThisMonth: Math.max(0, s.launchSlotsThisMonth - 1),\n                    lastLaunchMetrics: {\n                        before: metricsBefore,\n                        after: metricsAfter,\n                        podsLaunched: podsThisLaunch\n                    }\n                };\n            });\n            return {\n                success: true,\n                podsLaunched: podsThisLaunch\n            };\n        },\n        setLaunchReliability: (reliability)=>{\n            set({\n                launchReliability: Math.max(0.80, Math.min(0.999, reliability))\n            });\n            window.dispatchEvent(new CustomEvent(\"controls-changed\"));\n        },\n        setCoolingOverhead: (overhead)=>{\n            set({\n                coolingOverhead: Math.max(0.10, Math.min(0.50, overhead))\n            });\n            window.dispatchEvent(new CustomEvent(\"controls-changed\"));\n        },\n        setGroundEnergyPrice: (price)=>{\n            const state = get();\n            if (state.simState) {\n                state.simState.groundDcSpec.energyPricePerMwh = Math.max(30, Math.min(100, price));\n                set({\n                    simState: {\n                        ...state.simState\n                    }\n                });\n                window.dispatchEvent(new CustomEvent(\"controls-changed\"));\n            }\n        },\n        setLaunchCapacity: (capacity)=>{\n            set({\n                launchSlotsThisMonth: Math.max(1, Math.min(40, Math.floor(capacity)))\n            });\n            window.dispatchEvent(new CustomEvent(\"controls-changed\"));\n        }\n    }));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zdG9yZS9zYW5kYm94U3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlDO0FBaUJNO0FBU0o7QUFFc0I7QUFDYjtBQThGckMsTUFBTVMsa0JBQWtCVCwrQ0FBTUEsQ0FBZSxDQUFDVSxLQUFLQyxNQUFTO1FBQ2pFQyxxQkFBcUI7UUFDckJDLG1CQUFtQjtRQUNuQkMsbUJBQW1CO1FBQ25CQyxlQUFlO1FBQ2ZDLGFBQWE7UUFDYkMsaUJBQWlCO1FBQ2pCQyxpQkFBaUI7UUFDakJDLGtCQUFrQjtZQUFDO1NBQXlCO1FBQzVDQyxtQkFBbUIsRUFBRTtRQUNyQkMsZUFBZTtZQUFDO1NBQVU7UUFDMUJDLGtCQUFrQjtRQUNsQkMsY0FBYztRQUNkQyxhQUFhO1FBQ2JDLDBCQUEwQjtRQUMxQix1QkFBdUI7UUFDdkJDLG9CQUFvQjtZQUFDO1NBQU07UUFDM0JDLHlCQUF5QjtZQUFDO1NBQUs7UUFDL0JDLGtCQUFrQjtRQUNsQkMsa0JBQWtCO1FBQ2xCLDhCQUE4QjtRQUM5QkMsaUJBQWlCO1FBQ2pCQyxXQUFXO1FBQ1hDLHVCQUF1QjtZQUFDO1NBQUs7UUFDN0JDLFlBQVk7UUFDWkMsYUFBYTtRQUNiLG1CQUFtQjtRQUNuQkMsZ0JBQWdCO1FBQ2hCLDZCQUE2QjtRQUM3QkMsU0FBU25DLHNGQUF5QkE7UUFDbENvQyxvQkFBb0IsRUFBRTtRQUN0QkMsYUFBYWpDLGlGQUF3QkE7UUFDckMsK0JBQStCO1FBQy9Ca0MsVUFBVWhDLHFFQUFxQkE7UUFDL0IsbUJBQW1CO1FBQ25CaUMsaUJBQWlCO1FBQ2pCQyx1QkFBdUI7UUFDdkJDLHNCQUFzQjtRQUN0QkMsdUJBQXVCO1FBQ3ZCQyxtQkFBbUI7UUFDbkJDLGlCQUFpQjtRQUNqQkMsbUJBQW1CO1FBQ25CQyx3QkFBd0IsQ0FBQ0M7WUFDdkJ0QyxJQUFJO2dCQUFFRSxxQkFBcUJvQztZQUFNO1lBQ2pDLDZDQUE2QztZQUM3QyxNQUFNQyxhQUFhLFFBQVVELENBQUFBLFFB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T0MsYUFBYSxDQUFDLElBQUlDLFlBQVk7UUFDdkM7SUFDRixJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9zdG9yZS9zYW5kYm94U3RvcmUudHM/NWRmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGUgfSBmcm9tIFwienVzdGFuZFwiO1xuaW1wb3J0IHsgTUlTU0lPTlMsIGdldE1pc3Npb25CeUlkIH0gZnJvbSBcIi4uL2dhbWUvbWlzc2lvbkVuZ2luZVwiO1xuaW1wb3J0IHR5cGUgeyBTaW11bGF0aW9uU3RhdGUgfSBmcm9tIFwiLi4vZ2FtZS9zaW1UeXBlc1wiO1xuaW1wb3J0IHsgdXNlU2ltU3RvcmUgfSBmcm9tIFwiLi9zaW1TdG9yZVwiO1xuaW1wb3J0IHsgdXNlT3JiaXRhbFVuaXRzU3RvcmUgfSBmcm9tIFwiLi9vcmJpdGFsVW5pdHNTdG9yZVwiO1xuaW1wb3J0IHR5cGUgeyBQb2RUaWVySWQgfSBmcm9tIFwiLi4vbGliL2RlcGxveW1lbnQvcG9kVGllcnNcIjtcbmltcG9ydCB0eXBlIHsgTGF1bmNoUHJvdmlkZXJJZCB9IGZyb20gXCIuLi9saWIvZGVwbG95bWVudC9sYXVuY2hQcm92aWRlcnNcIjtcbmltcG9ydCB0eXBlIHtcbiAgRmFjdG9yeVN0YXRlLFxuICBSZWNpcGVGYWN0b3J5Tm9kZUlkLFxuICBCb3R0bGVuZWNrLFxufSBmcm9tIFwiLi4vbGliL2ZhY3RvcnkvZmFjdG9yeVJlY2lwZXNcIjtcbmltcG9ydCB0eXBlIHsgRmFjdG9yeU5vZGVJZCB9IGZyb20gXCIuLi9saWIvZmFjdG9yeS9mYWN0b3J5TGF5b3V0XCI7XG5pbXBvcnQge1xuICBjcmVhdGVEZWZhdWx0RmFjdG9yeVN0YXRlLFxuICBydW5GYWN0b3J5VGljayBhcyBydW5GYWN0b3J5VGlja0VuZ2luZSxcbiAgY29tcHV0ZUJvdHRsZW5lY2tzLFxufSBmcm9tIFwiLi4vbGliL2ZhY3RvcnkvZmFjdG9yeVJlY2lwZXNcIjtcbmltcG9ydCB0eXBlIHtcbiAgTGF1bmNoU3RhdGUsXG4gIExhdW5jaFByb3ZpZGVySWQgYXMgTmV3TGF1bmNoUHJvdmlkZXJJZCxcbn0gZnJvbSBcIi4uL2xpYi9sYXVuY2gvbGF1bmNoUXVldWVcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZURlZmF1bHRMYXVuY2hTdGF0ZSxcbiAgcHJvY2Vzc0xhdW5jaFF1ZXVlLFxuICBjYWxjdWxhdGVEZXBsb3ltZW50UmF0ZSxcbn0gZnJvbSBcIi4uL2xpYi9sYXVuY2gvbGF1bmNoUXVldWVcIjtcbmltcG9ydCB0eXBlIHsgU2ltU3RhdGUsIE1hY2hpbmVJZCB9IGZyb20gXCIuLi9saWIvc2ltL21vZGVsXCI7XG5pbXBvcnQgeyBjcmVhdGVJbml0aWFsU2ltU3RhdGUgfSBmcm9tIFwiLi4vbGliL3NpbS9tb2RlbFwiO1xuaW1wb3J0IHsgc3RlcFNpbSB9IGZyb20gXCIuLi9saWIvc2ltL2VuZ2luZVwiO1xuXG5leHBvcnQgdHlwZSBTYW5kYm94UHJlc2V0ID0gXCJhbGxfZWFydGhcIiB8IFwiaHlicmlkXzIwMzVcIiB8IFwib3JiaXRfZG9taW5hbnRfMjA2MFwiIHwgXCJleHRyZW1lXzEwMF9vcmJpdFwiIHwgXCJjdXN0b21cIjtcbmV4cG9ydCB0eXBlIFNhbmRib3hNb2RlID0gXCJmcmVlcGxheVwiIHwgXCJtaXNzaW9uc1wiO1xuXG5leHBvcnQgdHlwZSBPcmJpdE1vZGUgPSBcIkxFT1wiIHwgXCJNRU9cIiB8IFwiR0VPXCI7XG5leHBvcnQgdHlwZSBEZW5zaXR5TW9kZSA9IFwiU2FmZVwiIHwgXCJBZ2dyZXNzaXZlXCIgfCBcIk9wdGltaXplZFwiO1xuXG5pbnRlcmZhY2UgU2FuZGJveFN0b3JlIHtcbiAgb3JiaXRhbENvbXB1dGVVbml0czogbnVtYmVyOyAvLyBOdW1iZXIgb2Ygb3JiaXRhbCBjb21wdXRlIHVuaXRzIGFkZGVkXG4gIGdyb3VuZERDUmVkdWN0aW9uOiBudW1iZXI7IC8vIFBlcmNlbnRhZ2Ugb2YgZ3JvdW5kIERDcyByZW1vdmVkICgwLTEwMClcbiAgaXNNb3N0bHlTcGFjZU1vZGU6IGJvb2xlYW47IC8vID41MCUgb3JiaXQgc2hhcmVcbiAgY3VycmVudFByZXNldDogU2FuZGJveFByZXNldDtcbiAgaXNUdXRvcmlhbEFjdGl2ZTogYm9vbGVhbjtcbiAgdHV0b3JpYWxTdGVwOiAwIHwgMSB8IDIgfCAzIHwgNCB8IDUgfCA2IHwgNyB8IDggfCA5IHwgMTAgfCAxMSB8IFwiZG9uZVwiO1xuICBzYW5kYm94TW9kZTogU2FuZGJveE1vZGU7XG4gIGFjdGl2ZU1pc3Npb25JZDogc3RyaW5nIHwgbnVsbDtcbiAgbWlzc2lvblByb2dyZXNzOiBudW1iZXI7IC8vIDAtMTAwXG4gIHVubG9ja2VkTWlzc2lvbnM6IHN0cmluZ1tdOyAvLyBtaXNzaW9uIGlkc1xuICBjb21wbGV0ZWRNaXNzaW9uczogc3RyaW5nW107XG4gIHVubG9ja2VkVW5pdHM6IHN0cmluZ1tdOyAvLyBMaXN0IG9mIHVubG9ja2VkIHVuaXQgdHlwZXMgKGUuZy4sIFtcImdlb19odWJcIiwgXCJzZXJ2ZXJfZmFybVwiXSlcbiAgaXNDb21wbGV0ZWQ6IGJvb2xlYW47IC8vIFdoZXRoZXIgc2FuZGJveCB0dXRvcmlhbCBpcyBjb21wbGV0ZWRcbiAgdHV0b3JpYWxPcmJpdFNoYXJlVGFyZ2V0OiBudW1iZXI7IC8vIFRhcmdldCBvcmJpdCBzaGFyZSBmb3Igc3RlcCAzICgzMCUpXG4gIC8vIE1pc3Npb24gc3lzdGVtIHN0YXRlXG4gIHVubG9ja2VkT3JiaXRNb2Rlczogc3RyaW5nW107IC8vIFVubG9ja2VkIG9yYml0IG1vZGVzXG4gIHVubG9ja2VkTGF1bmNoUHJvdmlkZXJzOiBzdHJpbmdbXTsgLy8gVW5sb2NrZWQgbGF1bmNoIHByb3ZpZGVyc1xuICBtaXNzaW9uU3RhcnRUaW1lOiBudW1iZXIgfCBudWxsOyAvLyBUaW1lc3RhbXAgd2hlbiBtaXNzaW9uIHN0YXJ0ZWRcbiAgbWlzc2lvblRpbWVMaW1pdDogbnVtYmVyIHwgbnVsbDsgLy8gVGltZSBsaW1pdCBpbiBzZWNvbmRzIChvcHRpb25hbClcbiAgLy8gU3RyYXRlZ2ljIGxldmVyc1xuICBzZWxlY3RlZFBvZFRpZXI6IFBvZFRpZXJJZDsgLy8gQ3VycmVudGx5IHNlbGVjdGVkIHBvZCB0aWVyXG4gIG9yYml0TW9kZTogT3JiaXRNb2RlO1xuICBhY3RpdmVMYXVuY2hQcm92aWRlcnM6IExhdW5jaFByb3ZpZGVySWRbXTsgLy8gTXVsdGlwbGUgcHJvdmlkZXJzIGNhbiBiZSBhY3RpdmVcbiAgb2ZmbG9hZFBjdDogbnVtYmVyOyAvLyAwLTEwMFxuICBkZW5zaXR5TW9kZTogRGVuc2l0eU1vZGU7XG4gIC8vIERlcGxveW1lbnQgc3RhdGVcbiAgdG90YWxQb2RzQnVpbHQ6IG51bWJlcjsgLy8gVG90YWwgcG9kcyBldmVyIGJ1aWx0IChmb3IgdGllciB1bmxvY2tzKVxuICAvLyBGYWN0b3J5IC8gcHJvZHVjdGlvbiBlbmdpbmUgKG5ldyBGYWN0b3Jpby1zdHlsZSlcbiAgZmFjdG9yeTogRmFjdG9yeVN0YXRlO1xuICBmYWN0b3J5Qm90dGxlbmVja3M6IEJvdHRsZW5lY2tbXTtcbiAgbGF1bmNoU3RhdGU6IExhdW5jaFN0YXRlO1xuICAvLyBOZXcgRmFjdG9yaW8tc3R5bGUgc2ltIHN0YXRlXG4gIHNpbVN0YXRlOiBTaW1TdGF0ZSB8IG51bGw7XG4gIC8vIERlcGxveW1lbnQgc3RhdGVcbiAgbGF1bmNoVGhyZXNob2xkOiBudW1iZXI7IC8vIDUsIDEwLCBvciBtYXhcbiAgZnVlbEF2YWlsYWJsZUxhdW5jaGVzOiBudW1iZXI7IC8vIEludGVnZXJcbiAgbGF1bmNoU2xvdHNUaGlzTW9udGg6IG51bWJlcjsgLy8gSW50ZWdlclxuICBwb2RzUGVyTGF1bmNoQ2FwYWNpdHk6IG51bWJlcjsgLy8gRnJvbSBMYXVuY2ggQ29tcGxleCBsZXZlbFxuICBsYXVuY2hSZWxpYWJpbGl0eTogbnVtYmVyOyAvLyAwLjgwLTAuOTk5ICg4MCUtOTkuOSUpXG4gIGNvb2xpbmdPdmVyaGVhZDogbnVtYmVyOyAvLyAwLjEwLTAuNTAgKDEwJS01MCUpXG4gIGxhc3RMYXVuY2hNZXRyaWNzOiB7XG4gICAgYmVmb3JlOiBhbnk7XG4gICAgYWZ0ZXI6IGFueTtcbiAgICBwb2RzTGF1bmNoZWQ6IG51bWJlcjtcbiAgfSB8IG51bGw7XG4gIHNldE9yYml0YWxDb21wdXRlVW5pdHM6ICh1bml0czogbnVtYmVyKSA9PiB2b2lkO1xuICBhZGRPcmJpdGFsQ29tcHV0ZTogKCkgPT4gdm9pZDtcbiAgc2V0R3JvdW5kRENSZWR1Y3Rpb246IChwZXJjZW50OiBudW1iZXIpID0+IHZvaWQ7XG4gIHNldFByZXNldDogKHByZXNldDogU2FuZGJveFByZXNldCkgPT4gdm9pZDtcbiAgc2V0U2FuZGJveE1vZGU6IChtb2RlOiBTYW5kYm94TW9kZSkgPT4gdm9pZDtcbiAgc2V0QWN0aXZlTWlzc2lvbjogKG1pc3Npb25JZDogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcbiAgc2V0TWlzc2lvblByb2dyZXNzOiAocHJvZ3Jlc3M6IG51bWJlcikgPT4gdm9pZDtcbiAgdW5sb2NrTWlzc2lvbjogKG1pc3Npb25JZDogc3RyaW5nKSA9PiB2b2lkO1xuICBtYXJrTWlzc2lvbkNvbXBsZXRlZDogKG1pc3Npb25JZDogc3RyaW5nKSA9PiB2b2lkO1xuICB1bmxvY2tVbml0OiAodW5pdFR5cGU6IHN0cmluZykgPT4gdm9pZDtcbiAgc3RhcnRUdXRvcmlhbDogKCkgPT4gdm9pZDtcbiAgbmV4dFR1dG9yaWFsU3RlcDogKCkgPT4gdm9pZDtcbiAgY29tcGxldGVUdXRvcmlhbDogKCkgPT4gdm9pZDtcbiAgcmVzZXRTYW5kYm94OiAoKSA9PiB2b2lkO1xuICBzZXRUdXRvcmlhbE9yYml0U2hhcmVUYXJnZXQ6ICh0YXJnZXQ6IG51bWJlcikgPT4gdm9pZDtcbiAgc2V0T3JiaXRTaGFyZTogKHBlcmNlbnQ6IG51bWJlcikgPT4gdm9pZDsgLy8gRGlyZWN0bHkgc2V0IG9yYml0IHNoYXJlICgwLTEwMClcbiAgLy8gU3RyYXRlZ2ljIGxldmVyIHNldHRlcnNcbiAgc2V0U2VsZWN0ZWRQb2RUaWVyOiAodGllcjogUG9kVGllcklkKSA9PiB2b2lkO1xuICBzZXRPcmJpdE1vZGU6IChtb2RlOiBPcmJpdE1vZGUpID0+IHZvaWQ7XG4gIHNldEFjdGl2ZUxhdW5jaFByb3ZpZGVyczogKHByb3ZpZGVyczogTGF1bmNoUHJvdmlkZXJJZFtdKSA9PiB2b2lkO1xuICB0b2dnbGVMYXVuY2hQcm92aWRlck9sZDogKHByb3ZpZGVyOiBMYXVuY2hQcm92aWRlcklkKSA9PiB2b2lkO1xuICBzZXRPZmZsb2FkUGN0OiAocGN0OiBudW1iZXIpID0+IHZvaWQ7XG4gIHNldERlbnNpdHlNb2RlOiAobW9kZTogRGVuc2l0eU1vZGUpID0+IHZvaWQ7XG4gIGluY3JlbWVudFRvdGFsUG9kc0J1aWx0OiAoKSA9PiB2b2lkO1xuICAvLyBGYWN0b3J5IGNvbnRyb2xzIChuZXcgc3lzdGVtKVxuICBydW5GYWN0b3J5VGljazogKG1vbnRoRnJhY3Rpb246IG51bWJlcikgPT4gdm9pZDtcbiAgdXBkYXRlTWFjaGluZUxpbmVzOiAobWFjaGluZUlkOiBNYWNoaW5lSWQsIGxpbmVzOiBudW1iZXIpID0+IHZvaWQ7XG4gIHVwZGF0ZUZhY3RvcnlMaW5lczogKG5vZGVJZDogRmFjdG9yeU5vZGVJZCwgbGluZXM6IG51bWJlcikgPT4gYm9vbGVhbjsgLy8gUmV0dXJucyB0cnVlIGlmIHN1Y2Nlc3NmdWxcbiAgdG9nZ2xlTGF1bmNoUHJvdmlkZXI6IChwcm92aWRlcklkOiBOZXdMYXVuY2hQcm92aWRlcklkKSA9PiB2b2lkO1xuICAvLyBEZXBsb3ltZW50IGNvbnRyb2xzXG4gIHNldExhdW5jaFRocmVzaG9sZDogKHRocmVzaG9sZDogbnVtYmVyKSA9PiB2b2lkO1xuICBwZXJmb3JtTGF1bmNoOiAoKSA9PiB7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nOyBwb2RzTGF1bmNoZWQ/OiBudW1iZXIgfTtcbiAgc2V0TGF1bmNoUmVsaWFiaWxpdHk6IChyZWxpYWJpbGl0eTogbnVtYmVyKSA9PiB2b2lkO1xuICBzZXRDb29saW5nT3ZlcmhlYWQ6IChvdmVyaGVhZDogbnVtYmVyKSA9PiB2b2lkO1xuICBzZXRHcm91bmRFbmVyZ3lQcmljZTogKHByaWNlOiBudW1iZXIpID0+IHZvaWQ7XG4gIHNldExhdW5jaENhcGFjaXR5OiAoY2FwYWNpdHk6IG51bWJlcikgPT4gdm9pZDtcbiAgc2V0VGltZVNjYWxlOiAoc2NhbGU6IDEgfCAxMCB8IDEwMCkgPT4gdm9pZDtcbiAgc3RlcFNpbXVsYXRpb246IChkdE1pbnV0ZXM6IG51bWJlcikgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGNvbnN0IHVzZVNhbmRib3hTdG9yZSA9IGNyZWF0ZTxTYW5kYm94U3RvcmU+KChzZXQsIGdldCkgPT4gKHtcbiAgb3JiaXRhbENvbXB1dGVVbml0czogMCxcbiAgZ3JvdW5kRENSZWR1Y3Rpb246IDAsXG4gIGlzTW9zdGx5U3BhY2VNb2RlOiBmYWxzZSxcbiAgY3VycmVudFByZXNldDogXCJjdXN0b21cIixcbiAgc2FuZGJveE1vZGU6IFwiZnJlZXBsYXlcIiBhcyBTYW5kYm94TW9kZSxcbiAgYWN0aXZlTWlzc2lvbklkOiBudWxsLFxuICBtaXNzaW9uUHJvZ3Jlc3M6IDAsXG4gIHVubG9ja2VkTWlzc2lvbnM6IFtcIm1pc3Npb25fbGF0ZW5jeV9kZXNlcnRcIl0sIC8vIFN0YXJ0IHdpdGggZmlyc3QgbWlzc2lvbiB1bmxvY2tlZFxuICBjb21wbGV0ZWRNaXNzaW9uczogW10sXG4gIHVubG9ja2VkVW5pdHM6IFtcImxlb19wb2RcIl0sIC8vIFN0YXJ0IHdpdGggb25seSBMRU8gcG9kIHVubG9ja2VkXG4gIGlzVHV0b3JpYWxBY3RpdmU6IGZhbHNlLFxuICB0dXRvcmlhbFN0ZXA6IDAsXG4gIGlzQ29tcGxldGVkOiBmYWxzZSwgLy8gU2FuZGJveCB0dXRvcmlhbCBjb21wbGV0aW9uIHN0YXR1c1xuICB0dXRvcmlhbE9yYml0U2hhcmVUYXJnZXQ6IDMwLCAvLyBEZWZhdWx0IHRhcmdldCBmb3Igc3RlcCAzXG4gIC8vIE1pc3Npb24gc3lzdGVtIHN0YXRlXG4gIHVubG9ja2VkT3JiaXRNb2RlczogW1wiTEVPXCJdLCAvLyBTdGFydCB3aXRoIExFTyBvbmx5XG4gIHVubG9ja2VkTGF1bmNoUHJvdmlkZXJzOiBbXCJGOVwiXSwgLy8gU3RhcnQgd2l0aCBGOSBvbmx5XG4gIG1pc3Npb25TdGFydFRpbWU6IG51bGwsXG4gIG1pc3Npb25UaW1lTGltaXQ6IG51bGwsXG4gIC8vIFN0cmF0ZWdpYyBsZXZlcnMgLSBkZWZhdWx0c1xuICBzZWxlY3RlZFBvZFRpZXI6IFwidGllcjFcIiwgLy8gU3RhcnQgd2l0aCBUaWVyIDFcbiAgb3JiaXRNb2RlOiBcIkxFT1wiLCAvLyBTdGFydCB3aXRoIExFTyAoZmlyc3QgbWlzc2lvbiByZXF1aXJlbWVudClcbiAgYWN0aXZlTGF1bmNoUHJvdmlkZXJzOiBbXCJGOVwiXSwgLy8gU3RhcnQgd2l0aCBGOSBvbmx5XG4gIG9mZmxvYWRQY3Q6IDAsIC8vIDAlID0gYWxsIGdyb3VuZFxuICBkZW5zaXR5TW9kZTogXCJTYWZlXCIsIC8vIFN0YXJ0IHdpdGggU2FmZSAoZmlyc3QgbWlzc2lvbiByZXF1aXJlbWVudClcbiAgLy8gRGVwbG95bWVudCBzdGF0ZVxuICB0b3RhbFBvZHNCdWlsdDogMCwgLy8gU3RhcnQgYXQgMCBwb2RzIGJ1aWx0XG4gIC8vIEZhY3Rvcnkgc3RhdGUgKG5ldyBzeXN0ZW0pXG4gIGZhY3Rvcnk6IGNyZWF0ZURlZmF1bHRGYWN0b3J5U3RhdGUoKSxcbiAgZmFjdG9yeUJvdHRsZW5lY2tzOiBbXSxcbiAgbGF1bmNoU3RhdGU6IGNyZWF0ZURlZmF1bHRMYXVuY2hTdGF0ZSgpLFxuICAvLyBOZXcgRmFjdG9yaW8tc3R5bGUgc2ltIHN0YXRlXG4gIHNpbVN0YXRlOiBjcmVhdGVJbml0aWFsU2ltU3RhdGUoKSxcbiAgLy8gRGVwbG95bWVudCBzdGF0ZVxuICBsYXVuY2hUaHJlc2hvbGQ6IDUsIC8vIERlZmF1bHQgdG8gNSBwb2RzXG4gIGZ1ZWxBdmFpbGFibGVMYXVuY2hlczogMTAsIC8vIFN0YXJ0IHdpdGggMTAgbGF1bmNoZXMgd29ydGggb2YgZnVlbFxuICBsYXVuY2hTbG90c1RoaXNNb250aDogMTIsIC8vIDEyIGxhdW5jaGVzIHBlciBtb250aCBjYXBhY2l0eVxuICBwb2RzUGVyTGF1bmNoQ2FwYWNpdHk6IDYsIC8vIERlZmF1bHQgNiBwb2RzIHBlciBsYXVuY2hcbiAgbGF1bmNoUmVsaWFiaWxpdHk6IDAuOTUsIC8vIDk1JSBkZWZhdWx0XG4gIGNvb2xpbmdPdmVyaGVhZDogMC4yMCwgLy8gMjAlIGRlZmF1bHRcbiAgbGFzdExhdW5jaE1ldHJpY3M6IG51bGwsXG4gIHNldE9yYml0YWxDb21wdXRlVW5pdHM6ICh1bml0cykgPT4ge1xuICAgIHNldCh7IG9yYml0YWxDb21wdXRlVW5pdHM6IHVuaXRzIH0pO1xuICAgIC8vIENoZWNrIGlmIHdlJ3ZlIGVudGVyZWQgXCJtb3N0bHkgc3BhY2VcIiBtb2RlXG4gICAgY29uc3Qgb3JiaXRTaGFyZSA9ICh1bml0cyAvICh1bml0cyArICgxMDAgLSBnZXQoKS5ncm91bmREQ1JlZHVjdGlvbikpKSAqIDEwMDtcbiAgICBzZXQoeyBpc01vc3RseVNwYWNlTW9kZTogb3JiaXRTaGFyZSA+IDUwIH0pO1xuICB9LFxuICBhZGRPcmJpdGFsQ29tcHV0ZTogKCkgPT4ge1xuICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IG5ld1VuaXRzID0gc3RhdGUub3JiaXRhbENvbXB1dGVVbml0cyArIDE7XG4gICAgICBjb25zdCBvcmJpdFNoYXJlID0gKG5ld1VuaXRzIC8gKG5ld1VuaXRzICsgKDEwMCAtIHN0YXRlLmdyb3VuZERDUmVkdWN0aW9uKSkpICogMTAwO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3JiaXRhbENvbXB1dGVVbml0czogbmV3VW5pdHMsXG4gICAgICAgIGlzTW9zdGx5U3BhY2VNb2RlOiBvcmJpdFNoYXJlID4gNTAsXG4gICAgICB9O1xuICAgIH0pO1xuICB9LFxuICBzZXRHcm91bmREQ1JlZHVjdGlvbjogKHBlcmNlbnQpID0+IHtcbiAgICBzZXQoeyBncm91bmREQ1JlZHVjdGlvbjogTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCBwZXJjZW50KSkgfSk7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICBjb25zdCBvcmJpdFNoYXJlID0gKHN0YXRlLm9yYml0YWxDb21wdXRlVW5pdHMgLyAoc3RhdGUub3JiaXRhbENvbXB1dGVVbml0cyArICgxMDAgLSBwZXJjZW50KSkpICogMTAwO1xuICAgIHNldCh7IGlzTW9zdGx5U3BhY2VNb2RlOiBvcmJpdFNoYXJlID4gNTAgfSk7XG4gICAgLy8gVXBkYXRlIG1pc3Npb24gcHJvZ3Jlc3MgaWYgYWN0aXZlXG4gICAgaWYgKHN0YXRlLmFjdGl2ZU1pc3Npb25JZCkge1xuICAgICAgY29uc3QgdG90YWxDb21wdXRlID0gc3RhdGUub3JiaXRhbENvbXB1dGVVbml0cyArICgxMDAgLSBwZXJjZW50KTtcbiAgICAgIGNvbnN0IGN1cnJlbnRPcmJpdFNoYXJlID0gdG90YWxDb21wdXRlID4gMCA/IChzdGF0ZS5vcmJpdGFsQ29tcHV0ZVVuaXRzIC8gdG90YWxDb21wdXRlKSAqIDEwMCA6IDA7XG4gICAgICBpZiAoc3RhdGUuYWN0aXZlTWlzc2lvbklkID09PSBcInN0YWJpbGl6ZV9hYmlsZW5lXCIgfHwgc3RhdGUuYWN0aXZlTWlzc2lvbklkID09PSBcInN1cmdlX2V2ZW50XCIpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0T3JiaXRTaGFyZSA9IDUwO1xuICAgICAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgubWluKDEwMCwgKGN1cnJlbnRPcmJpdFNoYXJlIC8gdGFyZ2V0T3JiaXRTaGFyZSkgKiAxMDApO1xuICAgICAgICBzZXQoeyBtaXNzaW9uUHJvZ3Jlc3M6IHByb2dyZXNzIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2V0UHJlc2V0OiAocHJlc2V0KSA9PiB7XG4gICAgaWYgKHByZXNldCA9PT0gXCJhbGxfZWFydGhcIikge1xuICAgICAgc2V0KHsgb3JiaXRhbENvbXB1dGVVbml0czogMCwgZ3JvdW5kRENSZWR1Y3Rpb246IDAsIGN1cnJlbnRQcmVzZXQ6IHByZXNldCB9KTtcbiAgICB9IGVsc2UgaWYgKHByZXNldCA9PT0gXCJoeWJyaWRfMjAzNVwiKSB7XG4gICAgICBzZXQoeyBvcmJpdGFsQ29tcHV0ZVVuaXRzOiAzMCwgZ3JvdW5kRENSZWR1Y3Rpb246IDAsIGN1cnJlbnRQcmVzZXQ6IHByZXNldCB9KTtcbiAgICB9IGVsc2UgaWYgKHByZXNldCA9PT0gXCJvcmJpdF9kb21pbmFudF8yMDYwXCIpIHtcbiAgICAgIHNldCh7IG9yYml0YWxDb21wdXRlVW5pdHM6IDc1LCBncm91bmREQ1JlZHVjdGlvbjogMjAsIGN1cnJlbnRQcmVzZXQ6IHByZXNldCB9KTtcbiAgICB9IGVsc2UgaWYgKHByZXNldCA9PT0gXCJleHRyZW1lXzEwMF9vcmJpdFwiKSB7XG4gICAgICBzZXQoeyBvcmJpdGFsQ29tcHV0ZVVuaXRzOiAxMDAsIGdyb3VuZERDUmVkdWN0aW9uOiAxMDAsIGN1cnJlbnRQcmVzZXQ6IHByZXNldCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0KHsgY3VycmVudFByZXNldDogcHJlc2V0IH0pO1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgIGNvbnN0IG9yYml0U2hhcmUgPSAoc3RhdGUub3JiaXRhbENvbXB1dGVVbml0cyAvIChzdGF0ZS5vcmJpdGFsQ29tcHV0ZVVuaXRzICsgKDEwMCAtIHN0YXRlLmdyb3VuZERDUmVkdWN0aW9uKSkpICogMTAwO1xuICAgIHNldCh7IGlzTW9zdGx5U3BhY2VNb2RlOiBvcmJpdFNoYXJlID4gNTAgfSk7XG4gIH0sXG4gIHNldFNhbmRib3hNb2RlOiAobW9kZSkgPT4ge1xuICAgIHNldCh7IHNhbmRib3hNb2RlOiBtb2RlIH0pO1xuICAgIC8vIEluIGZyZWVwbGF5LCB1bmxvY2sgYWxsIHVuaXRzLiBJbiBtaXNzaW9ucywgb25seSBMRU8gcG9kIGlzIHVubG9ja2VkXG4gICAgaWYgKG1vZGUgPT09IFwiZnJlZXBsYXlcIikge1xuICAgICAgc2V0KHsgdW5sb2NrZWRVbml0czogW1wibGVvX3BvZFwiLCBcImdlb19odWJcIiwgXCJzZXJ2ZXJfZmFybVwiXSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0KHsgdW5sb2NrZWRVbml0czogW1wibGVvX3BvZFwiXSB9KTtcbiAgICB9XG4gIH0sXG4gIHNldEFjdGl2ZU1pc3Npb246IChtaXNzaW9uSWQpID0+IHtcbiAgICBpZiAoIW1pc3Npb25JZCkge1xuICAgICAgc2V0KHsgXG4gICAgICAgIGFjdGl2ZU1pc3Npb25JZDogbnVsbCwgXG4gICAgICAgIHNhbmRib3hNb2RlOiBcImZyZWVwbGF5XCIsXG4gICAgICAgIG1pc3Npb25TdGFydFRpbWU6IG51bGwsXG4gICAgICAgIG1pc3Npb25UaW1lTGltaXQ6IG51bGwsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBMb2FkIG1pc3Npb24gZnJvbSBtaXNzaW9ucyBtb2R1bGVcbiAgICBpbXBvcnQoXCIuLi9nYW1lL21pc3Npb25zXCIpLnRoZW4oKG1pc3Npb25zTW9kdWxlKSA9PiB7XG4gICAgICBjb25zdCBtaXNzaW9uID0gbWlzc2lvbnNNb2R1bGUuZ2V0TWlzc2lvbkJ5SWQobWlzc2lvbklkKTtcbiAgICAgIFxuICAgICAgaWYgKG1pc3Npb24pIHtcbiAgICAgICAgY29uc3Qgc3RhcnRpbmdTdGF0ZSA9IG1pc3Npb24uc3RhcnRpbmdTdGF0ZTtcbiAgICAgICAgY29uc3QgeyByZXNldCB9ID0gcmVxdWlyZShcIi4vb3JiaXRhbFVuaXRzU3RvcmVcIikudXNlT3JiaXRhbFVuaXRzU3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlc2V0IGRlcGxveW1lbnQgcXVldWVcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFwcGx5IG1pc3Npb24gc3RhcnRpbmcgc3RhdGVcbiAgICAgICAgc2V0KHtcbiAgICAgICAgICBhY3RpdmVNaXNzaW9uSWQ6IG1pc3Npb25JZCxcbiAgICAgICAgICBzYW5kYm94TW9kZTogXCJtaXNzaW9uc1wiLFxuICAgICAgICAgIG9yYml0YWxDb21wdXRlVW5pdHM6IDAsXG4gICAgICAgICAgZ3JvdW5kRENSZWR1Y3Rpb246IDAsXG4gICAgICAgICAgY3VycmVudFByZXNldDogXCJjdXN0b21cIixcbiAgICAgICAgICBtaXNzaW9uUHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgc2VsZWN0ZWRQb2RUaWVyOiBcInRpZXIxXCIsIC8vIE1pc3Npb25zIHN0YXJ0IHdpdGggdGllciAxXG4gICAgICAgICAgb3JiaXRNb2RlOiBzdGFydGluZ1N0YXRlLm9yYml0QmFuZCBhcyBPcmJpdE1vZGUsXG4gICAgICAgICAgYWN0aXZlTGF1bmNoUHJvdmlkZXJzOiBzdGFydGluZ1N0YXRlLmxhdW5jaFByb3ZpZGVyID8gW3N0YXJ0aW5nU3RhdGUubGF1bmNoUHJvdmlkZXIgYXMgTGF1bmNoUHJvdmlkZXJJZF0gOiBbXCJGOVwiXSxcbiAgICAgICAgICBkZW5zaXR5TW9kZTogc3RhcnRpbmdTdGF0ZS5kZW5zaXR5TW9kZSBhcyBEZW5zaXR5TW9kZSxcbiAgICAgICAgICBvZmZsb2FkUGN0OiBzdGFydGluZ1N0YXRlLm9mZmxvYWRQY3QsXG4gICAgICAgICAgbWlzc2lvblN0YXJ0VGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICBtaXNzaW9uVGltZUxpbWl0OiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgc2V0TWlzc2lvblByb2dyZXNzOiAocHJvZ3Jlc3MpID0+IHtcbiAgICBjb25zdCBuZXdQcm9ncmVzcyA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgcHJvZ3Jlc3MpKTtcbiAgICBzZXQoeyBtaXNzaW9uUHJvZ3Jlc3M6IG5ld1Byb2dyZXNzIH0pO1xuICAgIC8vIENoZWNrIGlmIG1pc3Npb24gaXMgY29tcGxldGUgYW5kIHVubG9jayB1bml0c1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgaWYgKG5ld1Byb2dyZXNzID49IDEwMCAmJiBzdGF0ZS5hY3RpdmVNaXNzaW9uSWQpIHtcbiAgICAgIGlmIChzdGF0ZS5hY3RpdmVNaXNzaW9uSWQgPT09IFwic3RhYmlsaXplX2FiaWxlbmVcIiAmJiAhc3RhdGUudW5sb2NrZWRVbml0cy5pbmNsdWRlcyhcImdlb19odWJcIikpIHtcbiAgICAgICAgc2V0KChzKSA9PiAoeyB1bmxvY2tlZFVuaXRzOiBbLi4ucy51bmxvY2tlZFVuaXRzLCBcImdlb19odWJcIl0gfSkpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5hY3RpdmVNaXNzaW9uSWQgPT09IFwic3VyZ2VfZXZlbnRcIiAmJiAhc3RhdGUudW5sb2NrZWRVbml0cy5pbmNsdWRlcyhcInNlcnZlcl9mYXJtXCIpKSB7XG4gICAgICAgIHNldCgocykgPT4gKHsgdW5sb2NrZWRVbml0czogWy4uLnMudW5sb2NrZWRVbml0cywgXCJzZXJ2ZXJfZmFybVwiXSB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICB1bmxvY2tVbml0OiAodW5pdFR5cGUpID0+IHNldCgoc3RhdGUpID0+ICh7XG4gICAgdW5sb2NrZWRVbml0czogc3RhdGUudW5sb2NrZWRVbml0cy5pbmNsdWRlcyh1bml0VHlwZSkgXG4gICAgICA/IHN0YXRlLnVubG9ja2VkVW5pdHMgXG4gICAgICA6IFsuLi5zdGF0ZS51bmxvY2tlZFVuaXRzLCB1bml0VHlwZV1cbiAgfSkpLFxuICB1bmxvY2tNaXNzaW9uOiAobWlzc2lvbklkKSA9PlxuICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICB1bmxvY2tlZE1pc3Npb25zOiBzdGF0ZS51bmxvY2tlZE1pc3Npb25zLmluY2x1ZGVzKG1pc3Npb25JZClcbiAgICAgICAgPyBzdGF0ZS51bmxvY2tlZE1pc3Npb25zXG4gICAgICAgIDogWy4uLnN0YXRlLnVubG9ja2VkTWlzc2lvbnMsIG1pc3Npb25JZF0sXG4gICAgfSkpLFxuICBtYXJrTWlzc2lvbkNvbXBsZXRlZDogKG1pc3Npb25JZCkgPT4ge1xuICAgIGltcG9ydChcIi4uL2dhbWUvbWlzc2lvbnNcIikudGhlbigobWlzc2lvbnNNb2R1bGUpID0+IHtcbiAgICAgIGNvbnN0IG1pc3Npb24gPSBtaXNzaW9uc01vZHVsZS5nZXRNaXNzaW9uQnlJZChtaXNzaW9uSWQpO1xuICAgICAgXG4gICAgICBpZiAobWlzc2lvbikge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICBjb25zdCBuZXdDb21wbGV0ZWQgPSBzdGF0ZS5jb21wbGV0ZWRNaXNzaW9ucy5pbmNsdWRlcyhtaXNzaW9uSWQpXG4gICAgICAgID8gc3RhdGUuY29tcGxldGVkTWlzc2lvbnNcbiAgICAgICAgICA6IFsuLi5zdGF0ZS5jb21wbGV0ZWRNaXNzaW9ucywgbWlzc2lvbklkXTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFwcGx5IHJld2FyZHNcbiAgICAgICAgY29uc3QgbmV3VW5sb2NrZWRNaXNzaW9ucyA9IFsuLi5zdGF0ZS51bmxvY2tlZE1pc3Npb25zXTtcbiAgICAgICAgY29uc3QgbmV3VW5sb2NrZWRPcmJpdE1vZGVzID0gWy4uLnN0YXRlLnVubG9ja2VkT3JiaXRNb2Rlc107XG4gICAgICAgIGNvbnN0IG5ld1VubG9ja2VkTGF1bmNoUHJvdmlkZXJzID0gWy4uLnN0YXRlLnVubG9ja2VkTGF1bmNoUHJvdmlkZXJzXTtcbiAgICAgICAgXG4gICAgICAgIG1pc3Npb24ucmV3YXJkcy5mb3JFYWNoKChyZXdhcmQ6IGFueSkgPT4ge1xuICAgICAgICAgIGlmIChyZXdhcmQudHlwZSA9PT0gXCJVTkxPQ0tfTUlTU0lPTlwiICYmICFuZXdVbmxvY2tlZE1pc3Npb25zLmluY2x1ZGVzKHJld2FyZC52YWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1VubG9ja2VkTWlzc2lvbnMucHVzaChyZXdhcmQudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmV3YXJkLnR5cGUgPT09IFwiVU5MT0NLX09SQklUX01PREVcIiAmJiAhbmV3VW5sb2NrZWRPcmJpdE1vZGVzLmluY2x1ZGVzKHJld2FyZC52YWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1VubG9ja2VkT3JiaXRNb2Rlcy5wdXNoKHJld2FyZC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXdhcmQudHlwZSA9PT0gXCJVTkxPQ0tfTEFVTkNIX1BST1ZJREVSXCIgJiYgIW5ld1VubG9ja2VkTGF1bmNoUHJvdmlkZXJzLmluY2x1ZGVzKHJld2FyZC52YWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1VubG9ja2VkTGF1bmNoUHJvdmlkZXJzLnB1c2gocmV3YXJkLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTm90ZTogVGVjaCBsZXZlbCB1bmxvY2tzIGFyZSBub3cgaGFuZGxlZCBieSBwb2QgdGllciB1bmxvY2tzIChhdXRvbWF0aWMgYXQgMTAwLzUwMCBwb2RzKVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHNldCh7XG4gICAgICAgICAgY29tcGxldGVkTWlzc2lvbnM6IG5ld0NvbXBsZXRlZCxcbiAgICAgICAgICB1bmxvY2tlZE1pc3Npb25zOiBuZXdVbmxvY2tlZE1pc3Npb25zLFxuICAgICAgICAgIHVubG9ja2VkT3JiaXRNb2RlczogbmV3VW5sb2NrZWRPcmJpdE1vZGVzLFxuICAgICAgICAgIHVubG9ja2VkTGF1bmNoUHJvdmlkZXJzOiBuZXdVbmxvY2tlZExhdW5jaFByb3ZpZGVycyxcbiAgICAgICAgICBhY3RpdmVNaXNzaW9uSWQ6IG51bGwsIC8vIENvbXBsZXRlIG1pc3Npb24sIHJldHVybiB0byBmcmVlcGxheVxuICAgICAgICAgIHNhbmRib3hNb2RlOiBcImZyZWVwbGF5XCIsXG4gICAgICAgICAgbWlzc2lvblN0YXJ0VGltZTogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIHN0YXJ0VHV0b3JpYWw6ICgpID0+IHtcbiAgICAvLyBSZXNldCBzYW5kYm94IHRvIGJhc2VsaW5lIChncm91bmQtb25seSkgd2hlbiBzdGFydGluZyB0dXRvcmlhbFxuICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgc2V0KHsgXG4gICAgICBpc1R1dG9yaWFsQWN0aXZlOiB0cnVlLCBcbiAgICAgIHR1dG9yaWFsU3RlcDogMSxcbiAgICAgIG9yYml0YWxDb21wdXRlVW5pdHM6IDAsXG4gICAgICBncm91bmREQ1JlZHVjdGlvbjogMCxcbiAgICAgIGN1cnJlbnRQcmVzZXQ6IFwiYWxsX2VhcnRoXCIsXG4gICAgICBtaXNzaW9uUHJvZ3Jlc3M6IDAsXG4gICAgICBhY3RpdmVNaXNzaW9uSWQ6IG51bGwsXG4gICAgfSk7XG4gIH0sXG4gIG5leHRUdXRvcmlhbFN0ZXA6ICgpID0+IHNldCgoc3RhdGUpID0+IHtcbiAgICBpZiAoc3RhdGUudHV0b3JpYWxTdGVwID09PSBcImRvbmVcIikgcmV0dXJuIHN0YXRlO1xuICAgIGNvbnN0IG5leHQgPSBzdGF0ZS50dXRvcmlhbFN0ZXAgKyAxO1xuICAgIGlmIChuZXh0ID4gMTEpIHtcbiAgICAgIHJldHVybiB7IHR1dG9yaWFsU3RlcDogXCJkb25lXCIsIGlzVHV0b3JpYWxBY3RpdmU6IGZhbHNlLCBpc0NvbXBsZXRlZDogdHJ1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4geyB0dXRvcmlhbFN0ZXA6IG5leHQgYXMgMSB8IDIgfCAzIHwgNCB8IDUgfCA2IHwgNyB8IDggfCA5IHwgMTAgfCAxMSB9O1xuICB9KSxcbiAgY29tcGxldGVUdXRvcmlhbDogKCkgPT4gc2V0KHsgaXNUdXRvcmlhbEFjdGl2ZTogZmFsc2UsIHR1dG9yaWFsU3RlcDogXCJkb25lXCIsIGlzQ29tcGxldGVkOiB0cnVlIH0pLFxuICBzZXRUdXRvcmlhbE9yYml0U2hhcmVUYXJnZXQ6ICh0YXJnZXQpID0+IHNldCh7IHR1dG9yaWFsT3JiaXRTaGFyZVRhcmdldDogdGFyZ2V0IH0pLFxuICBzZXRPcmJpdFNoYXJlOiAocGVyY2VudCkgPT4ge1xuICAgIGNvbnN0IHRhcmdldFNoYXJlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCBwZXJjZW50KSkgLyAxMDA7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICBcbiAgICBpZiAoIXN0YXRlLnNpbVN0YXRlKSByZXR1cm47XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHRhcmdldCBwb2RzIGJhc2VkIG9uIG9yYml0YWwgc2hhcmVcbiAgICAvLyBGb3JtdWxhOiBvcmJpdGFsU2hhcmUgPSAocG9kc0luT3JiaXQgKiBwb2RDb21wdXRlS3cpIC8gdGFyZ2V0Q29tcHV0ZUt3XG4gICAgLy8gU29sdmluZzogcG9kc0luT3JiaXQgPSAodGFyZ2V0U2hhcmUgKiB0YXJnZXRDb21wdXRlS3cpIC8gcG9kQ29tcHV0ZUt3XG4gICAgY29uc3QgdGFyZ2V0Q29tcHV0ZUt3ID0gc3RhdGUuc2ltU3RhdGUudGFyZ2V0Q29tcHV0ZUt3O1xuICAgIGNvbnN0IHBvZENvbXB1dGVLdyA9IHN0YXRlLnNpbVN0YXRlLm9yYml0YWxQb2RTcGVjLmNvbXB1dGVLdztcbiAgICBjb25zdCB0YXJnZXRQb2RzID0gTWF0aC5yb3VuZCgodGFyZ2V0U2hhcmUgKiB0YXJnZXRDb21wdXRlS3cpIC8gcG9kQ29tcHV0ZUt3KTtcbiAgICBcbiAgICAvLyBEaXJlY3RseSBzZXQgcG9kc0luT3JiaXQgaW4gc2ltU3RhdGVcbiAgICBzZXQoe1xuICAgICAgc2ltU3RhdGU6IHtcbiAgICAgICAgLi4uc3RhdGUuc2ltU3RhdGUsXG4gICAgICAgIHBvZHNJbk9yYml0OiB0YXJnZXRQb2RzLFxuICAgICAgfSxcbiAgICAgIG9yYml0YWxDb21wdXRlVW5pdHM6IHRhcmdldFBvZHMsIC8vIEtlZXAgaW4gc3luY1xuICAgICAgaXNNb3N0bHlTcGFjZU1vZGU6IHRhcmdldFNoYXJlID4gMC41LFxuICAgIH0pO1xuICB9LFxuICByZXNldFNhbmRib3g6ICgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgIGNvbnN0IG1vZGUgPSBzdGF0ZS5zYW5kYm94TW9kZTtcbiAgICAvLyBJbiBmcmVlcGxheSwgdW5sb2NrIGFsbCB1bml0cy4gSW4gbWlzc2lvbnMsIG9ubHkgTEVPIHBvZFxuICAgIGNvbnN0IGRlZmF1bHRVbmxvY2tlZCA9IG1vZGUgPT09IFwiZnJlZXBsYXlcIiBcbiAgICAgID8gW1wibGVvX3BvZFwiLCBcImdlb19odWJcIiwgXCJzZXJ2ZXJfZmFybVwiXVxuICAgICAgOiBbXCJsZW9fcG9kXCJdO1xuICAgIHNldCh7IFxuICAgICAgb3JiaXRhbENvbXB1dGVVbml0czogMCwgXG4gICAgICBncm91bmREQ1JlZHVjdGlvbjogMCwgXG4gICAgICBpc01vc3RseVNwYWNlTW9kZTogZmFsc2UsIFxuICAgICAgY3VycmVudFByZXNldDogXCJjdXN0b21cIixcbiAgICAgIGFjdGl2ZU1pc3Npb25JZDogbnVsbCxcbiAgICAgIG1pc3Npb25Qcm9ncmVzczogMCxcbiAgICAgIHVubG9ja2VkVW5pdHM6IGRlZmF1bHRVbmxvY2tlZCxcbiAgICAgIC8vIFJlc2V0IHN0cmF0ZWdpYyBsZXZlcnMgdG8gZGVmYXVsdHNcbiAgICAgIHNlbGVjdGVkUG9kVGllcjogXCJ0aWVyMVwiLFxuICAgICAgb3JiaXRNb2RlOiBcIk1FT1wiLFxuICAgICAgYWN0aXZlTGF1bmNoUHJvdmlkZXJzOiBbXCJGOVwiXSxcbiAgICAgIG9mZmxvYWRQY3Q6IDAsXG4gICAgICBkZW5zaXR5TW9kZTogXCJPcHRpbWl6ZWRcIixcbiAgICAgIHRvdGFsUG9kc0J1aWx0OiAwLFxuICAgIH0pO1xuICB9LFxuICAvLyBTdHJhdGVnaWMgbGV2ZXIgc2V0dGVyc1xuICBzZXRTZWxlY3RlZFBvZFRpZXI6ICh0aWVyKSA9PiBzZXQoeyBzZWxlY3RlZFBvZFRpZXI6IHRpZXIgfSksXG4gIHNldE9yYml0TW9kZTogKG1vZGUpID0+IHNldCh7IG9yYml0TW9kZTogbW9kZSB9KSxcbiAgc2V0QWN0aXZlTGF1bmNoUHJvdmlkZXJzOiAocHJvdmlkZXJzKSA9PiBzZXQoeyBhY3RpdmVMYXVuY2hQcm92aWRlcnM6IHByb3ZpZGVycyB9KSxcbiAgdG9nZ2xlTGF1bmNoUHJvdmlkZXJPbGQ6IChwcm92aWRlcikgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBzdGF0ZS5hY3RpdmVMYXVuY2hQcm92aWRlcnM7XG4gICAgaWYgKGN1cnJlbnQuaW5jbHVkZXMocHJvdmlkZXIpKSB7XG4gICAgICAvLyBSZW1vdmUgaWYgYWxyZWFkeSBhY3RpdmUgKGJ1dCBrZWVwIGF0IGxlYXN0IG9uZSlcbiAgICAgIGlmIChjdXJyZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHsgYWN0aXZlTGF1bmNoUHJvdmlkZXJzOiBjdXJyZW50LmZpbHRlcihwID0+IHAgIT09IHByb3ZpZGVyKSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRlOyAvLyBDYW4ndCByZW1vdmUgdGhlIGxhc3QgcHJvdmlkZXJcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWRkIGlmIG5vdCBhY3RpdmVcbiAgICAgIHJldHVybiB7IGFjdGl2ZUxhdW5jaFByb3ZpZGVyczogWy4uLmN1cnJlbnQsIHByb3ZpZGVyXSB9O1xuICAgIH1cbiAgfSksXG4gIHNldE9mZmxvYWRQY3Q6IChwY3QpID0+IHNldCh7IG9mZmxvYWRQY3Q6IE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgcGN0KSkgfSksXG4gIHNldERlbnNpdHlNb2RlOiAobW9kZSkgPT4gc2V0KHsgZGVuc2l0eU1vZGU6IG1vZGUgfSksXG4gIGluY3JlbWVudFRvdGFsUG9kc0J1aWx0OiAoKSA9PiBzZXQoKHN0YXRlKSA9PiAoeyB0b3RhbFBvZHNCdWlsdDogc3RhdGUudG90YWxQb2RzQnVpbHQgKyAxIH0pKSxcbiAgLy8gRmFjdG9yeSBjb250cm9scyAobmV3IHN5c3RlbSlcbiAgcnVuRmFjdG9yeVRpY2s6IChtb250aEZyYWN0aW9uKSA9PiB7XG4gICAgc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgLy8gUnVuIGZhY3RvcnkgcHJvZHVjdGlvblxuICAgICAgY29uc3QgdXBkYXRlZEZhY3RvcnkgPSBydW5GYWN0b3J5VGlja0VuZ2luZShzdGF0ZS5mYWN0b3J5LCBtb250aEZyYWN0aW9uKTtcbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyBsYXVuY2ggcXVldWVcbiAgICAgIGNvbnN0IHBvZHNBdmFpbGFibGUgPSB1cGRhdGVkRmFjdG9yeS5pbnZlbnRvcnkucG9kcyA/PyAwO1xuICAgICAgY29uc3QgZnVlbEF2YWlsYWJsZSA9IHVwZGF0ZWRGYWN0b3J5LmludmVudG9yeS5mdWVsID8/IDA7XG4gICAgICAvLyBFbnN1cmUgbGF1bmNoU3RhdGUgZXhpc3RzXG4gICAgICBjb25zdCBjdXJyZW50TGF1bmNoU3RhdGUgPSBzdGF0ZS5sYXVuY2hTdGF0ZSB8fCBjcmVhdGVEZWZhdWx0TGF1bmNoU3RhdGUoKTtcbiAgICAgIGNvbnN0IHsgbmV3U3RhdGU6IHVwZGF0ZWRMYXVuY2hTdGF0ZSwgcG9kc0xhdW5jaGVkIH0gPSBwcm9jZXNzTGF1bmNoUXVldWUoXG4gICAgICAgIGN1cnJlbnRMYXVuY2hTdGF0ZSxcbiAgICAgICAgcG9kc0F2YWlsYWJsZSxcbiAgICAgICAgZnVlbEF2YWlsYWJsZSxcbiAgICAgICAgMTAsIC8vIGZ1ZWxQZXJMYXVuY2hcbiAgICAgICAgbW9udGhGcmFjdGlvblxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gQ29uc3VtZSBwb2RzIGFuZCBmdWVsIGZvciBsYXVuY2hlcywgYWRkIHRvIG9yYml0XG4gICAgICBpZiAocG9kc0xhdW5jaGVkID4gMCkge1xuICAgICAgICB1cGRhdGVkRmFjdG9yeS5pbnZlbnRvcnkucG9kcyA9IE1hdGgubWF4KDAsICh1cGRhdGVkRmFjdG9yeS5pbnZlbnRvcnkucG9kcyA/PyAwKSAtIHBvZHNMYXVuY2hlZCk7XG4gICAgICAgIHVwZGF0ZWRGYWN0b3J5LmludmVudG9yeS5mdWVsID0gTWF0aC5tYXgoMCwgKHVwZGF0ZWRGYWN0b3J5LmludmVudG9yeS5mdWVsID8/IDApIC0gcG9kc0xhdW5jaGVkICogMTApO1xuICAgICAgICB1cGRhdGVkRmFjdG9yeS5pbnZlbnRvcnkub3JiaXRQb2RzID0gTWF0aC5mbG9vcigodXBkYXRlZEZhY3RvcnkuaW52ZW50b3J5Lm9yYml0UG9kcyA/PyAwKSArIHBvZHNMYXVuY2hlZCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENvbXB1dGUgYm90dGxlbmVja3NcbiAgICAgIGNvbnN0IGJvdHRsZW5lY2tzID0gY29tcHV0ZUJvdHRsZW5lY2tzKHVwZGF0ZWRGYWN0b3J5KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmFjdG9yeTogdXBkYXRlZEZhY3RvcnksXG4gICAgICAgIGZhY3RvcnlCb3R0bGVuZWNrczogYm90dGxlbmVja3MsXG4gICAgICAgIGxhdW5jaFN0YXRlOiB1cGRhdGVkTGF1bmNoU3RhdGUsXG4gICAgICAgIHRvdGFsUG9kc0J1aWx0OiB1cGRhdGVkRmFjdG9yeS5pbnZlbnRvcnkub3JiaXRQb2RzID8/IDAsXG4gICAgICB9O1xuICAgIH0pO1xuICB9LFxuICB1cGRhdGVGYWN0b3J5TGluZXM6IChub2RlSWQsIG5ld0xpbmVzKSA9PiB7XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gZ2V0KCk7XG4gICAgLy8gQ29udmVydCBGYWN0b3J5Tm9kZUlkIHRvIFJlY2lwZUZhY3RvcnlOb2RlSWRcbiAgICAvLyBPbmx5IG5vZGVzIHRoYXQgZXhpc3QgaW4gUmVjaXBlRmFjdG9yeU5vZGVJZCBjYW4gYmUgdXBkYXRlZFxuICAgIGxldCByZWNpcGVOb2RlSWQ6IFJlY2lwZUZhY3RvcnlOb2RlSWQ7XG4gICAgaWYgKG5vZGVJZCA9PT0gJ2Z1ZWxQbGFudCcpIHtcbiAgICAgIHJlY2lwZU5vZGVJZCA9ICdmdWVsRGVwb3QnO1xuICAgIH0gZWxzZSBpZiAobm9kZUlkID09PSAnY2hpcEZhYicgfHwgbm9kZUlkID09PSAncmFja0xpbmUnIHx8IG5vZGVJZCA9PT0gJ3BvZEZhY3RvcnknIHx8IG5vZGVJZCA9PT0gJ2xhdW5jaENvbXBsZXgnKSB7XG4gICAgICByZWNpcGVOb2RlSWQgPSBub2RlSWQgYXMgUmVjaXBlRmFjdG9yeU5vZGVJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm9kZSBkb2Vzbid0IGV4aXN0IGluIFJlY2lwZUZhY3RvcnlOb2RlSWQgKGUuZy4sIG1ldGhhbmVUYW5rLCBsb3hUYW5rLCBldGMuKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50TGluZXMgPSBjdXJyZW50U3RhdGUuZmFjdG9yeS5saW5lc1tyZWNpcGVOb2RlSWRdID8/IDA7XG4gICAgY29uc3QgZGVsdGEgPSBuZXdMaW5lcyAtIGN1cnJlbnRMaW5lcztcbiAgICBcbiAgICAvLyBDaGVjayBpbmZyYSBjYXBcbiAgICBjb25zdCBuZXdVc2VkSW5mcmEgPSBjdXJyZW50U3RhdGUuZmFjdG9yeS51c2VkSW5mcmFQb2ludHMgKyBkZWx0YTtcbiAgICBpZiAobmV3VXNlZEluZnJhID4gY3VycmVudFN0YXRlLmZhY3RvcnkubWF4SW5mcmFQb2ludHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gQ2FuJ3QgZXhjZWVkIGluZnJhIGNhcFxuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgbGluZXNcbiAgICBjb25zdCB1cGRhdGVkTGluZXMgPSB7XG4gICAgICAuLi5jdXJyZW50U3RhdGUuZmFjdG9yeS5saW5lcyxcbiAgICAgIFtyZWNpcGVOb2RlSWRdOiBNYXRoLm1heCgwLCBuZXdMaW5lcyksXG4gICAgfTtcbiAgICBcbiAgICBzZXQoe1xuICAgICAgZmFjdG9yeToge1xuICAgICAgICAuLi5jdXJyZW50U3RhdGUuZmFjdG9yeSxcbiAgICAgICAgbGluZXM6IHVwZGF0ZWRMaW5lcyxcbiAgICAgICAgdXNlZEluZnJhUG9pbnRzOiBuZXdVc2VkSW5mcmEsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB0cnVlOyAvLyBTdWNjZXNzXG4gIH0sXG4gIHRvZ2dsZUxhdW5jaFByb3ZpZGVyOiAocHJvdmlkZXJJZCkgPT4ge1xuICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gc3RhdGUubGF1bmNoU3RhdGUucHJvdmlkZXJzW3Byb3ZpZGVySWRdO1xuICAgICAgaWYgKCFwcm92aWRlcikgcmV0dXJuIHN0YXRlO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYXVuY2hTdGF0ZToge1xuICAgICAgICAgIC4uLnN0YXRlLmxhdW5jaFN0YXRlLFxuICAgICAgICAgIHByb3ZpZGVyczoge1xuICAgICAgICAgICAgLi4uc3RhdGUubGF1bmNoU3RhdGUucHJvdmlkZXJzLFxuICAgICAgICAgICAgW3Byb3ZpZGVySWRdOiB7XG4gICAgICAgICAgICAgIC4uLnByb3ZpZGVyLFxuICAgICAgICAgICAgICBlbmFibGVkOiAhcHJvdmlkZXIuZW5hYmxlZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH0sXG4gIC8vIE5ldyBGYWN0b3Jpby1zdHlsZSBzaW0gY29udHJvbHNcbiAgc3RlcFNpbXVsYXRpb246IChkdE1pbnV0ZXMpID0+IHtcbiAgICBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICBpZiAoIXN0YXRlLnNpbVN0YXRlKSByZXR1cm4gc3RhdGU7XG4gICAgICBjb25zdCBuZXh0U3RhdGUgPSBzdGVwU2ltKHN0YXRlLnNpbVN0YXRlLCBkdE1pbnV0ZXMpO1xuICAgICAgXG4gICAgICAvLyBTeW5jIHBvZHNJbk9yYml0IGZyb20gbGF1bmNoZXMgYnVmZmVyICh3aGVuIGxhdW5jaGVzIGNvbXBsZXRlLCB0aGV5IGJlY29tZSBwb2RzIGluIG9yYml0KVxuICAgICAgLy8gVGhpcyBoYXBwZW5zIGluIHN0ZXBTaW0gd2hlbiBsYXVuY2hlcyBhcmUgcHJvZHVjZWQsIGJ1dCB3ZSBlbnN1cmUgaXQncyBzeW5jZWQgaGVyZVxuICAgICAgY29uc3QgbGF1bmNoZXNCdWZmZXIgPSBNYXRoLmZsb29yKG5leHRTdGF0ZS5yZXNvdXJjZXMubGF1bmNoZXM/LmJ1ZmZlciA/PyAwKTtcbiAgICAgIC8vIHBvZHNJbk9yYml0IGlzIGFscmVhZHkgdXBkYXRlZCBpbiBzdGVwU2ltIHdoZW4gbGF1bmNoZXMgYXJlIHByb2R1Y2VkXG4gICAgICBcbiAgICAgIHJldHVybiB7IHNpbVN0YXRlOiBuZXh0U3RhdGUgfTtcbiAgICB9KTtcbiAgfSxcbiAgdXBkYXRlTWFjaGluZUxpbmVzOiAobWFjaGluZUlkLCBsaW5lcykgPT4ge1xuICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgIGlmICghc3RhdGUuc2ltU3RhdGUpIHJldHVybiBzdGF0ZTtcbiAgICAgIGNvbnN0IG1hY2hpbmUgPSBzdGF0ZS5zaW1TdGF0ZS5tYWNoaW5lc1ttYWNoaW5lSWQgYXMga2V5b2YgdHlwZW9mIHN0YXRlLnNpbVN0YXRlLm1hY2hpbmVzXTtcbiAgICAgIGlmICghbWFjaGluZSkgcmV0dXJuIHN0YXRlO1xuICAgICAgXG4gICAgICBjb25zdCBuZXdMaW5lcyA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3IobGluZXMpKTtcbiAgICAgIGNvbnN0IGxpbmVEZWx0YSA9IG5ld0xpbmVzIC0gbWFjaGluZS5saW5lcztcbiAgICAgIFxuICAgICAgLy8gSWYgYWRkaW5nIGxpbmVzLCBjaGVjayBjb25zdHJhaW50c1xuICAgICAgaWYgKGxpbmVEZWx0YSA+IDApIHtcbiAgICAgICAgY29uc3QgeyBjYW5BZGRNYWNoaW5lTGluZSB9ID0gcmVxdWlyZShcIi4uL2xpYi9zaW0vY29uc3RyYWludHNcIik7XG4gICAgICAgIGNvbnN0IGNoZWNrID0gY2FuQWRkTWFjaGluZUxpbmUoc3RhdGUuc2ltU3RhdGUsIG1hY2hpbmVJZCBhcyBhbnksIGxpbmVEZWx0YSk7XG4gICAgICAgIGlmICghY2hlY2suY2FuQWRkKSB7XG4gICAgICAgICAgLy8gU2hvdyB0b2FzdCBlcnJvclxuICAgICAgICAgIGNvbnN0IHsgc2hvd1RvYXN0IH0gPSByZXF1aXJlKFwiLi4vbGliL3V0aWxzL3RvYXN0XCIpO1xuICAgICAgICAgIHNob3dUb2FzdChjaGVjay5yZWFzb24gfHwgXCJDYW5ub3QgYWRkIG1hY2hpbmUgbGluZVwiLCAnZXJyb3InKTtcbiAgICAgICAgICAvLyBSZXR1cm4gc3RhdGUgdW5jaGFuZ2VkXG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBtYWNoaW5lIGxpbmVzXG4gICAgICBjb25zdCB1cGRhdGVkTWFjaGluZSA9IHtcbiAgICAgICAgLi4ubWFjaGluZSxcbiAgICAgICAgbGluZXM6IG5ld0xpbmVzLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gUmVjYWxjdWxhdGUgY29uc3RyYWludHMgdXNhZ2UgZnJvbSBhbGwgbWFjaGluZXNcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0geyAuLi5zdGF0ZS5zaW1TdGF0ZS5jb25zdHJhaW50cyB9O1xuICAgICAgbGV0IHRvdGFsUG93ZXJVc2VkID0gMDtcbiAgICAgIGxldCB0b3RhbENvb2xpbmdVc2VkID0gMDtcbiAgICAgIGxldCB0b3RhbFdvcmtmb3JjZVVzZWQgPSAwO1xuICAgICAgXG4gICAgICBPYmplY3QudmFsdWVzKHN0YXRlLnNpbVN0YXRlLm1hY2hpbmVzKS5mb3JFYWNoKG0gPT4ge1xuICAgICAgICBjb25zdCBsaW5lcyA9IG0uaWQgPT09IG1hY2hpbmVJZCA/IG5ld0xpbmVzIDogbS5saW5lcztcbiAgICAgICAgdG90YWxQb3dlclVzZWQgKz0gKG0ucG93ZXJEcmF3TVcgfHwgMCkgKiBsaW5lcztcbiAgICAgICAgdG90YWxDb29saW5nVXNlZCArPSAobS5oZWF0TVcgfHwgMCkgKiBsaW5lcztcbiAgICAgICAgdG90YWxXb3JrZm9yY2VVc2VkICs9IChtLndvcmtlcnMgfHwgMCkgKiBsaW5lcztcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdHJhaW50cy5wb3dlclVzZWRNVyA9IHRvdGFsUG93ZXJVc2VkO1xuICAgICAgY29uc3RyYWludHMuY29vbGluZ1VzZWRNVyA9IHRvdGFsQ29vbGluZ1VzZWQ7XG4gICAgICBjb25zdHJhaW50cy53b3JrZm9yY2VVc2VkID0gdG90YWxXb3JrZm9yY2VVc2VkO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaW1TdGF0ZToge1xuICAgICAgICAgIC4uLnN0YXRlLnNpbVN0YXRlLFxuICAgICAgICAgIG1hY2hpbmVzOiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5zaW1TdGF0ZS5tYWNoaW5lcyxcbiAgICAgICAgICAgIFttYWNoaW5lSWRdOiB1cGRhdGVkTWFjaGluZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbnN0cmFpbnRzLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9KTtcbiAgfSxcbiAgc2V0VGltZVNjYWxlOiAoc2NhbGUpID0+IHtcbiAgICBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICBpZiAoIXN0YXRlLnNpbVN0YXRlKSByZXR1cm4gc3RhdGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaW1TdGF0ZToge1xuICAgICAgICAgIC4uLnN0YXRlLnNpbVN0YXRlLFxuICAgICAgICAgIHRpbWVTY2FsZTogc2NhbGUsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0pO1xuICB9LFxuICAvLyBEZXBsb3ltZW50IGNvbnRyb2xzXG4gIHNldExhdW5jaFRocmVzaG9sZDogKHRocmVzaG9sZCkgPT4ge1xuICAgIHNldCh7IGxhdW5jaFRocmVzaG9sZDogdGhyZXNob2xkIH0pO1xuICB9LFxuICBwZXJmb3JtTGF1bmNoOiAoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICBpZiAoIXN0YXRlLnNpbVN0YXRlKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiU2ltdWxhdGlvbiBzdGF0ZSBub3QgaW5pdGlhbGl6ZWRcIiB9O1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBwb2RzSW5XYXJlaG91c2UgPSBNYXRoLmZsb29yKHN0YXRlLnNpbVN0YXRlLnJlc291cmNlcy5wb2RzPy5idWZmZXIgfHwgMCk7XG4gICAgY29uc3QgeyBsYXVuY2hUaHJlc2hvbGQsIGZ1ZWxBdmFpbGFibGVMYXVuY2hlcywgbGF1bmNoU2xvdHNUaGlzTW9udGgsIHBvZHNQZXJMYXVuY2hDYXBhY2l0eSB9ID0gc3RhdGU7XG4gICAgXG4gICAgLy8gQ2hlY2sgcmVhZGluZXNzXG4gICAgaWYgKHBvZHNJbldhcmVob3VzZSA8IGxhdW5jaFRocmVzaG9sZCkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIk5lZWQgbW9yZSBwb2RzXCIgfTtcbiAgICB9XG4gICAgaWYgKGZ1ZWxBdmFpbGFibGVMYXVuY2hlcyA8PSAwKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiTm8gZnVlbCBhdmFpbGFibGVcIiB9O1xuICAgIH1cbiAgICBpZiAobGF1bmNoU2xvdHNUaGlzTW9udGggPD0gMCkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIk5vIGxhdW5jaCBzbG90cyByZW1haW5pbmdcIiB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgcG9kcyB0byBsYXVuY2hcbiAgICBjb25zdCBtYXhQb2RzID0gTWF0aC5taW4obGF1bmNoVGhyZXNob2xkLCBwb2RzSW5XYXJlaG91c2UsIHBvZHNQZXJMYXVuY2hDYXBhY2l0eSk7XG4gICAgY29uc3QgcG9kc1RoaXNMYXVuY2ggPSBNYXRoLmZsb29yKG1heFBvZHMpO1xuICAgIFxuICAgIGlmIChwb2RzVGhpc0xhdW5jaCA8PSAwKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiQ2Fubm90IGxhdW5jaCAwIHBvZHNcIiB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBTdG9yZSBtZXRyaWNzIGJlZm9yZSBsYXVuY2hcbiAgICBjb25zdCB7IGNhbGN1bGF0ZURlcGxveW1lbnRNZXRyaWNzIH0gPSByZXF1aXJlKFwiLi4vbGliL2RlcGxveW1lbnQvbWV0cmljc1wiKTtcbiAgICBjb25zdCBtZXRyaWNzQmVmb3JlID0gY2FsY3VsYXRlRGVwbG95bWVudE1ldHJpY3Moc3RhdGUuc2ltU3RhdGUpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgIHNldCgocykgPT4ge1xuICAgICAgaWYgKCFzLnNpbVN0YXRlKSByZXR1cm4gcztcbiAgICAgIFxuICAgICAgY29uc3QgdXBkYXRlZFJlc291cmNlcyA9IHtcbiAgICAgICAgLi4ucy5zaW1TdGF0ZS5yZXNvdXJjZXMsXG4gICAgICAgIHBvZHM6IHtcbiAgICAgICAgICAuLi5zLnNpbVN0YXRlLnJlc291cmNlcy5wb2RzLFxuICAgICAgICAgIGJ1ZmZlcjogTWF0aC5tYXgoMCwgcy5zaW1TdGF0ZS5yZXNvdXJjZXMucG9kcy5idWZmZXIgLSBwb2RzVGhpc0xhdW5jaCksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCB1cGRhdGVkU2ltU3RhdGUgPSB7XG4gICAgICAgIC4uLnMuc2ltU3RhdGUsXG4gICAgICAgIHJlc291cmNlczogdXBkYXRlZFJlc291cmNlcyxcbiAgICAgICAgcG9kc0luT3JiaXQ6IHMuc2ltU3RhdGUucG9kc0luT3JiaXQgKyBwb2RzVGhpc0xhdW5jaCxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBtZXRyaWNzIGFmdGVyIGxhdW5jaFxuICAgICAgY29uc3QgbWV0cmljc0FmdGVyID0gY2FsY3VsYXRlRGVwbG95bWVudE1ldHJpY3ModXBkYXRlZFNpbVN0YXRlKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2ltU3RhdGU6IHVwZGF0ZWRTaW1TdGF0ZSxcbiAgICAgICAgZnVlbEF2YWlsYWJsZUxhdW5jaGVzOiBNYXRoLm1heCgwLCBzLmZ1ZWxBdmFpbGFibGVMYXVuY2hlcyAtIDEpLFxuICAgICAgICBsYXVuY2hTbG90c1RoaXNNb250aDogTWF0aC5tYXgoMCwgcy5sYXVuY2hTbG90c1RoaXNNb250aCAtIDEpLFxuICAgICAgICBsYXN0TGF1bmNoTWV0cmljczoge1xuICAgICAgICAgIGJlZm9yZTogbWV0cmljc0JlZm9yZSxcbiAgICAgICAgICBhZnRlcjogbWV0cmljc0FmdGVyLFxuICAgICAgICAgIHBvZHNMYXVuY2hlZDogcG9kc1RoaXNMYXVuY2gsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHBvZHNMYXVuY2hlZDogcG9kc1RoaXNMYXVuY2ggfTtcbiAgfSxcbiAgc2V0TGF1bmNoUmVsaWFiaWxpdHk6IChyZWxpYWJpbGl0eTogbnVtYmVyKSA9PiB7XG4gICAgc2V0KHsgbGF1bmNoUmVsaWFiaWxpdHk6IE1hdGgubWF4KDAuODAsIE1hdGgubWluKDAuOTk5LCByZWxpYWJpbGl0eSkpIH0pO1xuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnY29udHJvbHMtY2hhbmdlZCcpKTtcbiAgfSxcbiAgc2V0Q29vbGluZ092ZXJoZWFkOiAob3ZlcmhlYWQ6IG51bWJlcikgPT4ge1xuICAgIHNldCh7IGNvb2xpbmdPdmVyaGVhZDogTWF0aC5tYXgoMC4xMCwgTWF0aC5taW4oMC41MCwgb3ZlcmhlYWQpKSB9KTtcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2NvbnRyb2xzLWNoYW5nZWQnKSk7XG4gIH0sXG4gIHNldEdyb3VuZEVuZXJneVByaWNlOiAocHJpY2U6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgaWYgKHN0YXRlLnNpbVN0YXRlKSB7XG4gICAgICBzdGF0ZS5zaW1TdGF0ZS5ncm91bmREY1NwZWMuZW5lcmd5UHJpY2VQZXJNd2ggPSBNYXRoLm1heCgzMCwgTWF0aC5taW4oMTAwLCBwcmljZSkpO1xuICAgICAgc2V0KHsgc2ltU3RhdGU6IHsgLi4uc3RhdGUuc2ltU3RhdGUgfSB9KTtcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnY29udHJvbHMtY2hhbmdlZCcpKTtcbiAgICB9XG4gIH0sXG4gIHNldExhdW5jaENhcGFjaXR5OiAoY2FwYWNpdHk6IG51bWJlcikgPT4ge1xuICAgIHNldCh7IGxhdW5jaFNsb3RzVGhpc01vbnRoOiBNYXRoLm1heCgxLCBNYXRoLm1pbig0MCwgTWF0aC5mbG9vcihjYXBhY2l0eSkpKSB9KTtcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2NvbnRyb2xzLWNoYW5nZWQnKSk7XG4gIH0sXG59KSk7XG5cblxuIl0sIm5hbWVzIjpbImNyZWF0ZSIsImNyZWF0ZURlZmF1bHRGYWN0b3J5U3RhdGUiLCJydW5GYWN0b3J5VGljayIsInJ1bkZhY3RvcnlUaWNrRW5naW5lIiwiY29tcHV0ZUJvdHRsZW5lY2tzIiwiY3JlYXRlRGVmYXVsdExhdW5jaFN0YXRlIiwicHJvY2Vzc0xhdW5jaFF1ZXVlIiwiY3JlYXRlSW5pdGlhbFNpbVN0YXRlIiwic3RlcFNpbSIsInVzZVNhbmRib3hTdG9yZSIsInNldCIsImdldCIsIm9yYml0YWxDb21wdXRlVW5pdHMiLCJncm91bmREQ1JlZHVjdGlvbiIsImlzTW9zdGx5U3BhY2VNb2RlIiwiY3VycmVudFByZXNldCIsInNhbmRib3hNb2RlIiwiYWN0aXZlTWlzc2lvbklkIiwibWlzc2lvblByb2dyZXNzIiwidW5sb2NrZWRNaXNzaW9ucyIsImNvbXBsZXRlZE1pc3Npb25zIiwidW5sb2NrZWRVbml0cyIsImlzVHV0b3JpYWxBY3RpdmUiLCJ0dXRvcmlhbFN0ZXAiLCJpc0NvbXBsZXRlZCIsInR1dG9yaWFsT3JiaXRTaGFyZVRhcmdldCIsInVubG9ja2VkT3JiaXRNb2RlcyIsInVubG9ja2VkTGF1bmNoUHJvdmlkZXJzIiwibWlzc2lvblN0YXJ0VGltZSIsIm1pc3Npb25UaW1lTGltaXQiLCJzZWxlY3RlZFBvZFRpZXIiLCJvcmJpdE1vZGUiLCJhY3RpdmVMYXVuY2hQcm92aWRlcnMiLCJvZmZsb2FkUGN0IiwiZGVuc2l0eU1vZGUiLCJ0b3RhbFBvZHNCdWlsdCIsImZhY3RvcnkiLCJmYWN0b3J5Qm90dGxlbmVja3MiLCJsYXVuY2hTdGF0ZSIsInNpbVN0YXRlIiwibGF1bmNoVGhyZXNob2xkIiwiZnVlbEF2YWlsYWJsZUxhdW5jaGVzIiwibGF1bmNoU2xvdHNUaGlzTW9udGgiLCJwb2RzUGVyTGF1bmNoQ2FwYWNpdHkiLCJsYXVuY2hSZWxpYWJpbGl0eSIsImNvb2xpbmdPdmVyaGVhZCIsImxhc3RMYXVuY2hNZXRyaWNzIiwic2V0T3JiaXRhbENvbXB1dGVVbml0cyIsInVuaXRzIiwib3JiaXRTaGFyZSIsImFkZE9yYml0YWxDb21wdXRlIiwic3RhdGUiLCJuZXdVbml0cyIsInNldEdyb3VuZERDUmVkdWN0aW9uIiwicGVyY2VudCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJ0b3RhbENvbXB1dGUiLCJjdXJyZW50T3JiaXRTaGFyZSIsInRhcmdldE9yYml0U2hhcmUiLCJwcm9ncmVzcyIsInNldFByZXNldCIsInByZXNldCIsInNldFNhbmRib3hNb2RlIiwibW9kZSIsInNldEFjdGl2ZU1pc3Npb24iLCJtaXNzaW9uSWQiLCJ0aGVuIiwibWlzc2lvbnNNb2R1bGUiLCJtaXNzaW9uIiwiZ2V0TWlzc2lvbkJ5SWQiLCJzdGFydGluZ1N0YXRlIiwicmVzZXQiLCJyZXF1aXJlIiwidXNlT3JiaXRhbFVuaXRzU3RvcmUiLCJnZXRTdGF0ZSIsIm9yYml0QmFuZCIsImxhdW5jaFByb3ZpZGVyIiwiRGF0ZSIsIm5vdyIsInNldE1pc3Npb25Qcm9ncmVzcyIsIm5ld1Byb2dyZXNzIiwiaW5jbHVkZXMiLCJzIiwidW5sb2NrVW5pdCIsInVuaXRUeXBlIiwidW5sb2NrTWlzc2lvbiIsIm1hcmtNaXNzaW9uQ29tcGxldGVkIiwibmV3Q29tcGxldGVkIiwibmV3VW5sb2NrZWRNaXNzaW9ucyIsIm5ld1VubG9ja2VkT3JiaXRNb2RlcyIsIm5ld1VubG9ja2VkTGF1bmNoUHJvdmlkZXJzIiwicmV3YXJkcyIsImZvckVhY2giLCJyZXdhcmQiLCJ0eXBlIiwidmFsdWUiLCJwdXNoIiwic3RhcnRUdXRvcmlhbCIsIm5leHRUdXRvcmlhbFN0ZXAiLCJuZXh0IiwiY29tcGxldGVUdXRvcmlhbCIsInNldFR1dG9yaWFsT3JiaXRTaGFyZVRhcmdldCIsInRhcmdldCIsInNldE9yYml0U2hhcmUiLCJ0YXJnZXRTaGFyZSIsInRhcmdldENvbXB1dGVLdyIsInBvZENvbXB1dGVLdyIsIm9yYml0YWxQb2RTcGVjIiwiY29tcHV0ZUt3IiwidGFyZ2V0UG9kcyIsInJvdW5kIiwicG9kc0luT3JiaXQiLCJyZXNldFNhbmRib3giLCJkZWZhdWx0VW5sb2NrZWQiLCJzZXRTZWxlY3RlZFBvZFRpZXIiLCJ0aWVyIiwic2V0T3JiaXRNb2RlIiwic2V0QWN0aXZlTGF1bmNoUHJvdmlkZXJzIiwicHJvdmlkZXJzIiwidG9nZ2xlTGF1bmNoUHJvdmlkZXJPbGQiLCJwcm92aWRlciIsImN1cnJlbnQiLCJsZW5ndGgiLCJmaWx0ZXIiLCJwIiwic2V0T2ZmbG9hZFBjdCIsInBjdCIsInNldERlbnNpdHlNb2RlIiwiaW5jcmVtZW50VG90YWxQb2RzQnVpbHQiLCJtb250aEZyYWN0aW9uIiwidXBkYXRlZEZhY3RvcnkiLCJwb2RzQXZhaWxhYmxlIiwiaW52ZW50b3J5IiwicG9kcyIsImZ1ZWxBdmFpbGFibGUiLCJmdWVsIiwiY3VycmVudExhdW5jaFN0YXRlIiwibmV3U3RhdGUiLCJ1cGRhdGVkTGF1bmNoU3RhdGUiLCJwb2RzTGF1bmNoZWQiLCJvcmJpdFBvZHMiLCJmbG9vciIsImJvdHRsZW5lY2tzIiwidXBkYXRlRmFjdG9yeUxpbmVzIiwibm9kZUlkIiwibmV3TGluZXMiLCJjdXJyZW50U3RhdGUiLCJyZWNpcGVOb2RlSWQiLCJjdXJyZW50TGluZXMiLCJsaW5lcyIsImRlbHRhIiwibmV3VXNlZEluZnJhIiwidXNlZEluZnJhUG9pbnRzIiwibWF4SW5mcmFQb2ludHMiLCJ1cGRhdGVkTGluZXMiLCJ0b2dnbGVMYXVuY2hQcm92aWRlciIsInByb3ZpZGVySWQiLCJlbmFibGVkIiwic3RlcFNpbXVsYXRpb24iLCJkdE1pbnV0ZXMiLCJuZXh0U3RhdGUiLCJsYXVuY2hlc0J1ZmZlciIsInJlc291cmNlcyIsImxhdW5jaGVzIiwiYnVmZmVyIiwidXBkYXRlTWFjaGluZUxpbmVzIiwibWFjaGluZUlkIiwibWFjaGluZSIsIm1hY2hpbmVzIiwibGluZURlbHRhIiwiY2FuQWRkTWFjaGluZUxpbmUiLCJjaGVjayIsImNhbkFkZCIsInNob3dUb2FzdCIsInJlYXNvbiIsInVwZGF0ZWRNYWNoaW5lIiwiY29uc3RyYWludHMiLCJ0b3RhbFBvd2VyVXNlZCIsInRvdGFsQ29vbGluZ1VzZWQiLCJ0b3RhbFdvcmtmb3JjZVVzZWQiLCJPYmplY3QiLCJ2YWx1ZXMiLCJtIiwiaWQiLCJwb3dlckRyYXdNVyIsImhlYXRNVyIsIndvcmtlcnMiLCJwb3dlclVzZWRNVyIsImNvb2xpbmdVc2VkTVciLCJ3b3JrZm9yY2VVc2VkIiwic2V0VGltZVNjYWxlIiwic2NhbGUiLCJ0aW1lU2NhbGUiLCJzZXRMYXVuY2hUaHJlc2hvbGQiLCJ0aHJlc2hvbGQiLCJwZXJmb3JtTGF1bmNoIiwic3VjY2VzcyIsImVycm9yIiwicG9kc0luV2FyZWhvdXNlIiwibWF4UG9kcyIsInBvZHNUaGlzTGF1bmNoIiwiY2FsY3VsYXRlRGVwbG95bWVudE1ldHJpY3MiLCJtZXRyaWNzQmVmb3JlIiwidXBkYXRlZFJlc291cmNlcyIsInVwZGF0ZWRTaW1TdGF0ZSIsIm1ldHJpY3NBZnRlciIsImJlZm9yZSIsImFmdGVyIiwic2V0TGF1bmNoUmVsaWFiaWxpdHkiLCJyZWxpYWJpbGl0eSIsIndpbmRvdyIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsInNldENvb2xpbmdPdmVyaGVhZCIsIm92ZXJoZWFkIiwic2V0R3JvdW5kRW5lcmd5UHJpY2UiLCJwcmljZSIsImdyb3VuZERjU3BlYyIsImVuZXJneVByaWNlUGVyTXdoIiwic2V0TGF1bmNoQ2FwYWNpdHkiLCJjYXBhY2l0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/store/sandboxStore.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/store/simStore.ts":
/*!*******************************!*\
  !*** ./app/store/simStore.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSimStore: function() { return /* binding */ useSimStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n\nconst useSimStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)((set)=>({\n        state: null,\n        loading: false,\n        error: null,\n        selectedEntity: null,\n        scenario: \"normal\",\n        orbitOffloadPercent: 30,\n        performanceMode: true,\n        setState: (state)=>set({\n                state\n            }),\n        setLoading: (loading)=>set({\n                loading\n            }),\n        setError: (error)=>set({\n                error\n            }),\n        setSelectedEntity: (entity)=>set({\n                selectedEntity: entity\n            }),\n        setScenario: (scenario)=>set({\n                scenario\n            }),\n        setOrbitOffloadPercent: (percent)=>set({\n                orbitOffloadPercent: percent\n            }),\n        setPerformanceMode: (enabled)=>set({\n                performanceMode: enabled\n            })\n    }));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zdG9yZS9zaW1TdG9yZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpQztBQTJFMUIsTUFBTUMsY0FBY0QsK0NBQU1BLENBQVcsQ0FBQ0UsTUFBUztRQUNwREMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLE9BQU87UUFDUEMsZ0JBQWdCO1FBQ2hCQyxVQUFVO1FBQ1ZDLHFCQUFxQjtRQUNyQkMsaUJBQWlCO1FBQ2pCQyxVQUFVLENBQUNQLFFBQVVELElBQUk7Z0JBQUVDO1lBQU07UUFDakNRLFlBQVksQ0FBQ1AsVUFBWUYsSUFBSTtnQkFBRUU7WUFBUTtRQUN2Q1EsVUFBVSxDQUFDUCxRQUFVSCxJQUFJO2dCQUFFRztZQUFNO1FBQ2pDUSxtQkFBbUIsQ0FBQ0MsU0FBV1osSUFBSTtnQkFBRUksZ0JBQWdCUTtZQUFPO1FBQzVEQyxhQUFhLENBQUNSLFdBQWFMLElBQUk7Z0JBQUVLO1lBQVM7UUFDMUNTLHdCQUF3QixDQUFDQyxVQUFZZixJQUFJO2dCQUFFTSxxQkFBcUJTO1lBQVE7UUFDeEVDLG9CQUFvQixDQUFDQyxVQUFZakIsSUFBSTtnQkFBRU8saUJBQWlCVTtZQUFRO0lBQ2xFLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL3N0b3JlL3NpbVN0b3JlLnRzPzNlM2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSBcInp1c3RhbmRcIjtcblxuLy8gVHlwZXMgbWF0Y2hpbmcgdGhlIG5ldyBTaW1TdGF0ZSBjb250cmFjdFxuZXhwb3J0IHR5cGUgU2F0ZWxsaXRlID0ge1xuICBpZDogc3RyaW5nO1xuICBsYXQ6IG51bWJlcjtcbiAgbG9uOiBudW1iZXI7XG4gIGFsdF9rbTogbnVtYmVyO1xuICBzdW5saXQ6IGJvb2xlYW47XG4gIHV0aWxpemF0aW9uOiBudW1iZXI7IC8vIDDigJMxIGNvbXB1dGUgYXZhaWxhYmlsaXR5XG4gIGNhcGFjaXR5TXc6IG51bWJlcjtcbiAgbmVhcmVzdEdhdGV3YXlJZDogc3RyaW5nO1xuICBsYXRlbmN5TXM6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIEdyb3VuZFNpdGUgPSB7XG4gIGlkOiBzdHJpbmc7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIGxhdDogbnVtYmVyO1xuICBsb246IG51bWJlcjtcbiAgcG93ZXJNdzogbnVtYmVyO1xuICBjb29saW5nTXc6IG51bWJlcjtcbiAgam9ic1J1bm5pbmc6IG51bWJlcjtcbiAgY2FyYm9uSW50ZW5zaXR5OiBudW1iZXI7IC8vIGtnQ08yL01XaFxuICBlbmVyZ3lQcmljZTogbnVtYmVyOyAvLyAkL01XaFxuICB0eXBlPzogXCJkYXRhX2NlbnRlclwiIHwgXCJsYXVuY2hfc2l0ZVwiOyAvLyBUeXBlIG9mIGdyb3VuZCBzaXRlXG59O1xuXG5leHBvcnQgdHlwZSBXb3JrbG9hZCA9IHtcbiAgam9ic1BlbmRpbmc6IG51bWJlcjtcbiAgam9ic1J1bm5pbmdPcmJpdDogbnVtYmVyO1xuICBqb2JzUnVubmluZ0dyb3VuZDogbnVtYmVyO1xuICBqb2JzQ29tcGxldGVkOiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBNZXRyaWNzID0ge1xuICB0b3RhbEdyb3VuZFBvd2VyTXc6IG51bWJlcjtcbiAgdG90YWxPcmJpdGFsUG93ZXJNdzogbnVtYmVyO1xuICBhdmdMYXRlbmN5TXM6IG51bWJlcjtcbiAgb3JiaXRTaGFyZVBlcmNlbnQ6IG51bWJlcjtcbiAgdG90YWxKb2JzUnVubmluZzogbnVtYmVyO1xuICBlbmVyZ3lDb3N0R3JvdW5kOiBudW1iZXI7XG4gIGVuZXJneUNvc3RPcmJpdDogbnVtYmVyO1xuICBjYXJib25Hcm91bmQ6IG51bWJlcjtcbiAgY2FyYm9uT3JiaXQ6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIFNpbVN0YXRlID0ge1xuICB0aW1lOiBzdHJpbmc7XG4gIHNhdGVsbGl0ZXM6IFNhdGVsbGl0ZVtdO1xuICBncm91bmRTaXRlczogR3JvdW5kU2l0ZVtdO1xuICB3b3JrbG9hZDogV29ya2xvYWQ7XG4gIG1ldHJpY3M6IE1ldHJpY3M7XG4gIGV2ZW50czogc3RyaW5nW107IC8vIGNvbW1lbnRhcnkgc3RyaW5nc1xufTtcblxuZXhwb3J0IHR5cGUgU2NlbmFyaW8gPSBcIm5vcm1hbFwiIHwgXCJwcmljZV9zcGlrZVwiIHwgXCJzb2xhcl9zdG9ybVwiIHwgXCJmaWJlcl9jdXRcIjtcblxuaW50ZXJmYWNlIFNpbVN0b3JlIHtcbiAgc3RhdGU6IFNpbVN0YXRlIHwgbnVsbDtcbiAgbG9hZGluZzogYm9vbGVhbjtcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XG4gIHNlbGVjdGVkRW50aXR5OiB7IHR5cGU6IFwic2F0ZWxsaXRlXCIgfCBcImdyb3VuZFwiOyBpZDogc3RyaW5nIH0gfCBudWxsO1xuICBzY2VuYXJpbzogU2NlbmFyaW87XG4gIG9yYml0T2ZmbG9hZFBlcmNlbnQ6IG51bWJlcjsgLy8gMC0xMDBcbiAgcGVyZm9ybWFuY2VNb2RlOiBib29sZWFuOyAvLyBJZiB0cnVlLCBsaW1pdCBkaXNwbGF5ZWQgc2F0ZWxsaXRlcyBmb3IgcGVyZm9ybWFuY2VcbiAgc2V0U3RhdGU6IChzdGF0ZTogU2ltU3RhdGUpID0+IHZvaWQ7XG4gIHNldExvYWRpbmc6IChsb2FkaW5nOiBib29sZWFuKSA9PiB2b2lkO1xuICBzZXRFcnJvcjogKGVycm9yOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xuICBzZXRTZWxlY3RlZEVudGl0eTogKGVudGl0eTogeyB0eXBlOiBcInNhdGVsbGl0ZVwiIHwgXCJncm91bmRcIjsgaWQ6IHN0cmluZyB9IHwgbnVsbCkgPT4gdm9pZDtcbiAgc2V0U2NlbmFyaW86IChzY2VuYXJpbzogU2NlbmFyaW8pID0+IHZvaWQ7XG4gIHNldE9yYml0T2ZmbG9hZFBlcmNlbnQ6IChwZXJjZW50OiBudW1iZXIpID0+IHZvaWQ7XG4gIHNldFBlcmZvcm1hbmNlTW9kZTogKGVuYWJsZWQ6IGJvb2xlYW4pID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCB1c2VTaW1TdG9yZSA9IGNyZWF0ZTxTaW1TdG9yZT4oKHNldCkgPT4gKHtcbiAgc3RhdGU6IG51bGwsXG4gIGxvYWRpbmc6IGZhbHNlLCAvLyBTdGFydCBhcyBmYWxzZSAtIG5ldyBPcmJpdFNpbSBkb2Vzbid0IG5lZWQgYmFja2VuZFxuICBlcnJvcjogbnVsbCxcbiAgc2VsZWN0ZWRFbnRpdHk6IG51bGwsXG4gIHNjZW5hcmlvOiBcIm5vcm1hbFwiLFxuICBvcmJpdE9mZmxvYWRQZXJjZW50OiAzMCxcbiAgcGVyZm9ybWFuY2VNb2RlOiB0cnVlLCAvLyBEZWZhdWx0IHRvIHBlcmZvcm1hbmNlIG1vZGUgKGxpbWl0IHRvIDUwMCBzYXRlbGxpdGVzKVxuICBzZXRTdGF0ZTogKHN0YXRlKSA9PiBzZXQoeyBzdGF0ZSB9KSxcbiAgc2V0TG9hZGluZzogKGxvYWRpbmcpID0+IHNldCh7IGxvYWRpbmcgfSksXG4gIHNldEVycm9yOiAoZXJyb3IpID0+IHNldCh7IGVycm9yIH0pLFxuICBzZXRTZWxlY3RlZEVudGl0eTogKGVudGl0eSkgPT4gc2V0KHsgc2VsZWN0ZWRFbnRpdHk6IGVudGl0eSB9KSxcbiAgc2V0U2NlbmFyaW86IChzY2VuYXJpbykgPT4gc2V0KHsgc2NlbmFyaW8gfSksXG4gIHNldE9yYml0T2ZmbG9hZFBlcmNlbnQ6IChwZXJjZW50KSA9PiBzZXQoeyBvcmJpdE9mZmxvYWRQZXJjZW50OiBwZXJjZW50IH0pLFxuICBzZXRQZXJmb3JtYW5jZU1vZGU6IChlbmFibGVkKSA9PiBzZXQoeyBwZXJmb3JtYW5jZU1vZGU6IGVuYWJsZWQgfSksXG59KSk7XG5cbiJdLCJuYW1lcyI6WyJjcmVhdGUiLCJ1c2VTaW1TdG9yZSIsInNldCIsInN0YXRlIiwibG9hZGluZyIsImVycm9yIiwic2VsZWN0ZWRFbnRpdHkiLCJzY2VuYXJpbyIsIm9yYml0T2ZmbG9hZFBlcmNlbnQiLCJwZXJmb3JtYW5jZU1vZGUiLCJzZXRTdGF0ZSIsInNldExvYWRpbmciLCJzZXRFcnJvciIsInNldFNlbGVjdGVkRW50aXR5IiwiZW50aXR5Iiwic2V0U2NlbmFyaW8iLCJzZXRPcmJpdE9mZmxvYWRQZXJjZW50IiwicGVyY2VudCIsInNldFBlcmZvcm1hbmNlTW9kZSIsImVuYWJsZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/store/simStore.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement$1(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement$1(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (hasOwnProperty.call(props, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(props).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV = jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FB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bW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz84ODEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBSRUFDVF9DQUNIRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY2FjaGUnKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cbnZhciBlbmFibGVDYWNoZUVsZW1lbnQgPSBmYWxzZTtcbnZhciBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyA9IGZhbHNlOyAvLyBObyBrbm93biBidWdzLCBidXQgbmVlZHMgcGVyZm9ybWFuY2UgdGVzdGluZ1xuXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXG5cbnZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTsgLy8gVHJhY2sgd2hpY2ggRmliZXIocykgc2NoZWR1bGUgcmVuZGVyIHdvcmsuXG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gICAgY2FzZSBSRUFDVF9DQUNIRV9UWVBFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gJ0NhY2hlJztcbiAgICAgIH1cblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/MzIyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/zustand/esm/react.mjs":
/*!********************************************!*\
  !*** ./node_modules/zustand/esm/react.mjs ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: function() { return /* binding */ create; },\n/* harmony export */   useStore: function() { return /* binding */ useStore; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var zustand_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand/vanilla */ \"(app-pages-browser)/./node_modules/zustand/esm/vanilla.mjs\");\n\n\n\nconst identity = (arg) => arg;\nfunction useStore(api, selector = identity) {\n  const slice = react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore(\n    api.subscribe,\n    react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => selector(api.getState()), [api, selector]),\n    react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => selector(api.getInitialState()), [api, selector])\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue(slice);\n  return slice;\n}\nconst createImpl = (createState) => {\n  const api = (0,zustand_vanilla__WEBPACK_IMPORTED_MODULE_1__.createStore)(createState);\n  const useBoundStore = (selector) => useStore(api, selector);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nconst create = ((createState) => createState ? createImpl(createState) : createImpl);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS9yZWFjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUEwQjtBQUNvQjs7QUFFOUM7QUFDQTtBQUNBLGdCQUFnQix1REFBMEI7QUFDMUM7QUFDQSxJQUFJLDhDQUFpQjtBQUNyQixJQUFJLDhDQUFpQjtBQUNyQjtBQUNBLEVBQUUsZ0RBQW1CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNERBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3p1c3RhbmQvZXNtL3JlYWN0Lm1qcz85MDUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVTdG9yZSB9IGZyb20gJ3p1c3RhbmQvdmFuaWxsYSc7XG5cbmNvbnN0IGlkZW50aXR5ID0gKGFyZykgPT4gYXJnO1xuZnVuY3Rpb24gdXNlU3RvcmUoYXBpLCBzZWxlY3RvciA9IGlkZW50aXR5KSB7XG4gIGNvbnN0IHNsaWNlID0gUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgYXBpLnN1YnNjcmliZSxcbiAgICBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiBzZWxlY3RvcihhcGkuZ2V0U3RhdGUoKSksIFthcGksIHNlbGVjdG9yXSksXG4gICAgUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4gc2VsZWN0b3IoYXBpLmdldEluaXRpYWxTdGF0ZSgpKSwgW2FwaSwgc2VsZWN0b3JdKVxuICApO1xuICBSZWFjdC51c2VEZWJ1Z1ZhbHVlKHNsaWNlKTtcbiAgcmV0dXJuIHNsaWNlO1xufVxuY29uc3QgY3JlYXRlSW1wbCA9IChjcmVhdGVTdGF0ZSkgPT4ge1xuICBjb25zdCBhcGkgPSBjcmVhdGVTdG9yZShjcmVhdGVTdGF0ZSk7XG4gIGNvbnN0IHVzZUJvdW5kU3RvcmUgPSAoc2VsZWN0b3IpID0+IHVzZVN0b3JlKGFwaSwgc2VsZWN0b3IpO1xuICBPYmplY3QuYXNzaWduKHVzZUJvdW5kU3RvcmUsIGFwaSk7XG4gIHJldHVybiB1c2VCb3VuZFN0b3JlO1xufTtcbmNvbnN0IGNyZWF0ZSA9ICgoY3JlYXRlU3RhdGUpID0+IGNyZWF0ZVN0YXRlID8gY3JlYXRlSW1wbChjcmVhdGVTdGF0ZSkgOiBjcmVhdGVJbXBsKTtcblxuZXhwb3J0IHsgY3JlYXRlLCB1c2VTdG9yZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/zustand/esm/react.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/zustand/esm/vanilla.mjs":
/*!**********************************************!*\
  !*** ./node_modules/zustand/esm/vanilla.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStore: function() { return /* binding */ createStore; }\n/* harmony export */ });\nconst createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const api = { setState, getState, getInitialState, subscribe };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = ((createState) => createState ? createStoreImpl(createState) : createStoreImpl);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS92YW5pbGxhLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SEFBOEg7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUV1QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vdmFuaWxsYS5tanM/Mzk4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjcmVhdGVTdG9yZUltcGwgPSAoY3JlYXRlU3RhdGUpID0+IHtcbiAgbGV0IHN0YXRlO1xuICBjb25zdCBsaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBzZXRTdGF0ZSA9IChwYXJ0aWFsLCByZXBsYWNlKSA9PiB7XG4gICAgY29uc3QgbmV4dFN0YXRlID0gdHlwZW9mIHBhcnRpYWwgPT09IFwiZnVuY3Rpb25cIiA/IHBhcnRpYWwoc3RhdGUpIDogcGFydGlhbDtcbiAgICBpZiAoIU9iamVjdC5pcyhuZXh0U3RhdGUsIHN0YXRlKSkge1xuICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHN0YXRlO1xuICAgICAgc3RhdGUgPSAocmVwbGFjZSAhPSBudWxsID8gcmVwbGFjZSA6IHR5cGVvZiBuZXh0U3RhdGUgIT09IFwib2JqZWN0XCIgfHwgbmV4dFN0YXRlID09PSBudWxsKSA/IG5leHRTdGF0ZSA6IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCBuZXh0U3RhdGUpO1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihzdGF0ZSwgcHJldmlvdXNTdGF0ZSkpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZ2V0U3RhdGUgPSAoKSA9PiBzdGF0ZTtcbiAgY29uc3QgZ2V0SW5pdGlhbFN0YXRlID0gKCkgPT4gaW5pdGlhbFN0YXRlO1xuICBjb25zdCBzdWJzY3JpYmUgPSAobGlzdGVuZXIpID0+IHtcbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gIH07XG4gIGNvbnN0IGFwaSA9IHsgc2V0U3RhdGUsIGdldFN0YXRlLCBnZXRJbml0aWFsU3RhdGUsIHN1YnNjcmliZSB9O1xuICBjb25zdCBpbml0aWFsU3RhdGUgPSBzdGF0ZSA9IGNyZWF0ZVN0YXRlKHNldFN0YXRlLCBnZXRTdGF0ZSwgYXBpKTtcbiAgcmV0dXJuIGFwaTtcbn07XG5jb25zdCBjcmVhdGVTdG9yZSA9ICgoY3JlYXRlU3RhdGUpID0+IGNyZWF0ZVN0YXRlID8gY3JlYXRlU3RvcmVJbXBsKGNyZWF0ZVN0YXRlKSA6IGNyZWF0ZVN0b3JlSW1wbCk7XG5cbmV4cG9ydCB7IGNyZWF0ZVN0b3JlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/zustand/esm/vanilla.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fpranav%2FCoding_Projects%2FCursor%2Forbitalcompute%2Ffrontend%2Fapp%2Fcomponents%2FSimPollingProvider.tsx&modules=%2FUsers%2Fpranav%2FCoding_Projects%2FCursor%2Forbitalcompute%2Ffrontend%2Fapp%2Fglobals.css&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);